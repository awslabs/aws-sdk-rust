// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The tags for the resource. The metadata that you apply to a resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Tag {
    /// <p>One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag).
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// See [`Tag`](crate::model::Tag).
pub mod tag {

    /// A builder for [`Tag`](crate::model::Tag).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag).
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}

/// When writing a match expression against `EvaluationMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let evaluationmode = unimplemented!();
/// match evaluationmode {
///     EvaluationMode::Detective => { /* ... */ },
///     EvaluationMode::Proactive => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `evaluationmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EvaluationMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EvaluationMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EvaluationMode::NewFeature` is defined.
/// Specifically, when `evaluationmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EvaluationMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EvaluationMode {
    #[allow(missing_docs)] // documentation missing in model
    Detective,
    #[allow(missing_docs)] // documentation missing in model
    Proactive,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EvaluationMode {
    fn from(s: &str) -> Self {
        match s {
            "DETECTIVE" => EvaluationMode::Detective,
            "PROACTIVE" => EvaluationMode::Proactive,
            other => EvaluationMode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EvaluationMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EvaluationMode::from(s))
    }
}
impl EvaluationMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EvaluationMode::Detective => "DETECTIVE",
            EvaluationMode::Proactive => "PROACTIVE",
            EvaluationMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DETECTIVE", "PROACTIVE"]
    }
}
impl AsRef<str> for EvaluationMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Use EvaluationContext to group independently initiated proactive resource evaluations. For example, CFN Stack. If you want to check just a resource definition, you do not need to provide evaluation context.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EvaluationContext {
    /// <p>A unique EvaluationContextIdentifier ID for an EvaluationContext.</p>
    #[doc(hidden)]
    pub evaluation_context_identifier: std::option::Option<std::string::String>,
}
impl EvaluationContext {
    /// <p>A unique EvaluationContextIdentifier ID for an EvaluationContext.</p>
    pub fn evaluation_context_identifier(&self) -> std::option::Option<&str> {
        self.evaluation_context_identifier.as_deref()
    }
}
impl EvaluationContext {
    /// Creates a new builder-style object to manufacture [`EvaluationContext`](crate::model::EvaluationContext).
    pub fn builder() -> crate::model::evaluation_context::Builder {
        crate::model::evaluation_context::Builder::default()
    }
}

/// See [`EvaluationContext`](crate::model::EvaluationContext).
pub mod evaluation_context {

    /// A builder for [`EvaluationContext`](crate::model::EvaluationContext).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) evaluation_context_identifier: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique EvaluationContextIdentifier ID for an EvaluationContext.</p>
        pub fn evaluation_context_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.evaluation_context_identifier = Some(input.into());
            self
        }
        /// <p>A unique EvaluationContextIdentifier ID for an EvaluationContext.</p>
        pub fn set_evaluation_context_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.evaluation_context_identifier = input;
            self
        }
        /// Consumes the builder and constructs a [`EvaluationContext`](crate::model::EvaluationContext).
        pub fn build(self) -> crate::model::EvaluationContext {
            crate::model::EvaluationContext {
                evaluation_context_identifier: self.evaluation_context_identifier,
            }
        }
    }
}

/// <p>Returns information about the resource being evaluated. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceDetails {
    /// <p>A unique resource ID for an evaluation.</p>
    #[doc(hidden)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The type of resource being evaluated.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The resource definition to be evaluated as per the resource configuration schema type.</p>
    #[doc(hidden)]
    pub resource_configuration: std::option::Option<std::string::String>,
    /// <p>The schema type of the resource configuration.</p>
    #[doc(hidden)]
    pub resource_configuration_schema_type:
        std::option::Option<crate::model::ResourceConfigurationSchemaType>,
}
impl ResourceDetails {
    /// <p>A unique resource ID for an evaluation.</p>
    pub fn resource_id(&self) -> std::option::Option<&str> {
        self.resource_id.as_deref()
    }
    /// <p>The type of resource being evaluated.</p>
    pub fn resource_type(&self) -> std::option::Option<&str> {
        self.resource_type.as_deref()
    }
    /// <p>The resource definition to be evaluated as per the resource configuration schema type.</p>
    pub fn resource_configuration(&self) -> std::option::Option<&str> {
        self.resource_configuration.as_deref()
    }
    /// <p>The schema type of the resource configuration.</p>
    pub fn resource_configuration_schema_type(
        &self,
    ) -> std::option::Option<&crate::model::ResourceConfigurationSchemaType> {
        self.resource_configuration_schema_type.as_ref()
    }
}
impl ResourceDetails {
    /// Creates a new builder-style object to manufacture [`ResourceDetails`](crate::model::ResourceDetails).
    pub fn builder() -> crate::model::resource_details::Builder {
        crate::model::resource_details::Builder::default()
    }
}

/// See [`ResourceDetails`](crate::model::ResourceDetails).
pub mod resource_details {

    /// A builder for [`ResourceDetails`](crate::model::ResourceDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) resource_configuration: std::option::Option<std::string::String>,
        pub(crate) resource_configuration_schema_type:
            std::option::Option<crate::model::ResourceConfigurationSchemaType>,
    }
    impl Builder {
        /// <p>A unique resource ID for an evaluation.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>A unique resource ID for an evaluation.</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The type of resource being evaluated.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The type of resource being evaluated.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The resource definition to be evaluated as per the resource configuration schema type.</p>
        pub fn resource_configuration(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_configuration = Some(input.into());
            self
        }
        /// <p>The resource definition to be evaluated as per the resource configuration schema type.</p>
        pub fn set_resource_configuration(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_configuration = input;
            self
        }
        /// <p>The schema type of the resource configuration.</p>
        pub fn resource_configuration_schema_type(
            mut self,
            input: crate::model::ResourceConfigurationSchemaType,
        ) -> Self {
            self.resource_configuration_schema_type = Some(input);
            self
        }
        /// <p>The schema type of the resource configuration.</p>
        pub fn set_resource_configuration_schema_type(
            mut self,
            input: std::option::Option<crate::model::ResourceConfigurationSchemaType>,
        ) -> Self {
            self.resource_configuration_schema_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceDetails`](crate::model::ResourceDetails).
        pub fn build(self) -> crate::model::ResourceDetails {
            crate::model::ResourceDetails {
                resource_id: self.resource_id,
                resource_type: self.resource_type,
                resource_configuration: self.resource_configuration,
                resource_configuration_schema_type: self.resource_configuration_schema_type,
            }
        }
    }
}

/// When writing a match expression against `ResourceConfigurationSchemaType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourceconfigurationschematype = unimplemented!();
/// match resourceconfigurationschematype {
///     ResourceConfigurationSchemaType::CfnResourceSchema => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourceconfigurationschematype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceConfigurationSchemaType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceConfigurationSchemaType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceConfigurationSchemaType::NewFeature` is defined.
/// Specifically, when `resourceconfigurationschematype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceConfigurationSchemaType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceConfigurationSchemaType {
    #[allow(missing_docs)] // documentation missing in model
    CfnResourceSchema,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceConfigurationSchemaType {
    fn from(s: &str) -> Self {
        match s {
            "CFN_RESOURCE_SCHEMA" => ResourceConfigurationSchemaType::CfnResourceSchema,
            other => ResourceConfigurationSchemaType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ResourceConfigurationSchemaType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceConfigurationSchemaType::from(s))
    }
}
impl ResourceConfigurationSchemaType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceConfigurationSchemaType::CfnResourceSchema => "CFN_RESOURCE_SCHEMA",
            ResourceConfigurationSchemaType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CFN_RESOURCE_SCHEMA"]
    }
}
impl AsRef<str> for ResourceConfigurationSchemaType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The details that identify a resource within Config, including the resource type and resource ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceKey {
    /// <p>The resource type.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>The ID of the resource (for example., sg-xxxxxx). </p>
    #[doc(hidden)]
    pub resource_id: std::option::Option<std::string::String>,
}
impl ResourceKey {
    /// <p>The resource type.</p>
    pub fn resource_type(&self) -> std::option::Option<&crate::model::ResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>The ID of the resource (for example., sg-xxxxxx). </p>
    pub fn resource_id(&self) -> std::option::Option<&str> {
        self.resource_id.as_deref()
    }
}
impl ResourceKey {
    /// Creates a new builder-style object to manufacture [`ResourceKey`](crate::model::ResourceKey).
    pub fn builder() -> crate::model::resource_key::Builder {
        crate::model::resource_key::Builder::default()
    }
}

/// See [`ResourceKey`](crate::model::ResourceKey).
pub mod resource_key {

    /// A builder for [`ResourceKey`](crate::model::ResourceKey).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The resource type.</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>The resource type.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The ID of the resource (for example., sg-xxxxxx). </p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The ID of the resource (for example., sg-xxxxxx). </p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceKey`](crate::model::ResourceKey).
        pub fn build(self) -> crate::model::ResourceKey {
            crate::model::ResourceKey {
                resource_type: self.resource_type,
                resource_id: self.resource_id,
            }
        }
    }
}

/// When writing a match expression against `ResourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourcetype = unimplemented!();
/// match resourcetype {
///     ResourceType::Certificate => { /* ... */ },
///     ResourceType::AccessAnalyzerAnalyzer => { /* ... */ },
///     ResourceType::RestApi => { /* ... */ },
///     ResourceType::Stage => { /* ... */ },
///     ResourceType::Api => { /* ... */ },
///     ResourceType::StageV2 => { /* ... */ },
///     ResourceType::AppConfigApplication => { /* ... */ },
///     ResourceType::AppSyncGraphQlApi => { /* ... */ },
///     ResourceType::AthenaDataCatalog => { /* ... */ },
///     ResourceType::AthenaWorkGroup => { /* ... */ },
///     ResourceType::AutoScalingGroup => { /* ... */ },
///     ResourceType::LaunchConfiguration => { /* ... */ },
///     ResourceType::ScalingPolicy => { /* ... */ },
///     ResourceType::ScheduledAction => { /* ... */ },
///     ResourceType::BackupPlan => { /* ... */ },
///     ResourceType::BackupSelection => { /* ... */ },
///     ResourceType::BackupVault => { /* ... */ },
///     ResourceType::BackupRecoveryPoint => { /* ... */ },
///     ResourceType::BatchComputeEnvironment => { /* ... */ },
///     ResourceType::BatchJobQueue => { /* ... */ },
///     ResourceType::Stack => { /* ... */ },
///     ResourceType::Distribution => { /* ... */ },
///     ResourceType::StreamingDistribution => { /* ... */ },
///     ResourceType::Trail => { /* ... */ },
///     ResourceType::Alarm => { /* ... */ },
///     ResourceType::Project => { /* ... */ },
///     ResourceType::CodeDeployApplication => { /* ... */ },
///     ResourceType::CodeDeployDeploymentConfig => { /* ... */ },
///     ResourceType::CodeDeployDeploymentGroup => { /* ... */ },
///     ResourceType::Pipeline => { /* ... */ },
///     ResourceType::ConformancePackCompliance => { /* ... */ },
///     ResourceType::ResourceCompliance => { /* ... */ },
///     ResourceType::DmsCertificate => { /* ... */ },
///     ResourceType::DmsEventSubscription => { /* ... */ },
///     ResourceType::DmsReplicationSubnetGroup => { /* ... */ },
///     ResourceType::DataSyncLocationEfs => { /* ... */ },
///     ResourceType::DataSyncLocationFSxLustre => { /* ... */ },
///     ResourceType::DataSyncLocationNfs => { /* ... */ },
///     ResourceType::DataSyncLocationS3 => { /* ... */ },
///     ResourceType::DataSyncLocationSmb => { /* ... */ },
///     ResourceType::DataSyncTask => { /* ... */ },
///     ResourceType::DetectiveGraph => { /* ... */ },
///     ResourceType::Table => { /* ... */ },
///     ResourceType::CustomerGateway => { /* ... */ },
///     ResourceType::Eip => { /* ... */ },
///     ResourceType::EgressOnlyInternetGateway => { /* ... */ },
///     ResourceType::FlowLog => { /* ... */ },
///     ResourceType::Host => { /* ... */ },
///     ResourceType::Instance => { /* ... */ },
///     ResourceType::InternetGateway => { /* ... */ },
///     ResourceType::LaunchTemplate => { /* ... */ },
///     ResourceType::NatGateway => { /* ... */ },
///     ResourceType::NetworkAcl => { /* ... */ },
///     ResourceType::NetworkInsightsAccessScopeAnalysis => { /* ... */ },
///     ResourceType::NetworkInterface => { /* ... */ },
///     ResourceType::RegisteredHaInstance => { /* ... */ },
///     ResourceType::RouteTable => { /* ... */ },
///     ResourceType::SecurityGroup => { /* ... */ },
///     ResourceType::Subnet => { /* ... */ },
///     ResourceType::TransitGateway => { /* ... */ },
///     ResourceType::TransitGatewayAttachment => { /* ... */ },
///     ResourceType::TransitGatewayRouteTable => { /* ... */ },
///     ResourceType::Vpc => { /* ... */ },
///     ResourceType::VpcEndpoint => { /* ... */ },
///     ResourceType::VpcEndpointService => { /* ... */ },
///     ResourceType::VpcPeeringConnection => { /* ... */ },
///     ResourceType::VpnConnection => { /* ... */ },
///     ResourceType::VpnGateway => { /* ... */ },
///     ResourceType::Volume => { /* ... */ },
///     ResourceType::EcrPublicRepository => { /* ... */ },
///     ResourceType::EcrRepository => { /* ... */ },
///     ResourceType::EcsCluster => { /* ... */ },
///     ResourceType::EcsService => { /* ... */ },
///     ResourceType::EcsTaskDefinition => { /* ... */ },
///     ResourceType::EfsAccessPoint => { /* ... */ },
///     ResourceType::EfsFileSystem => { /* ... */ },
///     ResourceType::EksCluster => { /* ... */ },
///     ResourceType::EksFargateProfile => { /* ... */ },
///     ResourceType::EmrSecurityConfiguration => { /* ... */ },
///     ResourceType::Application => { /* ... */ },
///     ResourceType::ApplicationVersion => { /* ... */ },
///     ResourceType::Environment => { /* ... */ },
///     ResourceType::LoadBalancer => { /* ... */ },
///     ResourceType::ListenerV2 => { /* ... */ },
///     ResourceType::LoadBalancerV2 => { /* ... */ },
///     ResourceType::Domain => { /* ... */ },
///     ResourceType::GlobalAcceleratorAccelerator => { /* ... */ },
///     ResourceType::GlobalAcceleratorEndpointGroup => { /* ... */ },
///     ResourceType::GlobalAcceleratorListener => { /* ... */ },
///     ResourceType::GlueJob => { /* ... */ },
///     ResourceType::GuardDutyDetector => { /* ... */ },
///     ResourceType::GuardDutyIpSet => { /* ... */ },
///     ResourceType::GuardDutyThreatIntelSet => { /* ... */ },
///     ResourceType::Group => { /* ... */ },
///     ResourceType::Policy => { /* ... */ },
///     ResourceType::Role => { /* ... */ },
///     ResourceType::User => { /* ... */ },
///     ResourceType::Key => { /* ... */ },
///     ResourceType::KinesisStream => { /* ... */ },
///     ResourceType::KinesisStreamConsumer => { /* ... */ },
///     ResourceType::Function => { /* ... */ },
///     ResourceType::MskCluster => { /* ... */ },
///     ResourceType::NetworkFirewallFirewall => { /* ... */ },
///     ResourceType::NetworkFirewallFirewallPolicy => { /* ... */ },
///     ResourceType::NetworkFirewallRuleGroup => { /* ... */ },
///     ResourceType::OpenSearchDomain => { /* ... */ },
///     ResourceType::QldbLedger => { /* ... */ },
///     ResourceType::DbCluster => { /* ... */ },
///     ResourceType::DbClusterSnapshot => { /* ... */ },
///     ResourceType::DbInstance => { /* ... */ },
///     ResourceType::DbSecurityGroup => { /* ... */ },
///     ResourceType::DbSnapshot => { /* ... */ },
///     ResourceType::DbSubnetGroup => { /* ... */ },
///     ResourceType::EventSubscription => { /* ... */ },
///     ResourceType::Cluster => { /* ... */ },
///     ResourceType::ClusterParameterGroup => { /* ... */ },
///     ResourceType::ClusterSecurityGroup => { /* ... */ },
///     ResourceType::ClusterSnapshot => { /* ... */ },
///     ResourceType::ClusterSubnetGroup => { /* ... */ },
///     ResourceType::RedshiftEventSubscription => { /* ... */ },
///     ResourceType::Route53HostedZone => { /* ... */ },
///     ResourceType::Route53ResolverResolverEndpoint => { /* ... */ },
///     ResourceType::Route53ResolverResolverRule => { /* ... */ },
///     ResourceType::Route53ResolverResolverRuleAssociation => { /* ... */ },
///     ResourceType::AccountPublicAccessBlock => { /* ... */ },
///     ResourceType::Bucket => { /* ... */ },
///     ResourceType::SesConfigurationSet => { /* ... */ },
///     ResourceType::SesContactList => { /* ... */ },
///     ResourceType::Topic => { /* ... */ },
///     ResourceType::Queue => { /* ... */ },
///     ResourceType::AssociationCompliance => { /* ... */ },
///     ResourceType::FileData => { /* ... */ },
///     ResourceType::ManagedInstanceInventory => { /* ... */ },
///     ResourceType::PatchCompliance => { /* ... */ },
///     ResourceType::SageMakerCodeRepository => { /* ... */ },
///     ResourceType::SageMakerModel => { /* ... */ },
///     ResourceType::SageMakerNotebookInstanceLifecycleConfig => { /* ... */ },
///     ResourceType::SageMakerWorkteam => { /* ... */ },
///     ResourceType::Secret => { /* ... */ },
///     ResourceType::CloudFormationProduct => { /* ... */ },
///     ResourceType::CloudFormationProvisionedProduct => { /* ... */ },
///     ResourceType::Portfolio => { /* ... */ },
///     ResourceType::ServiceDiscoveryPublicDnsNamespace => { /* ... */ },
///     ResourceType::ServiceDiscoveryService => { /* ... */ },
///     ResourceType::Protection => { /* ... */ },
///     ResourceType::RegionalProtection => { /* ... */ },
///     ResourceType::StepFunctionsActivity => { /* ... */ },
///     ResourceType::StepFunctionsStateMachine => { /* ... */ },
///     ResourceType::RateBasedRule => { /* ... */ },
///     ResourceType::Rule => { /* ... */ },
///     ResourceType::RuleGroup => { /* ... */ },
///     ResourceType::WebAcl => { /* ... */ },
///     ResourceType::RegionalRateBasedRule => { /* ... */ },
///     ResourceType::RegionalRule => { /* ... */ },
///     ResourceType::RegionalRuleGroup => { /* ... */ },
///     ResourceType::RegionalWebAcl => { /* ... */ },
///     ResourceType::IpSetV2 => { /* ... */ },
///     ResourceType::ManagedRuleSetV2 => { /* ... */ },
///     ResourceType::RegexPatternSetV2 => { /* ... */ },
///     ResourceType::RuleGroupV2 => { /* ... */ },
///     ResourceType::WebAclv2 => { /* ... */ },
///     ResourceType::WorkSpacesConnectionAlias => { /* ... */ },
///     ResourceType::WorkSpacesWorkspace => { /* ... */ },
///     ResourceType::EncryptionConfig => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceType::NewFeature` is defined.
/// Specifically, when `resourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceType {
    #[allow(missing_docs)] // documentation missing in model
    Certificate,
    #[allow(missing_docs)] // documentation missing in model
    AccessAnalyzerAnalyzer,
    #[allow(missing_docs)] // documentation missing in model
    RestApi,
    #[allow(missing_docs)] // documentation missing in model
    Stage,
    #[allow(missing_docs)] // documentation missing in model
    Api,
    #[allow(missing_docs)] // documentation missing in model
    StageV2,
    #[allow(missing_docs)] // documentation missing in model
    AppConfigApplication,
    #[allow(missing_docs)] // documentation missing in model
    AppSyncGraphQlApi,
    #[allow(missing_docs)] // documentation missing in model
    AthenaDataCatalog,
    #[allow(missing_docs)] // documentation missing in model
    AthenaWorkGroup,
    #[allow(missing_docs)] // documentation missing in model
    AutoScalingGroup,
    #[allow(missing_docs)] // documentation missing in model
    LaunchConfiguration,
    #[allow(missing_docs)] // documentation missing in model
    ScalingPolicy,
    #[allow(missing_docs)] // documentation missing in model
    ScheduledAction,
    #[allow(missing_docs)] // documentation missing in model
    BackupPlan,
    #[allow(missing_docs)] // documentation missing in model
    BackupSelection,
    #[allow(missing_docs)] // documentation missing in model
    BackupVault,
    #[allow(missing_docs)] // documentation missing in model
    BackupRecoveryPoint,
    #[allow(missing_docs)] // documentation missing in model
    BatchComputeEnvironment,
    #[allow(missing_docs)] // documentation missing in model
    BatchJobQueue,
    #[allow(missing_docs)] // documentation missing in model
    Stack,
    #[allow(missing_docs)] // documentation missing in model
    Distribution,
    #[allow(missing_docs)] // documentation missing in model
    StreamingDistribution,
    #[allow(missing_docs)] // documentation missing in model
    Trail,
    #[allow(missing_docs)] // documentation missing in model
    Alarm,
    #[allow(missing_docs)] // documentation missing in model
    Project,
    #[allow(missing_docs)] // documentation missing in model
    CodeDeployApplication,
    #[allow(missing_docs)] // documentation missing in model
    CodeDeployDeploymentConfig,
    #[allow(missing_docs)] // documentation missing in model
    CodeDeployDeploymentGroup,
    #[allow(missing_docs)] // documentation missing in model
    Pipeline,
    #[allow(missing_docs)] // documentation missing in model
    ConformancePackCompliance,
    #[allow(missing_docs)] // documentation missing in model
    ResourceCompliance,
    #[allow(missing_docs)] // documentation missing in model
    DmsCertificate,
    #[allow(missing_docs)] // documentation missing in model
    DmsEventSubscription,
    #[allow(missing_docs)] // documentation missing in model
    DmsReplicationSubnetGroup,
    #[allow(missing_docs)] // documentation missing in model
    DataSyncLocationEfs,
    #[allow(missing_docs)] // documentation missing in model
    DataSyncLocationFSxLustre,
    #[allow(missing_docs)] // documentation missing in model
    DataSyncLocationNfs,
    #[allow(missing_docs)] // documentation missing in model
    DataSyncLocationS3,
    #[allow(missing_docs)] // documentation missing in model
    DataSyncLocationSmb,
    #[allow(missing_docs)] // documentation missing in model
    DataSyncTask,
    #[allow(missing_docs)] // documentation missing in model
    DetectiveGraph,
    #[allow(missing_docs)] // documentation missing in model
    Table,
    #[allow(missing_docs)] // documentation missing in model
    CustomerGateway,
    #[allow(missing_docs)] // documentation missing in model
    Eip,
    #[allow(missing_docs)] // documentation missing in model
    EgressOnlyInternetGateway,
    #[allow(missing_docs)] // documentation missing in model
    FlowLog,
    #[allow(missing_docs)] // documentation missing in model
    Host,
    #[allow(missing_docs)] // documentation missing in model
    Instance,
    #[allow(missing_docs)] // documentation missing in model
    InternetGateway,
    #[allow(missing_docs)] // documentation missing in model
    LaunchTemplate,
    #[allow(missing_docs)] // documentation missing in model
    NatGateway,
    #[allow(missing_docs)] // documentation missing in model
    NetworkAcl,
    #[allow(missing_docs)] // documentation missing in model
    NetworkInsightsAccessScopeAnalysis,
    #[allow(missing_docs)] // documentation missing in model
    NetworkInterface,
    #[allow(missing_docs)] // documentation missing in model
    RegisteredHaInstance,
    #[allow(missing_docs)] // documentation missing in model
    RouteTable,
    #[allow(missing_docs)] // documentation missing in model
    SecurityGroup,
    #[allow(missing_docs)] // documentation missing in model
    Subnet,
    #[allow(missing_docs)] // documentation missing in model
    TransitGateway,
    #[allow(missing_docs)] // documentation missing in model
    TransitGatewayAttachment,
    #[allow(missing_docs)] // documentation missing in model
    TransitGatewayRouteTable,
    #[allow(missing_docs)] // documentation missing in model
    Vpc,
    #[allow(missing_docs)] // documentation missing in model
    VpcEndpoint,
    #[allow(missing_docs)] // documentation missing in model
    VpcEndpointService,
    #[allow(missing_docs)] // documentation missing in model
    VpcPeeringConnection,
    #[allow(missing_docs)] // documentation missing in model
    VpnConnection,
    #[allow(missing_docs)] // documentation missing in model
    VpnGateway,
    #[allow(missing_docs)] // documentation missing in model
    Volume,
    #[allow(missing_docs)] // documentation missing in model
    EcrPublicRepository,
    #[allow(missing_docs)] // documentation missing in model
    EcrRepository,
    #[allow(missing_docs)] // documentation missing in model
    EcsCluster,
    #[allow(missing_docs)] // documentation missing in model
    EcsService,
    #[allow(missing_docs)] // documentation missing in model
    EcsTaskDefinition,
    #[allow(missing_docs)] // documentation missing in model
    EfsAccessPoint,
    #[allow(missing_docs)] // documentation missing in model
    EfsFileSystem,
    #[allow(missing_docs)] // documentation missing in model
    EksCluster,
    #[allow(missing_docs)] // documentation missing in model
    EksFargateProfile,
    #[allow(missing_docs)] // documentation missing in model
    EmrSecurityConfiguration,
    #[allow(missing_docs)] // documentation missing in model
    Application,
    #[allow(missing_docs)] // documentation missing in model
    ApplicationVersion,
    #[allow(missing_docs)] // documentation missing in model
    Environment,
    #[allow(missing_docs)] // documentation missing in model
    LoadBalancer,
    #[allow(missing_docs)] // documentation missing in model
    ListenerV2,
    #[allow(missing_docs)] // documentation missing in model
    LoadBalancerV2,
    #[allow(missing_docs)] // documentation missing in model
    Domain,
    #[allow(missing_docs)] // documentation missing in model
    GlobalAcceleratorAccelerator,
    #[allow(missing_docs)] // documentation missing in model
    GlobalAcceleratorEndpointGroup,
    #[allow(missing_docs)] // documentation missing in model
    GlobalAcceleratorListener,
    #[allow(missing_docs)] // documentation missing in model
    GlueJob,
    #[allow(missing_docs)] // documentation missing in model
    GuardDutyDetector,
    #[allow(missing_docs)] // documentation missing in model
    GuardDutyIpSet,
    #[allow(missing_docs)] // documentation missing in model
    GuardDutyThreatIntelSet,
    #[allow(missing_docs)] // documentation missing in model
    Group,
    #[allow(missing_docs)] // documentation missing in model
    Policy,
    #[allow(missing_docs)] // documentation missing in model
    Role,
    #[allow(missing_docs)] // documentation missing in model
    User,
    #[allow(missing_docs)] // documentation missing in model
    Key,
    #[allow(missing_docs)] // documentation missing in model
    KinesisStream,
    #[allow(missing_docs)] // documentation missing in model
    KinesisStreamConsumer,
    #[allow(missing_docs)] // documentation missing in model
    Function,
    #[allow(missing_docs)] // documentation missing in model
    MskCluster,
    #[allow(missing_docs)] // documentation missing in model
    NetworkFirewallFirewall,
    #[allow(missing_docs)] // documentation missing in model
    NetworkFirewallFirewallPolicy,
    #[allow(missing_docs)] // documentation missing in model
    NetworkFirewallRuleGroup,
    #[allow(missing_docs)] // documentation missing in model
    OpenSearchDomain,
    #[allow(missing_docs)] // documentation missing in model
    QldbLedger,
    #[allow(missing_docs)] // documentation missing in model
    DbCluster,
    #[allow(missing_docs)] // documentation missing in model
    DbClusterSnapshot,
    #[allow(missing_docs)] // documentation missing in model
    DbInstance,
    #[allow(missing_docs)] // documentation missing in model
    DbSecurityGroup,
    #[allow(missing_docs)] // documentation missing in model
    DbSnapshot,
    #[allow(missing_docs)] // documentation missing in model
    DbSubnetGroup,
    #[allow(missing_docs)] // documentation missing in model
    EventSubscription,
    #[allow(missing_docs)] // documentation missing in model
    Cluster,
    #[allow(missing_docs)] // documentation missing in model
    ClusterParameterGroup,
    #[allow(missing_docs)] // documentation missing in model
    ClusterSecurityGroup,
    #[allow(missing_docs)] // documentation missing in model
    ClusterSnapshot,
    #[allow(missing_docs)] // documentation missing in model
    ClusterSubnetGroup,
    #[allow(missing_docs)] // documentation missing in model
    RedshiftEventSubscription,
    #[allow(missing_docs)] // documentation missing in model
    Route53HostedZone,
    #[allow(missing_docs)] // documentation missing in model
    Route53ResolverResolverEndpoint,
    #[allow(missing_docs)] // documentation missing in model
    Route53ResolverResolverRule,
    #[allow(missing_docs)] // documentation missing in model
    Route53ResolverResolverRuleAssociation,
    #[allow(missing_docs)] // documentation missing in model
    AccountPublicAccessBlock,
    #[allow(missing_docs)] // documentation missing in model
    Bucket,
    #[allow(missing_docs)] // documentation missing in model
    SesConfigurationSet,
    #[allow(missing_docs)] // documentation missing in model
    SesContactList,
    #[allow(missing_docs)] // documentation missing in model
    Topic,
    #[allow(missing_docs)] // documentation missing in model
    Queue,
    #[allow(missing_docs)] // documentation missing in model
    AssociationCompliance,
    #[allow(missing_docs)] // documentation missing in model
    FileData,
    #[allow(missing_docs)] // documentation missing in model
    ManagedInstanceInventory,
    #[allow(missing_docs)] // documentation missing in model
    PatchCompliance,
    #[allow(missing_docs)] // documentation missing in model
    SageMakerCodeRepository,
    #[allow(missing_docs)] // documentation missing in model
    SageMakerModel,
    #[allow(missing_docs)] // documentation missing in model
    SageMakerNotebookInstanceLifecycleConfig,
    #[allow(missing_docs)] // documentation missing in model
    SageMakerWorkteam,
    #[allow(missing_docs)] // documentation missing in model
    Secret,
    #[allow(missing_docs)] // documentation missing in model
    CloudFormationProduct,
    #[allow(missing_docs)] // documentation missing in model
    CloudFormationProvisionedProduct,
    #[allow(missing_docs)] // documentation missing in model
    Portfolio,
    #[allow(missing_docs)] // documentation missing in model
    ServiceDiscoveryPublicDnsNamespace,
    #[allow(missing_docs)] // documentation missing in model
    ServiceDiscoveryService,
    #[allow(missing_docs)] // documentation missing in model
    Protection,
    #[allow(missing_docs)] // documentation missing in model
    RegionalProtection,
    #[allow(missing_docs)] // documentation missing in model
    StepFunctionsActivity,
    #[allow(missing_docs)] // documentation missing in model
    StepFunctionsStateMachine,
    #[allow(missing_docs)] // documentation missing in model
    RateBasedRule,
    #[allow(missing_docs)] // documentation missing in model
    Rule,
    #[allow(missing_docs)] // documentation missing in model
    RuleGroup,
    #[allow(missing_docs)] // documentation missing in model
    WebAcl,
    #[allow(missing_docs)] // documentation missing in model
    RegionalRateBasedRule,
    #[allow(missing_docs)] // documentation missing in model
    RegionalRule,
    #[allow(missing_docs)] // documentation missing in model
    RegionalRuleGroup,
    #[allow(missing_docs)] // documentation missing in model
    RegionalWebAcl,
    #[allow(missing_docs)] // documentation missing in model
    IpSetV2,
    #[allow(missing_docs)] // documentation missing in model
    ManagedRuleSetV2,
    #[allow(missing_docs)] // documentation missing in model
    RegexPatternSetV2,
    #[allow(missing_docs)] // documentation missing in model
    RuleGroupV2,
    #[allow(missing_docs)] // documentation missing in model
    WebAclv2,
    #[allow(missing_docs)] // documentation missing in model
    WorkSpacesConnectionAlias,
    #[allow(missing_docs)] // documentation missing in model
    WorkSpacesWorkspace,
    #[allow(missing_docs)] // documentation missing in model
    EncryptionConfig,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceType {
    fn from(s: &str) -> Self {
        match s {
            "AWS::ACM::Certificate" => ResourceType::Certificate,
            "AWS::AccessAnalyzer::Analyzer" => ResourceType::AccessAnalyzerAnalyzer,
            "AWS::ApiGateway::RestApi" => ResourceType::RestApi,
            "AWS::ApiGateway::Stage" => ResourceType::Stage,
            "AWS::ApiGatewayV2::Api" => ResourceType::Api,
            "AWS::ApiGatewayV2::Stage" => ResourceType::StageV2,
            "AWS::AppConfig::Application" => ResourceType::AppConfigApplication,
            "AWS::AppSync::GraphQLApi" => ResourceType::AppSyncGraphQlApi,
            "AWS::Athena::DataCatalog" => ResourceType::AthenaDataCatalog,
            "AWS::Athena::WorkGroup" => ResourceType::AthenaWorkGroup,
            "AWS::AutoScaling::AutoScalingGroup" => ResourceType::AutoScalingGroup,
            "AWS::AutoScaling::LaunchConfiguration" => ResourceType::LaunchConfiguration,
            "AWS::AutoScaling::ScalingPolicy" => ResourceType::ScalingPolicy,
            "AWS::AutoScaling::ScheduledAction" => ResourceType::ScheduledAction,
            "AWS::Backup::BackupPlan" => ResourceType::BackupPlan,
            "AWS::Backup::BackupSelection" => ResourceType::BackupSelection,
            "AWS::Backup::BackupVault" => ResourceType::BackupVault,
            "AWS::Backup::RecoveryPoint" => ResourceType::BackupRecoveryPoint,
            "AWS::Batch::ComputeEnvironment" => ResourceType::BatchComputeEnvironment,
            "AWS::Batch::JobQueue" => ResourceType::BatchJobQueue,
            "AWS::CloudFormation::Stack" => ResourceType::Stack,
            "AWS::CloudFront::Distribution" => ResourceType::Distribution,
            "AWS::CloudFront::StreamingDistribution" => ResourceType::StreamingDistribution,
            "AWS::CloudTrail::Trail" => ResourceType::Trail,
            "AWS::CloudWatch::Alarm" => ResourceType::Alarm,
            "AWS::CodeBuild::Project" => ResourceType::Project,
            "AWS::CodeDeploy::Application" => ResourceType::CodeDeployApplication,
            "AWS::CodeDeploy::DeploymentConfig" => ResourceType::CodeDeployDeploymentConfig,
            "AWS::CodeDeploy::DeploymentGroup" => ResourceType::CodeDeployDeploymentGroup,
            "AWS::CodePipeline::Pipeline" => ResourceType::Pipeline,
            "AWS::Config::ConformancePackCompliance" => ResourceType::ConformancePackCompliance,
            "AWS::Config::ResourceCompliance" => ResourceType::ResourceCompliance,
            "AWS::DMS::Certificate" => ResourceType::DmsCertificate,
            "AWS::DMS::EventSubscription" => ResourceType::DmsEventSubscription,
            "AWS::DMS::ReplicationSubnetGroup" => ResourceType::DmsReplicationSubnetGroup,
            "AWS::DataSync::LocationEFS" => ResourceType::DataSyncLocationEfs,
            "AWS::DataSync::LocationFSxLustre" => ResourceType::DataSyncLocationFSxLustre,
            "AWS::DataSync::LocationNFS" => ResourceType::DataSyncLocationNfs,
            "AWS::DataSync::LocationS3" => ResourceType::DataSyncLocationS3,
            "AWS::DataSync::LocationSMB" => ResourceType::DataSyncLocationSmb,
            "AWS::DataSync::Task" => ResourceType::DataSyncTask,
            "AWS::Detective::Graph" => ResourceType::DetectiveGraph,
            "AWS::DynamoDB::Table" => ResourceType::Table,
            "AWS::EC2::CustomerGateway" => ResourceType::CustomerGateway,
            "AWS::EC2::EIP" => ResourceType::Eip,
            "AWS::EC2::EgressOnlyInternetGateway" => ResourceType::EgressOnlyInternetGateway,
            "AWS::EC2::FlowLog" => ResourceType::FlowLog,
            "AWS::EC2::Host" => ResourceType::Host,
            "AWS::EC2::Instance" => ResourceType::Instance,
            "AWS::EC2::InternetGateway" => ResourceType::InternetGateway,
            "AWS::EC2::LaunchTemplate" => ResourceType::LaunchTemplate,
            "AWS::EC2::NatGateway" => ResourceType::NatGateway,
            "AWS::EC2::NetworkAcl" => ResourceType::NetworkAcl,
            "AWS::EC2::NetworkInsightsAccessScopeAnalysis" => {
                ResourceType::NetworkInsightsAccessScopeAnalysis
            }
            "AWS::EC2::NetworkInterface" => ResourceType::NetworkInterface,
            "AWS::EC2::RegisteredHAInstance" => ResourceType::RegisteredHaInstance,
            "AWS::EC2::RouteTable" => ResourceType::RouteTable,
            "AWS::EC2::SecurityGroup" => ResourceType::SecurityGroup,
            "AWS::EC2::Subnet" => ResourceType::Subnet,
            "AWS::EC2::TransitGateway" => ResourceType::TransitGateway,
            "AWS::EC2::TransitGatewayAttachment" => ResourceType::TransitGatewayAttachment,
            "AWS::EC2::TransitGatewayRouteTable" => ResourceType::TransitGatewayRouteTable,
            "AWS::EC2::VPC" => ResourceType::Vpc,
            "AWS::EC2::VPCEndpoint" => ResourceType::VpcEndpoint,
            "AWS::EC2::VPCEndpointService" => ResourceType::VpcEndpointService,
            "AWS::EC2::VPCPeeringConnection" => ResourceType::VpcPeeringConnection,
            "AWS::EC2::VPNConnection" => ResourceType::VpnConnection,
            "AWS::EC2::VPNGateway" => ResourceType::VpnGateway,
            "AWS::EC2::Volume" => ResourceType::Volume,
            "AWS::ECR::PublicRepository" => ResourceType::EcrPublicRepository,
            "AWS::ECR::Repository" => ResourceType::EcrRepository,
            "AWS::ECS::Cluster" => ResourceType::EcsCluster,
            "AWS::ECS::Service" => ResourceType::EcsService,
            "AWS::ECS::TaskDefinition" => ResourceType::EcsTaskDefinition,
            "AWS::EFS::AccessPoint" => ResourceType::EfsAccessPoint,
            "AWS::EFS::FileSystem" => ResourceType::EfsFileSystem,
            "AWS::EKS::Cluster" => ResourceType::EksCluster,
            "AWS::EKS::FargateProfile" => ResourceType::EksFargateProfile,
            "AWS::EMR::SecurityConfiguration" => ResourceType::EmrSecurityConfiguration,
            "AWS::ElasticBeanstalk::Application" => ResourceType::Application,
            "AWS::ElasticBeanstalk::ApplicationVersion" => ResourceType::ApplicationVersion,
            "AWS::ElasticBeanstalk::Environment" => ResourceType::Environment,
            "AWS::ElasticLoadBalancing::LoadBalancer" => ResourceType::LoadBalancer,
            "AWS::ElasticLoadBalancingV2::Listener" => ResourceType::ListenerV2,
            "AWS::ElasticLoadBalancingV2::LoadBalancer" => ResourceType::LoadBalancerV2,
            "AWS::Elasticsearch::Domain" => ResourceType::Domain,
            "AWS::GlobalAccelerator::Accelerator" => ResourceType::GlobalAcceleratorAccelerator,
            "AWS::GlobalAccelerator::EndpointGroup" => ResourceType::GlobalAcceleratorEndpointGroup,
            "AWS::GlobalAccelerator::Listener" => ResourceType::GlobalAcceleratorListener,
            "AWS::Glue::Job" => ResourceType::GlueJob,
            "AWS::GuardDuty::Detector" => ResourceType::GuardDutyDetector,
            "AWS::GuardDuty::IPSet" => ResourceType::GuardDutyIpSet,
            "AWS::GuardDuty::ThreatIntelSet" => ResourceType::GuardDutyThreatIntelSet,
            "AWS::IAM::Group" => ResourceType::Group,
            "AWS::IAM::Policy" => ResourceType::Policy,
            "AWS::IAM::Role" => ResourceType::Role,
            "AWS::IAM::User" => ResourceType::User,
            "AWS::KMS::Key" => ResourceType::Key,
            "AWS::Kinesis::Stream" => ResourceType::KinesisStream,
            "AWS::Kinesis::StreamConsumer" => ResourceType::KinesisStreamConsumer,
            "AWS::Lambda::Function" => ResourceType::Function,
            "AWS::MSK::Cluster" => ResourceType::MskCluster,
            "AWS::NetworkFirewall::Firewall" => ResourceType::NetworkFirewallFirewall,
            "AWS::NetworkFirewall::FirewallPolicy" => ResourceType::NetworkFirewallFirewallPolicy,
            "AWS::NetworkFirewall::RuleGroup" => ResourceType::NetworkFirewallRuleGroup,
            "AWS::OpenSearch::Domain" => ResourceType::OpenSearchDomain,
            "AWS::QLDB::Ledger" => ResourceType::QldbLedger,
            "AWS::RDS::DBCluster" => ResourceType::DbCluster,
            "AWS::RDS::DBClusterSnapshot" => ResourceType::DbClusterSnapshot,
            "AWS::RDS::DBInstance" => ResourceType::DbInstance,
            "AWS::RDS::DBSecurityGroup" => ResourceType::DbSecurityGroup,
            "AWS::RDS::DBSnapshot" => ResourceType::DbSnapshot,
            "AWS::RDS::DBSubnetGroup" => ResourceType::DbSubnetGroup,
            "AWS::RDS::EventSubscription" => ResourceType::EventSubscription,
            "AWS::Redshift::Cluster" => ResourceType::Cluster,
            "AWS::Redshift::ClusterParameterGroup" => ResourceType::ClusterParameterGroup,
            "AWS::Redshift::ClusterSecurityGroup" => ResourceType::ClusterSecurityGroup,
            "AWS::Redshift::ClusterSnapshot" => ResourceType::ClusterSnapshot,
            "AWS::Redshift::ClusterSubnetGroup" => ResourceType::ClusterSubnetGroup,
            "AWS::Redshift::EventSubscription" => ResourceType::RedshiftEventSubscription,
            "AWS::Route53::HostedZone" => ResourceType::Route53HostedZone,
            "AWS::Route53Resolver::ResolverEndpoint" => {
                ResourceType::Route53ResolverResolverEndpoint
            }
            "AWS::Route53Resolver::ResolverRule" => ResourceType::Route53ResolverResolverRule,
            "AWS::Route53Resolver::ResolverRuleAssociation" => {
                ResourceType::Route53ResolverResolverRuleAssociation
            }
            "AWS::S3::AccountPublicAccessBlock" => ResourceType::AccountPublicAccessBlock,
            "AWS::S3::Bucket" => ResourceType::Bucket,
            "AWS::SES::ConfigurationSet" => ResourceType::SesConfigurationSet,
            "AWS::SES::ContactList" => ResourceType::SesContactList,
            "AWS::SNS::Topic" => ResourceType::Topic,
            "AWS::SQS::Queue" => ResourceType::Queue,
            "AWS::SSM::AssociationCompliance" => ResourceType::AssociationCompliance,
            "AWS::SSM::FileData" => ResourceType::FileData,
            "AWS::SSM::ManagedInstanceInventory" => ResourceType::ManagedInstanceInventory,
            "AWS::SSM::PatchCompliance" => ResourceType::PatchCompliance,
            "AWS::SageMaker::CodeRepository" => ResourceType::SageMakerCodeRepository,
            "AWS::SageMaker::Model" => ResourceType::SageMakerModel,
            "AWS::SageMaker::NotebookInstanceLifecycleConfig" => {
                ResourceType::SageMakerNotebookInstanceLifecycleConfig
            }
            "AWS::SageMaker::Workteam" => ResourceType::SageMakerWorkteam,
            "AWS::SecretsManager::Secret" => ResourceType::Secret,
            "AWS::ServiceCatalog::CloudFormationProduct" => ResourceType::CloudFormationProduct,
            "AWS::ServiceCatalog::CloudFormationProvisionedProduct" => {
                ResourceType::CloudFormationProvisionedProduct
            }
            "AWS::ServiceCatalog::Portfolio" => ResourceType::Portfolio,
            "AWS::ServiceDiscovery::PublicDnsNamespace" => {
                ResourceType::ServiceDiscoveryPublicDnsNamespace
            }
            "AWS::ServiceDiscovery::Service" => ResourceType::ServiceDiscoveryService,
            "AWS::Shield::Protection" => ResourceType::Protection,
            "AWS::ShieldRegional::Protection" => ResourceType::RegionalProtection,
            "AWS::StepFunctions::Activity" => ResourceType::StepFunctionsActivity,
            "AWS::StepFunctions::StateMachine" => ResourceType::StepFunctionsStateMachine,
            "AWS::WAF::RateBasedRule" => ResourceType::RateBasedRule,
            "AWS::WAF::Rule" => ResourceType::Rule,
            "AWS::WAF::RuleGroup" => ResourceType::RuleGroup,
            "AWS::WAF::WebACL" => ResourceType::WebAcl,
            "AWS::WAFRegional::RateBasedRule" => ResourceType::RegionalRateBasedRule,
            "AWS::WAFRegional::Rule" => ResourceType::RegionalRule,
            "AWS::WAFRegional::RuleGroup" => ResourceType::RegionalRuleGroup,
            "AWS::WAFRegional::WebACL" => ResourceType::RegionalWebAcl,
            "AWS::WAFv2::IPSet" => ResourceType::IpSetV2,
            "AWS::WAFv2::ManagedRuleSet" => ResourceType::ManagedRuleSetV2,
            "AWS::WAFv2::RegexPatternSet" => ResourceType::RegexPatternSetV2,
            "AWS::WAFv2::RuleGroup" => ResourceType::RuleGroupV2,
            "AWS::WAFv2::WebACL" => ResourceType::WebAclv2,
            "AWS::WorkSpaces::ConnectionAlias" => ResourceType::WorkSpacesConnectionAlias,
            "AWS::WorkSpaces::Workspace" => ResourceType::WorkSpacesWorkspace,
            "AWS::XRay::EncryptionConfig" => ResourceType::EncryptionConfig,
            other => ResourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceType::from(s))
    }
}
impl ResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceType::Certificate => "AWS::ACM::Certificate",
            ResourceType::AccessAnalyzerAnalyzer => "AWS::AccessAnalyzer::Analyzer",
            ResourceType::RestApi => "AWS::ApiGateway::RestApi",
            ResourceType::Stage => "AWS::ApiGateway::Stage",
            ResourceType::Api => "AWS::ApiGatewayV2::Api",
            ResourceType::StageV2 => "AWS::ApiGatewayV2::Stage",
            ResourceType::AppConfigApplication => "AWS::AppConfig::Application",
            ResourceType::AppSyncGraphQlApi => "AWS::AppSync::GraphQLApi",
            ResourceType::AthenaDataCatalog => "AWS::Athena::DataCatalog",
            ResourceType::AthenaWorkGroup => "AWS::Athena::WorkGroup",
            ResourceType::AutoScalingGroup => "AWS::AutoScaling::AutoScalingGroup",
            ResourceType::LaunchConfiguration => "AWS::AutoScaling::LaunchConfiguration",
            ResourceType::ScalingPolicy => "AWS::AutoScaling::ScalingPolicy",
            ResourceType::ScheduledAction => "AWS::AutoScaling::ScheduledAction",
            ResourceType::BackupPlan => "AWS::Backup::BackupPlan",
            ResourceType::BackupSelection => "AWS::Backup::BackupSelection",
            ResourceType::BackupVault => "AWS::Backup::BackupVault",
            ResourceType::BackupRecoveryPoint => "AWS::Backup::RecoveryPoint",
            ResourceType::BatchComputeEnvironment => "AWS::Batch::ComputeEnvironment",
            ResourceType::BatchJobQueue => "AWS::Batch::JobQueue",
            ResourceType::Stack => "AWS::CloudFormation::Stack",
            ResourceType::Distribution => "AWS::CloudFront::Distribution",
            ResourceType::StreamingDistribution => "AWS::CloudFront::StreamingDistribution",
            ResourceType::Trail => "AWS::CloudTrail::Trail",
            ResourceType::Alarm => "AWS::CloudWatch::Alarm",
            ResourceType::Project => "AWS::CodeBuild::Project",
            ResourceType::CodeDeployApplication => "AWS::CodeDeploy::Application",
            ResourceType::CodeDeployDeploymentConfig => "AWS::CodeDeploy::DeploymentConfig",
            ResourceType::CodeDeployDeploymentGroup => "AWS::CodeDeploy::DeploymentGroup",
            ResourceType::Pipeline => "AWS::CodePipeline::Pipeline",
            ResourceType::ConformancePackCompliance => "AWS::Config::ConformancePackCompliance",
            ResourceType::ResourceCompliance => "AWS::Config::ResourceCompliance",
            ResourceType::DmsCertificate => "AWS::DMS::Certificate",
            ResourceType::DmsEventSubscription => "AWS::DMS::EventSubscription",
            ResourceType::DmsReplicationSubnetGroup => "AWS::DMS::ReplicationSubnetGroup",
            ResourceType::DataSyncLocationEfs => "AWS::DataSync::LocationEFS",
            ResourceType::DataSyncLocationFSxLustre => "AWS::DataSync::LocationFSxLustre",
            ResourceType::DataSyncLocationNfs => "AWS::DataSync::LocationNFS",
            ResourceType::DataSyncLocationS3 => "AWS::DataSync::LocationS3",
            ResourceType::DataSyncLocationSmb => "AWS::DataSync::LocationSMB",
            ResourceType::DataSyncTask => "AWS::DataSync::Task",
            ResourceType::DetectiveGraph => "AWS::Detective::Graph",
            ResourceType::Table => "AWS::DynamoDB::Table",
            ResourceType::CustomerGateway => "AWS::EC2::CustomerGateway",
            ResourceType::Eip => "AWS::EC2::EIP",
            ResourceType::EgressOnlyInternetGateway => "AWS::EC2::EgressOnlyInternetGateway",
            ResourceType::FlowLog => "AWS::EC2::FlowLog",
            ResourceType::Host => "AWS::EC2::Host",
            ResourceType::Instance => "AWS::EC2::Instance",
            ResourceType::InternetGateway => "AWS::EC2::InternetGateway",
            ResourceType::LaunchTemplate => "AWS::EC2::LaunchTemplate",
            ResourceType::NatGateway => "AWS::EC2::NatGateway",
            ResourceType::NetworkAcl => "AWS::EC2::NetworkAcl",
            ResourceType::NetworkInsightsAccessScopeAnalysis => {
                "AWS::EC2::NetworkInsightsAccessScopeAnalysis"
            }
            ResourceType::NetworkInterface => "AWS::EC2::NetworkInterface",
            ResourceType::RegisteredHaInstance => "AWS::EC2::RegisteredHAInstance",
            ResourceType::RouteTable => "AWS::EC2::RouteTable",
            ResourceType::SecurityGroup => "AWS::EC2::SecurityGroup",
            ResourceType::Subnet => "AWS::EC2::Subnet",
            ResourceType::TransitGateway => "AWS::EC2::TransitGateway",
            ResourceType::TransitGatewayAttachment => "AWS::EC2::TransitGatewayAttachment",
            ResourceType::TransitGatewayRouteTable => "AWS::EC2::TransitGatewayRouteTable",
            ResourceType::Vpc => "AWS::EC2::VPC",
            ResourceType::VpcEndpoint => "AWS::EC2::VPCEndpoint",
            ResourceType::VpcEndpointService => "AWS::EC2::VPCEndpointService",
            ResourceType::VpcPeeringConnection => "AWS::EC2::VPCPeeringConnection",
            ResourceType::VpnConnection => "AWS::EC2::VPNConnection",
            ResourceType::VpnGateway => "AWS::EC2::VPNGateway",
            ResourceType::Volume => "AWS::EC2::Volume",
            ResourceType::EcrPublicRepository => "AWS::ECR::PublicRepository",
            ResourceType::EcrRepository => "AWS::ECR::Repository",
            ResourceType::EcsCluster => "AWS::ECS::Cluster",
            ResourceType::EcsService => "AWS::ECS::Service",
            ResourceType::EcsTaskDefinition => "AWS::ECS::TaskDefinition",
            ResourceType::EfsAccessPoint => "AWS::EFS::AccessPoint",
            ResourceType::EfsFileSystem => "AWS::EFS::FileSystem",
            ResourceType::EksCluster => "AWS::EKS::Cluster",
            ResourceType::EksFargateProfile => "AWS::EKS::FargateProfile",
            ResourceType::EmrSecurityConfiguration => "AWS::EMR::SecurityConfiguration",
            ResourceType::Application => "AWS::ElasticBeanstalk::Application",
            ResourceType::ApplicationVersion => "AWS::ElasticBeanstalk::ApplicationVersion",
            ResourceType::Environment => "AWS::ElasticBeanstalk::Environment",
            ResourceType::LoadBalancer => "AWS::ElasticLoadBalancing::LoadBalancer",
            ResourceType::ListenerV2 => "AWS::ElasticLoadBalancingV2::Listener",
            ResourceType::LoadBalancerV2 => "AWS::ElasticLoadBalancingV2::LoadBalancer",
            ResourceType::Domain => "AWS::Elasticsearch::Domain",
            ResourceType::GlobalAcceleratorAccelerator => "AWS::GlobalAccelerator::Accelerator",
            ResourceType::GlobalAcceleratorEndpointGroup => "AWS::GlobalAccelerator::EndpointGroup",
            ResourceType::GlobalAcceleratorListener => "AWS::GlobalAccelerator::Listener",
            ResourceType::GlueJob => "AWS::Glue::Job",
            ResourceType::GuardDutyDetector => "AWS::GuardDuty::Detector",
            ResourceType::GuardDutyIpSet => "AWS::GuardDuty::IPSet",
            ResourceType::GuardDutyThreatIntelSet => "AWS::GuardDuty::ThreatIntelSet",
            ResourceType::Group => "AWS::IAM::Group",
            ResourceType::Policy => "AWS::IAM::Policy",
            ResourceType::Role => "AWS::IAM::Role",
            ResourceType::User => "AWS::IAM::User",
            ResourceType::Key => "AWS::KMS::Key",
            ResourceType::KinesisStream => "AWS::Kinesis::Stream",
            ResourceType::KinesisStreamConsumer => "AWS::Kinesis::StreamConsumer",
            ResourceType::Function => "AWS::Lambda::Function",
            ResourceType::MskCluster => "AWS::MSK::Cluster",
            ResourceType::NetworkFirewallFirewall => "AWS::NetworkFirewall::Firewall",
            ResourceType::NetworkFirewallFirewallPolicy => "AWS::NetworkFirewall::FirewallPolicy",
            ResourceType::NetworkFirewallRuleGroup => "AWS::NetworkFirewall::RuleGroup",
            ResourceType::OpenSearchDomain => "AWS::OpenSearch::Domain",
            ResourceType::QldbLedger => "AWS::QLDB::Ledger",
            ResourceType::DbCluster => "AWS::RDS::DBCluster",
            ResourceType::DbClusterSnapshot => "AWS::RDS::DBClusterSnapshot",
            ResourceType::DbInstance => "AWS::RDS::DBInstance",
            ResourceType::DbSecurityGroup => "AWS::RDS::DBSecurityGroup",
            ResourceType::DbSnapshot => "AWS::RDS::DBSnapshot",
            ResourceType::DbSubnetGroup => "AWS::RDS::DBSubnetGroup",
            ResourceType::EventSubscription => "AWS::RDS::EventSubscription",
            ResourceType::Cluster => "AWS::Redshift::Cluster",
            ResourceType::ClusterParameterGroup => "AWS::Redshift::ClusterParameterGroup",
            ResourceType::ClusterSecurityGroup => "AWS::Redshift::ClusterSecurityGroup",
            ResourceType::ClusterSnapshot => "AWS::Redshift::ClusterSnapshot",
            ResourceType::ClusterSubnetGroup => "AWS::Redshift::ClusterSubnetGroup",
            ResourceType::RedshiftEventSubscription => "AWS::Redshift::EventSubscription",
            ResourceType::Route53HostedZone => "AWS::Route53::HostedZone",
            ResourceType::Route53ResolverResolverEndpoint => {
                "AWS::Route53Resolver::ResolverEndpoint"
            }
            ResourceType::Route53ResolverResolverRule => "AWS::Route53Resolver::ResolverRule",
            ResourceType::Route53ResolverResolverRuleAssociation => {
                "AWS::Route53Resolver::ResolverRuleAssociation"
            }
            ResourceType::AccountPublicAccessBlock => "AWS::S3::AccountPublicAccessBlock",
            ResourceType::Bucket => "AWS::S3::Bucket",
            ResourceType::SesConfigurationSet => "AWS::SES::ConfigurationSet",
            ResourceType::SesContactList => "AWS::SES::ContactList",
            ResourceType::Topic => "AWS::SNS::Topic",
            ResourceType::Queue => "AWS::SQS::Queue",
            ResourceType::AssociationCompliance => "AWS::SSM::AssociationCompliance",
            ResourceType::FileData => "AWS::SSM::FileData",
            ResourceType::ManagedInstanceInventory => "AWS::SSM::ManagedInstanceInventory",
            ResourceType::PatchCompliance => "AWS::SSM::PatchCompliance",
            ResourceType::SageMakerCodeRepository => "AWS::SageMaker::CodeRepository",
            ResourceType::SageMakerModel => "AWS::SageMaker::Model",
            ResourceType::SageMakerNotebookInstanceLifecycleConfig => {
                "AWS::SageMaker::NotebookInstanceLifecycleConfig"
            }
            ResourceType::SageMakerWorkteam => "AWS::SageMaker::Workteam",
            ResourceType::Secret => "AWS::SecretsManager::Secret",
            ResourceType::CloudFormationProduct => "AWS::ServiceCatalog::CloudFormationProduct",
            ResourceType::CloudFormationProvisionedProduct => {
                "AWS::ServiceCatalog::CloudFormationProvisionedProduct"
            }
            ResourceType::Portfolio => "AWS::ServiceCatalog::Portfolio",
            ResourceType::ServiceDiscoveryPublicDnsNamespace => {
                "AWS::ServiceDiscovery::PublicDnsNamespace"
            }
            ResourceType::ServiceDiscoveryService => "AWS::ServiceDiscovery::Service",
            ResourceType::Protection => "AWS::Shield::Protection",
            ResourceType::RegionalProtection => "AWS::ShieldRegional::Protection",
            ResourceType::StepFunctionsActivity => "AWS::StepFunctions::Activity",
            ResourceType::StepFunctionsStateMachine => "AWS::StepFunctions::StateMachine",
            ResourceType::RateBasedRule => "AWS::WAF::RateBasedRule",
            ResourceType::Rule => "AWS::WAF::Rule",
            ResourceType::RuleGroup => "AWS::WAF::RuleGroup",
            ResourceType::WebAcl => "AWS::WAF::WebACL",
            ResourceType::RegionalRateBasedRule => "AWS::WAFRegional::RateBasedRule",
            ResourceType::RegionalRule => "AWS::WAFRegional::Rule",
            ResourceType::RegionalRuleGroup => "AWS::WAFRegional::RuleGroup",
            ResourceType::RegionalWebAcl => "AWS::WAFRegional::WebACL",
            ResourceType::IpSetV2 => "AWS::WAFv2::IPSet",
            ResourceType::ManagedRuleSetV2 => "AWS::WAFv2::ManagedRuleSet",
            ResourceType::RegexPatternSetV2 => "AWS::WAFv2::RegexPatternSet",
            ResourceType::RuleGroupV2 => "AWS::WAFv2::RuleGroup",
            ResourceType::WebAclv2 => "AWS::WAFv2::WebACL",
            ResourceType::WorkSpacesConnectionAlias => "AWS::WorkSpaces::ConnectionAlias",
            ResourceType::WorkSpacesWorkspace => "AWS::WorkSpaces::Workspace",
            ResourceType::EncryptionConfig => "AWS::XRay::EncryptionConfig",
            ResourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AWS::ACM::Certificate",
            "AWS::AccessAnalyzer::Analyzer",
            "AWS::ApiGateway::RestApi",
            "AWS::ApiGateway::Stage",
            "AWS::ApiGatewayV2::Api",
            "AWS::ApiGatewayV2::Stage",
            "AWS::AppConfig::Application",
            "AWS::AppSync::GraphQLApi",
            "AWS::Athena::DataCatalog",
            "AWS::Athena::WorkGroup",
            "AWS::AutoScaling::AutoScalingGroup",
            "AWS::AutoScaling::LaunchConfiguration",
            "AWS::AutoScaling::ScalingPolicy",
            "AWS::AutoScaling::ScheduledAction",
            "AWS::Backup::BackupPlan",
            "AWS::Backup::BackupSelection",
            "AWS::Backup::BackupVault",
            "AWS::Backup::RecoveryPoint",
            "AWS::Batch::ComputeEnvironment",
            "AWS::Batch::JobQueue",
            "AWS::CloudFormation::Stack",
            "AWS::CloudFront::Distribution",
            "AWS::CloudFront::StreamingDistribution",
            "AWS::CloudTrail::Trail",
            "AWS::CloudWatch::Alarm",
            "AWS::CodeBuild::Project",
            "AWS::CodeDeploy::Application",
            "AWS::CodeDeploy::DeploymentConfig",
            "AWS::CodeDeploy::DeploymentGroup",
            "AWS::CodePipeline::Pipeline",
            "AWS::Config::ConformancePackCompliance",
            "AWS::Config::ResourceCompliance",
            "AWS::DMS::Certificate",
            "AWS::DMS::EventSubscription",
            "AWS::DMS::ReplicationSubnetGroup",
            "AWS::DataSync::LocationEFS",
            "AWS::DataSync::LocationFSxLustre",
            "AWS::DataSync::LocationNFS",
            "AWS::DataSync::LocationS3",
            "AWS::DataSync::LocationSMB",
            "AWS::DataSync::Task",
            "AWS::Detective::Graph",
            "AWS::DynamoDB::Table",
            "AWS::EC2::CustomerGateway",
            "AWS::EC2::EIP",
            "AWS::EC2::EgressOnlyInternetGateway",
            "AWS::EC2::FlowLog",
            "AWS::EC2::Host",
            "AWS::EC2::Instance",
            "AWS::EC2::InternetGateway",
            "AWS::EC2::LaunchTemplate",
            "AWS::EC2::NatGateway",
            "AWS::EC2::NetworkAcl",
            "AWS::EC2::NetworkInsightsAccessScopeAnalysis",
            "AWS::EC2::NetworkInterface",
            "AWS::EC2::RegisteredHAInstance",
            "AWS::EC2::RouteTable",
            "AWS::EC2::SecurityGroup",
            "AWS::EC2::Subnet",
            "AWS::EC2::TransitGateway",
            "AWS::EC2::TransitGatewayAttachment",
            "AWS::EC2::TransitGatewayRouteTable",
            "AWS::EC2::VPC",
            "AWS::EC2::VPCEndpoint",
            "AWS::EC2::VPCEndpointService",
            "AWS::EC2::VPCPeeringConnection",
            "AWS::EC2::VPNConnection",
            "AWS::EC2::VPNGateway",
            "AWS::EC2::Volume",
            "AWS::ECR::PublicRepository",
            "AWS::ECR::Repository",
            "AWS::ECS::Cluster",
            "AWS::ECS::Service",
            "AWS::ECS::TaskDefinition",
            "AWS::EFS::AccessPoint",
            "AWS::EFS::FileSystem",
            "AWS::EKS::Cluster",
            "AWS::EKS::FargateProfile",
            "AWS::EMR::SecurityConfiguration",
            "AWS::ElasticBeanstalk::Application",
            "AWS::ElasticBeanstalk::ApplicationVersion",
            "AWS::ElasticBeanstalk::Environment",
            "AWS::ElasticLoadBalancing::LoadBalancer",
            "AWS::ElasticLoadBalancingV2::Listener",
            "AWS::ElasticLoadBalancingV2::LoadBalancer",
            "AWS::Elasticsearch::Domain",
            "AWS::GlobalAccelerator::Accelerator",
            "AWS::GlobalAccelerator::EndpointGroup",
            "AWS::GlobalAccelerator::Listener",
            "AWS::Glue::Job",
            "AWS::GuardDuty::Detector",
            "AWS::GuardDuty::IPSet",
            "AWS::GuardDuty::ThreatIntelSet",
            "AWS::IAM::Group",
            "AWS::IAM::Policy",
            "AWS::IAM::Role",
            "AWS::IAM::User",
            "AWS::KMS::Key",
            "AWS::Kinesis::Stream",
            "AWS::Kinesis::StreamConsumer",
            "AWS::Lambda::Function",
            "AWS::MSK::Cluster",
            "AWS::NetworkFirewall::Firewall",
            "AWS::NetworkFirewall::FirewallPolicy",
            "AWS::NetworkFirewall::RuleGroup",
            "AWS::OpenSearch::Domain",
            "AWS::QLDB::Ledger",
            "AWS::RDS::DBCluster",
            "AWS::RDS::DBClusterSnapshot",
            "AWS::RDS::DBInstance",
            "AWS::RDS::DBSecurityGroup",
            "AWS::RDS::DBSnapshot",
            "AWS::RDS::DBSubnetGroup",
            "AWS::RDS::EventSubscription",
            "AWS::Redshift::Cluster",
            "AWS::Redshift::ClusterParameterGroup",
            "AWS::Redshift::ClusterSecurityGroup",
            "AWS::Redshift::ClusterSnapshot",
            "AWS::Redshift::ClusterSubnetGroup",
            "AWS::Redshift::EventSubscription",
            "AWS::Route53::HostedZone",
            "AWS::Route53Resolver::ResolverEndpoint",
            "AWS::Route53Resolver::ResolverRule",
            "AWS::Route53Resolver::ResolverRuleAssociation",
            "AWS::S3::AccountPublicAccessBlock",
            "AWS::S3::Bucket",
            "AWS::SES::ConfigurationSet",
            "AWS::SES::ContactList",
            "AWS::SNS::Topic",
            "AWS::SQS::Queue",
            "AWS::SSM::AssociationCompliance",
            "AWS::SSM::FileData",
            "AWS::SSM::ManagedInstanceInventory",
            "AWS::SSM::PatchCompliance",
            "AWS::SageMaker::CodeRepository",
            "AWS::SageMaker::Model",
            "AWS::SageMaker::NotebookInstanceLifecycleConfig",
            "AWS::SageMaker::Workteam",
            "AWS::SecretsManager::Secret",
            "AWS::ServiceCatalog::CloudFormationProduct",
            "AWS::ServiceCatalog::CloudFormationProvisionedProduct",
            "AWS::ServiceCatalog::Portfolio",
            "AWS::ServiceDiscovery::PublicDnsNamespace",
            "AWS::ServiceDiscovery::Service",
            "AWS::Shield::Protection",
            "AWS::ShieldRegional::Protection",
            "AWS::StepFunctions::Activity",
            "AWS::StepFunctions::StateMachine",
            "AWS::WAF::RateBasedRule",
            "AWS::WAF::Rule",
            "AWS::WAF::RuleGroup",
            "AWS::WAF::WebACL",
            "AWS::WAFRegional::RateBasedRule",
            "AWS::WAFRegional::Rule",
            "AWS::WAFRegional::RuleGroup",
            "AWS::WAFRegional::WebACL",
            "AWS::WAFv2::IPSet",
            "AWS::WAFv2::ManagedRuleSet",
            "AWS::WAFv2::RegexPatternSet",
            "AWS::WAFv2::RuleGroup",
            "AWS::WAFv2::WebACL",
            "AWS::WorkSpaces::ConnectionAlias",
            "AWS::WorkSpaces::Workspace",
            "AWS::XRay::EncryptionConfig",
        ]
    }
}
impl AsRef<str> for ResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details about the query.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QueryInfo {
    /// <p>Returns a <code>FieldInfo</code> object.</p>
    #[doc(hidden)]
    pub select_fields: std::option::Option<std::vec::Vec<crate::model::FieldInfo>>,
}
impl QueryInfo {
    /// <p>Returns a <code>FieldInfo</code> object.</p>
    pub fn select_fields(&self) -> std::option::Option<&[crate::model::FieldInfo]> {
        self.select_fields.as_deref()
    }
}
impl QueryInfo {
    /// Creates a new builder-style object to manufacture [`QueryInfo`](crate::model::QueryInfo).
    pub fn builder() -> crate::model::query_info::Builder {
        crate::model::query_info::Builder::default()
    }
}

/// See [`QueryInfo`](crate::model::QueryInfo).
pub mod query_info {

    /// A builder for [`QueryInfo`](crate::model::QueryInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) select_fields: std::option::Option<std::vec::Vec<crate::model::FieldInfo>>,
    }
    impl Builder {
        /// Appends an item to `select_fields`.
        ///
        /// To override the contents of this collection use [`set_select_fields`](Self::set_select_fields).
        ///
        /// <p>Returns a <code>FieldInfo</code> object.</p>
        pub fn select_fields(mut self, input: crate::model::FieldInfo) -> Self {
            let mut v = self.select_fields.unwrap_or_default();
            v.push(input);
            self.select_fields = Some(v);
            self
        }
        /// <p>Returns a <code>FieldInfo</code> object.</p>
        pub fn set_select_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldInfo>>,
        ) -> Self {
            self.select_fields = input;
            self
        }
        /// Consumes the builder and constructs a [`QueryInfo`](crate::model::QueryInfo).
        pub fn build(self) -> crate::model::QueryInfo {
            crate::model::QueryInfo {
                select_fields: self.select_fields,
            }
        }
    }
}

/// <p>Details about the fields such as name of the field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldInfo {
    /// <p>Name of the field.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl FieldInfo {
    /// <p>Name of the field.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl FieldInfo {
    /// Creates a new builder-style object to manufacture [`FieldInfo`](crate::model::FieldInfo).
    pub fn builder() -> crate::model::field_info::Builder {
        crate::model::field_info::Builder::default()
    }
}

/// See [`FieldInfo`](crate::model::FieldInfo).
pub mod field_info {

    /// A builder for [`FieldInfo`](crate::model::FieldInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Name of the field.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Name of the field.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`FieldInfo`](crate::model::FieldInfo).
        pub fn build(self) -> crate::model::FieldInfo {
            crate::model::FieldInfo { name: self.name }
        }
    }
}

/// <p>Provides the details of a stored query.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StoredQuery {
    /// <p>The ID of the query.</p>
    #[doc(hidden)]
    pub query_id: std::option::Option<std::string::String>,
    /// <p>Amazon Resource Name (ARN) of the query. For example, arn:partition:service:region:account-id:resource-type/resource-name/resource-id.</p>
    #[doc(hidden)]
    pub query_arn: std::option::Option<std::string::String>,
    /// <p>The name of the query.</p>
    #[doc(hidden)]
    pub query_name: std::option::Option<std::string::String>,
    /// <p>A unique description for the query.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The expression of the query. For example, <code>SELECT resourceId, resourceType, supplementaryConfiguration.BucketVersioningConfiguration.status WHERE resourceType = 'AWS::S3::Bucket' AND supplementaryConfiguration.BucketVersioningConfiguration.status = 'Off'.</code> </p>
    #[doc(hidden)]
    pub expression: std::option::Option<std::string::String>,
}
impl StoredQuery {
    /// <p>The ID of the query.</p>
    pub fn query_id(&self) -> std::option::Option<&str> {
        self.query_id.as_deref()
    }
    /// <p>Amazon Resource Name (ARN) of the query. For example, arn:partition:service:region:account-id:resource-type/resource-name/resource-id.</p>
    pub fn query_arn(&self) -> std::option::Option<&str> {
        self.query_arn.as_deref()
    }
    /// <p>The name of the query.</p>
    pub fn query_name(&self) -> std::option::Option<&str> {
        self.query_name.as_deref()
    }
    /// <p>A unique description for the query.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The expression of the query. For example, <code>SELECT resourceId, resourceType, supplementaryConfiguration.BucketVersioningConfiguration.status WHERE resourceType = 'AWS::S3::Bucket' AND supplementaryConfiguration.BucketVersioningConfiguration.status = 'Off'.</code> </p>
    pub fn expression(&self) -> std::option::Option<&str> {
        self.expression.as_deref()
    }
}
impl StoredQuery {
    /// Creates a new builder-style object to manufacture [`StoredQuery`](crate::model::StoredQuery).
    pub fn builder() -> crate::model::stored_query::Builder {
        crate::model::stored_query::Builder::default()
    }
}

/// See [`StoredQuery`](crate::model::StoredQuery).
pub mod stored_query {

    /// A builder for [`StoredQuery`](crate::model::StoredQuery).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) query_id: std::option::Option<std::string::String>,
        pub(crate) query_arn: std::option::Option<std::string::String>,
        pub(crate) query_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) expression: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the query.</p>
        pub fn query_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_id = Some(input.into());
            self
        }
        /// <p>The ID of the query.</p>
        pub fn set_query_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_id = input;
            self
        }
        /// <p>Amazon Resource Name (ARN) of the query. For example, arn:partition:service:region:account-id:resource-type/resource-name/resource-id.</p>
        pub fn query_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_arn = Some(input.into());
            self
        }
        /// <p>Amazon Resource Name (ARN) of the query. For example, arn:partition:service:region:account-id:resource-type/resource-name/resource-id.</p>
        pub fn set_query_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_arn = input;
            self
        }
        /// <p>The name of the query.</p>
        pub fn query_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_name = Some(input.into());
            self
        }
        /// <p>The name of the query.</p>
        pub fn set_query_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_name = input;
            self
        }
        /// <p>A unique description for the query.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A unique description for the query.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The expression of the query. For example, <code>SELECT resourceId, resourceType, supplementaryConfiguration.BucketVersioningConfiguration.status WHERE resourceType = 'AWS::S3::Bucket' AND supplementaryConfiguration.BucketVersioningConfiguration.status = 'Off'.</code> </p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.expression = Some(input.into());
            self
        }
        /// <p>The expression of the query. For example, <code>SELECT resourceId, resourceType, supplementaryConfiguration.BucketVersioningConfiguration.status WHERE resourceType = 'AWS::S3::Bucket' AND supplementaryConfiguration.BucketVersioningConfiguration.status = 'Off'.</code> </p>
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expression = input;
            self
        }
        /// Consumes the builder and constructs a [`StoredQuery`](crate::model::StoredQuery).
        pub fn build(self) -> crate::model::StoredQuery {
            crate::model::StoredQuery {
                query_id: self.query_id,
                query_arn: self.query_arn,
                query_name: self.query_name,
                description: self.description,
                expression: self.expression,
            }
        }
    }
}

/// <p>An object with the name of the retention configuration and the retention period in days. The object stores the configuration for data retention in Config.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RetentionConfiguration {
    /// <p>The name of the retention configuration object.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Number of days Config stores your historical information.</p> <note>
    /// <p>Currently, only applicable to the configuration item history.</p>
    /// </note>
    #[doc(hidden)]
    pub retention_period_in_days: i32,
}
impl RetentionConfiguration {
    /// <p>The name of the retention configuration object.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Number of days Config stores your historical information.</p> <note>
    /// <p>Currently, only applicable to the configuration item history.</p>
    /// </note>
    pub fn retention_period_in_days(&self) -> i32 {
        self.retention_period_in_days
    }
}
impl RetentionConfiguration {
    /// Creates a new builder-style object to manufacture [`RetentionConfiguration`](crate::model::RetentionConfiguration).
    pub fn builder() -> crate::model::retention_configuration::Builder {
        crate::model::retention_configuration::Builder::default()
    }
}

/// See [`RetentionConfiguration`](crate::model::RetentionConfiguration).
pub mod retention_configuration {

    /// A builder for [`RetentionConfiguration`](crate::model::RetentionConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) retention_period_in_days: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the retention configuration object.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the retention configuration object.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Number of days Config stores your historical information.</p> <note>
        /// <p>Currently, only applicable to the configuration item history.</p>
        /// </note>
        pub fn retention_period_in_days(mut self, input: i32) -> Self {
            self.retention_period_in_days = Some(input);
            self
        }
        /// <p>Number of days Config stores your historical information.</p> <note>
        /// <p>Currently, only applicable to the configuration item history.</p>
        /// </note>
        pub fn set_retention_period_in_days(mut self, input: std::option::Option<i32>) -> Self {
            self.retention_period_in_days = input;
            self
        }
        /// Consumes the builder and constructs a [`RetentionConfiguration`](crate::model::RetentionConfiguration).
        pub fn build(self) -> crate::model::RetentionConfiguration {
            crate::model::RetentionConfiguration {
                name: self.name,
                retention_period_in_days: self.retention_period_in_days.unwrap_or_default(),
            }
        }
    }
}

/// <p>List of each of the failed remediation exceptions with specific reasons.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FailedRemediationExceptionBatch {
    /// <p>Returns a failure message. For example, the auto-remediation has failed.</p>
    #[doc(hidden)]
    pub failure_message: std::option::Option<std::string::String>,
    /// <p>Returns remediation exception resource key object of the failed items.</p>
    #[doc(hidden)]
    pub failed_items: std::option::Option<std::vec::Vec<crate::model::RemediationException>>,
}
impl FailedRemediationExceptionBatch {
    /// <p>Returns a failure message. For example, the auto-remediation has failed.</p>
    pub fn failure_message(&self) -> std::option::Option<&str> {
        self.failure_message.as_deref()
    }
    /// <p>Returns remediation exception resource key object of the failed items.</p>
    pub fn failed_items(&self) -> std::option::Option<&[crate::model::RemediationException]> {
        self.failed_items.as_deref()
    }
}
impl FailedRemediationExceptionBatch {
    /// Creates a new builder-style object to manufacture [`FailedRemediationExceptionBatch`](crate::model::FailedRemediationExceptionBatch).
    pub fn builder() -> crate::model::failed_remediation_exception_batch::Builder {
        crate::model::failed_remediation_exception_batch::Builder::default()
    }
}

/// See [`FailedRemediationExceptionBatch`](crate::model::FailedRemediationExceptionBatch).
pub mod failed_remediation_exception_batch {

    /// A builder for [`FailedRemediationExceptionBatch`](crate::model::FailedRemediationExceptionBatch).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) failure_message: std::option::Option<std::string::String>,
        pub(crate) failed_items:
            std::option::Option<std::vec::Vec<crate::model::RemediationException>>,
    }
    impl Builder {
        /// <p>Returns a failure message. For example, the auto-remediation has failed.</p>
        pub fn failure_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_message = Some(input.into());
            self
        }
        /// <p>Returns a failure message. For example, the auto-remediation has failed.</p>
        pub fn set_failure_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_message = input;
            self
        }
        /// Appends an item to `failed_items`.
        ///
        /// To override the contents of this collection use [`set_failed_items`](Self::set_failed_items).
        ///
        /// <p>Returns remediation exception resource key object of the failed items.</p>
        pub fn failed_items(mut self, input: crate::model::RemediationException) -> Self {
            let mut v = self.failed_items.unwrap_or_default();
            v.push(input);
            self.failed_items = Some(v);
            self
        }
        /// <p>Returns remediation exception resource key object of the failed items.</p>
        pub fn set_failed_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RemediationException>>,
        ) -> Self {
            self.failed_items = input;
            self
        }
        /// Consumes the builder and constructs a [`FailedRemediationExceptionBatch`](crate::model::FailedRemediationExceptionBatch).
        pub fn build(self) -> crate::model::FailedRemediationExceptionBatch {
            crate::model::FailedRemediationExceptionBatch {
                failure_message: self.failure_message,
                failed_items: self.failed_items,
            }
        }
    }
}

/// <p>An object that represents the details about the remediation exception. The details include the rule name, an explanation of an exception, the time when the exception will be deleted, the resource ID, and resource type. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RemediationException {
    /// <p>The name of the Config rule.</p>
    #[doc(hidden)]
    pub config_rule_name: std::option::Option<std::string::String>,
    /// <p>The type of a resource.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The ID of the resource (for example., sg-xxxxxx).</p>
    #[doc(hidden)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>An explanation of an remediation exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The time when the remediation exception will be deleted.</p>
    #[doc(hidden)]
    pub expiration_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl RemediationException {
    /// <p>The name of the Config rule.</p>
    pub fn config_rule_name(&self) -> std::option::Option<&str> {
        self.config_rule_name.as_deref()
    }
    /// <p>The type of a resource.</p>
    pub fn resource_type(&self) -> std::option::Option<&str> {
        self.resource_type.as_deref()
    }
    /// <p>The ID of the resource (for example., sg-xxxxxx).</p>
    pub fn resource_id(&self) -> std::option::Option<&str> {
        self.resource_id.as_deref()
    }
    /// <p>An explanation of an remediation exception.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>The time when the remediation exception will be deleted.</p>
    pub fn expiration_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.expiration_time.as_ref()
    }
}
impl RemediationException {
    /// Creates a new builder-style object to manufacture [`RemediationException`](crate::model::RemediationException).
    pub fn builder() -> crate::model::remediation_exception::Builder {
        crate::model::remediation_exception::Builder::default()
    }
}

/// See [`RemediationException`](crate::model::RemediationException).
pub mod remediation_exception {

    /// A builder for [`RemediationException`](crate::model::RemediationException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) config_rule_name: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) expiration_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the Config rule.</p>
        pub fn config_rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.config_rule_name = Some(input.into());
            self
        }
        /// <p>The name of the Config rule.</p>
        pub fn set_config_rule_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.config_rule_name = input;
            self
        }
        /// <p>The type of a resource.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The type of a resource.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The ID of the resource (for example., sg-xxxxxx).</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The ID of the resource (for example., sg-xxxxxx).</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>An explanation of an remediation exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>An explanation of an remediation exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The time when the remediation exception will be deleted.</p>
        pub fn expiration_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.expiration_time = Some(input);
            self
        }
        /// <p>The time when the remediation exception will be deleted.</p>
        pub fn set_expiration_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.expiration_time = input;
            self
        }
        /// Consumes the builder and constructs a [`RemediationException`](crate::model::RemediationException).
        pub fn build(self) -> crate::model::RemediationException {
            crate::model::RemediationException {
                config_rule_name: self.config_rule_name,
                resource_type: self.resource_type,
                resource_id: self.resource_id,
                message: self.message,
                expiration_time: self.expiration_time,
            }
        }
    }
}

/// <p>The details that identify a resource within Config, including the resource type and resource ID. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RemediationExceptionResourceKey {
    /// <p>The type of a resource.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The ID of the resource (for example., sg-xxxxxx).</p>
    #[doc(hidden)]
    pub resource_id: std::option::Option<std::string::String>,
}
impl RemediationExceptionResourceKey {
    /// <p>The type of a resource.</p>
    pub fn resource_type(&self) -> std::option::Option<&str> {
        self.resource_type.as_deref()
    }
    /// <p>The ID of the resource (for example., sg-xxxxxx).</p>
    pub fn resource_id(&self) -> std::option::Option<&str> {
        self.resource_id.as_deref()
    }
}
impl RemediationExceptionResourceKey {
    /// Creates a new builder-style object to manufacture [`RemediationExceptionResourceKey`](crate::model::RemediationExceptionResourceKey).
    pub fn builder() -> crate::model::remediation_exception_resource_key::Builder {
        crate::model::remediation_exception_resource_key::Builder::default()
    }
}

/// See [`RemediationExceptionResourceKey`](crate::model::RemediationExceptionResourceKey).
pub mod remediation_exception_resource_key {

    /// A builder for [`RemediationExceptionResourceKey`](crate::model::RemediationExceptionResourceKey).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of a resource.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The type of a resource.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The ID of the resource (for example., sg-xxxxxx).</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The ID of the resource (for example., sg-xxxxxx).</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// Consumes the builder and constructs a [`RemediationExceptionResourceKey`](crate::model::RemediationExceptionResourceKey).
        pub fn build(self) -> crate::model::RemediationExceptionResourceKey {
            crate::model::RemediationExceptionResourceKey {
                resource_type: self.resource_type,
                resource_id: self.resource_id,
            }
        }
    }
}

/// <p>List of each of the failed remediations with specific reasons.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FailedRemediationBatch {
    /// <p>Returns a failure message. For example, the resource is already compliant.</p>
    #[doc(hidden)]
    pub failure_message: std::option::Option<std::string::String>,
    /// <p>Returns remediation configurations of the failed items.</p>
    #[doc(hidden)]
    pub failed_items: std::option::Option<std::vec::Vec<crate::model::RemediationConfiguration>>,
}
impl FailedRemediationBatch {
    /// <p>Returns a failure message. For example, the resource is already compliant.</p>
    pub fn failure_message(&self) -> std::option::Option<&str> {
        self.failure_message.as_deref()
    }
    /// <p>Returns remediation configurations of the failed items.</p>
    pub fn failed_items(&self) -> std::option::Option<&[crate::model::RemediationConfiguration]> {
        self.failed_items.as_deref()
    }
}
impl FailedRemediationBatch {
    /// Creates a new builder-style object to manufacture [`FailedRemediationBatch`](crate::model::FailedRemediationBatch).
    pub fn builder() -> crate::model::failed_remediation_batch::Builder {
        crate::model::failed_remediation_batch::Builder::default()
    }
}

/// See [`FailedRemediationBatch`](crate::model::FailedRemediationBatch).
pub mod failed_remediation_batch {

    /// A builder for [`FailedRemediationBatch`](crate::model::FailedRemediationBatch).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) failure_message: std::option::Option<std::string::String>,
        pub(crate) failed_items:
            std::option::Option<std::vec::Vec<crate::model::RemediationConfiguration>>,
    }
    impl Builder {
        /// <p>Returns a failure message. For example, the resource is already compliant.</p>
        pub fn failure_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_message = Some(input.into());
            self
        }
        /// <p>Returns a failure message. For example, the resource is already compliant.</p>
        pub fn set_failure_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_message = input;
            self
        }
        /// Appends an item to `failed_items`.
        ///
        /// To override the contents of this collection use [`set_failed_items`](Self::set_failed_items).
        ///
        /// <p>Returns remediation configurations of the failed items.</p>
        pub fn failed_items(mut self, input: crate::model::RemediationConfiguration) -> Self {
            let mut v = self.failed_items.unwrap_or_default();
            v.push(input);
            self.failed_items = Some(v);
            self
        }
        /// <p>Returns remediation configurations of the failed items.</p>
        pub fn set_failed_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RemediationConfiguration>>,
        ) -> Self {
            self.failed_items = input;
            self
        }
        /// Consumes the builder and constructs a [`FailedRemediationBatch`](crate::model::FailedRemediationBatch).
        pub fn build(self) -> crate::model::FailedRemediationBatch {
            crate::model::FailedRemediationBatch {
                failure_message: self.failure_message,
                failed_items: self.failed_items,
            }
        }
    }
}

/// <p>An object that represents the details about the remediation configuration that includes the remediation action, parameters, and data to execute the action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RemediationConfiguration {
    /// <p>The name of the Config rule.</p>
    #[doc(hidden)]
    pub config_rule_name: std::option::Option<std::string::String>,
    /// <p>The type of the target. Target executes remediation. For example, SSM document.</p>
    #[doc(hidden)]
    pub target_type: std::option::Option<crate::model::RemediationTargetType>,
    /// <p>Target ID is the name of the public document.</p>
    #[doc(hidden)]
    pub target_id: std::option::Option<std::string::String>,
    /// <p>Version of the target. For example, version of the SSM document.</p> <note>
    /// <p>If you make backward incompatible changes to the SSM document, you must call PutRemediationConfiguration API again to ensure the remediations can run.</p>
    /// </note>
    #[doc(hidden)]
    pub target_version: std::option::Option<std::string::String>,
    /// <p>An object of the RemediationParameterValue.</p>
    #[doc(hidden)]
    pub parameters: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::RemediationParameterValue>,
    >,
    /// <p>The type of a resource. </p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The remediation is triggered automatically.</p>
    #[doc(hidden)]
    pub automatic: bool,
    /// <p>An ExecutionControls object.</p>
    #[doc(hidden)]
    pub execution_controls: std::option::Option<crate::model::ExecutionControls>,
    /// <p>The maximum number of failed attempts for auto-remediation. If you do not select a number, the default is 5.</p>
    /// <p>For example, if you specify MaximumAutomaticAttempts as 5 with RetryAttemptSeconds as 50 seconds, Config will put a RemediationException on your behalf for the failing resource after the 5th failed attempt within 50 seconds.</p>
    #[doc(hidden)]
    pub maximum_automatic_attempts: std::option::Option<i32>,
    /// <p>Maximum time in seconds that Config runs auto-remediation. If you do not select a number, the default is 60 seconds. </p>
    /// <p>For example, if you specify RetryAttemptSeconds as 50 seconds and MaximumAutomaticAttempts as 5, Config will run auto-remediations 5 times within 50 seconds before throwing an exception.</p>
    #[doc(hidden)]
    pub retry_attempt_seconds: std::option::Option<i64>,
    /// <p>Amazon Resource Name (ARN) of remediation configuration.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Name of the service that owns the service-linked rule, if applicable.</p>
    #[doc(hidden)]
    pub created_by_service: std::option::Option<std::string::String>,
}
impl RemediationConfiguration {
    /// <p>The name of the Config rule.</p>
    pub fn config_rule_name(&self) -> std::option::Option<&str> {
        self.config_rule_name.as_deref()
    }
    /// <p>The type of the target. Target executes remediation. For example, SSM document.</p>
    pub fn target_type(&self) -> std::option::Option<&crate::model::RemediationTargetType> {
        self.target_type.as_ref()
    }
    /// <p>Target ID is the name of the public document.</p>
    pub fn target_id(&self) -> std::option::Option<&str> {
        self.target_id.as_deref()
    }
    /// <p>Version of the target. For example, version of the SSM document.</p> <note>
    /// <p>If you make backward incompatible changes to the SSM document, you must call PutRemediationConfiguration API again to ensure the remediations can run.</p>
    /// </note>
    pub fn target_version(&self) -> std::option::Option<&str> {
        self.target_version.as_deref()
    }
    /// <p>An object of the RemediationParameterValue.</p>
    pub fn parameters(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::RemediationParameterValue>,
    > {
        self.parameters.as_ref()
    }
    /// <p>The type of a resource. </p>
    pub fn resource_type(&self) -> std::option::Option<&str> {
        self.resource_type.as_deref()
    }
    /// <p>The remediation is triggered automatically.</p>
    pub fn automatic(&self) -> bool {
        self.automatic
    }
    /// <p>An ExecutionControls object.</p>
    pub fn execution_controls(&self) -> std::option::Option<&crate::model::ExecutionControls> {
        self.execution_controls.as_ref()
    }
    /// <p>The maximum number of failed attempts for auto-remediation. If you do not select a number, the default is 5.</p>
    /// <p>For example, if you specify MaximumAutomaticAttempts as 5 with RetryAttemptSeconds as 50 seconds, Config will put a RemediationException on your behalf for the failing resource after the 5th failed attempt within 50 seconds.</p>
    pub fn maximum_automatic_attempts(&self) -> std::option::Option<i32> {
        self.maximum_automatic_attempts
    }
    /// <p>Maximum time in seconds that Config runs auto-remediation. If you do not select a number, the default is 60 seconds. </p>
    /// <p>For example, if you specify RetryAttemptSeconds as 50 seconds and MaximumAutomaticAttempts as 5, Config will run auto-remediations 5 times within 50 seconds before throwing an exception.</p>
    pub fn retry_attempt_seconds(&self) -> std::option::Option<i64> {
        self.retry_attempt_seconds
    }
    /// <p>Amazon Resource Name (ARN) of remediation configuration.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>Name of the service that owns the service-linked rule, if applicable.</p>
    pub fn created_by_service(&self) -> std::option::Option<&str> {
        self.created_by_service.as_deref()
    }
}
impl RemediationConfiguration {
    /// Creates a new builder-style object to manufacture [`RemediationConfiguration`](crate::model::RemediationConfiguration).
    pub fn builder() -> crate::model::remediation_configuration::Builder {
        crate::model::remediation_configuration::Builder::default()
    }
}

/// See [`RemediationConfiguration`](crate::model::RemediationConfiguration).
pub mod remediation_configuration {

    /// A builder for [`RemediationConfiguration`](crate::model::RemediationConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) config_rule_name: std::option::Option<std::string::String>,
        pub(crate) target_type: std::option::Option<crate::model::RemediationTargetType>,
        pub(crate) target_id: std::option::Option<std::string::String>,
        pub(crate) target_version: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::RemediationParameterValue>,
        >,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) automatic: std::option::Option<bool>,
        pub(crate) execution_controls: std::option::Option<crate::model::ExecutionControls>,
        pub(crate) maximum_automatic_attempts: std::option::Option<i32>,
        pub(crate) retry_attempt_seconds: std::option::Option<i64>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) created_by_service: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Config rule.</p>
        pub fn config_rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.config_rule_name = Some(input.into());
            self
        }
        /// <p>The name of the Config rule.</p>
        pub fn set_config_rule_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.config_rule_name = input;
            self
        }
        /// <p>The type of the target. Target executes remediation. For example, SSM document.</p>
        pub fn target_type(mut self, input: crate::model::RemediationTargetType) -> Self {
            self.target_type = Some(input);
            self
        }
        /// <p>The type of the target. Target executes remediation. For example, SSM document.</p>
        pub fn set_target_type(
            mut self,
            input: std::option::Option<crate::model::RemediationTargetType>,
        ) -> Self {
            self.target_type = input;
            self
        }
        /// <p>Target ID is the name of the public document.</p>
        pub fn target_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_id = Some(input.into());
            self
        }
        /// <p>Target ID is the name of the public document.</p>
        pub fn set_target_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_id = input;
            self
        }
        /// <p>Version of the target. For example, version of the SSM document.</p> <note>
        /// <p>If you make backward incompatible changes to the SSM document, you must call PutRemediationConfiguration API again to ensure the remediations can run.</p>
        /// </note>
        pub fn target_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_version = Some(input.into());
            self
        }
        /// <p>Version of the target. For example, version of the SSM document.</p> <note>
        /// <p>If you make backward incompatible changes to the SSM document, you must call PutRemediationConfiguration API again to ensure the remediations can run.</p>
        /// </note>
        pub fn set_target_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_version = input;
            self
        }
        /// Adds a key-value pair to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>An object of the RemediationParameterValue.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::RemediationParameterValue,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.parameters = Some(hash_map);
            self
        }
        /// <p>An object of the RemediationParameterValue.</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::RemediationParameterValue,
                >,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// <p>The type of a resource. </p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The type of a resource. </p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The remediation is triggered automatically.</p>
        pub fn automatic(mut self, input: bool) -> Self {
            self.automatic = Some(input);
            self
        }
        /// <p>The remediation is triggered automatically.</p>
        pub fn set_automatic(mut self, input: std::option::Option<bool>) -> Self {
            self.automatic = input;
            self
        }
        /// <p>An ExecutionControls object.</p>
        pub fn execution_controls(mut self, input: crate::model::ExecutionControls) -> Self {
            self.execution_controls = Some(input);
            self
        }
        /// <p>An ExecutionControls object.</p>
        pub fn set_execution_controls(
            mut self,
            input: std::option::Option<crate::model::ExecutionControls>,
        ) -> Self {
            self.execution_controls = input;
            self
        }
        /// <p>The maximum number of failed attempts for auto-remediation. If you do not select a number, the default is 5.</p>
        /// <p>For example, if you specify MaximumAutomaticAttempts as 5 with RetryAttemptSeconds as 50 seconds, Config will put a RemediationException on your behalf for the failing resource after the 5th failed attempt within 50 seconds.</p>
        pub fn maximum_automatic_attempts(mut self, input: i32) -> Self {
            self.maximum_automatic_attempts = Some(input);
            self
        }
        /// <p>The maximum number of failed attempts for auto-remediation. If you do not select a number, the default is 5.</p>
        /// <p>For example, if you specify MaximumAutomaticAttempts as 5 with RetryAttemptSeconds as 50 seconds, Config will put a RemediationException on your behalf for the failing resource after the 5th failed attempt within 50 seconds.</p>
        pub fn set_maximum_automatic_attempts(mut self, input: std::option::Option<i32>) -> Self {
            self.maximum_automatic_attempts = input;
            self
        }
        /// <p>Maximum time in seconds that Config runs auto-remediation. If you do not select a number, the default is 60 seconds. </p>
        /// <p>For example, if you specify RetryAttemptSeconds as 50 seconds and MaximumAutomaticAttempts as 5, Config will run auto-remediations 5 times within 50 seconds before throwing an exception.</p>
        pub fn retry_attempt_seconds(mut self, input: i64) -> Self {
            self.retry_attempt_seconds = Some(input);
            self
        }
        /// <p>Maximum time in seconds that Config runs auto-remediation. If you do not select a number, the default is 60 seconds. </p>
        /// <p>For example, if you specify RetryAttemptSeconds as 50 seconds and MaximumAutomaticAttempts as 5, Config will run auto-remediations 5 times within 50 seconds before throwing an exception.</p>
        pub fn set_retry_attempt_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.retry_attempt_seconds = input;
            self
        }
        /// <p>Amazon Resource Name (ARN) of remediation configuration.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Amazon Resource Name (ARN) of remediation configuration.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>Name of the service that owns the service-linked rule, if applicable.</p>
        pub fn created_by_service(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by_service = Some(input.into());
            self
        }
        /// <p>Name of the service that owns the service-linked rule, if applicable.</p>
        pub fn set_created_by_service(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.created_by_service = input;
            self
        }
        /// Consumes the builder and constructs a [`RemediationConfiguration`](crate::model::RemediationConfiguration).
        pub fn build(self) -> crate::model::RemediationConfiguration {
            crate::model::RemediationConfiguration {
                config_rule_name: self.config_rule_name,
                target_type: self.target_type,
                target_id: self.target_id,
                target_version: self.target_version,
                parameters: self.parameters,
                resource_type: self.resource_type,
                automatic: self.automatic.unwrap_or_default(),
                execution_controls: self.execution_controls,
                maximum_automatic_attempts: self.maximum_automatic_attempts,
                retry_attempt_seconds: self.retry_attempt_seconds,
                arn: self.arn,
                created_by_service: self.created_by_service,
            }
        }
    }
}

/// <p>The controls that Config uses for executing remediations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExecutionControls {
    /// <p>A SsmControls object.</p>
    #[doc(hidden)]
    pub ssm_controls: std::option::Option<crate::model::SsmControls>,
}
impl ExecutionControls {
    /// <p>A SsmControls object.</p>
    pub fn ssm_controls(&self) -> std::option::Option<&crate::model::SsmControls> {
        self.ssm_controls.as_ref()
    }
}
impl ExecutionControls {
    /// Creates a new builder-style object to manufacture [`ExecutionControls`](crate::model::ExecutionControls).
    pub fn builder() -> crate::model::execution_controls::Builder {
        crate::model::execution_controls::Builder::default()
    }
}

/// See [`ExecutionControls`](crate::model::ExecutionControls).
pub mod execution_controls {

    /// A builder for [`ExecutionControls`](crate::model::ExecutionControls).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ssm_controls: std::option::Option<crate::model::SsmControls>,
    }
    impl Builder {
        /// <p>A SsmControls object.</p>
        pub fn ssm_controls(mut self, input: crate::model::SsmControls) -> Self {
            self.ssm_controls = Some(input);
            self
        }
        /// <p>A SsmControls object.</p>
        pub fn set_ssm_controls(
            mut self,
            input: std::option::Option<crate::model::SsmControls>,
        ) -> Self {
            self.ssm_controls = input;
            self
        }
        /// Consumes the builder and constructs a [`ExecutionControls`](crate::model::ExecutionControls).
        pub fn build(self) -> crate::model::ExecutionControls {
            crate::model::ExecutionControls {
                ssm_controls: self.ssm_controls,
            }
        }
    }
}

/// <p>Amazon Web Services Systems Manager (SSM) specific remediation controls.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SsmControls {
    /// <p>The maximum percentage of remediation actions allowed to run in parallel on the non-compliant resources for that specific rule. You can specify a percentage, such as 10%. The default value is 10. </p>
    #[doc(hidden)]
    pub concurrent_execution_rate_percentage: std::option::Option<i32>,
    /// <p>The percentage of errors that are allowed before SSM stops running automations on non-compliant resources for that specific rule. You can specify a percentage of errors, for example 10%. If you do not specifiy a percentage, the default is 50%. For example, if you set the ErrorPercentage to 40% for 10 non-compliant resources, then SSM stops running the automations when the fifth error is received. </p>
    #[doc(hidden)]
    pub error_percentage: std::option::Option<i32>,
}
impl SsmControls {
    /// <p>The maximum percentage of remediation actions allowed to run in parallel on the non-compliant resources for that specific rule. You can specify a percentage, such as 10%. The default value is 10. </p>
    pub fn concurrent_execution_rate_percentage(&self) -> std::option::Option<i32> {
        self.concurrent_execution_rate_percentage
    }
    /// <p>The percentage of errors that are allowed before SSM stops running automations on non-compliant resources for that specific rule. You can specify a percentage of errors, for example 10%. If you do not specifiy a percentage, the default is 50%. For example, if you set the ErrorPercentage to 40% for 10 non-compliant resources, then SSM stops running the automations when the fifth error is received. </p>
    pub fn error_percentage(&self) -> std::option::Option<i32> {
        self.error_percentage
    }
}
impl SsmControls {
    /// Creates a new builder-style object to manufacture [`SsmControls`](crate::model::SsmControls).
    pub fn builder() -> crate::model::ssm_controls::Builder {
        crate::model::ssm_controls::Builder::default()
    }
}

/// See [`SsmControls`](crate::model::SsmControls).
pub mod ssm_controls {

    /// A builder for [`SsmControls`](crate::model::SsmControls).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) concurrent_execution_rate_percentage: std::option::Option<i32>,
        pub(crate) error_percentage: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The maximum percentage of remediation actions allowed to run in parallel on the non-compliant resources for that specific rule. You can specify a percentage, such as 10%. The default value is 10. </p>
        pub fn concurrent_execution_rate_percentage(mut self, input: i32) -> Self {
            self.concurrent_execution_rate_percentage = Some(input);
            self
        }
        /// <p>The maximum percentage of remediation actions allowed to run in parallel on the non-compliant resources for that specific rule. You can specify a percentage, such as 10%. The default value is 10. </p>
        pub fn set_concurrent_execution_rate_percentage(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.concurrent_execution_rate_percentage = input;
            self
        }
        /// <p>The percentage of errors that are allowed before SSM stops running automations on non-compliant resources for that specific rule. You can specify a percentage of errors, for example 10%. If you do not specifiy a percentage, the default is 50%. For example, if you set the ErrorPercentage to 40% for 10 non-compliant resources, then SSM stops running the automations when the fifth error is received. </p>
        pub fn error_percentage(mut self, input: i32) -> Self {
            self.error_percentage = Some(input);
            self
        }
        /// <p>The percentage of errors that are allowed before SSM stops running automations on non-compliant resources for that specific rule. You can specify a percentage of errors, for example 10%. If you do not specifiy a percentage, the default is 50%. For example, if you set the ErrorPercentage to 40% for 10 non-compliant resources, then SSM stops running the automations when the fifth error is received. </p>
        pub fn set_error_percentage(mut self, input: std::option::Option<i32>) -> Self {
            self.error_percentage = input;
            self
        }
        /// Consumes the builder and constructs a [`SsmControls`](crate::model::SsmControls).
        pub fn build(self) -> crate::model::SsmControls {
            crate::model::SsmControls {
                concurrent_execution_rate_percentage: self.concurrent_execution_rate_percentage,
                error_percentage: self.error_percentage,
            }
        }
    }
}

/// <p>The value is either a dynamic (resource) value or a static value. You must select either a dynamic value or a static value.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RemediationParameterValue {
    /// <p>The value is dynamic and changes at run-time.</p>
    #[doc(hidden)]
    pub resource_value: std::option::Option<crate::model::ResourceValue>,
    /// <p>The value is static and does not change at run-time.</p>
    #[doc(hidden)]
    pub static_value: std::option::Option<crate::model::StaticValue>,
}
impl RemediationParameterValue {
    /// <p>The value is dynamic and changes at run-time.</p>
    pub fn resource_value(&self) -> std::option::Option<&crate::model::ResourceValue> {
        self.resource_value.as_ref()
    }
    /// <p>The value is static and does not change at run-time.</p>
    pub fn static_value(&self) -> std::option::Option<&crate::model::StaticValue> {
        self.static_value.as_ref()
    }
}
impl RemediationParameterValue {
    /// Creates a new builder-style object to manufacture [`RemediationParameterValue`](crate::model::RemediationParameterValue).
    pub fn builder() -> crate::model::remediation_parameter_value::Builder {
        crate::model::remediation_parameter_value::Builder::default()
    }
}

/// See [`RemediationParameterValue`](crate::model::RemediationParameterValue).
pub mod remediation_parameter_value {

    /// A builder for [`RemediationParameterValue`](crate::model::RemediationParameterValue).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_value: std::option::Option<crate::model::ResourceValue>,
        pub(crate) static_value: std::option::Option<crate::model::StaticValue>,
    }
    impl Builder {
        /// <p>The value is dynamic and changes at run-time.</p>
        pub fn resource_value(mut self, input: crate::model::ResourceValue) -> Self {
            self.resource_value = Some(input);
            self
        }
        /// <p>The value is dynamic and changes at run-time.</p>
        pub fn set_resource_value(
            mut self,
            input: std::option::Option<crate::model::ResourceValue>,
        ) -> Self {
            self.resource_value = input;
            self
        }
        /// <p>The value is static and does not change at run-time.</p>
        pub fn static_value(mut self, input: crate::model::StaticValue) -> Self {
            self.static_value = Some(input);
            self
        }
        /// <p>The value is static and does not change at run-time.</p>
        pub fn set_static_value(
            mut self,
            input: std::option::Option<crate::model::StaticValue>,
        ) -> Self {
            self.static_value = input;
            self
        }
        /// Consumes the builder and constructs a [`RemediationParameterValue`](crate::model::RemediationParameterValue).
        pub fn build(self) -> crate::model::RemediationParameterValue {
            crate::model::RemediationParameterValue {
                resource_value: self.resource_value,
                static_value: self.static_value,
            }
        }
    }
}

/// <p>The static value of the resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StaticValue {
    /// <p>A list of values. For example, the ARN of the assumed role. </p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl StaticValue {
    /// <p>A list of values. For example, the ARN of the assumed role. </p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
}
impl StaticValue {
    /// Creates a new builder-style object to manufacture [`StaticValue`](crate::model::StaticValue).
    pub fn builder() -> crate::model::static_value::Builder {
        crate::model::static_value::Builder::default()
    }
}

/// See [`StaticValue`](crate::model::StaticValue).
pub mod static_value {

    /// A builder for [`StaticValue`](crate::model::StaticValue).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>A list of values. For example, the ARN of the assumed role. </p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>A list of values. For example, the ARN of the assumed role. </p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`StaticValue`](crate::model::StaticValue).
        pub fn build(self) -> crate::model::StaticValue {
            crate::model::StaticValue {
                values: self.values,
            }
        }
    }
}

/// <p>The dynamic value of the resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceValue {
    /// <p>The value is a resource ID.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::ResourceValueType>,
}
impl ResourceValue {
    /// <p>The value is a resource ID.</p>
    pub fn value(&self) -> std::option::Option<&crate::model::ResourceValueType> {
        self.value.as_ref()
    }
}
impl ResourceValue {
    /// Creates a new builder-style object to manufacture [`ResourceValue`](crate::model::ResourceValue).
    pub fn builder() -> crate::model::resource_value::Builder {
        crate::model::resource_value::Builder::default()
    }
}

/// See [`ResourceValue`](crate::model::ResourceValue).
pub mod resource_value {

    /// A builder for [`ResourceValue`](crate::model::ResourceValue).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<crate::model::ResourceValueType>,
    }
    impl Builder {
        /// <p>The value is a resource ID.</p>
        pub fn value(mut self, input: crate::model::ResourceValueType) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value is a resource ID.</p>
        pub fn set_value(
            mut self,
            input: std::option::Option<crate::model::ResourceValueType>,
        ) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceValue`](crate::model::ResourceValue).
        pub fn build(self) -> crate::model::ResourceValue {
            crate::model::ResourceValue { value: self.value }
        }
    }
}

/// When writing a match expression against `ResourceValueType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourcevaluetype = unimplemented!();
/// match resourcevaluetype {
///     ResourceValueType::ResourceId => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourcevaluetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceValueType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceValueType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceValueType::NewFeature` is defined.
/// Specifically, when `resourcevaluetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceValueType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceValueType {
    #[allow(missing_docs)] // documentation missing in model
    ResourceId,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceValueType {
    fn from(s: &str) -> Self {
        match s {
            "RESOURCE_ID" => ResourceValueType::ResourceId,
            other => {
                ResourceValueType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ResourceValueType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceValueType::from(s))
    }
}
impl ResourceValueType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceValueType::ResourceId => "RESOURCE_ID",
            ResourceValueType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["RESOURCE_ID"]
    }
}
impl AsRef<str> for ResourceValueType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `RemediationTargetType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let remediationtargettype = unimplemented!();
/// match remediationtargettype {
///     RemediationTargetType::SsmDocument => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `remediationtargettype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RemediationTargetType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RemediationTargetType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RemediationTargetType::NewFeature` is defined.
/// Specifically, when `remediationtargettype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RemediationTargetType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RemediationTargetType {
    #[allow(missing_docs)] // documentation missing in model
    SsmDocument,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RemediationTargetType {
    fn from(s: &str) -> Self {
        match s {
            "SSM_DOCUMENT" => RemediationTargetType::SsmDocument,
            other => {
                RemediationTargetType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for RemediationTargetType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RemediationTargetType::from(s))
    }
}
impl RemediationTargetType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RemediationTargetType::SsmDocument => "SSM_DOCUMENT",
            RemediationTargetType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SSM_DOCUMENT"]
    }
}
impl AsRef<str> for RemediationTargetType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Input parameters in the form of key-value pairs for the conformance pack, both of which you define. Keys can have a maximum character length of 255 characters, and values can have a maximum length of 4096 characters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConformancePackInputParameter {
    /// <p>One part of a key-value pair.</p>
    #[doc(hidden)]
    pub parameter_name: std::option::Option<std::string::String>,
    /// <p>Another part of the key-value pair. </p>
    #[doc(hidden)]
    pub parameter_value: std::option::Option<std::string::String>,
}
impl ConformancePackInputParameter {
    /// <p>One part of a key-value pair.</p>
    pub fn parameter_name(&self) -> std::option::Option<&str> {
        self.parameter_name.as_deref()
    }
    /// <p>Another part of the key-value pair. </p>
    pub fn parameter_value(&self) -> std::option::Option<&str> {
        self.parameter_value.as_deref()
    }
}
impl ConformancePackInputParameter {
    /// Creates a new builder-style object to manufacture [`ConformancePackInputParameter`](crate::model::ConformancePackInputParameter).
    pub fn builder() -> crate::model::conformance_pack_input_parameter::Builder {
        crate::model::conformance_pack_input_parameter::Builder::default()
    }
}

/// See [`ConformancePackInputParameter`](crate::model::ConformancePackInputParameter).
pub mod conformance_pack_input_parameter {

    /// A builder for [`ConformancePackInputParameter`](crate::model::ConformancePackInputParameter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_name: std::option::Option<std::string::String>,
        pub(crate) parameter_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>One part of a key-value pair.</p>
        pub fn parameter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_name = Some(input.into());
            self
        }
        /// <p>One part of a key-value pair.</p>
        pub fn set_parameter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_name = input;
            self
        }
        /// <p>Another part of the key-value pair. </p>
        pub fn parameter_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_value = Some(input.into());
            self
        }
        /// <p>Another part of the key-value pair. </p>
        pub fn set_parameter_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_value = input;
            self
        }
        /// Consumes the builder and constructs a [`ConformancePackInputParameter`](crate::model::ConformancePackInputParameter).
        pub fn build(self) -> crate::model::ConformancePackInputParameter {
            crate::model::ConformancePackInputParameter {
                parameter_name: self.parameter_name,
                parameter_value: self.parameter_value,
            }
        }
    }
}

/// <p>An object that specifies metadata for your organization's Config Custom Policy rule. The metadata includes the runtime system in use, which accounts have debug logging enabled, and other custom rule metadata, such as resource type, resource ID of Amazon Web Services resource, and organization trigger types that initiate Config to evaluate Amazon Web Services resources against a rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OrganizationCustomPolicyRuleMetadata {
    /// <p>The description that you provide for your organization Config Custom Policy rule.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of notification that initiates Config to run an evaluation for a rule. For Config Custom Policy rules, Config supports change-initiated notification types:</p>
    /// <ul>
    /// <li> <p> <code>ConfigurationItemChangeNotification</code> - Initiates an evaluation when Config delivers a configuration item as a result of a resource change.</p> </li>
    /// <li> <p> <code>OversizedConfigurationItemChangeNotification</code> - Initiates an evaluation when Config delivers an oversized configuration item. Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub organization_config_rule_trigger_types:
        std::option::Option<std::vec::Vec<crate::model::OrganizationConfigRuleTriggerTypeNoSn>>,
    /// <p>A string, in JSON format, that is passed to your organization Config Custom Policy rule.</p>
    #[doc(hidden)]
    pub input_parameters: std::option::Option<std::string::String>,
    /// <p>The maximum frequency with which Config runs evaluations for a rule. Your Config Custom Policy rule is triggered when Config delivers the configuration snapshot. For more information, see <code>ConfigSnapshotDeliveryProperties</code>.</p>
    #[doc(hidden)]
    pub maximum_execution_frequency: std::option::Option<crate::model::MaximumExecutionFrequency>,
    /// <p>The type of the Amazon Web Services resource that was evaluated.</p>
    #[doc(hidden)]
    pub resource_types_scope: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the Amazon Web Services resource that was evaluated.</p>
    #[doc(hidden)]
    pub resource_id_scope: std::option::Option<std::string::String>,
    /// <p>One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.</p>
    #[doc(hidden)]
    pub tag_key_scope: std::option::Option<std::string::String>,
    /// <p>The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).</p>
    #[doc(hidden)]
    pub tag_value_scope: std::option::Option<std::string::String>,
    /// <p>The runtime system for your organization Config Custom Policy rules. Guard is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. For more information about Guard, see the <a href="https://github.com/aws-cloudformation/cloudformation-guard">Guard GitHub Repository</a>.</p>
    #[doc(hidden)]
    pub policy_runtime: std::option::Option<std::string::String>,
    /// <p>The policy definition containing the logic for your organization Config Custom Policy rule.</p>
    #[doc(hidden)]
    pub policy_text: std::option::Option<std::string::String>,
    /// <p>A list of accounts that you can enable debug logging for your organization Config Custom Policy rule. List is null when debug logging is enabled for all accounts.</p>
    #[doc(hidden)]
    pub debug_log_delivery_accounts: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl OrganizationCustomPolicyRuleMetadata {
    /// <p>The description that you provide for your organization Config Custom Policy rule.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of notification that initiates Config to run an evaluation for a rule. For Config Custom Policy rules, Config supports change-initiated notification types:</p>
    /// <ul>
    /// <li> <p> <code>ConfigurationItemChangeNotification</code> - Initiates an evaluation when Config delivers a configuration item as a result of a resource change.</p> </li>
    /// <li> <p> <code>OversizedConfigurationItemChangeNotification</code> - Initiates an evaluation when Config delivers an oversized configuration item. Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.</p> </li>
    /// </ul>
    pub fn organization_config_rule_trigger_types(
        &self,
    ) -> std::option::Option<&[crate::model::OrganizationConfigRuleTriggerTypeNoSn]> {
        self.organization_config_rule_trigger_types.as_deref()
    }
    /// <p>A string, in JSON format, that is passed to your organization Config Custom Policy rule.</p>
    pub fn input_parameters(&self) -> std::option::Option<&str> {
        self.input_parameters.as_deref()
    }
    /// <p>The maximum frequency with which Config runs evaluations for a rule. Your Config Custom Policy rule is triggered when Config delivers the configuration snapshot. For more information, see <code>ConfigSnapshotDeliveryProperties</code>.</p>
    pub fn maximum_execution_frequency(
        &self,
    ) -> std::option::Option<&crate::model::MaximumExecutionFrequency> {
        self.maximum_execution_frequency.as_ref()
    }
    /// <p>The type of the Amazon Web Services resource that was evaluated.</p>
    pub fn resource_types_scope(&self) -> std::option::Option<&[std::string::String]> {
        self.resource_types_scope.as_deref()
    }
    /// <p>The ID of the Amazon Web Services resource that was evaluated.</p>
    pub fn resource_id_scope(&self) -> std::option::Option<&str> {
        self.resource_id_scope.as_deref()
    }
    /// <p>One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.</p>
    pub fn tag_key_scope(&self) -> std::option::Option<&str> {
        self.tag_key_scope.as_deref()
    }
    /// <p>The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).</p>
    pub fn tag_value_scope(&self) -> std::option::Option<&str> {
        self.tag_value_scope.as_deref()
    }
    /// <p>The runtime system for your organization Config Custom Policy rules. Guard is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. For more information about Guard, see the <a href="https://github.com/aws-cloudformation/cloudformation-guard">Guard GitHub Repository</a>.</p>
    pub fn policy_runtime(&self) -> std::option::Option<&str> {
        self.policy_runtime.as_deref()
    }
    /// <p>The policy definition containing the logic for your organization Config Custom Policy rule.</p>
    pub fn policy_text(&self) -> std::option::Option<&str> {
        self.policy_text.as_deref()
    }
    /// <p>A list of accounts that you can enable debug logging for your organization Config Custom Policy rule. List is null when debug logging is enabled for all accounts.</p>
    pub fn debug_log_delivery_accounts(&self) -> std::option::Option<&[std::string::String]> {
        self.debug_log_delivery_accounts.as_deref()
    }
}
impl OrganizationCustomPolicyRuleMetadata {
    /// Creates a new builder-style object to manufacture [`OrganizationCustomPolicyRuleMetadata`](crate::model::OrganizationCustomPolicyRuleMetadata).
    pub fn builder() -> crate::model::organization_custom_policy_rule_metadata::Builder {
        crate::model::organization_custom_policy_rule_metadata::Builder::default()
    }
}

/// See [`OrganizationCustomPolicyRuleMetadata`](crate::model::OrganizationCustomPolicyRuleMetadata).
pub mod organization_custom_policy_rule_metadata {

    /// A builder for [`OrganizationCustomPolicyRuleMetadata`](crate::model::OrganizationCustomPolicyRuleMetadata).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) organization_config_rule_trigger_types:
            std::option::Option<std::vec::Vec<crate::model::OrganizationConfigRuleTriggerTypeNoSn>>,
        pub(crate) input_parameters: std::option::Option<std::string::String>,
        pub(crate) maximum_execution_frequency:
            std::option::Option<crate::model::MaximumExecutionFrequency>,
        pub(crate) resource_types_scope: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) resource_id_scope: std::option::Option<std::string::String>,
        pub(crate) tag_key_scope: std::option::Option<std::string::String>,
        pub(crate) tag_value_scope: std::option::Option<std::string::String>,
        pub(crate) policy_runtime: std::option::Option<std::string::String>,
        pub(crate) policy_text: std::option::Option<std::string::String>,
        pub(crate) debug_log_delivery_accounts:
            std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The description that you provide for your organization Config Custom Policy rule.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description that you provide for your organization Config Custom Policy rule.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `organization_config_rule_trigger_types`.
        ///
        /// To override the contents of this collection use [`set_organization_config_rule_trigger_types`](Self::set_organization_config_rule_trigger_types).
        ///
        /// <p>The type of notification that initiates Config to run an evaluation for a rule. For Config Custom Policy rules, Config supports change-initiated notification types:</p>
        /// <ul>
        /// <li> <p> <code>ConfigurationItemChangeNotification</code> - Initiates an evaluation when Config delivers a configuration item as a result of a resource change.</p> </li>
        /// <li> <p> <code>OversizedConfigurationItemChangeNotification</code> - Initiates an evaluation when Config delivers an oversized configuration item. Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.</p> </li>
        /// </ul>
        pub fn organization_config_rule_trigger_types(
            mut self,
            input: crate::model::OrganizationConfigRuleTriggerTypeNoSn,
        ) -> Self {
            let mut v = self
                .organization_config_rule_trigger_types
                .unwrap_or_default();
            v.push(input);
            self.organization_config_rule_trigger_types = Some(v);
            self
        }
        /// <p>The type of notification that initiates Config to run an evaluation for a rule. For Config Custom Policy rules, Config supports change-initiated notification types:</p>
        /// <ul>
        /// <li> <p> <code>ConfigurationItemChangeNotification</code> - Initiates an evaluation when Config delivers a configuration item as a result of a resource change.</p> </li>
        /// <li> <p> <code>OversizedConfigurationItemChangeNotification</code> - Initiates an evaluation when Config delivers an oversized configuration item. Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.</p> </li>
        /// </ul>
        pub fn set_organization_config_rule_trigger_types(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::OrganizationConfigRuleTriggerTypeNoSn>,
            >,
        ) -> Self {
            self.organization_config_rule_trigger_types = input;
            self
        }
        /// <p>A string, in JSON format, that is passed to your organization Config Custom Policy rule.</p>
        pub fn input_parameters(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_parameters = Some(input.into());
            self
        }
        /// <p>A string, in JSON format, that is passed to your organization Config Custom Policy rule.</p>
        pub fn set_input_parameters(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.input_parameters = input;
            self
        }
        /// <p>The maximum frequency with which Config runs evaluations for a rule. Your Config Custom Policy rule is triggered when Config delivers the configuration snapshot. For more information, see <code>ConfigSnapshotDeliveryProperties</code>.</p>
        pub fn maximum_execution_frequency(
            mut self,
            input: crate::model::MaximumExecutionFrequency,
        ) -> Self {
            self.maximum_execution_frequency = Some(input);
            self
        }
        /// <p>The maximum frequency with which Config runs evaluations for a rule. Your Config Custom Policy rule is triggered when Config delivers the configuration snapshot. For more information, see <code>ConfigSnapshotDeliveryProperties</code>.</p>
        pub fn set_maximum_execution_frequency(
            mut self,
            input: std::option::Option<crate::model::MaximumExecutionFrequency>,
        ) -> Self {
            self.maximum_execution_frequency = input;
            self
        }
        /// Appends an item to `resource_types_scope`.
        ///
        /// To override the contents of this collection use [`set_resource_types_scope`](Self::set_resource_types_scope).
        ///
        /// <p>The type of the Amazon Web Services resource that was evaluated.</p>
        pub fn resource_types_scope(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.resource_types_scope.unwrap_or_default();
            v.push(input.into());
            self.resource_types_scope = Some(v);
            self
        }
        /// <p>The type of the Amazon Web Services resource that was evaluated.</p>
        pub fn set_resource_types_scope(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.resource_types_scope = input;
            self
        }
        /// <p>The ID of the Amazon Web Services resource that was evaluated.</p>
        pub fn resource_id_scope(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id_scope = Some(input.into());
            self
        }
        /// <p>The ID of the Amazon Web Services resource that was evaluated.</p>
        pub fn set_resource_id_scope(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_id_scope = input;
            self
        }
        /// <p>One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.</p>
        pub fn tag_key_scope(mut self, input: impl Into<std::string::String>) -> Self {
            self.tag_key_scope = Some(input.into());
            self
        }
        /// <p>One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.</p>
        pub fn set_tag_key_scope(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tag_key_scope = input;
            self
        }
        /// <p>The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).</p>
        pub fn tag_value_scope(mut self, input: impl Into<std::string::String>) -> Self {
            self.tag_value_scope = Some(input.into());
            self
        }
        /// <p>The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).</p>
        pub fn set_tag_value_scope(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tag_value_scope = input;
            self
        }
        /// <p>The runtime system for your organization Config Custom Policy rules. Guard is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. For more information about Guard, see the <a href="https://github.com/aws-cloudformation/cloudformation-guard">Guard GitHub Repository</a>.</p>
        pub fn policy_runtime(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_runtime = Some(input.into());
            self
        }
        /// <p>The runtime system for your organization Config Custom Policy rules. Guard is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. For more information about Guard, see the <a href="https://github.com/aws-cloudformation/cloudformation-guard">Guard GitHub Repository</a>.</p>
        pub fn set_policy_runtime(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_runtime = input;
            self
        }
        /// <p>The policy definition containing the logic for your organization Config Custom Policy rule.</p>
        pub fn policy_text(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_text = Some(input.into());
            self
        }
        /// <p>The policy definition containing the logic for your organization Config Custom Policy rule.</p>
        pub fn set_policy_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_text = input;
            self
        }
        /// Appends an item to `debug_log_delivery_accounts`.
        ///
        /// To override the contents of this collection use [`set_debug_log_delivery_accounts`](Self::set_debug_log_delivery_accounts).
        ///
        /// <p>A list of accounts that you can enable debug logging for your organization Config Custom Policy rule. List is null when debug logging is enabled for all accounts.</p>
        pub fn debug_log_delivery_accounts(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.debug_log_delivery_accounts.unwrap_or_default();
            v.push(input.into());
            self.debug_log_delivery_accounts = Some(v);
            self
        }
        /// <p>A list of accounts that you can enable debug logging for your organization Config Custom Policy rule. List is null when debug logging is enabled for all accounts.</p>
        pub fn set_debug_log_delivery_accounts(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.debug_log_delivery_accounts = input;
            self
        }
        /// Consumes the builder and constructs a [`OrganizationCustomPolicyRuleMetadata`](crate::model::OrganizationCustomPolicyRuleMetadata).
        pub fn build(self) -> crate::model::OrganizationCustomPolicyRuleMetadata {
            crate::model::OrganizationCustomPolicyRuleMetadata {
                description: self.description,
                organization_config_rule_trigger_types: self.organization_config_rule_trigger_types,
                input_parameters: self.input_parameters,
                maximum_execution_frequency: self.maximum_execution_frequency,
                resource_types_scope: self.resource_types_scope,
                resource_id_scope: self.resource_id_scope,
                tag_key_scope: self.tag_key_scope,
                tag_value_scope: self.tag_value_scope,
                policy_runtime: self.policy_runtime,
                policy_text: self.policy_text,
                debug_log_delivery_accounts: self.debug_log_delivery_accounts,
            }
        }
    }
}

/// When writing a match expression against `MaximumExecutionFrequency`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let maximumexecutionfrequency = unimplemented!();
/// match maximumexecutionfrequency {
///     MaximumExecutionFrequency::OneHour => { /* ... */ },
///     MaximumExecutionFrequency::SixHours => { /* ... */ },
///     MaximumExecutionFrequency::ThreeHours => { /* ... */ },
///     MaximumExecutionFrequency::TwelveHours => { /* ... */ },
///     MaximumExecutionFrequency::TwentyFourHours => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `maximumexecutionfrequency` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MaximumExecutionFrequency::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MaximumExecutionFrequency::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MaximumExecutionFrequency::NewFeature` is defined.
/// Specifically, when `maximumexecutionfrequency` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MaximumExecutionFrequency::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MaximumExecutionFrequency {
    #[allow(missing_docs)] // documentation missing in model
    OneHour,
    #[allow(missing_docs)] // documentation missing in model
    SixHours,
    #[allow(missing_docs)] // documentation missing in model
    ThreeHours,
    #[allow(missing_docs)] // documentation missing in model
    TwelveHours,
    #[allow(missing_docs)] // documentation missing in model
    TwentyFourHours,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MaximumExecutionFrequency {
    fn from(s: &str) -> Self {
        match s {
            "One_Hour" => MaximumExecutionFrequency::OneHour,
            "Six_Hours" => MaximumExecutionFrequency::SixHours,
            "Three_Hours" => MaximumExecutionFrequency::ThreeHours,
            "Twelve_Hours" => MaximumExecutionFrequency::TwelveHours,
            "TwentyFour_Hours" => MaximumExecutionFrequency::TwentyFourHours,
            other => MaximumExecutionFrequency::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for MaximumExecutionFrequency {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MaximumExecutionFrequency::from(s))
    }
}
impl MaximumExecutionFrequency {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MaximumExecutionFrequency::OneHour => "One_Hour",
            MaximumExecutionFrequency::SixHours => "Six_Hours",
            MaximumExecutionFrequency::ThreeHours => "Three_Hours",
            MaximumExecutionFrequency::TwelveHours => "Twelve_Hours",
            MaximumExecutionFrequency::TwentyFourHours => "TwentyFour_Hours",
            MaximumExecutionFrequency::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "One_Hour",
            "Six_Hours",
            "Three_Hours",
            "Twelve_Hours",
            "TwentyFour_Hours",
        ]
    }
}
impl AsRef<str> for MaximumExecutionFrequency {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `OrganizationConfigRuleTriggerTypeNoSn`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let organizationconfigruletriggertypenosn = unimplemented!();
/// match organizationconfigruletriggertypenosn {
///     OrganizationConfigRuleTriggerTypeNoSn::ConfigurationItemChangeNotification => { /* ... */ },
///     OrganizationConfigRuleTriggerTypeNoSn::OversizedConfigurationItemChangeNotifcation => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `organizationconfigruletriggertypenosn` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OrganizationConfigRuleTriggerTypeNoSn::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OrganizationConfigRuleTriggerTypeNoSn::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OrganizationConfigRuleTriggerTypeNoSn::NewFeature` is defined.
/// Specifically, when `organizationconfigruletriggertypenosn` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OrganizationConfigRuleTriggerTypeNoSn::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OrganizationConfigRuleTriggerTypeNoSn {
    #[allow(missing_docs)] // documentation missing in model
    ConfigurationItemChangeNotification,
    #[allow(missing_docs)] // documentation missing in model
    OversizedConfigurationItemChangeNotifcation,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OrganizationConfigRuleTriggerTypeNoSn {
    fn from(s: &str) -> Self {
        match s {
            "ConfigurationItemChangeNotification" => {
                OrganizationConfigRuleTriggerTypeNoSn::ConfigurationItemChangeNotification
            }
            "OversizedConfigurationItemChangeNotification" => {
                OrganizationConfigRuleTriggerTypeNoSn::OversizedConfigurationItemChangeNotifcation
            }
            other => OrganizationConfigRuleTriggerTypeNoSn::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for OrganizationConfigRuleTriggerTypeNoSn {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OrganizationConfigRuleTriggerTypeNoSn::from(s))
    }
}
impl OrganizationConfigRuleTriggerTypeNoSn {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OrganizationConfigRuleTriggerTypeNoSn::ConfigurationItemChangeNotification => {
                "ConfigurationItemChangeNotification"
            }
            OrganizationConfigRuleTriggerTypeNoSn::OversizedConfigurationItemChangeNotifcation => {
                "OversizedConfigurationItemChangeNotification"
            }
            OrganizationConfigRuleTriggerTypeNoSn::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ConfigurationItemChangeNotification",
            "OversizedConfigurationItemChangeNotification",
        ]
    }
}
impl AsRef<str> for OrganizationConfigRuleTriggerTypeNoSn {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that specifies organization custom rule metadata such as resource type, resource ID of Amazon Web Services resource, Lambda function ARN, and organization trigger types that trigger Config to evaluate your Amazon Web Services resources against a rule. It also provides the frequency with which you want Config to run evaluations for the rule if the trigger type is periodic.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OrganizationCustomRuleMetadata {
    /// <p>The description that you provide for your organization Config rule.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The lambda function ARN.</p>
    #[doc(hidden)]
    pub lambda_function_arn: std::option::Option<std::string::String>,
    /// <p>The type of notification that triggers Config to run an evaluation for a rule. You can specify the following notification types:</p>
    /// <ul>
    /// <li> <p> <code>ConfigurationItemChangeNotification</code> - Triggers an evaluation when Config delivers a configuration item as a result of a resource change.</p> </li>
    /// <li> <p> <code>OversizedConfigurationItemChangeNotification</code> - Triggers an evaluation when Config delivers an oversized configuration item. Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.</p> </li>
    /// <li> <p> <code>ScheduledNotification</code> - Triggers a periodic evaluation at the frequency specified for <code>MaximumExecutionFrequency</code>.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub organization_config_rule_trigger_types:
        std::option::Option<std::vec::Vec<crate::model::OrganizationConfigRuleTriggerType>>,
    /// <p>A string, in JSON format, that is passed to your organization Config rule Lambda function.</p>
    #[doc(hidden)]
    pub input_parameters: std::option::Option<std::string::String>,
    /// <p>The maximum frequency with which Config runs evaluations for a rule. Your custom rule is triggered when Config delivers the configuration snapshot. For more information, see <code>ConfigSnapshotDeliveryProperties</code>.</p> <note>
    /// <p>By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the <code>MaximumExecutionFrequency</code> parameter.</p>
    /// </note>
    #[doc(hidden)]
    pub maximum_execution_frequency: std::option::Option<crate::model::MaximumExecutionFrequency>,
    /// <p>The type of the Amazon Web Services resource that was evaluated.</p>
    #[doc(hidden)]
    pub resource_types_scope: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the Amazon Web Services resource that was evaluated.</p>
    #[doc(hidden)]
    pub resource_id_scope: std::option::Option<std::string::String>,
    /// <p>One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values. </p>
    #[doc(hidden)]
    pub tag_key_scope: std::option::Option<std::string::String>,
    /// <p>The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key). </p>
    #[doc(hidden)]
    pub tag_value_scope: std::option::Option<std::string::String>,
}
impl OrganizationCustomRuleMetadata {
    /// <p>The description that you provide for your organization Config rule.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The lambda function ARN.</p>
    pub fn lambda_function_arn(&self) -> std::option::Option<&str> {
        self.lambda_function_arn.as_deref()
    }
    /// <p>The type of notification that triggers Config to run an evaluation for a rule. You can specify the following notification types:</p>
    /// <ul>
    /// <li> <p> <code>ConfigurationItemChangeNotification</code> - Triggers an evaluation when Config delivers a configuration item as a result of a resource change.</p> </li>
    /// <li> <p> <code>OversizedConfigurationItemChangeNotification</code> - Triggers an evaluation when Config delivers an oversized configuration item. Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.</p> </li>
    /// <li> <p> <code>ScheduledNotification</code> - Triggers a periodic evaluation at the frequency specified for <code>MaximumExecutionFrequency</code>.</p> </li>
    /// </ul>
    pub fn organization_config_rule_trigger_types(
        &self,
    ) -> std::option::Option<&[crate::model::OrganizationConfigRuleTriggerType]> {
        self.organization_config_rule_trigger_types.as_deref()
    }
    /// <p>A string, in JSON format, that is passed to your organization Config rule Lambda function.</p>
    pub fn input_parameters(&self) -> std::option::Option<&str> {
        self.input_parameters.as_deref()
    }
    /// <p>The maximum frequency with which Config runs evaluations for a rule. Your custom rule is triggered when Config delivers the configuration snapshot. For more information, see <code>ConfigSnapshotDeliveryProperties</code>.</p> <note>
    /// <p>By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the <code>MaximumExecutionFrequency</code> parameter.</p>
    /// </note>
    pub fn maximum_execution_frequency(
        &self,
    ) -> std::option::Option<&crate::model::MaximumExecutionFrequency> {
        self.maximum_execution_frequency.as_ref()
    }
    /// <p>The type of the Amazon Web Services resource that was evaluated.</p>
    pub fn resource_types_scope(&self) -> std::option::Option<&[std::string::String]> {
        self.resource_types_scope.as_deref()
    }
    /// <p>The ID of the Amazon Web Services resource that was evaluated.</p>
    pub fn resource_id_scope(&self) -> std::option::Option<&str> {
        self.resource_id_scope.as_deref()
    }
    /// <p>One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values. </p>
    pub fn tag_key_scope(&self) -> std::option::Option<&str> {
        self.tag_key_scope.as_deref()
    }
    /// <p>The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key). </p>
    pub fn tag_value_scope(&self) -> std::option::Option<&str> {
        self.tag_value_scope.as_deref()
    }
}
impl OrganizationCustomRuleMetadata {
    /// Creates a new builder-style object to manufacture [`OrganizationCustomRuleMetadata`](crate::model::OrganizationCustomRuleMetadata).
    pub fn builder() -> crate::model::organization_custom_rule_metadata::Builder {
        crate::model::organization_custom_rule_metadata::Builder::default()
    }
}

/// See [`OrganizationCustomRuleMetadata`](crate::model::OrganizationCustomRuleMetadata).
pub mod organization_custom_rule_metadata {

    /// A builder for [`OrganizationCustomRuleMetadata`](crate::model::OrganizationCustomRuleMetadata).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) lambda_function_arn: std::option::Option<std::string::String>,
        pub(crate) organization_config_rule_trigger_types:
            std::option::Option<std::vec::Vec<crate::model::OrganizationConfigRuleTriggerType>>,
        pub(crate) input_parameters: std::option::Option<std::string::String>,
        pub(crate) maximum_execution_frequency:
            std::option::Option<crate::model::MaximumExecutionFrequency>,
        pub(crate) resource_types_scope: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) resource_id_scope: std::option::Option<std::string::String>,
        pub(crate) tag_key_scope: std::option::Option<std::string::String>,
        pub(crate) tag_value_scope: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The description that you provide for your organization Config rule.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description that you provide for your organization Config rule.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The lambda function ARN.</p>
        pub fn lambda_function_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.lambda_function_arn = Some(input.into());
            self
        }
        /// <p>The lambda function ARN.</p>
        pub fn set_lambda_function_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.lambda_function_arn = input;
            self
        }
        /// Appends an item to `organization_config_rule_trigger_types`.
        ///
        /// To override the contents of this collection use [`set_organization_config_rule_trigger_types`](Self::set_organization_config_rule_trigger_types).
        ///
        /// <p>The type of notification that triggers Config to run an evaluation for a rule. You can specify the following notification types:</p>
        /// <ul>
        /// <li> <p> <code>ConfigurationItemChangeNotification</code> - Triggers an evaluation when Config delivers a configuration item as a result of a resource change.</p> </li>
        /// <li> <p> <code>OversizedConfigurationItemChangeNotification</code> - Triggers an evaluation when Config delivers an oversized configuration item. Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.</p> </li>
        /// <li> <p> <code>ScheduledNotification</code> - Triggers a periodic evaluation at the frequency specified for <code>MaximumExecutionFrequency</code>.</p> </li>
        /// </ul>
        pub fn organization_config_rule_trigger_types(
            mut self,
            input: crate::model::OrganizationConfigRuleTriggerType,
        ) -> Self {
            let mut v = self
                .organization_config_rule_trigger_types
                .unwrap_or_default();
            v.push(input);
            self.organization_config_rule_trigger_types = Some(v);
            self
        }
        /// <p>The type of notification that triggers Config to run an evaluation for a rule. You can specify the following notification types:</p>
        /// <ul>
        /// <li> <p> <code>ConfigurationItemChangeNotification</code> - Triggers an evaluation when Config delivers a configuration item as a result of a resource change.</p> </li>
        /// <li> <p> <code>OversizedConfigurationItemChangeNotification</code> - Triggers an evaluation when Config delivers an oversized configuration item. Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.</p> </li>
        /// <li> <p> <code>ScheduledNotification</code> - Triggers a periodic evaluation at the frequency specified for <code>MaximumExecutionFrequency</code>.</p> </li>
        /// </ul>
        pub fn set_organization_config_rule_trigger_types(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::OrganizationConfigRuleTriggerType>,
            >,
        ) -> Self {
            self.organization_config_rule_trigger_types = input;
            self
        }
        /// <p>A string, in JSON format, that is passed to your organization Config rule Lambda function.</p>
        pub fn input_parameters(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_parameters = Some(input.into());
            self
        }
        /// <p>A string, in JSON format, that is passed to your organization Config rule Lambda function.</p>
        pub fn set_input_parameters(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.input_parameters = input;
            self
        }
        /// <p>The maximum frequency with which Config runs evaluations for a rule. Your custom rule is triggered when Config delivers the configuration snapshot. For more information, see <code>ConfigSnapshotDeliveryProperties</code>.</p> <note>
        /// <p>By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the <code>MaximumExecutionFrequency</code> parameter.</p>
        /// </note>
        pub fn maximum_execution_frequency(
            mut self,
            input: crate::model::MaximumExecutionFrequency,
        ) -> Self {
            self.maximum_execution_frequency = Some(input);
            self
        }
        /// <p>The maximum frequency with which Config runs evaluations for a rule. Your custom rule is triggered when Config delivers the configuration snapshot. For more information, see <code>ConfigSnapshotDeliveryProperties</code>.</p> <note>
        /// <p>By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the <code>MaximumExecutionFrequency</code> parameter.</p>
        /// </note>
        pub fn set_maximum_execution_frequency(
            mut self,
            input: std::option::Option<crate::model::MaximumExecutionFrequency>,
        ) -> Self {
            self.maximum_execution_frequency = input;
            self
        }
        /// Appends an item to `resource_types_scope`.
        ///
        /// To override the contents of this collection use [`set_resource_types_scope`](Self::set_resource_types_scope).
        ///
        /// <p>The type of the Amazon Web Services resource that was evaluated.</p>
        pub fn resource_types_scope(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.resource_types_scope.unwrap_or_default();
            v.push(input.into());
            self.resource_types_scope = Some(v);
            self
        }
        /// <p>The type of the Amazon Web Services resource that was evaluated.</p>
        pub fn set_resource_types_scope(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.resource_types_scope = input;
            self
        }
        /// <p>The ID of the Amazon Web Services resource that was evaluated.</p>
        pub fn resource_id_scope(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id_scope = Some(input.into());
            self
        }
        /// <p>The ID of the Amazon Web Services resource that was evaluated.</p>
        pub fn set_resource_id_scope(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_id_scope = input;
            self
        }
        /// <p>One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values. </p>
        pub fn tag_key_scope(mut self, input: impl Into<std::string::String>) -> Self {
            self.tag_key_scope = Some(input.into());
            self
        }
        /// <p>One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values. </p>
        pub fn set_tag_key_scope(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tag_key_scope = input;
            self
        }
        /// <p>The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key). </p>
        pub fn tag_value_scope(mut self, input: impl Into<std::string::String>) -> Self {
            self.tag_value_scope = Some(input.into());
            self
        }
        /// <p>The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key). </p>
        pub fn set_tag_value_scope(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tag_value_scope = input;
            self
        }
        /// Consumes the builder and constructs a [`OrganizationCustomRuleMetadata`](crate::model::OrganizationCustomRuleMetadata).
        pub fn build(self) -> crate::model::OrganizationCustomRuleMetadata {
            crate::model::OrganizationCustomRuleMetadata {
                description: self.description,
                lambda_function_arn: self.lambda_function_arn,
                organization_config_rule_trigger_types: self.organization_config_rule_trigger_types,
                input_parameters: self.input_parameters,
                maximum_execution_frequency: self.maximum_execution_frequency,
                resource_types_scope: self.resource_types_scope,
                resource_id_scope: self.resource_id_scope,
                tag_key_scope: self.tag_key_scope,
                tag_value_scope: self.tag_value_scope,
            }
        }
    }
}

/// When writing a match expression against `OrganizationConfigRuleTriggerType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let organizationconfigruletriggertype = unimplemented!();
/// match organizationconfigruletriggertype {
///     OrganizationConfigRuleTriggerType::ConfigurationItemChangeNotification => { /* ... */ },
///     OrganizationConfigRuleTriggerType::OversizedConfigurationItemChangeNotifcation => { /* ... */ },
///     OrganizationConfigRuleTriggerType::ScheduledNotification => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `organizationconfigruletriggertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OrganizationConfigRuleTriggerType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OrganizationConfigRuleTriggerType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OrganizationConfigRuleTriggerType::NewFeature` is defined.
/// Specifically, when `organizationconfigruletriggertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OrganizationConfigRuleTriggerType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OrganizationConfigRuleTriggerType {
    #[allow(missing_docs)] // documentation missing in model
    ConfigurationItemChangeNotification,
    #[allow(missing_docs)] // documentation missing in model
    OversizedConfigurationItemChangeNotifcation,
    #[allow(missing_docs)] // documentation missing in model
    ScheduledNotification,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OrganizationConfigRuleTriggerType {
    fn from(s: &str) -> Self {
        match s {
            "ConfigurationItemChangeNotification" => {
                OrganizationConfigRuleTriggerType::ConfigurationItemChangeNotification
            }
            "OversizedConfigurationItemChangeNotification" => {
                OrganizationConfigRuleTriggerType::OversizedConfigurationItemChangeNotifcation
            }
            "ScheduledNotification" => OrganizationConfigRuleTriggerType::ScheduledNotification,
            other => OrganizationConfigRuleTriggerType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for OrganizationConfigRuleTriggerType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OrganizationConfigRuleTriggerType::from(s))
    }
}
impl OrganizationConfigRuleTriggerType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OrganizationConfigRuleTriggerType::ConfigurationItemChangeNotification => {
                "ConfigurationItemChangeNotification"
            }
            OrganizationConfigRuleTriggerType::OversizedConfigurationItemChangeNotifcation => {
                "OversizedConfigurationItemChangeNotification"
            }
            OrganizationConfigRuleTriggerType::ScheduledNotification => "ScheduledNotification",
            OrganizationConfigRuleTriggerType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ConfigurationItemChangeNotification",
            "OversizedConfigurationItemChangeNotification",
            "ScheduledNotification",
        ]
    }
}
impl AsRef<str> for OrganizationConfigRuleTriggerType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that specifies organization managed rule metadata such as resource type and ID of Amazon Web Services resource along with the rule identifier. It also provides the frequency with which you want Config to run evaluations for the rule if the trigger type is periodic.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OrganizationManagedRuleMetadata {
    /// <p>The description that you provide for your organization Config rule.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>For organization config managed rules, a predefined identifier from a list. For example, <code>IAM_PASSWORD_POLICY</code> is a managed rule. To reference a managed rule, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_use-managed-rules.html">Using Config managed rules</a>.</p>
    #[doc(hidden)]
    pub rule_identifier: std::option::Option<std::string::String>,
    /// <p>A string, in JSON format, that is passed to your organization Config rule Lambda function.</p>
    #[doc(hidden)]
    pub input_parameters: std::option::Option<std::string::String>,
    /// <p>The maximum frequency with which Config runs evaluations for a rule. This is for an Config managed rule that is triggered at a periodic frequency.</p> <note>
    /// <p>By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the <code>MaximumExecutionFrequency</code> parameter.</p>
    /// </note>
    #[doc(hidden)]
    pub maximum_execution_frequency: std::option::Option<crate::model::MaximumExecutionFrequency>,
    /// <p>The type of the Amazon Web Services resource that was evaluated.</p>
    #[doc(hidden)]
    pub resource_types_scope: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the Amazon Web Services resource that was evaluated.</p>
    #[doc(hidden)]
    pub resource_id_scope: std::option::Option<std::string::String>,
    /// <p>One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values. </p>
    #[doc(hidden)]
    pub tag_key_scope: std::option::Option<std::string::String>,
    /// <p>The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).</p>
    #[doc(hidden)]
    pub tag_value_scope: std::option::Option<std::string::String>,
}
impl OrganizationManagedRuleMetadata {
    /// <p>The description that you provide for your organization Config rule.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>For organization config managed rules, a predefined identifier from a list. For example, <code>IAM_PASSWORD_POLICY</code> is a managed rule. To reference a managed rule, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_use-managed-rules.html">Using Config managed rules</a>.</p>
    pub fn rule_identifier(&self) -> std::option::Option<&str> {
        self.rule_identifier.as_deref()
    }
    /// <p>A string, in JSON format, that is passed to your organization Config rule Lambda function.</p>
    pub fn input_parameters(&self) -> std::option::Option<&str> {
        self.input_parameters.as_deref()
    }
    /// <p>The maximum frequency with which Config runs evaluations for a rule. This is for an Config managed rule that is triggered at a periodic frequency.</p> <note>
    /// <p>By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the <code>MaximumExecutionFrequency</code> parameter.</p>
    /// </note>
    pub fn maximum_execution_frequency(
        &self,
    ) -> std::option::Option<&crate::model::MaximumExecutionFrequency> {
        self.maximum_execution_frequency.as_ref()
    }
    /// <p>The type of the Amazon Web Services resource that was evaluated.</p>
    pub fn resource_types_scope(&self) -> std::option::Option<&[std::string::String]> {
        self.resource_types_scope.as_deref()
    }
    /// <p>The ID of the Amazon Web Services resource that was evaluated.</p>
    pub fn resource_id_scope(&self) -> std::option::Option<&str> {
        self.resource_id_scope.as_deref()
    }
    /// <p>One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values. </p>
    pub fn tag_key_scope(&self) -> std::option::Option<&str> {
        self.tag_key_scope.as_deref()
    }
    /// <p>The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).</p>
    pub fn tag_value_scope(&self) -> std::option::Option<&str> {
        self.tag_value_scope.as_deref()
    }
}
impl OrganizationManagedRuleMetadata {
    /// Creates a new builder-style object to manufacture [`OrganizationManagedRuleMetadata`](crate::model::OrganizationManagedRuleMetadata).
    pub fn builder() -> crate::model::organization_managed_rule_metadata::Builder {
        crate::model::organization_managed_rule_metadata::Builder::default()
    }
}

/// See [`OrganizationManagedRuleMetadata`](crate::model::OrganizationManagedRuleMetadata).
pub mod organization_managed_rule_metadata {

    /// A builder for [`OrganizationManagedRuleMetadata`](crate::model::OrganizationManagedRuleMetadata).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) rule_identifier: std::option::Option<std::string::String>,
        pub(crate) input_parameters: std::option::Option<std::string::String>,
        pub(crate) maximum_execution_frequency:
            std::option::Option<crate::model::MaximumExecutionFrequency>,
        pub(crate) resource_types_scope: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) resource_id_scope: std::option::Option<std::string::String>,
        pub(crate) tag_key_scope: std::option::Option<std::string::String>,
        pub(crate) tag_value_scope: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The description that you provide for your organization Config rule.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description that you provide for your organization Config rule.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>For organization config managed rules, a predefined identifier from a list. For example, <code>IAM_PASSWORD_POLICY</code> is a managed rule. To reference a managed rule, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_use-managed-rules.html">Using Config managed rules</a>.</p>
        pub fn rule_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_identifier = Some(input.into());
            self
        }
        /// <p>For organization config managed rules, a predefined identifier from a list. For example, <code>IAM_PASSWORD_POLICY</code> is a managed rule. To reference a managed rule, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_use-managed-rules.html">Using Config managed rules</a>.</p>
        pub fn set_rule_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_identifier = input;
            self
        }
        /// <p>A string, in JSON format, that is passed to your organization Config rule Lambda function.</p>
        pub fn input_parameters(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_parameters = Some(input.into());
            self
        }
        /// <p>A string, in JSON format, that is passed to your organization Config rule Lambda function.</p>
        pub fn set_input_parameters(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.input_parameters = input;
            self
        }
        /// <p>The maximum frequency with which Config runs evaluations for a rule. This is for an Config managed rule that is triggered at a periodic frequency.</p> <note>
        /// <p>By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the <code>MaximumExecutionFrequency</code> parameter.</p>
        /// </note>
        pub fn maximum_execution_frequency(
            mut self,
            input: crate::model::MaximumExecutionFrequency,
        ) -> Self {
            self.maximum_execution_frequency = Some(input);
            self
        }
        /// <p>The maximum frequency with which Config runs evaluations for a rule. This is for an Config managed rule that is triggered at a periodic frequency.</p> <note>
        /// <p>By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the <code>MaximumExecutionFrequency</code> parameter.</p>
        /// </note>
        pub fn set_maximum_execution_frequency(
            mut self,
            input: std::option::Option<crate::model::MaximumExecutionFrequency>,
        ) -> Self {
            self.maximum_execution_frequency = input;
            self
        }
        /// Appends an item to `resource_types_scope`.
        ///
        /// To override the contents of this collection use [`set_resource_types_scope`](Self::set_resource_types_scope).
        ///
        /// <p>The type of the Amazon Web Services resource that was evaluated.</p>
        pub fn resource_types_scope(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.resource_types_scope.unwrap_or_default();
            v.push(input.into());
            self.resource_types_scope = Some(v);
            self
        }
        /// <p>The type of the Amazon Web Services resource that was evaluated.</p>
        pub fn set_resource_types_scope(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.resource_types_scope = input;
            self
        }
        /// <p>The ID of the Amazon Web Services resource that was evaluated.</p>
        pub fn resource_id_scope(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id_scope = Some(input.into());
            self
        }
        /// <p>The ID of the Amazon Web Services resource that was evaluated.</p>
        pub fn set_resource_id_scope(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_id_scope = input;
            self
        }
        /// <p>One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values. </p>
        pub fn tag_key_scope(mut self, input: impl Into<std::string::String>) -> Self {
            self.tag_key_scope = Some(input.into());
            self
        }
        /// <p>One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values. </p>
        pub fn set_tag_key_scope(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tag_key_scope = input;
            self
        }
        /// <p>The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).</p>
        pub fn tag_value_scope(mut self, input: impl Into<std::string::String>) -> Self {
            self.tag_value_scope = Some(input.into());
            self
        }
        /// <p>The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).</p>
        pub fn set_tag_value_scope(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tag_value_scope = input;
            self
        }
        /// Consumes the builder and constructs a [`OrganizationManagedRuleMetadata`](crate::model::OrganizationManagedRuleMetadata).
        pub fn build(self) -> crate::model::OrganizationManagedRuleMetadata {
            crate::model::OrganizationManagedRuleMetadata {
                description: self.description,
                rule_identifier: self.rule_identifier,
                input_parameters: self.input_parameters,
                maximum_execution_frequency: self.maximum_execution_frequency,
                resource_types_scope: self.resource_types_scope,
                resource_id_scope: self.resource_id_scope,
                tag_key_scope: self.tag_key_scope,
                tag_value_scope: self.tag_value_scope,
            }
        }
    }
}

/// <p>Identifies an Amazon Web Services resource and indicates whether it complies with the Config rule that it was evaluated against.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExternalEvaluation {
    /// <p>The evaluated compliance resource type. Config accepts <code>AWS::::Account</code> resource type.</p>
    #[doc(hidden)]
    pub compliance_resource_type: std::option::Option<std::string::String>,
    /// <p>The evaluated compliance resource ID. Config accepts only Amazon Web Services account ID.</p>
    #[doc(hidden)]
    pub compliance_resource_id: std::option::Option<std::string::String>,
    /// <p>The compliance of the Amazon Web Services resource. The valid values are <code>COMPLIANT, NON_COMPLIANT, </code> and <code>NOT_APPLICABLE</code>.</p>
    #[doc(hidden)]
    pub compliance_type: std::option::Option<crate::model::ComplianceType>,
    /// <p>Supplementary information about the reason of compliance. For example, this task was completed on a specific date.</p>
    #[doc(hidden)]
    pub annotation: std::option::Option<std::string::String>,
    /// <p>The time when the compliance was recorded. </p>
    #[doc(hidden)]
    pub ordering_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl ExternalEvaluation {
    /// <p>The evaluated compliance resource type. Config accepts <code>AWS::::Account</code> resource type.</p>
    pub fn compliance_resource_type(&self) -> std::option::Option<&str> {
        self.compliance_resource_type.as_deref()
    }
    /// <p>The evaluated compliance resource ID. Config accepts only Amazon Web Services account ID.</p>
    pub fn compliance_resource_id(&self) -> std::option::Option<&str> {
        self.compliance_resource_id.as_deref()
    }
    /// <p>The compliance of the Amazon Web Services resource. The valid values are <code>COMPLIANT, NON_COMPLIANT, </code> and <code>NOT_APPLICABLE</code>.</p>
    pub fn compliance_type(&self) -> std::option::Option<&crate::model::ComplianceType> {
        self.compliance_type.as_ref()
    }
    /// <p>Supplementary information about the reason of compliance. For example, this task was completed on a specific date.</p>
    pub fn annotation(&self) -> std::option::Option<&str> {
        self.annotation.as_deref()
    }
    /// <p>The time when the compliance was recorded. </p>
    pub fn ordering_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.ordering_timestamp.as_ref()
    }
}
impl ExternalEvaluation {
    /// Creates a new builder-style object to manufacture [`ExternalEvaluation`](crate::model::ExternalEvaluation).
    pub fn builder() -> crate::model::external_evaluation::Builder {
        crate::model::external_evaluation::Builder::default()
    }
}

/// See [`ExternalEvaluation`](crate::model::ExternalEvaluation).
pub mod external_evaluation {

    /// A builder for [`ExternalEvaluation`](crate::model::ExternalEvaluation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) compliance_resource_type: std::option::Option<std::string::String>,
        pub(crate) compliance_resource_id: std::option::Option<std::string::String>,
        pub(crate) compliance_type: std::option::Option<crate::model::ComplianceType>,
        pub(crate) annotation: std::option::Option<std::string::String>,
        pub(crate) ordering_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The evaluated compliance resource type. Config accepts <code>AWS::::Account</code> resource type.</p>
        pub fn compliance_resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.compliance_resource_type = Some(input.into());
            self
        }
        /// <p>The evaluated compliance resource type. Config accepts <code>AWS::::Account</code> resource type.</p>
        pub fn set_compliance_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.compliance_resource_type = input;
            self
        }
        /// <p>The evaluated compliance resource ID. Config accepts only Amazon Web Services account ID.</p>
        pub fn compliance_resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.compliance_resource_id = Some(input.into());
            self
        }
        /// <p>The evaluated compliance resource ID. Config accepts only Amazon Web Services account ID.</p>
        pub fn set_compliance_resource_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.compliance_resource_id = input;
            self
        }
        /// <p>The compliance of the Amazon Web Services resource. The valid values are <code>COMPLIANT, NON_COMPLIANT, </code> and <code>NOT_APPLICABLE</code>.</p>
        pub fn compliance_type(mut self, input: crate::model::ComplianceType) -> Self {
            self.compliance_type = Some(input);
            self
        }
        /// <p>The compliance of the Amazon Web Services resource. The valid values are <code>COMPLIANT, NON_COMPLIANT, </code> and <code>NOT_APPLICABLE</code>.</p>
        pub fn set_compliance_type(
            mut self,
            input: std::option::Option<crate::model::ComplianceType>,
        ) -> Self {
            self.compliance_type = input;
            self
        }
        /// <p>Supplementary information about the reason of compliance. For example, this task was completed on a specific date.</p>
        pub fn annotation(mut self, input: impl Into<std::string::String>) -> Self {
            self.annotation = Some(input.into());
            self
        }
        /// <p>Supplementary information about the reason of compliance. For example, this task was completed on a specific date.</p>
        pub fn set_annotation(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.annotation = input;
            self
        }
        /// <p>The time when the compliance was recorded. </p>
        pub fn ordering_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.ordering_timestamp = Some(input);
            self
        }
        /// <p>The time when the compliance was recorded. </p>
        pub fn set_ordering_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.ordering_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`ExternalEvaluation`](crate::model::ExternalEvaluation).
        pub fn build(self) -> crate::model::ExternalEvaluation {
            crate::model::ExternalEvaluation {
                compliance_resource_type: self.compliance_resource_type,
                compliance_resource_id: self.compliance_resource_id,
                compliance_type: self.compliance_type,
                annotation: self.annotation,
                ordering_timestamp: self.ordering_timestamp,
            }
        }
    }
}

/// When writing a match expression against `ComplianceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let compliancetype = unimplemented!();
/// match compliancetype {
///     ComplianceType::Compliant => { /* ... */ },
///     ComplianceType::InsufficientData => { /* ... */ },
///     ComplianceType::NonCompliant => { /* ... */ },
///     ComplianceType::NotApplicable => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `compliancetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ComplianceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ComplianceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ComplianceType::NewFeature` is defined.
/// Specifically, when `compliancetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ComplianceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ComplianceType {
    #[allow(missing_docs)] // documentation missing in model
    Compliant,
    #[allow(missing_docs)] // documentation missing in model
    InsufficientData,
    #[allow(missing_docs)] // documentation missing in model
    NonCompliant,
    #[allow(missing_docs)] // documentation missing in model
    NotApplicable,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ComplianceType {
    fn from(s: &str) -> Self {
        match s {
            "COMPLIANT" => ComplianceType::Compliant,
            "INSUFFICIENT_DATA" => ComplianceType::InsufficientData,
            "NON_COMPLIANT" => ComplianceType::NonCompliant,
            "NOT_APPLICABLE" => ComplianceType::NotApplicable,
            other => ComplianceType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ComplianceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ComplianceType::from(s))
    }
}
impl ComplianceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ComplianceType::Compliant => "COMPLIANT",
            ComplianceType::InsufficientData => "INSUFFICIENT_DATA",
            ComplianceType::NonCompliant => "NON_COMPLIANT",
            ComplianceType::NotApplicable => "NOT_APPLICABLE",
            ComplianceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "COMPLIANT",
            "INSUFFICIENT_DATA",
            "NON_COMPLIANT",
            "NOT_APPLICABLE",
        ]
    }
}
impl AsRef<str> for ComplianceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Identifies an Amazon Web Services resource and indicates whether it complies with the Config rule that it was evaluated against.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Evaluation {
    /// <p>The type of Amazon Web Services resource that was evaluated.</p>
    #[doc(hidden)]
    pub compliance_resource_type: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services resource that was evaluated.</p>
    #[doc(hidden)]
    pub compliance_resource_id: std::option::Option<std::string::String>,
    /// <p>Indicates whether the Amazon Web Services resource complies with the Config rule that it was evaluated against.</p>
    /// <p>For the <code>Evaluation</code> data type, Config supports only the <code>COMPLIANT</code>, <code>NON_COMPLIANT</code>, and <code>NOT_APPLICABLE</code> values. Config does not support the <code>INSUFFICIENT_DATA</code> value for this data type.</p>
    /// <p>Similarly, Config does not accept <code>INSUFFICIENT_DATA</code> as the value for <code>ComplianceType</code> from a <code>PutEvaluations</code> request. For example, an Lambda function for a custom Config rule cannot pass an <code>INSUFFICIENT_DATA</code> value to Config.</p>
    #[doc(hidden)]
    pub compliance_type: std::option::Option<crate::model::ComplianceType>,
    /// <p>Supplementary information about how the evaluation determined the compliance.</p>
    #[doc(hidden)]
    pub annotation: std::option::Option<std::string::String>,
    /// <p>The time of the event in Config that triggered the evaluation. For event-based evaluations, the time indicates when Config created the configuration item that triggered the evaluation. For periodic evaluations, the time indicates when Config triggered the evaluation at the frequency that you specified (for example, every 24 hours).</p>
    #[doc(hidden)]
    pub ordering_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl Evaluation {
    /// <p>The type of Amazon Web Services resource that was evaluated.</p>
    pub fn compliance_resource_type(&self) -> std::option::Option<&str> {
        self.compliance_resource_type.as_deref()
    }
    /// <p>The ID of the Amazon Web Services resource that was evaluated.</p>
    pub fn compliance_resource_id(&self) -> std::option::Option<&str> {
        self.compliance_resource_id.as_deref()
    }
    /// <p>Indicates whether the Amazon Web Services resource complies with the Config rule that it was evaluated against.</p>
    /// <p>For the <code>Evaluation</code> data type, Config supports only the <code>COMPLIANT</code>, <code>NON_COMPLIANT</code>, and <code>NOT_APPLICABLE</code> values. Config does not support the <code>INSUFFICIENT_DATA</code> value for this data type.</p>
    /// <p>Similarly, Config does not accept <code>INSUFFICIENT_DATA</code> as the value for <code>ComplianceType</code> from a <code>PutEvaluations</code> request. For example, an Lambda function for a custom Config rule cannot pass an <code>INSUFFICIENT_DATA</code> value to Config.</p>
    pub fn compliance_type(&self) -> std::option::Option<&crate::model::ComplianceType> {
        self.compliance_type.as_ref()
    }
    /// <p>Supplementary information about how the evaluation determined the compliance.</p>
    pub fn annotation(&self) -> std::option::Option<&str> {
        self.annotation.as_deref()
    }
    /// <p>The time of the event in Config that triggered the evaluation. For event-based evaluations, the time indicates when Config created the configuration item that triggered the evaluation. For periodic evaluations, the time indicates when Config triggered the evaluation at the frequency that you specified (for example, every 24 hours).</p>
    pub fn ordering_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.ordering_timestamp.as_ref()
    }
}
impl Evaluation {
    /// Creates a new builder-style object to manufacture [`Evaluation`](crate::model::Evaluation).
    pub fn builder() -> crate::model::evaluation::Builder {
        crate::model::evaluation::Builder::default()
    }
}

/// See [`Evaluation`](crate::model::Evaluation).
pub mod evaluation {

    /// A builder for [`Evaluation`](crate::model::Evaluation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) compliance_resource_type: std::option::Option<std::string::String>,
        pub(crate) compliance_resource_id: std::option::Option<std::string::String>,
        pub(crate) compliance_type: std::option::Option<crate::model::ComplianceType>,
        pub(crate) annotation: std::option::Option<std::string::String>,
        pub(crate) ordering_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The type of Amazon Web Services resource that was evaluated.</p>
        pub fn compliance_resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.compliance_resource_type = Some(input.into());
            self
        }
        /// <p>The type of Amazon Web Services resource that was evaluated.</p>
        pub fn set_compliance_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.compliance_resource_type = input;
            self
        }
        /// <p>The ID of the Amazon Web Services resource that was evaluated.</p>
        pub fn compliance_resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.compliance_resource_id = Some(input.into());
            self
        }
        /// <p>The ID of the Amazon Web Services resource that was evaluated.</p>
        pub fn set_compliance_resource_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.compliance_resource_id = input;
            self
        }
        /// <p>Indicates whether the Amazon Web Services resource complies with the Config rule that it was evaluated against.</p>
        /// <p>For the <code>Evaluation</code> data type, Config supports only the <code>COMPLIANT</code>, <code>NON_COMPLIANT</code>, and <code>NOT_APPLICABLE</code> values. Config does not support the <code>INSUFFICIENT_DATA</code> value for this data type.</p>
        /// <p>Similarly, Config does not accept <code>INSUFFICIENT_DATA</code> as the value for <code>ComplianceType</code> from a <code>PutEvaluations</code> request. For example, an Lambda function for a custom Config rule cannot pass an <code>INSUFFICIENT_DATA</code> value to Config.</p>
        pub fn compliance_type(mut self, input: crate::model::ComplianceType) -> Self {
            self.compliance_type = Some(input);
            self
        }
        /// <p>Indicates whether the Amazon Web Services resource complies with the Config rule that it was evaluated against.</p>
        /// <p>For the <code>Evaluation</code> data type, Config supports only the <code>COMPLIANT</code>, <code>NON_COMPLIANT</code>, and <code>NOT_APPLICABLE</code> values. Config does not support the <code>INSUFFICIENT_DATA</code> value for this data type.</p>
        /// <p>Similarly, Config does not accept <code>INSUFFICIENT_DATA</code> as the value for <code>ComplianceType</code> from a <code>PutEvaluations</code> request. For example, an Lambda function for a custom Config rule cannot pass an <code>INSUFFICIENT_DATA</code> value to Config.</p>
        pub fn set_compliance_type(
            mut self,
            input: std::option::Option<crate::model::ComplianceType>,
        ) -> Self {
            self.compliance_type = input;
            self
        }
        /// <p>Supplementary information about how the evaluation determined the compliance.</p>
        pub fn annotation(mut self, input: impl Into<std::string::String>) -> Self {
            self.annotation = Some(input.into());
            self
        }
        /// <p>Supplementary information about how the evaluation determined the compliance.</p>
        pub fn set_annotation(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.annotation = input;
            self
        }
        /// <p>The time of the event in Config that triggered the evaluation. For event-based evaluations, the time indicates when Config created the configuration item that triggered the evaluation. For periodic evaluations, the time indicates when Config triggered the evaluation at the frequency that you specified (for example, every 24 hours).</p>
        pub fn ordering_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.ordering_timestamp = Some(input);
            self
        }
        /// <p>The time of the event in Config that triggered the evaluation. For event-based evaluations, the time indicates when Config created the configuration item that triggered the evaluation. For periodic evaluations, the time indicates when Config triggered the evaluation at the frequency that you specified (for example, every 24 hours).</p>
        pub fn set_ordering_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.ordering_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`Evaluation`](crate::model::Evaluation).
        pub fn build(self) -> crate::model::Evaluation {
            crate::model::Evaluation {
                compliance_resource_type: self.compliance_resource_type,
                compliance_resource_id: self.compliance_resource_id,
                compliance_type: self.compliance_type,
                annotation: self.annotation,
                ordering_timestamp: self.ordering_timestamp,
            }
        }
    }
}

/// <p>The channel through which Config delivers notifications and updated configuration states.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeliveryChannel {
    /// <p>The name of the delivery channel. By default, Config assigns the name "default" when creating the delivery channel. To change the delivery channel name, you must use the DeleteDeliveryChannel action to delete your current delivery channel, and then you must use the PutDeliveryChannel command to create a delivery channel that has the desired name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the Amazon S3 bucket to which Config delivers configuration snapshots and configuration history files.</p>
    /// <p>If you specify a bucket that belongs to another Amazon Web Services account, that bucket must have policies that grant access permissions to Config. For more information, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/s3-bucket-policy.html">Permissions for the Amazon S3 Bucket</a> in the <i>Config Developer Guide</i>.</p>
    #[doc(hidden)]
    pub s3_bucket_name: std::option::Option<std::string::String>,
    /// <p>The prefix for the specified Amazon S3 bucket.</p>
    #[doc(hidden)]
    pub s3_key_prefix: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Key Management Service (KMS ) KMS key (KMS key) used to encrypt objects delivered by Config. Must belong to the same Region as the destination S3 bucket.</p>
    #[doc(hidden)]
    pub s3_kms_key_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic to which Config sends notifications about configuration changes.</p>
    /// <p>If you choose a topic from another account, the topic must have policies that grant access permissions to Config. For more information, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/sns-topic-policy.html">Permissions for the Amazon SNS Topic</a> in the <i>Config Developer Guide</i>.</p>
    #[doc(hidden)]
    pub sns_topic_arn: std::option::Option<std::string::String>,
    /// <p>The options for how often Config delivers configuration snapshots to the Amazon S3 bucket.</p>
    #[doc(hidden)]
    pub config_snapshot_delivery_properties:
        std::option::Option<crate::model::ConfigSnapshotDeliveryProperties>,
}
impl DeliveryChannel {
    /// <p>The name of the delivery channel. By default, Config assigns the name "default" when creating the delivery channel. To change the delivery channel name, you must use the DeleteDeliveryChannel action to delete your current delivery channel, and then you must use the PutDeliveryChannel command to create a delivery channel that has the desired name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the Amazon S3 bucket to which Config delivers configuration snapshots and configuration history files.</p>
    /// <p>If you specify a bucket that belongs to another Amazon Web Services account, that bucket must have policies that grant access permissions to Config. For more information, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/s3-bucket-policy.html">Permissions for the Amazon S3 Bucket</a> in the <i>Config Developer Guide</i>.</p>
    pub fn s3_bucket_name(&self) -> std::option::Option<&str> {
        self.s3_bucket_name.as_deref()
    }
    /// <p>The prefix for the specified Amazon S3 bucket.</p>
    pub fn s3_key_prefix(&self) -> std::option::Option<&str> {
        self.s3_key_prefix.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Key Management Service (KMS ) KMS key (KMS key) used to encrypt objects delivered by Config. Must belong to the same Region as the destination S3 bucket.</p>
    pub fn s3_kms_key_arn(&self) -> std::option::Option<&str> {
        self.s3_kms_key_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic to which Config sends notifications about configuration changes.</p>
    /// <p>If you choose a topic from another account, the topic must have policies that grant access permissions to Config. For more information, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/sns-topic-policy.html">Permissions for the Amazon SNS Topic</a> in the <i>Config Developer Guide</i>.</p>
    pub fn sns_topic_arn(&self) -> std::option::Option<&str> {
        self.sns_topic_arn.as_deref()
    }
    /// <p>The options for how often Config delivers configuration snapshots to the Amazon S3 bucket.</p>
    pub fn config_snapshot_delivery_properties(
        &self,
    ) -> std::option::Option<&crate::model::ConfigSnapshotDeliveryProperties> {
        self.config_snapshot_delivery_properties.as_ref()
    }
}
impl DeliveryChannel {
    /// Creates a new builder-style object to manufacture [`DeliveryChannel`](crate::model::DeliveryChannel).
    pub fn builder() -> crate::model::delivery_channel::Builder {
        crate::model::delivery_channel::Builder::default()
    }
}

/// See [`DeliveryChannel`](crate::model::DeliveryChannel).
pub mod delivery_channel {

    /// A builder for [`DeliveryChannel`](crate::model::DeliveryChannel).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) s3_bucket_name: std::option::Option<std::string::String>,
        pub(crate) s3_key_prefix: std::option::Option<std::string::String>,
        pub(crate) s3_kms_key_arn: std::option::Option<std::string::String>,
        pub(crate) sns_topic_arn: std::option::Option<std::string::String>,
        pub(crate) config_snapshot_delivery_properties:
            std::option::Option<crate::model::ConfigSnapshotDeliveryProperties>,
    }
    impl Builder {
        /// <p>The name of the delivery channel. By default, Config assigns the name "default" when creating the delivery channel. To change the delivery channel name, you must use the DeleteDeliveryChannel action to delete your current delivery channel, and then you must use the PutDeliveryChannel command to create a delivery channel that has the desired name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the delivery channel. By default, Config assigns the name "default" when creating the delivery channel. To change the delivery channel name, you must use the DeleteDeliveryChannel action to delete your current delivery channel, and then you must use the PutDeliveryChannel command to create a delivery channel that has the desired name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the Amazon S3 bucket to which Config delivers configuration snapshots and configuration history files.</p>
        /// <p>If you specify a bucket that belongs to another Amazon Web Services account, that bucket must have policies that grant access permissions to Config. For more information, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/s3-bucket-policy.html">Permissions for the Amazon S3 Bucket</a> in the <i>Config Developer Guide</i>.</p>
        pub fn s3_bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket_name = Some(input.into());
            self
        }
        /// <p>The name of the Amazon S3 bucket to which Config delivers configuration snapshots and configuration history files.</p>
        /// <p>If you specify a bucket that belongs to another Amazon Web Services account, that bucket must have policies that grant access permissions to Config. For more information, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/s3-bucket-policy.html">Permissions for the Amazon S3 Bucket</a> in the <i>Config Developer Guide</i>.</p>
        pub fn set_s3_bucket_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_bucket_name = input;
            self
        }
        /// <p>The prefix for the specified Amazon S3 bucket.</p>
        pub fn s3_key_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_key_prefix = Some(input.into());
            self
        }
        /// <p>The prefix for the specified Amazon S3 bucket.</p>
        pub fn set_s3_key_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_key_prefix = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Key Management Service (KMS ) KMS key (KMS key) used to encrypt objects delivered by Config. Must belong to the same Region as the destination S3 bucket.</p>
        pub fn s3_kms_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_kms_key_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Key Management Service (KMS ) KMS key (KMS key) used to encrypt objects delivered by Config. Must belong to the same Region as the destination S3 bucket.</p>
        pub fn set_s3_kms_key_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_kms_key_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic to which Config sends notifications about configuration changes.</p>
        /// <p>If you choose a topic from another account, the topic must have policies that grant access permissions to Config. For more information, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/sns-topic-policy.html">Permissions for the Amazon SNS Topic</a> in the <i>Config Developer Guide</i>.</p>
        pub fn sns_topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.sns_topic_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic to which Config sends notifications about configuration changes.</p>
        /// <p>If you choose a topic from another account, the topic must have policies that grant access permissions to Config. For more information, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/sns-topic-policy.html">Permissions for the Amazon SNS Topic</a> in the <i>Config Developer Guide</i>.</p>
        pub fn set_sns_topic_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sns_topic_arn = input;
            self
        }
        /// <p>The options for how often Config delivers configuration snapshots to the Amazon S3 bucket.</p>
        pub fn config_snapshot_delivery_properties(
            mut self,
            input: crate::model::ConfigSnapshotDeliveryProperties,
        ) -> Self {
            self.config_snapshot_delivery_properties = Some(input);
            self
        }
        /// <p>The options for how often Config delivers configuration snapshots to the Amazon S3 bucket.</p>
        pub fn set_config_snapshot_delivery_properties(
            mut self,
            input: std::option::Option<crate::model::ConfigSnapshotDeliveryProperties>,
        ) -> Self {
            self.config_snapshot_delivery_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DeliveryChannel`](crate::model::DeliveryChannel).
        pub fn build(self) -> crate::model::DeliveryChannel {
            crate::model::DeliveryChannel {
                name: self.name,
                s3_bucket_name: self.s3_bucket_name,
                s3_key_prefix: self.s3_key_prefix,
                s3_kms_key_arn: self.s3_kms_key_arn,
                sns_topic_arn: self.sns_topic_arn,
                config_snapshot_delivery_properties: self.config_snapshot_delivery_properties,
            }
        }
    }
}

/// <p>Provides options for how often Config delivers configuration snapshots to the Amazon S3 bucket in your delivery channel.</p>
/// <p>The frequency for a rule that triggers evaluations for your resources when Config delivers the configuration snapshot is set by one of two values, depending on which is less frequent:</p>
/// <ul>
/// <li> <p>The value for the <code>deliveryFrequency</code> parameter within the delivery channel configuration, which sets how often Config delivers configuration snapshots. This value also sets how often Config invokes evaluations for Config rules.</p> </li>
/// <li> <p>The value for the <code>MaximumExecutionFrequency</code> parameter, which sets the maximum frequency with which Config invokes evaluations for the rule. For more information, see <code>ConfigRule</code>.</p> </li>
/// </ul>
/// <p>If the <code>deliveryFrequency</code> value is less frequent than the <code>MaximumExecutionFrequency</code> value for a rule, Config invokes the rule only as often as the <code>deliveryFrequency</code> value.</p>
/// <ol>
/// <li> <p>For example, you want your rule to run evaluations when Config delivers the configuration snapshot.</p> </li>
/// <li> <p>You specify the <code>MaximumExecutionFrequency</code> value for <code>Six_Hours</code>. </p> </li>
/// <li> <p>You then specify the delivery channel <code>deliveryFrequency</code> value for <code>TwentyFour_Hours</code>.</p> </li>
/// <li> <p>Because the value for <code>deliveryFrequency</code> is less frequent than <code>MaximumExecutionFrequency</code>, Config invokes evaluations for the rule every 24 hours. </p> </li>
/// </ol>
/// <p>You should set the <code>MaximumExecutionFrequency</code> value to be at least as frequent as the <code>deliveryFrequency</code> value. You can view the <code>deliveryFrequency</code> value by using the <code>DescribeDeliveryChannnels</code> action.</p>
/// <p>To update the <code>deliveryFrequency</code> with which Config delivers your configuration snapshots, use the <code>PutDeliveryChannel</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfigSnapshotDeliveryProperties {
    /// <p>The frequency with which Config delivers configuration snapshots.</p>
    #[doc(hidden)]
    pub delivery_frequency: std::option::Option<crate::model::MaximumExecutionFrequency>,
}
impl ConfigSnapshotDeliveryProperties {
    /// <p>The frequency with which Config delivers configuration snapshots.</p>
    pub fn delivery_frequency(
        &self,
    ) -> std::option::Option<&crate::model::MaximumExecutionFrequency> {
        self.delivery_frequency.as_ref()
    }
}
impl ConfigSnapshotDeliveryProperties {
    /// Creates a new builder-style object to manufacture [`ConfigSnapshotDeliveryProperties`](crate::model::ConfigSnapshotDeliveryProperties).
    pub fn builder() -> crate::model::config_snapshot_delivery_properties::Builder {
        crate::model::config_snapshot_delivery_properties::Builder::default()
    }
}

/// See [`ConfigSnapshotDeliveryProperties`](crate::model::ConfigSnapshotDeliveryProperties).
pub mod config_snapshot_delivery_properties {

    /// A builder for [`ConfigSnapshotDeliveryProperties`](crate::model::ConfigSnapshotDeliveryProperties).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) delivery_frequency: std::option::Option<crate::model::MaximumExecutionFrequency>,
    }
    impl Builder {
        /// <p>The frequency with which Config delivers configuration snapshots.</p>
        pub fn delivery_frequency(
            mut self,
            input: crate::model::MaximumExecutionFrequency,
        ) -> Self {
            self.delivery_frequency = Some(input);
            self
        }
        /// <p>The frequency with which Config delivers configuration snapshots.</p>
        pub fn set_delivery_frequency(
            mut self,
            input: std::option::Option<crate::model::MaximumExecutionFrequency>,
        ) -> Self {
            self.delivery_frequency = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigSnapshotDeliveryProperties`](crate::model::ConfigSnapshotDeliveryProperties).
        pub fn build(self) -> crate::model::ConfigSnapshotDeliveryProperties {
            crate::model::ConfigSnapshotDeliveryProperties {
                delivery_frequency: self.delivery_frequency,
            }
        }
    }
}

/// <p>This API allows you to create a conformance pack template with an Amazon Web Services Systems Manager document (SSM document). To deploy a conformance pack using an SSM document, first create an SSM document with conformance pack content, and then provide the <code>DocumentName</code> in the <a href="https://docs.aws.amazon.com/config/latest/APIReference/API_PutConformancePack.html">PutConformancePack API</a>. You can also provide the <code>DocumentVersion</code>.</p>
/// <p>The <code>TemplateSSMDocumentDetails</code> object contains the name of the SSM document and the version of the SSM document.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TemplateSsmDocumentDetails {
    /// <p>The name or Amazon Resource Name (ARN) of the SSM document to use to create a conformance pack. If you use the document name, Config checks only your account and Amazon Web Services Region for the SSM document. If you want to use an SSM document from another Region or account, you must provide the ARN.</p>
    #[doc(hidden)]
    pub document_name: std::option::Option<std::string::String>,
    /// <p>The version of the SSM document to use to create a conformance pack. By default, Config uses the latest version.</p> <note>
    /// <p>This field is optional.</p>
    /// </note>
    #[doc(hidden)]
    pub document_version: std::option::Option<std::string::String>,
}
impl TemplateSsmDocumentDetails {
    /// <p>The name or Amazon Resource Name (ARN) of the SSM document to use to create a conformance pack. If you use the document name, Config checks only your account and Amazon Web Services Region for the SSM document. If you want to use an SSM document from another Region or account, you must provide the ARN.</p>
    pub fn document_name(&self) -> std::option::Option<&str> {
        self.document_name.as_deref()
    }
    /// <p>The version of the SSM document to use to create a conformance pack. By default, Config uses the latest version.</p> <note>
    /// <p>This field is optional.</p>
    /// </note>
    pub fn document_version(&self) -> std::option::Option<&str> {
        self.document_version.as_deref()
    }
}
impl TemplateSsmDocumentDetails {
    /// Creates a new builder-style object to manufacture [`TemplateSsmDocumentDetails`](crate::model::TemplateSsmDocumentDetails).
    pub fn builder() -> crate::model::template_ssm_document_details::Builder {
        crate::model::template_ssm_document_details::Builder::default()
    }
}

/// See [`TemplateSsmDocumentDetails`](crate::model::TemplateSsmDocumentDetails).
pub mod template_ssm_document_details {

    /// A builder for [`TemplateSsmDocumentDetails`](crate::model::TemplateSsmDocumentDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_name: std::option::Option<std::string::String>,
        pub(crate) document_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name or Amazon Resource Name (ARN) of the SSM document to use to create a conformance pack. If you use the document name, Config checks only your account and Amazon Web Services Region for the SSM document. If you want to use an SSM document from another Region or account, you must provide the ARN.</p>
        pub fn document_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_name = Some(input.into());
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the SSM document to use to create a conformance pack. If you use the document name, Config checks only your account and Amazon Web Services Region for the SSM document. If you want to use an SSM document from another Region or account, you must provide the ARN.</p>
        pub fn set_document_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_name = input;
            self
        }
        /// <p>The version of the SSM document to use to create a conformance pack. By default, Config uses the latest version.</p> <note>
        /// <p>This field is optional.</p>
        /// </note>
        pub fn document_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_version = Some(input.into());
            self
        }
        /// <p>The version of the SSM document to use to create a conformance pack. By default, Config uses the latest version.</p> <note>
        /// <p>This field is optional.</p>
        /// </note>
        pub fn set_document_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_version = input;
            self
        }
        /// Consumes the builder and constructs a [`TemplateSsmDocumentDetails`](crate::model::TemplateSsmDocumentDetails).
        pub fn build(self) -> crate::model::TemplateSsmDocumentDetails {
            crate::model::TemplateSsmDocumentDetails {
                document_name: self.document_name,
                document_version: self.document_version,
            }
        }
    }
}

/// <p>An object that represents the recording of configuration changes of an Amazon Web Services resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfigurationRecorder {
    /// <p>The name of the recorder. By default, Config automatically assigns the name "default" when creating the configuration recorder. You cannot change the assigned name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Amazon Resource Name (ARN) of the IAM role used to describe the Amazon Web Services resources associated with the account.</p> <note>
    /// <p>While the API model does not require this field, the server will reject a request without a defined roleARN for the configuration recorder.</p>
    /// </note>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>Specifies the types of Amazon Web Services resources for which Config records configuration changes.</p>
    #[doc(hidden)]
    pub recording_group: std::option::Option<crate::model::RecordingGroup>,
}
impl ConfigurationRecorder {
    /// <p>The name of the recorder. By default, Config automatically assigns the name "default" when creating the configuration recorder. You cannot change the assigned name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Amazon Resource Name (ARN) of the IAM role used to describe the Amazon Web Services resources associated with the account.</p> <note>
    /// <p>While the API model does not require this field, the server will reject a request without a defined roleARN for the configuration recorder.</p>
    /// </note>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>Specifies the types of Amazon Web Services resources for which Config records configuration changes.</p>
    pub fn recording_group(&self) -> std::option::Option<&crate::model::RecordingGroup> {
        self.recording_group.as_ref()
    }
}
impl ConfigurationRecorder {
    /// Creates a new builder-style object to manufacture [`ConfigurationRecorder`](crate::model::ConfigurationRecorder).
    pub fn builder() -> crate::model::configuration_recorder::Builder {
        crate::model::configuration_recorder::Builder::default()
    }
}

/// See [`ConfigurationRecorder`](crate::model::ConfigurationRecorder).
pub mod configuration_recorder {

    /// A builder for [`ConfigurationRecorder`](crate::model::ConfigurationRecorder).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) recording_group: std::option::Option<crate::model::RecordingGroup>,
    }
    impl Builder {
        /// <p>The name of the recorder. By default, Config automatically assigns the name "default" when creating the configuration recorder. You cannot change the assigned name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the recorder. By default, Config automatically assigns the name "default" when creating the configuration recorder. You cannot change the assigned name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Amazon Resource Name (ARN) of the IAM role used to describe the Amazon Web Services resources associated with the account.</p> <note>
        /// <p>While the API model does not require this field, the server will reject a request without a defined roleARN for the configuration recorder.</p>
        /// </note>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>Amazon Resource Name (ARN) of the IAM role used to describe the Amazon Web Services resources associated with the account.</p> <note>
        /// <p>While the API model does not require this field, the server will reject a request without a defined roleARN for the configuration recorder.</p>
        /// </note>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>Specifies the types of Amazon Web Services resources for which Config records configuration changes.</p>
        pub fn recording_group(mut self, input: crate::model::RecordingGroup) -> Self {
            self.recording_group = Some(input);
            self
        }
        /// <p>Specifies the types of Amazon Web Services resources for which Config records configuration changes.</p>
        pub fn set_recording_group(
            mut self,
            input: std::option::Option<crate::model::RecordingGroup>,
        ) -> Self {
            self.recording_group = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigurationRecorder`](crate::model::ConfigurationRecorder).
        pub fn build(self) -> crate::model::ConfigurationRecorder {
            crate::model::ConfigurationRecorder {
                name: self.name,
                role_arn: self.role_arn,
                recording_group: self.recording_group,
            }
        }
    }
}

/// <p>Specifies which Amazon Web Services resource types Config records for configuration changes. In the recording group, you specify whether you want to record all supported resource types or only specific types of resources.</p>
/// <p>By default, Config records the configuration changes for all supported types of <i>regional resources</i> that Config discovers in the region in which it is running. Regional resources are tied to a region and can be used only in that region. Examples of regional resources are EC2 instances and EBS volumes.</p>
/// <p>You can also have Config record supported types of <i>global resources</i>. Global resources are not tied to a specific region and can be used in all regions. The global resource types that Config supports include IAM users, groups, roles, and customer managed policies.</p> <important>
/// <p>Global resource types onboarded to Config recording after February 2022 will only be recorded in the service's home region for the commercial partition and Amazon Web Services GovCloud (US) West for the GovCloud partition. You can view the Configuration Items for these new global resource types only in their home region and Amazon Web Services GovCloud (US) West.</p>
/// <p>Supported global resource types onboarded before February 2022 such as <code>AWS::IAM::Group</code>, <code>AWS::IAM::Policy</code>, <code>AWS::IAM::Role</code>, <code>AWS::IAM::User</code> remain unchanged, and they will continue to deliver Configuration Items in all supported regions in Config. The change will only affect new global resource types onboarded after February 2022.</p>
/// <p>To record global resource types onboarded after February 2022, enable All Supported Resource Types in the home region of the global resource type you want to record.</p>
/// </important>
/// <p>If you don't want Config to record all resources, you can specify which types of resources it will record with the <code>resourceTypes</code> parameter.</p>
/// <p>For a list of supported resource types, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/resource-config-reference.html#supported-resources">Supported Resource Types</a>.</p>
/// <p>For more information and a table of the Home Regions for Global Resource Types Onboarded after February 2022, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/select-resources.html">Selecting Which Resources Config Records</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecordingGroup {
    /// <p>Specifies whether Config records configuration changes for every supported type of regional resource.</p>
    /// <p>If you set this option to <code>true</code>, when Config adds support for a new type of regional resource, it starts recording resources of that type automatically.</p>
    /// <p>If you set this option to <code>true</code>, you cannot enumerate a list of <code>resourceTypes</code>.</p>
    #[doc(hidden)]
    pub all_supported: bool,
    /// <p>Specifies whether Config includes all supported types of global resources (for example, IAM resources) with the resources that it records.</p>
    /// <p>Before you can set this option to <code>true</code>, you must set the <code>allSupported</code> option to <code>true</code>.</p>
    /// <p>If you set this option to <code>true</code>, when Config adds support for a new type of global resource, it starts recording resources of that type automatically.</p>
    /// <p>The configuration details for any global resource are the same in all regions. To prevent duplicate configuration items, you should consider customizing Config in only one region to record global resources.</p>
    #[doc(hidden)]
    pub include_global_resource_types: bool,
    /// <p>A comma-separated list that specifies the types of Amazon Web Services resources for which Config records configuration changes (for example, <code>AWS::EC2::Instance</code> or <code>AWS::CloudTrail::Trail</code>).</p>
    /// <p>To record all configuration changes, you must set the <code>allSupported</code> option to <code>true</code>.</p>
    /// <p>If you set this option to <code>false</code>, when Config adds support for a new type of resource, it will not record resources of that type unless you manually add that type to your recording group.</p>
    /// <p>For a list of valid <code>resourceTypes</code> values, see the <b>resourceType Value</b> column in <a href="https://docs.aws.amazon.com/config/latest/developerguide/resource-config-reference.html#supported-resources">Supported Amazon Web Services resource Types</a>.</p>
    #[doc(hidden)]
    pub resource_types: std::option::Option<std::vec::Vec<crate::model::ResourceType>>,
}
impl RecordingGroup {
    /// <p>Specifies whether Config records configuration changes for every supported type of regional resource.</p>
    /// <p>If you set this option to <code>true</code>, when Config adds support for a new type of regional resource, it starts recording resources of that type automatically.</p>
    /// <p>If you set this option to <code>true</code>, you cannot enumerate a list of <code>resourceTypes</code>.</p>
    pub fn all_supported(&self) -> bool {
        self.all_supported
    }
    /// <p>Specifies whether Config includes all supported types of global resources (for example, IAM resources) with the resources that it records.</p>
    /// <p>Before you can set this option to <code>true</code>, you must set the <code>allSupported</code> option to <code>true</code>.</p>
    /// <p>If you set this option to <code>true</code>, when Config adds support for a new type of global resource, it starts recording resources of that type automatically.</p>
    /// <p>The configuration details for any global resource are the same in all regions. To prevent duplicate configuration items, you should consider customizing Config in only one region to record global resources.</p>
    pub fn include_global_resource_types(&self) -> bool {
        self.include_global_resource_types
    }
    /// <p>A comma-separated list that specifies the types of Amazon Web Services resources for which Config records configuration changes (for example, <code>AWS::EC2::Instance</code> or <code>AWS::CloudTrail::Trail</code>).</p>
    /// <p>To record all configuration changes, you must set the <code>allSupported</code> option to <code>true</code>.</p>
    /// <p>If you set this option to <code>false</code>, when Config adds support for a new type of resource, it will not record resources of that type unless you manually add that type to your recording group.</p>
    /// <p>For a list of valid <code>resourceTypes</code> values, see the <b>resourceType Value</b> column in <a href="https://docs.aws.amazon.com/config/latest/developerguide/resource-config-reference.html#supported-resources">Supported Amazon Web Services resource Types</a>.</p>
    pub fn resource_types(&self) -> std::option::Option<&[crate::model::ResourceType]> {
        self.resource_types.as_deref()
    }
}
impl RecordingGroup {
    /// Creates a new builder-style object to manufacture [`RecordingGroup`](crate::model::RecordingGroup).
    pub fn builder() -> crate::model::recording_group::Builder {
        crate::model::recording_group::Builder::default()
    }
}

/// See [`RecordingGroup`](crate::model::RecordingGroup).
pub mod recording_group {

    /// A builder for [`RecordingGroup`](crate::model::RecordingGroup).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) all_supported: std::option::Option<bool>,
        pub(crate) include_global_resource_types: std::option::Option<bool>,
        pub(crate) resource_types: std::option::Option<std::vec::Vec<crate::model::ResourceType>>,
    }
    impl Builder {
        /// <p>Specifies whether Config records configuration changes for every supported type of regional resource.</p>
        /// <p>If you set this option to <code>true</code>, when Config adds support for a new type of regional resource, it starts recording resources of that type automatically.</p>
        /// <p>If you set this option to <code>true</code>, you cannot enumerate a list of <code>resourceTypes</code>.</p>
        pub fn all_supported(mut self, input: bool) -> Self {
            self.all_supported = Some(input);
            self
        }
        /// <p>Specifies whether Config records configuration changes for every supported type of regional resource.</p>
        /// <p>If you set this option to <code>true</code>, when Config adds support for a new type of regional resource, it starts recording resources of that type automatically.</p>
        /// <p>If you set this option to <code>true</code>, you cannot enumerate a list of <code>resourceTypes</code>.</p>
        pub fn set_all_supported(mut self, input: std::option::Option<bool>) -> Self {
            self.all_supported = input;
            self
        }
        /// <p>Specifies whether Config includes all supported types of global resources (for example, IAM resources) with the resources that it records.</p>
        /// <p>Before you can set this option to <code>true</code>, you must set the <code>allSupported</code> option to <code>true</code>.</p>
        /// <p>If you set this option to <code>true</code>, when Config adds support for a new type of global resource, it starts recording resources of that type automatically.</p>
        /// <p>The configuration details for any global resource are the same in all regions. To prevent duplicate configuration items, you should consider customizing Config in only one region to record global resources.</p>
        pub fn include_global_resource_types(mut self, input: bool) -> Self {
            self.include_global_resource_types = Some(input);
            self
        }
        /// <p>Specifies whether Config includes all supported types of global resources (for example, IAM resources) with the resources that it records.</p>
        /// <p>Before you can set this option to <code>true</code>, you must set the <code>allSupported</code> option to <code>true</code>.</p>
        /// <p>If you set this option to <code>true</code>, when Config adds support for a new type of global resource, it starts recording resources of that type automatically.</p>
        /// <p>The configuration details for any global resource are the same in all regions. To prevent duplicate configuration items, you should consider customizing Config in only one region to record global resources.</p>
        pub fn set_include_global_resource_types(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.include_global_resource_types = input;
            self
        }
        /// Appends an item to `resource_types`.
        ///
        /// To override the contents of this collection use [`set_resource_types`](Self::set_resource_types).
        ///
        /// <p>A comma-separated list that specifies the types of Amazon Web Services resources for which Config records configuration changes (for example, <code>AWS::EC2::Instance</code> or <code>AWS::CloudTrail::Trail</code>).</p>
        /// <p>To record all configuration changes, you must set the <code>allSupported</code> option to <code>true</code>.</p>
        /// <p>If you set this option to <code>false</code>, when Config adds support for a new type of resource, it will not record resources of that type unless you manually add that type to your recording group.</p>
        /// <p>For a list of valid <code>resourceTypes</code> values, see the <b>resourceType Value</b> column in <a href="https://docs.aws.amazon.com/config/latest/developerguide/resource-config-reference.html#supported-resources">Supported Amazon Web Services resource Types</a>.</p>
        pub fn resource_types(mut self, input: crate::model::ResourceType) -> Self {
            let mut v = self.resource_types.unwrap_or_default();
            v.push(input);
            self.resource_types = Some(v);
            self
        }
        /// <p>A comma-separated list that specifies the types of Amazon Web Services resources for which Config records configuration changes (for example, <code>AWS::EC2::Instance</code> or <code>AWS::CloudTrail::Trail</code>).</p>
        /// <p>To record all configuration changes, you must set the <code>allSupported</code> option to <code>true</code>.</p>
        /// <p>If you set this option to <code>false</code>, when Config adds support for a new type of resource, it will not record resources of that type unless you manually add that type to your recording group.</p>
        /// <p>For a list of valid <code>resourceTypes</code> values, see the <b>resourceType Value</b> column in <a href="https://docs.aws.amazon.com/config/latest/developerguide/resource-config-reference.html#supported-resources">Supported Amazon Web Services resource Types</a>.</p>
        pub fn set_resource_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourceType>>,
        ) -> Self {
            self.resource_types = input;
            self
        }
        /// Consumes the builder and constructs a [`RecordingGroup`](crate::model::RecordingGroup).
        pub fn build(self) -> crate::model::RecordingGroup {
            crate::model::RecordingGroup {
                all_supported: self.all_supported.unwrap_or_default(),
                include_global_resource_types: self
                    .include_global_resource_types
                    .unwrap_or_default(),
                resource_types: self.resource_types,
            }
        }
    }
}

/// <p>The details about the configuration aggregator, including information about source accounts, regions, and metadata of the aggregator. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfigurationAggregator {
    /// <p>The name of the aggregator.</p>
    #[doc(hidden)]
    pub configuration_aggregator_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the aggregator.</p>
    #[doc(hidden)]
    pub configuration_aggregator_arn: std::option::Option<std::string::String>,
    /// <p>Provides a list of source accounts and regions to be aggregated.</p>
    #[doc(hidden)]
    pub account_aggregation_sources:
        std::option::Option<std::vec::Vec<crate::model::AccountAggregationSource>>,
    /// <p>Provides an organization and list of regions to be aggregated.</p>
    #[doc(hidden)]
    pub organization_aggregation_source:
        std::option::Option<crate::model::OrganizationAggregationSource>,
    /// <p>The time stamp when the configuration aggregator was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time of the last update.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Amazon Web Services service that created the configuration aggregator.</p>
    #[doc(hidden)]
    pub created_by: std::option::Option<std::string::String>,
}
impl ConfigurationAggregator {
    /// <p>The name of the aggregator.</p>
    pub fn configuration_aggregator_name(&self) -> std::option::Option<&str> {
        self.configuration_aggregator_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the aggregator.</p>
    pub fn configuration_aggregator_arn(&self) -> std::option::Option<&str> {
        self.configuration_aggregator_arn.as_deref()
    }
    /// <p>Provides a list of source accounts and regions to be aggregated.</p>
    pub fn account_aggregation_sources(
        &self,
    ) -> std::option::Option<&[crate::model::AccountAggregationSource]> {
        self.account_aggregation_sources.as_deref()
    }
    /// <p>Provides an organization and list of regions to be aggregated.</p>
    pub fn organization_aggregation_source(
        &self,
    ) -> std::option::Option<&crate::model::OrganizationAggregationSource> {
        self.organization_aggregation_source.as_ref()
    }
    /// <p>The time stamp when the configuration aggregator was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The time of the last update.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_time.as_ref()
    }
    /// <p>Amazon Web Services service that created the configuration aggregator.</p>
    pub fn created_by(&self) -> std::option::Option<&str> {
        self.created_by.as_deref()
    }
}
impl ConfigurationAggregator {
    /// Creates a new builder-style object to manufacture [`ConfigurationAggregator`](crate::model::ConfigurationAggregator).
    pub fn builder() -> crate::model::configuration_aggregator::Builder {
        crate::model::configuration_aggregator::Builder::default()
    }
}

/// See [`ConfigurationAggregator`](crate::model::ConfigurationAggregator).
pub mod configuration_aggregator {

    /// A builder for [`ConfigurationAggregator`](crate::model::ConfigurationAggregator).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configuration_aggregator_name: std::option::Option<std::string::String>,
        pub(crate) configuration_aggregator_arn: std::option::Option<std::string::String>,
        pub(crate) account_aggregation_sources:
            std::option::Option<std::vec::Vec<crate::model::AccountAggregationSource>>,
        pub(crate) organization_aggregation_source:
            std::option::Option<crate::model::OrganizationAggregationSource>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_by: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the aggregator.</p>
        pub fn configuration_aggregator_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.configuration_aggregator_name = Some(input.into());
            self
        }
        /// <p>The name of the aggregator.</p>
        pub fn set_configuration_aggregator_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.configuration_aggregator_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the aggregator.</p>
        pub fn configuration_aggregator_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.configuration_aggregator_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the aggregator.</p>
        pub fn set_configuration_aggregator_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.configuration_aggregator_arn = input;
            self
        }
        /// Appends an item to `account_aggregation_sources`.
        ///
        /// To override the contents of this collection use [`set_account_aggregation_sources`](Self::set_account_aggregation_sources).
        ///
        /// <p>Provides a list of source accounts and regions to be aggregated.</p>
        pub fn account_aggregation_sources(
            mut self,
            input: crate::model::AccountAggregationSource,
        ) -> Self {
            let mut v = self.account_aggregation_sources.unwrap_or_default();
            v.push(input);
            self.account_aggregation_sources = Some(v);
            self
        }
        /// <p>Provides a list of source accounts and regions to be aggregated.</p>
        pub fn set_account_aggregation_sources(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AccountAggregationSource>>,
        ) -> Self {
            self.account_aggregation_sources = input;
            self
        }
        /// <p>Provides an organization and list of regions to be aggregated.</p>
        pub fn organization_aggregation_source(
            mut self,
            input: crate::model::OrganizationAggregationSource,
        ) -> Self {
            self.organization_aggregation_source = Some(input);
            self
        }
        /// <p>Provides an organization and list of regions to be aggregated.</p>
        pub fn set_organization_aggregation_source(
            mut self,
            input: std::option::Option<crate::model::OrganizationAggregationSource>,
        ) -> Self {
            self.organization_aggregation_source = input;
            self
        }
        /// <p>The time stamp when the configuration aggregator was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time stamp when the configuration aggregator was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time of the last update.</p>
        pub fn last_updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_time = Some(input);
            self
        }
        /// <p>The time of the last update.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// <p>Amazon Web Services service that created the configuration aggregator.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        /// <p>Amazon Web Services service that created the configuration aggregator.</p>
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigurationAggregator`](crate::model::ConfigurationAggregator).
        pub fn build(self) -> crate::model::ConfigurationAggregator {
            crate::model::ConfigurationAggregator {
                configuration_aggregator_name: self.configuration_aggregator_name,
                configuration_aggregator_arn: self.configuration_aggregator_arn,
                account_aggregation_sources: self.account_aggregation_sources,
                organization_aggregation_source: self.organization_aggregation_source,
                creation_time: self.creation_time,
                last_updated_time: self.last_updated_time,
                created_by: self.created_by,
            }
        }
    }
}

/// <p>This object contains regions to set up the aggregator and an IAM role to retrieve organization details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OrganizationAggregationSource {
    /// <p>ARN of the IAM role used to retrieve Amazon Web Services Organization details associated with the aggregator account.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The source regions being aggregated.</p>
    #[doc(hidden)]
    pub aws_regions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>If true, aggregate existing Config regions and future regions.</p>
    #[doc(hidden)]
    pub all_aws_regions: bool,
}
impl OrganizationAggregationSource {
    /// <p>ARN of the IAM role used to retrieve Amazon Web Services Organization details associated with the aggregator account.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>The source regions being aggregated.</p>
    pub fn aws_regions(&self) -> std::option::Option<&[std::string::String]> {
        self.aws_regions.as_deref()
    }
    /// <p>If true, aggregate existing Config regions and future regions.</p>
    pub fn all_aws_regions(&self) -> bool {
        self.all_aws_regions
    }
}
impl OrganizationAggregationSource {
    /// Creates a new builder-style object to manufacture [`OrganizationAggregationSource`](crate::model::OrganizationAggregationSource).
    pub fn builder() -> crate::model::organization_aggregation_source::Builder {
        crate::model::organization_aggregation_source::Builder::default()
    }
}

/// See [`OrganizationAggregationSource`](crate::model::OrganizationAggregationSource).
pub mod organization_aggregation_source {

    /// A builder for [`OrganizationAggregationSource`](crate::model::OrganizationAggregationSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) aws_regions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) all_aws_regions: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>ARN of the IAM role used to retrieve Amazon Web Services Organization details associated with the aggregator account.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>ARN of the IAM role used to retrieve Amazon Web Services Organization details associated with the aggregator account.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Appends an item to `aws_regions`.
        ///
        /// To override the contents of this collection use [`set_aws_regions`](Self::set_aws_regions).
        ///
        /// <p>The source regions being aggregated.</p>
        pub fn aws_regions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.aws_regions.unwrap_or_default();
            v.push(input.into());
            self.aws_regions = Some(v);
            self
        }
        /// <p>The source regions being aggregated.</p>
        pub fn set_aws_regions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.aws_regions = input;
            self
        }
        /// <p>If true, aggregate existing Config regions and future regions.</p>
        pub fn all_aws_regions(mut self, input: bool) -> Self {
            self.all_aws_regions = Some(input);
            self
        }
        /// <p>If true, aggregate existing Config regions and future regions.</p>
        pub fn set_all_aws_regions(mut self, input: std::option::Option<bool>) -> Self {
            self.all_aws_regions = input;
            self
        }
        /// Consumes the builder and constructs a [`OrganizationAggregationSource`](crate::model::OrganizationAggregationSource).
        pub fn build(self) -> crate::model::OrganizationAggregationSource {
            crate::model::OrganizationAggregationSource {
                role_arn: self.role_arn,
                aws_regions: self.aws_regions,
                all_aws_regions: self.all_aws_regions.unwrap_or_default(),
            }
        }
    }
}

/// <p>A collection of accounts and regions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccountAggregationSource {
    /// <p>The 12-digit account ID of the account being aggregated. </p>
    #[doc(hidden)]
    pub account_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>If true, aggregate existing Config regions and future regions.</p>
    #[doc(hidden)]
    pub all_aws_regions: bool,
    /// <p>The source regions being aggregated.</p>
    #[doc(hidden)]
    pub aws_regions: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AccountAggregationSource {
    /// <p>The 12-digit account ID of the account being aggregated. </p>
    pub fn account_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.account_ids.as_deref()
    }
    /// <p>If true, aggregate existing Config regions and future regions.</p>
    pub fn all_aws_regions(&self) -> bool {
        self.all_aws_regions
    }
    /// <p>The source regions being aggregated.</p>
    pub fn aws_regions(&self) -> std::option::Option<&[std::string::String]> {
        self.aws_regions.as_deref()
    }
}
impl AccountAggregationSource {
    /// Creates a new builder-style object to manufacture [`AccountAggregationSource`](crate::model::AccountAggregationSource).
    pub fn builder() -> crate::model::account_aggregation_source::Builder {
        crate::model::account_aggregation_source::Builder::default()
    }
}

/// See [`AccountAggregationSource`](crate::model::AccountAggregationSource).
pub mod account_aggregation_source {

    /// A builder for [`AccountAggregationSource`](crate::model::AccountAggregationSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) all_aws_regions: std::option::Option<bool>,
        pub(crate) aws_regions: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `account_ids`.
        ///
        /// To override the contents of this collection use [`set_account_ids`](Self::set_account_ids).
        ///
        /// <p>The 12-digit account ID of the account being aggregated. </p>
        pub fn account_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.account_ids.unwrap_or_default();
            v.push(input.into());
            self.account_ids = Some(v);
            self
        }
        /// <p>The 12-digit account ID of the account being aggregated. </p>
        pub fn set_account_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.account_ids = input;
            self
        }
        /// <p>If true, aggregate existing Config regions and future regions.</p>
        pub fn all_aws_regions(mut self, input: bool) -> Self {
            self.all_aws_regions = Some(input);
            self
        }
        /// <p>If true, aggregate existing Config regions and future regions.</p>
        pub fn set_all_aws_regions(mut self, input: std::option::Option<bool>) -> Self {
            self.all_aws_regions = input;
            self
        }
        /// Appends an item to `aws_regions`.
        ///
        /// To override the contents of this collection use [`set_aws_regions`](Self::set_aws_regions).
        ///
        /// <p>The source regions being aggregated.</p>
        pub fn aws_regions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.aws_regions.unwrap_or_default();
            v.push(input.into());
            self.aws_regions = Some(v);
            self
        }
        /// <p>The source regions being aggregated.</p>
        pub fn set_aws_regions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.aws_regions = input;
            self
        }
        /// Consumes the builder and constructs a [`AccountAggregationSource`](crate::model::AccountAggregationSource).
        pub fn build(self) -> crate::model::AccountAggregationSource {
            crate::model::AccountAggregationSource {
                account_ids: self.account_ids,
                all_aws_regions: self.all_aws_regions.unwrap_or_default(),
                aws_regions: self.aws_regions,
            }
        }
    }
}

/// <p>Config rules evaluate the configuration settings of your Amazon Web Services resources. A rule can run when Config detects a configuration change to an Amazon Web Services resource or at a periodic frequency that you choose (for example, every 24 hours). There are two types of rules: Config Managed Rules and Config Custom Rules. Managed rules are predefined, customizable rules created by Config. For a list of managed rules, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/managed-rules-by-aws-config.html">List of Config Managed Rules</a>.</p>
/// <p>Custom rules are rules that you can create using either Guard or Lambda functions. Guard (<a href="https://github.com/aws-cloudformation/cloudformation-guard">Guard GitHub Repository</a>) is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. Lambda uses custom code that you upload to evaluate a custom rule. It is invoked by events that are published to it by an event source, which Config invokes when the custom rule is initiated.</p>
/// <p>For more information about developing and using Config rules, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config.html">Evaluating Amazon Web Services resource Configurations with Config</a> in the <i>Config Developer Guide</i>.</p> <note>
/// <p>You can use the Amazon Web Services CLI and Amazon Web Services SDKs if you want to create a rule that triggers evaluations for your resources when Config delivers the configuration snapshot. For more information, see <code>ConfigSnapshotDeliveryProperties</code>.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfigRule {
    /// <p>The name that you assign to the Config rule. The name is required if you are adding a new rule.</p>
    #[doc(hidden)]
    pub config_rule_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Config rule.</p>
    #[doc(hidden)]
    pub config_rule_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the Config rule.</p>
    #[doc(hidden)]
    pub config_rule_id: std::option::Option<std::string::String>,
    /// <p>The description that you provide for the Config rule.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Defines which resources can trigger an evaluation for the rule. The scope can include one or more resource types, a combination of one resource type and one resource ID, or a combination of a tag key and value. Specify a scope to constrain the resources that can trigger an evaluation for the rule. If you do not specify a scope, evaluations are triggered when any resource in the recording group changes.</p> <note>
    /// <p>The scope can be empty. </p>
    /// </note>
    #[doc(hidden)]
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>Provides the rule owner (<code>Amazon Web Services</code> for managed rules, <code>CUSTOM_POLICY</code> for Custom Policy rules, and <code>CUSTOM_LAMBDA</code> for Custom Lambda rules), the rule identifier, and the notifications that cause the function to evaluate your Amazon Web Services resources.</p>
    #[doc(hidden)]
    pub source: std::option::Option<crate::model::Source>,
    /// <p>A string, in JSON format, that is passed to the Config rule Lambda function.</p>
    #[doc(hidden)]
    pub input_parameters: std::option::Option<std::string::String>,
    /// <p>The maximum frequency with which Config runs evaluations for a rule. You can specify a value for <code>MaximumExecutionFrequency</code> when:</p>
    /// <ul>
    /// <li> <p>This is for an Config managed rule that is triggered at a periodic frequency.</p> </li>
    /// <li> <p>Your custom rule is triggered when Config delivers the configuration snapshot. For more information, see <code>ConfigSnapshotDeliveryProperties</code>.</p> </li>
    /// </ul> <note>
    /// <p>By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the <code>MaximumExecutionFrequency</code> parameter.</p>
    /// </note>
    #[doc(hidden)]
    pub maximum_execution_frequency: std::option::Option<crate::model::MaximumExecutionFrequency>,
    /// <p>Indicates whether the Config rule is active or is currently being deleted by Config. It can also indicate the evaluation status for the Config rule.</p>
    /// <p>Config sets the state of the rule to <code>EVALUATING</code> temporarily after you use the <code>StartConfigRulesEvaluation</code> request to evaluate your resources against the Config rule.</p>
    /// <p>Config sets the state of the rule to <code>DELETING_RESULTS</code> temporarily after you use the <code>DeleteEvaluationResults</code> request to delete the current evaluation results for the Config rule.</p>
    /// <p>Config temporarily sets the state of a rule to <code>DELETING</code> after you use the <code>DeleteConfigRule</code> request to delete the rule. After Config deletes the rule, the rule and all of its evaluations are erased and are no longer available.</p>
    #[doc(hidden)]
    pub config_rule_state: std::option::Option<crate::model::ConfigRuleState>,
    /// <p>Service principal name of the service that created the rule.</p> <note>
    /// <p>The field is populated only if the service-linked rule is created by a service. The field is empty if you create your own rule.</p>
    /// </note>
    #[doc(hidden)]
    pub created_by: std::option::Option<std::string::String>,
    /// <p>The modes the Config rule can be evaluated in. The valid values are distinct objects. By default, the value is Detective evaluation mode only.</p>
    #[doc(hidden)]
    pub evaluation_modes:
        std::option::Option<std::vec::Vec<crate::model::EvaluationModeConfiguration>>,
}
impl ConfigRule {
    /// <p>The name that you assign to the Config rule. The name is required if you are adding a new rule.</p>
    pub fn config_rule_name(&self) -> std::option::Option<&str> {
        self.config_rule_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Config rule.</p>
    pub fn config_rule_arn(&self) -> std::option::Option<&str> {
        self.config_rule_arn.as_deref()
    }
    /// <p>The ID of the Config rule.</p>
    pub fn config_rule_id(&self) -> std::option::Option<&str> {
        self.config_rule_id.as_deref()
    }
    /// <p>The description that you provide for the Config rule.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Defines which resources can trigger an evaluation for the rule. The scope can include one or more resource types, a combination of one resource type and one resource ID, or a combination of a tag key and value. Specify a scope to constrain the resources that can trigger an evaluation for the rule. If you do not specify a scope, evaluations are triggered when any resource in the recording group changes.</p> <note>
    /// <p>The scope can be empty. </p>
    /// </note>
    pub fn scope(&self) -> std::option::Option<&crate::model::Scope> {
        self.scope.as_ref()
    }
    /// <p>Provides the rule owner (<code>Amazon Web Services</code> for managed rules, <code>CUSTOM_POLICY</code> for Custom Policy rules, and <code>CUSTOM_LAMBDA</code> for Custom Lambda rules), the rule identifier, and the notifications that cause the function to evaluate your Amazon Web Services resources.</p>
    pub fn source(&self) -> std::option::Option<&crate::model::Source> {
        self.source.as_ref()
    }
    /// <p>A string, in JSON format, that is passed to the Config rule Lambda function.</p>
    pub fn input_parameters(&self) -> std::option::Option<&str> {
        self.input_parameters.as_deref()
    }
    /// <p>The maximum frequency with which Config runs evaluations for a rule. You can specify a value for <code>MaximumExecutionFrequency</code> when:</p>
    /// <ul>
    /// <li> <p>This is for an Config managed rule that is triggered at a periodic frequency.</p> </li>
    /// <li> <p>Your custom rule is triggered when Config delivers the configuration snapshot. For more information, see <code>ConfigSnapshotDeliveryProperties</code>.</p> </li>
    /// </ul> <note>
    /// <p>By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the <code>MaximumExecutionFrequency</code> parameter.</p>
    /// </note>
    pub fn maximum_execution_frequency(
        &self,
    ) -> std::option::Option<&crate::model::MaximumExecutionFrequency> {
        self.maximum_execution_frequency.as_ref()
    }
    /// <p>Indicates whether the Config rule is active or is currently being deleted by Config. It can also indicate the evaluation status for the Config rule.</p>
    /// <p>Config sets the state of the rule to <code>EVALUATING</code> temporarily after you use the <code>StartConfigRulesEvaluation</code> request to evaluate your resources against the Config rule.</p>
    /// <p>Config sets the state of the rule to <code>DELETING_RESULTS</code> temporarily after you use the <code>DeleteEvaluationResults</code> request to delete the current evaluation results for the Config rule.</p>
    /// <p>Config temporarily sets the state of a rule to <code>DELETING</code> after you use the <code>DeleteConfigRule</code> request to delete the rule. After Config deletes the rule, the rule and all of its evaluations are erased and are no longer available.</p>
    pub fn config_rule_state(&self) -> std::option::Option<&crate::model::ConfigRuleState> {
        self.config_rule_state.as_ref()
    }
    /// <p>Service principal name of the service that created the rule.</p> <note>
    /// <p>The field is populated only if the service-linked rule is created by a service. The field is empty if you create your own rule.</p>
    /// </note>
    pub fn created_by(&self) -> std::option::Option<&str> {
        self.created_by.as_deref()
    }
    /// <p>The modes the Config rule can be evaluated in. The valid values are distinct objects. By default, the value is Detective evaluation mode only.</p>
    pub fn evaluation_modes(
        &self,
    ) -> std::option::Option<&[crate::model::EvaluationModeConfiguration]> {
        self.evaluation_modes.as_deref()
    }
}
impl ConfigRule {
    /// Creates a new builder-style object to manufacture [`ConfigRule`](crate::model::ConfigRule).
    pub fn builder() -> crate::model::config_rule::Builder {
        crate::model::config_rule::Builder::default()
    }
}

/// See [`ConfigRule`](crate::model::ConfigRule).
pub mod config_rule {

    /// A builder for [`ConfigRule`](crate::model::ConfigRule).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) config_rule_name: std::option::Option<std::string::String>,
        pub(crate) config_rule_arn: std::option::Option<std::string::String>,
        pub(crate) config_rule_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) source: std::option::Option<crate::model::Source>,
        pub(crate) input_parameters: std::option::Option<std::string::String>,
        pub(crate) maximum_execution_frequency:
            std::option::Option<crate::model::MaximumExecutionFrequency>,
        pub(crate) config_rule_state: std::option::Option<crate::model::ConfigRuleState>,
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) evaluation_modes:
            std::option::Option<std::vec::Vec<crate::model::EvaluationModeConfiguration>>,
    }
    impl Builder {
        /// <p>The name that you assign to the Config rule. The name is required if you are adding a new rule.</p>
        pub fn config_rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.config_rule_name = Some(input.into());
            self
        }
        /// <p>The name that you assign to the Config rule. The name is required if you are adding a new rule.</p>
        pub fn set_config_rule_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.config_rule_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Config rule.</p>
        pub fn config_rule_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.config_rule_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Config rule.</p>
        pub fn set_config_rule_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.config_rule_arn = input;
            self
        }
        /// <p>The ID of the Config rule.</p>
        pub fn config_rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.config_rule_id = Some(input.into());
            self
        }
        /// <p>The ID of the Config rule.</p>
        pub fn set_config_rule_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.config_rule_id = input;
            self
        }
        /// <p>The description that you provide for the Config rule.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description that you provide for the Config rule.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Defines which resources can trigger an evaluation for the rule. The scope can include one or more resource types, a combination of one resource type and one resource ID, or a combination of a tag key and value. Specify a scope to constrain the resources that can trigger an evaluation for the rule. If you do not specify a scope, evaluations are triggered when any resource in the recording group changes.</p> <note>
        /// <p>The scope can be empty. </p>
        /// </note>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        /// <p>Defines which resources can trigger an evaluation for the rule. The scope can include one or more resource types, a combination of one resource type and one resource ID, or a combination of a tag key and value. Specify a scope to constrain the resources that can trigger an evaluation for the rule. If you do not specify a scope, evaluations are triggered when any resource in the recording group changes.</p> <note>
        /// <p>The scope can be empty. </p>
        /// </note>
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>Provides the rule owner (<code>Amazon Web Services</code> for managed rules, <code>CUSTOM_POLICY</code> for Custom Policy rules, and <code>CUSTOM_LAMBDA</code> for Custom Lambda rules), the rule identifier, and the notifications that cause the function to evaluate your Amazon Web Services resources.</p>
        pub fn source(mut self, input: crate::model::Source) -> Self {
            self.source = Some(input);
            self
        }
        /// <p>Provides the rule owner (<code>Amazon Web Services</code> for managed rules, <code>CUSTOM_POLICY</code> for Custom Policy rules, and <code>CUSTOM_LAMBDA</code> for Custom Lambda rules), the rule identifier, and the notifications that cause the function to evaluate your Amazon Web Services resources.</p>
        pub fn set_source(mut self, input: std::option::Option<crate::model::Source>) -> Self {
            self.source = input;
            self
        }
        /// <p>A string, in JSON format, that is passed to the Config rule Lambda function.</p>
        pub fn input_parameters(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_parameters = Some(input.into());
            self
        }
        /// <p>A string, in JSON format, that is passed to the Config rule Lambda function.</p>
        pub fn set_input_parameters(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.input_parameters = input;
            self
        }
        /// <p>The maximum frequency with which Config runs evaluations for a rule. You can specify a value for <code>MaximumExecutionFrequency</code> when:</p>
        /// <ul>
        /// <li> <p>This is for an Config managed rule that is triggered at a periodic frequency.</p> </li>
        /// <li> <p>Your custom rule is triggered when Config delivers the configuration snapshot. For more information, see <code>ConfigSnapshotDeliveryProperties</code>.</p> </li>
        /// </ul> <note>
        /// <p>By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the <code>MaximumExecutionFrequency</code> parameter.</p>
        /// </note>
        pub fn maximum_execution_frequency(
            mut self,
            input: crate::model::MaximumExecutionFrequency,
        ) -> Self {
            self.maximum_execution_frequency = Some(input);
            self
        }
        /// <p>The maximum frequency with which Config runs evaluations for a rule. You can specify a value for <code>MaximumExecutionFrequency</code> when:</p>
        /// <ul>
        /// <li> <p>This is for an Config managed rule that is triggered at a periodic frequency.</p> </li>
        /// <li> <p>Your custom rule is triggered when Config delivers the configuration snapshot. For more information, see <code>ConfigSnapshotDeliveryProperties</code>.</p> </li>
        /// </ul> <note>
        /// <p>By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the <code>MaximumExecutionFrequency</code> parameter.</p>
        /// </note>
        pub fn set_maximum_execution_frequency(
            mut self,
            input: std::option::Option<crate::model::MaximumExecutionFrequency>,
        ) -> Self {
            self.maximum_execution_frequency = input;
            self
        }
        /// <p>Indicates whether the Config rule is active or is currently being deleted by Config. It can also indicate the evaluation status for the Config rule.</p>
        /// <p>Config sets the state of the rule to <code>EVALUATING</code> temporarily after you use the <code>StartConfigRulesEvaluation</code> request to evaluate your resources against the Config rule.</p>
        /// <p>Config sets the state of the rule to <code>DELETING_RESULTS</code> temporarily after you use the <code>DeleteEvaluationResults</code> request to delete the current evaluation results for the Config rule.</p>
        /// <p>Config temporarily sets the state of a rule to <code>DELETING</code> after you use the <code>DeleteConfigRule</code> request to delete the rule. After Config deletes the rule, the rule and all of its evaluations are erased and are no longer available.</p>
        pub fn config_rule_state(mut self, input: crate::model::ConfigRuleState) -> Self {
            self.config_rule_state = Some(input);
            self
        }
        /// <p>Indicates whether the Config rule is active or is currently being deleted by Config. It can also indicate the evaluation status for the Config rule.</p>
        /// <p>Config sets the state of the rule to <code>EVALUATING</code> temporarily after you use the <code>StartConfigRulesEvaluation</code> request to evaluate your resources against the Config rule.</p>
        /// <p>Config sets the state of the rule to <code>DELETING_RESULTS</code> temporarily after you use the <code>DeleteEvaluationResults</code> request to delete the current evaluation results for the Config rule.</p>
        /// <p>Config temporarily sets the state of a rule to <code>DELETING</code> after you use the <code>DeleteConfigRule</code> request to delete the rule. After Config deletes the rule, the rule and all of its evaluations are erased and are no longer available.</p>
        pub fn set_config_rule_state(
            mut self,
            input: std::option::Option<crate::model::ConfigRuleState>,
        ) -> Self {
            self.config_rule_state = input;
            self
        }
        /// <p>Service principal name of the service that created the rule.</p> <note>
        /// <p>The field is populated only if the service-linked rule is created by a service. The field is empty if you create your own rule.</p>
        /// </note>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        /// <p>Service principal name of the service that created the rule.</p> <note>
        /// <p>The field is populated only if the service-linked rule is created by a service. The field is empty if you create your own rule.</p>
        /// </note>
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// Appends an item to `evaluation_modes`.
        ///
        /// To override the contents of this collection use [`set_evaluation_modes`](Self::set_evaluation_modes).
        ///
        /// <p>The modes the Config rule can be evaluated in. The valid values are distinct objects. By default, the value is Detective evaluation mode only.</p>
        pub fn evaluation_modes(
            mut self,
            input: crate::model::EvaluationModeConfiguration,
        ) -> Self {
            let mut v = self.evaluation_modes.unwrap_or_default();
            v.push(input);
            self.evaluation_modes = Some(v);
            self
        }
        /// <p>The modes the Config rule can be evaluated in. The valid values are distinct objects. By default, the value is Detective evaluation mode only.</p>
        pub fn set_evaluation_modes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EvaluationModeConfiguration>>,
        ) -> Self {
            self.evaluation_modes = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigRule`](crate::model::ConfigRule).
        pub fn build(self) -> crate::model::ConfigRule {
            crate::model::ConfigRule {
                config_rule_name: self.config_rule_name,
                config_rule_arn: self.config_rule_arn,
                config_rule_id: self.config_rule_id,
                description: self.description,
                scope: self.scope,
                source: self.source,
                input_parameters: self.input_parameters,
                maximum_execution_frequency: self.maximum_execution_frequency,
                config_rule_state: self.config_rule_state,
                created_by: self.created_by,
                evaluation_modes: self.evaluation_modes,
            }
        }
    }
}

/// <p>The configuration object for Config rule evaluation mode. The Supported valid values are Detective or Proactive.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EvaluationModeConfiguration {
    /// <p>The mode of an evaluation. The valid values are Detective or Proactive.</p>
    #[doc(hidden)]
    pub mode: std::option::Option<crate::model::EvaluationMode>,
}
impl EvaluationModeConfiguration {
    /// <p>The mode of an evaluation. The valid values are Detective or Proactive.</p>
    pub fn mode(&self) -> std::option::Option<&crate::model::EvaluationMode> {
        self.mode.as_ref()
    }
}
impl EvaluationModeConfiguration {
    /// Creates a new builder-style object to manufacture [`EvaluationModeConfiguration`](crate::model::EvaluationModeConfiguration).
    pub fn builder() -> crate::model::evaluation_mode_configuration::Builder {
        crate::model::evaluation_mode_configuration::Builder::default()
    }
}

/// See [`EvaluationModeConfiguration`](crate::model::EvaluationModeConfiguration).
pub mod evaluation_mode_configuration {

    /// A builder for [`EvaluationModeConfiguration`](crate::model::EvaluationModeConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mode: std::option::Option<crate::model::EvaluationMode>,
    }
    impl Builder {
        /// <p>The mode of an evaluation. The valid values are Detective or Proactive.</p>
        pub fn mode(mut self, input: crate::model::EvaluationMode) -> Self {
            self.mode = Some(input);
            self
        }
        /// <p>The mode of an evaluation. The valid values are Detective or Proactive.</p>
        pub fn set_mode(
            mut self,
            input: std::option::Option<crate::model::EvaluationMode>,
        ) -> Self {
            self.mode = input;
            self
        }
        /// Consumes the builder and constructs a [`EvaluationModeConfiguration`](crate::model::EvaluationModeConfiguration).
        pub fn build(self) -> crate::model::EvaluationModeConfiguration {
            crate::model::EvaluationModeConfiguration { mode: self.mode }
        }
    }
}

/// When writing a match expression against `ConfigRuleState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let configrulestate = unimplemented!();
/// match configrulestate {
///     ConfigRuleState::Active => { /* ... */ },
///     ConfigRuleState::Deleting => { /* ... */ },
///     ConfigRuleState::DeletingResults => { /* ... */ },
///     ConfigRuleState::Evaluating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `configrulestate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConfigRuleState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConfigRuleState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConfigRuleState::NewFeature` is defined.
/// Specifically, when `configrulestate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConfigRuleState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConfigRuleState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    DeletingResults,
    #[allow(missing_docs)] // documentation missing in model
    Evaluating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConfigRuleState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => ConfigRuleState::Active,
            "DELETING" => ConfigRuleState::Deleting,
            "DELETING_RESULTS" => ConfigRuleState::DeletingResults,
            "EVALUATING" => ConfigRuleState::Evaluating,
            other => ConfigRuleState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ConfigRuleState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConfigRuleState::from(s))
    }
}
impl ConfigRuleState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConfigRuleState::Active => "ACTIVE",
            ConfigRuleState::Deleting => "DELETING",
            ConfigRuleState::DeletingResults => "DELETING_RESULTS",
            ConfigRuleState::Evaluating => "EVALUATING",
            ConfigRuleState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "DELETING", "DELETING_RESULTS", "EVALUATING"]
    }
}
impl AsRef<str> for ConfigRuleState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides the CustomPolicyDetails, the rule owner (<code>Amazon Web Services</code> for managed rules, <code>CUSTOM_POLICY</code> for Custom Policy rules, and <code>CUSTOM_LAMBDA</code> for Custom Lambda rules), the rule identifier, and the events that cause the evaluation of your Amazon Web Services resources.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Source {
    /// <p>Indicates whether Amazon Web Services or the customer owns and manages the Config rule.</p>
    /// <p>Config Managed Rules are predefined rules owned by Amazon Web Services. For more information, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_use-managed-rules.html">Config Managed Rules</a> in the <i>Config developer guide</i>.</p>
    /// <p>Config Custom Rules are rules that you can develop either with Guard (<code>CUSTOM_POLICY</code>) or Lambda (<code>CUSTOM_LAMBDA</code>). For more information, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_develop-rules.html">Config Custom Rules </a> in the <i>Config developer guide</i>.</p>
    #[doc(hidden)]
    pub owner: std::option::Option<crate::model::Owner>,
    /// <p>For Config Managed rules, a predefined identifier from a list. For example, <code>IAM_PASSWORD_POLICY</code> is a managed rule. To reference a managed rule, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/managed-rules-by-aws-config.html">List of Config Managed Rules</a>.</p>
    /// <p>For Config Custom Lambda rules, the identifier is the Amazon Resource Name (ARN) of the rule's Lambda function, such as <code>arn:aws:lambda:us-east-2:123456789012:function:custom_rule_name</code>.</p>
    /// <p>For Config Custom Policy rules, this field will be ignored.</p>
    #[doc(hidden)]
    pub source_identifier: std::option::Option<std::string::String>,
    /// <p>Provides the source and the message types that cause Config to evaluate your Amazon Web Services resources against a rule. It also provides the frequency with which you want Config to run evaluations for the rule if the trigger type is periodic.</p>
    /// <p>If the owner is set to <code>CUSTOM_POLICY</code>, the only acceptable values for the Config rule trigger message type are <code>ConfigurationItemChangeNotification</code> and <code>OversizedConfigurationItemChangeNotification</code>.</p>
    #[doc(hidden)]
    pub source_details: std::option::Option<std::vec::Vec<crate::model::SourceDetail>>,
    /// <p>Provides the runtime system, policy definition, and whether debug logging is enabled. Required when owner is set to <code>CUSTOM_POLICY</code>.</p>
    #[doc(hidden)]
    pub custom_policy_details: std::option::Option<crate::model::CustomPolicyDetails>,
}
impl Source {
    /// <p>Indicates whether Amazon Web Services or the customer owns and manages the Config rule.</p>
    /// <p>Config Managed Rules are predefined rules owned by Amazon Web Services. For more information, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_use-managed-rules.html">Config Managed Rules</a> in the <i>Config developer guide</i>.</p>
    /// <p>Config Custom Rules are rules that you can develop either with Guard (<code>CUSTOM_POLICY</code>) or Lambda (<code>CUSTOM_LAMBDA</code>). For more information, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_develop-rules.html">Config Custom Rules </a> in the <i>Config developer guide</i>.</p>
    pub fn owner(&self) -> std::option::Option<&crate::model::Owner> {
        self.owner.as_ref()
    }
    /// <p>For Config Managed rules, a predefined identifier from a list. For example, <code>IAM_PASSWORD_POLICY</code> is a managed rule. To reference a managed rule, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/managed-rules-by-aws-config.html">List of Config Managed Rules</a>.</p>
    /// <p>For Config Custom Lambda rules, the identifier is the Amazon Resource Name (ARN) of the rule's Lambda function, such as <code>arn:aws:lambda:us-east-2:123456789012:function:custom_rule_name</code>.</p>
    /// <p>For Config Custom Policy rules, this field will be ignored.</p>
    pub fn source_identifier(&self) -> std::option::Option<&str> {
        self.source_identifier.as_deref()
    }
    /// <p>Provides the source and the message types that cause Config to evaluate your Amazon Web Services resources against a rule. It also provides the frequency with which you want Config to run evaluations for the rule if the trigger type is periodic.</p>
    /// <p>If the owner is set to <code>CUSTOM_POLICY</code>, the only acceptable values for the Config rule trigger message type are <code>ConfigurationItemChangeNotification</code> and <code>OversizedConfigurationItemChangeNotification</code>.</p>
    pub fn source_details(&self) -> std::option::Option<&[crate::model::SourceDetail]> {
        self.source_details.as_deref()
    }
    /// <p>Provides the runtime system, policy definition, and whether debug logging is enabled. Required when owner is set to <code>CUSTOM_POLICY</code>.</p>
    pub fn custom_policy_details(&self) -> std::option::Option<&crate::model::CustomPolicyDetails> {
        self.custom_policy_details.as_ref()
    }
}
impl Source {
    /// Creates a new builder-style object to manufacture [`Source`](crate::model::Source).
    pub fn builder() -> crate::model::source::Builder {
        crate::model::source::Builder::default()
    }
}

/// See [`Source`](crate::model::Source).
pub mod source {

    /// A builder for [`Source`](crate::model::Source).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) owner: std::option::Option<crate::model::Owner>,
        pub(crate) source_identifier: std::option::Option<std::string::String>,
        pub(crate) source_details: std::option::Option<std::vec::Vec<crate::model::SourceDetail>>,
        pub(crate) custom_policy_details: std::option::Option<crate::model::CustomPolicyDetails>,
    }
    impl Builder {
        /// <p>Indicates whether Amazon Web Services or the customer owns and manages the Config rule.</p>
        /// <p>Config Managed Rules are predefined rules owned by Amazon Web Services. For more information, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_use-managed-rules.html">Config Managed Rules</a> in the <i>Config developer guide</i>.</p>
        /// <p>Config Custom Rules are rules that you can develop either with Guard (<code>CUSTOM_POLICY</code>) or Lambda (<code>CUSTOM_LAMBDA</code>). For more information, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_develop-rules.html">Config Custom Rules </a> in the <i>Config developer guide</i>.</p>
        pub fn owner(mut self, input: crate::model::Owner) -> Self {
            self.owner = Some(input);
            self
        }
        /// <p>Indicates whether Amazon Web Services or the customer owns and manages the Config rule.</p>
        /// <p>Config Managed Rules are predefined rules owned by Amazon Web Services. For more information, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_use-managed-rules.html">Config Managed Rules</a> in the <i>Config developer guide</i>.</p>
        /// <p>Config Custom Rules are rules that you can develop either with Guard (<code>CUSTOM_POLICY</code>) or Lambda (<code>CUSTOM_LAMBDA</code>). For more information, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_develop-rules.html">Config Custom Rules </a> in the <i>Config developer guide</i>.</p>
        pub fn set_owner(mut self, input: std::option::Option<crate::model::Owner>) -> Self {
            self.owner = input;
            self
        }
        /// <p>For Config Managed rules, a predefined identifier from a list. For example, <code>IAM_PASSWORD_POLICY</code> is a managed rule. To reference a managed rule, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/managed-rules-by-aws-config.html">List of Config Managed Rules</a>.</p>
        /// <p>For Config Custom Lambda rules, the identifier is the Amazon Resource Name (ARN) of the rule's Lambda function, such as <code>arn:aws:lambda:us-east-2:123456789012:function:custom_rule_name</code>.</p>
        /// <p>For Config Custom Policy rules, this field will be ignored.</p>
        pub fn source_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_identifier = Some(input.into());
            self
        }
        /// <p>For Config Managed rules, a predefined identifier from a list. For example, <code>IAM_PASSWORD_POLICY</code> is a managed rule. To reference a managed rule, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/managed-rules-by-aws-config.html">List of Config Managed Rules</a>.</p>
        /// <p>For Config Custom Lambda rules, the identifier is the Amazon Resource Name (ARN) of the rule's Lambda function, such as <code>arn:aws:lambda:us-east-2:123456789012:function:custom_rule_name</code>.</p>
        /// <p>For Config Custom Policy rules, this field will be ignored.</p>
        pub fn set_source_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_identifier = input;
            self
        }
        /// Appends an item to `source_details`.
        ///
        /// To override the contents of this collection use [`set_source_details`](Self::set_source_details).
        ///
        /// <p>Provides the source and the message types that cause Config to evaluate your Amazon Web Services resources against a rule. It also provides the frequency with which you want Config to run evaluations for the rule if the trigger type is periodic.</p>
        /// <p>If the owner is set to <code>CUSTOM_POLICY</code>, the only acceptable values for the Config rule trigger message type are <code>ConfigurationItemChangeNotification</code> and <code>OversizedConfigurationItemChangeNotification</code>.</p>
        pub fn source_details(mut self, input: crate::model::SourceDetail) -> Self {
            let mut v = self.source_details.unwrap_or_default();
            v.push(input);
            self.source_details = Some(v);
            self
        }
        /// <p>Provides the source and the message types that cause Config to evaluate your Amazon Web Services resources against a rule. It also provides the frequency with which you want Config to run evaluations for the rule if the trigger type is periodic.</p>
        /// <p>If the owner is set to <code>CUSTOM_POLICY</code>, the only acceptable values for the Config rule trigger message type are <code>ConfigurationItemChangeNotification</code> and <code>OversizedConfigurationItemChangeNotification</code>.</p>
        pub fn set_source_details(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SourceDetail>>,
        ) -> Self {
            self.source_details = input;
            self
        }
        /// <p>Provides the runtime system, policy definition, and whether debug logging is enabled. Required when owner is set to <code>CUSTOM_POLICY</code>.</p>
        pub fn custom_policy_details(mut self, input: crate::model::CustomPolicyDetails) -> Self {
            self.custom_policy_details = Some(input);
            self
        }
        /// <p>Provides the runtime system, policy definition, and whether debug logging is enabled. Required when owner is set to <code>CUSTOM_POLICY</code>.</p>
        pub fn set_custom_policy_details(
            mut self,
            input: std::option::Option<crate::model::CustomPolicyDetails>,
        ) -> Self {
            self.custom_policy_details = input;
            self
        }
        /// Consumes the builder and constructs a [`Source`](crate::model::Source).
        pub fn build(self) -> crate::model::Source {
            crate::model::Source {
                owner: self.owner,
                source_identifier: self.source_identifier,
                source_details: self.source_details,
                custom_policy_details: self.custom_policy_details,
            }
        }
    }
}

/// <p>Provides the runtime system, policy definition, and whether debug logging enabled. You can specify the following CustomPolicyDetails parameter values only for Config Custom Policy rules.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomPolicyDetails {
    /// <p>The runtime system for your Config Custom Policy rule. Guard is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. For more information about Guard, see the <a href="https://github.com/aws-cloudformation/cloudformation-guard">Guard GitHub Repository</a>.</p>
    #[doc(hidden)]
    pub policy_runtime: std::option::Option<std::string::String>,
    /// <p>The policy definition containing the logic for your Config Custom Policy rule.</p>
    #[doc(hidden)]
    pub policy_text: std::option::Option<std::string::String>,
    /// <p>The boolean expression for enabling debug logging for your Config Custom Policy rule. The default value is <code>false</code>.</p>
    #[doc(hidden)]
    pub enable_debug_log_delivery: bool,
}
impl CustomPolicyDetails {
    /// <p>The runtime system for your Config Custom Policy rule. Guard is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. For more information about Guard, see the <a href="https://github.com/aws-cloudformation/cloudformation-guard">Guard GitHub Repository</a>.</p>
    pub fn policy_runtime(&self) -> std::option::Option<&str> {
        self.policy_runtime.as_deref()
    }
    /// <p>The policy definition containing the logic for your Config Custom Policy rule.</p>
    pub fn policy_text(&self) -> std::option::Option<&str> {
        self.policy_text.as_deref()
    }
    /// <p>The boolean expression for enabling debug logging for your Config Custom Policy rule. The default value is <code>false</code>.</p>
    pub fn enable_debug_log_delivery(&self) -> bool {
        self.enable_debug_log_delivery
    }
}
impl CustomPolicyDetails {
    /// Creates a new builder-style object to manufacture [`CustomPolicyDetails`](crate::model::CustomPolicyDetails).
    pub fn builder() -> crate::model::custom_policy_details::Builder {
        crate::model::custom_policy_details::Builder::default()
    }
}

/// See [`CustomPolicyDetails`](crate::model::CustomPolicyDetails).
pub mod custom_policy_details {

    /// A builder for [`CustomPolicyDetails`](crate::model::CustomPolicyDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_runtime: std::option::Option<std::string::String>,
        pub(crate) policy_text: std::option::Option<std::string::String>,
        pub(crate) enable_debug_log_delivery: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The runtime system for your Config Custom Policy rule. Guard is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. For more information about Guard, see the <a href="https://github.com/aws-cloudformation/cloudformation-guard">Guard GitHub Repository</a>.</p>
        pub fn policy_runtime(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_runtime = Some(input.into());
            self
        }
        /// <p>The runtime system for your Config Custom Policy rule. Guard is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. For more information about Guard, see the <a href="https://github.com/aws-cloudformation/cloudformation-guard">Guard GitHub Repository</a>.</p>
        pub fn set_policy_runtime(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_runtime = input;
            self
        }
        /// <p>The policy definition containing the logic for your Config Custom Policy rule.</p>
        pub fn policy_text(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_text = Some(input.into());
            self
        }
        /// <p>The policy definition containing the logic for your Config Custom Policy rule.</p>
        pub fn set_policy_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_text = input;
            self
        }
        /// <p>The boolean expression for enabling debug logging for your Config Custom Policy rule. The default value is <code>false</code>.</p>
        pub fn enable_debug_log_delivery(mut self, input: bool) -> Self {
            self.enable_debug_log_delivery = Some(input);
            self
        }
        /// <p>The boolean expression for enabling debug logging for your Config Custom Policy rule. The default value is <code>false</code>.</p>
        pub fn set_enable_debug_log_delivery(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_debug_log_delivery = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomPolicyDetails`](crate::model::CustomPolicyDetails).
        pub fn build(self) -> crate::model::CustomPolicyDetails {
            crate::model::CustomPolicyDetails {
                policy_runtime: self.policy_runtime,
                policy_text: self.policy_text,
                enable_debug_log_delivery: self.enable_debug_log_delivery.unwrap_or_default(),
            }
        }
    }
}

/// <p>Provides the source and the message types that trigger Config to evaluate your Amazon Web Services resources against a rule. It also provides the frequency with which you want Config to run evaluations for the rule if the trigger type is periodic. You can specify the parameter values for <code>SourceDetail</code> only for custom rules. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SourceDetail {
    /// <p>The source of the event, such as an Amazon Web Services service, that triggers Config to evaluate your Amazon Web Services resources.</p>
    #[doc(hidden)]
    pub event_source: std::option::Option<crate::model::EventSource>,
    /// <p>The type of notification that triggers Config to run an evaluation for a rule. You can specify the following notification types:</p>
    /// <ul>
    /// <li> <p> <code>ConfigurationItemChangeNotification</code> - Triggers an evaluation when Config delivers a configuration item as a result of a resource change.</p> </li>
    /// <li> <p> <code>OversizedConfigurationItemChangeNotification</code> - Triggers an evaluation when Config delivers an oversized configuration item. Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.</p> </li>
    /// <li> <p> <code>ScheduledNotification</code> - Triggers a periodic evaluation at the frequency specified for <code>MaximumExecutionFrequency</code>.</p> </li>
    /// <li> <p> <code>ConfigurationSnapshotDeliveryCompleted</code> - Triggers a periodic evaluation when Config delivers a configuration snapshot.</p> </li>
    /// </ul>
    /// <p>If you want your custom rule to be triggered by configuration changes, specify two SourceDetail objects, one for <code>ConfigurationItemChangeNotification</code> and one for <code>OversizedConfigurationItemChangeNotification</code>.</p>
    #[doc(hidden)]
    pub message_type: std::option::Option<crate::model::MessageType>,
    /// <p>The frequency at which you want Config to run evaluations for a custom rule with a periodic trigger. If you specify a value for <code>MaximumExecutionFrequency</code>, then <code>MessageType</code> must use the <code>ScheduledNotification</code> value.</p> <note>
    /// <p>By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the <code>MaximumExecutionFrequency</code> parameter.</p>
    /// <p>Based on the valid value you choose, Config runs evaluations once for each valid value. For example, if you choose <code>Three_Hours</code>, Config runs evaluations once every three hours. In this case, <code>Three_Hours</code> is the frequency of this rule. </p>
    /// </note>
    #[doc(hidden)]
    pub maximum_execution_frequency: std::option::Option<crate::model::MaximumExecutionFrequency>,
}
impl SourceDetail {
    /// <p>The source of the event, such as an Amazon Web Services service, that triggers Config to evaluate your Amazon Web Services resources.</p>
    pub fn event_source(&self) -> std::option::Option<&crate::model::EventSource> {
        self.event_source.as_ref()
    }
    /// <p>The type of notification that triggers Config to run an evaluation for a rule. You can specify the following notification types:</p>
    /// <ul>
    /// <li> <p> <code>ConfigurationItemChangeNotification</code> - Triggers an evaluation when Config delivers a configuration item as a result of a resource change.</p> </li>
    /// <li> <p> <code>OversizedConfigurationItemChangeNotification</code> - Triggers an evaluation when Config delivers an oversized configuration item. Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.</p> </li>
    /// <li> <p> <code>ScheduledNotification</code> - Triggers a periodic evaluation at the frequency specified for <code>MaximumExecutionFrequency</code>.</p> </li>
    /// <li> <p> <code>ConfigurationSnapshotDeliveryCompleted</code> - Triggers a periodic evaluation when Config delivers a configuration snapshot.</p> </li>
    /// </ul>
    /// <p>If you want your custom rule to be triggered by configuration changes, specify two SourceDetail objects, one for <code>ConfigurationItemChangeNotification</code> and one for <code>OversizedConfigurationItemChangeNotification</code>.</p>
    pub fn message_type(&self) -> std::option::Option<&crate::model::MessageType> {
        self.message_type.as_ref()
    }
    /// <p>The frequency at which you want Config to run evaluations for a custom rule with a periodic trigger. If you specify a value for <code>MaximumExecutionFrequency</code>, then <code>MessageType</code> must use the <code>ScheduledNotification</code> value.</p> <note>
    /// <p>By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the <code>MaximumExecutionFrequency</code> parameter.</p>
    /// <p>Based on the valid value you choose, Config runs evaluations once for each valid value. For example, if you choose <code>Three_Hours</code>, Config runs evaluations once every three hours. In this case, <code>Three_Hours</code> is the frequency of this rule. </p>
    /// </note>
    pub fn maximum_execution_frequency(
        &self,
    ) -> std::option::Option<&crate::model::MaximumExecutionFrequency> {
        self.maximum_execution_frequency.as_ref()
    }
}
impl SourceDetail {
    /// Creates a new builder-style object to manufacture [`SourceDetail`](crate::model::SourceDetail).
    pub fn builder() -> crate::model::source_detail::Builder {
        crate::model::source_detail::Builder::default()
    }
}

/// See [`SourceDetail`](crate::model::SourceDetail).
pub mod source_detail {

    /// A builder for [`SourceDetail`](crate::model::SourceDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) event_source: std::option::Option<crate::model::EventSource>,
        pub(crate) message_type: std::option::Option<crate::model::MessageType>,
        pub(crate) maximum_execution_frequency:
            std::option::Option<crate::model::MaximumExecutionFrequency>,
    }
    impl Builder {
        /// <p>The source of the event, such as an Amazon Web Services service, that triggers Config to evaluate your Amazon Web Services resources.</p>
        pub fn event_source(mut self, input: crate::model::EventSource) -> Self {
            self.event_source = Some(input);
            self
        }
        /// <p>The source of the event, such as an Amazon Web Services service, that triggers Config to evaluate your Amazon Web Services resources.</p>
        pub fn set_event_source(
            mut self,
            input: std::option::Option<crate::model::EventSource>,
        ) -> Self {
            self.event_source = input;
            self
        }
        /// <p>The type of notification that triggers Config to run an evaluation for a rule. You can specify the following notification types:</p>
        /// <ul>
        /// <li> <p> <code>ConfigurationItemChangeNotification</code> - Triggers an evaluation when Config delivers a configuration item as a result of a resource change.</p> </li>
        /// <li> <p> <code>OversizedConfigurationItemChangeNotification</code> - Triggers an evaluation when Config delivers an oversized configuration item. Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.</p> </li>
        /// <li> <p> <code>ScheduledNotification</code> - Triggers a periodic evaluation at the frequency specified for <code>MaximumExecutionFrequency</code>.</p> </li>
        /// <li> <p> <code>ConfigurationSnapshotDeliveryCompleted</code> - Triggers a periodic evaluation when Config delivers a configuration snapshot.</p> </li>
        /// </ul>
        /// <p>If you want your custom rule to be triggered by configuration changes, specify two SourceDetail objects, one for <code>ConfigurationItemChangeNotification</code> and one for <code>OversizedConfigurationItemChangeNotification</code>.</p>
        pub fn message_type(mut self, input: crate::model::MessageType) -> Self {
            self.message_type = Some(input);
            self
        }
        /// <p>The type of notification that triggers Config to run an evaluation for a rule. You can specify the following notification types:</p>
        /// <ul>
        /// <li> <p> <code>ConfigurationItemChangeNotification</code> - Triggers an evaluation when Config delivers a configuration item as a result of a resource change.</p> </li>
        /// <li> <p> <code>OversizedConfigurationItemChangeNotification</code> - Triggers an evaluation when Config delivers an oversized configuration item. Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.</p> </li>
        /// <li> <p> <code>ScheduledNotification</code> - Triggers a periodic evaluation at the frequency specified for <code>MaximumExecutionFrequency</code>.</p> </li>
        /// <li> <p> <code>ConfigurationSnapshotDeliveryCompleted</code> - Triggers a periodic evaluation when Config delivers a configuration snapshot.</p> </li>
        /// </ul>
        /// <p>If you want your custom rule to be triggered by configuration changes, specify two SourceDetail objects, one for <code>ConfigurationItemChangeNotification</code> and one for <code>OversizedConfigurationItemChangeNotification</code>.</p>
        pub fn set_message_type(
            mut self,
            input: std::option::Option<crate::model::MessageType>,
        ) -> Self {
            self.message_type = input;
            self
        }
        /// <p>The frequency at which you want Config to run evaluations for a custom rule with a periodic trigger. If you specify a value for <code>MaximumExecutionFrequency</code>, then <code>MessageType</code> must use the <code>ScheduledNotification</code> value.</p> <note>
        /// <p>By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the <code>MaximumExecutionFrequency</code> parameter.</p>
        /// <p>Based on the valid value you choose, Config runs evaluations once for each valid value. For example, if you choose <code>Three_Hours</code>, Config runs evaluations once every three hours. In this case, <code>Three_Hours</code> is the frequency of this rule. </p>
        /// </note>
        pub fn maximum_execution_frequency(
            mut self,
            input: crate::model::MaximumExecutionFrequency,
        ) -> Self {
            self.maximum_execution_frequency = Some(input);
            self
        }
        /// <p>The frequency at which you want Config to run evaluations for a custom rule with a periodic trigger. If you specify a value for <code>MaximumExecutionFrequency</code>, then <code>MessageType</code> must use the <code>ScheduledNotification</code> value.</p> <note>
        /// <p>By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the <code>MaximumExecutionFrequency</code> parameter.</p>
        /// <p>Based on the valid value you choose, Config runs evaluations once for each valid value. For example, if you choose <code>Three_Hours</code>, Config runs evaluations once every three hours. In this case, <code>Three_Hours</code> is the frequency of this rule. </p>
        /// </note>
        pub fn set_maximum_execution_frequency(
            mut self,
            input: std::option::Option<crate::model::MaximumExecutionFrequency>,
        ) -> Self {
            self.maximum_execution_frequency = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceDetail`](crate::model::SourceDetail).
        pub fn build(self) -> crate::model::SourceDetail {
            crate::model::SourceDetail {
                event_source: self.event_source,
                message_type: self.message_type,
                maximum_execution_frequency: self.maximum_execution_frequency,
            }
        }
    }
}

/// When writing a match expression against `MessageType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let messagetype = unimplemented!();
/// match messagetype {
///     MessageType::ConfigurationItemChangeNotification => { /* ... */ },
///     MessageType::ConfigurationSnapshotDeliveryCompleted => { /* ... */ },
///     MessageType::OversizedConfigurationItemChangeNotification => { /* ... */ },
///     MessageType::ScheduledNotification => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `messagetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MessageType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MessageType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MessageType::NewFeature` is defined.
/// Specifically, when `messagetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MessageType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MessageType {
    #[allow(missing_docs)] // documentation missing in model
    ConfigurationItemChangeNotification,
    #[allow(missing_docs)] // documentation missing in model
    ConfigurationSnapshotDeliveryCompleted,
    #[allow(missing_docs)] // documentation missing in model
    OversizedConfigurationItemChangeNotification,
    #[allow(missing_docs)] // documentation missing in model
    ScheduledNotification,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MessageType {
    fn from(s: &str) -> Self {
        match s {
            "ConfigurationItemChangeNotification" => {
                MessageType::ConfigurationItemChangeNotification
            }
            "ConfigurationSnapshotDeliveryCompleted" => {
                MessageType::ConfigurationSnapshotDeliveryCompleted
            }
            "OversizedConfigurationItemChangeNotification" => {
                MessageType::OversizedConfigurationItemChangeNotification
            }
            "ScheduledNotification" => MessageType::ScheduledNotification,
            other => MessageType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for MessageType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MessageType::from(s))
    }
}
impl MessageType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MessageType::ConfigurationItemChangeNotification => {
                "ConfigurationItemChangeNotification"
            }
            MessageType::ConfigurationSnapshotDeliveryCompleted => {
                "ConfigurationSnapshotDeliveryCompleted"
            }
            MessageType::OversizedConfigurationItemChangeNotification => {
                "OversizedConfigurationItemChangeNotification"
            }
            MessageType::ScheduledNotification => "ScheduledNotification",
            MessageType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ConfigurationItemChangeNotification",
            "ConfigurationSnapshotDeliveryCompleted",
            "OversizedConfigurationItemChangeNotification",
            "ScheduledNotification",
        ]
    }
}
impl AsRef<str> for MessageType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `EventSource`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let eventsource = unimplemented!();
/// match eventsource {
///     EventSource::AwsConfig => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `eventsource` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EventSource::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EventSource::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EventSource::NewFeature` is defined.
/// Specifically, when `eventsource` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EventSource::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EventSource {
    #[allow(missing_docs)] // documentation missing in model
    AwsConfig,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EventSource {
    fn from(s: &str) -> Self {
        match s {
            "aws.config" => EventSource::AwsConfig,
            other => EventSource::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EventSource {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EventSource::from(s))
    }
}
impl EventSource {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EventSource::AwsConfig => "aws.config",
            EventSource::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["aws.config"]
    }
}
impl AsRef<str> for EventSource {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Owner`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let owner = unimplemented!();
/// match owner {
///     Owner::Aws => { /* ... */ },
///     Owner::CustomLambda => { /* ... */ },
///     Owner::CustomPolicy => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `owner` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Owner::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Owner::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Owner::NewFeature` is defined.
/// Specifically, when `owner` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Owner::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Owner {
    #[allow(missing_docs)] // documentation missing in model
    Aws,
    #[allow(missing_docs)] // documentation missing in model
    CustomLambda,
    #[allow(missing_docs)] // documentation missing in model
    CustomPolicy,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Owner {
    fn from(s: &str) -> Self {
        match s {
            "AWS" => Owner::Aws,
            "CUSTOM_LAMBDA" => Owner::CustomLambda,
            "CUSTOM_POLICY" => Owner::CustomPolicy,
            other => Owner::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Owner {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Owner::from(s))
    }
}
impl Owner {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Owner::Aws => "AWS",
            Owner::CustomLambda => "CUSTOM_LAMBDA",
            Owner::CustomPolicy => "CUSTOM_POLICY",
            Owner::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AWS", "CUSTOM_LAMBDA", "CUSTOM_POLICY"]
    }
}
impl AsRef<str> for Owner {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Defines which resources trigger an evaluation for an Config rule. The scope can include one or more resource types, a combination of a tag key and value, or a combination of one resource type and one resource ID. Specify a scope to constrain which resources trigger an evaluation for a rule. Otherwise, evaluations for the rule are triggered when any resource in your recording group changes in configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Scope {
    /// <p>The resource types of only those Amazon Web Services resources that you want to trigger an evaluation for the rule. You can only specify one type if you also specify a resource ID for <code>ComplianceResourceId</code>.</p>
    #[doc(hidden)]
    pub compliance_resource_types: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The tag key that is applied to only those Amazon Web Services resources that you want to trigger an evaluation for the rule.</p>
    #[doc(hidden)]
    pub tag_key: std::option::Option<std::string::String>,
    /// <p>The tag value applied to only those Amazon Web Services resources that you want to trigger an evaluation for the rule. If you specify a value for <code>TagValue</code>, you must also specify a value for <code>TagKey</code>.</p>
    #[doc(hidden)]
    pub tag_value: std::option::Option<std::string::String>,
    /// <p>The ID of the only Amazon Web Services resource that you want to trigger an evaluation for the rule. If you specify a resource ID, you must specify one resource type for <code>ComplianceResourceTypes</code>.</p>
    #[doc(hidden)]
    pub compliance_resource_id: std::option::Option<std::string::String>,
}
impl Scope {
    /// <p>The resource types of only those Amazon Web Services resources that you want to trigger an evaluation for the rule. You can only specify one type if you also specify a resource ID for <code>ComplianceResourceId</code>.</p>
    pub fn compliance_resource_types(&self) -> std::option::Option<&[std::string::String]> {
        self.compliance_resource_types.as_deref()
    }
    /// <p>The tag key that is applied to only those Amazon Web Services resources that you want to trigger an evaluation for the rule.</p>
    pub fn tag_key(&self) -> std::option::Option<&str> {
        self.tag_key.as_deref()
    }
    /// <p>The tag value applied to only those Amazon Web Services resources that you want to trigger an evaluation for the rule. If you specify a value for <code>TagValue</code>, you must also specify a value for <code>TagKey</code>.</p>
    pub fn tag_value(&self) -> std::option::Option<&str> {
        self.tag_value.as_deref()
    }
    /// <p>The ID of the only Amazon Web Services resource that you want to trigger an evaluation for the rule. If you specify a resource ID, you must specify one resource type for <code>ComplianceResourceTypes</code>.</p>
    pub fn compliance_resource_id(&self) -> std::option::Option<&str> {
        self.compliance_resource_id.as_deref()
    }
}
impl Scope {
    /// Creates a new builder-style object to manufacture [`Scope`](crate::model::Scope).
    pub fn builder() -> crate::model::scope::Builder {
        crate::model::scope::Builder::default()
    }
}

/// See [`Scope`](crate::model::Scope).
pub mod scope {

    /// A builder for [`Scope`](crate::model::Scope).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) compliance_resource_types:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tag_key: std::option::Option<std::string::String>,
        pub(crate) tag_value: std::option::Option<std::string::String>,
        pub(crate) compliance_resource_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `compliance_resource_types`.
        ///
        /// To override the contents of this collection use [`set_compliance_resource_types`](Self::set_compliance_resource_types).
        ///
        /// <p>The resource types of only those Amazon Web Services resources that you want to trigger an evaluation for the rule. You can only specify one type if you also specify a resource ID for <code>ComplianceResourceId</code>.</p>
        pub fn compliance_resource_types(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.compliance_resource_types.unwrap_or_default();
            v.push(input.into());
            self.compliance_resource_types = Some(v);
            self
        }
        /// <p>The resource types of only those Amazon Web Services resources that you want to trigger an evaluation for the rule. You can only specify one type if you also specify a resource ID for <code>ComplianceResourceId</code>.</p>
        pub fn set_compliance_resource_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.compliance_resource_types = input;
            self
        }
        /// <p>The tag key that is applied to only those Amazon Web Services resources that you want to trigger an evaluation for the rule.</p>
        pub fn tag_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.tag_key = Some(input.into());
            self
        }
        /// <p>The tag key that is applied to only those Amazon Web Services resources that you want to trigger an evaluation for the rule.</p>
        pub fn set_tag_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tag_key = input;
            self
        }
        /// <p>The tag value applied to only those Amazon Web Services resources that you want to trigger an evaluation for the rule. If you specify a value for <code>TagValue</code>, you must also specify a value for <code>TagKey</code>.</p>
        pub fn tag_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.tag_value = Some(input.into());
            self
        }
        /// <p>The tag value applied to only those Amazon Web Services resources that you want to trigger an evaluation for the rule. If you specify a value for <code>TagValue</code>, you must also specify a value for <code>TagKey</code>.</p>
        pub fn set_tag_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tag_value = input;
            self
        }
        /// <p>The ID of the only Amazon Web Services resource that you want to trigger an evaluation for the rule. If you specify a resource ID, you must specify one resource type for <code>ComplianceResourceTypes</code>.</p>
        pub fn compliance_resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.compliance_resource_id = Some(input.into());
            self
        }
        /// <p>The ID of the only Amazon Web Services resource that you want to trigger an evaluation for the rule. If you specify a resource ID, you must specify one resource type for <code>ComplianceResourceTypes</code>.</p>
        pub fn set_compliance_resource_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.compliance_resource_id = input;
            self
        }
        /// Consumes the builder and constructs a [`Scope`](crate::model::Scope).
        pub fn build(self) -> crate::model::Scope {
            crate::model::Scope {
                compliance_resource_types: self.compliance_resource_types,
                tag_key: self.tag_key,
                tag_value: self.tag_value,
                compliance_resource_id: self.compliance_resource_id,
            }
        }
    }
}

/// <p>An object that represents the authorizations granted to aggregator accounts and regions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AggregationAuthorization {
    /// <p>The Amazon Resource Name (ARN) of the aggregation object.</p>
    #[doc(hidden)]
    pub aggregation_authorization_arn: std::option::Option<std::string::String>,
    /// <p>The 12-digit account ID of the account authorized to aggregate data.</p>
    #[doc(hidden)]
    pub authorized_account_id: std::option::Option<std::string::String>,
    /// <p>The region authorized to collect aggregated data.</p>
    #[doc(hidden)]
    pub authorized_aws_region: std::option::Option<std::string::String>,
    /// <p>The time stamp when the aggregation authorization was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl AggregationAuthorization {
    /// <p>The Amazon Resource Name (ARN) of the aggregation object.</p>
    pub fn aggregation_authorization_arn(&self) -> std::option::Option<&str> {
        self.aggregation_authorization_arn.as_deref()
    }
    /// <p>The 12-digit account ID of the account authorized to aggregate data.</p>
    pub fn authorized_account_id(&self) -> std::option::Option<&str> {
        self.authorized_account_id.as_deref()
    }
    /// <p>The region authorized to collect aggregated data.</p>
    pub fn authorized_aws_region(&self) -> std::option::Option<&str> {
        self.authorized_aws_region.as_deref()
    }
    /// <p>The time stamp when the aggregation authorization was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
}
impl AggregationAuthorization {
    /// Creates a new builder-style object to manufacture [`AggregationAuthorization`](crate::model::AggregationAuthorization).
    pub fn builder() -> crate::model::aggregation_authorization::Builder {
        crate::model::aggregation_authorization::Builder::default()
    }
}

/// See [`AggregationAuthorization`](crate::model::AggregationAuthorization).
pub mod aggregation_authorization {

    /// A builder for [`AggregationAuthorization`](crate::model::AggregationAuthorization).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) aggregation_authorization_arn: std::option::Option<std::string::String>,
        pub(crate) authorized_account_id: std::option::Option<std::string::String>,
        pub(crate) authorized_aws_region: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the aggregation object.</p>
        pub fn aggregation_authorization_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.aggregation_authorization_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the aggregation object.</p>
        pub fn set_aggregation_authorization_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.aggregation_authorization_arn = input;
            self
        }
        /// <p>The 12-digit account ID of the account authorized to aggregate data.</p>
        pub fn authorized_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.authorized_account_id = Some(input.into());
            self
        }
        /// <p>The 12-digit account ID of the account authorized to aggregate data.</p>
        pub fn set_authorized_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.authorized_account_id = input;
            self
        }
        /// <p>The region authorized to collect aggregated data.</p>
        pub fn authorized_aws_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.authorized_aws_region = Some(input.into());
            self
        }
        /// <p>The region authorized to collect aggregated data.</p>
        pub fn set_authorized_aws_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.authorized_aws_region = input;
            self
        }
        /// <p>The time stamp when the aggregation authorization was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time stamp when the aggregation authorization was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`AggregationAuthorization`](crate::model::AggregationAuthorization).
        pub fn build(self) -> crate::model::AggregationAuthorization {
            crate::model::AggregationAuthorization {
                aggregation_authorization_arn: self.aggregation_authorization_arn,
                authorized_account_id: self.authorized_account_id,
                authorized_aws_region: self.authorized_aws_region,
                creation_time: self.creation_time,
            }
        }
    }
}

/// <p>Returns details of a specific query. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StoredQueryMetadata {
    /// <p>The ID of the query. </p>
    #[doc(hidden)]
    pub query_id: std::option::Option<std::string::String>,
    /// <p>Amazon Resource Name (ARN) of the query. For example, arn:partition:service:region:account-id:resource-type/resource-name/resource-id.</p>
    #[doc(hidden)]
    pub query_arn: std::option::Option<std::string::String>,
    /// <p>The name of the query.</p>
    #[doc(hidden)]
    pub query_name: std::option::Option<std::string::String>,
    /// <p>A unique description for the query.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl StoredQueryMetadata {
    /// <p>The ID of the query. </p>
    pub fn query_id(&self) -> std::option::Option<&str> {
        self.query_id.as_deref()
    }
    /// <p>Amazon Resource Name (ARN) of the query. For example, arn:partition:service:region:account-id:resource-type/resource-name/resource-id.</p>
    pub fn query_arn(&self) -> std::option::Option<&str> {
        self.query_arn.as_deref()
    }
    /// <p>The name of the query.</p>
    pub fn query_name(&self) -> std::option::Option<&str> {
        self.query_name.as_deref()
    }
    /// <p>A unique description for the query.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
impl StoredQueryMetadata {
    /// Creates a new builder-style object to manufacture [`StoredQueryMetadata`](crate::model::StoredQueryMetadata).
    pub fn builder() -> crate::model::stored_query_metadata::Builder {
        crate::model::stored_query_metadata::Builder::default()
    }
}

/// See [`StoredQueryMetadata`](crate::model::StoredQueryMetadata).
pub mod stored_query_metadata {

    /// A builder for [`StoredQueryMetadata`](crate::model::StoredQueryMetadata).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) query_id: std::option::Option<std::string::String>,
        pub(crate) query_arn: std::option::Option<std::string::String>,
        pub(crate) query_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the query. </p>
        pub fn query_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_id = Some(input.into());
            self
        }
        /// <p>The ID of the query. </p>
        pub fn set_query_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_id = input;
            self
        }
        /// <p>Amazon Resource Name (ARN) of the query. For example, arn:partition:service:region:account-id:resource-type/resource-name/resource-id.</p>
        pub fn query_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_arn = Some(input.into());
            self
        }
        /// <p>Amazon Resource Name (ARN) of the query. For example, arn:partition:service:region:account-id:resource-type/resource-name/resource-id.</p>
        pub fn set_query_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_arn = input;
            self
        }
        /// <p>The name of the query.</p>
        pub fn query_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_name = Some(input.into());
            self
        }
        /// <p>The name of the query.</p>
        pub fn set_query_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_name = input;
            self
        }
        /// <p>A unique description for the query.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A unique description for the query.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`StoredQueryMetadata`](crate::model::StoredQueryMetadata).
        pub fn build(self) -> crate::model::StoredQueryMetadata {
            crate::model::StoredQueryMetadata {
                query_id: self.query_id,
                query_arn: self.query_arn,
                query_name: self.query_name,
                description: self.description,
            }
        }
    }
}

/// <p>Returns details of a resource evaluation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceEvaluation {
    /// <p>The ResourceEvaluationId of a evaluation.</p>
    #[doc(hidden)]
    pub resource_evaluation_id: std::option::Option<std::string::String>,
    /// <p>The mode of an evaluation. The valid values are Detective or Proactive.</p>
    #[doc(hidden)]
    pub evaluation_mode: std::option::Option<crate::model::EvaluationMode>,
    /// <p>The starting time of an execution.</p>
    #[doc(hidden)]
    pub evaluation_start_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl ResourceEvaluation {
    /// <p>The ResourceEvaluationId of a evaluation.</p>
    pub fn resource_evaluation_id(&self) -> std::option::Option<&str> {
        self.resource_evaluation_id.as_deref()
    }
    /// <p>The mode of an evaluation. The valid values are Detective or Proactive.</p>
    pub fn evaluation_mode(&self) -> std::option::Option<&crate::model::EvaluationMode> {
        self.evaluation_mode.as_ref()
    }
    /// <p>The starting time of an execution.</p>
    pub fn evaluation_start_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.evaluation_start_timestamp.as_ref()
    }
}
impl ResourceEvaluation {
    /// Creates a new builder-style object to manufacture [`ResourceEvaluation`](crate::model::ResourceEvaluation).
    pub fn builder() -> crate::model::resource_evaluation::Builder {
        crate::model::resource_evaluation::Builder::default()
    }
}

/// See [`ResourceEvaluation`](crate::model::ResourceEvaluation).
pub mod resource_evaluation {

    /// A builder for [`ResourceEvaluation`](crate::model::ResourceEvaluation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_evaluation_id: std::option::Option<std::string::String>,
        pub(crate) evaluation_mode: std::option::Option<crate::model::EvaluationMode>,
        pub(crate) evaluation_start_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The ResourceEvaluationId of a evaluation.</p>
        pub fn resource_evaluation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_evaluation_id = Some(input.into());
            self
        }
        /// <p>The ResourceEvaluationId of a evaluation.</p>
        pub fn set_resource_evaluation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_evaluation_id = input;
            self
        }
        /// <p>The mode of an evaluation. The valid values are Detective or Proactive.</p>
        pub fn evaluation_mode(mut self, input: crate::model::EvaluationMode) -> Self {
            self.evaluation_mode = Some(input);
            self
        }
        /// <p>The mode of an evaluation. The valid values are Detective or Proactive.</p>
        pub fn set_evaluation_mode(
            mut self,
            input: std::option::Option<crate::model::EvaluationMode>,
        ) -> Self {
            self.evaluation_mode = input;
            self
        }
        /// <p>The starting time of an execution.</p>
        pub fn evaluation_start_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.evaluation_start_timestamp = Some(input);
            self
        }
        /// <p>The starting time of an execution.</p>
        pub fn set_evaluation_start_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.evaluation_start_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceEvaluation`](crate::model::ResourceEvaluation).
        pub fn build(self) -> crate::model::ResourceEvaluation {
            crate::model::ResourceEvaluation {
                resource_evaluation_id: self.resource_evaluation_id,
                evaluation_mode: self.evaluation_mode,
                evaluation_start_timestamp: self.evaluation_start_timestamp,
            }
        }
    }
}

/// <p>Returns details of a resource evaluation based on the selected filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceEvaluationFilters {
    /// <p>Filters all resource evaluations results based on an evaluation mode. the valid value for this API is <code>Proactive</code>.</p>
    #[doc(hidden)]
    pub evaluation_mode: std::option::Option<crate::model::EvaluationMode>,
    /// <p>Returns a <code>TimeWindow</code> object.</p>
    #[doc(hidden)]
    pub time_window: std::option::Option<crate::model::TimeWindow>,
    /// <p>Filters evaluations for a given infrastructure deployment. For example: CFN Stack.</p>
    #[doc(hidden)]
    pub evaluation_context_identifier: std::option::Option<std::string::String>,
}
impl ResourceEvaluationFilters {
    /// <p>Filters all resource evaluations results based on an evaluation mode. the valid value for this API is <code>Proactive</code>.</p>
    pub fn evaluation_mode(&self) -> std::option::Option<&crate::model::EvaluationMode> {
        self.evaluation_mode.as_ref()
    }
    /// <p>Returns a <code>TimeWindow</code> object.</p>
    pub fn time_window(&self) -> std::option::Option<&crate::model::TimeWindow> {
        self.time_window.as_ref()
    }
    /// <p>Filters evaluations for a given infrastructure deployment. For example: CFN Stack.</p>
    pub fn evaluation_context_identifier(&self) -> std::option::Option<&str> {
        self.evaluation_context_identifier.as_deref()
    }
}
impl ResourceEvaluationFilters {
    /// Creates a new builder-style object to manufacture [`ResourceEvaluationFilters`](crate::model::ResourceEvaluationFilters).
    pub fn builder() -> crate::model::resource_evaluation_filters::Builder {
        crate::model::resource_evaluation_filters::Builder::default()
    }
}

/// See [`ResourceEvaluationFilters`](crate::model::ResourceEvaluationFilters).
pub mod resource_evaluation_filters {

    /// A builder for [`ResourceEvaluationFilters`](crate::model::ResourceEvaluationFilters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) evaluation_mode: std::option::Option<crate::model::EvaluationMode>,
        pub(crate) time_window: std::option::Option<crate::model::TimeWindow>,
        pub(crate) evaluation_context_identifier: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Filters all resource evaluations results based on an evaluation mode. the valid value for this API is <code>Proactive</code>.</p>
        pub fn evaluation_mode(mut self, input: crate::model::EvaluationMode) -> Self {
            self.evaluation_mode = Some(input);
            self
        }
        /// <p>Filters all resource evaluations results based on an evaluation mode. the valid value for this API is <code>Proactive</code>.</p>
        pub fn set_evaluation_mode(
            mut self,
            input: std::option::Option<crate::model::EvaluationMode>,
        ) -> Self {
            self.evaluation_mode = input;
            self
        }
        /// <p>Returns a <code>TimeWindow</code> object.</p>
        pub fn time_window(mut self, input: crate::model::TimeWindow) -> Self {
            self.time_window = Some(input);
            self
        }
        /// <p>Returns a <code>TimeWindow</code> object.</p>
        pub fn set_time_window(
            mut self,
            input: std::option::Option<crate::model::TimeWindow>,
        ) -> Self {
            self.time_window = input;
            self
        }
        /// <p>Filters evaluations for a given infrastructure deployment. For example: CFN Stack.</p>
        pub fn evaluation_context_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.evaluation_context_identifier = Some(input.into());
            self
        }
        /// <p>Filters evaluations for a given infrastructure deployment. For example: CFN Stack.</p>
        pub fn set_evaluation_context_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.evaluation_context_identifier = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceEvaluationFilters`](crate::model::ResourceEvaluationFilters).
        pub fn build(self) -> crate::model::ResourceEvaluationFilters {
            crate::model::ResourceEvaluationFilters {
                evaluation_mode: self.evaluation_mode,
                time_window: self.time_window,
                evaluation_context_identifier: self.evaluation_context_identifier,
            }
        }
    }
}

/// <p>Filters evaluation results based on start and end times.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TimeWindow {
    /// <p>The start time of an execution.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The end time of an execution. The end time must be after the start date.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl TimeWindow {
    /// <p>The start time of an execution.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The end time of an execution. The end time must be after the start date.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
}
impl TimeWindow {
    /// Creates a new builder-style object to manufacture [`TimeWindow`](crate::model::TimeWindow).
    pub fn builder() -> crate::model::time_window::Builder {
        crate::model::time_window::Builder::default()
    }
}

/// See [`TimeWindow`](crate::model::TimeWindow).
pub mod time_window {

    /// A builder for [`TimeWindow`](crate::model::TimeWindow).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The start time of an execution.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The start time of an execution.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end time of an execution. The end time must be after the start date.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end time of an execution. The end time must be after the start date.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// Consumes the builder and constructs a [`TimeWindow`](crate::model::TimeWindow).
        pub fn build(self) -> crate::model::TimeWindow {
            crate::model::TimeWindow {
                start_time: self.start_time,
                end_time: self.end_time,
            }
        }
    }
}

/// <p>The details that identify a resource that is discovered by Config, including the resource type, ID, and (if available) the custom resource name.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceIdentifier {
    /// <p>The type of resource.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>The ID of the resource (for example, <code>sg-xxxxxx</code>).</p>
    #[doc(hidden)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The custom name of the resource (if available).</p>
    #[doc(hidden)]
    pub resource_name: std::option::Option<std::string::String>,
    /// <p>The time that the resource was deleted.</p>
    #[doc(hidden)]
    pub resource_deletion_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ResourceIdentifier {
    /// <p>The type of resource.</p>
    pub fn resource_type(&self) -> std::option::Option<&crate::model::ResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>The ID of the resource (for example, <code>sg-xxxxxx</code>).</p>
    pub fn resource_id(&self) -> std::option::Option<&str> {
        self.resource_id.as_deref()
    }
    /// <p>The custom name of the resource (if available).</p>
    pub fn resource_name(&self) -> std::option::Option<&str> {
        self.resource_name.as_deref()
    }
    /// <p>The time that the resource was deleted.</p>
    pub fn resource_deletion_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.resource_deletion_time.as_ref()
    }
}
impl ResourceIdentifier {
    /// Creates a new builder-style object to manufacture [`ResourceIdentifier`](crate::model::ResourceIdentifier).
    pub fn builder() -> crate::model::resource_identifier::Builder {
        crate::model::resource_identifier::Builder::default()
    }
}

/// See [`ResourceIdentifier`](crate::model::ResourceIdentifier).
pub mod resource_identifier {

    /// A builder for [`ResourceIdentifier`](crate::model::ResourceIdentifier).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_name: std::option::Option<std::string::String>,
        pub(crate) resource_deletion_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The type of resource.</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>The type of resource.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The ID of the resource (for example, <code>sg-xxxxxx</code>).</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The ID of the resource (for example, <code>sg-xxxxxx</code>).</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The custom name of the resource (if available).</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_name = Some(input.into());
            self
        }
        /// <p>The custom name of the resource (if available).</p>
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_name = input;
            self
        }
        /// <p>The time that the resource was deleted.</p>
        pub fn resource_deletion_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.resource_deletion_time = Some(input);
            self
        }
        /// <p>The time that the resource was deleted.</p>
        pub fn set_resource_deletion_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.resource_deletion_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceIdentifier`](crate::model::ResourceIdentifier).
        pub fn build(self) -> crate::model::ResourceIdentifier {
            crate::model::ResourceIdentifier {
                resource_type: self.resource_type,
                resource_id: self.resource_id,
                resource_name: self.resource_name,
                resource_deletion_time: self.resource_deletion_time,
            }
        }
    }
}

/// <p>A compliance score is the percentage of the number of compliant rule-resource combinations in a conformance pack compared to the number of total possible rule-resource combinations in the conformance pack. This metric provides you with a high-level view of the compliance state of your conformance packs. You can use it to identify, investigate, and understand the level of compliance in your conformance packs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConformancePackComplianceScore {
    /// <p>Compliance score for the conformance pack. Conformance packs with no evaluation results will have a compliance score of <code>INSUFFICIENT_DATA</code>.</p>
    #[doc(hidden)]
    pub score: std::option::Option<std::string::String>,
    /// <p>The name of the conformance pack.</p>
    #[doc(hidden)]
    pub conformance_pack_name: std::option::Option<std::string::String>,
    /// <p>The time that the conformance pack compliance score was last updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ConformancePackComplianceScore {
    /// <p>Compliance score for the conformance pack. Conformance packs with no evaluation results will have a compliance score of <code>INSUFFICIENT_DATA</code>.</p>
    pub fn score(&self) -> std::option::Option<&str> {
        self.score.as_deref()
    }
    /// <p>The name of the conformance pack.</p>
    pub fn conformance_pack_name(&self) -> std::option::Option<&str> {
        self.conformance_pack_name.as_deref()
    }
    /// <p>The time that the conformance pack compliance score was last updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_time.as_ref()
    }
}
impl ConformancePackComplianceScore {
    /// Creates a new builder-style object to manufacture [`ConformancePackComplianceScore`](crate::model::ConformancePackComplianceScore).
    pub fn builder() -> crate::model::conformance_pack_compliance_score::Builder {
        crate::model::conformance_pack_compliance_score::Builder::default()
    }
}

/// See [`ConformancePackComplianceScore`](crate::model::ConformancePackComplianceScore).
pub mod conformance_pack_compliance_score {

    /// A builder for [`ConformancePackComplianceScore`](crate::model::ConformancePackComplianceScore).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) score: std::option::Option<std::string::String>,
        pub(crate) conformance_pack_name: std::option::Option<std::string::String>,
        pub(crate) last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Compliance score for the conformance pack. Conformance packs with no evaluation results will have a compliance score of <code>INSUFFICIENT_DATA</code>.</p>
        pub fn score(mut self, input: impl Into<std::string::String>) -> Self {
            self.score = Some(input.into());
            self
        }
        /// <p>Compliance score for the conformance pack. Conformance packs with no evaluation results will have a compliance score of <code>INSUFFICIENT_DATA</code>.</p>
        pub fn set_score(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.score = input;
            self
        }
        /// <p>The name of the conformance pack.</p>
        pub fn conformance_pack_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.conformance_pack_name = Some(input.into());
            self
        }
        /// <p>The name of the conformance pack.</p>
        pub fn set_conformance_pack_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.conformance_pack_name = input;
            self
        }
        /// <p>The time that the conformance pack compliance score was last updated.</p>
        pub fn last_updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_time = Some(input);
            self
        }
        /// <p>The time that the conformance pack compliance score was last updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ConformancePackComplianceScore`](crate::model::ConformancePackComplianceScore).
        pub fn build(self) -> crate::model::ConformancePackComplianceScore {
            crate::model::ConformancePackComplianceScore {
                score: self.score,
                conformance_pack_name: self.conformance_pack_name,
                last_updated_time: self.last_updated_time,
            }
        }
    }
}

/// When writing a match expression against `SortBy`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sortby = unimplemented!();
/// match sortby {
///     SortBy::Score => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sortby` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SortBy::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SortBy::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SortBy::NewFeature` is defined.
/// Specifically, when `sortby` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SortBy::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortBy {
    #[allow(missing_docs)] // documentation missing in model
    Score,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SortBy {
    fn from(s: &str) -> Self {
        match s {
            "SCORE" => SortBy::Score,
            other => SortBy::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortBy::from(s))
    }
}
impl SortBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SortBy::Score => "SCORE",
            SortBy::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SCORE"]
    }
}
impl AsRef<str> for SortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SortOrder`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sortorder = unimplemented!();
/// match sortorder {
///     SortOrder::Ascending => { /* ... */ },
///     SortOrder::Descending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sortorder` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SortOrder::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SortOrder::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SortOrder::NewFeature` is defined.
/// Specifically, when `sortorder` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SortOrder::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortOrder {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SortOrder {
    fn from(s: &str) -> Self {
        match s {
            "ASCENDING" => SortOrder::Ascending,
            "DESCENDING" => SortOrder::Descending,
            other => SortOrder::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortOrder::from(s))
    }
}
impl SortOrder {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SortOrder::Ascending => "ASCENDING",
            SortOrder::Descending => "DESCENDING",
            SortOrder::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ASCENDING", "DESCENDING"]
    }
}
impl AsRef<str> for SortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A list of filters to apply to the conformance pack compliance score result set. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConformancePackComplianceScoresFilters {
    /// <p>The names of the conformance packs whose compliance scores you want to include in the conformance pack compliance score result set. You can include up to 25 conformance packs in the <code>ConformancePackNames</code> array of strings, each with a character limit of 256 characters for the conformance pack name.</p>
    #[doc(hidden)]
    pub conformance_pack_names: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ConformancePackComplianceScoresFilters {
    /// <p>The names of the conformance packs whose compliance scores you want to include in the conformance pack compliance score result set. You can include up to 25 conformance packs in the <code>ConformancePackNames</code> array of strings, each with a character limit of 256 characters for the conformance pack name.</p>
    pub fn conformance_pack_names(&self) -> std::option::Option<&[std::string::String]> {
        self.conformance_pack_names.as_deref()
    }
}
impl ConformancePackComplianceScoresFilters {
    /// Creates a new builder-style object to manufacture [`ConformancePackComplianceScoresFilters`](crate::model::ConformancePackComplianceScoresFilters).
    pub fn builder() -> crate::model::conformance_pack_compliance_scores_filters::Builder {
        crate::model::conformance_pack_compliance_scores_filters::Builder::default()
    }
}

/// See [`ConformancePackComplianceScoresFilters`](crate::model::ConformancePackComplianceScoresFilters).
pub mod conformance_pack_compliance_scores_filters {

    /// A builder for [`ConformancePackComplianceScoresFilters`](crate::model::ConformancePackComplianceScoresFilters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) conformance_pack_names: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `conformance_pack_names`.
        ///
        /// To override the contents of this collection use [`set_conformance_pack_names`](Self::set_conformance_pack_names).
        ///
        /// <p>The names of the conformance packs whose compliance scores you want to include in the conformance pack compliance score result set. You can include up to 25 conformance packs in the <code>ConformancePackNames</code> array of strings, each with a character limit of 256 characters for the conformance pack name.</p>
        pub fn conformance_pack_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.conformance_pack_names.unwrap_or_default();
            v.push(input.into());
            self.conformance_pack_names = Some(v);
            self
        }
        /// <p>The names of the conformance packs whose compliance scores you want to include in the conformance pack compliance score result set. You can include up to 25 conformance packs in the <code>ConformancePackNames</code> array of strings, each with a character limit of 256 characters for the conformance pack name.</p>
        pub fn set_conformance_pack_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.conformance_pack_names = input;
            self
        }
        /// Consumes the builder and constructs a [`ConformancePackComplianceScoresFilters`](crate::model::ConformancePackComplianceScoresFilters).
        pub fn build(self) -> crate::model::ConformancePackComplianceScoresFilters {
            crate::model::ConformancePackComplianceScoresFilters {
                conformance_pack_names: self.conformance_pack_names,
            }
        }
    }
}

/// <p>The details that identify a resource that is collected by Config aggregator, including the resource type, ID, (if available) the custom resource name, the source account, and source region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AggregateResourceIdentifier {
    /// <p>The 12-digit account ID of the source account.</p>
    #[doc(hidden)]
    pub source_account_id: std::option::Option<std::string::String>,
    /// <p>The source region where data is aggregated.</p>
    #[doc(hidden)]
    pub source_region: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services resource.</p>
    #[doc(hidden)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The type of the Amazon Web Services resource.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>The name of the Amazon Web Services resource.</p>
    #[doc(hidden)]
    pub resource_name: std::option::Option<std::string::String>,
}
impl AggregateResourceIdentifier {
    /// <p>The 12-digit account ID of the source account.</p>
    pub fn source_account_id(&self) -> std::option::Option<&str> {
        self.source_account_id.as_deref()
    }
    /// <p>The source region where data is aggregated.</p>
    pub fn source_region(&self) -> std::option::Option<&str> {
        self.source_region.as_deref()
    }
    /// <p>The ID of the Amazon Web Services resource.</p>
    pub fn resource_id(&self) -> std::option::Option<&str> {
        self.resource_id.as_deref()
    }
    /// <p>The type of the Amazon Web Services resource.</p>
    pub fn resource_type(&self) -> std::option::Option<&crate::model::ResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>The name of the Amazon Web Services resource.</p>
    pub fn resource_name(&self) -> std::option::Option<&str> {
        self.resource_name.as_deref()
    }
}
impl AggregateResourceIdentifier {
    /// Creates a new builder-style object to manufacture [`AggregateResourceIdentifier`](crate::model::AggregateResourceIdentifier).
    pub fn builder() -> crate::model::aggregate_resource_identifier::Builder {
        crate::model::aggregate_resource_identifier::Builder::default()
    }
}

/// See [`AggregateResourceIdentifier`](crate::model::AggregateResourceIdentifier).
pub mod aggregate_resource_identifier {

    /// A builder for [`AggregateResourceIdentifier`](crate::model::AggregateResourceIdentifier).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_account_id: std::option::Option<std::string::String>,
        pub(crate) source_region: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) resource_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The 12-digit account ID of the source account.</p>
        pub fn source_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_account_id = Some(input.into());
            self
        }
        /// <p>The 12-digit account ID of the source account.</p>
        pub fn set_source_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_account_id = input;
            self
        }
        /// <p>The source region where data is aggregated.</p>
        pub fn source_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_region = Some(input.into());
            self
        }
        /// <p>The source region where data is aggregated.</p>
        pub fn set_source_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_region = input;
            self
        }
        /// <p>The ID of the Amazon Web Services resource.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The ID of the Amazon Web Services resource.</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The type of the Amazon Web Services resource.</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>The type of the Amazon Web Services resource.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The name of the Amazon Web Services resource.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_name = Some(input.into());
            self
        }
        /// <p>The name of the Amazon Web Services resource.</p>
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AggregateResourceIdentifier`](crate::model::AggregateResourceIdentifier).
        pub fn build(self) -> crate::model::AggregateResourceIdentifier {
            crate::model::AggregateResourceIdentifier {
                source_account_id: self.source_account_id,
                source_region: self.source_region,
                resource_id: self.resource_id,
                resource_type: self.resource_type,
                resource_name: self.resource_name,
            }
        }
    }
}

/// <p>Filters the results by resource account ID, region, resource ID, and resource name.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceFilters {
    /// <p>The 12-digit source account ID.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The ID of the resource.</p>
    #[doc(hidden)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The name of the resource.</p>
    #[doc(hidden)]
    pub resource_name: std::option::Option<std::string::String>,
    /// <p>The source region.</p>
    #[doc(hidden)]
    pub region: std::option::Option<std::string::String>,
}
impl ResourceFilters {
    /// <p>The 12-digit source account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The ID of the resource.</p>
    pub fn resource_id(&self) -> std::option::Option<&str> {
        self.resource_id.as_deref()
    }
    /// <p>The name of the resource.</p>
    pub fn resource_name(&self) -> std::option::Option<&str> {
        self.resource_name.as_deref()
    }
    /// <p>The source region.</p>
    pub fn region(&self) -> std::option::Option<&str> {
        self.region.as_deref()
    }
}
impl ResourceFilters {
    /// Creates a new builder-style object to manufacture [`ResourceFilters`](crate::model::ResourceFilters).
    pub fn builder() -> crate::model::resource_filters::Builder {
        crate::model::resource_filters::Builder::default()
    }
}

/// See [`ResourceFilters`](crate::model::ResourceFilters).
pub mod resource_filters {

    /// A builder for [`ResourceFilters`](crate::model::ResourceFilters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_name: std::option::Option<std::string::String>,
        pub(crate) region: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The 12-digit source account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The 12-digit source account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The ID of the resource.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The ID of the resource.</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The name of the resource.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_name = Some(input.into());
            self
        }
        /// <p>The name of the resource.</p>
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_name = input;
            self
        }
        /// <p>The source region.</p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        /// <p>The source region.</p>
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceFilters`](crate::model::ResourceFilters).
        pub fn build(self) -> crate::model::ResourceFilters {
            crate::model::ResourceFilters {
                account_id: self.account_id,
                resource_id: self.resource_id,
                resource_name: self.resource_name,
                region: self.region,
            }
        }
    }
}

/// <p>Returns status details of an evaluation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EvaluationStatus {
    /// <p>The status of an execution. The valid values are In_Progress, Succeeded or Failed. </p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ResourceEvaluationStatus>,
    /// <p>An explanation for failed execution status.</p>
    #[doc(hidden)]
    pub failure_reason: std::option::Option<std::string::String>,
}
impl EvaluationStatus {
    /// <p>The status of an execution. The valid values are In_Progress, Succeeded or Failed. </p>
    pub fn status(&self) -> std::option::Option<&crate::model::ResourceEvaluationStatus> {
        self.status.as_ref()
    }
    /// <p>An explanation for failed execution status.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
}
impl EvaluationStatus {
    /// Creates a new builder-style object to manufacture [`EvaluationStatus`](crate::model::EvaluationStatus).
    pub fn builder() -> crate::model::evaluation_status::Builder {
        crate::model::evaluation_status::Builder::default()
    }
}

/// See [`EvaluationStatus`](crate::model::EvaluationStatus).
pub mod evaluation_status {

    /// A builder for [`EvaluationStatus`](crate::model::EvaluationStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::ResourceEvaluationStatus>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The status of an execution. The valid values are In_Progress, Succeeded or Failed. </p>
        pub fn status(mut self, input: crate::model::ResourceEvaluationStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of an execution. The valid values are In_Progress, Succeeded or Failed. </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ResourceEvaluationStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>An explanation for failed execution status.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>An explanation for failed execution status.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`EvaluationStatus`](crate::model::EvaluationStatus).
        pub fn build(self) -> crate::model::EvaluationStatus {
            crate::model::EvaluationStatus {
                status: self.status,
                failure_reason: self.failure_reason,
            }
        }
    }
}

/// When writing a match expression against `ResourceEvaluationStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourceevaluationstatus = unimplemented!();
/// match resourceevaluationstatus {
///     ResourceEvaluationStatus::Failed => { /* ... */ },
///     ResourceEvaluationStatus::InProgress => { /* ... */ },
///     ResourceEvaluationStatus::Succeeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourceevaluationstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceEvaluationStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceEvaluationStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceEvaluationStatus::NewFeature` is defined.
/// Specifically, when `resourceevaluationstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceEvaluationStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceEvaluationStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceEvaluationStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => ResourceEvaluationStatus::Failed,
            "IN_PROGRESS" => ResourceEvaluationStatus::InProgress,
            "SUCCEEDED" => ResourceEvaluationStatus::Succeeded,
            other => ResourceEvaluationStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ResourceEvaluationStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceEvaluationStatus::from(s))
    }
}
impl ResourceEvaluationStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceEvaluationStatus::Failed => "FAILED",
            ResourceEvaluationStatus::InProgress => "IN_PROGRESS",
            ResourceEvaluationStatus::Succeeded => "SUCCEEDED",
            ResourceEvaluationStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FAILED", "IN_PROGRESS", "SUCCEEDED"]
    }
}
impl AsRef<str> for ResourceEvaluationStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A list that contains detailed configurations of a specified resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfigurationItem {
    /// <p>The version number of the resource configuration.</p>
    #[doc(hidden)]
    pub version: std::option::Option<std::string::String>,
    /// <p>The 12-digit Amazon Web Services account ID associated with the resource.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The time when the configuration recording was initiated.</p>
    #[doc(hidden)]
    pub configuration_item_capture_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The configuration item status. The valid values are:</p>
    /// <ul>
    /// <li> <p>OK – The resource configuration has been updated</p> </li>
    /// <li> <p>ResourceDiscovered – The resource was newly discovered</p> </li>
    /// <li> <p>ResourceNotRecorded – The resource was discovered but its configuration was not recorded since the recorder excludes the recording of resources of this type</p> </li>
    /// <li> <p>ResourceDeleted – The resource was deleted</p> </li>
    /// <li> <p>ResourceDeletedNotRecorded – The resource was deleted but its configuration was not recorded since the recorder excludes the recording of resources of this type</p> </li>
    /// </ul> <note>
    /// <p>The CIs do not incur any cost.</p>
    /// </note>
    #[doc(hidden)]
    pub configuration_item_status: std::option::Option<crate::model::ConfigurationItemStatus>,
    /// <p>An identifier that indicates the ordering of the configuration items of a resource.</p>
    #[doc(hidden)]
    pub configuration_state_id: std::option::Option<std::string::String>,
    /// <p>Unique MD5 hash that represents the configuration item's state.</p>
    /// <p>You can use MD5 hash to compare the states of two or more configuration items that are associated with the same resource.</p>
    #[doc(hidden)]
    pub configuration_item_md5_hash: std::option::Option<std::string::String>,
    /// <p>Amazon Resource Name (ARN) associated with the resource.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The type of Amazon Web Services resource.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>The ID of the resource (for example, <code>sg-xxxxxx</code>).</p>
    #[doc(hidden)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The custom name of the resource, if available.</p>
    #[doc(hidden)]
    pub resource_name: std::option::Option<std::string::String>,
    /// <p>The region where the resource resides.</p>
    #[doc(hidden)]
    pub aws_region: std::option::Option<std::string::String>,
    /// <p>The Availability Zone associated with the resource.</p>
    #[doc(hidden)]
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The time stamp when the resource was created.</p>
    #[doc(hidden)]
    pub resource_creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A mapping of key value tags associated with the resource.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A list of CloudTrail event IDs.</p>
    /// <p>A populated field indicates that the current configuration was initiated by the events recorded in the CloudTrail log. For more information about CloudTrail, see <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/what_is_cloud_trail_top_level.html">What Is CloudTrail</a>.</p>
    /// <p>An empty field indicates that the current configuration was not initiated by any event. As of Version 1.3, the relatedEvents field is empty. You can access the <a href="https://docs.aws.amazon.com/awscloudtrail/latest/APIReference/API_LookupEvents.html">LookupEvents API</a> in the <i>CloudTrail API Reference</i> to retrieve the events for the resource.</p>
    #[doc(hidden)]
    pub related_events: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of related Amazon Web Services resources.</p>
    #[doc(hidden)]
    pub relationships: std::option::Option<std::vec::Vec<crate::model::Relationship>>,
    /// <p>The description of the resource configuration.</p>
    #[doc(hidden)]
    pub configuration: std::option::Option<std::string::String>,
    /// <p>Configuration attributes that Config returns for certain resource types to supplement the information returned for the <code>configuration</code> parameter.</p>
    #[doc(hidden)]
    pub supplementary_configuration:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl ConfigurationItem {
    /// <p>The version number of the resource configuration.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
    /// <p>The 12-digit Amazon Web Services account ID associated with the resource.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The time when the configuration recording was initiated.</p>
    pub fn configuration_item_capture_time(
        &self,
    ) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.configuration_item_capture_time.as_ref()
    }
    /// <p>The configuration item status. The valid values are:</p>
    /// <ul>
    /// <li> <p>OK – The resource configuration has been updated</p> </li>
    /// <li> <p>ResourceDiscovered – The resource was newly discovered</p> </li>
    /// <li> <p>ResourceNotRecorded – The resource was discovered but its configuration was not recorded since the recorder excludes the recording of resources of this type</p> </li>
    /// <li> <p>ResourceDeleted – The resource was deleted</p> </li>
    /// <li> <p>ResourceDeletedNotRecorded – The resource was deleted but its configuration was not recorded since the recorder excludes the recording of resources of this type</p> </li>
    /// </ul> <note>
    /// <p>The CIs do not incur any cost.</p>
    /// </note>
    pub fn configuration_item_status(
        &self,
    ) -> std::option::Option<&crate::model::ConfigurationItemStatus> {
        self.configuration_item_status.as_ref()
    }
    /// <p>An identifier that indicates the ordering of the configuration items of a resource.</p>
    pub fn configuration_state_id(&self) -> std::option::Option<&str> {
        self.configuration_state_id.as_deref()
    }
    /// <p>Unique MD5 hash that represents the configuration item's state.</p>
    /// <p>You can use MD5 hash to compare the states of two or more configuration items that are associated with the same resource.</p>
    pub fn configuration_item_md5_hash(&self) -> std::option::Option<&str> {
        self.configuration_item_md5_hash.as_deref()
    }
    /// <p>Amazon Resource Name (ARN) associated with the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The type of Amazon Web Services resource.</p>
    pub fn resource_type(&self) -> std::option::Option<&crate::model::ResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>The ID of the resource (for example, <code>sg-xxxxxx</code>).</p>
    pub fn resource_id(&self) -> std::option::Option<&str> {
        self.resource_id.as_deref()
    }
    /// <p>The custom name of the resource, if available.</p>
    pub fn resource_name(&self) -> std::option::Option<&str> {
        self.resource_name.as_deref()
    }
    /// <p>The region where the resource resides.</p>
    pub fn aws_region(&self) -> std::option::Option<&str> {
        self.aws_region.as_deref()
    }
    /// <p>The Availability Zone associated with the resource.</p>
    pub fn availability_zone(&self) -> std::option::Option<&str> {
        self.availability_zone.as_deref()
    }
    /// <p>The time stamp when the resource was created.</p>
    pub fn resource_creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.resource_creation_time.as_ref()
    }
    /// <p>A mapping of key value tags associated with the resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>A list of CloudTrail event IDs.</p>
    /// <p>A populated field indicates that the current configuration was initiated by the events recorded in the CloudTrail log. For more information about CloudTrail, see <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/what_is_cloud_trail_top_level.html">What Is CloudTrail</a>.</p>
    /// <p>An empty field indicates that the current configuration was not initiated by any event. As of Version 1.3, the relatedEvents field is empty. You can access the <a href="https://docs.aws.amazon.com/awscloudtrail/latest/APIReference/API_LookupEvents.html">LookupEvents API</a> in the <i>CloudTrail API Reference</i> to retrieve the events for the resource.</p>
    pub fn related_events(&self) -> std::option::Option<&[std::string::String]> {
        self.related_events.as_deref()
    }
    /// <p>A list of related Amazon Web Services resources.</p>
    pub fn relationships(&self) -> std::option::Option<&[crate::model::Relationship]> {
        self.relationships.as_deref()
    }
    /// <p>The description of the resource configuration.</p>
    pub fn configuration(&self) -> std::option::Option<&str> {
        self.configuration.as_deref()
    }
    /// <p>Configuration attributes that Config returns for certain resource types to supplement the information returned for the <code>configuration</code> parameter.</p>
    pub fn supplementary_configuration(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.supplementary_configuration.as_ref()
    }
}
impl ConfigurationItem {
    /// Creates a new builder-style object to manufacture [`ConfigurationItem`](crate::model::ConfigurationItem).
    pub fn builder() -> crate::model::configuration_item::Builder {
        crate::model::configuration_item::Builder::default()
    }
}

/// See [`ConfigurationItem`](crate::model::ConfigurationItem).
pub mod configuration_item {

    /// A builder for [`ConfigurationItem`](crate::model::ConfigurationItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) version: std::option::Option<std::string::String>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) configuration_item_capture_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) configuration_item_status:
            std::option::Option<crate::model::ConfigurationItemStatus>,
        pub(crate) configuration_state_id: std::option::Option<std::string::String>,
        pub(crate) configuration_item_md5_hash: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_name: std::option::Option<std::string::String>,
        pub(crate) aws_region: std::option::Option<std::string::String>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) resource_creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) related_events: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) relationships: std::option::Option<std::vec::Vec<crate::model::Relationship>>,
        pub(crate) configuration: std::option::Option<std::string::String>,
        pub(crate) supplementary_configuration: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The version number of the resource configuration.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The version number of the resource configuration.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// <p>The 12-digit Amazon Web Services account ID associated with the resource.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The 12-digit Amazon Web Services account ID associated with the resource.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The time when the configuration recording was initiated.</p>
        pub fn configuration_item_capture_time(
            mut self,
            input: aws_smithy_types::DateTime,
        ) -> Self {
            self.configuration_item_capture_time = Some(input);
            self
        }
        /// <p>The time when the configuration recording was initiated.</p>
        pub fn set_configuration_item_capture_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.configuration_item_capture_time = input;
            self
        }
        /// <p>The configuration item status. The valid values are:</p>
        /// <ul>
        /// <li> <p>OK – The resource configuration has been updated</p> </li>
        /// <li> <p>ResourceDiscovered – The resource was newly discovered</p> </li>
        /// <li> <p>ResourceNotRecorded – The resource was discovered but its configuration was not recorded since the recorder excludes the recording of resources of this type</p> </li>
        /// <li> <p>ResourceDeleted – The resource was deleted</p> </li>
        /// <li> <p>ResourceDeletedNotRecorded – The resource was deleted but its configuration was not recorded since the recorder excludes the recording of resources of this type</p> </li>
        /// </ul> <note>
        /// <p>The CIs do not incur any cost.</p>
        /// </note>
        pub fn configuration_item_status(
            mut self,
            input: crate::model::ConfigurationItemStatus,
        ) -> Self {
            self.configuration_item_status = Some(input);
            self
        }
        /// <p>The configuration item status. The valid values are:</p>
        /// <ul>
        /// <li> <p>OK – The resource configuration has been updated</p> </li>
        /// <li> <p>ResourceDiscovered – The resource was newly discovered</p> </li>
        /// <li> <p>ResourceNotRecorded – The resource was discovered but its configuration was not recorded since the recorder excludes the recording of resources of this type</p> </li>
        /// <li> <p>ResourceDeleted – The resource was deleted</p> </li>
        /// <li> <p>ResourceDeletedNotRecorded – The resource was deleted but its configuration was not recorded since the recorder excludes the recording of resources of this type</p> </li>
        /// </ul> <note>
        /// <p>The CIs do not incur any cost.</p>
        /// </note>
        pub fn set_configuration_item_status(
            mut self,
            input: std::option::Option<crate::model::ConfigurationItemStatus>,
        ) -> Self {
            self.configuration_item_status = input;
            self
        }
        /// <p>An identifier that indicates the ordering of the configuration items of a resource.</p>
        pub fn configuration_state_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.configuration_state_id = Some(input.into());
            self
        }
        /// <p>An identifier that indicates the ordering of the configuration items of a resource.</p>
        pub fn set_configuration_state_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.configuration_state_id = input;
            self
        }
        /// <p>Unique MD5 hash that represents the configuration item's state.</p>
        /// <p>You can use MD5 hash to compare the states of two or more configuration items that are associated with the same resource.</p>
        pub fn configuration_item_md5_hash(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.configuration_item_md5_hash = Some(input.into());
            self
        }
        /// <p>Unique MD5 hash that represents the configuration item's state.</p>
        /// <p>You can use MD5 hash to compare the states of two or more configuration items that are associated with the same resource.</p>
        pub fn set_configuration_item_md5_hash(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.configuration_item_md5_hash = input;
            self
        }
        /// <p>Amazon Resource Name (ARN) associated with the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Amazon Resource Name (ARN) associated with the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The type of Amazon Web Services resource.</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>The type of Amazon Web Services resource.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The ID of the resource (for example, <code>sg-xxxxxx</code>).</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The ID of the resource (for example, <code>sg-xxxxxx</code>).</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The custom name of the resource, if available.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_name = Some(input.into());
            self
        }
        /// <p>The custom name of the resource, if available.</p>
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_name = input;
            self
        }
        /// <p>The region where the resource resides.</p>
        pub fn aws_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_region = Some(input.into());
            self
        }
        /// <p>The region where the resource resides.</p>
        pub fn set_aws_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.aws_region = input;
            self
        }
        /// <p>The Availability Zone associated with the resource.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        /// <p>The Availability Zone associated with the resource.</p>
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The time stamp when the resource was created.</p>
        pub fn resource_creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.resource_creation_time = Some(input);
            self
        }
        /// <p>The time stamp when the resource was created.</p>
        pub fn set_resource_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.resource_creation_time = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A mapping of key value tags associated with the resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A mapping of key value tags associated with the resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Appends an item to `related_events`.
        ///
        /// To override the contents of this collection use [`set_related_events`](Self::set_related_events).
        ///
        /// <p>A list of CloudTrail event IDs.</p>
        /// <p>A populated field indicates that the current configuration was initiated by the events recorded in the CloudTrail log. For more information about CloudTrail, see <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/what_is_cloud_trail_top_level.html">What Is CloudTrail</a>.</p>
        /// <p>An empty field indicates that the current configuration was not initiated by any event. As of Version 1.3, the relatedEvents field is empty. You can access the <a href="https://docs.aws.amazon.com/awscloudtrail/latest/APIReference/API_LookupEvents.html">LookupEvents API</a> in the <i>CloudTrail API Reference</i> to retrieve the events for the resource.</p>
        pub fn related_events(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.related_events.unwrap_or_default();
            v.push(input.into());
            self.related_events = Some(v);
            self
        }
        /// <p>A list of CloudTrail event IDs.</p>
        /// <p>A populated field indicates that the current configuration was initiated by the events recorded in the CloudTrail log. For more information about CloudTrail, see <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/what_is_cloud_trail_top_level.html">What Is CloudTrail</a>.</p>
        /// <p>An empty field indicates that the current configuration was not initiated by any event. As of Version 1.3, the relatedEvents field is empty. You can access the <a href="https://docs.aws.amazon.com/awscloudtrail/latest/APIReference/API_LookupEvents.html">LookupEvents API</a> in the <i>CloudTrail API Reference</i> to retrieve the events for the resource.</p>
        pub fn set_related_events(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.related_events = input;
            self
        }
        /// Appends an item to `relationships`.
        ///
        /// To override the contents of this collection use [`set_relationships`](Self::set_relationships).
        ///
        /// <p>A list of related Amazon Web Services resources.</p>
        pub fn relationships(mut self, input: crate::model::Relationship) -> Self {
            let mut v = self.relationships.unwrap_or_default();
            v.push(input);
            self.relationships = Some(v);
            self
        }
        /// <p>A list of related Amazon Web Services resources.</p>
        pub fn set_relationships(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Relationship>>,
        ) -> Self {
            self.relationships = input;
            self
        }
        /// <p>The description of the resource configuration.</p>
        pub fn configuration(mut self, input: impl Into<std::string::String>) -> Self {
            self.configuration = Some(input.into());
            self
        }
        /// <p>The description of the resource configuration.</p>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// Adds a key-value pair to `supplementary_configuration`.
        ///
        /// To override the contents of this collection use [`set_supplementary_configuration`](Self::set_supplementary_configuration).
        ///
        /// <p>Configuration attributes that Config returns for certain resource types to supplement the information returned for the <code>configuration</code> parameter.</p>
        pub fn supplementary_configuration(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.supplementary_configuration.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.supplementary_configuration = Some(hash_map);
            self
        }
        /// <p>Configuration attributes that Config returns for certain resource types to supplement the information returned for the <code>configuration</code> parameter.</p>
        pub fn set_supplementary_configuration(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.supplementary_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigurationItem`](crate::model::ConfigurationItem).
        pub fn build(self) -> crate::model::ConfigurationItem {
            crate::model::ConfigurationItem {
                version: self.version,
                account_id: self.account_id,
                configuration_item_capture_time: self.configuration_item_capture_time,
                configuration_item_status: self.configuration_item_status,
                configuration_state_id: self.configuration_state_id,
                configuration_item_md5_hash: self.configuration_item_md5_hash,
                arn: self.arn,
                resource_type: self.resource_type,
                resource_id: self.resource_id,
                resource_name: self.resource_name,
                aws_region: self.aws_region,
                availability_zone: self.availability_zone,
                resource_creation_time: self.resource_creation_time,
                tags: self.tags,
                related_events: self.related_events,
                relationships: self.relationships,
                configuration: self.configuration,
                supplementary_configuration: self.supplementary_configuration,
            }
        }
    }
}

/// <p>The relationship of the related resource to the main resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Relationship {
    /// <p>The resource type of the related resource.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>The ID of the related resource (for example, <code>sg-xxxxxx</code>).</p>
    #[doc(hidden)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The custom name of the related resource, if available.</p>
    #[doc(hidden)]
    pub resource_name: std::option::Option<std::string::String>,
    /// <p>The type of relationship with the related resource.</p>
    #[doc(hidden)]
    pub relationship_name: std::option::Option<std::string::String>,
}
impl Relationship {
    /// <p>The resource type of the related resource.</p>
    pub fn resource_type(&self) -> std::option::Option<&crate::model::ResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>The ID of the related resource (for example, <code>sg-xxxxxx</code>).</p>
    pub fn resource_id(&self) -> std::option::Option<&str> {
        self.resource_id.as_deref()
    }
    /// <p>The custom name of the related resource, if available.</p>
    pub fn resource_name(&self) -> std::option::Option<&str> {
        self.resource_name.as_deref()
    }
    /// <p>The type of relationship with the related resource.</p>
    pub fn relationship_name(&self) -> std::option::Option<&str> {
        self.relationship_name.as_deref()
    }
}
impl Relationship {
    /// Creates a new builder-style object to manufacture [`Relationship`](crate::model::Relationship).
    pub fn builder() -> crate::model::relationship::Builder {
        crate::model::relationship::Builder::default()
    }
}

/// See [`Relationship`](crate::model::Relationship).
pub mod relationship {

    /// A builder for [`Relationship`](crate::model::Relationship).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_name: std::option::Option<std::string::String>,
        pub(crate) relationship_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The resource type of the related resource.</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>The resource type of the related resource.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The ID of the related resource (for example, <code>sg-xxxxxx</code>).</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The ID of the related resource (for example, <code>sg-xxxxxx</code>).</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The custom name of the related resource, if available.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_name = Some(input.into());
            self
        }
        /// <p>The custom name of the related resource, if available.</p>
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_name = input;
            self
        }
        /// <p>The type of relationship with the related resource.</p>
        pub fn relationship_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.relationship_name = Some(input.into());
            self
        }
        /// <p>The type of relationship with the related resource.</p>
        pub fn set_relationship_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relationship_name = input;
            self
        }
        /// Consumes the builder and constructs a [`Relationship`](crate::model::Relationship).
        pub fn build(self) -> crate::model::Relationship {
            crate::model::Relationship {
                resource_type: self.resource_type,
                resource_id: self.resource_id,
                resource_name: self.resource_name,
                relationship_name: self.relationship_name,
            }
        }
    }
}

/// When writing a match expression against `ConfigurationItemStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let configurationitemstatus = unimplemented!();
/// match configurationitemstatus {
///     ConfigurationItemStatus::Ok => { /* ... */ },
///     ConfigurationItemStatus::ResourceDeleted => { /* ... */ },
///     ConfigurationItemStatus::ResourceDeletedNotRecorded => { /* ... */ },
///     ConfigurationItemStatus::ResourceDiscovered => { /* ... */ },
///     ConfigurationItemStatus::ResourceNotRecorded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `configurationitemstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConfigurationItemStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConfigurationItemStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConfigurationItemStatus::NewFeature` is defined.
/// Specifically, when `configurationitemstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConfigurationItemStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConfigurationItemStatus {
    #[allow(missing_docs)] // documentation missing in model
    Ok,
    #[allow(missing_docs)] // documentation missing in model
    ResourceDeleted,
    #[allow(missing_docs)] // documentation missing in model
    ResourceDeletedNotRecorded,
    #[allow(missing_docs)] // documentation missing in model
    ResourceDiscovered,
    #[allow(missing_docs)] // documentation missing in model
    ResourceNotRecorded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConfigurationItemStatus {
    fn from(s: &str) -> Self {
        match s {
            "OK" => ConfigurationItemStatus::Ok,
            "ResourceDeleted" => ConfigurationItemStatus::ResourceDeleted,
            "ResourceDeletedNotRecorded" => ConfigurationItemStatus::ResourceDeletedNotRecorded,
            "ResourceDiscovered" => ConfigurationItemStatus::ResourceDiscovered,
            "ResourceNotRecorded" => ConfigurationItemStatus::ResourceNotRecorded,
            other => ConfigurationItemStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ConfigurationItemStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConfigurationItemStatus::from(s))
    }
}
impl ConfigurationItemStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConfigurationItemStatus::Ok => "OK",
            ConfigurationItemStatus::ResourceDeleted => "ResourceDeleted",
            ConfigurationItemStatus::ResourceDeletedNotRecorded => "ResourceDeletedNotRecorded",
            ConfigurationItemStatus::ResourceDiscovered => "ResourceDiscovered",
            ConfigurationItemStatus::ResourceNotRecorded => "ResourceNotRecorded",
            ConfigurationItemStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "OK",
            "ResourceDeleted",
            "ResourceDeletedNotRecorded",
            "ResourceDiscovered",
            "ResourceNotRecorded",
        ]
    }
}
impl AsRef<str> for ConfigurationItemStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ChronologicalOrder`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let chronologicalorder = unimplemented!();
/// match chronologicalorder {
///     ChronologicalOrder::Forward => { /* ... */ },
///     ChronologicalOrder::Reverse => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `chronologicalorder` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ChronologicalOrder::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ChronologicalOrder::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ChronologicalOrder::NewFeature` is defined.
/// Specifically, when `chronologicalorder` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ChronologicalOrder::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ChronologicalOrder {
    #[allow(missing_docs)] // documentation missing in model
    Forward,
    #[allow(missing_docs)] // documentation missing in model
    Reverse,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ChronologicalOrder {
    fn from(s: &str) -> Self {
        match s {
            "Forward" => ChronologicalOrder::Forward,
            "Reverse" => ChronologicalOrder::Reverse,
            other => {
                ChronologicalOrder::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ChronologicalOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ChronologicalOrder::from(s))
    }
}
impl ChronologicalOrder {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ChronologicalOrder::Forward => "Forward",
            ChronologicalOrder::Reverse => "Reverse",
            ChronologicalOrder::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Forward", "Reverse"]
    }
}
impl AsRef<str> for ChronologicalOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Organization conformance pack creation or deletion status in each member account. This includes the name of the conformance pack, the status, error code and error message when the conformance pack creation or deletion failed. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OrganizationConformancePackDetailedStatus {
    /// <p>The 12-digit account ID of a member account.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The name of conformance pack deployed in the member account.</p>
    #[doc(hidden)]
    pub conformance_pack_name: std::option::Option<std::string::String>,
    /// <p>Indicates deployment status for conformance pack in a member account. When management account calls <code>PutOrganizationConformancePack</code> action for the first time, conformance pack status is created in the member account. When management account calls <code>PutOrganizationConformancePack</code> action for the second time, conformance pack status is updated in the member account. Conformance pack status is deleted when the management account deletes <code>OrganizationConformancePack</code> and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>. </p>
    /// <p> Config sets the state of the conformance pack to:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_SUCCESSFUL</code> when conformance pack has been created in the member account. </p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> when conformance pack is being created in the member account.</p> </li>
    /// <li> <p> <code>CREATE_FAILED</code> when conformance pack creation has failed in the member account.</p> </li>
    /// <li> <p> <code>DELETE_FAILED</code> when conformance pack deletion has failed in the member account.</p> </li>
    /// <li> <p> <code>DELETE_IN_PROGRESS</code> when conformance pack is being deleted in the member account.</p> </li>
    /// <li> <p> <code>DELETE_SUCCESSFUL</code> when conformance pack has been deleted in the member account. </p> </li>
    /// <li> <p> <code>UPDATE_SUCCESSFUL</code> when conformance pack has been updated in the member account.</p> </li>
    /// <li> <p> <code>UPDATE_IN_PROGRESS</code> when conformance pack is being updated in the member account.</p> </li>
    /// <li> <p> <code>UPDATE_FAILED</code> when conformance pack deletion has failed in the member account.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::OrganizationResourceDetailedStatus>,
    /// <p>An error code that is returned when conformance pack creation or deletion failed in the member account. </p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>An error message indicating that conformance pack account creation or deletion has failed due to an error in the member account. </p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>The timestamp of the last status update.</p>
    #[doc(hidden)]
    pub last_update_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl OrganizationConformancePackDetailedStatus {
    /// <p>The 12-digit account ID of a member account.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The name of conformance pack deployed in the member account.</p>
    pub fn conformance_pack_name(&self) -> std::option::Option<&str> {
        self.conformance_pack_name.as_deref()
    }
    /// <p>Indicates deployment status for conformance pack in a member account. When management account calls <code>PutOrganizationConformancePack</code> action for the first time, conformance pack status is created in the member account. When management account calls <code>PutOrganizationConformancePack</code> action for the second time, conformance pack status is updated in the member account. Conformance pack status is deleted when the management account deletes <code>OrganizationConformancePack</code> and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>. </p>
    /// <p> Config sets the state of the conformance pack to:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_SUCCESSFUL</code> when conformance pack has been created in the member account. </p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> when conformance pack is being created in the member account.</p> </li>
    /// <li> <p> <code>CREATE_FAILED</code> when conformance pack creation has failed in the member account.</p> </li>
    /// <li> <p> <code>DELETE_FAILED</code> when conformance pack deletion has failed in the member account.</p> </li>
    /// <li> <p> <code>DELETE_IN_PROGRESS</code> when conformance pack is being deleted in the member account.</p> </li>
    /// <li> <p> <code>DELETE_SUCCESSFUL</code> when conformance pack has been deleted in the member account. </p> </li>
    /// <li> <p> <code>UPDATE_SUCCESSFUL</code> when conformance pack has been updated in the member account.</p> </li>
    /// <li> <p> <code>UPDATE_IN_PROGRESS</code> when conformance pack is being updated in the member account.</p> </li>
    /// <li> <p> <code>UPDATE_FAILED</code> when conformance pack deletion has failed in the member account.</p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::OrganizationResourceDetailedStatus> {
        self.status.as_ref()
    }
    /// <p>An error code that is returned when conformance pack creation or deletion failed in the member account. </p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>An error message indicating that conformance pack account creation or deletion has failed due to an error in the member account. </p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>The timestamp of the last status update.</p>
    pub fn last_update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_update_time.as_ref()
    }
}
impl OrganizationConformancePackDetailedStatus {
    /// Creates a new builder-style object to manufacture [`OrganizationConformancePackDetailedStatus`](crate::model::OrganizationConformancePackDetailedStatus).
    pub fn builder() -> crate::model::organization_conformance_pack_detailed_status::Builder {
        crate::model::organization_conformance_pack_detailed_status::Builder::default()
    }
}

/// See [`OrganizationConformancePackDetailedStatus`](crate::model::OrganizationConformancePackDetailedStatus).
pub mod organization_conformance_pack_detailed_status {

    /// A builder for [`OrganizationConformancePackDetailedStatus`](crate::model::OrganizationConformancePackDetailedStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) conformance_pack_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::OrganizationResourceDetailedStatus>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) last_update_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The 12-digit account ID of a member account.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The 12-digit account ID of a member account.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The name of conformance pack deployed in the member account.</p>
        pub fn conformance_pack_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.conformance_pack_name = Some(input.into());
            self
        }
        /// <p>The name of conformance pack deployed in the member account.</p>
        pub fn set_conformance_pack_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.conformance_pack_name = input;
            self
        }
        /// <p>Indicates deployment status for conformance pack in a member account. When management account calls <code>PutOrganizationConformancePack</code> action for the first time, conformance pack status is created in the member account. When management account calls <code>PutOrganizationConformancePack</code> action for the second time, conformance pack status is updated in the member account. Conformance pack status is deleted when the management account deletes <code>OrganizationConformancePack</code> and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>. </p>
        /// <p> Config sets the state of the conformance pack to:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_SUCCESSFUL</code> when conformance pack has been created in the member account. </p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> when conformance pack is being created in the member account.</p> </li>
        /// <li> <p> <code>CREATE_FAILED</code> when conformance pack creation has failed in the member account.</p> </li>
        /// <li> <p> <code>DELETE_FAILED</code> when conformance pack deletion has failed in the member account.</p> </li>
        /// <li> <p> <code>DELETE_IN_PROGRESS</code> when conformance pack is being deleted in the member account.</p> </li>
        /// <li> <p> <code>DELETE_SUCCESSFUL</code> when conformance pack has been deleted in the member account. </p> </li>
        /// <li> <p> <code>UPDATE_SUCCESSFUL</code> when conformance pack has been updated in the member account.</p> </li>
        /// <li> <p> <code>UPDATE_IN_PROGRESS</code> when conformance pack is being updated in the member account.</p> </li>
        /// <li> <p> <code>UPDATE_FAILED</code> when conformance pack deletion has failed in the member account.</p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::OrganizationResourceDetailedStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Indicates deployment status for conformance pack in a member account. When management account calls <code>PutOrganizationConformancePack</code> action for the first time, conformance pack status is created in the member account. When management account calls <code>PutOrganizationConformancePack</code> action for the second time, conformance pack status is updated in the member account. Conformance pack status is deleted when the management account deletes <code>OrganizationConformancePack</code> and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>. </p>
        /// <p> Config sets the state of the conformance pack to:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_SUCCESSFUL</code> when conformance pack has been created in the member account. </p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> when conformance pack is being created in the member account.</p> </li>
        /// <li> <p> <code>CREATE_FAILED</code> when conformance pack creation has failed in the member account.</p> </li>
        /// <li> <p> <code>DELETE_FAILED</code> when conformance pack deletion has failed in the member account.</p> </li>
        /// <li> <p> <code>DELETE_IN_PROGRESS</code> when conformance pack is being deleted in the member account.</p> </li>
        /// <li> <p> <code>DELETE_SUCCESSFUL</code> when conformance pack has been deleted in the member account. </p> </li>
        /// <li> <p> <code>UPDATE_SUCCESSFUL</code> when conformance pack has been updated in the member account.</p> </li>
        /// <li> <p> <code>UPDATE_IN_PROGRESS</code> when conformance pack is being updated in the member account.</p> </li>
        /// <li> <p> <code>UPDATE_FAILED</code> when conformance pack deletion has failed in the member account.</p> </li>
        /// </ul>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OrganizationResourceDetailedStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>An error code that is returned when conformance pack creation or deletion failed in the member account. </p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>An error code that is returned when conformance pack creation or deletion failed in the member account. </p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>An error message indicating that conformance pack account creation or deletion has failed due to an error in the member account. </p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>An error message indicating that conformance pack account creation or deletion has failed due to an error in the member account. </p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>The timestamp of the last status update.</p>
        pub fn last_update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_update_time = Some(input);
            self
        }
        /// <p>The timestamp of the last status update.</p>
        pub fn set_last_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_update_time = input;
            self
        }
        /// Consumes the builder and constructs a [`OrganizationConformancePackDetailedStatus`](crate::model::OrganizationConformancePackDetailedStatus).
        pub fn build(self) -> crate::model::OrganizationConformancePackDetailedStatus {
            crate::model::OrganizationConformancePackDetailedStatus {
                account_id: self.account_id,
                conformance_pack_name: self.conformance_pack_name,
                status: self.status,
                error_code: self.error_code,
                error_message: self.error_message,
                last_update_time: self.last_update_time,
            }
        }
    }
}

/// When writing a match expression against `OrganizationResourceDetailedStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let organizationresourcedetailedstatus = unimplemented!();
/// match organizationresourcedetailedstatus {
///     OrganizationResourceDetailedStatus::CreateFailed => { /* ... */ },
///     OrganizationResourceDetailedStatus::CreateInProgress => { /* ... */ },
///     OrganizationResourceDetailedStatus::CreateSuccessful => { /* ... */ },
///     OrganizationResourceDetailedStatus::DeleteFailed => { /* ... */ },
///     OrganizationResourceDetailedStatus::DeleteInProgress => { /* ... */ },
///     OrganizationResourceDetailedStatus::DeleteSuccessful => { /* ... */ },
///     OrganizationResourceDetailedStatus::UpdateFailed => { /* ... */ },
///     OrganizationResourceDetailedStatus::UpdateInProgress => { /* ... */ },
///     OrganizationResourceDetailedStatus::UpdateSuccessful => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `organizationresourcedetailedstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OrganizationResourceDetailedStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OrganizationResourceDetailedStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OrganizationResourceDetailedStatus::NewFeature` is defined.
/// Specifically, when `organizationresourcedetailedstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OrganizationResourceDetailedStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OrganizationResourceDetailedStatus {
    #[allow(missing_docs)] // documentation missing in model
    CreateFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    CreateSuccessful,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    DeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    DeleteSuccessful,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFailed,
    #[allow(missing_docs)] // documentation missing in model
    UpdateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    UpdateSuccessful,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OrganizationResourceDetailedStatus {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_FAILED" => OrganizationResourceDetailedStatus::CreateFailed,
            "CREATE_IN_PROGRESS" => OrganizationResourceDetailedStatus::CreateInProgress,
            "CREATE_SUCCESSFUL" => OrganizationResourceDetailedStatus::CreateSuccessful,
            "DELETE_FAILED" => OrganizationResourceDetailedStatus::DeleteFailed,
            "DELETE_IN_PROGRESS" => OrganizationResourceDetailedStatus::DeleteInProgress,
            "DELETE_SUCCESSFUL" => OrganizationResourceDetailedStatus::DeleteSuccessful,
            "UPDATE_FAILED" => OrganizationResourceDetailedStatus::UpdateFailed,
            "UPDATE_IN_PROGRESS" => OrganizationResourceDetailedStatus::UpdateInProgress,
            "UPDATE_SUCCESSFUL" => OrganizationResourceDetailedStatus::UpdateSuccessful,
            other => OrganizationResourceDetailedStatus::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for OrganizationResourceDetailedStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OrganizationResourceDetailedStatus::from(s))
    }
}
impl OrganizationResourceDetailedStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OrganizationResourceDetailedStatus::CreateFailed => "CREATE_FAILED",
            OrganizationResourceDetailedStatus::CreateInProgress => "CREATE_IN_PROGRESS",
            OrganizationResourceDetailedStatus::CreateSuccessful => "CREATE_SUCCESSFUL",
            OrganizationResourceDetailedStatus::DeleteFailed => "DELETE_FAILED",
            OrganizationResourceDetailedStatus::DeleteInProgress => "DELETE_IN_PROGRESS",
            OrganizationResourceDetailedStatus::DeleteSuccessful => "DELETE_SUCCESSFUL",
            OrganizationResourceDetailedStatus::UpdateFailed => "UPDATE_FAILED",
            OrganizationResourceDetailedStatus::UpdateInProgress => "UPDATE_IN_PROGRESS",
            OrganizationResourceDetailedStatus::UpdateSuccessful => "UPDATE_SUCCESSFUL",
            OrganizationResourceDetailedStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CREATE_FAILED",
            "CREATE_IN_PROGRESS",
            "CREATE_SUCCESSFUL",
            "DELETE_FAILED",
            "DELETE_IN_PROGRESS",
            "DELETE_SUCCESSFUL",
            "UPDATE_FAILED",
            "UPDATE_IN_PROGRESS",
            "UPDATE_SUCCESSFUL",
        ]
    }
}
impl AsRef<str> for OrganizationResourceDetailedStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Status filter object to filter results based on specific member account ID or status type for an organization conformance pack.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OrganizationResourceDetailedStatusFilters {
    /// <p>The 12-digit account ID of the member account within an organization.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>Indicates deployment status for conformance pack in a member account. When management account calls <code>PutOrganizationConformancePack</code> action for the first time, conformance pack status is created in the member account. When management account calls <code>PutOrganizationConformancePack</code> action for the second time, conformance pack status is updated in the member account. Conformance pack status is deleted when the management account deletes <code>OrganizationConformancePack</code> and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>. </p>
    /// <p> Config sets the state of the conformance pack to:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_SUCCESSFUL</code> when conformance pack has been created in the member account. </p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> when conformance pack is being created in the member account.</p> </li>
    /// <li> <p> <code>CREATE_FAILED</code> when conformance pack creation has failed in the member account.</p> </li>
    /// <li> <p> <code>DELETE_FAILED</code> when conformance pack deletion has failed in the member account.</p> </li>
    /// <li> <p> <code>DELETE_IN_PROGRESS</code> when conformance pack is being deleted in the member account.</p> </li>
    /// <li> <p> <code>DELETE_SUCCESSFUL</code> when conformance pack has been deleted in the member account. </p> </li>
    /// <li> <p> <code>UPDATE_SUCCESSFUL</code> when conformance pack has been updated in the member account.</p> </li>
    /// <li> <p> <code>UPDATE_IN_PROGRESS</code> when conformance pack is being updated in the member account.</p> </li>
    /// <li> <p> <code>UPDATE_FAILED</code> when conformance pack deletion has failed in the member account.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::OrganizationResourceDetailedStatus>,
}
impl OrganizationResourceDetailedStatusFilters {
    /// <p>The 12-digit account ID of the member account within an organization.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>Indicates deployment status for conformance pack in a member account. When management account calls <code>PutOrganizationConformancePack</code> action for the first time, conformance pack status is created in the member account. When management account calls <code>PutOrganizationConformancePack</code> action for the second time, conformance pack status is updated in the member account. Conformance pack status is deleted when the management account deletes <code>OrganizationConformancePack</code> and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>. </p>
    /// <p> Config sets the state of the conformance pack to:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_SUCCESSFUL</code> when conformance pack has been created in the member account. </p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> when conformance pack is being created in the member account.</p> </li>
    /// <li> <p> <code>CREATE_FAILED</code> when conformance pack creation has failed in the member account.</p> </li>
    /// <li> <p> <code>DELETE_FAILED</code> when conformance pack deletion has failed in the member account.</p> </li>
    /// <li> <p> <code>DELETE_IN_PROGRESS</code> when conformance pack is being deleted in the member account.</p> </li>
    /// <li> <p> <code>DELETE_SUCCESSFUL</code> when conformance pack has been deleted in the member account. </p> </li>
    /// <li> <p> <code>UPDATE_SUCCESSFUL</code> when conformance pack has been updated in the member account.</p> </li>
    /// <li> <p> <code>UPDATE_IN_PROGRESS</code> when conformance pack is being updated in the member account.</p> </li>
    /// <li> <p> <code>UPDATE_FAILED</code> when conformance pack deletion has failed in the member account.</p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::OrganizationResourceDetailedStatus> {
        self.status.as_ref()
    }
}
impl OrganizationResourceDetailedStatusFilters {
    /// Creates a new builder-style object to manufacture [`OrganizationResourceDetailedStatusFilters`](crate::model::OrganizationResourceDetailedStatusFilters).
    pub fn builder() -> crate::model::organization_resource_detailed_status_filters::Builder {
        crate::model::organization_resource_detailed_status_filters::Builder::default()
    }
}

/// See [`OrganizationResourceDetailedStatusFilters`](crate::model::OrganizationResourceDetailedStatusFilters).
pub mod organization_resource_detailed_status_filters {

    /// A builder for [`OrganizationResourceDetailedStatusFilters`](crate::model::OrganizationResourceDetailedStatusFilters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::OrganizationResourceDetailedStatus>,
    }
    impl Builder {
        /// <p>The 12-digit account ID of the member account within an organization.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The 12-digit account ID of the member account within an organization.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>Indicates deployment status for conformance pack in a member account. When management account calls <code>PutOrganizationConformancePack</code> action for the first time, conformance pack status is created in the member account. When management account calls <code>PutOrganizationConformancePack</code> action for the second time, conformance pack status is updated in the member account. Conformance pack status is deleted when the management account deletes <code>OrganizationConformancePack</code> and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>. </p>
        /// <p> Config sets the state of the conformance pack to:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_SUCCESSFUL</code> when conformance pack has been created in the member account. </p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> when conformance pack is being created in the member account.</p> </li>
        /// <li> <p> <code>CREATE_FAILED</code> when conformance pack creation has failed in the member account.</p> </li>
        /// <li> <p> <code>DELETE_FAILED</code> when conformance pack deletion has failed in the member account.</p> </li>
        /// <li> <p> <code>DELETE_IN_PROGRESS</code> when conformance pack is being deleted in the member account.</p> </li>
        /// <li> <p> <code>DELETE_SUCCESSFUL</code> when conformance pack has been deleted in the member account. </p> </li>
        /// <li> <p> <code>UPDATE_SUCCESSFUL</code> when conformance pack has been updated in the member account.</p> </li>
        /// <li> <p> <code>UPDATE_IN_PROGRESS</code> when conformance pack is being updated in the member account.</p> </li>
        /// <li> <p> <code>UPDATE_FAILED</code> when conformance pack deletion has failed in the member account.</p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::OrganizationResourceDetailedStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Indicates deployment status for conformance pack in a member account. When management account calls <code>PutOrganizationConformancePack</code> action for the first time, conformance pack status is created in the member account. When management account calls <code>PutOrganizationConformancePack</code> action for the second time, conformance pack status is updated in the member account. Conformance pack status is deleted when the management account deletes <code>OrganizationConformancePack</code> and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>. </p>
        /// <p> Config sets the state of the conformance pack to:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_SUCCESSFUL</code> when conformance pack has been created in the member account. </p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> when conformance pack is being created in the member account.</p> </li>
        /// <li> <p> <code>CREATE_FAILED</code> when conformance pack creation has failed in the member account.</p> </li>
        /// <li> <p> <code>DELETE_FAILED</code> when conformance pack deletion has failed in the member account.</p> </li>
        /// <li> <p> <code>DELETE_IN_PROGRESS</code> when conformance pack is being deleted in the member account.</p> </li>
        /// <li> <p> <code>DELETE_SUCCESSFUL</code> when conformance pack has been deleted in the member account. </p> </li>
        /// <li> <p> <code>UPDATE_SUCCESSFUL</code> when conformance pack has been updated in the member account.</p> </li>
        /// <li> <p> <code>UPDATE_IN_PROGRESS</code> when conformance pack is being updated in the member account.</p> </li>
        /// <li> <p> <code>UPDATE_FAILED</code> when conformance pack deletion has failed in the member account.</p> </li>
        /// </ul>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OrganizationResourceDetailedStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`OrganizationResourceDetailedStatusFilters`](crate::model::OrganizationResourceDetailedStatusFilters).
        pub fn build(self) -> crate::model::OrganizationResourceDetailedStatusFilters {
            crate::model::OrganizationResourceDetailedStatusFilters {
                account_id: self.account_id,
                status: self.status,
            }
        }
    }
}

/// <p>Organization Config rule creation or deletion status in each member account. This includes the name of the rule, the status, error code and error message when the rule creation or deletion failed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MemberAccountStatus {
    /// <p>The 12-digit account ID of a member account.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The name of Config rule deployed in the member account.</p>
    #[doc(hidden)]
    pub config_rule_name: std::option::Option<std::string::String>,
    /// <p>Indicates deployment status for Config rule in the member account. When management account calls <code>PutOrganizationConfigRule</code> action for the first time, Config rule status is created in the member account. When management account calls <code>PutOrganizationConfigRule</code> action for the second time, Config rule status is updated in the member account. Config rule status is deleted when the management account deletes <code>OrganizationConfigRule</code> and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>. </p>
    /// <p> Config sets the state of the rule to:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_SUCCESSFUL</code> when Config rule has been created in the member account. </p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> when Config rule is being created in the member account.</p> </li>
    /// <li> <p> <code>CREATE_FAILED</code> when Config rule creation has failed in the member account.</p> </li>
    /// <li> <p> <code>DELETE_FAILED</code> when Config rule deletion has failed in the member account.</p> </li>
    /// <li> <p> <code>DELETE_IN_PROGRESS</code> when Config rule is being deleted in the member account.</p> </li>
    /// <li> <p> <code>DELETE_SUCCESSFUL</code> when Config rule has been deleted in the member account. </p> </li>
    /// <li> <p> <code>UPDATE_SUCCESSFUL</code> when Config rule has been updated in the member account.</p> </li>
    /// <li> <p> <code>UPDATE_IN_PROGRESS</code> when Config rule is being updated in the member account.</p> </li>
    /// <li> <p> <code>UPDATE_FAILED</code> when Config rule deletion has failed in the member account.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub member_account_rule_status: std::option::Option<crate::model::MemberAccountRuleStatus>,
    /// <p>An error code that is returned when Config rule creation or deletion failed in the member account.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>An error message indicating that Config rule account creation or deletion has failed due to an error in the member account.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>The timestamp of the last status update.</p>
    #[doc(hidden)]
    pub last_update_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl MemberAccountStatus {
    /// <p>The 12-digit account ID of a member account.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The name of Config rule deployed in the member account.</p>
    pub fn config_rule_name(&self) -> std::option::Option<&str> {
        self.config_rule_name.as_deref()
    }
    /// <p>Indicates deployment status for Config rule in the member account. When management account calls <code>PutOrganizationConfigRule</code> action for the first time, Config rule status is created in the member account. When management account calls <code>PutOrganizationConfigRule</code> action for the second time, Config rule status is updated in the member account. Config rule status is deleted when the management account deletes <code>OrganizationConfigRule</code> and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>. </p>
    /// <p> Config sets the state of the rule to:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_SUCCESSFUL</code> when Config rule has been created in the member account. </p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> when Config rule is being created in the member account.</p> </li>
    /// <li> <p> <code>CREATE_FAILED</code> when Config rule creation has failed in the member account.</p> </li>
    /// <li> <p> <code>DELETE_FAILED</code> when Config rule deletion has failed in the member account.</p> </li>
    /// <li> <p> <code>DELETE_IN_PROGRESS</code> when Config rule is being deleted in the member account.</p> </li>
    /// <li> <p> <code>DELETE_SUCCESSFUL</code> when Config rule has been deleted in the member account. </p> </li>
    /// <li> <p> <code>UPDATE_SUCCESSFUL</code> when Config rule has been updated in the member account.</p> </li>
    /// <li> <p> <code>UPDATE_IN_PROGRESS</code> when Config rule is being updated in the member account.</p> </li>
    /// <li> <p> <code>UPDATE_FAILED</code> when Config rule deletion has failed in the member account.</p> </li>
    /// </ul>
    pub fn member_account_rule_status(
        &self,
    ) -> std::option::Option<&crate::model::MemberAccountRuleStatus> {
        self.member_account_rule_status.as_ref()
    }
    /// <p>An error code that is returned when Config rule creation or deletion failed in the member account.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>An error message indicating that Config rule account creation or deletion has failed due to an error in the member account.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>The timestamp of the last status update.</p>
    pub fn last_update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_update_time.as_ref()
    }
}
impl MemberAccountStatus {
    /// Creates a new builder-style object to manufacture [`MemberAccountStatus`](crate::model::MemberAccountStatus).
    pub fn builder() -> crate::model::member_account_status::Builder {
        crate::model::member_account_status::Builder::default()
    }
}

/// See [`MemberAccountStatus`](crate::model::MemberAccountStatus).
pub mod member_account_status {

    /// A builder for [`MemberAccountStatus`](crate::model::MemberAccountStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) config_rule_name: std::option::Option<std::string::String>,
        pub(crate) member_account_rule_status:
            std::option::Option<crate::model::MemberAccountRuleStatus>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) last_update_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The 12-digit account ID of a member account.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The 12-digit account ID of a member account.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The name of Config rule deployed in the member account.</p>
        pub fn config_rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.config_rule_name = Some(input.into());
            self
        }
        /// <p>The name of Config rule deployed in the member account.</p>
        pub fn set_config_rule_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.config_rule_name = input;
            self
        }
        /// <p>Indicates deployment status for Config rule in the member account. When management account calls <code>PutOrganizationConfigRule</code> action for the first time, Config rule status is created in the member account. When management account calls <code>PutOrganizationConfigRule</code> action for the second time, Config rule status is updated in the member account. Config rule status is deleted when the management account deletes <code>OrganizationConfigRule</code> and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>. </p>
        /// <p> Config sets the state of the rule to:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_SUCCESSFUL</code> when Config rule has been created in the member account. </p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> when Config rule is being created in the member account.</p> </li>
        /// <li> <p> <code>CREATE_FAILED</code> when Config rule creation has failed in the member account.</p> </li>
        /// <li> <p> <code>DELETE_FAILED</code> when Config rule deletion has failed in the member account.</p> </li>
        /// <li> <p> <code>DELETE_IN_PROGRESS</code> when Config rule is being deleted in the member account.</p> </li>
        /// <li> <p> <code>DELETE_SUCCESSFUL</code> when Config rule has been deleted in the member account. </p> </li>
        /// <li> <p> <code>UPDATE_SUCCESSFUL</code> when Config rule has been updated in the member account.</p> </li>
        /// <li> <p> <code>UPDATE_IN_PROGRESS</code> when Config rule is being updated in the member account.</p> </li>
        /// <li> <p> <code>UPDATE_FAILED</code> when Config rule deletion has failed in the member account.</p> </li>
        /// </ul>
        pub fn member_account_rule_status(
            mut self,
            input: crate::model::MemberAccountRuleStatus,
        ) -> Self {
            self.member_account_rule_status = Some(input);
            self
        }
        /// <p>Indicates deployment status for Config rule in the member account. When management account calls <code>PutOrganizationConfigRule</code> action for the first time, Config rule status is created in the member account. When management account calls <code>PutOrganizationConfigRule</code> action for the second time, Config rule status is updated in the member account. Config rule status is deleted when the management account deletes <code>OrganizationConfigRule</code> and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>. </p>
        /// <p> Config sets the state of the rule to:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_SUCCESSFUL</code> when Config rule has been created in the member account. </p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> when Config rule is being created in the member account.</p> </li>
        /// <li> <p> <code>CREATE_FAILED</code> when Config rule creation has failed in the member account.</p> </li>
        /// <li> <p> <code>DELETE_FAILED</code> when Config rule deletion has failed in the member account.</p> </li>
        /// <li> <p> <code>DELETE_IN_PROGRESS</code> when Config rule is being deleted in the member account.</p> </li>
        /// <li> <p> <code>DELETE_SUCCESSFUL</code> when Config rule has been deleted in the member account. </p> </li>
        /// <li> <p> <code>UPDATE_SUCCESSFUL</code> when Config rule has been updated in the member account.</p> </li>
        /// <li> <p> <code>UPDATE_IN_PROGRESS</code> when Config rule is being updated in the member account.</p> </li>
        /// <li> <p> <code>UPDATE_FAILED</code> when Config rule deletion has failed in the member account.</p> </li>
        /// </ul>
        pub fn set_member_account_rule_status(
            mut self,
            input: std::option::Option<crate::model::MemberAccountRuleStatus>,
        ) -> Self {
            self.member_account_rule_status = input;
            self
        }
        /// <p>An error code that is returned when Config rule creation or deletion failed in the member account.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>An error code that is returned when Config rule creation or deletion failed in the member account.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>An error message indicating that Config rule account creation or deletion has failed due to an error in the member account.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>An error message indicating that Config rule account creation or deletion has failed due to an error in the member account.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>The timestamp of the last status update.</p>
        pub fn last_update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_update_time = Some(input);
            self
        }
        /// <p>The timestamp of the last status update.</p>
        pub fn set_last_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_update_time = input;
            self
        }
        /// Consumes the builder and constructs a [`MemberAccountStatus`](crate::model::MemberAccountStatus).
        pub fn build(self) -> crate::model::MemberAccountStatus {
            crate::model::MemberAccountStatus {
                account_id: self.account_id,
                config_rule_name: self.config_rule_name,
                member_account_rule_status: self.member_account_rule_status,
                error_code: self.error_code,
                error_message: self.error_message,
                last_update_time: self.last_update_time,
            }
        }
    }
}

/// When writing a match expression against `MemberAccountRuleStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let memberaccountrulestatus = unimplemented!();
/// match memberaccountrulestatus {
///     MemberAccountRuleStatus::CreateFailed => { /* ... */ },
///     MemberAccountRuleStatus::CreateInProgress => { /* ... */ },
///     MemberAccountRuleStatus::CreateSuccessful => { /* ... */ },
///     MemberAccountRuleStatus::DeleteFailed => { /* ... */ },
///     MemberAccountRuleStatus::DeleteInProgress => { /* ... */ },
///     MemberAccountRuleStatus::DeleteSuccessful => { /* ... */ },
///     MemberAccountRuleStatus::UpdateFailed => { /* ... */ },
///     MemberAccountRuleStatus::UpdateInProgress => { /* ... */ },
///     MemberAccountRuleStatus::UpdateSuccessful => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `memberaccountrulestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MemberAccountRuleStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MemberAccountRuleStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MemberAccountRuleStatus::NewFeature` is defined.
/// Specifically, when `memberaccountrulestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MemberAccountRuleStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MemberAccountRuleStatus {
    #[allow(missing_docs)] // documentation missing in model
    CreateFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    CreateSuccessful,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    DeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    DeleteSuccessful,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFailed,
    #[allow(missing_docs)] // documentation missing in model
    UpdateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    UpdateSuccessful,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MemberAccountRuleStatus {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_FAILED" => MemberAccountRuleStatus::CreateFailed,
            "CREATE_IN_PROGRESS" => MemberAccountRuleStatus::CreateInProgress,
            "CREATE_SUCCESSFUL" => MemberAccountRuleStatus::CreateSuccessful,
            "DELETE_FAILED" => MemberAccountRuleStatus::DeleteFailed,
            "DELETE_IN_PROGRESS" => MemberAccountRuleStatus::DeleteInProgress,
            "DELETE_SUCCESSFUL" => MemberAccountRuleStatus::DeleteSuccessful,
            "UPDATE_FAILED" => MemberAccountRuleStatus::UpdateFailed,
            "UPDATE_IN_PROGRESS" => MemberAccountRuleStatus::UpdateInProgress,
            "UPDATE_SUCCESSFUL" => MemberAccountRuleStatus::UpdateSuccessful,
            other => MemberAccountRuleStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for MemberAccountRuleStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MemberAccountRuleStatus::from(s))
    }
}
impl MemberAccountRuleStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MemberAccountRuleStatus::CreateFailed => "CREATE_FAILED",
            MemberAccountRuleStatus::CreateInProgress => "CREATE_IN_PROGRESS",
            MemberAccountRuleStatus::CreateSuccessful => "CREATE_SUCCESSFUL",
            MemberAccountRuleStatus::DeleteFailed => "DELETE_FAILED",
            MemberAccountRuleStatus::DeleteInProgress => "DELETE_IN_PROGRESS",
            MemberAccountRuleStatus::DeleteSuccessful => "DELETE_SUCCESSFUL",
            MemberAccountRuleStatus::UpdateFailed => "UPDATE_FAILED",
            MemberAccountRuleStatus::UpdateInProgress => "UPDATE_IN_PROGRESS",
            MemberAccountRuleStatus::UpdateSuccessful => "UPDATE_SUCCESSFUL",
            MemberAccountRuleStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CREATE_FAILED",
            "CREATE_IN_PROGRESS",
            "CREATE_SUCCESSFUL",
            "DELETE_FAILED",
            "DELETE_IN_PROGRESS",
            "DELETE_SUCCESSFUL",
            "UPDATE_FAILED",
            "UPDATE_IN_PROGRESS",
            "UPDATE_SUCCESSFUL",
        ]
    }
}
impl AsRef<str> for MemberAccountRuleStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Status filter object to filter results based on specific member account ID or status type for an organization Config rule. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StatusDetailFilters {
    /// <p>The 12-digit account ID of the member account within an organization.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>Indicates deployment status for Config rule in the member account. When management account calls <code>PutOrganizationConfigRule</code> action for the first time, Config rule status is created in the member account. When management account calls <code>PutOrganizationConfigRule</code> action for the second time, Config rule status is updated in the member account. Config rule status is deleted when the management account deletes <code>OrganizationConfigRule</code> and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>. </p>
    /// <p>Config sets the state of the rule to:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_SUCCESSFUL</code> when Config rule has been created in the member account.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> when Config rule is being created in the member account.</p> </li>
    /// <li> <p> <code>CREATE_FAILED</code> when Config rule creation has failed in the member account.</p> </li>
    /// <li> <p> <code>DELETE_FAILED</code> when Config rule deletion has failed in the member account.</p> </li>
    /// <li> <p> <code>DELETE_IN_PROGRESS</code> when Config rule is being deleted in the member account.</p> </li>
    /// <li> <p> <code>DELETE_SUCCESSFUL</code> when Config rule has been deleted in the member account.</p> </li>
    /// <li> <p> <code>UPDATE_SUCCESSFUL</code> when Config rule has been updated in the member account.</p> </li>
    /// <li> <p> <code>UPDATE_IN_PROGRESS</code> when Config rule is being updated in the member account.</p> </li>
    /// <li> <p> <code>UPDATE_FAILED</code> when Config rule deletion has failed in the member account.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub member_account_rule_status: std::option::Option<crate::model::MemberAccountRuleStatus>,
}
impl StatusDetailFilters {
    /// <p>The 12-digit account ID of the member account within an organization.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>Indicates deployment status for Config rule in the member account. When management account calls <code>PutOrganizationConfigRule</code> action for the first time, Config rule status is created in the member account. When management account calls <code>PutOrganizationConfigRule</code> action for the second time, Config rule status is updated in the member account. Config rule status is deleted when the management account deletes <code>OrganizationConfigRule</code> and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>. </p>
    /// <p>Config sets the state of the rule to:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_SUCCESSFUL</code> when Config rule has been created in the member account.</p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> when Config rule is being created in the member account.</p> </li>
    /// <li> <p> <code>CREATE_FAILED</code> when Config rule creation has failed in the member account.</p> </li>
    /// <li> <p> <code>DELETE_FAILED</code> when Config rule deletion has failed in the member account.</p> </li>
    /// <li> <p> <code>DELETE_IN_PROGRESS</code> when Config rule is being deleted in the member account.</p> </li>
    /// <li> <p> <code>DELETE_SUCCESSFUL</code> when Config rule has been deleted in the member account.</p> </li>
    /// <li> <p> <code>UPDATE_SUCCESSFUL</code> when Config rule has been updated in the member account.</p> </li>
    /// <li> <p> <code>UPDATE_IN_PROGRESS</code> when Config rule is being updated in the member account.</p> </li>
    /// <li> <p> <code>UPDATE_FAILED</code> when Config rule deletion has failed in the member account.</p> </li>
    /// </ul>
    pub fn member_account_rule_status(
        &self,
    ) -> std::option::Option<&crate::model::MemberAccountRuleStatus> {
        self.member_account_rule_status.as_ref()
    }
}
impl StatusDetailFilters {
    /// Creates a new builder-style object to manufacture [`StatusDetailFilters`](crate::model::StatusDetailFilters).
    pub fn builder() -> crate::model::status_detail_filters::Builder {
        crate::model::status_detail_filters::Builder::default()
    }
}

/// See [`StatusDetailFilters`](crate::model::StatusDetailFilters).
pub mod status_detail_filters {

    /// A builder for [`StatusDetailFilters`](crate::model::StatusDetailFilters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) member_account_rule_status:
            std::option::Option<crate::model::MemberAccountRuleStatus>,
    }
    impl Builder {
        /// <p>The 12-digit account ID of the member account within an organization.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The 12-digit account ID of the member account within an organization.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>Indicates deployment status for Config rule in the member account. When management account calls <code>PutOrganizationConfigRule</code> action for the first time, Config rule status is created in the member account. When management account calls <code>PutOrganizationConfigRule</code> action for the second time, Config rule status is updated in the member account. Config rule status is deleted when the management account deletes <code>OrganizationConfigRule</code> and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>. </p>
        /// <p>Config sets the state of the rule to:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_SUCCESSFUL</code> when Config rule has been created in the member account.</p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> when Config rule is being created in the member account.</p> </li>
        /// <li> <p> <code>CREATE_FAILED</code> when Config rule creation has failed in the member account.</p> </li>
        /// <li> <p> <code>DELETE_FAILED</code> when Config rule deletion has failed in the member account.</p> </li>
        /// <li> <p> <code>DELETE_IN_PROGRESS</code> when Config rule is being deleted in the member account.</p> </li>
        /// <li> <p> <code>DELETE_SUCCESSFUL</code> when Config rule has been deleted in the member account.</p> </li>
        /// <li> <p> <code>UPDATE_SUCCESSFUL</code> when Config rule has been updated in the member account.</p> </li>
        /// <li> <p> <code>UPDATE_IN_PROGRESS</code> when Config rule is being updated in the member account.</p> </li>
        /// <li> <p> <code>UPDATE_FAILED</code> when Config rule deletion has failed in the member account.</p> </li>
        /// </ul>
        pub fn member_account_rule_status(
            mut self,
            input: crate::model::MemberAccountRuleStatus,
        ) -> Self {
            self.member_account_rule_status = Some(input);
            self
        }
        /// <p>Indicates deployment status for Config rule in the member account. When management account calls <code>PutOrganizationConfigRule</code> action for the first time, Config rule status is created in the member account. When management account calls <code>PutOrganizationConfigRule</code> action for the second time, Config rule status is updated in the member account. Config rule status is deleted when the management account deletes <code>OrganizationConfigRule</code> and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>. </p>
        /// <p>Config sets the state of the rule to:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_SUCCESSFUL</code> when Config rule has been created in the member account.</p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> when Config rule is being created in the member account.</p> </li>
        /// <li> <p> <code>CREATE_FAILED</code> when Config rule creation has failed in the member account.</p> </li>
        /// <li> <p> <code>DELETE_FAILED</code> when Config rule deletion has failed in the member account.</p> </li>
        /// <li> <p> <code>DELETE_IN_PROGRESS</code> when Config rule is being deleted in the member account.</p> </li>
        /// <li> <p> <code>DELETE_SUCCESSFUL</code> when Config rule has been deleted in the member account.</p> </li>
        /// <li> <p> <code>UPDATE_SUCCESSFUL</code> when Config rule has been updated in the member account.</p> </li>
        /// <li> <p> <code>UPDATE_IN_PROGRESS</code> when Config rule is being updated in the member account.</p> </li>
        /// <li> <p> <code>UPDATE_FAILED</code> when Config rule deletion has failed in the member account.</p> </li>
        /// </ul>
        pub fn set_member_account_rule_status(
            mut self,
            input: std::option::Option<crate::model::MemberAccountRuleStatus>,
        ) -> Self {
            self.member_account_rule_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StatusDetailFilters`](crate::model::StatusDetailFilters).
        pub fn build(self) -> crate::model::StatusDetailFilters {
            crate::model::StatusDetailFilters {
                account_id: self.account_id,
                member_account_rule_status: self.member_account_rule_status,
            }
        }
    }
}

/// <p>An object that contains the resource type and the number of resources.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceCount {
    /// <p>The resource type (for example, <code>"AWS::EC2::Instance"</code>).</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>The number of resources.</p>
    #[doc(hidden)]
    pub count: i64,
}
impl ResourceCount {
    /// <p>The resource type (for example, <code>"AWS::EC2::Instance"</code>).</p>
    pub fn resource_type(&self) -> std::option::Option<&crate::model::ResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>The number of resources.</p>
    pub fn count(&self) -> i64 {
        self.count
    }
}
impl ResourceCount {
    /// Creates a new builder-style object to manufacture [`ResourceCount`](crate::model::ResourceCount).
    pub fn builder() -> crate::model::resource_count::Builder {
        crate::model::resource_count::Builder::default()
    }
}

/// See [`ResourceCount`](crate::model::ResourceCount).
pub mod resource_count {

    /// A builder for [`ResourceCount`](crate::model::ResourceCount).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) count: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The resource type (for example, <code>"AWS::EC2::Instance"</code>).</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>The resource type (for example, <code>"AWS::EC2::Instance"</code>).</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The number of resources.</p>
        pub fn count(mut self, input: i64) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>The number of resources.</p>
        pub fn set_count(mut self, input: std::option::Option<i64>) -> Self {
            self.count = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceCount`](crate::model::ResourceCount).
        pub fn build(self) -> crate::model::ResourceCount {
            crate::model::ResourceCount {
                resource_type: self.resource_type,
                count: self.count.unwrap_or_default(),
            }
        }
    }
}

/// <p>Summary includes the name and status of the conformance pack.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConformancePackComplianceSummary {
    /// <p>The name of the conformance pack name.</p>
    #[doc(hidden)]
    pub conformance_pack_name: std::option::Option<std::string::String>,
    /// <p>The status of the conformance pack. The allowed values are <code>COMPLIANT</code>, <code>NON_COMPLIANT</code> and <code>INSUFFICIENT_DATA</code>.</p>
    #[doc(hidden)]
    pub conformance_pack_compliance_status:
        std::option::Option<crate::model::ConformancePackComplianceType>,
}
impl ConformancePackComplianceSummary {
    /// <p>The name of the conformance pack name.</p>
    pub fn conformance_pack_name(&self) -> std::option::Option<&str> {
        self.conformance_pack_name.as_deref()
    }
    /// <p>The status of the conformance pack. The allowed values are <code>COMPLIANT</code>, <code>NON_COMPLIANT</code> and <code>INSUFFICIENT_DATA</code>.</p>
    pub fn conformance_pack_compliance_status(
        &self,
    ) -> std::option::Option<&crate::model::ConformancePackComplianceType> {
        self.conformance_pack_compliance_status.as_ref()
    }
}
impl ConformancePackComplianceSummary {
    /// Creates a new builder-style object to manufacture [`ConformancePackComplianceSummary`](crate::model::ConformancePackComplianceSummary).
    pub fn builder() -> crate::model::conformance_pack_compliance_summary::Builder {
        crate::model::conformance_pack_compliance_summary::Builder::default()
    }
}

/// See [`ConformancePackComplianceSummary`](crate::model::ConformancePackComplianceSummary).
pub mod conformance_pack_compliance_summary {

    /// A builder for [`ConformancePackComplianceSummary`](crate::model::ConformancePackComplianceSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) conformance_pack_name: std::option::Option<std::string::String>,
        pub(crate) conformance_pack_compliance_status:
            std::option::Option<crate::model::ConformancePackComplianceType>,
    }
    impl Builder {
        /// <p>The name of the conformance pack name.</p>
        pub fn conformance_pack_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.conformance_pack_name = Some(input.into());
            self
        }
        /// <p>The name of the conformance pack name.</p>
        pub fn set_conformance_pack_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.conformance_pack_name = input;
            self
        }
        /// <p>The status of the conformance pack. The allowed values are <code>COMPLIANT</code>, <code>NON_COMPLIANT</code> and <code>INSUFFICIENT_DATA</code>.</p>
        pub fn conformance_pack_compliance_status(
            mut self,
            input: crate::model::ConformancePackComplianceType,
        ) -> Self {
            self.conformance_pack_compliance_status = Some(input);
            self
        }
        /// <p>The status of the conformance pack. The allowed values are <code>COMPLIANT</code>, <code>NON_COMPLIANT</code> and <code>INSUFFICIENT_DATA</code>.</p>
        pub fn set_conformance_pack_compliance_status(
            mut self,
            input: std::option::Option<crate::model::ConformancePackComplianceType>,
        ) -> Self {
            self.conformance_pack_compliance_status = input;
            self
        }
        /// Consumes the builder and constructs a [`ConformancePackComplianceSummary`](crate::model::ConformancePackComplianceSummary).
        pub fn build(self) -> crate::model::ConformancePackComplianceSummary {
            crate::model::ConformancePackComplianceSummary {
                conformance_pack_name: self.conformance_pack_name,
                conformance_pack_compliance_status: self.conformance_pack_compliance_status,
            }
        }
    }
}

/// When writing a match expression against `ConformancePackComplianceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let conformancepackcompliancetype = unimplemented!();
/// match conformancepackcompliancetype {
///     ConformancePackComplianceType::Compliant => { /* ... */ },
///     ConformancePackComplianceType::InsufficientData => { /* ... */ },
///     ConformancePackComplianceType::NonCompliant => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `conformancepackcompliancetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConformancePackComplianceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConformancePackComplianceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConformancePackComplianceType::NewFeature` is defined.
/// Specifically, when `conformancepackcompliancetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConformancePackComplianceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConformancePackComplianceType {
    #[allow(missing_docs)] // documentation missing in model
    Compliant,
    #[allow(missing_docs)] // documentation missing in model
    InsufficientData,
    #[allow(missing_docs)] // documentation missing in model
    NonCompliant,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConformancePackComplianceType {
    fn from(s: &str) -> Self {
        match s {
            "COMPLIANT" => ConformancePackComplianceType::Compliant,
            "INSUFFICIENT_DATA" => ConformancePackComplianceType::InsufficientData,
            "NON_COMPLIANT" => ConformancePackComplianceType::NonCompliant,
            other => ConformancePackComplianceType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ConformancePackComplianceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConformancePackComplianceType::from(s))
    }
}
impl ConformancePackComplianceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConformancePackComplianceType::Compliant => "COMPLIANT",
            ConformancePackComplianceType::InsufficientData => "INSUFFICIENT_DATA",
            ConformancePackComplianceType::NonCompliant => "NON_COMPLIANT",
            ConformancePackComplianceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COMPLIANT", "INSUFFICIENT_DATA", "NON_COMPLIANT"]
    }
}
impl AsRef<str> for ConformancePackComplianceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The details of a conformance pack evaluation. Provides Config rule and Amazon Web Services resource type that was evaluated, the compliance of the conformance pack, related time stamps, and supplementary information. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConformancePackEvaluationResult {
    /// <p>The compliance type. The allowed values are <code>COMPLIANT</code> and <code>NON_COMPLIANT</code>. <code>INSUFFICIENT_DATA</code> is not supported.</p>
    #[doc(hidden)]
    pub compliance_type: std::option::Option<crate::model::ConformancePackComplianceType>,
    /// <p>Uniquely identifies an evaluation result.</p>
    #[doc(hidden)]
    pub evaluation_result_identifier: std::option::Option<crate::model::EvaluationResultIdentifier>,
    /// <p>The time when Config rule evaluated Amazon Web Services resource.</p>
    #[doc(hidden)]
    pub config_rule_invoked_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time when Config recorded the evaluation result. </p>
    #[doc(hidden)]
    pub result_recorded_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Supplementary information about how the evaluation determined the compliance. </p>
    #[doc(hidden)]
    pub annotation: std::option::Option<std::string::String>,
}
impl ConformancePackEvaluationResult {
    /// <p>The compliance type. The allowed values are <code>COMPLIANT</code> and <code>NON_COMPLIANT</code>. <code>INSUFFICIENT_DATA</code> is not supported.</p>
    pub fn compliance_type(
        &self,
    ) -> std::option::Option<&crate::model::ConformancePackComplianceType> {
        self.compliance_type.as_ref()
    }
    /// <p>Uniquely identifies an evaluation result.</p>
    pub fn evaluation_result_identifier(
        &self,
    ) -> std::option::Option<&crate::model::EvaluationResultIdentifier> {
        self.evaluation_result_identifier.as_ref()
    }
    /// <p>The time when Config rule evaluated Amazon Web Services resource.</p>
    pub fn config_rule_invoked_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.config_rule_invoked_time.as_ref()
    }
    /// <p>The time when Config recorded the evaluation result. </p>
    pub fn result_recorded_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.result_recorded_time.as_ref()
    }
    /// <p>Supplementary information about how the evaluation determined the compliance. </p>
    pub fn annotation(&self) -> std::option::Option<&str> {
        self.annotation.as_deref()
    }
}
impl ConformancePackEvaluationResult {
    /// Creates a new builder-style object to manufacture [`ConformancePackEvaluationResult`](crate::model::ConformancePackEvaluationResult).
    pub fn builder() -> crate::model::conformance_pack_evaluation_result::Builder {
        crate::model::conformance_pack_evaluation_result::Builder::default()
    }
}

/// See [`ConformancePackEvaluationResult`](crate::model::ConformancePackEvaluationResult).
pub mod conformance_pack_evaluation_result {

    /// A builder for [`ConformancePackEvaluationResult`](crate::model::ConformancePackEvaluationResult).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) compliance_type:
            std::option::Option<crate::model::ConformancePackComplianceType>,
        pub(crate) evaluation_result_identifier:
            std::option::Option<crate::model::EvaluationResultIdentifier>,
        pub(crate) config_rule_invoked_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) result_recorded_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) annotation: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The compliance type. The allowed values are <code>COMPLIANT</code> and <code>NON_COMPLIANT</code>. <code>INSUFFICIENT_DATA</code> is not supported.</p>
        pub fn compliance_type(
            mut self,
            input: crate::model::ConformancePackComplianceType,
        ) -> Self {
            self.compliance_type = Some(input);
            self
        }
        /// <p>The compliance type. The allowed values are <code>COMPLIANT</code> and <code>NON_COMPLIANT</code>. <code>INSUFFICIENT_DATA</code> is not supported.</p>
        pub fn set_compliance_type(
            mut self,
            input: std::option::Option<crate::model::ConformancePackComplianceType>,
        ) -> Self {
            self.compliance_type = input;
            self
        }
        /// <p>Uniquely identifies an evaluation result.</p>
        pub fn evaluation_result_identifier(
            mut self,
            input: crate::model::EvaluationResultIdentifier,
        ) -> Self {
            self.evaluation_result_identifier = Some(input);
            self
        }
        /// <p>Uniquely identifies an evaluation result.</p>
        pub fn set_evaluation_result_identifier(
            mut self,
            input: std::option::Option<crate::model::EvaluationResultIdentifier>,
        ) -> Self {
            self.evaluation_result_identifier = input;
            self
        }
        /// <p>The time when Config rule evaluated Amazon Web Services resource.</p>
        pub fn config_rule_invoked_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.config_rule_invoked_time = Some(input);
            self
        }
        /// <p>The time when Config rule evaluated Amazon Web Services resource.</p>
        pub fn set_config_rule_invoked_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.config_rule_invoked_time = input;
            self
        }
        /// <p>The time when Config recorded the evaluation result. </p>
        pub fn result_recorded_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.result_recorded_time = Some(input);
            self
        }
        /// <p>The time when Config recorded the evaluation result. </p>
        pub fn set_result_recorded_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.result_recorded_time = input;
            self
        }
        /// <p>Supplementary information about how the evaluation determined the compliance. </p>
        pub fn annotation(mut self, input: impl Into<std::string::String>) -> Self {
            self.annotation = Some(input.into());
            self
        }
        /// <p>Supplementary information about how the evaluation determined the compliance. </p>
        pub fn set_annotation(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.annotation = input;
            self
        }
        /// Consumes the builder and constructs a [`ConformancePackEvaluationResult`](crate::model::ConformancePackEvaluationResult).
        pub fn build(self) -> crate::model::ConformancePackEvaluationResult {
            crate::model::ConformancePackEvaluationResult {
                compliance_type: self.compliance_type,
                evaluation_result_identifier: self.evaluation_result_identifier,
                config_rule_invoked_time: self.config_rule_invoked_time,
                result_recorded_time: self.result_recorded_time,
                annotation: self.annotation,
            }
        }
    }
}

/// <p>Uniquely identifies an evaluation result.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EvaluationResultIdentifier {
    /// <p>Identifies an Config rule used to evaluate an Amazon Web Services resource, and provides the type and ID of the evaluated resource.</p>
    #[doc(hidden)]
    pub evaluation_result_qualifier: std::option::Option<crate::model::EvaluationResultQualifier>,
    /// <p>The time of the event that triggered the evaluation of your Amazon Web Services resources. The time can indicate when Config delivered a configuration item change notification, or it can indicate when Config delivered the configuration snapshot, depending on which event triggered the evaluation.</p>
    #[doc(hidden)]
    pub ordering_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A Unique ID for an evaluation result.</p>
    #[doc(hidden)]
    pub resource_evaluation_id: std::option::Option<std::string::String>,
}
impl EvaluationResultIdentifier {
    /// <p>Identifies an Config rule used to evaluate an Amazon Web Services resource, and provides the type and ID of the evaluated resource.</p>
    pub fn evaluation_result_qualifier(
        &self,
    ) -> std::option::Option<&crate::model::EvaluationResultQualifier> {
        self.evaluation_result_qualifier.as_ref()
    }
    /// <p>The time of the event that triggered the evaluation of your Amazon Web Services resources. The time can indicate when Config delivered a configuration item change notification, or it can indicate when Config delivered the configuration snapshot, depending on which event triggered the evaluation.</p>
    pub fn ordering_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.ordering_timestamp.as_ref()
    }
    /// <p>A Unique ID for an evaluation result.</p>
    pub fn resource_evaluation_id(&self) -> std::option::Option<&str> {
        self.resource_evaluation_id.as_deref()
    }
}
impl EvaluationResultIdentifier {
    /// Creates a new builder-style object to manufacture [`EvaluationResultIdentifier`](crate::model::EvaluationResultIdentifier).
    pub fn builder() -> crate::model::evaluation_result_identifier::Builder {
        crate::model::evaluation_result_identifier::Builder::default()
    }
}

/// See [`EvaluationResultIdentifier`](crate::model::EvaluationResultIdentifier).
pub mod evaluation_result_identifier {

    /// A builder for [`EvaluationResultIdentifier`](crate::model::EvaluationResultIdentifier).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) evaluation_result_qualifier:
            std::option::Option<crate::model::EvaluationResultQualifier>,
        pub(crate) ordering_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) resource_evaluation_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Identifies an Config rule used to evaluate an Amazon Web Services resource, and provides the type and ID of the evaluated resource.</p>
        pub fn evaluation_result_qualifier(
            mut self,
            input: crate::model::EvaluationResultQualifier,
        ) -> Self {
            self.evaluation_result_qualifier = Some(input);
            self
        }
        /// <p>Identifies an Config rule used to evaluate an Amazon Web Services resource, and provides the type and ID of the evaluated resource.</p>
        pub fn set_evaluation_result_qualifier(
            mut self,
            input: std::option::Option<crate::model::EvaluationResultQualifier>,
        ) -> Self {
            self.evaluation_result_qualifier = input;
            self
        }
        /// <p>The time of the event that triggered the evaluation of your Amazon Web Services resources. The time can indicate when Config delivered a configuration item change notification, or it can indicate when Config delivered the configuration snapshot, depending on which event triggered the evaluation.</p>
        pub fn ordering_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.ordering_timestamp = Some(input);
            self
        }
        /// <p>The time of the event that triggered the evaluation of your Amazon Web Services resources. The time can indicate when Config delivered a configuration item change notification, or it can indicate when Config delivered the configuration snapshot, depending on which event triggered the evaluation.</p>
        pub fn set_ordering_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.ordering_timestamp = input;
            self
        }
        /// <p>A Unique ID for an evaluation result.</p>
        pub fn resource_evaluation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_evaluation_id = Some(input.into());
            self
        }
        /// <p>A Unique ID for an evaluation result.</p>
        pub fn set_resource_evaluation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_evaluation_id = input;
            self
        }
        /// Consumes the builder and constructs a [`EvaluationResultIdentifier`](crate::model::EvaluationResultIdentifier).
        pub fn build(self) -> crate::model::EvaluationResultIdentifier {
            crate::model::EvaluationResultIdentifier {
                evaluation_result_qualifier: self.evaluation_result_qualifier,
                ordering_timestamp: self.ordering_timestamp,
                resource_evaluation_id: self.resource_evaluation_id,
            }
        }
    }
}

/// <p>Identifies an Config rule that evaluated an Amazon Web Services resource, and provides the type and ID of the resource that the rule evaluated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EvaluationResultQualifier {
    /// <p>The name of the Config rule that was used in the evaluation.</p>
    #[doc(hidden)]
    pub config_rule_name: std::option::Option<std::string::String>,
    /// <p>The type of Amazon Web Services resource that was evaluated.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The ID of the evaluated Amazon Web Services resource.</p>
    #[doc(hidden)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The mode of an evaluation. The valid values are Detective or Proactive.</p>
    #[doc(hidden)]
    pub evaluation_mode: std::option::Option<crate::model::EvaluationMode>,
}
impl EvaluationResultQualifier {
    /// <p>The name of the Config rule that was used in the evaluation.</p>
    pub fn config_rule_name(&self) -> std::option::Option<&str> {
        self.config_rule_name.as_deref()
    }
    /// <p>The type of Amazon Web Services resource that was evaluated.</p>
    pub fn resource_type(&self) -> std::option::Option<&str> {
        self.resource_type.as_deref()
    }
    /// <p>The ID of the evaluated Amazon Web Services resource.</p>
    pub fn resource_id(&self) -> std::option::Option<&str> {
        self.resource_id.as_deref()
    }
    /// <p>The mode of an evaluation. The valid values are Detective or Proactive.</p>
    pub fn evaluation_mode(&self) -> std::option::Option<&crate::model::EvaluationMode> {
        self.evaluation_mode.as_ref()
    }
}
impl EvaluationResultQualifier {
    /// Creates a new builder-style object to manufacture [`EvaluationResultQualifier`](crate::model::EvaluationResultQualifier).
    pub fn builder() -> crate::model::evaluation_result_qualifier::Builder {
        crate::model::evaluation_result_qualifier::Builder::default()
    }
}

/// See [`EvaluationResultQualifier`](crate::model::EvaluationResultQualifier).
pub mod evaluation_result_qualifier {

    /// A builder for [`EvaluationResultQualifier`](crate::model::EvaluationResultQualifier).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) config_rule_name: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) evaluation_mode: std::option::Option<crate::model::EvaluationMode>,
    }
    impl Builder {
        /// <p>The name of the Config rule that was used in the evaluation.</p>
        pub fn config_rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.config_rule_name = Some(input.into());
            self
        }
        /// <p>The name of the Config rule that was used in the evaluation.</p>
        pub fn set_config_rule_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.config_rule_name = input;
            self
        }
        /// <p>The type of Amazon Web Services resource that was evaluated.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The type of Amazon Web Services resource that was evaluated.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The ID of the evaluated Amazon Web Services resource.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The ID of the evaluated Amazon Web Services resource.</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The mode of an evaluation. The valid values are Detective or Proactive.</p>
        pub fn evaluation_mode(mut self, input: crate::model::EvaluationMode) -> Self {
            self.evaluation_mode = Some(input);
            self
        }
        /// <p>The mode of an evaluation. The valid values are Detective or Proactive.</p>
        pub fn set_evaluation_mode(
            mut self,
            input: std::option::Option<crate::model::EvaluationMode>,
        ) -> Self {
            self.evaluation_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`EvaluationResultQualifier`](crate::model::EvaluationResultQualifier).
        pub fn build(self) -> crate::model::EvaluationResultQualifier {
            crate::model::EvaluationResultQualifier {
                config_rule_name: self.config_rule_name,
                resource_type: self.resource_type,
                resource_id: self.resource_id,
                evaluation_mode: self.evaluation_mode,
            }
        }
    }
}

/// <p>Filters a conformance pack by Config rule names, compliance types, Amazon Web Services resource types, and resource IDs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConformancePackEvaluationFilters {
    /// <p>Filters the results by Config rule names.</p>
    #[doc(hidden)]
    pub config_rule_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Filters the results by compliance.</p>
    /// <p>The allowed values are <code>COMPLIANT</code> and <code>NON_COMPLIANT</code>. <code>INSUFFICIENT_DATA</code> is not supported.</p>
    #[doc(hidden)]
    pub compliance_type: std::option::Option<crate::model::ConformancePackComplianceType>,
    /// <p>Filters the results by the resource type (for example, <code>"AWS::EC2::Instance"</code>). </p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>Filters the results by resource IDs.</p> <note>
    /// <p>This is valid only when you provide resource type. If there is no resource type, you will see an error.</p>
    /// </note>
    #[doc(hidden)]
    pub resource_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ConformancePackEvaluationFilters {
    /// <p>Filters the results by Config rule names.</p>
    pub fn config_rule_names(&self) -> std::option::Option<&[std::string::String]> {
        self.config_rule_names.as_deref()
    }
    /// <p>Filters the results by compliance.</p>
    /// <p>The allowed values are <code>COMPLIANT</code> and <code>NON_COMPLIANT</code>. <code>INSUFFICIENT_DATA</code> is not supported.</p>
    pub fn compliance_type(
        &self,
    ) -> std::option::Option<&crate::model::ConformancePackComplianceType> {
        self.compliance_type.as_ref()
    }
    /// <p>Filters the results by the resource type (for example, <code>"AWS::EC2::Instance"</code>). </p>
    pub fn resource_type(&self) -> std::option::Option<&str> {
        self.resource_type.as_deref()
    }
    /// <p>Filters the results by resource IDs.</p> <note>
    /// <p>This is valid only when you provide resource type. If there is no resource type, you will see an error.</p>
    /// </note>
    pub fn resource_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.resource_ids.as_deref()
    }
}
impl ConformancePackEvaluationFilters {
    /// Creates a new builder-style object to manufacture [`ConformancePackEvaluationFilters`](crate::model::ConformancePackEvaluationFilters).
    pub fn builder() -> crate::model::conformance_pack_evaluation_filters::Builder {
        crate::model::conformance_pack_evaluation_filters::Builder::default()
    }
}

/// See [`ConformancePackEvaluationFilters`](crate::model::ConformancePackEvaluationFilters).
pub mod conformance_pack_evaluation_filters {

    /// A builder for [`ConformancePackEvaluationFilters`](crate::model::ConformancePackEvaluationFilters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) config_rule_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) compliance_type:
            std::option::Option<crate::model::ConformancePackComplianceType>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) resource_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `config_rule_names`.
        ///
        /// To override the contents of this collection use [`set_config_rule_names`](Self::set_config_rule_names).
        ///
        /// <p>Filters the results by Config rule names.</p>
        pub fn config_rule_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.config_rule_names.unwrap_or_default();
            v.push(input.into());
            self.config_rule_names = Some(v);
            self
        }
        /// <p>Filters the results by Config rule names.</p>
        pub fn set_config_rule_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.config_rule_names = input;
            self
        }
        /// <p>Filters the results by compliance.</p>
        /// <p>The allowed values are <code>COMPLIANT</code> and <code>NON_COMPLIANT</code>. <code>INSUFFICIENT_DATA</code> is not supported.</p>
        pub fn compliance_type(
            mut self,
            input: crate::model::ConformancePackComplianceType,
        ) -> Self {
            self.compliance_type = Some(input);
            self
        }
        /// <p>Filters the results by compliance.</p>
        /// <p>The allowed values are <code>COMPLIANT</code> and <code>NON_COMPLIANT</code>. <code>INSUFFICIENT_DATA</code> is not supported.</p>
        pub fn set_compliance_type(
            mut self,
            input: std::option::Option<crate::model::ConformancePackComplianceType>,
        ) -> Self {
            self.compliance_type = input;
            self
        }
        /// <p>Filters the results by the resource type (for example, <code>"AWS::EC2::Instance"</code>). </p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>Filters the results by the resource type (for example, <code>"AWS::EC2::Instance"</code>). </p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Appends an item to `resource_ids`.
        ///
        /// To override the contents of this collection use [`set_resource_ids`](Self::set_resource_ids).
        ///
        /// <p>Filters the results by resource IDs.</p> <note>
        /// <p>This is valid only when you provide resource type. If there is no resource type, you will see an error.</p>
        /// </note>
        pub fn resource_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.resource_ids.unwrap_or_default();
            v.push(input.into());
            self.resource_ids = Some(v);
            self
        }
        /// <p>Filters the results by resource IDs.</p> <note>
        /// <p>This is valid only when you provide resource type. If there is no resource type, you will see an error.</p>
        /// </note>
        pub fn set_resource_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.resource_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`ConformancePackEvaluationFilters`](crate::model::ConformancePackEvaluationFilters).
        pub fn build(self) -> crate::model::ConformancePackEvaluationFilters {
            crate::model::ConformancePackEvaluationFilters {
                config_rule_names: self.config_rule_names,
                compliance_type: self.compliance_type,
                resource_type: self.resource_type,
                resource_ids: self.resource_ids,
            }
        }
    }
}

/// <p>The number of Amazon Web Services resources of a specific type that are compliant or noncompliant, up to a maximum of 100 for each.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComplianceSummaryByResourceType {
    /// <p>The type of Amazon Web Services resource.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The number of Amazon Web Services resources that are compliant or noncompliant, up to a maximum of 100 for each.</p>
    #[doc(hidden)]
    pub compliance_summary: std::option::Option<crate::model::ComplianceSummary>,
}
impl ComplianceSummaryByResourceType {
    /// <p>The type of Amazon Web Services resource.</p>
    pub fn resource_type(&self) -> std::option::Option<&str> {
        self.resource_type.as_deref()
    }
    /// <p>The number of Amazon Web Services resources that are compliant or noncompliant, up to a maximum of 100 for each.</p>
    pub fn compliance_summary(&self) -> std::option::Option<&crate::model::ComplianceSummary> {
        self.compliance_summary.as_ref()
    }
}
impl ComplianceSummaryByResourceType {
    /// Creates a new builder-style object to manufacture [`ComplianceSummaryByResourceType`](crate::model::ComplianceSummaryByResourceType).
    pub fn builder() -> crate::model::compliance_summary_by_resource_type::Builder {
        crate::model::compliance_summary_by_resource_type::Builder::default()
    }
}

/// See [`ComplianceSummaryByResourceType`](crate::model::ComplianceSummaryByResourceType).
pub mod compliance_summary_by_resource_type {

    /// A builder for [`ComplianceSummaryByResourceType`](crate::model::ComplianceSummaryByResourceType).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) compliance_summary: std::option::Option<crate::model::ComplianceSummary>,
    }
    impl Builder {
        /// <p>The type of Amazon Web Services resource.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The type of Amazon Web Services resource.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The number of Amazon Web Services resources that are compliant or noncompliant, up to a maximum of 100 for each.</p>
        pub fn compliance_summary(mut self, input: crate::model::ComplianceSummary) -> Self {
            self.compliance_summary = Some(input);
            self
        }
        /// <p>The number of Amazon Web Services resources that are compliant or noncompliant, up to a maximum of 100 for each.</p>
        pub fn set_compliance_summary(
            mut self,
            input: std::option::Option<crate::model::ComplianceSummary>,
        ) -> Self {
            self.compliance_summary = input;
            self
        }
        /// Consumes the builder and constructs a [`ComplianceSummaryByResourceType`](crate::model::ComplianceSummaryByResourceType).
        pub fn build(self) -> crate::model::ComplianceSummaryByResourceType {
            crate::model::ComplianceSummaryByResourceType {
                resource_type: self.resource_type,
                compliance_summary: self.compliance_summary,
            }
        }
    }
}

/// <p>The number of Config rules or Amazon Web Services resources that are compliant and noncompliant.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComplianceSummary {
    /// <p>The number of Config rules or Amazon Web Services resources that are compliant, up to a maximum of 25 for rules and 100 for resources.</p>
    #[doc(hidden)]
    pub compliant_resource_count: std::option::Option<crate::model::ComplianceContributorCount>,
    /// <p>The number of Config rules or Amazon Web Services resources that are noncompliant, up to a maximum of 25 for rules and 100 for resources.</p>
    #[doc(hidden)]
    pub non_compliant_resource_count: std::option::Option<crate::model::ComplianceContributorCount>,
    /// <p>The time that Config created the compliance summary.</p>
    #[doc(hidden)]
    pub compliance_summary_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl ComplianceSummary {
    /// <p>The number of Config rules or Amazon Web Services resources that are compliant, up to a maximum of 25 for rules and 100 for resources.</p>
    pub fn compliant_resource_count(
        &self,
    ) -> std::option::Option<&crate::model::ComplianceContributorCount> {
        self.compliant_resource_count.as_ref()
    }
    /// <p>The number of Config rules or Amazon Web Services resources that are noncompliant, up to a maximum of 25 for rules and 100 for resources.</p>
    pub fn non_compliant_resource_count(
        &self,
    ) -> std::option::Option<&crate::model::ComplianceContributorCount> {
        self.non_compliant_resource_count.as_ref()
    }
    /// <p>The time that Config created the compliance summary.</p>
    pub fn compliance_summary_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.compliance_summary_timestamp.as_ref()
    }
}
impl ComplianceSummary {
    /// Creates a new builder-style object to manufacture [`ComplianceSummary`](crate::model::ComplianceSummary).
    pub fn builder() -> crate::model::compliance_summary::Builder {
        crate::model::compliance_summary::Builder::default()
    }
}

/// See [`ComplianceSummary`](crate::model::ComplianceSummary).
pub mod compliance_summary {

    /// A builder for [`ComplianceSummary`](crate::model::ComplianceSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) compliant_resource_count:
            std::option::Option<crate::model::ComplianceContributorCount>,
        pub(crate) non_compliant_resource_count:
            std::option::Option<crate::model::ComplianceContributorCount>,
        pub(crate) compliance_summary_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The number of Config rules or Amazon Web Services resources that are compliant, up to a maximum of 25 for rules and 100 for resources.</p>
        pub fn compliant_resource_count(
            mut self,
            input: crate::model::ComplianceContributorCount,
        ) -> Self {
            self.compliant_resource_count = Some(input);
            self
        }
        /// <p>The number of Config rules or Amazon Web Services resources that are compliant, up to a maximum of 25 for rules and 100 for resources.</p>
        pub fn set_compliant_resource_count(
            mut self,
            input: std::option::Option<crate::model::ComplianceContributorCount>,
        ) -> Self {
            self.compliant_resource_count = input;
            self
        }
        /// <p>The number of Config rules or Amazon Web Services resources that are noncompliant, up to a maximum of 25 for rules and 100 for resources.</p>
        pub fn non_compliant_resource_count(
            mut self,
            input: crate::model::ComplianceContributorCount,
        ) -> Self {
            self.non_compliant_resource_count = Some(input);
            self
        }
        /// <p>The number of Config rules or Amazon Web Services resources that are noncompliant, up to a maximum of 25 for rules and 100 for resources.</p>
        pub fn set_non_compliant_resource_count(
            mut self,
            input: std::option::Option<crate::model::ComplianceContributorCount>,
        ) -> Self {
            self.non_compliant_resource_count = input;
            self
        }
        /// <p>The time that Config created the compliance summary.</p>
        pub fn compliance_summary_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.compliance_summary_timestamp = Some(input);
            self
        }
        /// <p>The time that Config created the compliance summary.</p>
        pub fn set_compliance_summary_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.compliance_summary_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`ComplianceSummary`](crate::model::ComplianceSummary).
        pub fn build(self) -> crate::model::ComplianceSummary {
            crate::model::ComplianceSummary {
                compliant_resource_count: self.compliant_resource_count,
                non_compliant_resource_count: self.non_compliant_resource_count,
                compliance_summary_timestamp: self.compliance_summary_timestamp,
            }
        }
    }
}

/// <p>The number of Amazon Web Services resources or Config rules responsible for the current compliance of the item, up to a maximum number.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComplianceContributorCount {
    /// <p>The number of Amazon Web Services resources or Config rules responsible for the current compliance of the item.</p>
    #[doc(hidden)]
    pub capped_count: i32,
    /// <p>Indicates whether the maximum count is reached.</p>
    #[doc(hidden)]
    pub cap_exceeded: bool,
}
impl ComplianceContributorCount {
    /// <p>The number of Amazon Web Services resources or Config rules responsible for the current compliance of the item.</p>
    pub fn capped_count(&self) -> i32 {
        self.capped_count
    }
    /// <p>Indicates whether the maximum count is reached.</p>
    pub fn cap_exceeded(&self) -> bool {
        self.cap_exceeded
    }
}
impl ComplianceContributorCount {
    /// Creates a new builder-style object to manufacture [`ComplianceContributorCount`](crate::model::ComplianceContributorCount).
    pub fn builder() -> crate::model::compliance_contributor_count::Builder {
        crate::model::compliance_contributor_count::Builder::default()
    }
}

/// See [`ComplianceContributorCount`](crate::model::ComplianceContributorCount).
pub mod compliance_contributor_count {

    /// A builder for [`ComplianceContributorCount`](crate::model::ComplianceContributorCount).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) capped_count: std::option::Option<i32>,
        pub(crate) cap_exceeded: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The number of Amazon Web Services resources or Config rules responsible for the current compliance of the item.</p>
        pub fn capped_count(mut self, input: i32) -> Self {
            self.capped_count = Some(input);
            self
        }
        /// <p>The number of Amazon Web Services resources or Config rules responsible for the current compliance of the item.</p>
        pub fn set_capped_count(mut self, input: std::option::Option<i32>) -> Self {
            self.capped_count = input;
            self
        }
        /// <p>Indicates whether the maximum count is reached.</p>
        pub fn cap_exceeded(mut self, input: bool) -> Self {
            self.cap_exceeded = Some(input);
            self
        }
        /// <p>Indicates whether the maximum count is reached.</p>
        pub fn set_cap_exceeded(mut self, input: std::option::Option<bool>) -> Self {
            self.cap_exceeded = input;
            self
        }
        /// Consumes the builder and constructs a [`ComplianceContributorCount`](crate::model::ComplianceContributorCount).
        pub fn build(self) -> crate::model::ComplianceContributorCount {
            crate::model::ComplianceContributorCount {
                capped_count: self.capped_count.unwrap_or_default(),
                cap_exceeded: self.cap_exceeded.unwrap_or_default(),
            }
        }
    }
}

/// <p>The details of an Config evaluation. Provides the Amazon Web Services resource that was evaluated, the compliance of the resource, related time stamps, and supplementary information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EvaluationResult {
    /// <p>Uniquely identifies the evaluation result.</p>
    #[doc(hidden)]
    pub evaluation_result_identifier: std::option::Option<crate::model::EvaluationResultIdentifier>,
    /// <p>Indicates whether the Amazon Web Services resource complies with the Config rule that evaluated it.</p>
    /// <p>For the <code>EvaluationResult</code> data type, Config supports only the <code>COMPLIANT</code>, <code>NON_COMPLIANT</code>, and <code>NOT_APPLICABLE</code> values. Config does not support the <code>INSUFFICIENT_DATA</code> value for the <code>EvaluationResult</code> data type.</p>
    #[doc(hidden)]
    pub compliance_type: std::option::Option<crate::model::ComplianceType>,
    /// <p>The time when Config recorded the evaluation result.</p>
    #[doc(hidden)]
    pub result_recorded_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time when the Config rule evaluated the Amazon Web Services resource.</p>
    #[doc(hidden)]
    pub config_rule_invoked_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Supplementary information about how the evaluation determined the compliance.</p>
    #[doc(hidden)]
    pub annotation: std::option::Option<std::string::String>,
    /// <p>An encrypted token that associates an evaluation with an Config rule. The token identifies the rule, the Amazon Web Services resource being evaluated, and the event that triggered the evaluation.</p>
    #[doc(hidden)]
    pub result_token: std::option::Option<std::string::String>,
}
impl EvaluationResult {
    /// <p>Uniquely identifies the evaluation result.</p>
    pub fn evaluation_result_identifier(
        &self,
    ) -> std::option::Option<&crate::model::EvaluationResultIdentifier> {
        self.evaluation_result_identifier.as_ref()
    }
    /// <p>Indicates whether the Amazon Web Services resource complies with the Config rule that evaluated it.</p>
    /// <p>For the <code>EvaluationResult</code> data type, Config supports only the <code>COMPLIANT</code>, <code>NON_COMPLIANT</code>, and <code>NOT_APPLICABLE</code> values. Config does not support the <code>INSUFFICIENT_DATA</code> value for the <code>EvaluationResult</code> data type.</p>
    pub fn compliance_type(&self) -> std::option::Option<&crate::model::ComplianceType> {
        self.compliance_type.as_ref()
    }
    /// <p>The time when Config recorded the evaluation result.</p>
    pub fn result_recorded_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.result_recorded_time.as_ref()
    }
    /// <p>The time when the Config rule evaluated the Amazon Web Services resource.</p>
    pub fn config_rule_invoked_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.config_rule_invoked_time.as_ref()
    }
    /// <p>Supplementary information about how the evaluation determined the compliance.</p>
    pub fn annotation(&self) -> std::option::Option<&str> {
        self.annotation.as_deref()
    }
    /// <p>An encrypted token that associates an evaluation with an Config rule. The token identifies the rule, the Amazon Web Services resource being evaluated, and the event that triggered the evaluation.</p>
    pub fn result_token(&self) -> std::option::Option<&str> {
        self.result_token.as_deref()
    }
}
impl EvaluationResult {
    /// Creates a new builder-style object to manufacture [`EvaluationResult`](crate::model::EvaluationResult).
    pub fn builder() -> crate::model::evaluation_result::Builder {
        crate::model::evaluation_result::Builder::default()
    }
}

/// See [`EvaluationResult`](crate::model::EvaluationResult).
pub mod evaluation_result {

    /// A builder for [`EvaluationResult`](crate::model::EvaluationResult).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) evaluation_result_identifier:
            std::option::Option<crate::model::EvaluationResultIdentifier>,
        pub(crate) compliance_type: std::option::Option<crate::model::ComplianceType>,
        pub(crate) result_recorded_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) config_rule_invoked_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) annotation: std::option::Option<std::string::String>,
        pub(crate) result_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Uniquely identifies the evaluation result.</p>
        pub fn evaluation_result_identifier(
            mut self,
            input: crate::model::EvaluationResultIdentifier,
        ) -> Self {
            self.evaluation_result_identifier = Some(input);
            self
        }
        /// <p>Uniquely identifies the evaluation result.</p>
        pub fn set_evaluation_result_identifier(
            mut self,
            input: std::option::Option<crate::model::EvaluationResultIdentifier>,
        ) -> Self {
            self.evaluation_result_identifier = input;
            self
        }
        /// <p>Indicates whether the Amazon Web Services resource complies with the Config rule that evaluated it.</p>
        /// <p>For the <code>EvaluationResult</code> data type, Config supports only the <code>COMPLIANT</code>, <code>NON_COMPLIANT</code>, and <code>NOT_APPLICABLE</code> values. Config does not support the <code>INSUFFICIENT_DATA</code> value for the <code>EvaluationResult</code> data type.</p>
        pub fn compliance_type(mut self, input: crate::model::ComplianceType) -> Self {
            self.compliance_type = Some(input);
            self
        }
        /// <p>Indicates whether the Amazon Web Services resource complies with the Config rule that evaluated it.</p>
        /// <p>For the <code>EvaluationResult</code> data type, Config supports only the <code>COMPLIANT</code>, <code>NON_COMPLIANT</code>, and <code>NOT_APPLICABLE</code> values. Config does not support the <code>INSUFFICIENT_DATA</code> value for the <code>EvaluationResult</code> data type.</p>
        pub fn set_compliance_type(
            mut self,
            input: std::option::Option<crate::model::ComplianceType>,
        ) -> Self {
            self.compliance_type = input;
            self
        }
        /// <p>The time when Config recorded the evaluation result.</p>
        pub fn result_recorded_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.result_recorded_time = Some(input);
            self
        }
        /// <p>The time when Config recorded the evaluation result.</p>
        pub fn set_result_recorded_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.result_recorded_time = input;
            self
        }
        /// <p>The time when the Config rule evaluated the Amazon Web Services resource.</p>
        pub fn config_rule_invoked_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.config_rule_invoked_time = Some(input);
            self
        }
        /// <p>The time when the Config rule evaluated the Amazon Web Services resource.</p>
        pub fn set_config_rule_invoked_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.config_rule_invoked_time = input;
            self
        }
        /// <p>Supplementary information about how the evaluation determined the compliance.</p>
        pub fn annotation(mut self, input: impl Into<std::string::String>) -> Self {
            self.annotation = Some(input.into());
            self
        }
        /// <p>Supplementary information about how the evaluation determined the compliance.</p>
        pub fn set_annotation(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.annotation = input;
            self
        }
        /// <p>An encrypted token that associates an evaluation with an Config rule. The token identifies the rule, the Amazon Web Services resource being evaluated, and the event that triggered the evaluation.</p>
        pub fn result_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.result_token = Some(input.into());
            self
        }
        /// <p>An encrypted token that associates an evaluation with an Config rule. The token identifies the rule, the Amazon Web Services resource being evaluated, and the event that triggered the evaluation.</p>
        pub fn set_result_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.result_token = input;
            self
        }
        /// Consumes the builder and constructs a [`EvaluationResult`](crate::model::EvaluationResult).
        pub fn build(self) -> crate::model::EvaluationResult {
            crate::model::EvaluationResult {
                evaluation_result_identifier: self.evaluation_result_identifier,
                compliance_type: self.compliance_type,
                result_recorded_time: self.result_recorded_time,
                config_rule_invoked_time: self.config_rule_invoked_time,
                annotation: self.annotation,
                result_token: self.result_token,
            }
        }
    }
}

/// <p>The count of resources that are grouped by the group name.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GroupedResourceCount {
    /// <p>The name of the group that can be region, account ID, or resource type. For example, region1, region2 if the region was chosen as <code>GroupByKey</code>.</p>
    #[doc(hidden)]
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The number of resources in the group.</p>
    #[doc(hidden)]
    pub resource_count: i64,
}
impl GroupedResourceCount {
    /// <p>The name of the group that can be region, account ID, or resource type. For example, region1, region2 if the region was chosen as <code>GroupByKey</code>.</p>
    pub fn group_name(&self) -> std::option::Option<&str> {
        self.group_name.as_deref()
    }
    /// <p>The number of resources in the group.</p>
    pub fn resource_count(&self) -> i64 {
        self.resource_count
    }
}
impl GroupedResourceCount {
    /// Creates a new builder-style object to manufacture [`GroupedResourceCount`](crate::model::GroupedResourceCount).
    pub fn builder() -> crate::model::grouped_resource_count::Builder {
        crate::model::grouped_resource_count::Builder::default()
    }
}

/// See [`GroupedResourceCount`](crate::model::GroupedResourceCount).
pub mod grouped_resource_count {

    /// A builder for [`GroupedResourceCount`](crate::model::GroupedResourceCount).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) resource_count: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The name of the group that can be region, account ID, or resource type. For example, region1, region2 if the region was chosen as <code>GroupByKey</code>.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        /// <p>The name of the group that can be region, account ID, or resource type. For example, region1, region2 if the region was chosen as <code>GroupByKey</code>.</p>
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// <p>The number of resources in the group.</p>
        pub fn resource_count(mut self, input: i64) -> Self {
            self.resource_count = Some(input);
            self
        }
        /// <p>The number of resources in the group.</p>
        pub fn set_resource_count(mut self, input: std::option::Option<i64>) -> Self {
            self.resource_count = input;
            self
        }
        /// Consumes the builder and constructs a [`GroupedResourceCount`](crate::model::GroupedResourceCount).
        pub fn build(self) -> crate::model::GroupedResourceCount {
            crate::model::GroupedResourceCount {
                group_name: self.group_name,
                resource_count: self.resource_count.unwrap_or_default(),
            }
        }
    }
}

/// When writing a match expression against `ResourceCountGroupKey`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourcecountgroupkey = unimplemented!();
/// match resourcecountgroupkey {
///     ResourceCountGroupKey::AccountId => { /* ... */ },
///     ResourceCountGroupKey::AwsRegion => { /* ... */ },
///     ResourceCountGroupKey::ResourceType => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourcecountgroupkey` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceCountGroupKey::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceCountGroupKey::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceCountGroupKey::NewFeature` is defined.
/// Specifically, when `resourcecountgroupkey` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceCountGroupKey::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceCountGroupKey {
    #[allow(missing_docs)] // documentation missing in model
    AccountId,
    #[allow(missing_docs)] // documentation missing in model
    AwsRegion,
    #[allow(missing_docs)] // documentation missing in model
    ResourceType,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceCountGroupKey {
    fn from(s: &str) -> Self {
        match s {
            "ACCOUNT_ID" => ResourceCountGroupKey::AccountId,
            "AWS_REGION" => ResourceCountGroupKey::AwsRegion,
            "RESOURCE_TYPE" => ResourceCountGroupKey::ResourceType,
            other => {
                ResourceCountGroupKey::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ResourceCountGroupKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceCountGroupKey::from(s))
    }
}
impl ResourceCountGroupKey {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceCountGroupKey::AccountId => "ACCOUNT_ID",
            ResourceCountGroupKey::AwsRegion => "AWS_REGION",
            ResourceCountGroupKey::ResourceType => "RESOURCE_TYPE",
            ResourceCountGroupKey::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACCOUNT_ID", "AWS_REGION", "RESOURCE_TYPE"]
    }
}
impl AsRef<str> for ResourceCountGroupKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Filters the resource count based on account ID, region, and resource type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceCountFilters {
    /// <p>The type of the Amazon Web Services resource.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>The 12-digit ID of the account.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The region where the account is located.</p>
    #[doc(hidden)]
    pub region: std::option::Option<std::string::String>,
}
impl ResourceCountFilters {
    /// <p>The type of the Amazon Web Services resource.</p>
    pub fn resource_type(&self) -> std::option::Option<&crate::model::ResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>The 12-digit ID of the account.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The region where the account is located.</p>
    pub fn region(&self) -> std::option::Option<&str> {
        self.region.as_deref()
    }
}
impl ResourceCountFilters {
    /// Creates a new builder-style object to manufacture [`ResourceCountFilters`](crate::model::ResourceCountFilters).
    pub fn builder() -> crate::model::resource_count_filters::Builder {
        crate::model::resource_count_filters::Builder::default()
    }
}

/// See [`ResourceCountFilters`](crate::model::ResourceCountFilters).
pub mod resource_count_filters {

    /// A builder for [`ResourceCountFilters`](crate::model::ResourceCountFilters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) region: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of the Amazon Web Services resource.</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>The type of the Amazon Web Services resource.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The 12-digit ID of the account.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The 12-digit ID of the account.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The region where the account is located.</p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        /// <p>The region where the account is located.</p>
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceCountFilters`](crate::model::ResourceCountFilters).
        pub fn build(self) -> crate::model::ResourceCountFilters {
            crate::model::ResourceCountFilters {
                resource_type: self.resource_type,
                account_id: self.account_id,
                region: self.region,
            }
        }
    }
}

/// <p>Provides a summary of compliance based on either account ID or region. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AggregateConformancePackComplianceSummary {
    /// <p>Returns an <code>AggregateConformancePackComplianceCount</code> object. </p>
    #[doc(hidden)]
    pub compliance_summary:
        std::option::Option<crate::model::AggregateConformancePackComplianceCount>,
    /// <p>Groups the result based on Amazon Web Services account ID or Amazon Web Services Region.</p>
    #[doc(hidden)]
    pub group_name: std::option::Option<std::string::String>,
}
impl AggregateConformancePackComplianceSummary {
    /// <p>Returns an <code>AggregateConformancePackComplianceCount</code> object. </p>
    pub fn compliance_summary(
        &self,
    ) -> std::option::Option<&crate::model::AggregateConformancePackComplianceCount> {
        self.compliance_summary.as_ref()
    }
    /// <p>Groups the result based on Amazon Web Services account ID or Amazon Web Services Region.</p>
    pub fn group_name(&self) -> std::option::Option<&str> {
        self.group_name.as_deref()
    }
}
impl AggregateConformancePackComplianceSummary {
    /// Creates a new builder-style object to manufacture [`AggregateConformancePackComplianceSummary`](crate::model::AggregateConformancePackComplianceSummary).
    pub fn builder() -> crate::model::aggregate_conformance_pack_compliance_summary::Builder {
        crate::model::aggregate_conformance_pack_compliance_summary::Builder::default()
    }
}

/// See [`AggregateConformancePackComplianceSummary`](crate::model::AggregateConformancePackComplianceSummary).
pub mod aggregate_conformance_pack_compliance_summary {

    /// A builder for [`AggregateConformancePackComplianceSummary`](crate::model::AggregateConformancePackComplianceSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) compliance_summary:
            std::option::Option<crate::model::AggregateConformancePackComplianceCount>,
        pub(crate) group_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Returns an <code>AggregateConformancePackComplianceCount</code> object. </p>
        pub fn compliance_summary(
            mut self,
            input: crate::model::AggregateConformancePackComplianceCount,
        ) -> Self {
            self.compliance_summary = Some(input);
            self
        }
        /// <p>Returns an <code>AggregateConformancePackComplianceCount</code> object. </p>
        pub fn set_compliance_summary(
            mut self,
            input: std::option::Option<crate::model::AggregateConformancePackComplianceCount>,
        ) -> Self {
            self.compliance_summary = input;
            self
        }
        /// <p>Groups the result based on Amazon Web Services account ID or Amazon Web Services Region.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        /// <p>Groups the result based on Amazon Web Services account ID or Amazon Web Services Region.</p>
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AggregateConformancePackComplianceSummary`](crate::model::AggregateConformancePackComplianceSummary).
        pub fn build(self) -> crate::model::AggregateConformancePackComplianceSummary {
            crate::model::AggregateConformancePackComplianceSummary {
                compliance_summary: self.compliance_summary,
                group_name: self.group_name,
            }
        }
    }
}

/// <p>The number of conformance packs that are compliant and noncompliant.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AggregateConformancePackComplianceCount {
    /// <p>Number of compliant conformance packs.</p>
    #[doc(hidden)]
    pub compliant_conformance_pack_count: i32,
    /// <p>Number of noncompliant conformance packs.</p>
    #[doc(hidden)]
    pub non_compliant_conformance_pack_count: i32,
}
impl AggregateConformancePackComplianceCount {
    /// <p>Number of compliant conformance packs.</p>
    pub fn compliant_conformance_pack_count(&self) -> i32 {
        self.compliant_conformance_pack_count
    }
    /// <p>Number of noncompliant conformance packs.</p>
    pub fn non_compliant_conformance_pack_count(&self) -> i32 {
        self.non_compliant_conformance_pack_count
    }
}
impl AggregateConformancePackComplianceCount {
    /// Creates a new builder-style object to manufacture [`AggregateConformancePackComplianceCount`](crate::model::AggregateConformancePackComplianceCount).
    pub fn builder() -> crate::model::aggregate_conformance_pack_compliance_count::Builder {
        crate::model::aggregate_conformance_pack_compliance_count::Builder::default()
    }
}

/// See [`AggregateConformancePackComplianceCount`](crate::model::AggregateConformancePackComplianceCount).
pub mod aggregate_conformance_pack_compliance_count {

    /// A builder for [`AggregateConformancePackComplianceCount`](crate::model::AggregateConformancePackComplianceCount).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) compliant_conformance_pack_count: std::option::Option<i32>,
        pub(crate) non_compliant_conformance_pack_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Number of compliant conformance packs.</p>
        pub fn compliant_conformance_pack_count(mut self, input: i32) -> Self {
            self.compliant_conformance_pack_count = Some(input);
            self
        }
        /// <p>Number of compliant conformance packs.</p>
        pub fn set_compliant_conformance_pack_count(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.compliant_conformance_pack_count = input;
            self
        }
        /// <p>Number of noncompliant conformance packs.</p>
        pub fn non_compliant_conformance_pack_count(mut self, input: i32) -> Self {
            self.non_compliant_conformance_pack_count = Some(input);
            self
        }
        /// <p>Number of noncompliant conformance packs.</p>
        pub fn set_non_compliant_conformance_pack_count(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.non_compliant_conformance_pack_count = input;
            self
        }
        /// Consumes the builder and constructs a [`AggregateConformancePackComplianceCount`](crate::model::AggregateConformancePackComplianceCount).
        pub fn build(self) -> crate::model::AggregateConformancePackComplianceCount {
            crate::model::AggregateConformancePackComplianceCount {
                compliant_conformance_pack_count: self
                    .compliant_conformance_pack_count
                    .unwrap_or_default(),
                non_compliant_conformance_pack_count: self
                    .non_compliant_conformance_pack_count
                    .unwrap_or_default(),
            }
        }
    }
}

/// When writing a match expression against `AggregateConformancePackComplianceSummaryGroupKey`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let aggregateconformancepackcompliancesummarygroupkey = unimplemented!();
/// match aggregateconformancepackcompliancesummarygroupkey {
///     AggregateConformancePackComplianceSummaryGroupKey::AccountId => { /* ... */ },
///     AggregateConformancePackComplianceSummaryGroupKey::AwsRegion => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `aggregateconformancepackcompliancesummarygroupkey` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AggregateConformancePackComplianceSummaryGroupKey::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AggregateConformancePackComplianceSummaryGroupKey::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AggregateConformancePackComplianceSummaryGroupKey::NewFeature` is defined.
/// Specifically, when `aggregateconformancepackcompliancesummarygroupkey` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AggregateConformancePackComplianceSummaryGroupKey::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AggregateConformancePackComplianceSummaryGroupKey {
    #[allow(missing_docs)] // documentation missing in model
    AccountId,
    #[allow(missing_docs)] // documentation missing in model
    AwsRegion,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AggregateConformancePackComplianceSummaryGroupKey {
    fn from(s: &str) -> Self {
        match s {
            "ACCOUNT_ID" => AggregateConformancePackComplianceSummaryGroupKey::AccountId,
            "AWS_REGION" => AggregateConformancePackComplianceSummaryGroupKey::AwsRegion,
            other => AggregateConformancePackComplianceSummaryGroupKey::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for AggregateConformancePackComplianceSummaryGroupKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AggregateConformancePackComplianceSummaryGroupKey::from(s))
    }
}
impl AggregateConformancePackComplianceSummaryGroupKey {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AggregateConformancePackComplianceSummaryGroupKey::AccountId => "ACCOUNT_ID",
            AggregateConformancePackComplianceSummaryGroupKey::AwsRegion => "AWS_REGION",
            AggregateConformancePackComplianceSummaryGroupKey::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACCOUNT_ID", "AWS_REGION"]
    }
}
impl AsRef<str> for AggregateConformancePackComplianceSummaryGroupKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Filters the results based on account ID and region. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AggregateConformancePackComplianceSummaryFilters {
    /// <p>The 12-digit Amazon Web Services account ID of the source account.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The source Amazon Web Services Region from where the data is aggregated.</p>
    #[doc(hidden)]
    pub aws_region: std::option::Option<std::string::String>,
}
impl AggregateConformancePackComplianceSummaryFilters {
    /// <p>The 12-digit Amazon Web Services account ID of the source account.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The source Amazon Web Services Region from where the data is aggregated.</p>
    pub fn aws_region(&self) -> std::option::Option<&str> {
        self.aws_region.as_deref()
    }
}
impl AggregateConformancePackComplianceSummaryFilters {
    /// Creates a new builder-style object to manufacture [`AggregateConformancePackComplianceSummaryFilters`](crate::model::AggregateConformancePackComplianceSummaryFilters).
    pub fn builder() -> crate::model::aggregate_conformance_pack_compliance_summary_filters::Builder
    {
        crate::model::aggregate_conformance_pack_compliance_summary_filters::Builder::default()
    }
}

/// See [`AggregateConformancePackComplianceSummaryFilters`](crate::model::AggregateConformancePackComplianceSummaryFilters).
pub mod aggregate_conformance_pack_compliance_summary_filters {

    /// A builder for [`AggregateConformancePackComplianceSummaryFilters`](crate::model::AggregateConformancePackComplianceSummaryFilters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) aws_region: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The 12-digit Amazon Web Services account ID of the source account.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The 12-digit Amazon Web Services account ID of the source account.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The source Amazon Web Services Region from where the data is aggregated.</p>
        pub fn aws_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_region = Some(input.into());
            self
        }
        /// <p>The source Amazon Web Services Region from where the data is aggregated.</p>
        pub fn set_aws_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.aws_region = input;
            self
        }
        /// Consumes the builder and constructs a [`AggregateConformancePackComplianceSummaryFilters`](crate::model::AggregateConformancePackComplianceSummaryFilters).
        pub fn build(self) -> crate::model::AggregateConformancePackComplianceSummaryFilters {
            crate::model::AggregateConformancePackComplianceSummaryFilters {
                account_id: self.account_id,
                aws_region: self.aws_region,
            }
        }
    }
}

/// <p>Returns the number of compliant and noncompliant rules for one or more accounts and regions in an aggregator.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AggregateComplianceCount {
    /// <p>The 12-digit account ID or region based on the GroupByKey value.</p>
    #[doc(hidden)]
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The number of compliant and noncompliant Config rules.</p>
    #[doc(hidden)]
    pub compliance_summary: std::option::Option<crate::model::ComplianceSummary>,
}
impl AggregateComplianceCount {
    /// <p>The 12-digit account ID or region based on the GroupByKey value.</p>
    pub fn group_name(&self) -> std::option::Option<&str> {
        self.group_name.as_deref()
    }
    /// <p>The number of compliant and noncompliant Config rules.</p>
    pub fn compliance_summary(&self) -> std::option::Option<&crate::model::ComplianceSummary> {
        self.compliance_summary.as_ref()
    }
}
impl AggregateComplianceCount {
    /// Creates a new builder-style object to manufacture [`AggregateComplianceCount`](crate::model::AggregateComplianceCount).
    pub fn builder() -> crate::model::aggregate_compliance_count::Builder {
        crate::model::aggregate_compliance_count::Builder::default()
    }
}

/// See [`AggregateComplianceCount`](crate::model::AggregateComplianceCount).
pub mod aggregate_compliance_count {

    /// A builder for [`AggregateComplianceCount`](crate::model::AggregateComplianceCount).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) compliance_summary: std::option::Option<crate::model::ComplianceSummary>,
    }
    impl Builder {
        /// <p>The 12-digit account ID or region based on the GroupByKey value.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        /// <p>The 12-digit account ID or region based on the GroupByKey value.</p>
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// <p>The number of compliant and noncompliant Config rules.</p>
        pub fn compliance_summary(mut self, input: crate::model::ComplianceSummary) -> Self {
            self.compliance_summary = Some(input);
            self
        }
        /// <p>The number of compliant and noncompliant Config rules.</p>
        pub fn set_compliance_summary(
            mut self,
            input: std::option::Option<crate::model::ComplianceSummary>,
        ) -> Self {
            self.compliance_summary = input;
            self
        }
        /// Consumes the builder and constructs a [`AggregateComplianceCount`](crate::model::AggregateComplianceCount).
        pub fn build(self) -> crate::model::AggregateComplianceCount {
            crate::model::AggregateComplianceCount {
                group_name: self.group_name,
                compliance_summary: self.compliance_summary,
            }
        }
    }
}

/// When writing a match expression against `ConfigRuleComplianceSummaryGroupKey`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let configrulecompliancesummarygroupkey = unimplemented!();
/// match configrulecompliancesummarygroupkey {
///     ConfigRuleComplianceSummaryGroupKey::AccountId => { /* ... */ },
///     ConfigRuleComplianceSummaryGroupKey::AwsRegion => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `configrulecompliancesummarygroupkey` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConfigRuleComplianceSummaryGroupKey::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConfigRuleComplianceSummaryGroupKey::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConfigRuleComplianceSummaryGroupKey::NewFeature` is defined.
/// Specifically, when `configrulecompliancesummarygroupkey` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConfigRuleComplianceSummaryGroupKey::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConfigRuleComplianceSummaryGroupKey {
    #[allow(missing_docs)] // documentation missing in model
    AccountId,
    #[allow(missing_docs)] // documentation missing in model
    AwsRegion,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConfigRuleComplianceSummaryGroupKey {
    fn from(s: &str) -> Self {
        match s {
            "ACCOUNT_ID" => ConfigRuleComplianceSummaryGroupKey::AccountId,
            "AWS_REGION" => ConfigRuleComplianceSummaryGroupKey::AwsRegion,
            other => ConfigRuleComplianceSummaryGroupKey::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for ConfigRuleComplianceSummaryGroupKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConfigRuleComplianceSummaryGroupKey::from(s))
    }
}
impl ConfigRuleComplianceSummaryGroupKey {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConfigRuleComplianceSummaryGroupKey::AccountId => "ACCOUNT_ID",
            ConfigRuleComplianceSummaryGroupKey::AwsRegion => "AWS_REGION",
            ConfigRuleComplianceSummaryGroupKey::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACCOUNT_ID", "AWS_REGION"]
    }
}
impl AsRef<str> for ConfigRuleComplianceSummaryGroupKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Filters the results based on the account IDs and regions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfigRuleComplianceSummaryFilters {
    /// <p>The 12-digit account ID of the source account.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The source region where the data is aggregated.</p>
    #[doc(hidden)]
    pub aws_region: std::option::Option<std::string::String>,
}
impl ConfigRuleComplianceSummaryFilters {
    /// <p>The 12-digit account ID of the source account.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The source region where the data is aggregated.</p>
    pub fn aws_region(&self) -> std::option::Option<&str> {
        self.aws_region.as_deref()
    }
}
impl ConfigRuleComplianceSummaryFilters {
    /// Creates a new builder-style object to manufacture [`ConfigRuleComplianceSummaryFilters`](crate::model::ConfigRuleComplianceSummaryFilters).
    pub fn builder() -> crate::model::config_rule_compliance_summary_filters::Builder {
        crate::model::config_rule_compliance_summary_filters::Builder::default()
    }
}

/// See [`ConfigRuleComplianceSummaryFilters`](crate::model::ConfigRuleComplianceSummaryFilters).
pub mod config_rule_compliance_summary_filters {

    /// A builder for [`ConfigRuleComplianceSummaryFilters`](crate::model::ConfigRuleComplianceSummaryFilters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) aws_region: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The 12-digit account ID of the source account.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The 12-digit account ID of the source account.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The source region where the data is aggregated.</p>
        pub fn aws_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_region = Some(input.into());
            self
        }
        /// <p>The source region where the data is aggregated.</p>
        pub fn set_aws_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.aws_region = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigRuleComplianceSummaryFilters`](crate::model::ConfigRuleComplianceSummaryFilters).
        pub fn build(self) -> crate::model::ConfigRuleComplianceSummaryFilters {
            crate::model::ConfigRuleComplianceSummaryFilters {
                account_id: self.account_id,
                aws_region: self.aws_region,
            }
        }
    }
}

/// <p>The details of an Config evaluation for an account ID and region in an aggregator. Provides the Amazon Web Services resource that was evaluated, the compliance of the resource, related time stamps, and supplementary information. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AggregateEvaluationResult {
    /// <p>Uniquely identifies the evaluation result.</p>
    #[doc(hidden)]
    pub evaluation_result_identifier: std::option::Option<crate::model::EvaluationResultIdentifier>,
    /// <p>The resource compliance status.</p>
    /// <p>For the <code>AggregationEvaluationResult</code> data type, Config supports only the <code>COMPLIANT</code> and <code>NON_COMPLIANT</code>. Config does not support the <code>NOT_APPLICABLE</code> and <code>INSUFFICIENT_DATA</code> value.</p>
    #[doc(hidden)]
    pub compliance_type: std::option::Option<crate::model::ComplianceType>,
    /// <p>The time when Config recorded the aggregate evaluation result.</p>
    #[doc(hidden)]
    pub result_recorded_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time when the Config rule evaluated the Amazon Web Services resource.</p>
    #[doc(hidden)]
    pub config_rule_invoked_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Supplementary information about how the agrregate evaluation determined the compliance.</p>
    #[doc(hidden)]
    pub annotation: std::option::Option<std::string::String>,
    /// <p>The 12-digit account ID of the source account.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The source region from where the data is aggregated.</p>
    #[doc(hidden)]
    pub aws_region: std::option::Option<std::string::String>,
}
impl AggregateEvaluationResult {
    /// <p>Uniquely identifies the evaluation result.</p>
    pub fn evaluation_result_identifier(
        &self,
    ) -> std::option::Option<&crate::model::EvaluationResultIdentifier> {
        self.evaluation_result_identifier.as_ref()
    }
    /// <p>The resource compliance status.</p>
    /// <p>For the <code>AggregationEvaluationResult</code> data type, Config supports only the <code>COMPLIANT</code> and <code>NON_COMPLIANT</code>. Config does not support the <code>NOT_APPLICABLE</code> and <code>INSUFFICIENT_DATA</code> value.</p>
    pub fn compliance_type(&self) -> std::option::Option<&crate::model::ComplianceType> {
        self.compliance_type.as_ref()
    }
    /// <p>The time when Config recorded the aggregate evaluation result.</p>
    pub fn result_recorded_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.result_recorded_time.as_ref()
    }
    /// <p>The time when the Config rule evaluated the Amazon Web Services resource.</p>
    pub fn config_rule_invoked_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.config_rule_invoked_time.as_ref()
    }
    /// <p>Supplementary information about how the agrregate evaluation determined the compliance.</p>
    pub fn annotation(&self) -> std::option::Option<&str> {
        self.annotation.as_deref()
    }
    /// <p>The 12-digit account ID of the source account.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The source region from where the data is aggregated.</p>
    pub fn aws_region(&self) -> std::option::Option<&str> {
        self.aws_region.as_deref()
    }
}
impl AggregateEvaluationResult {
    /// Creates a new builder-style object to manufacture [`AggregateEvaluationResult`](crate::model::AggregateEvaluationResult).
    pub fn builder() -> crate::model::aggregate_evaluation_result::Builder {
        crate::model::aggregate_evaluation_result::Builder::default()
    }
}

/// See [`AggregateEvaluationResult`](crate::model::AggregateEvaluationResult).
pub mod aggregate_evaluation_result {

    /// A builder for [`AggregateEvaluationResult`](crate::model::AggregateEvaluationResult).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) evaluation_result_identifier:
            std::option::Option<crate::model::EvaluationResultIdentifier>,
        pub(crate) compliance_type: std::option::Option<crate::model::ComplianceType>,
        pub(crate) result_recorded_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) config_rule_invoked_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) annotation: std::option::Option<std::string::String>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) aws_region: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Uniquely identifies the evaluation result.</p>
        pub fn evaluation_result_identifier(
            mut self,
            input: crate::model::EvaluationResultIdentifier,
        ) -> Self {
            self.evaluation_result_identifier = Some(input);
            self
        }
        /// <p>Uniquely identifies the evaluation result.</p>
        pub fn set_evaluation_result_identifier(
            mut self,
            input: std::option::Option<crate::model::EvaluationResultIdentifier>,
        ) -> Self {
            self.evaluation_result_identifier = input;
            self
        }
        /// <p>The resource compliance status.</p>
        /// <p>For the <code>AggregationEvaluationResult</code> data type, Config supports only the <code>COMPLIANT</code> and <code>NON_COMPLIANT</code>. Config does not support the <code>NOT_APPLICABLE</code> and <code>INSUFFICIENT_DATA</code> value.</p>
        pub fn compliance_type(mut self, input: crate::model::ComplianceType) -> Self {
            self.compliance_type = Some(input);
            self
        }
        /// <p>The resource compliance status.</p>
        /// <p>For the <code>AggregationEvaluationResult</code> data type, Config supports only the <code>COMPLIANT</code> and <code>NON_COMPLIANT</code>. Config does not support the <code>NOT_APPLICABLE</code> and <code>INSUFFICIENT_DATA</code> value.</p>
        pub fn set_compliance_type(
            mut self,
            input: std::option::Option<crate::model::ComplianceType>,
        ) -> Self {
            self.compliance_type = input;
            self
        }
        /// <p>The time when Config recorded the aggregate evaluation result.</p>
        pub fn result_recorded_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.result_recorded_time = Some(input);
            self
        }
        /// <p>The time when Config recorded the aggregate evaluation result.</p>
        pub fn set_result_recorded_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.result_recorded_time = input;
            self
        }
        /// <p>The time when the Config rule evaluated the Amazon Web Services resource.</p>
        pub fn config_rule_invoked_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.config_rule_invoked_time = Some(input);
            self
        }
        /// <p>The time when the Config rule evaluated the Amazon Web Services resource.</p>
        pub fn set_config_rule_invoked_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.config_rule_invoked_time = input;
            self
        }
        /// <p>Supplementary information about how the agrregate evaluation determined the compliance.</p>
        pub fn annotation(mut self, input: impl Into<std::string::String>) -> Self {
            self.annotation = Some(input.into());
            self
        }
        /// <p>Supplementary information about how the agrregate evaluation determined the compliance.</p>
        pub fn set_annotation(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.annotation = input;
            self
        }
        /// <p>The 12-digit account ID of the source account.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The 12-digit account ID of the source account.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The source region from where the data is aggregated.</p>
        pub fn aws_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_region = Some(input.into());
            self
        }
        /// <p>The source region from where the data is aggregated.</p>
        pub fn set_aws_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.aws_region = input;
            self
        }
        /// Consumes the builder and constructs a [`AggregateEvaluationResult`](crate::model::AggregateEvaluationResult).
        pub fn build(self) -> crate::model::AggregateEvaluationResult {
            crate::model::AggregateEvaluationResult {
                evaluation_result_identifier: self.evaluation_result_identifier,
                compliance_type: self.compliance_type,
                result_recorded_time: self.result_recorded_time,
                config_rule_invoked_time: self.config_rule_invoked_time,
                annotation: self.annotation,
                account_id: self.account_id,
                aws_region: self.aws_region,
            }
        }
    }
}

/// <p>Provides details of the current status of the invoked remediation action for that resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RemediationExecutionStatus {
    /// <p>The details that identify a resource within Config, including the resource type and resource ID.</p>
    #[doc(hidden)]
    pub resource_key: std::option::Option<crate::model::ResourceKey>,
    /// <p>ENUM of the values.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::RemediationExecutionState>,
    /// <p>Details of every step.</p>
    #[doc(hidden)]
    pub step_details: std::option::Option<std::vec::Vec<crate::model::RemediationExecutionStep>>,
    /// <p>Start time when the remediation was executed.</p>
    #[doc(hidden)]
    pub invocation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time when the remediation execution was last updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl RemediationExecutionStatus {
    /// <p>The details that identify a resource within Config, including the resource type and resource ID.</p>
    pub fn resource_key(&self) -> std::option::Option<&crate::model::ResourceKey> {
        self.resource_key.as_ref()
    }
    /// <p>ENUM of the values.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::RemediationExecutionState> {
        self.state.as_ref()
    }
    /// <p>Details of every step.</p>
    pub fn step_details(&self) -> std::option::Option<&[crate::model::RemediationExecutionStep]> {
        self.step_details.as_deref()
    }
    /// <p>Start time when the remediation was executed.</p>
    pub fn invocation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.invocation_time.as_ref()
    }
    /// <p>The time when the remediation execution was last updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_time.as_ref()
    }
}
impl RemediationExecutionStatus {
    /// Creates a new builder-style object to manufacture [`RemediationExecutionStatus`](crate::model::RemediationExecutionStatus).
    pub fn builder() -> crate::model::remediation_execution_status::Builder {
        crate::model::remediation_execution_status::Builder::default()
    }
}

/// See [`RemediationExecutionStatus`](crate::model::RemediationExecutionStatus).
pub mod remediation_execution_status {

    /// A builder for [`RemediationExecutionStatus`](crate::model::RemediationExecutionStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_key: std::option::Option<crate::model::ResourceKey>,
        pub(crate) state: std::option::Option<crate::model::RemediationExecutionState>,
        pub(crate) step_details:
            std::option::Option<std::vec::Vec<crate::model::RemediationExecutionStep>>,
        pub(crate) invocation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The details that identify a resource within Config, including the resource type and resource ID.</p>
        pub fn resource_key(mut self, input: crate::model::ResourceKey) -> Self {
            self.resource_key = Some(input);
            self
        }
        /// <p>The details that identify a resource within Config, including the resource type and resource ID.</p>
        pub fn set_resource_key(
            mut self,
            input: std::option::Option<crate::model::ResourceKey>,
        ) -> Self {
            self.resource_key = input;
            self
        }
        /// <p>ENUM of the values.</p>
        pub fn state(mut self, input: crate::model::RemediationExecutionState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>ENUM of the values.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::RemediationExecutionState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Appends an item to `step_details`.
        ///
        /// To override the contents of this collection use [`set_step_details`](Self::set_step_details).
        ///
        /// <p>Details of every step.</p>
        pub fn step_details(mut self, input: crate::model::RemediationExecutionStep) -> Self {
            let mut v = self.step_details.unwrap_or_default();
            v.push(input);
            self.step_details = Some(v);
            self
        }
        /// <p>Details of every step.</p>
        pub fn set_step_details(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RemediationExecutionStep>>,
        ) -> Self {
            self.step_details = input;
            self
        }
        /// <p>Start time when the remediation was executed.</p>
        pub fn invocation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.invocation_time = Some(input);
            self
        }
        /// <p>Start time when the remediation was executed.</p>
        pub fn set_invocation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.invocation_time = input;
            self
        }
        /// <p>The time when the remediation execution was last updated.</p>
        pub fn last_updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_time = Some(input);
            self
        }
        /// <p>The time when the remediation execution was last updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// Consumes the builder and constructs a [`RemediationExecutionStatus`](crate::model::RemediationExecutionStatus).
        pub fn build(self) -> crate::model::RemediationExecutionStatus {
            crate::model::RemediationExecutionStatus {
                resource_key: self.resource_key,
                state: self.state,
                step_details: self.step_details,
                invocation_time: self.invocation_time,
                last_updated_time: self.last_updated_time,
            }
        }
    }
}

/// <p>Name of the step from the SSM document.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RemediationExecutionStep {
    /// <p>The details of the step.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The valid status of the step.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::RemediationExecutionStepState>,
    /// <p>An error message if the step was interrupted during execution.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>The time when the step started.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time when the step stopped.</p>
    #[doc(hidden)]
    pub stop_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl RemediationExecutionStep {
    /// <p>The details of the step.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The valid status of the step.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::RemediationExecutionStepState> {
        self.state.as_ref()
    }
    /// <p>An error message if the step was interrupted during execution.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>The time when the step started.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The time when the step stopped.</p>
    pub fn stop_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.stop_time.as_ref()
    }
}
impl RemediationExecutionStep {
    /// Creates a new builder-style object to manufacture [`RemediationExecutionStep`](crate::model::RemediationExecutionStep).
    pub fn builder() -> crate::model::remediation_execution_step::Builder {
        crate::model::remediation_execution_step::Builder::default()
    }
}

/// See [`RemediationExecutionStep`](crate::model::RemediationExecutionStep).
pub mod remediation_execution_step {

    /// A builder for [`RemediationExecutionStep`](crate::model::RemediationExecutionStep).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::RemediationExecutionStepState>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) stop_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The details of the step.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The details of the step.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The valid status of the step.</p>
        pub fn state(mut self, input: crate::model::RemediationExecutionStepState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The valid status of the step.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::RemediationExecutionStepState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>An error message if the step was interrupted during execution.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>An error message if the step was interrupted during execution.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>The time when the step started.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The time when the step started.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The time when the step stopped.</p>
        pub fn stop_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.stop_time = Some(input);
            self
        }
        /// <p>The time when the step stopped.</p>
        pub fn set_stop_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.stop_time = input;
            self
        }
        /// Consumes the builder and constructs a [`RemediationExecutionStep`](crate::model::RemediationExecutionStep).
        pub fn build(self) -> crate::model::RemediationExecutionStep {
            crate::model::RemediationExecutionStep {
                name: self.name,
                state: self.state,
                error_message: self.error_message,
                start_time: self.start_time,
                stop_time: self.stop_time,
            }
        }
    }
}

/// When writing a match expression against `RemediationExecutionStepState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let remediationexecutionstepstate = unimplemented!();
/// match remediationexecutionstepstate {
///     RemediationExecutionStepState::Failed => { /* ... */ },
///     RemediationExecutionStepState::Pending => { /* ... */ },
///     RemediationExecutionStepState::Succeeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `remediationexecutionstepstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RemediationExecutionStepState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RemediationExecutionStepState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RemediationExecutionStepState::NewFeature` is defined.
/// Specifically, when `remediationexecutionstepstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RemediationExecutionStepState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RemediationExecutionStepState {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RemediationExecutionStepState {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => RemediationExecutionStepState::Failed,
            "PENDING" => RemediationExecutionStepState::Pending,
            "SUCCEEDED" => RemediationExecutionStepState::Succeeded,
            other => RemediationExecutionStepState::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for RemediationExecutionStepState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RemediationExecutionStepState::from(s))
    }
}
impl RemediationExecutionStepState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RemediationExecutionStepState::Failed => "FAILED",
            RemediationExecutionStepState::Pending => "PENDING",
            RemediationExecutionStepState::Succeeded => "SUCCEEDED",
            RemediationExecutionStepState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FAILED", "PENDING", "SUCCEEDED"]
    }
}
impl AsRef<str> for RemediationExecutionStepState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `RemediationExecutionState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let remediationexecutionstate = unimplemented!();
/// match remediationexecutionstate {
///     RemediationExecutionState::Failed => { /* ... */ },
///     RemediationExecutionState::InProgress => { /* ... */ },
///     RemediationExecutionState::Queued => { /* ... */ },
///     RemediationExecutionState::Succeeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `remediationexecutionstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RemediationExecutionState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RemediationExecutionState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RemediationExecutionState::NewFeature` is defined.
/// Specifically, when `remediationexecutionstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RemediationExecutionState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RemediationExecutionState {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Queued,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RemediationExecutionState {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => RemediationExecutionState::Failed,
            "IN_PROGRESS" => RemediationExecutionState::InProgress,
            "QUEUED" => RemediationExecutionState::Queued,
            "SUCCEEDED" => RemediationExecutionState::Succeeded,
            other => RemediationExecutionState::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for RemediationExecutionState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RemediationExecutionState::from(s))
    }
}
impl RemediationExecutionState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RemediationExecutionState::Failed => "FAILED",
            RemediationExecutionState::InProgress => "IN_PROGRESS",
            RemediationExecutionState::Queued => "QUEUED",
            RemediationExecutionState::Succeeded => "SUCCEEDED",
            RemediationExecutionState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FAILED", "IN_PROGRESS", "QUEUED", "SUCCEEDED"]
    }
}
impl AsRef<str> for RemediationExecutionState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that represents the account ID and region of an aggregator account that is requesting authorization but is not yet authorized.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PendingAggregationRequest {
    /// <p>The 12-digit account ID of the account requesting to aggregate data.</p>
    #[doc(hidden)]
    pub requester_account_id: std::option::Option<std::string::String>,
    /// <p>The region requesting to aggregate data. </p>
    #[doc(hidden)]
    pub requester_aws_region: std::option::Option<std::string::String>,
}
impl PendingAggregationRequest {
    /// <p>The 12-digit account ID of the account requesting to aggregate data.</p>
    pub fn requester_account_id(&self) -> std::option::Option<&str> {
        self.requester_account_id.as_deref()
    }
    /// <p>The region requesting to aggregate data. </p>
    pub fn requester_aws_region(&self) -> std::option::Option<&str> {
        self.requester_aws_region.as_deref()
    }
}
impl PendingAggregationRequest {
    /// Creates a new builder-style object to manufacture [`PendingAggregationRequest`](crate::model::PendingAggregationRequest).
    pub fn builder() -> crate::model::pending_aggregation_request::Builder {
        crate::model::pending_aggregation_request::Builder::default()
    }
}

/// See [`PendingAggregationRequest`](crate::model::PendingAggregationRequest).
pub mod pending_aggregation_request {

    /// A builder for [`PendingAggregationRequest`](crate::model::PendingAggregationRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) requester_account_id: std::option::Option<std::string::String>,
        pub(crate) requester_aws_region: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The 12-digit account ID of the account requesting to aggregate data.</p>
        pub fn requester_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.requester_account_id = Some(input.into());
            self
        }
        /// <p>The 12-digit account ID of the account requesting to aggregate data.</p>
        pub fn set_requester_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.requester_account_id = input;
            self
        }
        /// <p>The region requesting to aggregate data. </p>
        pub fn requester_aws_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.requester_aws_region = Some(input.into());
            self
        }
        /// <p>The region requesting to aggregate data. </p>
        pub fn set_requester_aws_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.requester_aws_region = input;
            self
        }
        /// Consumes the builder and constructs a [`PendingAggregationRequest`](crate::model::PendingAggregationRequest).
        pub fn build(self) -> crate::model::PendingAggregationRequest {
            crate::model::PendingAggregationRequest {
                requester_account_id: self.requester_account_id,
                requester_aws_region: self.requester_aws_region,
            }
        }
    }
}

/// <p>Returns the status for an organization conformance pack in an organization.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OrganizationConformancePackStatus {
    /// <p>The name that you assign to organization conformance pack.</p>
    #[doc(hidden)]
    pub organization_conformance_pack_name: std::option::Option<std::string::String>,
    /// <p>Indicates deployment status of an organization conformance pack. When management account calls PutOrganizationConformancePack for the first time, conformance pack status is created in all the member accounts. When management account calls PutOrganizationConformancePack for the second time, conformance pack status is updated in all the member accounts. Additionally, conformance pack status is updated when one or more member accounts join or leave an organization. Conformance pack status is deleted when the management account deletes OrganizationConformancePack in all the member accounts and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>.</p>
    /// <p>Config sets the state of the conformance pack to:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_SUCCESSFUL</code> when an organization conformance pack has been successfully created in all the member accounts. </p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> when an organization conformance pack creation is in progress.</p> </li>
    /// <li> <p> <code>CREATE_FAILED</code> when an organization conformance pack creation failed in one or more member accounts within that organization.</p> </li>
    /// <li> <p> <code>DELETE_FAILED</code> when an organization conformance pack deletion failed in one or more member accounts within that organization.</p> </li>
    /// <li> <p> <code>DELETE_IN_PROGRESS</code> when an organization conformance pack deletion is in progress.</p> </li>
    /// <li> <p> <code>DELETE_SUCCESSFUL</code> when an organization conformance pack has been successfully deleted from all the member accounts.</p> </li>
    /// <li> <p> <code>UPDATE_SUCCESSFUL</code> when an organization conformance pack has been successfully updated in all the member accounts.</p> </li>
    /// <li> <p> <code>UPDATE_IN_PROGRESS</code> when an organization conformance pack update is in progress.</p> </li>
    /// <li> <p> <code>UPDATE_FAILED</code> when an organization conformance pack update failed in one or more member accounts within that organization.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::OrganizationResourceStatus>,
    /// <p>An error code that is returned when organization conformance pack creation or deletion has failed in a member account. </p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>An error message indicating that organization conformance pack creation or deletion failed due to an error. </p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>The timestamp of the last update.</p>
    #[doc(hidden)]
    pub last_update_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl OrganizationConformancePackStatus {
    /// <p>The name that you assign to organization conformance pack.</p>
    pub fn organization_conformance_pack_name(&self) -> std::option::Option<&str> {
        self.organization_conformance_pack_name.as_deref()
    }
    /// <p>Indicates deployment status of an organization conformance pack. When management account calls PutOrganizationConformancePack for the first time, conformance pack status is created in all the member accounts. When management account calls PutOrganizationConformancePack for the second time, conformance pack status is updated in all the member accounts. Additionally, conformance pack status is updated when one or more member accounts join or leave an organization. Conformance pack status is deleted when the management account deletes OrganizationConformancePack in all the member accounts and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>.</p>
    /// <p>Config sets the state of the conformance pack to:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_SUCCESSFUL</code> when an organization conformance pack has been successfully created in all the member accounts. </p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> when an organization conformance pack creation is in progress.</p> </li>
    /// <li> <p> <code>CREATE_FAILED</code> when an organization conformance pack creation failed in one or more member accounts within that organization.</p> </li>
    /// <li> <p> <code>DELETE_FAILED</code> when an organization conformance pack deletion failed in one or more member accounts within that organization.</p> </li>
    /// <li> <p> <code>DELETE_IN_PROGRESS</code> when an organization conformance pack deletion is in progress.</p> </li>
    /// <li> <p> <code>DELETE_SUCCESSFUL</code> when an organization conformance pack has been successfully deleted from all the member accounts.</p> </li>
    /// <li> <p> <code>UPDATE_SUCCESSFUL</code> when an organization conformance pack has been successfully updated in all the member accounts.</p> </li>
    /// <li> <p> <code>UPDATE_IN_PROGRESS</code> when an organization conformance pack update is in progress.</p> </li>
    /// <li> <p> <code>UPDATE_FAILED</code> when an organization conformance pack update failed in one or more member accounts within that organization.</p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::OrganizationResourceStatus> {
        self.status.as_ref()
    }
    /// <p>An error code that is returned when organization conformance pack creation or deletion has failed in a member account. </p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>An error message indicating that organization conformance pack creation or deletion failed due to an error. </p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>The timestamp of the last update.</p>
    pub fn last_update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_update_time.as_ref()
    }
}
impl OrganizationConformancePackStatus {
    /// Creates a new builder-style object to manufacture [`OrganizationConformancePackStatus`](crate::model::OrganizationConformancePackStatus).
    pub fn builder() -> crate::model::organization_conformance_pack_status::Builder {
        crate::model::organization_conformance_pack_status::Builder::default()
    }
}

/// See [`OrganizationConformancePackStatus`](crate::model::OrganizationConformancePackStatus).
pub mod organization_conformance_pack_status {

    /// A builder for [`OrganizationConformancePackStatus`](crate::model::OrganizationConformancePackStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) organization_conformance_pack_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::OrganizationResourceStatus>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) last_update_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name that you assign to organization conformance pack.</p>
        pub fn organization_conformance_pack_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.organization_conformance_pack_name = Some(input.into());
            self
        }
        /// <p>The name that you assign to organization conformance pack.</p>
        pub fn set_organization_conformance_pack_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.organization_conformance_pack_name = input;
            self
        }
        /// <p>Indicates deployment status of an organization conformance pack. When management account calls PutOrganizationConformancePack for the first time, conformance pack status is created in all the member accounts. When management account calls PutOrganizationConformancePack for the second time, conformance pack status is updated in all the member accounts. Additionally, conformance pack status is updated when one or more member accounts join or leave an organization. Conformance pack status is deleted when the management account deletes OrganizationConformancePack in all the member accounts and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>.</p>
        /// <p>Config sets the state of the conformance pack to:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_SUCCESSFUL</code> when an organization conformance pack has been successfully created in all the member accounts. </p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> when an organization conformance pack creation is in progress.</p> </li>
        /// <li> <p> <code>CREATE_FAILED</code> when an organization conformance pack creation failed in one or more member accounts within that organization.</p> </li>
        /// <li> <p> <code>DELETE_FAILED</code> when an organization conformance pack deletion failed in one or more member accounts within that organization.</p> </li>
        /// <li> <p> <code>DELETE_IN_PROGRESS</code> when an organization conformance pack deletion is in progress.</p> </li>
        /// <li> <p> <code>DELETE_SUCCESSFUL</code> when an organization conformance pack has been successfully deleted from all the member accounts.</p> </li>
        /// <li> <p> <code>UPDATE_SUCCESSFUL</code> when an organization conformance pack has been successfully updated in all the member accounts.</p> </li>
        /// <li> <p> <code>UPDATE_IN_PROGRESS</code> when an organization conformance pack update is in progress.</p> </li>
        /// <li> <p> <code>UPDATE_FAILED</code> when an organization conformance pack update failed in one or more member accounts within that organization.</p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::OrganizationResourceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Indicates deployment status of an organization conformance pack. When management account calls PutOrganizationConformancePack for the first time, conformance pack status is created in all the member accounts. When management account calls PutOrganizationConformancePack for the second time, conformance pack status is updated in all the member accounts. Additionally, conformance pack status is updated when one or more member accounts join or leave an organization. Conformance pack status is deleted when the management account deletes OrganizationConformancePack in all the member accounts and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>.</p>
        /// <p>Config sets the state of the conformance pack to:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_SUCCESSFUL</code> when an organization conformance pack has been successfully created in all the member accounts. </p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> when an organization conformance pack creation is in progress.</p> </li>
        /// <li> <p> <code>CREATE_FAILED</code> when an organization conformance pack creation failed in one or more member accounts within that organization.</p> </li>
        /// <li> <p> <code>DELETE_FAILED</code> when an organization conformance pack deletion failed in one or more member accounts within that organization.</p> </li>
        /// <li> <p> <code>DELETE_IN_PROGRESS</code> when an organization conformance pack deletion is in progress.</p> </li>
        /// <li> <p> <code>DELETE_SUCCESSFUL</code> when an organization conformance pack has been successfully deleted from all the member accounts.</p> </li>
        /// <li> <p> <code>UPDATE_SUCCESSFUL</code> when an organization conformance pack has been successfully updated in all the member accounts.</p> </li>
        /// <li> <p> <code>UPDATE_IN_PROGRESS</code> when an organization conformance pack update is in progress.</p> </li>
        /// <li> <p> <code>UPDATE_FAILED</code> when an organization conformance pack update failed in one or more member accounts within that organization.</p> </li>
        /// </ul>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OrganizationResourceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>An error code that is returned when organization conformance pack creation or deletion has failed in a member account. </p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>An error code that is returned when organization conformance pack creation or deletion has failed in a member account. </p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>An error message indicating that organization conformance pack creation or deletion failed due to an error. </p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>An error message indicating that organization conformance pack creation or deletion failed due to an error. </p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>The timestamp of the last update.</p>
        pub fn last_update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_update_time = Some(input);
            self
        }
        /// <p>The timestamp of the last update.</p>
        pub fn set_last_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_update_time = input;
            self
        }
        /// Consumes the builder and constructs a [`OrganizationConformancePackStatus`](crate::model::OrganizationConformancePackStatus).
        pub fn build(self) -> crate::model::OrganizationConformancePackStatus {
            crate::model::OrganizationConformancePackStatus {
                organization_conformance_pack_name: self.organization_conformance_pack_name,
                status: self.status,
                error_code: self.error_code,
                error_message: self.error_message,
                last_update_time: self.last_update_time,
            }
        }
    }
}

/// When writing a match expression against `OrganizationResourceStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let organizationresourcestatus = unimplemented!();
/// match organizationresourcestatus {
///     OrganizationResourceStatus::CreateFailed => { /* ... */ },
///     OrganizationResourceStatus::CreateInProgress => { /* ... */ },
///     OrganizationResourceStatus::CreateSuccessful => { /* ... */ },
///     OrganizationResourceStatus::DeleteFailed => { /* ... */ },
///     OrganizationResourceStatus::DeleteInProgress => { /* ... */ },
///     OrganizationResourceStatus::DeleteSuccessful => { /* ... */ },
///     OrganizationResourceStatus::UpdateFailed => { /* ... */ },
///     OrganizationResourceStatus::UpdateInProgress => { /* ... */ },
///     OrganizationResourceStatus::UpdateSuccessful => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `organizationresourcestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OrganizationResourceStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OrganizationResourceStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OrganizationResourceStatus::NewFeature` is defined.
/// Specifically, when `organizationresourcestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OrganizationResourceStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OrganizationResourceStatus {
    #[allow(missing_docs)] // documentation missing in model
    CreateFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    CreateSuccessful,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    DeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    DeleteSuccessful,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFailed,
    #[allow(missing_docs)] // documentation missing in model
    UpdateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    UpdateSuccessful,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OrganizationResourceStatus {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_FAILED" => OrganizationResourceStatus::CreateFailed,
            "CREATE_IN_PROGRESS" => OrganizationResourceStatus::CreateInProgress,
            "CREATE_SUCCESSFUL" => OrganizationResourceStatus::CreateSuccessful,
            "DELETE_FAILED" => OrganizationResourceStatus::DeleteFailed,
            "DELETE_IN_PROGRESS" => OrganizationResourceStatus::DeleteInProgress,
            "DELETE_SUCCESSFUL" => OrganizationResourceStatus::DeleteSuccessful,
            "UPDATE_FAILED" => OrganizationResourceStatus::UpdateFailed,
            "UPDATE_IN_PROGRESS" => OrganizationResourceStatus::UpdateInProgress,
            "UPDATE_SUCCESSFUL" => OrganizationResourceStatus::UpdateSuccessful,
            other => OrganizationResourceStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for OrganizationResourceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OrganizationResourceStatus::from(s))
    }
}
impl OrganizationResourceStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OrganizationResourceStatus::CreateFailed => "CREATE_FAILED",
            OrganizationResourceStatus::CreateInProgress => "CREATE_IN_PROGRESS",
            OrganizationResourceStatus::CreateSuccessful => "CREATE_SUCCESSFUL",
            OrganizationResourceStatus::DeleteFailed => "DELETE_FAILED",
            OrganizationResourceStatus::DeleteInProgress => "DELETE_IN_PROGRESS",
            OrganizationResourceStatus::DeleteSuccessful => "DELETE_SUCCESSFUL",
            OrganizationResourceStatus::UpdateFailed => "UPDATE_FAILED",
            OrganizationResourceStatus::UpdateInProgress => "UPDATE_IN_PROGRESS",
            OrganizationResourceStatus::UpdateSuccessful => "UPDATE_SUCCESSFUL",
            OrganizationResourceStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CREATE_FAILED",
            "CREATE_IN_PROGRESS",
            "CREATE_SUCCESSFUL",
            "DELETE_FAILED",
            "DELETE_IN_PROGRESS",
            "DELETE_SUCCESSFUL",
            "UPDATE_FAILED",
            "UPDATE_IN_PROGRESS",
            "UPDATE_SUCCESSFUL",
        ]
    }
}
impl AsRef<str> for OrganizationResourceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An organization conformance pack that has information about conformance packs that Config creates in member accounts. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OrganizationConformancePack {
    /// <p>The name you assign to an organization conformance pack.</p>
    #[doc(hidden)]
    pub organization_conformance_pack_name: std::option::Option<std::string::String>,
    /// <p>Amazon Resource Name (ARN) of organization conformance pack.</p>
    #[doc(hidden)]
    pub organization_conformance_pack_arn: std::option::Option<std::string::String>,
    /// <p>The name of the Amazon S3 bucket where Config stores conformance pack templates. </p> <note>
    /// <p>This field is optional.</p>
    /// </note>
    #[doc(hidden)]
    pub delivery_s3_bucket: std::option::Option<std::string::String>,
    /// <p>Any folder structure you want to add to an Amazon S3 bucket.</p> <note>
    /// <p>This field is optional.</p>
    /// </note>
    #[doc(hidden)]
    pub delivery_s3_key_prefix: std::option::Option<std::string::String>,
    /// <p>A list of <code>ConformancePackInputParameter</code> objects.</p>
    #[doc(hidden)]
    pub conformance_pack_input_parameters:
        std::option::Option<std::vec::Vec<crate::model::ConformancePackInputParameter>>,
    /// <p>A comma-separated list of accounts excluded from organization conformance pack.</p>
    #[doc(hidden)]
    pub excluded_accounts: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Last time when organization conformation pack was updated.</p>
    #[doc(hidden)]
    pub last_update_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl OrganizationConformancePack {
    /// <p>The name you assign to an organization conformance pack.</p>
    pub fn organization_conformance_pack_name(&self) -> std::option::Option<&str> {
        self.organization_conformance_pack_name.as_deref()
    }
    /// <p>Amazon Resource Name (ARN) of organization conformance pack.</p>
    pub fn organization_conformance_pack_arn(&self) -> std::option::Option<&str> {
        self.organization_conformance_pack_arn.as_deref()
    }
    /// <p>The name of the Amazon S3 bucket where Config stores conformance pack templates. </p> <note>
    /// <p>This field is optional.</p>
    /// </note>
    pub fn delivery_s3_bucket(&self) -> std::option::Option<&str> {
        self.delivery_s3_bucket.as_deref()
    }
    /// <p>Any folder structure you want to add to an Amazon S3 bucket.</p> <note>
    /// <p>This field is optional.</p>
    /// </note>
    pub fn delivery_s3_key_prefix(&self) -> std::option::Option<&str> {
        self.delivery_s3_key_prefix.as_deref()
    }
    /// <p>A list of <code>ConformancePackInputParameter</code> objects.</p>
    pub fn conformance_pack_input_parameters(
        &self,
    ) -> std::option::Option<&[crate::model::ConformancePackInputParameter]> {
        self.conformance_pack_input_parameters.as_deref()
    }
    /// <p>A comma-separated list of accounts excluded from organization conformance pack.</p>
    pub fn excluded_accounts(&self) -> std::option::Option<&[std::string::String]> {
        self.excluded_accounts.as_deref()
    }
    /// <p>Last time when organization conformation pack was updated.</p>
    pub fn last_update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_update_time.as_ref()
    }
}
impl OrganizationConformancePack {
    /// Creates a new builder-style object to manufacture [`OrganizationConformancePack`](crate::model::OrganizationConformancePack).
    pub fn builder() -> crate::model::organization_conformance_pack::Builder {
        crate::model::organization_conformance_pack::Builder::default()
    }
}

/// See [`OrganizationConformancePack`](crate::model::OrganizationConformancePack).
pub mod organization_conformance_pack {

    /// A builder for [`OrganizationConformancePack`](crate::model::OrganizationConformancePack).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) organization_conformance_pack_name: std::option::Option<std::string::String>,
        pub(crate) organization_conformance_pack_arn: std::option::Option<std::string::String>,
        pub(crate) delivery_s3_bucket: std::option::Option<std::string::String>,
        pub(crate) delivery_s3_key_prefix: std::option::Option<std::string::String>,
        pub(crate) conformance_pack_input_parameters:
            std::option::Option<std::vec::Vec<crate::model::ConformancePackInputParameter>>,
        pub(crate) excluded_accounts: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) last_update_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name you assign to an organization conformance pack.</p>
        pub fn organization_conformance_pack_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.organization_conformance_pack_name = Some(input.into());
            self
        }
        /// <p>The name you assign to an organization conformance pack.</p>
        pub fn set_organization_conformance_pack_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.organization_conformance_pack_name = input;
            self
        }
        /// <p>Amazon Resource Name (ARN) of organization conformance pack.</p>
        pub fn organization_conformance_pack_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.organization_conformance_pack_arn = Some(input.into());
            self
        }
        /// <p>Amazon Resource Name (ARN) of organization conformance pack.</p>
        pub fn set_organization_conformance_pack_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.organization_conformance_pack_arn = input;
            self
        }
        /// <p>The name of the Amazon S3 bucket where Config stores conformance pack templates. </p> <note>
        /// <p>This field is optional.</p>
        /// </note>
        pub fn delivery_s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.delivery_s3_bucket = Some(input.into());
            self
        }
        /// <p>The name of the Amazon S3 bucket where Config stores conformance pack templates. </p> <note>
        /// <p>This field is optional.</p>
        /// </note>
        pub fn set_delivery_s3_bucket(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.delivery_s3_bucket = input;
            self
        }
        /// <p>Any folder structure you want to add to an Amazon S3 bucket.</p> <note>
        /// <p>This field is optional.</p>
        /// </note>
        pub fn delivery_s3_key_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.delivery_s3_key_prefix = Some(input.into());
            self
        }
        /// <p>Any folder structure you want to add to an Amazon S3 bucket.</p> <note>
        /// <p>This field is optional.</p>
        /// </note>
        pub fn set_delivery_s3_key_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.delivery_s3_key_prefix = input;
            self
        }
        /// Appends an item to `conformance_pack_input_parameters`.
        ///
        /// To override the contents of this collection use [`set_conformance_pack_input_parameters`](Self::set_conformance_pack_input_parameters).
        ///
        /// <p>A list of <code>ConformancePackInputParameter</code> objects.</p>
        pub fn conformance_pack_input_parameters(
            mut self,
            input: crate::model::ConformancePackInputParameter,
        ) -> Self {
            let mut v = self.conformance_pack_input_parameters.unwrap_or_default();
            v.push(input);
            self.conformance_pack_input_parameters = Some(v);
            self
        }
        /// <p>A list of <code>ConformancePackInputParameter</code> objects.</p>
        pub fn set_conformance_pack_input_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ConformancePackInputParameter>>,
        ) -> Self {
            self.conformance_pack_input_parameters = input;
            self
        }
        /// Appends an item to `excluded_accounts`.
        ///
        /// To override the contents of this collection use [`set_excluded_accounts`](Self::set_excluded_accounts).
        ///
        /// <p>A comma-separated list of accounts excluded from organization conformance pack.</p>
        pub fn excluded_accounts(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.excluded_accounts.unwrap_or_default();
            v.push(input.into());
            self.excluded_accounts = Some(v);
            self
        }
        /// <p>A comma-separated list of accounts excluded from organization conformance pack.</p>
        pub fn set_excluded_accounts(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.excluded_accounts = input;
            self
        }
        /// <p>Last time when organization conformation pack was updated.</p>
        pub fn last_update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_update_time = Some(input);
            self
        }
        /// <p>Last time when organization conformation pack was updated.</p>
        pub fn set_last_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_update_time = input;
            self
        }
        /// Consumes the builder and constructs a [`OrganizationConformancePack`](crate::model::OrganizationConformancePack).
        pub fn build(self) -> crate::model::OrganizationConformancePack {
            crate::model::OrganizationConformancePack {
                organization_conformance_pack_name: self.organization_conformance_pack_name,
                organization_conformance_pack_arn: self.organization_conformance_pack_arn,
                delivery_s3_bucket: self.delivery_s3_bucket,
                delivery_s3_key_prefix: self.delivery_s3_key_prefix,
                conformance_pack_input_parameters: self.conformance_pack_input_parameters,
                excluded_accounts: self.excluded_accounts,
                last_update_time: self.last_update_time,
            }
        }
    }
}

/// <p>Returns the status for an organization Config rule in an organization.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OrganizationConfigRuleStatus {
    /// <p>The name that you assign to organization Config rule.</p>
    #[doc(hidden)]
    pub organization_config_rule_name: std::option::Option<std::string::String>,
    /// <p>Indicates deployment status of an organization Config rule. When management account calls PutOrganizationConfigRule action for the first time, Config rule status is created in all the member accounts. When management account calls PutOrganizationConfigRule action for the second time, Config rule status is updated in all the member accounts. Additionally, Config rule status is updated when one or more member accounts join or leave an organization. Config rule status is deleted when the management account deletes OrganizationConfigRule in all the member accounts and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>.</p>
    /// <p>Config sets the state of the rule to:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_SUCCESSFUL</code> when an organization Config rule has been successfully created in all the member accounts. </p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> when an organization Config rule creation is in progress.</p> </li>
    /// <li> <p> <code>CREATE_FAILED</code> when an organization Config rule creation failed in one or more member accounts within that organization.</p> </li>
    /// <li> <p> <code>DELETE_FAILED</code> when an organization Config rule deletion failed in one or more member accounts within that organization.</p> </li>
    /// <li> <p> <code>DELETE_IN_PROGRESS</code> when an organization Config rule deletion is in progress.</p> </li>
    /// <li> <p> <code>DELETE_SUCCESSFUL</code> when an organization Config rule has been successfully deleted from all the member accounts.</p> </li>
    /// <li> <p> <code>UPDATE_SUCCESSFUL</code> when an organization Config rule has been successfully updated in all the member accounts.</p> </li>
    /// <li> <p> <code>UPDATE_IN_PROGRESS</code> when an organization Config rule update is in progress.</p> </li>
    /// <li> <p> <code>UPDATE_FAILED</code> when an organization Config rule update failed in one or more member accounts within that organization.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub organization_rule_status: std::option::Option<crate::model::OrganizationRuleStatus>,
    /// <p>An error code that is returned when organization Config rule creation or deletion has failed.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>An error message indicating that organization Config rule creation or deletion failed due to an error.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>The timestamp of the last update.</p>
    #[doc(hidden)]
    pub last_update_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl OrganizationConfigRuleStatus {
    /// <p>The name that you assign to organization Config rule.</p>
    pub fn organization_config_rule_name(&self) -> std::option::Option<&str> {
        self.organization_config_rule_name.as_deref()
    }
    /// <p>Indicates deployment status of an organization Config rule. When management account calls PutOrganizationConfigRule action for the first time, Config rule status is created in all the member accounts. When management account calls PutOrganizationConfigRule action for the second time, Config rule status is updated in all the member accounts. Additionally, Config rule status is updated when one or more member accounts join or leave an organization. Config rule status is deleted when the management account deletes OrganizationConfigRule in all the member accounts and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>.</p>
    /// <p>Config sets the state of the rule to:</p>
    /// <ul>
    /// <li> <p> <code>CREATE_SUCCESSFUL</code> when an organization Config rule has been successfully created in all the member accounts. </p> </li>
    /// <li> <p> <code>CREATE_IN_PROGRESS</code> when an organization Config rule creation is in progress.</p> </li>
    /// <li> <p> <code>CREATE_FAILED</code> when an organization Config rule creation failed in one or more member accounts within that organization.</p> </li>
    /// <li> <p> <code>DELETE_FAILED</code> when an organization Config rule deletion failed in one or more member accounts within that organization.</p> </li>
    /// <li> <p> <code>DELETE_IN_PROGRESS</code> when an organization Config rule deletion is in progress.</p> </li>
    /// <li> <p> <code>DELETE_SUCCESSFUL</code> when an organization Config rule has been successfully deleted from all the member accounts.</p> </li>
    /// <li> <p> <code>UPDATE_SUCCESSFUL</code> when an organization Config rule has been successfully updated in all the member accounts.</p> </li>
    /// <li> <p> <code>UPDATE_IN_PROGRESS</code> when an organization Config rule update is in progress.</p> </li>
    /// <li> <p> <code>UPDATE_FAILED</code> when an organization Config rule update failed in one or more member accounts within that organization.</p> </li>
    /// </ul>
    pub fn organization_rule_status(
        &self,
    ) -> std::option::Option<&crate::model::OrganizationRuleStatus> {
        self.organization_rule_status.as_ref()
    }
    /// <p>An error code that is returned when organization Config rule creation or deletion has failed.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>An error message indicating that organization Config rule creation or deletion failed due to an error.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>The timestamp of the last update.</p>
    pub fn last_update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_update_time.as_ref()
    }
}
impl OrganizationConfigRuleStatus {
    /// Creates a new builder-style object to manufacture [`OrganizationConfigRuleStatus`](crate::model::OrganizationConfigRuleStatus).
    pub fn builder() -> crate::model::organization_config_rule_status::Builder {
        crate::model::organization_config_rule_status::Builder::default()
    }
}

/// See [`OrganizationConfigRuleStatus`](crate::model::OrganizationConfigRuleStatus).
pub mod organization_config_rule_status {

    /// A builder for [`OrganizationConfigRuleStatus`](crate::model::OrganizationConfigRuleStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) organization_config_rule_name: std::option::Option<std::string::String>,
        pub(crate) organization_rule_status:
            std::option::Option<crate::model::OrganizationRuleStatus>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) last_update_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name that you assign to organization Config rule.</p>
        pub fn organization_config_rule_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.organization_config_rule_name = Some(input.into());
            self
        }
        /// <p>The name that you assign to organization Config rule.</p>
        pub fn set_organization_config_rule_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.organization_config_rule_name = input;
            self
        }
        /// <p>Indicates deployment status of an organization Config rule. When management account calls PutOrganizationConfigRule action for the first time, Config rule status is created in all the member accounts. When management account calls PutOrganizationConfigRule action for the second time, Config rule status is updated in all the member accounts. Additionally, Config rule status is updated when one or more member accounts join or leave an organization. Config rule status is deleted when the management account deletes OrganizationConfigRule in all the member accounts and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>.</p>
        /// <p>Config sets the state of the rule to:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_SUCCESSFUL</code> when an organization Config rule has been successfully created in all the member accounts. </p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> when an organization Config rule creation is in progress.</p> </li>
        /// <li> <p> <code>CREATE_FAILED</code> when an organization Config rule creation failed in one or more member accounts within that organization.</p> </li>
        /// <li> <p> <code>DELETE_FAILED</code> when an organization Config rule deletion failed in one or more member accounts within that organization.</p> </li>
        /// <li> <p> <code>DELETE_IN_PROGRESS</code> when an organization Config rule deletion is in progress.</p> </li>
        /// <li> <p> <code>DELETE_SUCCESSFUL</code> when an organization Config rule has been successfully deleted from all the member accounts.</p> </li>
        /// <li> <p> <code>UPDATE_SUCCESSFUL</code> when an organization Config rule has been successfully updated in all the member accounts.</p> </li>
        /// <li> <p> <code>UPDATE_IN_PROGRESS</code> when an organization Config rule update is in progress.</p> </li>
        /// <li> <p> <code>UPDATE_FAILED</code> when an organization Config rule update failed in one or more member accounts within that organization.</p> </li>
        /// </ul>
        pub fn organization_rule_status(
            mut self,
            input: crate::model::OrganizationRuleStatus,
        ) -> Self {
            self.organization_rule_status = Some(input);
            self
        }
        /// <p>Indicates deployment status of an organization Config rule. When management account calls PutOrganizationConfigRule action for the first time, Config rule status is created in all the member accounts. When management account calls PutOrganizationConfigRule action for the second time, Config rule status is updated in all the member accounts. Additionally, Config rule status is updated when one or more member accounts join or leave an organization. Config rule status is deleted when the management account deletes OrganizationConfigRule in all the member accounts and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>.</p>
        /// <p>Config sets the state of the rule to:</p>
        /// <ul>
        /// <li> <p> <code>CREATE_SUCCESSFUL</code> when an organization Config rule has been successfully created in all the member accounts. </p> </li>
        /// <li> <p> <code>CREATE_IN_PROGRESS</code> when an organization Config rule creation is in progress.</p> </li>
        /// <li> <p> <code>CREATE_FAILED</code> when an organization Config rule creation failed in one or more member accounts within that organization.</p> </li>
        /// <li> <p> <code>DELETE_FAILED</code> when an organization Config rule deletion failed in one or more member accounts within that organization.</p> </li>
        /// <li> <p> <code>DELETE_IN_PROGRESS</code> when an organization Config rule deletion is in progress.</p> </li>
        /// <li> <p> <code>DELETE_SUCCESSFUL</code> when an organization Config rule has been successfully deleted from all the member accounts.</p> </li>
        /// <li> <p> <code>UPDATE_SUCCESSFUL</code> when an organization Config rule has been successfully updated in all the member accounts.</p> </li>
        /// <li> <p> <code>UPDATE_IN_PROGRESS</code> when an organization Config rule update is in progress.</p> </li>
        /// <li> <p> <code>UPDATE_FAILED</code> when an organization Config rule update failed in one or more member accounts within that organization.</p> </li>
        /// </ul>
        pub fn set_organization_rule_status(
            mut self,
            input: std::option::Option<crate::model::OrganizationRuleStatus>,
        ) -> Self {
            self.organization_rule_status = input;
            self
        }
        /// <p>An error code that is returned when organization Config rule creation or deletion has failed.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>An error code that is returned when organization Config rule creation or deletion has failed.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>An error message indicating that organization Config rule creation or deletion failed due to an error.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>An error message indicating that organization Config rule creation or deletion failed due to an error.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>The timestamp of the last update.</p>
        pub fn last_update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_update_time = Some(input);
            self
        }
        /// <p>The timestamp of the last update.</p>
        pub fn set_last_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_update_time = input;
            self
        }
        /// Consumes the builder and constructs a [`OrganizationConfigRuleStatus`](crate::model::OrganizationConfigRuleStatus).
        pub fn build(self) -> crate::model::OrganizationConfigRuleStatus {
            crate::model::OrganizationConfigRuleStatus {
                organization_config_rule_name: self.organization_config_rule_name,
                organization_rule_status: self.organization_rule_status,
                error_code: self.error_code,
                error_message: self.error_message,
                last_update_time: self.last_update_time,
            }
        }
    }
}

/// When writing a match expression against `OrganizationRuleStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let organizationrulestatus = unimplemented!();
/// match organizationrulestatus {
///     OrganizationRuleStatus::CreateFailed => { /* ... */ },
///     OrganizationRuleStatus::CreateInProgress => { /* ... */ },
///     OrganizationRuleStatus::CreateSuccessful => { /* ... */ },
///     OrganizationRuleStatus::DeleteFailed => { /* ... */ },
///     OrganizationRuleStatus::DeleteInProgress => { /* ... */ },
///     OrganizationRuleStatus::DeleteSuccessful => { /* ... */ },
///     OrganizationRuleStatus::UpdateFailed => { /* ... */ },
///     OrganizationRuleStatus::UpdateInProgress => { /* ... */ },
///     OrganizationRuleStatus::UpdateSuccessful => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `organizationrulestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OrganizationRuleStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OrganizationRuleStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OrganizationRuleStatus::NewFeature` is defined.
/// Specifically, when `organizationrulestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OrganizationRuleStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OrganizationRuleStatus {
    #[allow(missing_docs)] // documentation missing in model
    CreateFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    CreateSuccessful,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    DeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    DeleteSuccessful,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFailed,
    #[allow(missing_docs)] // documentation missing in model
    UpdateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    UpdateSuccessful,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OrganizationRuleStatus {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_FAILED" => OrganizationRuleStatus::CreateFailed,
            "CREATE_IN_PROGRESS" => OrganizationRuleStatus::CreateInProgress,
            "CREATE_SUCCESSFUL" => OrganizationRuleStatus::CreateSuccessful,
            "DELETE_FAILED" => OrganizationRuleStatus::DeleteFailed,
            "DELETE_IN_PROGRESS" => OrganizationRuleStatus::DeleteInProgress,
            "DELETE_SUCCESSFUL" => OrganizationRuleStatus::DeleteSuccessful,
            "UPDATE_FAILED" => OrganizationRuleStatus::UpdateFailed,
            "UPDATE_IN_PROGRESS" => OrganizationRuleStatus::UpdateInProgress,
            "UPDATE_SUCCESSFUL" => OrganizationRuleStatus::UpdateSuccessful,
            other => {
                OrganizationRuleStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for OrganizationRuleStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OrganizationRuleStatus::from(s))
    }
}
impl OrganizationRuleStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OrganizationRuleStatus::CreateFailed => "CREATE_FAILED",
            OrganizationRuleStatus::CreateInProgress => "CREATE_IN_PROGRESS",
            OrganizationRuleStatus::CreateSuccessful => "CREATE_SUCCESSFUL",
            OrganizationRuleStatus::DeleteFailed => "DELETE_FAILED",
            OrganizationRuleStatus::DeleteInProgress => "DELETE_IN_PROGRESS",
            OrganizationRuleStatus::DeleteSuccessful => "DELETE_SUCCESSFUL",
            OrganizationRuleStatus::UpdateFailed => "UPDATE_FAILED",
            OrganizationRuleStatus::UpdateInProgress => "UPDATE_IN_PROGRESS",
            OrganizationRuleStatus::UpdateSuccessful => "UPDATE_SUCCESSFUL",
            OrganizationRuleStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CREATE_FAILED",
            "CREATE_IN_PROGRESS",
            "CREATE_SUCCESSFUL",
            "DELETE_FAILED",
            "DELETE_IN_PROGRESS",
            "DELETE_SUCCESSFUL",
            "UPDATE_FAILED",
            "UPDATE_IN_PROGRESS",
            "UPDATE_SUCCESSFUL",
        ]
    }
}
impl AsRef<str> for OrganizationRuleStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An organization Config rule that has information about Config rules that Config creates in member accounts.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OrganizationConfigRule {
    /// <p>The name that you assign to organization Config rule.</p>
    #[doc(hidden)]
    pub organization_config_rule_name: std::option::Option<std::string::String>,
    /// <p>Amazon Resource Name (ARN) of organization Config rule.</p>
    #[doc(hidden)]
    pub organization_config_rule_arn: std::option::Option<std::string::String>,
    /// <p>An <code>OrganizationManagedRuleMetadata</code> object.</p>
    #[doc(hidden)]
    pub organization_managed_rule_metadata:
        std::option::Option<crate::model::OrganizationManagedRuleMetadata>,
    /// <p>An <code>OrganizationCustomRuleMetadata</code> object.</p>
    #[doc(hidden)]
    pub organization_custom_rule_metadata:
        std::option::Option<crate::model::OrganizationCustomRuleMetadata>,
    /// <p>A comma-separated list of accounts excluded from organization Config rule.</p>
    #[doc(hidden)]
    pub excluded_accounts: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The timestamp of the last update.</p>
    #[doc(hidden)]
    pub last_update_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>An object that specifies metadata for your organization's Config Custom Policy rule. The metadata includes the runtime system in use, which accounts have debug logging enabled, and other custom rule metadata, such as resource type, resource ID of Amazon Web Services resource, and organization trigger types that initiate Config to evaluate Amazon Web Services resources against a rule.</p>
    #[doc(hidden)]
    pub organization_custom_policy_rule_metadata:
        std::option::Option<crate::model::OrganizationCustomPolicyRuleMetadataNoPolicy>,
}
impl OrganizationConfigRule {
    /// <p>The name that you assign to organization Config rule.</p>
    pub fn organization_config_rule_name(&self) -> std::option::Option<&str> {
        self.organization_config_rule_name.as_deref()
    }
    /// <p>Amazon Resource Name (ARN) of organization Config rule.</p>
    pub fn organization_config_rule_arn(&self) -> std::option::Option<&str> {
        self.organization_config_rule_arn.as_deref()
    }
    /// <p>An <code>OrganizationManagedRuleMetadata</code> object.</p>
    pub fn organization_managed_rule_metadata(
        &self,
    ) -> std::option::Option<&crate::model::OrganizationManagedRuleMetadata> {
        self.organization_managed_rule_metadata.as_ref()
    }
    /// <p>An <code>OrganizationCustomRuleMetadata</code> object.</p>
    pub fn organization_custom_rule_metadata(
        &self,
    ) -> std::option::Option<&crate::model::OrganizationCustomRuleMetadata> {
        self.organization_custom_rule_metadata.as_ref()
    }
    /// <p>A comma-separated list of accounts excluded from organization Config rule.</p>
    pub fn excluded_accounts(&self) -> std::option::Option<&[std::string::String]> {
        self.excluded_accounts.as_deref()
    }
    /// <p>The timestamp of the last update.</p>
    pub fn last_update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_update_time.as_ref()
    }
    /// <p>An object that specifies metadata for your organization's Config Custom Policy rule. The metadata includes the runtime system in use, which accounts have debug logging enabled, and other custom rule metadata, such as resource type, resource ID of Amazon Web Services resource, and organization trigger types that initiate Config to evaluate Amazon Web Services resources against a rule.</p>
    pub fn organization_custom_policy_rule_metadata(
        &self,
    ) -> std::option::Option<&crate::model::OrganizationCustomPolicyRuleMetadataNoPolicy> {
        self.organization_custom_policy_rule_metadata.as_ref()
    }
}
impl OrganizationConfigRule {
    /// Creates a new builder-style object to manufacture [`OrganizationConfigRule`](crate::model::OrganizationConfigRule).
    pub fn builder() -> crate::model::organization_config_rule::Builder {
        crate::model::organization_config_rule::Builder::default()
    }
}

/// See [`OrganizationConfigRule`](crate::model::OrganizationConfigRule).
pub mod organization_config_rule {

    /// A builder for [`OrganizationConfigRule`](crate::model::OrganizationConfigRule).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) organization_config_rule_name: std::option::Option<std::string::String>,
        pub(crate) organization_config_rule_arn: std::option::Option<std::string::String>,
        pub(crate) organization_managed_rule_metadata:
            std::option::Option<crate::model::OrganizationManagedRuleMetadata>,
        pub(crate) organization_custom_rule_metadata:
            std::option::Option<crate::model::OrganizationCustomRuleMetadata>,
        pub(crate) excluded_accounts: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) last_update_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) organization_custom_policy_rule_metadata:
            std::option::Option<crate::model::OrganizationCustomPolicyRuleMetadataNoPolicy>,
    }
    impl Builder {
        /// <p>The name that you assign to organization Config rule.</p>
        pub fn organization_config_rule_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.organization_config_rule_name = Some(input.into());
            self
        }
        /// <p>The name that you assign to organization Config rule.</p>
        pub fn set_organization_config_rule_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.organization_config_rule_name = input;
            self
        }
        /// <p>Amazon Resource Name (ARN) of organization Config rule.</p>
        pub fn organization_config_rule_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.organization_config_rule_arn = Some(input.into());
            self
        }
        /// <p>Amazon Resource Name (ARN) of organization Config rule.</p>
        pub fn set_organization_config_rule_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.organization_config_rule_arn = input;
            self
        }
        /// <p>An <code>OrganizationManagedRuleMetadata</code> object.</p>
        pub fn organization_managed_rule_metadata(
            mut self,
            input: crate::model::OrganizationManagedRuleMetadata,
        ) -> Self {
            self.organization_managed_rule_metadata = Some(input);
            self
        }
        /// <p>An <code>OrganizationManagedRuleMetadata</code> object.</p>
        pub fn set_organization_managed_rule_metadata(
            mut self,
            input: std::option::Option<crate::model::OrganizationManagedRuleMetadata>,
        ) -> Self {
            self.organization_managed_rule_metadata = input;
            self
        }
        /// <p>An <code>OrganizationCustomRuleMetadata</code> object.</p>
        pub fn organization_custom_rule_metadata(
            mut self,
            input: crate::model::OrganizationCustomRuleMetadata,
        ) -> Self {
            self.organization_custom_rule_metadata = Some(input);
            self
        }
        /// <p>An <code>OrganizationCustomRuleMetadata</code> object.</p>
        pub fn set_organization_custom_rule_metadata(
            mut self,
            input: std::option::Option<crate::model::OrganizationCustomRuleMetadata>,
        ) -> Self {
            self.organization_custom_rule_metadata = input;
            self
        }
        /// Appends an item to `excluded_accounts`.
        ///
        /// To override the contents of this collection use [`set_excluded_accounts`](Self::set_excluded_accounts).
        ///
        /// <p>A comma-separated list of accounts excluded from organization Config rule.</p>
        pub fn excluded_accounts(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.excluded_accounts.unwrap_or_default();
            v.push(input.into());
            self.excluded_accounts = Some(v);
            self
        }
        /// <p>A comma-separated list of accounts excluded from organization Config rule.</p>
        pub fn set_excluded_accounts(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.excluded_accounts = input;
            self
        }
        /// <p>The timestamp of the last update.</p>
        pub fn last_update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_update_time = Some(input);
            self
        }
        /// <p>The timestamp of the last update.</p>
        pub fn set_last_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_update_time = input;
            self
        }
        /// <p>An object that specifies metadata for your organization's Config Custom Policy rule. The metadata includes the runtime system in use, which accounts have debug logging enabled, and other custom rule metadata, such as resource type, resource ID of Amazon Web Services resource, and organization trigger types that initiate Config to evaluate Amazon Web Services resources against a rule.</p>
        pub fn organization_custom_policy_rule_metadata(
            mut self,
            input: crate::model::OrganizationCustomPolicyRuleMetadataNoPolicy,
        ) -> Self {
            self.organization_custom_policy_rule_metadata = Some(input);
            self
        }
        /// <p>An object that specifies metadata for your organization's Config Custom Policy rule. The metadata includes the runtime system in use, which accounts have debug logging enabled, and other custom rule metadata, such as resource type, resource ID of Amazon Web Services resource, and organization trigger types that initiate Config to evaluate Amazon Web Services resources against a rule.</p>
        pub fn set_organization_custom_policy_rule_metadata(
            mut self,
            input: std::option::Option<crate::model::OrganizationCustomPolicyRuleMetadataNoPolicy>,
        ) -> Self {
            self.organization_custom_policy_rule_metadata = input;
            self
        }
        /// Consumes the builder and constructs a [`OrganizationConfigRule`](crate::model::OrganizationConfigRule).
        pub fn build(self) -> crate::model::OrganizationConfigRule {
            crate::model::OrganizationConfigRule {
                organization_config_rule_name: self.organization_config_rule_name,
                organization_config_rule_arn: self.organization_config_rule_arn,
                organization_managed_rule_metadata: self.organization_managed_rule_metadata,
                organization_custom_rule_metadata: self.organization_custom_rule_metadata,
                excluded_accounts: self.excluded_accounts,
                last_update_time: self.last_update_time,
                organization_custom_policy_rule_metadata: self
                    .organization_custom_policy_rule_metadata,
            }
        }
    }
}

/// <p>An object that specifies metadata for your organization Config Custom Policy rule including the runtime system in use, which accounts have debug logging enabled, and other custom rule metadata such as resource type, resource ID of Amazon Web Services resource, and organization trigger types that trigger Config to evaluate Amazon Web Services resources against a rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OrganizationCustomPolicyRuleMetadataNoPolicy {
    /// <p>The description that you provide for your organization Config Custom Policy rule.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of notification that triggers Config to run an evaluation for a rule. For Config Custom Policy rules, Config supports change triggered notification types:</p>
    /// <ul>
    /// <li> <p> <code>ConfigurationItemChangeNotification</code> - Triggers an evaluation when Config delivers a configuration item as a result of a resource change.</p> </li>
    /// <li> <p> <code>OversizedConfigurationItemChangeNotification</code> - Triggers an evaluation when Config delivers an oversized configuration item. Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub organization_config_rule_trigger_types:
        std::option::Option<std::vec::Vec<crate::model::OrganizationConfigRuleTriggerTypeNoSn>>,
    /// <p>A string, in JSON format, that is passed to your organization Config Custom Policy rule.</p>
    #[doc(hidden)]
    pub input_parameters: std::option::Option<std::string::String>,
    /// <p>The maximum frequency with which Config runs evaluations for a rule. Your Config Custom Policy rule is triggered when Config delivers the configuration snapshot. For more information, see <code>ConfigSnapshotDeliveryProperties</code>.</p>
    #[doc(hidden)]
    pub maximum_execution_frequency: std::option::Option<crate::model::MaximumExecutionFrequency>,
    /// <p>The type of the Amazon Web Services resource that was evaluated.</p>
    #[doc(hidden)]
    pub resource_types_scope: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the Amazon Web Services resource that was evaluated.</p>
    #[doc(hidden)]
    pub resource_id_scope: std::option::Option<std::string::String>,
    /// <p>One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.</p>
    #[doc(hidden)]
    pub tag_key_scope: std::option::Option<std::string::String>,
    /// <p>The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).</p>
    #[doc(hidden)]
    pub tag_value_scope: std::option::Option<std::string::String>,
    /// <p>The runtime system for your organization Config Custom Policy rules. Guard is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. For more information about Guard, see the <a href="https://github.com/aws-cloudformation/cloudformation-guard">Guard GitHub Repository</a>.</p>
    #[doc(hidden)]
    pub policy_runtime: std::option::Option<std::string::String>,
    /// <p>A list of accounts that you can enable debug logging for your organization Config Custom Policy rule. List is null when debug logging is enabled for all accounts.</p>
    #[doc(hidden)]
    pub debug_log_delivery_accounts: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl OrganizationCustomPolicyRuleMetadataNoPolicy {
    /// <p>The description that you provide for your organization Config Custom Policy rule.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of notification that triggers Config to run an evaluation for a rule. For Config Custom Policy rules, Config supports change triggered notification types:</p>
    /// <ul>
    /// <li> <p> <code>ConfigurationItemChangeNotification</code> - Triggers an evaluation when Config delivers a configuration item as a result of a resource change.</p> </li>
    /// <li> <p> <code>OversizedConfigurationItemChangeNotification</code> - Triggers an evaluation when Config delivers an oversized configuration item. Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.</p> </li>
    /// </ul>
    pub fn organization_config_rule_trigger_types(
        &self,
    ) -> std::option::Option<&[crate::model::OrganizationConfigRuleTriggerTypeNoSn]> {
        self.organization_config_rule_trigger_types.as_deref()
    }
    /// <p>A string, in JSON format, that is passed to your organization Config Custom Policy rule.</p>
    pub fn input_parameters(&self) -> std::option::Option<&str> {
        self.input_parameters.as_deref()
    }
    /// <p>The maximum frequency with which Config runs evaluations for a rule. Your Config Custom Policy rule is triggered when Config delivers the configuration snapshot. For more information, see <code>ConfigSnapshotDeliveryProperties</code>.</p>
    pub fn maximum_execution_frequency(
        &self,
    ) -> std::option::Option<&crate::model::MaximumExecutionFrequency> {
        self.maximum_execution_frequency.as_ref()
    }
    /// <p>The type of the Amazon Web Services resource that was evaluated.</p>
    pub fn resource_types_scope(&self) -> std::option::Option<&[std::string::String]> {
        self.resource_types_scope.as_deref()
    }
    /// <p>The ID of the Amazon Web Services resource that was evaluated.</p>
    pub fn resource_id_scope(&self) -> std::option::Option<&str> {
        self.resource_id_scope.as_deref()
    }
    /// <p>One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.</p>
    pub fn tag_key_scope(&self) -> std::option::Option<&str> {
        self.tag_key_scope.as_deref()
    }
    /// <p>The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).</p>
    pub fn tag_value_scope(&self) -> std::option::Option<&str> {
        self.tag_value_scope.as_deref()
    }
    /// <p>The runtime system for your organization Config Custom Policy rules. Guard is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. For more information about Guard, see the <a href="https://github.com/aws-cloudformation/cloudformation-guard">Guard GitHub Repository</a>.</p>
    pub fn policy_runtime(&self) -> std::option::Option<&str> {
        self.policy_runtime.as_deref()
    }
    /// <p>A list of accounts that you can enable debug logging for your organization Config Custom Policy rule. List is null when debug logging is enabled for all accounts.</p>
    pub fn debug_log_delivery_accounts(&self) -> std::option::Option<&[std::string::String]> {
        self.debug_log_delivery_accounts.as_deref()
    }
}
impl OrganizationCustomPolicyRuleMetadataNoPolicy {
    /// Creates a new builder-style object to manufacture [`OrganizationCustomPolicyRuleMetadataNoPolicy`](crate::model::OrganizationCustomPolicyRuleMetadataNoPolicy).
    pub fn builder() -> crate::model::organization_custom_policy_rule_metadata_no_policy::Builder {
        crate::model::organization_custom_policy_rule_metadata_no_policy::Builder::default()
    }
}

/// See [`OrganizationCustomPolicyRuleMetadataNoPolicy`](crate::model::OrganizationCustomPolicyRuleMetadataNoPolicy).
pub mod organization_custom_policy_rule_metadata_no_policy {

    /// A builder for [`OrganizationCustomPolicyRuleMetadataNoPolicy`](crate::model::OrganizationCustomPolicyRuleMetadataNoPolicy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) organization_config_rule_trigger_types:
            std::option::Option<std::vec::Vec<crate::model::OrganizationConfigRuleTriggerTypeNoSn>>,
        pub(crate) input_parameters: std::option::Option<std::string::String>,
        pub(crate) maximum_execution_frequency:
            std::option::Option<crate::model::MaximumExecutionFrequency>,
        pub(crate) resource_types_scope: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) resource_id_scope: std::option::Option<std::string::String>,
        pub(crate) tag_key_scope: std::option::Option<std::string::String>,
        pub(crate) tag_value_scope: std::option::Option<std::string::String>,
        pub(crate) policy_runtime: std::option::Option<std::string::String>,
        pub(crate) debug_log_delivery_accounts:
            std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The description that you provide for your organization Config Custom Policy rule.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description that you provide for your organization Config Custom Policy rule.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `organization_config_rule_trigger_types`.
        ///
        /// To override the contents of this collection use [`set_organization_config_rule_trigger_types`](Self::set_organization_config_rule_trigger_types).
        ///
        /// <p>The type of notification that triggers Config to run an evaluation for a rule. For Config Custom Policy rules, Config supports change triggered notification types:</p>
        /// <ul>
        /// <li> <p> <code>ConfigurationItemChangeNotification</code> - Triggers an evaluation when Config delivers a configuration item as a result of a resource change.</p> </li>
        /// <li> <p> <code>OversizedConfigurationItemChangeNotification</code> - Triggers an evaluation when Config delivers an oversized configuration item. Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.</p> </li>
        /// </ul>
        pub fn organization_config_rule_trigger_types(
            mut self,
            input: crate::model::OrganizationConfigRuleTriggerTypeNoSn,
        ) -> Self {
            let mut v = self
                .organization_config_rule_trigger_types
                .unwrap_or_default();
            v.push(input);
            self.organization_config_rule_trigger_types = Some(v);
            self
        }
        /// <p>The type of notification that triggers Config to run an evaluation for a rule. For Config Custom Policy rules, Config supports change triggered notification types:</p>
        /// <ul>
        /// <li> <p> <code>ConfigurationItemChangeNotification</code> - Triggers an evaluation when Config delivers a configuration item as a result of a resource change.</p> </li>
        /// <li> <p> <code>OversizedConfigurationItemChangeNotification</code> - Triggers an evaluation when Config delivers an oversized configuration item. Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.</p> </li>
        /// </ul>
        pub fn set_organization_config_rule_trigger_types(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::OrganizationConfigRuleTriggerTypeNoSn>,
            >,
        ) -> Self {
            self.organization_config_rule_trigger_types = input;
            self
        }
        /// <p>A string, in JSON format, that is passed to your organization Config Custom Policy rule.</p>
        pub fn input_parameters(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_parameters = Some(input.into());
            self
        }
        /// <p>A string, in JSON format, that is passed to your organization Config Custom Policy rule.</p>
        pub fn set_input_parameters(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.input_parameters = input;
            self
        }
        /// <p>The maximum frequency with which Config runs evaluations for a rule. Your Config Custom Policy rule is triggered when Config delivers the configuration snapshot. For more information, see <code>ConfigSnapshotDeliveryProperties</code>.</p>
        pub fn maximum_execution_frequency(
            mut self,
            input: crate::model::MaximumExecutionFrequency,
        ) -> Self {
            self.maximum_execution_frequency = Some(input);
            self
        }
        /// <p>The maximum frequency with which Config runs evaluations for a rule. Your Config Custom Policy rule is triggered when Config delivers the configuration snapshot. For more information, see <code>ConfigSnapshotDeliveryProperties</code>.</p>
        pub fn set_maximum_execution_frequency(
            mut self,
            input: std::option::Option<crate::model::MaximumExecutionFrequency>,
        ) -> Self {
            self.maximum_execution_frequency = input;
            self
        }
        /// Appends an item to `resource_types_scope`.
        ///
        /// To override the contents of this collection use [`set_resource_types_scope`](Self::set_resource_types_scope).
        ///
        /// <p>The type of the Amazon Web Services resource that was evaluated.</p>
        pub fn resource_types_scope(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.resource_types_scope.unwrap_or_default();
            v.push(input.into());
            self.resource_types_scope = Some(v);
            self
        }
        /// <p>The type of the Amazon Web Services resource that was evaluated.</p>
        pub fn set_resource_types_scope(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.resource_types_scope = input;
            self
        }
        /// <p>The ID of the Amazon Web Services resource that was evaluated.</p>
        pub fn resource_id_scope(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id_scope = Some(input.into());
            self
        }
        /// <p>The ID of the Amazon Web Services resource that was evaluated.</p>
        pub fn set_resource_id_scope(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_id_scope = input;
            self
        }
        /// <p>One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.</p>
        pub fn tag_key_scope(mut self, input: impl Into<std::string::String>) -> Self {
            self.tag_key_scope = Some(input.into());
            self
        }
        /// <p>One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.</p>
        pub fn set_tag_key_scope(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tag_key_scope = input;
            self
        }
        /// <p>The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).</p>
        pub fn tag_value_scope(mut self, input: impl Into<std::string::String>) -> Self {
            self.tag_value_scope = Some(input.into());
            self
        }
        /// <p>The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).</p>
        pub fn set_tag_value_scope(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tag_value_scope = input;
            self
        }
        /// <p>The runtime system for your organization Config Custom Policy rules. Guard is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. For more information about Guard, see the <a href="https://github.com/aws-cloudformation/cloudformation-guard">Guard GitHub Repository</a>.</p>
        pub fn policy_runtime(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_runtime = Some(input.into());
            self
        }
        /// <p>The runtime system for your organization Config Custom Policy rules. Guard is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. For more information about Guard, see the <a href="https://github.com/aws-cloudformation/cloudformation-guard">Guard GitHub Repository</a>.</p>
        pub fn set_policy_runtime(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_runtime = input;
            self
        }
        /// Appends an item to `debug_log_delivery_accounts`.
        ///
        /// To override the contents of this collection use [`set_debug_log_delivery_accounts`](Self::set_debug_log_delivery_accounts).
        ///
        /// <p>A list of accounts that you can enable debug logging for your organization Config Custom Policy rule. List is null when debug logging is enabled for all accounts.</p>
        pub fn debug_log_delivery_accounts(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.debug_log_delivery_accounts.unwrap_or_default();
            v.push(input.into());
            self.debug_log_delivery_accounts = Some(v);
            self
        }
        /// <p>A list of accounts that you can enable debug logging for your organization Config Custom Policy rule. List is null when debug logging is enabled for all accounts.</p>
        pub fn set_debug_log_delivery_accounts(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.debug_log_delivery_accounts = input;
            self
        }
        /// Consumes the builder and constructs a [`OrganizationCustomPolicyRuleMetadataNoPolicy`](crate::model::OrganizationCustomPolicyRuleMetadataNoPolicy).
        pub fn build(self) -> crate::model::OrganizationCustomPolicyRuleMetadataNoPolicy {
            crate::model::OrganizationCustomPolicyRuleMetadataNoPolicy {
                description: self.description,
                organization_config_rule_trigger_types: self.organization_config_rule_trigger_types,
                input_parameters: self.input_parameters,
                maximum_execution_frequency: self.maximum_execution_frequency,
                resource_types_scope: self.resource_types_scope,
                resource_id_scope: self.resource_id_scope,
                tag_key_scope: self.tag_key_scope,
                tag_value_scope: self.tag_value_scope,
                policy_runtime: self.policy_runtime,
                debug_log_delivery_accounts: self.debug_log_delivery_accounts,
            }
        }
    }
}

/// <p>The status of a specified delivery channel.</p>
/// <p>Valid values: <code>Success</code> | <code>Failure</code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeliveryChannelStatus {
    /// <p>The name of the delivery channel.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A list containing the status of the delivery of the snapshot to the specified Amazon S3 bucket.</p>
    #[doc(hidden)]
    pub config_snapshot_delivery_info: std::option::Option<crate::model::ConfigExportDeliveryInfo>,
    /// <p>A list that contains the status of the delivery of the configuration history to the specified Amazon S3 bucket.</p>
    #[doc(hidden)]
    pub config_history_delivery_info: std::option::Option<crate::model::ConfigExportDeliveryInfo>,
    /// <p>A list containing the status of the delivery of the configuration stream notification to the specified Amazon SNS topic.</p>
    #[doc(hidden)]
    pub config_stream_delivery_info: std::option::Option<crate::model::ConfigStreamDeliveryInfo>,
}
impl DeliveryChannelStatus {
    /// <p>The name of the delivery channel.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A list containing the status of the delivery of the snapshot to the specified Amazon S3 bucket.</p>
    pub fn config_snapshot_delivery_info(
        &self,
    ) -> std::option::Option<&crate::model::ConfigExportDeliveryInfo> {
        self.config_snapshot_delivery_info.as_ref()
    }
    /// <p>A list that contains the status of the delivery of the configuration history to the specified Amazon S3 bucket.</p>
    pub fn config_history_delivery_info(
        &self,
    ) -> std::option::Option<&crate::model::ConfigExportDeliveryInfo> {
        self.config_history_delivery_info.as_ref()
    }
    /// <p>A list containing the status of the delivery of the configuration stream notification to the specified Amazon SNS topic.</p>
    pub fn config_stream_delivery_info(
        &self,
    ) -> std::option::Option<&crate::model::ConfigStreamDeliveryInfo> {
        self.config_stream_delivery_info.as_ref()
    }
}
impl DeliveryChannelStatus {
    /// Creates a new builder-style object to manufacture [`DeliveryChannelStatus`](crate::model::DeliveryChannelStatus).
    pub fn builder() -> crate::model::delivery_channel_status::Builder {
        crate::model::delivery_channel_status::Builder::default()
    }
}

/// See [`DeliveryChannelStatus`](crate::model::DeliveryChannelStatus).
pub mod delivery_channel_status {

    /// A builder for [`DeliveryChannelStatus`](crate::model::DeliveryChannelStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) config_snapshot_delivery_info:
            std::option::Option<crate::model::ConfigExportDeliveryInfo>,
        pub(crate) config_history_delivery_info:
            std::option::Option<crate::model::ConfigExportDeliveryInfo>,
        pub(crate) config_stream_delivery_info:
            std::option::Option<crate::model::ConfigStreamDeliveryInfo>,
    }
    impl Builder {
        /// <p>The name of the delivery channel.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the delivery channel.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A list containing the status of the delivery of the snapshot to the specified Amazon S3 bucket.</p>
        pub fn config_snapshot_delivery_info(
            mut self,
            input: crate::model::ConfigExportDeliveryInfo,
        ) -> Self {
            self.config_snapshot_delivery_info = Some(input);
            self
        }
        /// <p>A list containing the status of the delivery of the snapshot to the specified Amazon S3 bucket.</p>
        pub fn set_config_snapshot_delivery_info(
            mut self,
            input: std::option::Option<crate::model::ConfigExportDeliveryInfo>,
        ) -> Self {
            self.config_snapshot_delivery_info = input;
            self
        }
        /// <p>A list that contains the status of the delivery of the configuration history to the specified Amazon S3 bucket.</p>
        pub fn config_history_delivery_info(
            mut self,
            input: crate::model::ConfigExportDeliveryInfo,
        ) -> Self {
            self.config_history_delivery_info = Some(input);
            self
        }
        /// <p>A list that contains the status of the delivery of the configuration history to the specified Amazon S3 bucket.</p>
        pub fn set_config_history_delivery_info(
            mut self,
            input: std::option::Option<crate::model::ConfigExportDeliveryInfo>,
        ) -> Self {
            self.config_history_delivery_info = input;
            self
        }
        /// <p>A list containing the status of the delivery of the configuration stream notification to the specified Amazon SNS topic.</p>
        pub fn config_stream_delivery_info(
            mut self,
            input: crate::model::ConfigStreamDeliveryInfo,
        ) -> Self {
            self.config_stream_delivery_info = Some(input);
            self
        }
        /// <p>A list containing the status of the delivery of the configuration stream notification to the specified Amazon SNS topic.</p>
        pub fn set_config_stream_delivery_info(
            mut self,
            input: std::option::Option<crate::model::ConfigStreamDeliveryInfo>,
        ) -> Self {
            self.config_stream_delivery_info = input;
            self
        }
        /// Consumes the builder and constructs a [`DeliveryChannelStatus`](crate::model::DeliveryChannelStatus).
        pub fn build(self) -> crate::model::DeliveryChannelStatus {
            crate::model::DeliveryChannelStatus {
                name: self.name,
                config_snapshot_delivery_info: self.config_snapshot_delivery_info,
                config_history_delivery_info: self.config_history_delivery_info,
                config_stream_delivery_info: self.config_stream_delivery_info,
            }
        }
    }
}

/// <p>A list that contains the status of the delivery of the configuration stream notification to the Amazon SNS topic.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfigStreamDeliveryInfo {
    /// <p>Status of the last attempted delivery.</p>
    /// <p> <b>Note</b> Providing an SNS topic on a <a href="https://docs.aws.amazon.com/config/latest/APIReference/API_DeliveryChannel.html">DeliveryChannel</a> for Config is optional. If the SNS delivery is turned off, the last status will be <b>Not_Applicable</b>.</p>
    #[doc(hidden)]
    pub last_status: std::option::Option<crate::model::DeliveryStatus>,
    /// <p>The error code from the last attempted delivery.</p>
    #[doc(hidden)]
    pub last_error_code: std::option::Option<std::string::String>,
    /// <p>The error message from the last attempted delivery.</p>
    #[doc(hidden)]
    pub last_error_message: std::option::Option<std::string::String>,
    /// <p>The time from the last status change.</p>
    #[doc(hidden)]
    pub last_status_change_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ConfigStreamDeliveryInfo {
    /// <p>Status of the last attempted delivery.</p>
    /// <p> <b>Note</b> Providing an SNS topic on a <a href="https://docs.aws.amazon.com/config/latest/APIReference/API_DeliveryChannel.html">DeliveryChannel</a> for Config is optional. If the SNS delivery is turned off, the last status will be <b>Not_Applicable</b>.</p>
    pub fn last_status(&self) -> std::option::Option<&crate::model::DeliveryStatus> {
        self.last_status.as_ref()
    }
    /// <p>The error code from the last attempted delivery.</p>
    pub fn last_error_code(&self) -> std::option::Option<&str> {
        self.last_error_code.as_deref()
    }
    /// <p>The error message from the last attempted delivery.</p>
    pub fn last_error_message(&self) -> std::option::Option<&str> {
        self.last_error_message.as_deref()
    }
    /// <p>The time from the last status change.</p>
    pub fn last_status_change_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_status_change_time.as_ref()
    }
}
impl ConfigStreamDeliveryInfo {
    /// Creates a new builder-style object to manufacture [`ConfigStreamDeliveryInfo`](crate::model::ConfigStreamDeliveryInfo).
    pub fn builder() -> crate::model::config_stream_delivery_info::Builder {
        crate::model::config_stream_delivery_info::Builder::default()
    }
}

/// See [`ConfigStreamDeliveryInfo`](crate::model::ConfigStreamDeliveryInfo).
pub mod config_stream_delivery_info {

    /// A builder for [`ConfigStreamDeliveryInfo`](crate::model::ConfigStreamDeliveryInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) last_status: std::option::Option<crate::model::DeliveryStatus>,
        pub(crate) last_error_code: std::option::Option<std::string::String>,
        pub(crate) last_error_message: std::option::Option<std::string::String>,
        pub(crate) last_status_change_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Status of the last attempted delivery.</p>
        /// <p> <b>Note</b> Providing an SNS topic on a <a href="https://docs.aws.amazon.com/config/latest/APIReference/API_DeliveryChannel.html">DeliveryChannel</a> for Config is optional. If the SNS delivery is turned off, the last status will be <b>Not_Applicable</b>.</p>
        pub fn last_status(mut self, input: crate::model::DeliveryStatus) -> Self {
            self.last_status = Some(input);
            self
        }
        /// <p>Status of the last attempted delivery.</p>
        /// <p> <b>Note</b> Providing an SNS topic on a <a href="https://docs.aws.amazon.com/config/latest/APIReference/API_DeliveryChannel.html">DeliveryChannel</a> for Config is optional. If the SNS delivery is turned off, the last status will be <b>Not_Applicable</b>.</p>
        pub fn set_last_status(
            mut self,
            input: std::option::Option<crate::model::DeliveryStatus>,
        ) -> Self {
            self.last_status = input;
            self
        }
        /// <p>The error code from the last attempted delivery.</p>
        pub fn last_error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_error_code = Some(input.into());
            self
        }
        /// <p>The error code from the last attempted delivery.</p>
        pub fn set_last_error_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_error_code = input;
            self
        }
        /// <p>The error message from the last attempted delivery.</p>
        pub fn last_error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_error_message = Some(input.into());
            self
        }
        /// <p>The error message from the last attempted delivery.</p>
        pub fn set_last_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_error_message = input;
            self
        }
        /// <p>The time from the last status change.</p>
        pub fn last_status_change_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_status_change_time = Some(input);
            self
        }
        /// <p>The time from the last status change.</p>
        pub fn set_last_status_change_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_status_change_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigStreamDeliveryInfo`](crate::model::ConfigStreamDeliveryInfo).
        pub fn build(self) -> crate::model::ConfigStreamDeliveryInfo {
            crate::model::ConfigStreamDeliveryInfo {
                last_status: self.last_status,
                last_error_code: self.last_error_code,
                last_error_message: self.last_error_message,
                last_status_change_time: self.last_status_change_time,
            }
        }
    }
}

/// When writing a match expression against `DeliveryStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let deliverystatus = unimplemented!();
/// match deliverystatus {
///     DeliveryStatus::Failure => { /* ... */ },
///     DeliveryStatus::NotApplicable => { /* ... */ },
///     DeliveryStatus::Success => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `deliverystatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DeliveryStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DeliveryStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DeliveryStatus::NewFeature` is defined.
/// Specifically, when `deliverystatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DeliveryStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DeliveryStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failure,
    #[allow(missing_docs)] // documentation missing in model
    NotApplicable,
    #[allow(missing_docs)] // documentation missing in model
    Success,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DeliveryStatus {
    fn from(s: &str) -> Self {
        match s {
            "Failure" => DeliveryStatus::Failure,
            "Not_Applicable" => DeliveryStatus::NotApplicable,
            "Success" => DeliveryStatus::Success,
            other => DeliveryStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DeliveryStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DeliveryStatus::from(s))
    }
}
impl DeliveryStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DeliveryStatus::Failure => "Failure",
            DeliveryStatus::NotApplicable => "Not_Applicable",
            DeliveryStatus::Success => "Success",
            DeliveryStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Failure", "Not_Applicable", "Success"]
    }
}
impl AsRef<str> for DeliveryStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides status of the delivery of the snapshot or the configuration history to the specified Amazon S3 bucket. Also provides the status of notifications about the Amazon S3 delivery to the specified Amazon SNS topic.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfigExportDeliveryInfo {
    /// <p>Status of the last attempted delivery.</p>
    #[doc(hidden)]
    pub last_status: std::option::Option<crate::model::DeliveryStatus>,
    /// <p>The error code from the last attempted delivery.</p>
    #[doc(hidden)]
    pub last_error_code: std::option::Option<std::string::String>,
    /// <p>The error message from the last attempted delivery.</p>
    #[doc(hidden)]
    pub last_error_message: std::option::Option<std::string::String>,
    /// <p>The time of the last attempted delivery.</p>
    #[doc(hidden)]
    pub last_attempt_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time of the last successful delivery.</p>
    #[doc(hidden)]
    pub last_successful_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that the next delivery occurs.</p>
    #[doc(hidden)]
    pub next_delivery_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ConfigExportDeliveryInfo {
    /// <p>Status of the last attempted delivery.</p>
    pub fn last_status(&self) -> std::option::Option<&crate::model::DeliveryStatus> {
        self.last_status.as_ref()
    }
    /// <p>The error code from the last attempted delivery.</p>
    pub fn last_error_code(&self) -> std::option::Option<&str> {
        self.last_error_code.as_deref()
    }
    /// <p>The error message from the last attempted delivery.</p>
    pub fn last_error_message(&self) -> std::option::Option<&str> {
        self.last_error_message.as_deref()
    }
    /// <p>The time of the last attempted delivery.</p>
    pub fn last_attempt_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_attempt_time.as_ref()
    }
    /// <p>The time of the last successful delivery.</p>
    pub fn last_successful_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_successful_time.as_ref()
    }
    /// <p>The time that the next delivery occurs.</p>
    pub fn next_delivery_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.next_delivery_time.as_ref()
    }
}
impl ConfigExportDeliveryInfo {
    /// Creates a new builder-style object to manufacture [`ConfigExportDeliveryInfo`](crate::model::ConfigExportDeliveryInfo).
    pub fn builder() -> crate::model::config_export_delivery_info::Builder {
        crate::model::config_export_delivery_info::Builder::default()
    }
}

/// See [`ConfigExportDeliveryInfo`](crate::model::ConfigExportDeliveryInfo).
pub mod config_export_delivery_info {

    /// A builder for [`ConfigExportDeliveryInfo`](crate::model::ConfigExportDeliveryInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) last_status: std::option::Option<crate::model::DeliveryStatus>,
        pub(crate) last_error_code: std::option::Option<std::string::String>,
        pub(crate) last_error_message: std::option::Option<std::string::String>,
        pub(crate) last_attempt_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_successful_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) next_delivery_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Status of the last attempted delivery.</p>
        pub fn last_status(mut self, input: crate::model::DeliveryStatus) -> Self {
            self.last_status = Some(input);
            self
        }
        /// <p>Status of the last attempted delivery.</p>
        pub fn set_last_status(
            mut self,
            input: std::option::Option<crate::model::DeliveryStatus>,
        ) -> Self {
            self.last_status = input;
            self
        }
        /// <p>The error code from the last attempted delivery.</p>
        pub fn last_error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_error_code = Some(input.into());
            self
        }
        /// <p>The error code from the last attempted delivery.</p>
        pub fn set_last_error_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_error_code = input;
            self
        }
        /// <p>The error message from the last attempted delivery.</p>
        pub fn last_error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_error_message = Some(input.into());
            self
        }
        /// <p>The error message from the last attempted delivery.</p>
        pub fn set_last_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_error_message = input;
            self
        }
        /// <p>The time of the last attempted delivery.</p>
        pub fn last_attempt_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_attempt_time = Some(input);
            self
        }
        /// <p>The time of the last attempted delivery.</p>
        pub fn set_last_attempt_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_attempt_time = input;
            self
        }
        /// <p>The time of the last successful delivery.</p>
        pub fn last_successful_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_successful_time = Some(input);
            self
        }
        /// <p>The time of the last successful delivery.</p>
        pub fn set_last_successful_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_successful_time = input;
            self
        }
        /// <p>The time that the next delivery occurs.</p>
        pub fn next_delivery_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.next_delivery_time = Some(input);
            self
        }
        /// <p>The time that the next delivery occurs.</p>
        pub fn set_next_delivery_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.next_delivery_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigExportDeliveryInfo`](crate::model::ConfigExportDeliveryInfo).
        pub fn build(self) -> crate::model::ConfigExportDeliveryInfo {
            crate::model::ConfigExportDeliveryInfo {
                last_status: self.last_status,
                last_error_code: self.last_error_code,
                last_error_message: self.last_error_message,
                last_attempt_time: self.last_attempt_time,
                last_successful_time: self.last_successful_time,
                next_delivery_time: self.next_delivery_time,
            }
        }
    }
}

/// <p>Status details of a conformance pack.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConformancePackStatusDetail {
    /// <p>Name of the conformance pack.</p>
    #[doc(hidden)]
    pub conformance_pack_name: std::option::Option<std::string::String>,
    /// <p>ID of the conformance pack.</p>
    #[doc(hidden)]
    pub conformance_pack_id: std::option::Option<std::string::String>,
    /// <p>Amazon Resource Name (ARN) of comformance pack.</p>
    #[doc(hidden)]
    pub conformance_pack_arn: std::option::Option<std::string::String>,
    /// <p>Indicates deployment status of conformance pack.</p>
    /// <p>Config sets the state of the conformance pack to:</p>
    /// <ul>
    /// <li> <p>CREATE_IN_PROGRESS when a conformance pack creation is in progress for an account.</p> </li>
    /// <li> <p>CREATE_COMPLETE when a conformance pack has been successfully created in your account.</p> </li>
    /// <li> <p>CREATE_FAILED when a conformance pack creation failed in your account.</p> </li>
    /// <li> <p>DELETE_IN_PROGRESS when a conformance pack deletion is in progress. </p> </li>
    /// <li> <p>DELETE_FAILED when a conformance pack deletion failed in your account.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub conformance_pack_state: std::option::Option<crate::model::ConformancePackState>,
    /// <p>Amazon Resource Name (ARN) of CloudFormation stack. </p>
    #[doc(hidden)]
    pub stack_arn: std::option::Option<std::string::String>,
    /// <p>The reason of conformance pack creation failure.</p>
    #[doc(hidden)]
    pub conformance_pack_status_reason: std::option::Option<std::string::String>,
    /// <p>Last time when conformation pack creation and update was requested.</p>
    #[doc(hidden)]
    pub last_update_requested_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Last time when conformation pack creation and update was successful.</p>
    #[doc(hidden)]
    pub last_update_completed_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ConformancePackStatusDetail {
    /// <p>Name of the conformance pack.</p>
    pub fn conformance_pack_name(&self) -> std::option::Option<&str> {
        self.conformance_pack_name.as_deref()
    }
    /// <p>ID of the conformance pack.</p>
    pub fn conformance_pack_id(&self) -> std::option::Option<&str> {
        self.conformance_pack_id.as_deref()
    }
    /// <p>Amazon Resource Name (ARN) of comformance pack.</p>
    pub fn conformance_pack_arn(&self) -> std::option::Option<&str> {
        self.conformance_pack_arn.as_deref()
    }
    /// <p>Indicates deployment status of conformance pack.</p>
    /// <p>Config sets the state of the conformance pack to:</p>
    /// <ul>
    /// <li> <p>CREATE_IN_PROGRESS when a conformance pack creation is in progress for an account.</p> </li>
    /// <li> <p>CREATE_COMPLETE when a conformance pack has been successfully created in your account.</p> </li>
    /// <li> <p>CREATE_FAILED when a conformance pack creation failed in your account.</p> </li>
    /// <li> <p>DELETE_IN_PROGRESS when a conformance pack deletion is in progress. </p> </li>
    /// <li> <p>DELETE_FAILED when a conformance pack deletion failed in your account.</p> </li>
    /// </ul>
    pub fn conformance_pack_state(
        &self,
    ) -> std::option::Option<&crate::model::ConformancePackState> {
        self.conformance_pack_state.as_ref()
    }
    /// <p>Amazon Resource Name (ARN) of CloudFormation stack. </p>
    pub fn stack_arn(&self) -> std::option::Option<&str> {
        self.stack_arn.as_deref()
    }
    /// <p>The reason of conformance pack creation failure.</p>
    pub fn conformance_pack_status_reason(&self) -> std::option::Option<&str> {
        self.conformance_pack_status_reason.as_deref()
    }
    /// <p>Last time when conformation pack creation and update was requested.</p>
    pub fn last_update_requested_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_update_requested_time.as_ref()
    }
    /// <p>Last time when conformation pack creation and update was successful.</p>
    pub fn last_update_completed_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_update_completed_time.as_ref()
    }
}
impl ConformancePackStatusDetail {
    /// Creates a new builder-style object to manufacture [`ConformancePackStatusDetail`](crate::model::ConformancePackStatusDetail).
    pub fn builder() -> crate::model::conformance_pack_status_detail::Builder {
        crate::model::conformance_pack_status_detail::Builder::default()
    }
}

/// See [`ConformancePackStatusDetail`](crate::model::ConformancePackStatusDetail).
pub mod conformance_pack_status_detail {

    /// A builder for [`ConformancePackStatusDetail`](crate::model::ConformancePackStatusDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) conformance_pack_name: std::option::Option<std::string::String>,
        pub(crate) conformance_pack_id: std::option::Option<std::string::String>,
        pub(crate) conformance_pack_arn: std::option::Option<std::string::String>,
        pub(crate) conformance_pack_state: std::option::Option<crate::model::ConformancePackState>,
        pub(crate) stack_arn: std::option::Option<std::string::String>,
        pub(crate) conformance_pack_status_reason: std::option::Option<std::string::String>,
        pub(crate) last_update_requested_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_update_completed_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Name of the conformance pack.</p>
        pub fn conformance_pack_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.conformance_pack_name = Some(input.into());
            self
        }
        /// <p>Name of the conformance pack.</p>
        pub fn set_conformance_pack_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.conformance_pack_name = input;
            self
        }
        /// <p>ID of the conformance pack.</p>
        pub fn conformance_pack_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.conformance_pack_id = Some(input.into());
            self
        }
        /// <p>ID of the conformance pack.</p>
        pub fn set_conformance_pack_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.conformance_pack_id = input;
            self
        }
        /// <p>Amazon Resource Name (ARN) of comformance pack.</p>
        pub fn conformance_pack_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.conformance_pack_arn = Some(input.into());
            self
        }
        /// <p>Amazon Resource Name (ARN) of comformance pack.</p>
        pub fn set_conformance_pack_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.conformance_pack_arn = input;
            self
        }
        /// <p>Indicates deployment status of conformance pack.</p>
        /// <p>Config sets the state of the conformance pack to:</p>
        /// <ul>
        /// <li> <p>CREATE_IN_PROGRESS when a conformance pack creation is in progress for an account.</p> </li>
        /// <li> <p>CREATE_COMPLETE when a conformance pack has been successfully created in your account.</p> </li>
        /// <li> <p>CREATE_FAILED when a conformance pack creation failed in your account.</p> </li>
        /// <li> <p>DELETE_IN_PROGRESS when a conformance pack deletion is in progress. </p> </li>
        /// <li> <p>DELETE_FAILED when a conformance pack deletion failed in your account.</p> </li>
        /// </ul>
        pub fn conformance_pack_state(mut self, input: crate::model::ConformancePackState) -> Self {
            self.conformance_pack_state = Some(input);
            self
        }
        /// <p>Indicates deployment status of conformance pack.</p>
        /// <p>Config sets the state of the conformance pack to:</p>
        /// <ul>
        /// <li> <p>CREATE_IN_PROGRESS when a conformance pack creation is in progress for an account.</p> </li>
        /// <li> <p>CREATE_COMPLETE when a conformance pack has been successfully created in your account.</p> </li>
        /// <li> <p>CREATE_FAILED when a conformance pack creation failed in your account.</p> </li>
        /// <li> <p>DELETE_IN_PROGRESS when a conformance pack deletion is in progress. </p> </li>
        /// <li> <p>DELETE_FAILED when a conformance pack deletion failed in your account.</p> </li>
        /// </ul>
        pub fn set_conformance_pack_state(
            mut self,
            input: std::option::Option<crate::model::ConformancePackState>,
        ) -> Self {
            self.conformance_pack_state = input;
            self
        }
        /// <p>Amazon Resource Name (ARN) of CloudFormation stack. </p>
        pub fn stack_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.stack_arn = Some(input.into());
            self
        }
        /// <p>Amazon Resource Name (ARN) of CloudFormation stack. </p>
        pub fn set_stack_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stack_arn = input;
            self
        }
        /// <p>The reason of conformance pack creation failure.</p>
        pub fn conformance_pack_status_reason(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.conformance_pack_status_reason = Some(input.into());
            self
        }
        /// <p>The reason of conformance pack creation failure.</p>
        pub fn set_conformance_pack_status_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.conformance_pack_status_reason = input;
            self
        }
        /// <p>Last time when conformation pack creation and update was requested.</p>
        pub fn last_update_requested_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_update_requested_time = Some(input);
            self
        }
        /// <p>Last time when conformation pack creation and update was requested.</p>
        pub fn set_last_update_requested_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_update_requested_time = input;
            self
        }
        /// <p>Last time when conformation pack creation and update was successful.</p>
        pub fn last_update_completed_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_update_completed_time = Some(input);
            self
        }
        /// <p>Last time when conformation pack creation and update was successful.</p>
        pub fn set_last_update_completed_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_update_completed_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ConformancePackStatusDetail`](crate::model::ConformancePackStatusDetail).
        pub fn build(self) -> crate::model::ConformancePackStatusDetail {
            crate::model::ConformancePackStatusDetail {
                conformance_pack_name: self.conformance_pack_name,
                conformance_pack_id: self.conformance_pack_id,
                conformance_pack_arn: self.conformance_pack_arn,
                conformance_pack_state: self.conformance_pack_state,
                stack_arn: self.stack_arn,
                conformance_pack_status_reason: self.conformance_pack_status_reason,
                last_update_requested_time: self.last_update_requested_time,
                last_update_completed_time: self.last_update_completed_time,
            }
        }
    }
}

/// When writing a match expression against `ConformancePackState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let conformancepackstate = unimplemented!();
/// match conformancepackstate {
///     ConformancePackState::CreateComplete => { /* ... */ },
///     ConformancePackState::CreateFailed => { /* ... */ },
///     ConformancePackState::CreateInProgress => { /* ... */ },
///     ConformancePackState::DeleteFailed => { /* ... */ },
///     ConformancePackState::DeleteInProgress => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `conformancepackstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConformancePackState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConformancePackState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConformancePackState::NewFeature` is defined.
/// Specifically, when `conformancepackstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConformancePackState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConformancePackState {
    #[allow(missing_docs)] // documentation missing in model
    CreateComplete,
    #[allow(missing_docs)] // documentation missing in model
    CreateFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    DeleteInProgress,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConformancePackState {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_COMPLETE" => ConformancePackState::CreateComplete,
            "CREATE_FAILED" => ConformancePackState::CreateFailed,
            "CREATE_IN_PROGRESS" => ConformancePackState::CreateInProgress,
            "DELETE_FAILED" => ConformancePackState::DeleteFailed,
            "DELETE_IN_PROGRESS" => ConformancePackState::DeleteInProgress,
            other => {
                ConformancePackState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ConformancePackState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConformancePackState::from(s))
    }
}
impl ConformancePackState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConformancePackState::CreateComplete => "CREATE_COMPLETE",
            ConformancePackState::CreateFailed => "CREATE_FAILED",
            ConformancePackState::CreateInProgress => "CREATE_IN_PROGRESS",
            ConformancePackState::DeleteFailed => "DELETE_FAILED",
            ConformancePackState::DeleteInProgress => "DELETE_IN_PROGRESS",
            ConformancePackState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CREATE_COMPLETE",
            "CREATE_FAILED",
            "CREATE_IN_PROGRESS",
            "DELETE_FAILED",
            "DELETE_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for ConformancePackState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Returns details of a conformance pack. A conformance pack is a collection of Config rules and remediation actions that can be easily deployed in an account and a region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConformancePackDetail {
    /// <p>Name of the conformance pack.</p>
    #[doc(hidden)]
    pub conformance_pack_name: std::option::Option<std::string::String>,
    /// <p>Amazon Resource Name (ARN) of the conformance pack.</p>
    #[doc(hidden)]
    pub conformance_pack_arn: std::option::Option<std::string::String>,
    /// <p>ID of the conformance pack.</p>
    #[doc(hidden)]
    pub conformance_pack_id: std::option::Option<std::string::String>,
    /// <p>The name of the Amazon S3 bucket where Config stores conformance pack templates. </p> <note>
    /// <p>This field is optional.</p>
    /// </note>
    #[doc(hidden)]
    pub delivery_s3_bucket: std::option::Option<std::string::String>,
    /// <p>The prefix for the Amazon S3 bucket.</p> <note>
    /// <p>This field is optional.</p>
    /// </note>
    #[doc(hidden)]
    pub delivery_s3_key_prefix: std::option::Option<std::string::String>,
    /// <p>A list of <code>ConformancePackInputParameter</code> objects.</p>
    #[doc(hidden)]
    pub conformance_pack_input_parameters:
        std::option::Option<std::vec::Vec<crate::model::ConformancePackInputParameter>>,
    /// <p>The last time a conformation pack update was requested. </p>
    #[doc(hidden)]
    pub last_update_requested_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The Amazon Web Services service that created the conformance pack.</p>
    #[doc(hidden)]
    pub created_by: std::option::Option<std::string::String>,
    /// <p>An object that contains the name or Amazon Resource Name (ARN) of the Amazon Web Services Systems Manager document (SSM document) and the version of the SSM document that is used to create a conformance pack.</p>
    #[doc(hidden)]
    pub template_ssm_document_details:
        std::option::Option<crate::model::TemplateSsmDocumentDetails>,
}
impl ConformancePackDetail {
    /// <p>Name of the conformance pack.</p>
    pub fn conformance_pack_name(&self) -> std::option::Option<&str> {
        self.conformance_pack_name.as_deref()
    }
    /// <p>Amazon Resource Name (ARN) of the conformance pack.</p>
    pub fn conformance_pack_arn(&self) -> std::option::Option<&str> {
        self.conformance_pack_arn.as_deref()
    }
    /// <p>ID of the conformance pack.</p>
    pub fn conformance_pack_id(&self) -> std::option::Option<&str> {
        self.conformance_pack_id.as_deref()
    }
    /// <p>The name of the Amazon S3 bucket where Config stores conformance pack templates. </p> <note>
    /// <p>This field is optional.</p>
    /// </note>
    pub fn delivery_s3_bucket(&self) -> std::option::Option<&str> {
        self.delivery_s3_bucket.as_deref()
    }
    /// <p>The prefix for the Amazon S3 bucket.</p> <note>
    /// <p>This field is optional.</p>
    /// </note>
    pub fn delivery_s3_key_prefix(&self) -> std::option::Option<&str> {
        self.delivery_s3_key_prefix.as_deref()
    }
    /// <p>A list of <code>ConformancePackInputParameter</code> objects.</p>
    pub fn conformance_pack_input_parameters(
        &self,
    ) -> std::option::Option<&[crate::model::ConformancePackInputParameter]> {
        self.conformance_pack_input_parameters.as_deref()
    }
    /// <p>The last time a conformation pack update was requested. </p>
    pub fn last_update_requested_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_update_requested_time.as_ref()
    }
    /// <p>The Amazon Web Services service that created the conformance pack.</p>
    pub fn created_by(&self) -> std::option::Option<&str> {
        self.created_by.as_deref()
    }
    /// <p>An object that contains the name or Amazon Resource Name (ARN) of the Amazon Web Services Systems Manager document (SSM document) and the version of the SSM document that is used to create a conformance pack.</p>
    pub fn template_ssm_document_details(
        &self,
    ) -> std::option::Option<&crate::model::TemplateSsmDocumentDetails> {
        self.template_ssm_document_details.as_ref()
    }
}
impl ConformancePackDetail {
    /// Creates a new builder-style object to manufacture [`ConformancePackDetail`](crate::model::ConformancePackDetail).
    pub fn builder() -> crate::model::conformance_pack_detail::Builder {
        crate::model::conformance_pack_detail::Builder::default()
    }
}

/// See [`ConformancePackDetail`](crate::model::ConformancePackDetail).
pub mod conformance_pack_detail {

    /// A builder for [`ConformancePackDetail`](crate::model::ConformancePackDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) conformance_pack_name: std::option::Option<std::string::String>,
        pub(crate) conformance_pack_arn: std::option::Option<std::string::String>,
        pub(crate) conformance_pack_id: std::option::Option<std::string::String>,
        pub(crate) delivery_s3_bucket: std::option::Option<std::string::String>,
        pub(crate) delivery_s3_key_prefix: std::option::Option<std::string::String>,
        pub(crate) conformance_pack_input_parameters:
            std::option::Option<std::vec::Vec<crate::model::ConformancePackInputParameter>>,
        pub(crate) last_update_requested_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) template_ssm_document_details:
            std::option::Option<crate::model::TemplateSsmDocumentDetails>,
    }
    impl Builder {
        /// <p>Name of the conformance pack.</p>
        pub fn conformance_pack_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.conformance_pack_name = Some(input.into());
            self
        }
        /// <p>Name of the conformance pack.</p>
        pub fn set_conformance_pack_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.conformance_pack_name = input;
            self
        }
        /// <p>Amazon Resource Name (ARN) of the conformance pack.</p>
        pub fn conformance_pack_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.conformance_pack_arn = Some(input.into());
            self
        }
        /// <p>Amazon Resource Name (ARN) of the conformance pack.</p>
        pub fn set_conformance_pack_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.conformance_pack_arn = input;
            self
        }
        /// <p>ID of the conformance pack.</p>
        pub fn conformance_pack_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.conformance_pack_id = Some(input.into());
            self
        }
        /// <p>ID of the conformance pack.</p>
        pub fn set_conformance_pack_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.conformance_pack_id = input;
            self
        }
        /// <p>The name of the Amazon S3 bucket where Config stores conformance pack templates. </p> <note>
        /// <p>This field is optional.</p>
        /// </note>
        pub fn delivery_s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.delivery_s3_bucket = Some(input.into());
            self
        }
        /// <p>The name of the Amazon S3 bucket where Config stores conformance pack templates. </p> <note>
        /// <p>This field is optional.</p>
        /// </note>
        pub fn set_delivery_s3_bucket(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.delivery_s3_bucket = input;
            self
        }
        /// <p>The prefix for the Amazon S3 bucket.</p> <note>
        /// <p>This field is optional.</p>
        /// </note>
        pub fn delivery_s3_key_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.delivery_s3_key_prefix = Some(input.into());
            self
        }
        /// <p>The prefix for the Amazon S3 bucket.</p> <note>
        /// <p>This field is optional.</p>
        /// </note>
        pub fn set_delivery_s3_key_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.delivery_s3_key_prefix = input;
            self
        }
        /// Appends an item to `conformance_pack_input_parameters`.
        ///
        /// To override the contents of this collection use [`set_conformance_pack_input_parameters`](Self::set_conformance_pack_input_parameters).
        ///
        /// <p>A list of <code>ConformancePackInputParameter</code> objects.</p>
        pub fn conformance_pack_input_parameters(
            mut self,
            input: crate::model::ConformancePackInputParameter,
        ) -> Self {
            let mut v = self.conformance_pack_input_parameters.unwrap_or_default();
            v.push(input);
            self.conformance_pack_input_parameters = Some(v);
            self
        }
        /// <p>A list of <code>ConformancePackInputParameter</code> objects.</p>
        pub fn set_conformance_pack_input_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ConformancePackInputParameter>>,
        ) -> Self {
            self.conformance_pack_input_parameters = input;
            self
        }
        /// <p>The last time a conformation pack update was requested. </p>
        pub fn last_update_requested_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_update_requested_time = Some(input);
            self
        }
        /// <p>The last time a conformation pack update was requested. </p>
        pub fn set_last_update_requested_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_update_requested_time = input;
            self
        }
        /// <p>The Amazon Web Services service that created the conformance pack.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services service that created the conformance pack.</p>
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>An object that contains the name or Amazon Resource Name (ARN) of the Amazon Web Services Systems Manager document (SSM document) and the version of the SSM document that is used to create a conformance pack.</p>
        pub fn template_ssm_document_details(
            mut self,
            input: crate::model::TemplateSsmDocumentDetails,
        ) -> Self {
            self.template_ssm_document_details = Some(input);
            self
        }
        /// <p>An object that contains the name or Amazon Resource Name (ARN) of the Amazon Web Services Systems Manager document (SSM document) and the version of the SSM document that is used to create a conformance pack.</p>
        pub fn set_template_ssm_document_details(
            mut self,
            input: std::option::Option<crate::model::TemplateSsmDocumentDetails>,
        ) -> Self {
            self.template_ssm_document_details = input;
            self
        }
        /// Consumes the builder and constructs a [`ConformancePackDetail`](crate::model::ConformancePackDetail).
        pub fn build(self) -> crate::model::ConformancePackDetail {
            crate::model::ConformancePackDetail {
                conformance_pack_name: self.conformance_pack_name,
                conformance_pack_arn: self.conformance_pack_arn,
                conformance_pack_id: self.conformance_pack_id,
                delivery_s3_bucket: self.delivery_s3_bucket,
                delivery_s3_key_prefix: self.delivery_s3_key_prefix,
                conformance_pack_input_parameters: self.conformance_pack_input_parameters,
                last_update_requested_time: self.last_update_requested_time,
                created_by: self.created_by,
                template_ssm_document_details: self.template_ssm_document_details,
            }
        }
    }
}

/// <p>Compliance information of one or more Config rules within a conformance pack. You can filter using Config rule names and compliance types.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConformancePackRuleCompliance {
    /// <p>Name of the Config rule.</p>
    #[doc(hidden)]
    pub config_rule_name: std::option::Option<std::string::String>,
    /// <p>Compliance of the Config rule.</p>
    /// <p>The allowed values are <code>COMPLIANT</code>, <code>NON_COMPLIANT</code>, and <code>INSUFFICIENT_DATA</code>.</p>
    #[doc(hidden)]
    pub compliance_type: std::option::Option<crate::model::ConformancePackComplianceType>,
    /// <p>Controls for the conformance pack. A control is a process to prevent or detect problems while meeting objectives. A control can align with a specific compliance regime or map to internal controls defined by an organization.</p>
    #[doc(hidden)]
    pub controls: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ConformancePackRuleCompliance {
    /// <p>Name of the Config rule.</p>
    pub fn config_rule_name(&self) -> std::option::Option<&str> {
        self.config_rule_name.as_deref()
    }
    /// <p>Compliance of the Config rule.</p>
    /// <p>The allowed values are <code>COMPLIANT</code>, <code>NON_COMPLIANT</code>, and <code>INSUFFICIENT_DATA</code>.</p>
    pub fn compliance_type(
        &self,
    ) -> std::option::Option<&crate::model::ConformancePackComplianceType> {
        self.compliance_type.as_ref()
    }
    /// <p>Controls for the conformance pack. A control is a process to prevent or detect problems while meeting objectives. A control can align with a specific compliance regime or map to internal controls defined by an organization.</p>
    pub fn controls(&self) -> std::option::Option<&[std::string::String]> {
        self.controls.as_deref()
    }
}
impl ConformancePackRuleCompliance {
    /// Creates a new builder-style object to manufacture [`ConformancePackRuleCompliance`](crate::model::ConformancePackRuleCompliance).
    pub fn builder() -> crate::model::conformance_pack_rule_compliance::Builder {
        crate::model::conformance_pack_rule_compliance::Builder::default()
    }
}

/// See [`ConformancePackRuleCompliance`](crate::model::ConformancePackRuleCompliance).
pub mod conformance_pack_rule_compliance {

    /// A builder for [`ConformancePackRuleCompliance`](crate::model::ConformancePackRuleCompliance).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) config_rule_name: std::option::Option<std::string::String>,
        pub(crate) compliance_type:
            std::option::Option<crate::model::ConformancePackComplianceType>,
        pub(crate) controls: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>Name of the Config rule.</p>
        pub fn config_rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.config_rule_name = Some(input.into());
            self
        }
        /// <p>Name of the Config rule.</p>
        pub fn set_config_rule_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.config_rule_name = input;
            self
        }
        /// <p>Compliance of the Config rule.</p>
        /// <p>The allowed values are <code>COMPLIANT</code>, <code>NON_COMPLIANT</code>, and <code>INSUFFICIENT_DATA</code>.</p>
        pub fn compliance_type(
            mut self,
            input: crate::model::ConformancePackComplianceType,
        ) -> Self {
            self.compliance_type = Some(input);
            self
        }
        /// <p>Compliance of the Config rule.</p>
        /// <p>The allowed values are <code>COMPLIANT</code>, <code>NON_COMPLIANT</code>, and <code>INSUFFICIENT_DATA</code>.</p>
        pub fn set_compliance_type(
            mut self,
            input: std::option::Option<crate::model::ConformancePackComplianceType>,
        ) -> Self {
            self.compliance_type = input;
            self
        }
        /// Appends an item to `controls`.
        ///
        /// To override the contents of this collection use [`set_controls`](Self::set_controls).
        ///
        /// <p>Controls for the conformance pack. A control is a process to prevent or detect problems while meeting objectives. A control can align with a specific compliance regime or map to internal controls defined by an organization.</p>
        pub fn controls(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.controls.unwrap_or_default();
            v.push(input.into());
            self.controls = Some(v);
            self
        }
        /// <p>Controls for the conformance pack. A control is a process to prevent or detect problems while meeting objectives. A control can align with a specific compliance regime or map to internal controls defined by an organization.</p>
        pub fn set_controls(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.controls = input;
            self
        }
        /// Consumes the builder and constructs a [`ConformancePackRuleCompliance`](crate::model::ConformancePackRuleCompliance).
        pub fn build(self) -> crate::model::ConformancePackRuleCompliance {
            crate::model::ConformancePackRuleCompliance {
                config_rule_name: self.config_rule_name,
                compliance_type: self.compliance_type,
                controls: self.controls,
            }
        }
    }
}

/// <p>Filters the conformance pack by compliance types and Config rule names.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConformancePackComplianceFilters {
    /// <p>Filters the results by Config rule names.</p>
    #[doc(hidden)]
    pub config_rule_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Filters the results by compliance.</p>
    /// <p>The allowed values are <code>COMPLIANT</code> and <code>NON_COMPLIANT</code>. <code>INSUFFICIENT_DATA</code> is not supported.</p>
    #[doc(hidden)]
    pub compliance_type: std::option::Option<crate::model::ConformancePackComplianceType>,
}
impl ConformancePackComplianceFilters {
    /// <p>Filters the results by Config rule names.</p>
    pub fn config_rule_names(&self) -> std::option::Option<&[std::string::String]> {
        self.config_rule_names.as_deref()
    }
    /// <p>Filters the results by compliance.</p>
    /// <p>The allowed values are <code>COMPLIANT</code> and <code>NON_COMPLIANT</code>. <code>INSUFFICIENT_DATA</code> is not supported.</p>
    pub fn compliance_type(
        &self,
    ) -> std::option::Option<&crate::model::ConformancePackComplianceType> {
        self.compliance_type.as_ref()
    }
}
impl ConformancePackComplianceFilters {
    /// Creates a new builder-style object to manufacture [`ConformancePackComplianceFilters`](crate::model::ConformancePackComplianceFilters).
    pub fn builder() -> crate::model::conformance_pack_compliance_filters::Builder {
        crate::model::conformance_pack_compliance_filters::Builder::default()
    }
}

/// See [`ConformancePackComplianceFilters`](crate::model::ConformancePackComplianceFilters).
pub mod conformance_pack_compliance_filters {

    /// A builder for [`ConformancePackComplianceFilters`](crate::model::ConformancePackComplianceFilters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) config_rule_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) compliance_type:
            std::option::Option<crate::model::ConformancePackComplianceType>,
    }
    impl Builder {
        /// Appends an item to `config_rule_names`.
        ///
        /// To override the contents of this collection use [`set_config_rule_names`](Self::set_config_rule_names).
        ///
        /// <p>Filters the results by Config rule names.</p>
        pub fn config_rule_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.config_rule_names.unwrap_or_default();
            v.push(input.into());
            self.config_rule_names = Some(v);
            self
        }
        /// <p>Filters the results by Config rule names.</p>
        pub fn set_config_rule_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.config_rule_names = input;
            self
        }
        /// <p>Filters the results by compliance.</p>
        /// <p>The allowed values are <code>COMPLIANT</code> and <code>NON_COMPLIANT</code>. <code>INSUFFICIENT_DATA</code> is not supported.</p>
        pub fn compliance_type(
            mut self,
            input: crate::model::ConformancePackComplianceType,
        ) -> Self {
            self.compliance_type = Some(input);
            self
        }
        /// <p>Filters the results by compliance.</p>
        /// <p>The allowed values are <code>COMPLIANT</code> and <code>NON_COMPLIANT</code>. <code>INSUFFICIENT_DATA</code> is not supported.</p>
        pub fn set_compliance_type(
            mut self,
            input: std::option::Option<crate::model::ConformancePackComplianceType>,
        ) -> Self {
            self.compliance_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ConformancePackComplianceFilters`](crate::model::ConformancePackComplianceFilters).
        pub fn build(self) -> crate::model::ConformancePackComplianceFilters {
            crate::model::ConformancePackComplianceFilters {
                config_rule_names: self.config_rule_names,
                compliance_type: self.compliance_type,
            }
        }
    }
}

/// <p>The current status of the configuration recorder.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfigurationRecorderStatus {
    /// <p>The name of the configuration recorder.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The time the recorder was last started.</p>
    #[doc(hidden)]
    pub last_start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time the recorder was last stopped.</p>
    #[doc(hidden)]
    pub last_stop_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Specifies whether or not the recorder is currently recording.</p>
    #[doc(hidden)]
    pub recording: bool,
    /// <p>The last (previous) status of the recorder.</p>
    #[doc(hidden)]
    pub last_status: std::option::Option<crate::model::RecorderStatus>,
    /// <p>The error code indicating that the recording failed.</p>
    #[doc(hidden)]
    pub last_error_code: std::option::Option<std::string::String>,
    /// <p>The message indicating that the recording failed due to an error.</p>
    #[doc(hidden)]
    pub last_error_message: std::option::Option<std::string::String>,
    /// <p>The time when the status was last changed.</p>
    #[doc(hidden)]
    pub last_status_change_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ConfigurationRecorderStatus {
    /// <p>The name of the configuration recorder.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The time the recorder was last started.</p>
    pub fn last_start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_start_time.as_ref()
    }
    /// <p>The time the recorder was last stopped.</p>
    pub fn last_stop_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_stop_time.as_ref()
    }
    /// <p>Specifies whether or not the recorder is currently recording.</p>
    pub fn recording(&self) -> bool {
        self.recording
    }
    /// <p>The last (previous) status of the recorder.</p>
    pub fn last_status(&self) -> std::option::Option<&crate::model::RecorderStatus> {
        self.last_status.as_ref()
    }
    /// <p>The error code indicating that the recording failed.</p>
    pub fn last_error_code(&self) -> std::option::Option<&str> {
        self.last_error_code.as_deref()
    }
    /// <p>The message indicating that the recording failed due to an error.</p>
    pub fn last_error_message(&self) -> std::option::Option<&str> {
        self.last_error_message.as_deref()
    }
    /// <p>The time when the status was last changed.</p>
    pub fn last_status_change_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_status_change_time.as_ref()
    }
}
impl ConfigurationRecorderStatus {
    /// Creates a new builder-style object to manufacture [`ConfigurationRecorderStatus`](crate::model::ConfigurationRecorderStatus).
    pub fn builder() -> crate::model::configuration_recorder_status::Builder {
        crate::model::configuration_recorder_status::Builder::default()
    }
}

/// See [`ConfigurationRecorderStatus`](crate::model::ConfigurationRecorderStatus).
pub mod configuration_recorder_status {

    /// A builder for [`ConfigurationRecorderStatus`](crate::model::ConfigurationRecorderStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) last_start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_stop_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) recording: std::option::Option<bool>,
        pub(crate) last_status: std::option::Option<crate::model::RecorderStatus>,
        pub(crate) last_error_code: std::option::Option<std::string::String>,
        pub(crate) last_error_message: std::option::Option<std::string::String>,
        pub(crate) last_status_change_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the configuration recorder.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the configuration recorder.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The time the recorder was last started.</p>
        pub fn last_start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_start_time = Some(input);
            self
        }
        /// <p>The time the recorder was last started.</p>
        pub fn set_last_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_start_time = input;
            self
        }
        /// <p>The time the recorder was last stopped.</p>
        pub fn last_stop_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_stop_time = Some(input);
            self
        }
        /// <p>The time the recorder was last stopped.</p>
        pub fn set_last_stop_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_stop_time = input;
            self
        }
        /// <p>Specifies whether or not the recorder is currently recording.</p>
        pub fn recording(mut self, input: bool) -> Self {
            self.recording = Some(input);
            self
        }
        /// <p>Specifies whether or not the recorder is currently recording.</p>
        pub fn set_recording(mut self, input: std::option::Option<bool>) -> Self {
            self.recording = input;
            self
        }
        /// <p>The last (previous) status of the recorder.</p>
        pub fn last_status(mut self, input: crate::model::RecorderStatus) -> Self {
            self.last_status = Some(input);
            self
        }
        /// <p>The last (previous) status of the recorder.</p>
        pub fn set_last_status(
            mut self,
            input: std::option::Option<crate::model::RecorderStatus>,
        ) -> Self {
            self.last_status = input;
            self
        }
        /// <p>The error code indicating that the recording failed.</p>
        pub fn last_error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_error_code = Some(input.into());
            self
        }
        /// <p>The error code indicating that the recording failed.</p>
        pub fn set_last_error_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_error_code = input;
            self
        }
        /// <p>The message indicating that the recording failed due to an error.</p>
        pub fn last_error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_error_message = Some(input.into());
            self
        }
        /// <p>The message indicating that the recording failed due to an error.</p>
        pub fn set_last_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_error_message = input;
            self
        }
        /// <p>The time when the status was last changed.</p>
        pub fn last_status_change_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_status_change_time = Some(input);
            self
        }
        /// <p>The time when the status was last changed.</p>
        pub fn set_last_status_change_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_status_change_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigurationRecorderStatus`](crate::model::ConfigurationRecorderStatus).
        pub fn build(self) -> crate::model::ConfigurationRecorderStatus {
            crate::model::ConfigurationRecorderStatus {
                name: self.name,
                last_start_time: self.last_start_time,
                last_stop_time: self.last_stop_time,
                recording: self.recording.unwrap_or_default(),
                last_status: self.last_status,
                last_error_code: self.last_error_code,
                last_error_message: self.last_error_message,
                last_status_change_time: self.last_status_change_time,
            }
        }
    }
}

/// When writing a match expression against `RecorderStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let recorderstatus = unimplemented!();
/// match recorderstatus {
///     RecorderStatus::Failure => { /* ... */ },
///     RecorderStatus::Pending => { /* ... */ },
///     RecorderStatus::Success => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `recorderstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RecorderStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RecorderStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RecorderStatus::NewFeature` is defined.
/// Specifically, when `recorderstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RecorderStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RecorderStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failure,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Success,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RecorderStatus {
    fn from(s: &str) -> Self {
        match s {
            "Failure" => RecorderStatus::Failure,
            "Pending" => RecorderStatus::Pending,
            "Success" => RecorderStatus::Success,
            other => RecorderStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for RecorderStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RecorderStatus::from(s))
    }
}
impl RecorderStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RecorderStatus::Failure => "Failure",
            RecorderStatus::Pending => "Pending",
            RecorderStatus::Success => "Success",
            RecorderStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Failure", "Pending", "Success"]
    }
}
impl AsRef<str> for RecorderStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The current sync status between the source and the aggregator account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AggregatedSourceStatus {
    /// <p>The source account ID or an organization.</p>
    #[doc(hidden)]
    pub source_id: std::option::Option<std::string::String>,
    /// <p>The source account or an organization.</p>
    #[doc(hidden)]
    pub source_type: std::option::Option<crate::model::AggregatedSourceType>,
    /// <p>The region authorized to collect aggregated data.</p>
    #[doc(hidden)]
    pub aws_region: std::option::Option<std::string::String>,
    /// <p>Filters the last updated status type.</p>
    /// <ul>
    /// <li> <p>Valid value FAILED indicates errors while moving data.</p> </li>
    /// <li> <p>Valid value SUCCEEDED indicates the data was successfully moved.</p> </li>
    /// <li> <p>Valid value OUTDATED indicates the data is not the most recent.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub last_update_status: std::option::Option<crate::model::AggregatedSourceStatusType>,
    /// <p>The time of the last update.</p>
    #[doc(hidden)]
    pub last_update_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The error code that Config returned when the source account aggregation last failed.</p>
    #[doc(hidden)]
    pub last_error_code: std::option::Option<std::string::String>,
    /// <p>The message indicating that the source account aggregation failed due to an error.</p>
    #[doc(hidden)]
    pub last_error_message: std::option::Option<std::string::String>,
}
impl AggregatedSourceStatus {
    /// <p>The source account ID or an organization.</p>
    pub fn source_id(&self) -> std::option::Option<&str> {
        self.source_id.as_deref()
    }
    /// <p>The source account or an organization.</p>
    pub fn source_type(&self) -> std::option::Option<&crate::model::AggregatedSourceType> {
        self.source_type.as_ref()
    }
    /// <p>The region authorized to collect aggregated data.</p>
    pub fn aws_region(&self) -> std::option::Option<&str> {
        self.aws_region.as_deref()
    }
    /// <p>Filters the last updated status type.</p>
    /// <ul>
    /// <li> <p>Valid value FAILED indicates errors while moving data.</p> </li>
    /// <li> <p>Valid value SUCCEEDED indicates the data was successfully moved.</p> </li>
    /// <li> <p>Valid value OUTDATED indicates the data is not the most recent.</p> </li>
    /// </ul>
    pub fn last_update_status(
        &self,
    ) -> std::option::Option<&crate::model::AggregatedSourceStatusType> {
        self.last_update_status.as_ref()
    }
    /// <p>The time of the last update.</p>
    pub fn last_update_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_update_time.as_ref()
    }
    /// <p>The error code that Config returned when the source account aggregation last failed.</p>
    pub fn last_error_code(&self) -> std::option::Option<&str> {
        self.last_error_code.as_deref()
    }
    /// <p>The message indicating that the source account aggregation failed due to an error.</p>
    pub fn last_error_message(&self) -> std::option::Option<&str> {
        self.last_error_message.as_deref()
    }
}
impl AggregatedSourceStatus {
    /// Creates a new builder-style object to manufacture [`AggregatedSourceStatus`](crate::model::AggregatedSourceStatus).
    pub fn builder() -> crate::model::aggregated_source_status::Builder {
        crate::model::aggregated_source_status::Builder::default()
    }
}

/// See [`AggregatedSourceStatus`](crate::model::AggregatedSourceStatus).
pub mod aggregated_source_status {

    /// A builder for [`AggregatedSourceStatus`](crate::model::AggregatedSourceStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_id: std::option::Option<std::string::String>,
        pub(crate) source_type: std::option::Option<crate::model::AggregatedSourceType>,
        pub(crate) aws_region: std::option::Option<std::string::String>,
        pub(crate) last_update_status:
            std::option::Option<crate::model::AggregatedSourceStatusType>,
        pub(crate) last_update_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_error_code: std::option::Option<std::string::String>,
        pub(crate) last_error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The source account ID or an organization.</p>
        pub fn source_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_id = Some(input.into());
            self
        }
        /// <p>The source account ID or an organization.</p>
        pub fn set_source_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_id = input;
            self
        }
        /// <p>The source account or an organization.</p>
        pub fn source_type(mut self, input: crate::model::AggregatedSourceType) -> Self {
            self.source_type = Some(input);
            self
        }
        /// <p>The source account or an organization.</p>
        pub fn set_source_type(
            mut self,
            input: std::option::Option<crate::model::AggregatedSourceType>,
        ) -> Self {
            self.source_type = input;
            self
        }
        /// <p>The region authorized to collect aggregated data.</p>
        pub fn aws_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_region = Some(input.into());
            self
        }
        /// <p>The region authorized to collect aggregated data.</p>
        pub fn set_aws_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.aws_region = input;
            self
        }
        /// <p>Filters the last updated status type.</p>
        /// <ul>
        /// <li> <p>Valid value FAILED indicates errors while moving data.</p> </li>
        /// <li> <p>Valid value SUCCEEDED indicates the data was successfully moved.</p> </li>
        /// <li> <p>Valid value OUTDATED indicates the data is not the most recent.</p> </li>
        /// </ul>
        pub fn last_update_status(
            mut self,
            input: crate::model::AggregatedSourceStatusType,
        ) -> Self {
            self.last_update_status = Some(input);
            self
        }
        /// <p>Filters the last updated status type.</p>
        /// <ul>
        /// <li> <p>Valid value FAILED indicates errors while moving data.</p> </li>
        /// <li> <p>Valid value SUCCEEDED indicates the data was successfully moved.</p> </li>
        /// <li> <p>Valid value OUTDATED indicates the data is not the most recent.</p> </li>
        /// </ul>
        pub fn set_last_update_status(
            mut self,
            input: std::option::Option<crate::model::AggregatedSourceStatusType>,
        ) -> Self {
            self.last_update_status = input;
            self
        }
        /// <p>The time of the last update.</p>
        pub fn last_update_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_update_time = Some(input);
            self
        }
        /// <p>The time of the last update.</p>
        pub fn set_last_update_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_update_time = input;
            self
        }
        /// <p>The error code that Config returned when the source account aggregation last failed.</p>
        pub fn last_error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_error_code = Some(input.into());
            self
        }
        /// <p>The error code that Config returned when the source account aggregation last failed.</p>
        pub fn set_last_error_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_error_code = input;
            self
        }
        /// <p>The message indicating that the source account aggregation failed due to an error.</p>
        pub fn last_error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_error_message = Some(input.into());
            self
        }
        /// <p>The message indicating that the source account aggregation failed due to an error.</p>
        pub fn set_last_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`AggregatedSourceStatus`](crate::model::AggregatedSourceStatus).
        pub fn build(self) -> crate::model::AggregatedSourceStatus {
            crate::model::AggregatedSourceStatus {
                source_id: self.source_id,
                source_type: self.source_type,
                aws_region: self.aws_region,
                last_update_status: self.last_update_status,
                last_update_time: self.last_update_time,
                last_error_code: self.last_error_code,
                last_error_message: self.last_error_message,
            }
        }
    }
}

/// When writing a match expression against `AggregatedSourceStatusType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let aggregatedsourcestatustype = unimplemented!();
/// match aggregatedsourcestatustype {
///     AggregatedSourceStatusType::Failed => { /* ... */ },
///     AggregatedSourceStatusType::Outdated => { /* ... */ },
///     AggregatedSourceStatusType::Succeeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `aggregatedsourcestatustype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AggregatedSourceStatusType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AggregatedSourceStatusType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AggregatedSourceStatusType::NewFeature` is defined.
/// Specifically, when `aggregatedsourcestatustype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AggregatedSourceStatusType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AggregatedSourceStatusType {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Outdated,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AggregatedSourceStatusType {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => AggregatedSourceStatusType::Failed,
            "OUTDATED" => AggregatedSourceStatusType::Outdated,
            "SUCCEEDED" => AggregatedSourceStatusType::Succeeded,
            other => AggregatedSourceStatusType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for AggregatedSourceStatusType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AggregatedSourceStatusType::from(s))
    }
}
impl AggregatedSourceStatusType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AggregatedSourceStatusType::Failed => "FAILED",
            AggregatedSourceStatusType::Outdated => "OUTDATED",
            AggregatedSourceStatusType::Succeeded => "SUCCEEDED",
            AggregatedSourceStatusType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FAILED", "OUTDATED", "SUCCEEDED"]
    }
}
impl AsRef<str> for AggregatedSourceStatusType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `AggregatedSourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let aggregatedsourcetype = unimplemented!();
/// match aggregatedsourcetype {
///     AggregatedSourceType::Account => { /* ... */ },
///     AggregatedSourceType::Organization => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `aggregatedsourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AggregatedSourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AggregatedSourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AggregatedSourceType::NewFeature` is defined.
/// Specifically, when `aggregatedsourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AggregatedSourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AggregatedSourceType {
    #[allow(missing_docs)] // documentation missing in model
    Account,
    #[allow(missing_docs)] // documentation missing in model
    Organization,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AggregatedSourceType {
    fn from(s: &str) -> Self {
        match s {
            "ACCOUNT" => AggregatedSourceType::Account,
            "ORGANIZATION" => AggregatedSourceType::Organization,
            other => {
                AggregatedSourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for AggregatedSourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AggregatedSourceType::from(s))
    }
}
impl AggregatedSourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AggregatedSourceType::Account => "ACCOUNT",
            AggregatedSourceType::Organization => "ORGANIZATION",
            AggregatedSourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACCOUNT", "ORGANIZATION"]
    }
}
impl AsRef<str> for AggregatedSourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Returns a filtered list of Detective or Proactive Config rules. By default, if the filter is not defined, this API returns an unfiltered list.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeConfigRulesFilters {
    /// <p>The mode of an evaluation. The valid values are Detective or Proactive.</p>
    #[doc(hidden)]
    pub evaluation_mode: std::option::Option<crate::model::EvaluationMode>,
}
impl DescribeConfigRulesFilters {
    /// <p>The mode of an evaluation. The valid values are Detective or Proactive.</p>
    pub fn evaluation_mode(&self) -> std::option::Option<&crate::model::EvaluationMode> {
        self.evaluation_mode.as_ref()
    }
}
impl DescribeConfigRulesFilters {
    /// Creates a new builder-style object to manufacture [`DescribeConfigRulesFilters`](crate::model::DescribeConfigRulesFilters).
    pub fn builder() -> crate::model::describe_config_rules_filters::Builder {
        crate::model::describe_config_rules_filters::Builder::default()
    }
}

/// See [`DescribeConfigRulesFilters`](crate::model::DescribeConfigRulesFilters).
pub mod describe_config_rules_filters {

    /// A builder for [`DescribeConfigRulesFilters`](crate::model::DescribeConfigRulesFilters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) evaluation_mode: std::option::Option<crate::model::EvaluationMode>,
    }
    impl Builder {
        /// <p>The mode of an evaluation. The valid values are Detective or Proactive.</p>
        pub fn evaluation_mode(mut self, input: crate::model::EvaluationMode) -> Self {
            self.evaluation_mode = Some(input);
            self
        }
        /// <p>The mode of an evaluation. The valid values are Detective or Proactive.</p>
        pub fn set_evaluation_mode(
            mut self,
            input: std::option::Option<crate::model::EvaluationMode>,
        ) -> Self {
            self.evaluation_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeConfigRulesFilters`](crate::model::DescribeConfigRulesFilters).
        pub fn build(self) -> crate::model::DescribeConfigRulesFilters {
            crate::model::DescribeConfigRulesFilters {
                evaluation_mode: self.evaluation_mode,
            }
        }
    }
}

/// <p>Status information for your Config Managed rules and Config Custom Policy rules. The status includes information such as the last time the rule ran, the last time it failed, and the related error for the last failure.</p>
/// <p>This action does not return status information about Config Custom Lambda rules.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfigRuleEvaluationStatus {
    /// <p>The name of the Config rule.</p>
    #[doc(hidden)]
    pub config_rule_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Config rule.</p>
    #[doc(hidden)]
    pub config_rule_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the Config rule.</p>
    #[doc(hidden)]
    pub config_rule_id: std::option::Option<std::string::String>,
    /// <p>The time that Config last successfully invoked the Config rule to evaluate your Amazon Web Services resources.</p>
    #[doc(hidden)]
    pub last_successful_invocation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that Config last failed to invoke the Config rule to evaluate your Amazon Web Services resources.</p>
    #[doc(hidden)]
    pub last_failed_invocation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that Config last successfully evaluated your Amazon Web Services resources against the rule.</p>
    #[doc(hidden)]
    pub last_successful_evaluation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that Config last failed to evaluate your Amazon Web Services resources against the rule.</p>
    #[doc(hidden)]
    pub last_failed_evaluation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that you first activated the Config rule.</p>
    #[doc(hidden)]
    pub first_activated_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that you last turned off the Config rule.</p>
    #[doc(hidden)]
    pub last_deactivated_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The error code that Config returned when the rule last failed.</p>
    #[doc(hidden)]
    pub last_error_code: std::option::Option<std::string::String>,
    /// <p>The error message that Config returned when the rule last failed.</p>
    #[doc(hidden)]
    pub last_error_message: std::option::Option<std::string::String>,
    /// <p>Indicates whether Config has evaluated your resources against the rule at least once.</p>
    /// <ul>
    /// <li> <p> <code>true</code> - Config has evaluated your Amazon Web Services resources against the rule at least once.</p> </li>
    /// <li> <p> <code>false</code> - Config has not finished evaluating your Amazon Web Services resources against the rule at least once.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub first_evaluation_started: bool,
    /// <p>The status of the last attempted delivery of a debug log for your Config Custom Policy rules. Either <code>Successful</code> or <code>Failed</code>.</p>
    #[doc(hidden)]
    pub last_debug_log_delivery_status: std::option::Option<std::string::String>,
    /// <p>The reason Config was not able to deliver a debug log. This is for the last failed attempt to retrieve a debug log for your Config Custom Policy rules.</p>
    #[doc(hidden)]
    pub last_debug_log_delivery_status_reason: std::option::Option<std::string::String>,
    /// <p>The time Config last attempted to deliver a debug log for your Config Custom Policy rules.</p>
    #[doc(hidden)]
    pub last_debug_log_delivery_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ConfigRuleEvaluationStatus {
    /// <p>The name of the Config rule.</p>
    pub fn config_rule_name(&self) -> std::option::Option<&str> {
        self.config_rule_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Config rule.</p>
    pub fn config_rule_arn(&self) -> std::option::Option<&str> {
        self.config_rule_arn.as_deref()
    }
    /// <p>The ID of the Config rule.</p>
    pub fn config_rule_id(&self) -> std::option::Option<&str> {
        self.config_rule_id.as_deref()
    }
    /// <p>The time that Config last successfully invoked the Config rule to evaluate your Amazon Web Services resources.</p>
    pub fn last_successful_invocation_time(
        &self,
    ) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_successful_invocation_time.as_ref()
    }
    /// <p>The time that Config last failed to invoke the Config rule to evaluate your Amazon Web Services resources.</p>
    pub fn last_failed_invocation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_failed_invocation_time.as_ref()
    }
    /// <p>The time that Config last successfully evaluated your Amazon Web Services resources against the rule.</p>
    pub fn last_successful_evaluation_time(
        &self,
    ) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_successful_evaluation_time.as_ref()
    }
    /// <p>The time that Config last failed to evaluate your Amazon Web Services resources against the rule.</p>
    pub fn last_failed_evaluation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_failed_evaluation_time.as_ref()
    }
    /// <p>The time that you first activated the Config rule.</p>
    pub fn first_activated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.first_activated_time.as_ref()
    }
    /// <p>The time that you last turned off the Config rule.</p>
    pub fn last_deactivated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_deactivated_time.as_ref()
    }
    /// <p>The error code that Config returned when the rule last failed.</p>
    pub fn last_error_code(&self) -> std::option::Option<&str> {
        self.last_error_code.as_deref()
    }
    /// <p>The error message that Config returned when the rule last failed.</p>
    pub fn last_error_message(&self) -> std::option::Option<&str> {
        self.last_error_message.as_deref()
    }
    /// <p>Indicates whether Config has evaluated your resources against the rule at least once.</p>
    /// <ul>
    /// <li> <p> <code>true</code> - Config has evaluated your Amazon Web Services resources against the rule at least once.</p> </li>
    /// <li> <p> <code>false</code> - Config has not finished evaluating your Amazon Web Services resources against the rule at least once.</p> </li>
    /// </ul>
    pub fn first_evaluation_started(&self) -> bool {
        self.first_evaluation_started
    }
    /// <p>The status of the last attempted delivery of a debug log for your Config Custom Policy rules. Either <code>Successful</code> or <code>Failed</code>.</p>
    pub fn last_debug_log_delivery_status(&self) -> std::option::Option<&str> {
        self.last_debug_log_delivery_status.as_deref()
    }
    /// <p>The reason Config was not able to deliver a debug log. This is for the last failed attempt to retrieve a debug log for your Config Custom Policy rules.</p>
    pub fn last_debug_log_delivery_status_reason(&self) -> std::option::Option<&str> {
        self.last_debug_log_delivery_status_reason.as_deref()
    }
    /// <p>The time Config last attempted to deliver a debug log for your Config Custom Policy rules.</p>
    pub fn last_debug_log_delivery_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_debug_log_delivery_time.as_ref()
    }
}
impl ConfigRuleEvaluationStatus {
    /// Creates a new builder-style object to manufacture [`ConfigRuleEvaluationStatus`](crate::model::ConfigRuleEvaluationStatus).
    pub fn builder() -> crate::model::config_rule_evaluation_status::Builder {
        crate::model::config_rule_evaluation_status::Builder::default()
    }
}

/// See [`ConfigRuleEvaluationStatus`](crate::model::ConfigRuleEvaluationStatus).
pub mod config_rule_evaluation_status {

    /// A builder for [`ConfigRuleEvaluationStatus`](crate::model::ConfigRuleEvaluationStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) config_rule_name: std::option::Option<std::string::String>,
        pub(crate) config_rule_arn: std::option::Option<std::string::String>,
        pub(crate) config_rule_id: std::option::Option<std::string::String>,
        pub(crate) last_successful_invocation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_failed_invocation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_successful_evaluation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_failed_evaluation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) first_activated_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_deactivated_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_error_code: std::option::Option<std::string::String>,
        pub(crate) last_error_message: std::option::Option<std::string::String>,
        pub(crate) first_evaluation_started: std::option::Option<bool>,
        pub(crate) last_debug_log_delivery_status: std::option::Option<std::string::String>,
        pub(crate) last_debug_log_delivery_status_reason: std::option::Option<std::string::String>,
        pub(crate) last_debug_log_delivery_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the Config rule.</p>
        pub fn config_rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.config_rule_name = Some(input.into());
            self
        }
        /// <p>The name of the Config rule.</p>
        pub fn set_config_rule_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.config_rule_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Config rule.</p>
        pub fn config_rule_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.config_rule_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Config rule.</p>
        pub fn set_config_rule_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.config_rule_arn = input;
            self
        }
        /// <p>The ID of the Config rule.</p>
        pub fn config_rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.config_rule_id = Some(input.into());
            self
        }
        /// <p>The ID of the Config rule.</p>
        pub fn set_config_rule_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.config_rule_id = input;
            self
        }
        /// <p>The time that Config last successfully invoked the Config rule to evaluate your Amazon Web Services resources.</p>
        pub fn last_successful_invocation_time(
            mut self,
            input: aws_smithy_types::DateTime,
        ) -> Self {
            self.last_successful_invocation_time = Some(input);
            self
        }
        /// <p>The time that Config last successfully invoked the Config rule to evaluate your Amazon Web Services resources.</p>
        pub fn set_last_successful_invocation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_successful_invocation_time = input;
            self
        }
        /// <p>The time that Config last failed to invoke the Config rule to evaluate your Amazon Web Services resources.</p>
        pub fn last_failed_invocation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_failed_invocation_time = Some(input);
            self
        }
        /// <p>The time that Config last failed to invoke the Config rule to evaluate your Amazon Web Services resources.</p>
        pub fn set_last_failed_invocation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_failed_invocation_time = input;
            self
        }
        /// <p>The time that Config last successfully evaluated your Amazon Web Services resources against the rule.</p>
        pub fn last_successful_evaluation_time(
            mut self,
            input: aws_smithy_types::DateTime,
        ) -> Self {
            self.last_successful_evaluation_time = Some(input);
            self
        }
        /// <p>The time that Config last successfully evaluated your Amazon Web Services resources against the rule.</p>
        pub fn set_last_successful_evaluation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_successful_evaluation_time = input;
            self
        }
        /// <p>The time that Config last failed to evaluate your Amazon Web Services resources against the rule.</p>
        pub fn last_failed_evaluation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_failed_evaluation_time = Some(input);
            self
        }
        /// <p>The time that Config last failed to evaluate your Amazon Web Services resources against the rule.</p>
        pub fn set_last_failed_evaluation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_failed_evaluation_time = input;
            self
        }
        /// <p>The time that you first activated the Config rule.</p>
        pub fn first_activated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.first_activated_time = Some(input);
            self
        }
        /// <p>The time that you first activated the Config rule.</p>
        pub fn set_first_activated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.first_activated_time = input;
            self
        }
        /// <p>The time that you last turned off the Config rule.</p>
        pub fn last_deactivated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_deactivated_time = Some(input);
            self
        }
        /// <p>The time that you last turned off the Config rule.</p>
        pub fn set_last_deactivated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_deactivated_time = input;
            self
        }
        /// <p>The error code that Config returned when the rule last failed.</p>
        pub fn last_error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_error_code = Some(input.into());
            self
        }
        /// <p>The error code that Config returned when the rule last failed.</p>
        pub fn set_last_error_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_error_code = input;
            self
        }
        /// <p>The error message that Config returned when the rule last failed.</p>
        pub fn last_error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_error_message = Some(input.into());
            self
        }
        /// <p>The error message that Config returned when the rule last failed.</p>
        pub fn set_last_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_error_message = input;
            self
        }
        /// <p>Indicates whether Config has evaluated your resources against the rule at least once.</p>
        /// <ul>
        /// <li> <p> <code>true</code> - Config has evaluated your Amazon Web Services resources against the rule at least once.</p> </li>
        /// <li> <p> <code>false</code> - Config has not finished evaluating your Amazon Web Services resources against the rule at least once.</p> </li>
        /// </ul>
        pub fn first_evaluation_started(mut self, input: bool) -> Self {
            self.first_evaluation_started = Some(input);
            self
        }
        /// <p>Indicates whether Config has evaluated your resources against the rule at least once.</p>
        /// <ul>
        /// <li> <p> <code>true</code> - Config has evaluated your Amazon Web Services resources against the rule at least once.</p> </li>
        /// <li> <p> <code>false</code> - Config has not finished evaluating your Amazon Web Services resources against the rule at least once.</p> </li>
        /// </ul>
        pub fn set_first_evaluation_started(mut self, input: std::option::Option<bool>) -> Self {
            self.first_evaluation_started = input;
            self
        }
        /// <p>The status of the last attempted delivery of a debug log for your Config Custom Policy rules. Either <code>Successful</code> or <code>Failed</code>.</p>
        pub fn last_debug_log_delivery_status(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.last_debug_log_delivery_status = Some(input.into());
            self
        }
        /// <p>The status of the last attempted delivery of a debug log for your Config Custom Policy rules. Either <code>Successful</code> or <code>Failed</code>.</p>
        pub fn set_last_debug_log_delivery_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_debug_log_delivery_status = input;
            self
        }
        /// <p>The reason Config was not able to deliver a debug log. This is for the last failed attempt to retrieve a debug log for your Config Custom Policy rules.</p>
        pub fn last_debug_log_delivery_status_reason(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.last_debug_log_delivery_status_reason = Some(input.into());
            self
        }
        /// <p>The reason Config was not able to deliver a debug log. This is for the last failed attempt to retrieve a debug log for your Config Custom Policy rules.</p>
        pub fn set_last_debug_log_delivery_status_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_debug_log_delivery_status_reason = input;
            self
        }
        /// <p>The time Config last attempted to deliver a debug log for your Config Custom Policy rules.</p>
        pub fn last_debug_log_delivery_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_debug_log_delivery_time = Some(input);
            self
        }
        /// <p>The time Config last attempted to deliver a debug log for your Config Custom Policy rules.</p>
        pub fn set_last_debug_log_delivery_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_debug_log_delivery_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigRuleEvaluationStatus`](crate::model::ConfigRuleEvaluationStatus).
        pub fn build(self) -> crate::model::ConfigRuleEvaluationStatus {
            crate::model::ConfigRuleEvaluationStatus {
                config_rule_name: self.config_rule_name,
                config_rule_arn: self.config_rule_arn,
                config_rule_id: self.config_rule_id,
                last_successful_invocation_time: self.last_successful_invocation_time,
                last_failed_invocation_time: self.last_failed_invocation_time,
                last_successful_evaluation_time: self.last_successful_evaluation_time,
                last_failed_evaluation_time: self.last_failed_evaluation_time,
                first_activated_time: self.first_activated_time,
                last_deactivated_time: self.last_deactivated_time,
                last_error_code: self.last_error_code,
                last_error_message: self.last_error_message,
                first_evaluation_started: self.first_evaluation_started.unwrap_or_default(),
                last_debug_log_delivery_status: self.last_debug_log_delivery_status,
                last_debug_log_delivery_status_reason: self.last_debug_log_delivery_status_reason,
                last_debug_log_delivery_time: self.last_debug_log_delivery_time,
            }
        }
    }
}

/// <p>Indicates whether an Amazon Web Services resource that is evaluated according to one or more Config rules is compliant. A resource is compliant if it complies with all of the rules that evaluate it. A resource is noncompliant if it does not comply with one or more of these rules.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComplianceByResource {
    /// <p>The type of the Amazon Web Services resource that was evaluated.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services resource that was evaluated.</p>
    #[doc(hidden)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>Indicates whether the Amazon Web Services resource complies with all of the Config rules that evaluated it.</p>
    #[doc(hidden)]
    pub compliance: std::option::Option<crate::model::Compliance>,
}
impl ComplianceByResource {
    /// <p>The type of the Amazon Web Services resource that was evaluated.</p>
    pub fn resource_type(&self) -> std::option::Option<&str> {
        self.resource_type.as_deref()
    }
    /// <p>The ID of the Amazon Web Services resource that was evaluated.</p>
    pub fn resource_id(&self) -> std::option::Option<&str> {
        self.resource_id.as_deref()
    }
    /// <p>Indicates whether the Amazon Web Services resource complies with all of the Config rules that evaluated it.</p>
    pub fn compliance(&self) -> std::option::Option<&crate::model::Compliance> {
        self.compliance.as_ref()
    }
}
impl ComplianceByResource {
    /// Creates a new builder-style object to manufacture [`ComplianceByResource`](crate::model::ComplianceByResource).
    pub fn builder() -> crate::model::compliance_by_resource::Builder {
        crate::model::compliance_by_resource::Builder::default()
    }
}

/// See [`ComplianceByResource`](crate::model::ComplianceByResource).
pub mod compliance_by_resource {

    /// A builder for [`ComplianceByResource`](crate::model::ComplianceByResource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) compliance: std::option::Option<crate::model::Compliance>,
    }
    impl Builder {
        /// <p>The type of the Amazon Web Services resource that was evaluated.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The type of the Amazon Web Services resource that was evaluated.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The ID of the Amazon Web Services resource that was evaluated.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The ID of the Amazon Web Services resource that was evaluated.</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>Indicates whether the Amazon Web Services resource complies with all of the Config rules that evaluated it.</p>
        pub fn compliance(mut self, input: crate::model::Compliance) -> Self {
            self.compliance = Some(input);
            self
        }
        /// <p>Indicates whether the Amazon Web Services resource complies with all of the Config rules that evaluated it.</p>
        pub fn set_compliance(
            mut self,
            input: std::option::Option<crate::model::Compliance>,
        ) -> Self {
            self.compliance = input;
            self
        }
        /// Consumes the builder and constructs a [`ComplianceByResource`](crate::model::ComplianceByResource).
        pub fn build(self) -> crate::model::ComplianceByResource {
            crate::model::ComplianceByResource {
                resource_type: self.resource_type,
                resource_id: self.resource_id,
                compliance: self.compliance,
            }
        }
    }
}

/// <p>Indicates whether an Amazon Web Services resource or Config rule is compliant and provides the number of contributors that affect the compliance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Compliance {
    /// <p>Indicates whether an Amazon Web Services resource or Config rule is compliant.</p>
    /// <p>A resource is compliant if it complies with all of the Config rules that evaluate it. A resource is noncompliant if it does not comply with one or more of these rules.</p>
    /// <p>A rule is compliant if all of the resources that the rule evaluates comply with it. A rule is noncompliant if any of these resources do not comply.</p>
    /// <p>Config returns the <code>INSUFFICIENT_DATA</code> value when no evaluation results are available for the Amazon Web Services resource or Config rule.</p>
    /// <p>For the <code>Compliance</code> data type, Config supports only <code>COMPLIANT</code>, <code>NON_COMPLIANT</code>, and <code>INSUFFICIENT_DATA</code> values. Config does not support the <code>NOT_APPLICABLE</code> value for the <code>Compliance</code> data type.</p>
    #[doc(hidden)]
    pub compliance_type: std::option::Option<crate::model::ComplianceType>,
    /// <p>The number of Amazon Web Services resources or Config rules that cause a result of <code>NON_COMPLIANT</code>, up to a maximum number.</p>
    #[doc(hidden)]
    pub compliance_contributor_count: std::option::Option<crate::model::ComplianceContributorCount>,
}
impl Compliance {
    /// <p>Indicates whether an Amazon Web Services resource or Config rule is compliant.</p>
    /// <p>A resource is compliant if it complies with all of the Config rules that evaluate it. A resource is noncompliant if it does not comply with one or more of these rules.</p>
    /// <p>A rule is compliant if all of the resources that the rule evaluates comply with it. A rule is noncompliant if any of these resources do not comply.</p>
    /// <p>Config returns the <code>INSUFFICIENT_DATA</code> value when no evaluation results are available for the Amazon Web Services resource or Config rule.</p>
    /// <p>For the <code>Compliance</code> data type, Config supports only <code>COMPLIANT</code>, <code>NON_COMPLIANT</code>, and <code>INSUFFICIENT_DATA</code> values. Config does not support the <code>NOT_APPLICABLE</code> value for the <code>Compliance</code> data type.</p>
    pub fn compliance_type(&self) -> std::option::Option<&crate::model::ComplianceType> {
        self.compliance_type.as_ref()
    }
    /// <p>The number of Amazon Web Services resources or Config rules that cause a result of <code>NON_COMPLIANT</code>, up to a maximum number.</p>
    pub fn compliance_contributor_count(
        &self,
    ) -> std::option::Option<&crate::model::ComplianceContributorCount> {
        self.compliance_contributor_count.as_ref()
    }
}
impl Compliance {
    /// Creates a new builder-style object to manufacture [`Compliance`](crate::model::Compliance).
    pub fn builder() -> crate::model::compliance::Builder {
        crate::model::compliance::Builder::default()
    }
}

/// See [`Compliance`](crate::model::Compliance).
pub mod compliance {

    /// A builder for [`Compliance`](crate::model::Compliance).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) compliance_type: std::option::Option<crate::model::ComplianceType>,
        pub(crate) compliance_contributor_count:
            std::option::Option<crate::model::ComplianceContributorCount>,
    }
    impl Builder {
        /// <p>Indicates whether an Amazon Web Services resource or Config rule is compliant.</p>
        /// <p>A resource is compliant if it complies with all of the Config rules that evaluate it. A resource is noncompliant if it does not comply with one or more of these rules.</p>
        /// <p>A rule is compliant if all of the resources that the rule evaluates comply with it. A rule is noncompliant if any of these resources do not comply.</p>
        /// <p>Config returns the <code>INSUFFICIENT_DATA</code> value when no evaluation results are available for the Amazon Web Services resource or Config rule.</p>
        /// <p>For the <code>Compliance</code> data type, Config supports only <code>COMPLIANT</code>, <code>NON_COMPLIANT</code>, and <code>INSUFFICIENT_DATA</code> values. Config does not support the <code>NOT_APPLICABLE</code> value for the <code>Compliance</code> data type.</p>
        pub fn compliance_type(mut self, input: crate::model::ComplianceType) -> Self {
            self.compliance_type = Some(input);
            self
        }
        /// <p>Indicates whether an Amazon Web Services resource or Config rule is compliant.</p>
        /// <p>A resource is compliant if it complies with all of the Config rules that evaluate it. A resource is noncompliant if it does not comply with one or more of these rules.</p>
        /// <p>A rule is compliant if all of the resources that the rule evaluates comply with it. A rule is noncompliant if any of these resources do not comply.</p>
        /// <p>Config returns the <code>INSUFFICIENT_DATA</code> value when no evaluation results are available for the Amazon Web Services resource or Config rule.</p>
        /// <p>For the <code>Compliance</code> data type, Config supports only <code>COMPLIANT</code>, <code>NON_COMPLIANT</code>, and <code>INSUFFICIENT_DATA</code> values. Config does not support the <code>NOT_APPLICABLE</code> value for the <code>Compliance</code> data type.</p>
        pub fn set_compliance_type(
            mut self,
            input: std::option::Option<crate::model::ComplianceType>,
        ) -> Self {
            self.compliance_type = input;
            self
        }
        /// <p>The number of Amazon Web Services resources or Config rules that cause a result of <code>NON_COMPLIANT</code>, up to a maximum number.</p>
        pub fn compliance_contributor_count(
            mut self,
            input: crate::model::ComplianceContributorCount,
        ) -> Self {
            self.compliance_contributor_count = Some(input);
            self
        }
        /// <p>The number of Amazon Web Services resources or Config rules that cause a result of <code>NON_COMPLIANT</code>, up to a maximum number.</p>
        pub fn set_compliance_contributor_count(
            mut self,
            input: std::option::Option<crate::model::ComplianceContributorCount>,
        ) -> Self {
            self.compliance_contributor_count = input;
            self
        }
        /// Consumes the builder and constructs a [`Compliance`](crate::model::Compliance).
        pub fn build(self) -> crate::model::Compliance {
            crate::model::Compliance {
                compliance_type: self.compliance_type,
                compliance_contributor_count: self.compliance_contributor_count,
            }
        }
    }
}

/// <p>Indicates whether an Config rule is compliant. A rule is compliant if all of the resources that the rule evaluated comply with it. A rule is noncompliant if any of these resources do not comply.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComplianceByConfigRule {
    /// <p>The name of the Config rule.</p>
    #[doc(hidden)]
    pub config_rule_name: std::option::Option<std::string::String>,
    /// <p>Indicates whether the Config rule is compliant.</p>
    #[doc(hidden)]
    pub compliance: std::option::Option<crate::model::Compliance>,
}
impl ComplianceByConfigRule {
    /// <p>The name of the Config rule.</p>
    pub fn config_rule_name(&self) -> std::option::Option<&str> {
        self.config_rule_name.as_deref()
    }
    /// <p>Indicates whether the Config rule is compliant.</p>
    pub fn compliance(&self) -> std::option::Option<&crate::model::Compliance> {
        self.compliance.as_ref()
    }
}
impl ComplianceByConfigRule {
    /// Creates a new builder-style object to manufacture [`ComplianceByConfigRule`](crate::model::ComplianceByConfigRule).
    pub fn builder() -> crate::model::compliance_by_config_rule::Builder {
        crate::model::compliance_by_config_rule::Builder::default()
    }
}

/// See [`ComplianceByConfigRule`](crate::model::ComplianceByConfigRule).
pub mod compliance_by_config_rule {

    /// A builder for [`ComplianceByConfigRule`](crate::model::ComplianceByConfigRule).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) config_rule_name: std::option::Option<std::string::String>,
        pub(crate) compliance: std::option::Option<crate::model::Compliance>,
    }
    impl Builder {
        /// <p>The name of the Config rule.</p>
        pub fn config_rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.config_rule_name = Some(input.into());
            self
        }
        /// <p>The name of the Config rule.</p>
        pub fn set_config_rule_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.config_rule_name = input;
            self
        }
        /// <p>Indicates whether the Config rule is compliant.</p>
        pub fn compliance(mut self, input: crate::model::Compliance) -> Self {
            self.compliance = Some(input);
            self
        }
        /// <p>Indicates whether the Config rule is compliant.</p>
        pub fn set_compliance(
            mut self,
            input: std::option::Option<crate::model::Compliance>,
        ) -> Self {
            self.compliance = input;
            self
        }
        /// Consumes the builder and constructs a [`ComplianceByConfigRule`](crate::model::ComplianceByConfigRule).
        pub fn build(self) -> crate::model::ComplianceByConfigRule {
            crate::model::ComplianceByConfigRule {
                config_rule_name: self.config_rule_name,
                compliance: self.compliance,
            }
        }
    }
}

/// <p>Provides aggregate compliance of the conformance pack. Indicates whether a conformance pack is compliant based on the name of the conformance pack, account ID, and region.</p>
/// <p>A conformance pack is compliant if all of the rules in a conformance packs are compliant. It is noncompliant if any of the rules are not compliant. The compliance status of a conformance pack is INSUFFICIENT_DATA only if all rules within a conformance pack cannot be evaluated due to insufficient data. If some of the rules in a conformance pack are compliant but the compliance status of other rules in that same conformance pack is INSUFFICIENT_DATA, the conformance pack shows compliant.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AggregateComplianceByConformancePack {
    /// <p>The name of the conformance pack.</p>
    #[doc(hidden)]
    pub conformance_pack_name: std::option::Option<std::string::String>,
    /// <p>The compliance status of the conformance pack.</p>
    #[doc(hidden)]
    pub compliance: std::option::Option<crate::model::AggregateConformancePackCompliance>,
    /// <p>The 12-digit Amazon Web Services account ID of the source account.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The source Amazon Web Services Region from where the data is aggregated.</p>
    #[doc(hidden)]
    pub aws_region: std::option::Option<std::string::String>,
}
impl AggregateComplianceByConformancePack {
    /// <p>The name of the conformance pack.</p>
    pub fn conformance_pack_name(&self) -> std::option::Option<&str> {
        self.conformance_pack_name.as_deref()
    }
    /// <p>The compliance status of the conformance pack.</p>
    pub fn compliance(
        &self,
    ) -> std::option::Option<&crate::model::AggregateConformancePackCompliance> {
        self.compliance.as_ref()
    }
    /// <p>The 12-digit Amazon Web Services account ID of the source account.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The source Amazon Web Services Region from where the data is aggregated.</p>
    pub fn aws_region(&self) -> std::option::Option<&str> {
        self.aws_region.as_deref()
    }
}
impl AggregateComplianceByConformancePack {
    /// Creates a new builder-style object to manufacture [`AggregateComplianceByConformancePack`](crate::model::AggregateComplianceByConformancePack).
    pub fn builder() -> crate::model::aggregate_compliance_by_conformance_pack::Builder {
        crate::model::aggregate_compliance_by_conformance_pack::Builder::default()
    }
}

/// See [`AggregateComplianceByConformancePack`](crate::model::AggregateComplianceByConformancePack).
pub mod aggregate_compliance_by_conformance_pack {

    /// A builder for [`AggregateComplianceByConformancePack`](crate::model::AggregateComplianceByConformancePack).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) conformance_pack_name: std::option::Option<std::string::String>,
        pub(crate) compliance:
            std::option::Option<crate::model::AggregateConformancePackCompliance>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) aws_region: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the conformance pack.</p>
        pub fn conformance_pack_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.conformance_pack_name = Some(input.into());
            self
        }
        /// <p>The name of the conformance pack.</p>
        pub fn set_conformance_pack_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.conformance_pack_name = input;
            self
        }
        /// <p>The compliance status of the conformance pack.</p>
        pub fn compliance(
            mut self,
            input: crate::model::AggregateConformancePackCompliance,
        ) -> Self {
            self.compliance = Some(input);
            self
        }
        /// <p>The compliance status of the conformance pack.</p>
        pub fn set_compliance(
            mut self,
            input: std::option::Option<crate::model::AggregateConformancePackCompliance>,
        ) -> Self {
            self.compliance = input;
            self
        }
        /// <p>The 12-digit Amazon Web Services account ID of the source account.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The 12-digit Amazon Web Services account ID of the source account.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The source Amazon Web Services Region from where the data is aggregated.</p>
        pub fn aws_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_region = Some(input.into());
            self
        }
        /// <p>The source Amazon Web Services Region from where the data is aggregated.</p>
        pub fn set_aws_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.aws_region = input;
            self
        }
        /// Consumes the builder and constructs a [`AggregateComplianceByConformancePack`](crate::model::AggregateComplianceByConformancePack).
        pub fn build(self) -> crate::model::AggregateComplianceByConformancePack {
            crate::model::AggregateComplianceByConformancePack {
                conformance_pack_name: self.conformance_pack_name,
                compliance: self.compliance,
                account_id: self.account_id,
                aws_region: self.aws_region,
            }
        }
    }
}

/// <p>Provides the number of compliant and noncompliant rules within a conformance pack. Also provides the compliance status of the conformance pack and the total rule count which includes compliant rules, noncompliant rules, and rules that cannot be evaluated due to insufficient data.</p>
/// <p>A conformance pack is compliant if all of the rules in a conformance packs are compliant. It is noncompliant if any of the rules are not compliant. The compliance status of a conformance pack is INSUFFICIENT_DATA only if all rules within a conformance pack cannot be evaluated due to insufficient data. If some of the rules in a conformance pack are compliant but the compliance status of other rules in that same conformance pack is INSUFFICIENT_DATA, the conformance pack shows compliant.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AggregateConformancePackCompliance {
    /// <p>The compliance status of the conformance pack.</p>
    #[doc(hidden)]
    pub compliance_type: std::option::Option<crate::model::ConformancePackComplianceType>,
    /// <p>The number of compliant Config Rules.</p>
    #[doc(hidden)]
    pub compliant_rule_count: i32,
    /// <p>The number of noncompliant Config Rules.</p>
    #[doc(hidden)]
    pub non_compliant_rule_count: i32,
    /// <p>Total number of compliant rules, noncompliant rules, and the rules that do not have any applicable resources to evaluate upon resulting in insufficient data.</p>
    #[doc(hidden)]
    pub total_rule_count: i32,
}
impl AggregateConformancePackCompliance {
    /// <p>The compliance status of the conformance pack.</p>
    pub fn compliance_type(
        &self,
    ) -> std::option::Option<&crate::model::ConformancePackComplianceType> {
        self.compliance_type.as_ref()
    }
    /// <p>The number of compliant Config Rules.</p>
    pub fn compliant_rule_count(&self) -> i32 {
        self.compliant_rule_count
    }
    /// <p>The number of noncompliant Config Rules.</p>
    pub fn non_compliant_rule_count(&self) -> i32 {
        self.non_compliant_rule_count
    }
    /// <p>Total number of compliant rules, noncompliant rules, and the rules that do not have any applicable resources to evaluate upon resulting in insufficient data.</p>
    pub fn total_rule_count(&self) -> i32 {
        self.total_rule_count
    }
}
impl AggregateConformancePackCompliance {
    /// Creates a new builder-style object to manufacture [`AggregateConformancePackCompliance`](crate::model::AggregateConformancePackCompliance).
    pub fn builder() -> crate::model::aggregate_conformance_pack_compliance::Builder {
        crate::model::aggregate_conformance_pack_compliance::Builder::default()
    }
}

/// See [`AggregateConformancePackCompliance`](crate::model::AggregateConformancePackCompliance).
pub mod aggregate_conformance_pack_compliance {

    /// A builder for [`AggregateConformancePackCompliance`](crate::model::AggregateConformancePackCompliance).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) compliance_type:
            std::option::Option<crate::model::ConformancePackComplianceType>,
        pub(crate) compliant_rule_count: std::option::Option<i32>,
        pub(crate) non_compliant_rule_count: std::option::Option<i32>,
        pub(crate) total_rule_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The compliance status of the conformance pack.</p>
        pub fn compliance_type(
            mut self,
            input: crate::model::ConformancePackComplianceType,
        ) -> Self {
            self.compliance_type = Some(input);
            self
        }
        /// <p>The compliance status of the conformance pack.</p>
        pub fn set_compliance_type(
            mut self,
            input: std::option::Option<crate::model::ConformancePackComplianceType>,
        ) -> Self {
            self.compliance_type = input;
            self
        }
        /// <p>The number of compliant Config Rules.</p>
        pub fn compliant_rule_count(mut self, input: i32) -> Self {
            self.compliant_rule_count = Some(input);
            self
        }
        /// <p>The number of compliant Config Rules.</p>
        pub fn set_compliant_rule_count(mut self, input: std::option::Option<i32>) -> Self {
            self.compliant_rule_count = input;
            self
        }
        /// <p>The number of noncompliant Config Rules.</p>
        pub fn non_compliant_rule_count(mut self, input: i32) -> Self {
            self.non_compliant_rule_count = Some(input);
            self
        }
        /// <p>The number of noncompliant Config Rules.</p>
        pub fn set_non_compliant_rule_count(mut self, input: std::option::Option<i32>) -> Self {
            self.non_compliant_rule_count = input;
            self
        }
        /// <p>Total number of compliant rules, noncompliant rules, and the rules that do not have any applicable resources to evaluate upon resulting in insufficient data.</p>
        pub fn total_rule_count(mut self, input: i32) -> Self {
            self.total_rule_count = Some(input);
            self
        }
        /// <p>Total number of compliant rules, noncompliant rules, and the rules that do not have any applicable resources to evaluate upon resulting in insufficient data.</p>
        pub fn set_total_rule_count(mut self, input: std::option::Option<i32>) -> Self {
            self.total_rule_count = input;
            self
        }
        /// Consumes the builder and constructs a [`AggregateConformancePackCompliance`](crate::model::AggregateConformancePackCompliance).
        pub fn build(self) -> crate::model::AggregateConformancePackCompliance {
            crate::model::AggregateConformancePackCompliance {
                compliance_type: self.compliance_type,
                compliant_rule_count: self.compliant_rule_count.unwrap_or_default(),
                non_compliant_rule_count: self.non_compliant_rule_count.unwrap_or_default(),
                total_rule_count: self.total_rule_count.unwrap_or_default(),
            }
        }
    }
}

/// <p>Filters the conformance packs based on an account ID, region, compliance type, and the name of the conformance pack.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AggregateConformancePackComplianceFilters {
    /// <p>The name of the conformance pack.</p>
    #[doc(hidden)]
    pub conformance_pack_name: std::option::Option<std::string::String>,
    /// <p>The compliance status of the conformance pack.</p>
    #[doc(hidden)]
    pub compliance_type: std::option::Option<crate::model::ConformancePackComplianceType>,
    /// <p>The 12-digit Amazon Web Services account ID of the source account.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The source Amazon Web Services Region from where the data is aggregated.</p>
    #[doc(hidden)]
    pub aws_region: std::option::Option<std::string::String>,
}
impl AggregateConformancePackComplianceFilters {
    /// <p>The name of the conformance pack.</p>
    pub fn conformance_pack_name(&self) -> std::option::Option<&str> {
        self.conformance_pack_name.as_deref()
    }
    /// <p>The compliance status of the conformance pack.</p>
    pub fn compliance_type(
        &self,
    ) -> std::option::Option<&crate::model::ConformancePackComplianceType> {
        self.compliance_type.as_ref()
    }
    /// <p>The 12-digit Amazon Web Services account ID of the source account.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The source Amazon Web Services Region from where the data is aggregated.</p>
    pub fn aws_region(&self) -> std::option::Option<&str> {
        self.aws_region.as_deref()
    }
}
impl AggregateConformancePackComplianceFilters {
    /// Creates a new builder-style object to manufacture [`AggregateConformancePackComplianceFilters`](crate::model::AggregateConformancePackComplianceFilters).
    pub fn builder() -> crate::model::aggregate_conformance_pack_compliance_filters::Builder {
        crate::model::aggregate_conformance_pack_compliance_filters::Builder::default()
    }
}

/// See [`AggregateConformancePackComplianceFilters`](crate::model::AggregateConformancePackComplianceFilters).
pub mod aggregate_conformance_pack_compliance_filters {

    /// A builder for [`AggregateConformancePackComplianceFilters`](crate::model::AggregateConformancePackComplianceFilters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) conformance_pack_name: std::option::Option<std::string::String>,
        pub(crate) compliance_type:
            std::option::Option<crate::model::ConformancePackComplianceType>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) aws_region: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the conformance pack.</p>
        pub fn conformance_pack_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.conformance_pack_name = Some(input.into());
            self
        }
        /// <p>The name of the conformance pack.</p>
        pub fn set_conformance_pack_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.conformance_pack_name = input;
            self
        }
        /// <p>The compliance status of the conformance pack.</p>
        pub fn compliance_type(
            mut self,
            input: crate::model::ConformancePackComplianceType,
        ) -> Self {
            self.compliance_type = Some(input);
            self
        }
        /// <p>The compliance status of the conformance pack.</p>
        pub fn set_compliance_type(
            mut self,
            input: std::option::Option<crate::model::ConformancePackComplianceType>,
        ) -> Self {
            self.compliance_type = input;
            self
        }
        /// <p>The 12-digit Amazon Web Services account ID of the source account.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The 12-digit Amazon Web Services account ID of the source account.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The source Amazon Web Services Region from where the data is aggregated.</p>
        pub fn aws_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_region = Some(input.into());
            self
        }
        /// <p>The source Amazon Web Services Region from where the data is aggregated.</p>
        pub fn set_aws_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.aws_region = input;
            self
        }
        /// Consumes the builder and constructs a [`AggregateConformancePackComplianceFilters`](crate::model::AggregateConformancePackComplianceFilters).
        pub fn build(self) -> crate::model::AggregateConformancePackComplianceFilters {
            crate::model::AggregateConformancePackComplianceFilters {
                conformance_pack_name: self.conformance_pack_name,
                compliance_type: self.compliance_type,
                account_id: self.account_id,
                aws_region: self.aws_region,
            }
        }
    }
}

/// <p>Indicates whether an Config rule is compliant based on account ID, region, compliance, and rule name.</p>
/// <p>A rule is compliant if all of the resources that the rule evaluated comply with it. It is noncompliant if any of these resources do not comply.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AggregateComplianceByConfigRule {
    /// <p>The name of the Config rule.</p>
    #[doc(hidden)]
    pub config_rule_name: std::option::Option<std::string::String>,
    /// <p>Indicates whether an Amazon Web Services resource or Config rule is compliant and provides the number of contributors that affect the compliance.</p>
    #[doc(hidden)]
    pub compliance: std::option::Option<crate::model::Compliance>,
    /// <p>The 12-digit account ID of the source account.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The source region from where the data is aggregated.</p>
    #[doc(hidden)]
    pub aws_region: std::option::Option<std::string::String>,
}
impl AggregateComplianceByConfigRule {
    /// <p>The name of the Config rule.</p>
    pub fn config_rule_name(&self) -> std::option::Option<&str> {
        self.config_rule_name.as_deref()
    }
    /// <p>Indicates whether an Amazon Web Services resource or Config rule is compliant and provides the number of contributors that affect the compliance.</p>
    pub fn compliance(&self) -> std::option::Option<&crate::model::Compliance> {
        self.compliance.as_ref()
    }
    /// <p>The 12-digit account ID of the source account.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The source region from where the data is aggregated.</p>
    pub fn aws_region(&self) -> std::option::Option<&str> {
        self.aws_region.as_deref()
    }
}
impl AggregateComplianceByConfigRule {
    /// Creates a new builder-style object to manufacture [`AggregateComplianceByConfigRule`](crate::model::AggregateComplianceByConfigRule).
    pub fn builder() -> crate::model::aggregate_compliance_by_config_rule::Builder {
        crate::model::aggregate_compliance_by_config_rule::Builder::default()
    }
}

/// See [`AggregateComplianceByConfigRule`](crate::model::AggregateComplianceByConfigRule).
pub mod aggregate_compliance_by_config_rule {

    /// A builder for [`AggregateComplianceByConfigRule`](crate::model::AggregateComplianceByConfigRule).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) config_rule_name: std::option::Option<std::string::String>,
        pub(crate) compliance: std::option::Option<crate::model::Compliance>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) aws_region: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Config rule.</p>
        pub fn config_rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.config_rule_name = Some(input.into());
            self
        }
        /// <p>The name of the Config rule.</p>
        pub fn set_config_rule_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.config_rule_name = input;
            self
        }
        /// <p>Indicates whether an Amazon Web Services resource or Config rule is compliant and provides the number of contributors that affect the compliance.</p>
        pub fn compliance(mut self, input: crate::model::Compliance) -> Self {
            self.compliance = Some(input);
            self
        }
        /// <p>Indicates whether an Amazon Web Services resource or Config rule is compliant and provides the number of contributors that affect the compliance.</p>
        pub fn set_compliance(
            mut self,
            input: std::option::Option<crate::model::Compliance>,
        ) -> Self {
            self.compliance = input;
            self
        }
        /// <p>The 12-digit account ID of the source account.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The 12-digit account ID of the source account.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The source region from where the data is aggregated.</p>
        pub fn aws_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_region = Some(input.into());
            self
        }
        /// <p>The source region from where the data is aggregated.</p>
        pub fn set_aws_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.aws_region = input;
            self
        }
        /// Consumes the builder and constructs a [`AggregateComplianceByConfigRule`](crate::model::AggregateComplianceByConfigRule).
        pub fn build(self) -> crate::model::AggregateComplianceByConfigRule {
            crate::model::AggregateComplianceByConfigRule {
                config_rule_name: self.config_rule_name,
                compliance: self.compliance,
                account_id: self.account_id,
                aws_region: self.aws_region,
            }
        }
    }
}

/// <p>Filters the compliance results based on account ID, region, compliance type, and rule name.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfigRuleComplianceFilters {
    /// <p>The name of the Config rule.</p>
    #[doc(hidden)]
    pub config_rule_name: std::option::Option<std::string::String>,
    /// <p>The rule compliance status.</p>
    /// <p>For the <code>ConfigRuleComplianceFilters</code> data type, Config supports only <code>COMPLIANT</code> and <code>NON_COMPLIANT</code>. Config does not support the <code>NOT_APPLICABLE</code> and the <code>INSUFFICIENT_DATA</code> values.</p>
    #[doc(hidden)]
    pub compliance_type: std::option::Option<crate::model::ComplianceType>,
    /// <p>The 12-digit account ID of the source account. </p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The source region where the data is aggregated. </p>
    #[doc(hidden)]
    pub aws_region: std::option::Option<std::string::String>,
}
impl ConfigRuleComplianceFilters {
    /// <p>The name of the Config rule.</p>
    pub fn config_rule_name(&self) -> std::option::Option<&str> {
        self.config_rule_name.as_deref()
    }
    /// <p>The rule compliance status.</p>
    /// <p>For the <code>ConfigRuleComplianceFilters</code> data type, Config supports only <code>COMPLIANT</code> and <code>NON_COMPLIANT</code>. Config does not support the <code>NOT_APPLICABLE</code> and the <code>INSUFFICIENT_DATA</code> values.</p>
    pub fn compliance_type(&self) -> std::option::Option<&crate::model::ComplianceType> {
        self.compliance_type.as_ref()
    }
    /// <p>The 12-digit account ID of the source account. </p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The source region where the data is aggregated. </p>
    pub fn aws_region(&self) -> std::option::Option<&str> {
        self.aws_region.as_deref()
    }
}
impl ConfigRuleComplianceFilters {
    /// Creates a new builder-style object to manufacture [`ConfigRuleComplianceFilters`](crate::model::ConfigRuleComplianceFilters).
    pub fn builder() -> crate::model::config_rule_compliance_filters::Builder {
        crate::model::config_rule_compliance_filters::Builder::default()
    }
}

/// See [`ConfigRuleComplianceFilters`](crate::model::ConfigRuleComplianceFilters).
pub mod config_rule_compliance_filters {

    /// A builder for [`ConfigRuleComplianceFilters`](crate::model::ConfigRuleComplianceFilters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) config_rule_name: std::option::Option<std::string::String>,
        pub(crate) compliance_type: std::option::Option<crate::model::ComplianceType>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) aws_region: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Config rule.</p>
        pub fn config_rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.config_rule_name = Some(input.into());
            self
        }
        /// <p>The name of the Config rule.</p>
        pub fn set_config_rule_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.config_rule_name = input;
            self
        }
        /// <p>The rule compliance status.</p>
        /// <p>For the <code>ConfigRuleComplianceFilters</code> data type, Config supports only <code>COMPLIANT</code> and <code>NON_COMPLIANT</code>. Config does not support the <code>NOT_APPLICABLE</code> and the <code>INSUFFICIENT_DATA</code> values.</p>
        pub fn compliance_type(mut self, input: crate::model::ComplianceType) -> Self {
            self.compliance_type = Some(input);
            self
        }
        /// <p>The rule compliance status.</p>
        /// <p>For the <code>ConfigRuleComplianceFilters</code> data type, Config supports only <code>COMPLIANT</code> and <code>NON_COMPLIANT</code>. Config does not support the <code>NOT_APPLICABLE</code> and the <code>INSUFFICIENT_DATA</code> values.</p>
        pub fn set_compliance_type(
            mut self,
            input: std::option::Option<crate::model::ComplianceType>,
        ) -> Self {
            self.compliance_type = input;
            self
        }
        /// <p>The 12-digit account ID of the source account. </p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The 12-digit account ID of the source account. </p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The source region where the data is aggregated. </p>
        pub fn aws_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_region = Some(input.into());
            self
        }
        /// <p>The source region where the data is aggregated. </p>
        pub fn set_aws_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.aws_region = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigRuleComplianceFilters`](crate::model::ConfigRuleComplianceFilters).
        pub fn build(self) -> crate::model::ConfigRuleComplianceFilters {
            crate::model::ConfigRuleComplianceFilters {
                config_rule_name: self.config_rule_name,
                compliance_type: self.compliance_type,
                account_id: self.account_id,
                aws_region: self.aws_region,
            }
        }
    }
}

/// <p>List of each of the failed delete remediation exceptions with specific reasons.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FailedDeleteRemediationExceptionsBatch {
    /// <p>Returns a failure message for delete remediation exception. For example, Config creates an exception due to an internal error.</p>
    #[doc(hidden)]
    pub failure_message: std::option::Option<std::string::String>,
    /// <p>Returns remediation exception resource key object of the failed items.</p>
    #[doc(hidden)]
    pub failed_items:
        std::option::Option<std::vec::Vec<crate::model::RemediationExceptionResourceKey>>,
}
impl FailedDeleteRemediationExceptionsBatch {
    /// <p>Returns a failure message for delete remediation exception. For example, Config creates an exception due to an internal error.</p>
    pub fn failure_message(&self) -> std::option::Option<&str> {
        self.failure_message.as_deref()
    }
    /// <p>Returns remediation exception resource key object of the failed items.</p>
    pub fn failed_items(
        &self,
    ) -> std::option::Option<&[crate::model::RemediationExceptionResourceKey]> {
        self.failed_items.as_deref()
    }
}
impl FailedDeleteRemediationExceptionsBatch {
    /// Creates a new builder-style object to manufacture [`FailedDeleteRemediationExceptionsBatch`](crate::model::FailedDeleteRemediationExceptionsBatch).
    pub fn builder() -> crate::model::failed_delete_remediation_exceptions_batch::Builder {
        crate::model::failed_delete_remediation_exceptions_batch::Builder::default()
    }
}

/// See [`FailedDeleteRemediationExceptionsBatch`](crate::model::FailedDeleteRemediationExceptionsBatch).
pub mod failed_delete_remediation_exceptions_batch {

    /// A builder for [`FailedDeleteRemediationExceptionsBatch`](crate::model::FailedDeleteRemediationExceptionsBatch).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) failure_message: std::option::Option<std::string::String>,
        pub(crate) failed_items:
            std::option::Option<std::vec::Vec<crate::model::RemediationExceptionResourceKey>>,
    }
    impl Builder {
        /// <p>Returns a failure message for delete remediation exception. For example, Config creates an exception due to an internal error.</p>
        pub fn failure_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_message = Some(input.into());
            self
        }
        /// <p>Returns a failure message for delete remediation exception. For example, Config creates an exception due to an internal error.</p>
        pub fn set_failure_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_message = input;
            self
        }
        /// Appends an item to `failed_items`.
        ///
        /// To override the contents of this collection use [`set_failed_items`](Self::set_failed_items).
        ///
        /// <p>Returns remediation exception resource key object of the failed items.</p>
        pub fn failed_items(
            mut self,
            input: crate::model::RemediationExceptionResourceKey,
        ) -> Self {
            let mut v = self.failed_items.unwrap_or_default();
            v.push(input);
            self.failed_items = Some(v);
            self
        }
        /// <p>Returns remediation exception resource key object of the failed items.</p>
        pub fn set_failed_items(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::RemediationExceptionResourceKey>,
            >,
        ) -> Self {
            self.failed_items = input;
            self
        }
        /// Consumes the builder and constructs a [`FailedDeleteRemediationExceptionsBatch`](crate::model::FailedDeleteRemediationExceptionsBatch).
        pub fn build(self) -> crate::model::FailedDeleteRemediationExceptionsBatch {
            crate::model::FailedDeleteRemediationExceptionsBatch {
                failure_message: self.failure_message,
                failed_items: self.failed_items,
            }
        }
    }
}

/// <p>The detailed configuration of a specified resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BaseConfigurationItem {
    /// <p>The version number of the resource configuration.</p>
    #[doc(hidden)]
    pub version: std::option::Option<std::string::String>,
    /// <p>The 12-digit Amazon Web Services account ID associated with the resource.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The time when the configuration recording was initiated.</p>
    #[doc(hidden)]
    pub configuration_item_capture_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The configuration item status. The valid values are:</p>
    /// <ul>
    /// <li> <p>OK – The resource configuration has been updated</p> </li>
    /// <li> <p>ResourceDiscovered – The resource was newly discovered</p> </li>
    /// <li> <p>ResourceNotRecorded – The resource was discovered but its configuration was not recorded since the recorder excludes the recording of resources of this type</p> </li>
    /// <li> <p>ResourceDeleted – The resource was deleted</p> </li>
    /// <li> <p>ResourceDeletedNotRecorded – The resource was deleted but its configuration was not recorded since the recorder excludes the recording of resources of this type</p> </li>
    /// </ul> <note>
    /// <p>The CIs do not incur any cost.</p>
    /// </note>
    #[doc(hidden)]
    pub configuration_item_status: std::option::Option<crate::model::ConfigurationItemStatus>,
    /// <p>An identifier that indicates the ordering of the configuration items of a resource.</p>
    #[doc(hidden)]
    pub configuration_state_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The type of Amazon Web Services resource.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>The ID of the resource (for example., sg-xxxxxx).</p>
    #[doc(hidden)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The custom name of the resource, if available.</p>
    #[doc(hidden)]
    pub resource_name: std::option::Option<std::string::String>,
    /// <p>The region where the resource resides.</p>
    #[doc(hidden)]
    pub aws_region: std::option::Option<std::string::String>,
    /// <p>The Availability Zone associated with the resource.</p>
    #[doc(hidden)]
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The time stamp when the resource was created.</p>
    #[doc(hidden)]
    pub resource_creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The description of the resource configuration.</p>
    #[doc(hidden)]
    pub configuration: std::option::Option<std::string::String>,
    /// <p>Configuration attributes that Config returns for certain resource types to supplement the information returned for the configuration parameter.</p>
    #[doc(hidden)]
    pub supplementary_configuration:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl BaseConfigurationItem {
    /// <p>The version number of the resource configuration.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
    /// <p>The 12-digit Amazon Web Services account ID associated with the resource.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The time when the configuration recording was initiated.</p>
    pub fn configuration_item_capture_time(
        &self,
    ) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.configuration_item_capture_time.as_ref()
    }
    /// <p>The configuration item status. The valid values are:</p>
    /// <ul>
    /// <li> <p>OK – The resource configuration has been updated</p> </li>
    /// <li> <p>ResourceDiscovered – The resource was newly discovered</p> </li>
    /// <li> <p>ResourceNotRecorded – The resource was discovered but its configuration was not recorded since the recorder excludes the recording of resources of this type</p> </li>
    /// <li> <p>ResourceDeleted – The resource was deleted</p> </li>
    /// <li> <p>ResourceDeletedNotRecorded – The resource was deleted but its configuration was not recorded since the recorder excludes the recording of resources of this type</p> </li>
    /// </ul> <note>
    /// <p>The CIs do not incur any cost.</p>
    /// </note>
    pub fn configuration_item_status(
        &self,
    ) -> std::option::Option<&crate::model::ConfigurationItemStatus> {
        self.configuration_item_status.as_ref()
    }
    /// <p>An identifier that indicates the ordering of the configuration items of a resource.</p>
    pub fn configuration_state_id(&self) -> std::option::Option<&str> {
        self.configuration_state_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The type of Amazon Web Services resource.</p>
    pub fn resource_type(&self) -> std::option::Option<&crate::model::ResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>The ID of the resource (for example., sg-xxxxxx).</p>
    pub fn resource_id(&self) -> std::option::Option<&str> {
        self.resource_id.as_deref()
    }
    /// <p>The custom name of the resource, if available.</p>
    pub fn resource_name(&self) -> std::option::Option<&str> {
        self.resource_name.as_deref()
    }
    /// <p>The region where the resource resides.</p>
    pub fn aws_region(&self) -> std::option::Option<&str> {
        self.aws_region.as_deref()
    }
    /// <p>The Availability Zone associated with the resource.</p>
    pub fn availability_zone(&self) -> std::option::Option<&str> {
        self.availability_zone.as_deref()
    }
    /// <p>The time stamp when the resource was created.</p>
    pub fn resource_creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.resource_creation_time.as_ref()
    }
    /// <p>The description of the resource configuration.</p>
    pub fn configuration(&self) -> std::option::Option<&str> {
        self.configuration.as_deref()
    }
    /// <p>Configuration attributes that Config returns for certain resource types to supplement the information returned for the configuration parameter.</p>
    pub fn supplementary_configuration(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.supplementary_configuration.as_ref()
    }
}
impl BaseConfigurationItem {
    /// Creates a new builder-style object to manufacture [`BaseConfigurationItem`](crate::model::BaseConfigurationItem).
    pub fn builder() -> crate::model::base_configuration_item::Builder {
        crate::model::base_configuration_item::Builder::default()
    }
}

/// See [`BaseConfigurationItem`](crate::model::BaseConfigurationItem).
pub mod base_configuration_item {

    /// A builder for [`BaseConfigurationItem`](crate::model::BaseConfigurationItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) version: std::option::Option<std::string::String>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) configuration_item_capture_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) configuration_item_status:
            std::option::Option<crate::model::ConfigurationItemStatus>,
        pub(crate) configuration_state_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_name: std::option::Option<std::string::String>,
        pub(crate) aws_region: std::option::Option<std::string::String>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) resource_creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) configuration: std::option::Option<std::string::String>,
        pub(crate) supplementary_configuration: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The version number of the resource configuration.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The version number of the resource configuration.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// <p>The 12-digit Amazon Web Services account ID associated with the resource.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The 12-digit Amazon Web Services account ID associated with the resource.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The time when the configuration recording was initiated.</p>
        pub fn configuration_item_capture_time(
            mut self,
            input: aws_smithy_types::DateTime,
        ) -> Self {
            self.configuration_item_capture_time = Some(input);
            self
        }
        /// <p>The time when the configuration recording was initiated.</p>
        pub fn set_configuration_item_capture_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.configuration_item_capture_time = input;
            self
        }
        /// <p>The configuration item status. The valid values are:</p>
        /// <ul>
        /// <li> <p>OK – The resource configuration has been updated</p> </li>
        /// <li> <p>ResourceDiscovered – The resource was newly discovered</p> </li>
        /// <li> <p>ResourceNotRecorded – The resource was discovered but its configuration was not recorded since the recorder excludes the recording of resources of this type</p> </li>
        /// <li> <p>ResourceDeleted – The resource was deleted</p> </li>
        /// <li> <p>ResourceDeletedNotRecorded – The resource was deleted but its configuration was not recorded since the recorder excludes the recording of resources of this type</p> </li>
        /// </ul> <note>
        /// <p>The CIs do not incur any cost.</p>
        /// </note>
        pub fn configuration_item_status(
            mut self,
            input: crate::model::ConfigurationItemStatus,
        ) -> Self {
            self.configuration_item_status = Some(input);
            self
        }
        /// <p>The configuration item status. The valid values are:</p>
        /// <ul>
        /// <li> <p>OK – The resource configuration has been updated</p> </li>
        /// <li> <p>ResourceDiscovered – The resource was newly discovered</p> </li>
        /// <li> <p>ResourceNotRecorded – The resource was discovered but its configuration was not recorded since the recorder excludes the recording of resources of this type</p> </li>
        /// <li> <p>ResourceDeleted – The resource was deleted</p> </li>
        /// <li> <p>ResourceDeletedNotRecorded – The resource was deleted but its configuration was not recorded since the recorder excludes the recording of resources of this type</p> </li>
        /// </ul> <note>
        /// <p>The CIs do not incur any cost.</p>
        /// </note>
        pub fn set_configuration_item_status(
            mut self,
            input: std::option::Option<crate::model::ConfigurationItemStatus>,
        ) -> Self {
            self.configuration_item_status = input;
            self
        }
        /// <p>An identifier that indicates the ordering of the configuration items of a resource.</p>
        pub fn configuration_state_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.configuration_state_id = Some(input.into());
            self
        }
        /// <p>An identifier that indicates the ordering of the configuration items of a resource.</p>
        pub fn set_configuration_state_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.configuration_state_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The type of Amazon Web Services resource.</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>The type of Amazon Web Services resource.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The ID of the resource (for example., sg-xxxxxx).</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The ID of the resource (for example., sg-xxxxxx).</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The custom name of the resource, if available.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_name = Some(input.into());
            self
        }
        /// <p>The custom name of the resource, if available.</p>
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_name = input;
            self
        }
        /// <p>The region where the resource resides.</p>
        pub fn aws_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_region = Some(input.into());
            self
        }
        /// <p>The region where the resource resides.</p>
        pub fn set_aws_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.aws_region = input;
            self
        }
        /// <p>The Availability Zone associated with the resource.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        /// <p>The Availability Zone associated with the resource.</p>
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The time stamp when the resource was created.</p>
        pub fn resource_creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.resource_creation_time = Some(input);
            self
        }
        /// <p>The time stamp when the resource was created.</p>
        pub fn set_resource_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.resource_creation_time = input;
            self
        }
        /// <p>The description of the resource configuration.</p>
        pub fn configuration(mut self, input: impl Into<std::string::String>) -> Self {
            self.configuration = Some(input.into());
            self
        }
        /// <p>The description of the resource configuration.</p>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// Adds a key-value pair to `supplementary_configuration`.
        ///
        /// To override the contents of this collection use [`set_supplementary_configuration`](Self::set_supplementary_configuration).
        ///
        /// <p>Configuration attributes that Config returns for certain resource types to supplement the information returned for the configuration parameter.</p>
        pub fn supplementary_configuration(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.supplementary_configuration.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.supplementary_configuration = Some(hash_map);
            self
        }
        /// <p>Configuration attributes that Config returns for certain resource types to supplement the information returned for the configuration parameter.</p>
        pub fn set_supplementary_configuration(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.supplementary_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`BaseConfigurationItem`](crate::model::BaseConfigurationItem).
        pub fn build(self) -> crate::model::BaseConfigurationItem {
            crate::model::BaseConfigurationItem {
                version: self.version,
                account_id: self.account_id,
                configuration_item_capture_time: self.configuration_item_capture_time,
                configuration_item_status: self.configuration_item_status,
                configuration_state_id: self.configuration_state_id,
                arn: self.arn,
                resource_type: self.resource_type,
                resource_id: self.resource_id,
                resource_name: self.resource_name,
                aws_region: self.aws_region,
                availability_zone: self.availability_zone,
                resource_creation_time: self.resource_creation_time,
                configuration: self.configuration,
                supplementary_configuration: self.supplementary_configuration,
            }
        }
    }
}
