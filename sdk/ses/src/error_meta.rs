// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum Error {
    /// <p>Indicates that email sending is disabled for your entire Amazon SES account.</p> 
    /// <p>You can enable or disable email sending for your Amazon SES account using <code>UpdateAccountSendingEnabled</code>.</p>
    AccountSendingPausedException(crate::error::AccountSendingPausedException),
    /// <p>Indicates that a resource could not be created because of a naming conflict.</p>
    AlreadyExistsException(crate::error::AlreadyExistsException),
    /// <p>Indicates that the delete operation could not be completed.</p>
    CannotDeleteException(crate::error::CannotDeleteException),
    /// <p>Indicates that the configuration set could not be created because of a naming conflict.</p>
    ConfigurationSetAlreadyExistsException(crate::error::ConfigurationSetAlreadyExistsException),
    /// <p>Indicates that the configuration set does not exist.</p>
    ConfigurationSetDoesNotExistException(crate::error::ConfigurationSetDoesNotExistException),
    /// <p>Indicates that email sending is disabled for the configuration set.</p> 
    /// <p>You can enable or disable email sending for a configuration set using <code>UpdateConfigurationSetSendingEnabled</code>.</p>
    ConfigurationSetSendingPausedException(crate::error::ConfigurationSetSendingPausedException),
    /// <p>Indicates that custom verification email template provided content is invalid.</p>
    CustomVerificationEmailInvalidContentException(crate::error::CustomVerificationEmailInvalidContentException),
    /// <p>Indicates that a custom verification email template with the name you specified already exists.</p>
    CustomVerificationEmailTemplateAlreadyExistsException(crate::error::CustomVerificationEmailTemplateAlreadyExistsException),
    /// <p>Indicates that a custom verification email template with the name you specified does not exist.</p>
    CustomVerificationEmailTemplateDoesNotExistException(crate::error::CustomVerificationEmailTemplateDoesNotExistException),
    /// <p>Indicates that the event destination could not be created because of a naming conflict.</p>
    EventDestinationAlreadyExistsException(crate::error::EventDestinationAlreadyExistsException),
    /// <p>Indicates that the event destination does not exist.</p>
    EventDestinationDoesNotExistException(crate::error::EventDestinationDoesNotExistException),
    /// <p>Indicates that the sender address specified for a custom verification email is not verified, and is therefore not eligible to send the custom verification email. </p>
    FromEmailAddressNotVerifiedException(crate::error::FromEmailAddressNotVerifiedException),
    /// <p>Indicates that the Amazon CloudWatch destination is invalid. See the error message for details.</p>
    InvalidCloudWatchDestinationException(crate::error::InvalidCloudWatchDestinationException),
    /// <p>Indicates that the configuration set is invalid. See the error message for details.</p>
    InvalidConfigurationSetException(crate::error::InvalidConfigurationSetException),
    /// <p>Indicates that provided delivery option is invalid.</p>
    InvalidDeliveryOptionsException(crate::error::InvalidDeliveryOptionsException),
    /// <p>Indicates that the Amazon Kinesis Firehose destination is invalid. See the error message for details.</p>
    InvalidFirehoseDestinationException(crate::error::InvalidFirehoseDestinationException),
    /// <p>Indicates that the provided AWS Lambda function is invalid, or that Amazon SES could not execute the provided function, possibly due to permissions issues. For information about giving permissions, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-permissions.html">Amazon SES Developer Guide</a>.</p>
    InvalidLambdaFunctionException(crate::error::InvalidLambdaFunctionException),
    /// <p>Indicates that the provided policy is invalid. Check the error stack for more information about what caused the error.</p>
    InvalidPolicyException(crate::error::InvalidPolicyException),
    /// <p>Indicates that one or more of the replacement values you provided is invalid. This error may occur when the TemplateData object contains invalid JSON.</p>
    InvalidRenderingParameterException(crate::error::InvalidRenderingParameterException),
    /// <p>Indicates that the provided Amazon S3 bucket or AWS KMS encryption key is invalid, or that Amazon SES could not publish to the bucket, possibly due to permissions issues. For information about giving permissions, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-permissions.html">Amazon SES Developer Guide</a>.</p>
    InvalidS3ConfigurationException(crate::error::InvalidS3ConfigurationException),
    /// <p>Indicates that the Amazon Simple Notification Service (Amazon SNS) destination is invalid. See the error message for details.</p>
    InvalidSnsDestinationException(crate::error::InvalidSnsDestinationException),
    /// <p>Indicates that the provided Amazon SNS topic is invalid, or that Amazon SES could not publish to the topic, possibly due to permissions issues. For information about giving permissions, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-permissions.html">Amazon SES Developer Guide</a>.</p>
    InvalidSnsTopicException(crate::error::InvalidSnsTopicException),
    /// <p>Indicates that the template that you specified could not be rendered. This issue may occur when a template refers to a partial that does not exist.</p>
    InvalidTemplateException(crate::error::InvalidTemplateException),
    /// <p>Indicates that the custom domain to be used for open and click tracking redirects is invalid. This error appears most often in the following situations:</p> 
    /// <ul> 
    /// <li> <p>When the tracking domain you specified is not verified in Amazon SES.</p> </li> 
    /// <li> <p>When the tracking domain you specified is not a valid domain or subdomain.</p> </li> 
    /// </ul>
    InvalidTrackingOptionsException(crate::error::InvalidTrackingOptionsException),
    /// <p>Indicates that a resource could not be created because of service limits. For a list of Amazon SES limits, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/limits.html">Amazon SES Developer Guide</a>.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p> Indicates that the message could not be sent because Amazon SES could not read the MX record required to use the specified MAIL FROM domain. For information about editing the custom MAIL FROM domain settings for an identity, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/mail-from-edit.html">Amazon SES Developer Guide</a>.</p>
    MailFromDomainNotVerifiedException(crate::error::MailFromDomainNotVerifiedException),
    /// <p>Indicates that the action failed, and the message could not be sent. Check the error stack for more information about what caused the error.</p>
    MessageRejected(crate::error::MessageRejected),
    /// <p>Indicates that one or more of the replacement values for the specified template was not specified. Ensure that the TemplateData object contains references to all of the replacement tags in the specified template.</p>
    MissingRenderingAttributeException(crate::error::MissingRenderingAttributeException),
    /// <p>Indicates that the account has not been granted production access.</p>
    ProductionAccessNotGrantedException(crate::error::ProductionAccessNotGrantedException),
    /// <p>Indicates that the provided receipt rule does not exist.</p>
    RuleDoesNotExistException(crate::error::RuleDoesNotExistException),
    /// <p>Indicates that the provided receipt rule set does not exist.</p>
    RuleSetDoesNotExistException(crate::error::RuleSetDoesNotExistException),
    /// <p>Indicates that the Template object you specified does not exist in your Amazon SES account.</p>
    TemplateDoesNotExistException(crate::error::TemplateDoesNotExistException),
    /// <p>Indicates that the configuration set you specified already contains a TrackingOptions object.</p>
    TrackingOptionsAlreadyExistsException(crate::error::TrackingOptionsAlreadyExistsException),
    /// <p>Indicates that the TrackingOptions object you specified does not exist.</p>
    TrackingOptionsDoesNotExistException(crate::error::TrackingOptionsDoesNotExistException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled)
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::AccountSendingPausedException(inner) => inner.fmt(f),
            Error::AlreadyExistsException(inner) => inner.fmt(f),
            Error::CannotDeleteException(inner) => inner.fmt(f),
            Error::ConfigurationSetAlreadyExistsException(inner) => inner.fmt(f),
            Error::ConfigurationSetDoesNotExistException(inner) => inner.fmt(f),
            Error::ConfigurationSetSendingPausedException(inner) => inner.fmt(f),
            Error::CustomVerificationEmailInvalidContentException(inner) => inner.fmt(f),
            Error::CustomVerificationEmailTemplateAlreadyExistsException(inner) => inner.fmt(f),
            Error::CustomVerificationEmailTemplateDoesNotExistException(inner) => inner.fmt(f),
            Error::EventDestinationAlreadyExistsException(inner) => inner.fmt(f),
            Error::EventDestinationDoesNotExistException(inner) => inner.fmt(f),
            Error::FromEmailAddressNotVerifiedException(inner) => inner.fmt(f),
            Error::InvalidCloudWatchDestinationException(inner) => inner.fmt(f),
            Error::InvalidConfigurationSetException(inner) => inner.fmt(f),
            Error::InvalidDeliveryOptionsException(inner) => inner.fmt(f),
            Error::InvalidFirehoseDestinationException(inner) => inner.fmt(f),
            Error::InvalidLambdaFunctionException(inner) => inner.fmt(f),
            Error::InvalidPolicyException(inner) => inner.fmt(f),
            Error::InvalidRenderingParameterException(inner) => inner.fmt(f),
            Error::InvalidS3ConfigurationException(inner) => inner.fmt(f),
            Error::InvalidSnsDestinationException(inner) => inner.fmt(f),
            Error::InvalidSnsTopicException(inner) => inner.fmt(f),
            Error::InvalidTemplateException(inner) => inner.fmt(f),
            Error::InvalidTrackingOptionsException(inner) => inner.fmt(f),
            Error::LimitExceededException(inner) => inner.fmt(f),
            Error::MailFromDomainNotVerifiedException(inner) => inner.fmt(f),
            Error::MessageRejected(inner) => inner.fmt(f),
            Error::MissingRenderingAttributeException(inner) => inner.fmt(f),
            Error::ProductionAccessNotGrantedException(inner) => inner.fmt(f),
            Error::RuleDoesNotExistException(inner) => inner.fmt(f),
            Error::RuleSetDoesNotExistException(inner) => inner.fmt(f),
            Error::TemplateDoesNotExistException(inner) => inner.fmt(f),
            Error::TrackingOptionsAlreadyExistsException(inner) => inner.fmt(f),
            Error::TrackingOptionsDoesNotExistException(inner) => inner.fmt(f),
            Error::Unhandled(inner) => inner.fmt(f)
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CloneReceiptRuleSetError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CloneReceiptRuleSetError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::CloneReceiptRuleSetError> for Error {
    fn from(err: crate::error::CloneReceiptRuleSetError) -> Self {
        match err {
            crate::error::CloneReceiptRuleSetError::AlreadyExistsException(inner) => Error::AlreadyExistsException(inner),
            crate::error::CloneReceiptRuleSetError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::CloneReceiptRuleSetError::RuleSetDoesNotExistException(inner) => Error::RuleSetDoesNotExistException(inner),
            crate::error::CloneReceiptRuleSetError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateConfigurationSetError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateConfigurationSetError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::CreateConfigurationSetError> for Error {
    fn from(err: crate::error::CreateConfigurationSetError) -> Self {
        match err {
            crate::error::CreateConfigurationSetError::ConfigurationSetAlreadyExistsException(inner) => Error::ConfigurationSetAlreadyExistsException(inner),
            crate::error::CreateConfigurationSetError::InvalidConfigurationSetException(inner) => Error::InvalidConfigurationSetException(inner),
            crate::error::CreateConfigurationSetError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::CreateConfigurationSetError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateConfigurationSetEventDestinationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateConfigurationSetEventDestinationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::CreateConfigurationSetEventDestinationError> for Error {
    fn from(err: crate::error::CreateConfigurationSetEventDestinationError) -> Self {
        match err {
            crate::error::CreateConfigurationSetEventDestinationError::ConfigurationSetDoesNotExistException(inner) => Error::ConfigurationSetDoesNotExistException(inner),
            crate::error::CreateConfigurationSetEventDestinationError::EventDestinationAlreadyExistsException(inner) => Error::EventDestinationAlreadyExistsException(inner),
            crate::error::CreateConfigurationSetEventDestinationError::InvalidCloudWatchDestinationException(inner) => Error::InvalidCloudWatchDestinationException(inner),
            crate::error::CreateConfigurationSetEventDestinationError::InvalidFirehoseDestinationException(inner) => Error::InvalidFirehoseDestinationException(inner),
            crate::error::CreateConfigurationSetEventDestinationError::InvalidSnsDestinationException(inner) => Error::InvalidSnsDestinationException(inner),
            crate::error::CreateConfigurationSetEventDestinationError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::CreateConfigurationSetEventDestinationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateConfigurationSetTrackingOptionsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateConfigurationSetTrackingOptionsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::CreateConfigurationSetTrackingOptionsError> for Error {
    fn from(err: crate::error::CreateConfigurationSetTrackingOptionsError) -> Self {
        match err {
            crate::error::CreateConfigurationSetTrackingOptionsError::ConfigurationSetDoesNotExistException(inner) => Error::ConfigurationSetDoesNotExistException(inner),
            crate::error::CreateConfigurationSetTrackingOptionsError::InvalidTrackingOptionsException(inner) => Error::InvalidTrackingOptionsException(inner),
            crate::error::CreateConfigurationSetTrackingOptionsError::TrackingOptionsAlreadyExistsException(inner) => Error::TrackingOptionsAlreadyExistsException(inner),
            crate::error::CreateConfigurationSetTrackingOptionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateCustomVerificationEmailTemplateError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateCustomVerificationEmailTemplateError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::CreateCustomVerificationEmailTemplateError> for Error {
    fn from(err: crate::error::CreateCustomVerificationEmailTemplateError) -> Self {
        match err {
            crate::error::CreateCustomVerificationEmailTemplateError::CustomVerificationEmailInvalidContentException(inner) => Error::CustomVerificationEmailInvalidContentException(inner),
            crate::error::CreateCustomVerificationEmailTemplateError::CustomVerificationEmailTemplateAlreadyExistsException(inner) => Error::CustomVerificationEmailTemplateAlreadyExistsException(inner),
            crate::error::CreateCustomVerificationEmailTemplateError::FromEmailAddressNotVerifiedException(inner) => Error::FromEmailAddressNotVerifiedException(inner),
            crate::error::CreateCustomVerificationEmailTemplateError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::CreateCustomVerificationEmailTemplateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateReceiptFilterError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateReceiptFilterError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::CreateReceiptFilterError> for Error {
    fn from(err: crate::error::CreateReceiptFilterError) -> Self {
        match err {
            crate::error::CreateReceiptFilterError::AlreadyExistsException(inner) => Error::AlreadyExistsException(inner),
            crate::error::CreateReceiptFilterError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::CreateReceiptFilterError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateReceiptRuleError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateReceiptRuleError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::CreateReceiptRuleError> for Error {
    fn from(err: crate::error::CreateReceiptRuleError) -> Self {
        match err {
            crate::error::CreateReceiptRuleError::AlreadyExistsException(inner) => Error::AlreadyExistsException(inner),
            crate::error::CreateReceiptRuleError::InvalidLambdaFunctionException(inner) => Error::InvalidLambdaFunctionException(inner),
            crate::error::CreateReceiptRuleError::InvalidS3ConfigurationException(inner) => Error::InvalidS3ConfigurationException(inner),
            crate::error::CreateReceiptRuleError::InvalidSnsTopicException(inner) => Error::InvalidSnsTopicException(inner),
            crate::error::CreateReceiptRuleError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::CreateReceiptRuleError::RuleDoesNotExistException(inner) => Error::RuleDoesNotExistException(inner),
            crate::error::CreateReceiptRuleError::RuleSetDoesNotExistException(inner) => Error::RuleSetDoesNotExistException(inner),
            crate::error::CreateReceiptRuleError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateReceiptRuleSetError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateReceiptRuleSetError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::CreateReceiptRuleSetError> for Error {
    fn from(err: crate::error::CreateReceiptRuleSetError) -> Self {
        match err {
            crate::error::CreateReceiptRuleSetError::AlreadyExistsException(inner) => Error::AlreadyExistsException(inner),
            crate::error::CreateReceiptRuleSetError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::CreateReceiptRuleSetError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateTemplateError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateTemplateError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::CreateTemplateError> for Error {
    fn from(err: crate::error::CreateTemplateError) -> Self {
        match err {
            crate::error::CreateTemplateError::AlreadyExistsException(inner) => Error::AlreadyExistsException(inner),
            crate::error::CreateTemplateError::InvalidTemplateException(inner) => Error::InvalidTemplateException(inner),
            crate::error::CreateTemplateError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::CreateTemplateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteConfigurationSetError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteConfigurationSetError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DeleteConfigurationSetError> for Error {
    fn from(err: crate::error::DeleteConfigurationSetError) -> Self {
        match err {
            crate::error::DeleteConfigurationSetError::ConfigurationSetDoesNotExistException(inner) => Error::ConfigurationSetDoesNotExistException(inner),
            crate::error::DeleteConfigurationSetError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteConfigurationSetEventDestinationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteConfigurationSetEventDestinationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DeleteConfigurationSetEventDestinationError> for Error {
    fn from(err: crate::error::DeleteConfigurationSetEventDestinationError) -> Self {
        match err {
            crate::error::DeleteConfigurationSetEventDestinationError::ConfigurationSetDoesNotExistException(inner) => Error::ConfigurationSetDoesNotExistException(inner),
            crate::error::DeleteConfigurationSetEventDestinationError::EventDestinationDoesNotExistException(inner) => Error::EventDestinationDoesNotExistException(inner),
            crate::error::DeleteConfigurationSetEventDestinationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteConfigurationSetTrackingOptionsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteConfigurationSetTrackingOptionsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DeleteConfigurationSetTrackingOptionsError> for Error {
    fn from(err: crate::error::DeleteConfigurationSetTrackingOptionsError) -> Self {
        match err {
            crate::error::DeleteConfigurationSetTrackingOptionsError::ConfigurationSetDoesNotExistException(inner) => Error::ConfigurationSetDoesNotExistException(inner),
            crate::error::DeleteConfigurationSetTrackingOptionsError::TrackingOptionsDoesNotExistException(inner) => Error::TrackingOptionsDoesNotExistException(inner),
            crate::error::DeleteConfigurationSetTrackingOptionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteCustomVerificationEmailTemplateError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteCustomVerificationEmailTemplateError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DeleteCustomVerificationEmailTemplateError> for Error {
    fn from(err: crate::error::DeleteCustomVerificationEmailTemplateError) -> Self {
        match err {
            crate::error::DeleteCustomVerificationEmailTemplateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteIdentityError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteIdentityError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DeleteIdentityError> for Error {
    fn from(err: crate::error::DeleteIdentityError) -> Self {
        match err {
            crate::error::DeleteIdentityError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteIdentityPolicyError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteIdentityPolicyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DeleteIdentityPolicyError> for Error {
    fn from(err: crate::error::DeleteIdentityPolicyError) -> Self {
        match err {
            crate::error::DeleteIdentityPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteReceiptFilterError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteReceiptFilterError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DeleteReceiptFilterError> for Error {
    fn from(err: crate::error::DeleteReceiptFilterError) -> Self {
        match err {
            crate::error::DeleteReceiptFilterError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteReceiptRuleError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteReceiptRuleError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DeleteReceiptRuleError> for Error {
    fn from(err: crate::error::DeleteReceiptRuleError) -> Self {
        match err {
            crate::error::DeleteReceiptRuleError::RuleSetDoesNotExistException(inner) => Error::RuleSetDoesNotExistException(inner),
            crate::error::DeleteReceiptRuleError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteReceiptRuleSetError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteReceiptRuleSetError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DeleteReceiptRuleSetError> for Error {
    fn from(err: crate::error::DeleteReceiptRuleSetError) -> Self {
        match err {
            crate::error::DeleteReceiptRuleSetError::CannotDeleteException(inner) => Error::CannotDeleteException(inner),
            crate::error::DeleteReceiptRuleSetError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteTemplateError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteTemplateError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DeleteTemplateError> for Error {
    fn from(err: crate::error::DeleteTemplateError) -> Self {
        match err {
            crate::error::DeleteTemplateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteVerifiedEmailAddressError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteVerifiedEmailAddressError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DeleteVerifiedEmailAddressError> for Error {
    fn from(err: crate::error::DeleteVerifiedEmailAddressError) -> Self {
        match err {
            crate::error::DeleteVerifiedEmailAddressError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeActiveReceiptRuleSetError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeActiveReceiptRuleSetError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DescribeActiveReceiptRuleSetError> for Error {
    fn from(err: crate::error::DescribeActiveReceiptRuleSetError) -> Self {
        match err {
            crate::error::DescribeActiveReceiptRuleSetError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeConfigurationSetError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeConfigurationSetError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DescribeConfigurationSetError> for Error {
    fn from(err: crate::error::DescribeConfigurationSetError) -> Self {
        match err {
            crate::error::DescribeConfigurationSetError::ConfigurationSetDoesNotExistException(inner) => Error::ConfigurationSetDoesNotExistException(inner),
            crate::error::DescribeConfigurationSetError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeReceiptRuleError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeReceiptRuleError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DescribeReceiptRuleError> for Error {
    fn from(err: crate::error::DescribeReceiptRuleError) -> Self {
        match err {
            crate::error::DescribeReceiptRuleError::RuleDoesNotExistException(inner) => Error::RuleDoesNotExistException(inner),
            crate::error::DescribeReceiptRuleError::RuleSetDoesNotExistException(inner) => Error::RuleSetDoesNotExistException(inner),
            crate::error::DescribeReceiptRuleError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeReceiptRuleSetError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeReceiptRuleSetError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DescribeReceiptRuleSetError> for Error {
    fn from(err: crate::error::DescribeReceiptRuleSetError) -> Self {
        match err {
            crate::error::DescribeReceiptRuleSetError::RuleSetDoesNotExistException(inner) => Error::RuleSetDoesNotExistException(inner),
            crate::error::DescribeReceiptRuleSetError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetAccountSendingEnabledError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetAccountSendingEnabledError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetAccountSendingEnabledError> for Error {
    fn from(err: crate::error::GetAccountSendingEnabledError) -> Self {
        match err {
            crate::error::GetAccountSendingEnabledError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetCustomVerificationEmailTemplateError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetCustomVerificationEmailTemplateError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetCustomVerificationEmailTemplateError> for Error {
    fn from(err: crate::error::GetCustomVerificationEmailTemplateError) -> Self {
        match err {
            crate::error::GetCustomVerificationEmailTemplateError::CustomVerificationEmailTemplateDoesNotExistException(inner) => Error::CustomVerificationEmailTemplateDoesNotExistException(inner),
            crate::error::GetCustomVerificationEmailTemplateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetIdentityDkimAttributesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetIdentityDkimAttributesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetIdentityDkimAttributesError> for Error {
    fn from(err: crate::error::GetIdentityDkimAttributesError) -> Self {
        match err {
            crate::error::GetIdentityDkimAttributesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetIdentityMailFromDomainAttributesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetIdentityMailFromDomainAttributesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetIdentityMailFromDomainAttributesError> for Error {
    fn from(err: crate::error::GetIdentityMailFromDomainAttributesError) -> Self {
        match err {
            crate::error::GetIdentityMailFromDomainAttributesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetIdentityNotificationAttributesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetIdentityNotificationAttributesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetIdentityNotificationAttributesError> for Error {
    fn from(err: crate::error::GetIdentityNotificationAttributesError) -> Self {
        match err {
            crate::error::GetIdentityNotificationAttributesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetIdentityPoliciesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetIdentityPoliciesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetIdentityPoliciesError> for Error {
    fn from(err: crate::error::GetIdentityPoliciesError) -> Self {
        match err {
            crate::error::GetIdentityPoliciesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetIdentityVerificationAttributesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetIdentityVerificationAttributesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetIdentityVerificationAttributesError> for Error {
    fn from(err: crate::error::GetIdentityVerificationAttributesError) -> Self {
        match err {
            crate::error::GetIdentityVerificationAttributesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetSendQuotaError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetSendQuotaError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetSendQuotaError> for Error {
    fn from(err: crate::error::GetSendQuotaError) -> Self {
        match err {
            crate::error::GetSendQuotaError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetSendStatisticsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetSendStatisticsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetSendStatisticsError> for Error {
    fn from(err: crate::error::GetSendStatisticsError) -> Self {
        match err {
            crate::error::GetSendStatisticsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetTemplateError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetTemplateError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetTemplateError> for Error {
    fn from(err: crate::error::GetTemplateError) -> Self {
        match err {
            crate::error::GetTemplateError::TemplateDoesNotExistException(inner) => Error::TemplateDoesNotExistException(inner),
            crate::error::GetTemplateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListConfigurationSetsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListConfigurationSetsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::ListConfigurationSetsError> for Error {
    fn from(err: crate::error::ListConfigurationSetsError) -> Self {
        match err {
            crate::error::ListConfigurationSetsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListCustomVerificationEmailTemplatesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListCustomVerificationEmailTemplatesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::ListCustomVerificationEmailTemplatesError> for Error {
    fn from(err: crate::error::ListCustomVerificationEmailTemplatesError) -> Self {
        match err {
            crate::error::ListCustomVerificationEmailTemplatesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListIdentitiesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListIdentitiesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::ListIdentitiesError> for Error {
    fn from(err: crate::error::ListIdentitiesError) -> Self {
        match err {
            crate::error::ListIdentitiesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListIdentityPoliciesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListIdentityPoliciesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::ListIdentityPoliciesError> for Error {
    fn from(err: crate::error::ListIdentityPoliciesError) -> Self {
        match err {
            crate::error::ListIdentityPoliciesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListReceiptFiltersError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListReceiptFiltersError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::ListReceiptFiltersError> for Error {
    fn from(err: crate::error::ListReceiptFiltersError) -> Self {
        match err {
            crate::error::ListReceiptFiltersError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListReceiptRuleSetsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListReceiptRuleSetsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::ListReceiptRuleSetsError> for Error {
    fn from(err: crate::error::ListReceiptRuleSetsError) -> Self {
        match err {
            crate::error::ListReceiptRuleSetsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListTemplatesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListTemplatesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::ListTemplatesError> for Error {
    fn from(err: crate::error::ListTemplatesError) -> Self {
        match err {
            crate::error::ListTemplatesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListVerifiedEmailAddressesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListVerifiedEmailAddressesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::ListVerifiedEmailAddressesError> for Error {
    fn from(err: crate::error::ListVerifiedEmailAddressesError) -> Self {
        match err {
            crate::error::ListVerifiedEmailAddressesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::PutConfigurationSetDeliveryOptionsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::PutConfigurationSetDeliveryOptionsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::PutConfigurationSetDeliveryOptionsError> for Error {
    fn from(err: crate::error::PutConfigurationSetDeliveryOptionsError) -> Self {
        match err {
            crate::error::PutConfigurationSetDeliveryOptionsError::ConfigurationSetDoesNotExistException(inner) => Error::ConfigurationSetDoesNotExistException(inner),
            crate::error::PutConfigurationSetDeliveryOptionsError::InvalidDeliveryOptionsException(inner) => Error::InvalidDeliveryOptionsException(inner),
            crate::error::PutConfigurationSetDeliveryOptionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::PutIdentityPolicyError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::PutIdentityPolicyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::PutIdentityPolicyError> for Error {
    fn from(err: crate::error::PutIdentityPolicyError) -> Self {
        match err {
            crate::error::PutIdentityPolicyError::InvalidPolicyException(inner) => Error::InvalidPolicyException(inner),
            crate::error::PutIdentityPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ReorderReceiptRuleSetError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ReorderReceiptRuleSetError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::ReorderReceiptRuleSetError> for Error {
    fn from(err: crate::error::ReorderReceiptRuleSetError) -> Self {
        match err {
            crate::error::ReorderReceiptRuleSetError::RuleDoesNotExistException(inner) => Error::RuleDoesNotExistException(inner),
            crate::error::ReorderReceiptRuleSetError::RuleSetDoesNotExistException(inner) => Error::RuleSetDoesNotExistException(inner),
            crate::error::ReorderReceiptRuleSetError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::SendBounceError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::SendBounceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::SendBounceError> for Error {
    fn from(err: crate::error::SendBounceError) -> Self {
        match err {
            crate::error::SendBounceError::MessageRejected(inner) => Error::MessageRejected(inner),
            crate::error::SendBounceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::SendBulkTemplatedEmailError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::SendBulkTemplatedEmailError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::SendBulkTemplatedEmailError> for Error {
    fn from(err: crate::error::SendBulkTemplatedEmailError) -> Self {
        match err {
            crate::error::SendBulkTemplatedEmailError::AccountSendingPausedException(inner) => Error::AccountSendingPausedException(inner),
            crate::error::SendBulkTemplatedEmailError::ConfigurationSetDoesNotExistException(inner) => Error::ConfigurationSetDoesNotExistException(inner),
            crate::error::SendBulkTemplatedEmailError::ConfigurationSetSendingPausedException(inner) => Error::ConfigurationSetSendingPausedException(inner),
            crate::error::SendBulkTemplatedEmailError::MailFromDomainNotVerifiedException(inner) => Error::MailFromDomainNotVerifiedException(inner),
            crate::error::SendBulkTemplatedEmailError::MessageRejected(inner) => Error::MessageRejected(inner),
            crate::error::SendBulkTemplatedEmailError::TemplateDoesNotExistException(inner) => Error::TemplateDoesNotExistException(inner),
            crate::error::SendBulkTemplatedEmailError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::SendCustomVerificationEmailError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::SendCustomVerificationEmailError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::SendCustomVerificationEmailError> for Error {
    fn from(err: crate::error::SendCustomVerificationEmailError) -> Self {
        match err {
            crate::error::SendCustomVerificationEmailError::ConfigurationSetDoesNotExistException(inner) => Error::ConfigurationSetDoesNotExistException(inner),
            crate::error::SendCustomVerificationEmailError::CustomVerificationEmailTemplateDoesNotExistException(inner) => Error::CustomVerificationEmailTemplateDoesNotExistException(inner),
            crate::error::SendCustomVerificationEmailError::FromEmailAddressNotVerifiedException(inner) => Error::FromEmailAddressNotVerifiedException(inner),
            crate::error::SendCustomVerificationEmailError::MessageRejected(inner) => Error::MessageRejected(inner),
            crate::error::SendCustomVerificationEmailError::ProductionAccessNotGrantedException(inner) => Error::ProductionAccessNotGrantedException(inner),
            crate::error::SendCustomVerificationEmailError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::SendEmailError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::SendEmailError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::SendEmailError> for Error {
    fn from(err: crate::error::SendEmailError) -> Self {
        match err {
            crate::error::SendEmailError::AccountSendingPausedException(inner) => Error::AccountSendingPausedException(inner),
            crate::error::SendEmailError::ConfigurationSetDoesNotExistException(inner) => Error::ConfigurationSetDoesNotExistException(inner),
            crate::error::SendEmailError::ConfigurationSetSendingPausedException(inner) => Error::ConfigurationSetSendingPausedException(inner),
            crate::error::SendEmailError::MailFromDomainNotVerifiedException(inner) => Error::MailFromDomainNotVerifiedException(inner),
            crate::error::SendEmailError::MessageRejected(inner) => Error::MessageRejected(inner),
            crate::error::SendEmailError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::SendRawEmailError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::SendRawEmailError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::SendRawEmailError> for Error {
    fn from(err: crate::error::SendRawEmailError) -> Self {
        match err {
            crate::error::SendRawEmailError::AccountSendingPausedException(inner) => Error::AccountSendingPausedException(inner),
            crate::error::SendRawEmailError::ConfigurationSetDoesNotExistException(inner) => Error::ConfigurationSetDoesNotExistException(inner),
            crate::error::SendRawEmailError::ConfigurationSetSendingPausedException(inner) => Error::ConfigurationSetSendingPausedException(inner),
            crate::error::SendRawEmailError::MailFromDomainNotVerifiedException(inner) => Error::MailFromDomainNotVerifiedException(inner),
            crate::error::SendRawEmailError::MessageRejected(inner) => Error::MessageRejected(inner),
            crate::error::SendRawEmailError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::SendTemplatedEmailError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::SendTemplatedEmailError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::SendTemplatedEmailError> for Error {
    fn from(err: crate::error::SendTemplatedEmailError) -> Self {
        match err {
            crate::error::SendTemplatedEmailError::AccountSendingPausedException(inner) => Error::AccountSendingPausedException(inner),
            crate::error::SendTemplatedEmailError::ConfigurationSetDoesNotExistException(inner) => Error::ConfigurationSetDoesNotExistException(inner),
            crate::error::SendTemplatedEmailError::ConfigurationSetSendingPausedException(inner) => Error::ConfigurationSetSendingPausedException(inner),
            crate::error::SendTemplatedEmailError::MailFromDomainNotVerifiedException(inner) => Error::MailFromDomainNotVerifiedException(inner),
            crate::error::SendTemplatedEmailError::MessageRejected(inner) => Error::MessageRejected(inner),
            crate::error::SendTemplatedEmailError::TemplateDoesNotExistException(inner) => Error::TemplateDoesNotExistException(inner),
            crate::error::SendTemplatedEmailError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::SetActiveReceiptRuleSetError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::SetActiveReceiptRuleSetError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::SetActiveReceiptRuleSetError> for Error {
    fn from(err: crate::error::SetActiveReceiptRuleSetError) -> Self {
        match err {
            crate::error::SetActiveReceiptRuleSetError::RuleSetDoesNotExistException(inner) => Error::RuleSetDoesNotExistException(inner),
            crate::error::SetActiveReceiptRuleSetError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::SetIdentityDkimEnabledError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::SetIdentityDkimEnabledError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::SetIdentityDkimEnabledError> for Error {
    fn from(err: crate::error::SetIdentityDkimEnabledError) -> Self {
        match err {
            crate::error::SetIdentityDkimEnabledError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::SetIdentityFeedbackForwardingEnabledError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::SetIdentityFeedbackForwardingEnabledError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::SetIdentityFeedbackForwardingEnabledError> for Error {
    fn from(err: crate::error::SetIdentityFeedbackForwardingEnabledError) -> Self {
        match err {
            crate::error::SetIdentityFeedbackForwardingEnabledError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::SetIdentityHeadersInNotificationsEnabledError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::SetIdentityHeadersInNotificationsEnabledError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::SetIdentityHeadersInNotificationsEnabledError> for Error {
    fn from(err: crate::error::SetIdentityHeadersInNotificationsEnabledError) -> Self {
        match err {
            crate::error::SetIdentityHeadersInNotificationsEnabledError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::SetIdentityMailFromDomainError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::SetIdentityMailFromDomainError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::SetIdentityMailFromDomainError> for Error {
    fn from(err: crate::error::SetIdentityMailFromDomainError) -> Self {
        match err {
            crate::error::SetIdentityMailFromDomainError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::SetIdentityNotificationTopicError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::SetIdentityNotificationTopicError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::SetIdentityNotificationTopicError> for Error {
    fn from(err: crate::error::SetIdentityNotificationTopicError) -> Self {
        match err {
            crate::error::SetIdentityNotificationTopicError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::SetReceiptRulePositionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::SetReceiptRulePositionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::SetReceiptRulePositionError> for Error {
    fn from(err: crate::error::SetReceiptRulePositionError) -> Self {
        match err {
            crate::error::SetReceiptRulePositionError::RuleDoesNotExistException(inner) => Error::RuleDoesNotExistException(inner),
            crate::error::SetReceiptRulePositionError::RuleSetDoesNotExistException(inner) => Error::RuleSetDoesNotExistException(inner),
            crate::error::SetReceiptRulePositionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::TestRenderTemplateError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::TestRenderTemplateError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::TestRenderTemplateError> for Error {
    fn from(err: crate::error::TestRenderTemplateError) -> Self {
        match err {
            crate::error::TestRenderTemplateError::InvalidRenderingParameterException(inner) => Error::InvalidRenderingParameterException(inner),
            crate::error::TestRenderTemplateError::MissingRenderingAttributeException(inner) => Error::MissingRenderingAttributeException(inner),
            crate::error::TestRenderTemplateError::TemplateDoesNotExistException(inner) => Error::TemplateDoesNotExistException(inner),
            crate::error::TestRenderTemplateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateAccountSendingEnabledError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateAccountSendingEnabledError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdateAccountSendingEnabledError> for Error {
    fn from(err: crate::error::UpdateAccountSendingEnabledError) -> Self {
        match err {
            crate::error::UpdateAccountSendingEnabledError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateConfigurationSetEventDestinationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateConfigurationSetEventDestinationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdateConfigurationSetEventDestinationError> for Error {
    fn from(err: crate::error::UpdateConfigurationSetEventDestinationError) -> Self {
        match err {
            crate::error::UpdateConfigurationSetEventDestinationError::ConfigurationSetDoesNotExistException(inner) => Error::ConfigurationSetDoesNotExistException(inner),
            crate::error::UpdateConfigurationSetEventDestinationError::EventDestinationDoesNotExistException(inner) => Error::EventDestinationDoesNotExistException(inner),
            crate::error::UpdateConfigurationSetEventDestinationError::InvalidCloudWatchDestinationException(inner) => Error::InvalidCloudWatchDestinationException(inner),
            crate::error::UpdateConfigurationSetEventDestinationError::InvalidFirehoseDestinationException(inner) => Error::InvalidFirehoseDestinationException(inner),
            crate::error::UpdateConfigurationSetEventDestinationError::InvalidSnsDestinationException(inner) => Error::InvalidSnsDestinationException(inner),
            crate::error::UpdateConfigurationSetEventDestinationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateConfigurationSetReputationMetricsEnabledError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateConfigurationSetReputationMetricsEnabledError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdateConfigurationSetReputationMetricsEnabledError> for Error {
    fn from(err: crate::error::UpdateConfigurationSetReputationMetricsEnabledError) -> Self {
        match err {
            crate::error::UpdateConfigurationSetReputationMetricsEnabledError::ConfigurationSetDoesNotExistException(inner) => Error::ConfigurationSetDoesNotExistException(inner),
            crate::error::UpdateConfigurationSetReputationMetricsEnabledError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateConfigurationSetSendingEnabledError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateConfigurationSetSendingEnabledError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdateConfigurationSetSendingEnabledError> for Error {
    fn from(err: crate::error::UpdateConfigurationSetSendingEnabledError) -> Self {
        match err {
            crate::error::UpdateConfigurationSetSendingEnabledError::ConfigurationSetDoesNotExistException(inner) => Error::ConfigurationSetDoesNotExistException(inner),
            crate::error::UpdateConfigurationSetSendingEnabledError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateConfigurationSetTrackingOptionsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateConfigurationSetTrackingOptionsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdateConfigurationSetTrackingOptionsError> for Error {
    fn from(err: crate::error::UpdateConfigurationSetTrackingOptionsError) -> Self {
        match err {
            crate::error::UpdateConfigurationSetTrackingOptionsError::ConfigurationSetDoesNotExistException(inner) => Error::ConfigurationSetDoesNotExistException(inner),
            crate::error::UpdateConfigurationSetTrackingOptionsError::InvalidTrackingOptionsException(inner) => Error::InvalidTrackingOptionsException(inner),
            crate::error::UpdateConfigurationSetTrackingOptionsError::TrackingOptionsDoesNotExistException(inner) => Error::TrackingOptionsDoesNotExistException(inner),
            crate::error::UpdateConfigurationSetTrackingOptionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateCustomVerificationEmailTemplateError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateCustomVerificationEmailTemplateError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdateCustomVerificationEmailTemplateError> for Error {
    fn from(err: crate::error::UpdateCustomVerificationEmailTemplateError) -> Self {
        match err {
            crate::error::UpdateCustomVerificationEmailTemplateError::CustomVerificationEmailInvalidContentException(inner) => Error::CustomVerificationEmailInvalidContentException(inner),
            crate::error::UpdateCustomVerificationEmailTemplateError::CustomVerificationEmailTemplateDoesNotExistException(inner) => Error::CustomVerificationEmailTemplateDoesNotExistException(inner),
            crate::error::UpdateCustomVerificationEmailTemplateError::FromEmailAddressNotVerifiedException(inner) => Error::FromEmailAddressNotVerifiedException(inner),
            crate::error::UpdateCustomVerificationEmailTemplateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateReceiptRuleError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateReceiptRuleError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdateReceiptRuleError> for Error {
    fn from(err: crate::error::UpdateReceiptRuleError) -> Self {
        match err {
            crate::error::UpdateReceiptRuleError::InvalidLambdaFunctionException(inner) => Error::InvalidLambdaFunctionException(inner),
            crate::error::UpdateReceiptRuleError::InvalidS3ConfigurationException(inner) => Error::InvalidS3ConfigurationException(inner),
            crate::error::UpdateReceiptRuleError::InvalidSnsTopicException(inner) => Error::InvalidSnsTopicException(inner),
            crate::error::UpdateReceiptRuleError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::UpdateReceiptRuleError::RuleDoesNotExistException(inner) => Error::RuleDoesNotExistException(inner),
            crate::error::UpdateReceiptRuleError::RuleSetDoesNotExistException(inner) => Error::RuleSetDoesNotExistException(inner),
            crate::error::UpdateReceiptRuleError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateTemplateError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateTemplateError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdateTemplateError> for Error {
    fn from(err: crate::error::UpdateTemplateError) -> Self {
        match err {
            crate::error::UpdateTemplateError::InvalidTemplateException(inner) => Error::InvalidTemplateException(inner),
            crate::error::UpdateTemplateError::TemplateDoesNotExistException(inner) => Error::TemplateDoesNotExistException(inner),
            crate::error::UpdateTemplateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::VerifyDomainDkimError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::VerifyDomainDkimError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::VerifyDomainDkimError> for Error {
    fn from(err: crate::error::VerifyDomainDkimError) -> Self {
        match err {
            crate::error::VerifyDomainDkimError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::VerifyDomainIdentityError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::VerifyDomainIdentityError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::VerifyDomainIdentityError> for Error {
    fn from(err: crate::error::VerifyDomainIdentityError) -> Self {
        match err {
            crate::error::VerifyDomainIdentityError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::VerifyEmailAddressError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::VerifyEmailAddressError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::VerifyEmailAddressError> for Error {
    fn from(err: crate::error::VerifyEmailAddressError) -> Self {
        match err {
            crate::error::VerifyEmailAddressError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::VerifyEmailIdentityError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::VerifyEmailIdentityError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::VerifyEmailIdentityError> for Error {
    fn from(err: crate::error::VerifyEmailIdentityError) -> Self {
        match err {
            crate::error::VerifyEmailIdentityError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl std::error::Error for Error {}
impl aws_http::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::AccountSendingPausedException(e) => e.request_id(),
            Self::AlreadyExistsException(e) => e.request_id(),
            Self::CannotDeleteException(e) => e.request_id(),
            Self::ConfigurationSetAlreadyExistsException(e) => e.request_id(),
            Self::ConfigurationSetDoesNotExistException(e) => e.request_id(),
            Self::ConfigurationSetSendingPausedException(e) => e.request_id(),
            Self::CustomVerificationEmailInvalidContentException(e) => e.request_id(),
            Self::CustomVerificationEmailTemplateAlreadyExistsException(e) => e.request_id(),
            Self::CustomVerificationEmailTemplateDoesNotExistException(e) => e.request_id(),
            Self::EventDestinationAlreadyExistsException(e) => e.request_id(),
            Self::EventDestinationDoesNotExistException(e) => e.request_id(),
            Self::FromEmailAddressNotVerifiedException(e) => e.request_id(),
            Self::InvalidCloudWatchDestinationException(e) => e.request_id(),
            Self::InvalidConfigurationSetException(e) => e.request_id(),
            Self::InvalidDeliveryOptionsException(e) => e.request_id(),
            Self::InvalidFirehoseDestinationException(e) => e.request_id(),
            Self::InvalidLambdaFunctionException(e) => e.request_id(),
            Self::InvalidPolicyException(e) => e.request_id(),
            Self::InvalidRenderingParameterException(e) => e.request_id(),
            Self::InvalidS3ConfigurationException(e) => e.request_id(),
            Self::InvalidSnsDestinationException(e) => e.request_id(),
            Self::InvalidSnsTopicException(e) => e.request_id(),
            Self::InvalidTemplateException(e) => e.request_id(),
            Self::InvalidTrackingOptionsException(e) => e.request_id(),
            Self::LimitExceededException(e) => e.request_id(),
            Self::MailFromDomainNotVerifiedException(e) => e.request_id(),
            Self::MessageRejected(e) => e.request_id(),
            Self::MissingRenderingAttributeException(e) => e.request_id(),
            Self::ProductionAccessNotGrantedException(e) => e.request_id(),
            Self::RuleDoesNotExistException(e) => e.request_id(),
            Self::RuleSetDoesNotExistException(e) => e.request_id(),
            Self::TemplateDoesNotExistException(e) => e.request_id(),
            Self::TrackingOptionsAlreadyExistsException(e) => e.request_id(),
            Self::TrackingOptionsDoesNotExistException(e) => e.request_id(),
            Self::Unhandled(e) => e.request_id(),
        }
    }
}

