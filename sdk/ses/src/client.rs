// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn clone_receipt_rule_set(&self) -> fluent_builders::CloneReceiptRuleSet<C> {
        fluent_builders::CloneReceiptRuleSet::new(self.handle.clone())
    }
    pub fn create_configuration_set(&self) -> fluent_builders::CreateConfigurationSet<C> {
        fluent_builders::CreateConfigurationSet::new(self.handle.clone())
    }
    pub fn create_configuration_set_event_destination(
        &self,
    ) -> fluent_builders::CreateConfigurationSetEventDestination<C> {
        fluent_builders::CreateConfigurationSetEventDestination::new(self.handle.clone())
    }
    pub fn create_configuration_set_tracking_options(
        &self,
    ) -> fluent_builders::CreateConfigurationSetTrackingOptions<C> {
        fluent_builders::CreateConfigurationSetTrackingOptions::new(self.handle.clone())
    }
    pub fn create_custom_verification_email_template(
        &self,
    ) -> fluent_builders::CreateCustomVerificationEmailTemplate<C> {
        fluent_builders::CreateCustomVerificationEmailTemplate::new(self.handle.clone())
    }
    pub fn create_receipt_filter(&self) -> fluent_builders::CreateReceiptFilter<C> {
        fluent_builders::CreateReceiptFilter::new(self.handle.clone())
    }
    pub fn create_receipt_rule(&self) -> fluent_builders::CreateReceiptRule<C> {
        fluent_builders::CreateReceiptRule::new(self.handle.clone())
    }
    pub fn create_receipt_rule_set(&self) -> fluent_builders::CreateReceiptRuleSet<C> {
        fluent_builders::CreateReceiptRuleSet::new(self.handle.clone())
    }
    pub fn create_template(&self) -> fluent_builders::CreateTemplate<C> {
        fluent_builders::CreateTemplate::new(self.handle.clone())
    }
    pub fn delete_configuration_set(&self) -> fluent_builders::DeleteConfigurationSet<C> {
        fluent_builders::DeleteConfigurationSet::new(self.handle.clone())
    }
    pub fn delete_configuration_set_event_destination(
        &self,
    ) -> fluent_builders::DeleteConfigurationSetEventDestination<C> {
        fluent_builders::DeleteConfigurationSetEventDestination::new(self.handle.clone())
    }
    pub fn delete_configuration_set_tracking_options(
        &self,
    ) -> fluent_builders::DeleteConfigurationSetTrackingOptions<C> {
        fluent_builders::DeleteConfigurationSetTrackingOptions::new(self.handle.clone())
    }
    pub fn delete_custom_verification_email_template(
        &self,
    ) -> fluent_builders::DeleteCustomVerificationEmailTemplate<C> {
        fluent_builders::DeleteCustomVerificationEmailTemplate::new(self.handle.clone())
    }
    pub fn delete_identity(&self) -> fluent_builders::DeleteIdentity<C> {
        fluent_builders::DeleteIdentity::new(self.handle.clone())
    }
    pub fn delete_identity_policy(&self) -> fluent_builders::DeleteIdentityPolicy<C> {
        fluent_builders::DeleteIdentityPolicy::new(self.handle.clone())
    }
    pub fn delete_receipt_filter(&self) -> fluent_builders::DeleteReceiptFilter<C> {
        fluent_builders::DeleteReceiptFilter::new(self.handle.clone())
    }
    pub fn delete_receipt_rule(&self) -> fluent_builders::DeleteReceiptRule<C> {
        fluent_builders::DeleteReceiptRule::new(self.handle.clone())
    }
    pub fn delete_receipt_rule_set(&self) -> fluent_builders::DeleteReceiptRuleSet<C> {
        fluent_builders::DeleteReceiptRuleSet::new(self.handle.clone())
    }
    pub fn delete_template(&self) -> fluent_builders::DeleteTemplate<C> {
        fluent_builders::DeleteTemplate::new(self.handle.clone())
    }
    pub fn delete_verified_email_address(&self) -> fluent_builders::DeleteVerifiedEmailAddress<C> {
        fluent_builders::DeleteVerifiedEmailAddress::new(self.handle.clone())
    }
    pub fn describe_active_receipt_rule_set(
        &self,
    ) -> fluent_builders::DescribeActiveReceiptRuleSet<C> {
        fluent_builders::DescribeActiveReceiptRuleSet::new(self.handle.clone())
    }
    pub fn describe_configuration_set(&self) -> fluent_builders::DescribeConfigurationSet<C> {
        fluent_builders::DescribeConfigurationSet::new(self.handle.clone())
    }
    pub fn describe_receipt_rule(&self) -> fluent_builders::DescribeReceiptRule<C> {
        fluent_builders::DescribeReceiptRule::new(self.handle.clone())
    }
    pub fn describe_receipt_rule_set(&self) -> fluent_builders::DescribeReceiptRuleSet<C> {
        fluent_builders::DescribeReceiptRuleSet::new(self.handle.clone())
    }
    pub fn get_account_sending_enabled(&self) -> fluent_builders::GetAccountSendingEnabled<C> {
        fluent_builders::GetAccountSendingEnabled::new(self.handle.clone())
    }
    pub fn get_custom_verification_email_template(
        &self,
    ) -> fluent_builders::GetCustomVerificationEmailTemplate<C> {
        fluent_builders::GetCustomVerificationEmailTemplate::new(self.handle.clone())
    }
    pub fn get_identity_dkim_attributes(&self) -> fluent_builders::GetIdentityDkimAttributes<C> {
        fluent_builders::GetIdentityDkimAttributes::new(self.handle.clone())
    }
    pub fn get_identity_mail_from_domain_attributes(
        &self,
    ) -> fluent_builders::GetIdentityMailFromDomainAttributes<C> {
        fluent_builders::GetIdentityMailFromDomainAttributes::new(self.handle.clone())
    }
    pub fn get_identity_notification_attributes(
        &self,
    ) -> fluent_builders::GetIdentityNotificationAttributes<C> {
        fluent_builders::GetIdentityNotificationAttributes::new(self.handle.clone())
    }
    pub fn get_identity_policies(&self) -> fluent_builders::GetIdentityPolicies<C> {
        fluent_builders::GetIdentityPolicies::new(self.handle.clone())
    }
    pub fn get_identity_verification_attributes(
        &self,
    ) -> fluent_builders::GetIdentityVerificationAttributes<C> {
        fluent_builders::GetIdentityVerificationAttributes::new(self.handle.clone())
    }
    pub fn get_send_quota(&self) -> fluent_builders::GetSendQuota<C> {
        fluent_builders::GetSendQuota::new(self.handle.clone())
    }
    pub fn get_send_statistics(&self) -> fluent_builders::GetSendStatistics<C> {
        fluent_builders::GetSendStatistics::new(self.handle.clone())
    }
    pub fn get_template(&self) -> fluent_builders::GetTemplate<C> {
        fluent_builders::GetTemplate::new(self.handle.clone())
    }
    pub fn list_configuration_sets(&self) -> fluent_builders::ListConfigurationSets<C> {
        fluent_builders::ListConfigurationSets::new(self.handle.clone())
    }
    pub fn list_custom_verification_email_templates(
        &self,
    ) -> fluent_builders::ListCustomVerificationEmailTemplates<C> {
        fluent_builders::ListCustomVerificationEmailTemplates::new(self.handle.clone())
    }
    pub fn list_identities(&self) -> fluent_builders::ListIdentities<C> {
        fluent_builders::ListIdentities::new(self.handle.clone())
    }
    pub fn list_identity_policies(&self) -> fluent_builders::ListIdentityPolicies<C> {
        fluent_builders::ListIdentityPolicies::new(self.handle.clone())
    }
    pub fn list_receipt_filters(&self) -> fluent_builders::ListReceiptFilters<C> {
        fluent_builders::ListReceiptFilters::new(self.handle.clone())
    }
    pub fn list_receipt_rule_sets(&self) -> fluent_builders::ListReceiptRuleSets<C> {
        fluent_builders::ListReceiptRuleSets::new(self.handle.clone())
    }
    pub fn list_templates(&self) -> fluent_builders::ListTemplates<C> {
        fluent_builders::ListTemplates::new(self.handle.clone())
    }
    pub fn list_verified_email_addresses(&self) -> fluent_builders::ListVerifiedEmailAddresses<C> {
        fluent_builders::ListVerifiedEmailAddresses::new(self.handle.clone())
    }
    pub fn put_configuration_set_delivery_options(
        &self,
    ) -> fluent_builders::PutConfigurationSetDeliveryOptions<C> {
        fluent_builders::PutConfigurationSetDeliveryOptions::new(self.handle.clone())
    }
    pub fn put_identity_policy(&self) -> fluent_builders::PutIdentityPolicy<C> {
        fluent_builders::PutIdentityPolicy::new(self.handle.clone())
    }
    pub fn reorder_receipt_rule_set(&self) -> fluent_builders::ReorderReceiptRuleSet<C> {
        fluent_builders::ReorderReceiptRuleSet::new(self.handle.clone())
    }
    pub fn send_bounce(&self) -> fluent_builders::SendBounce<C> {
        fluent_builders::SendBounce::new(self.handle.clone())
    }
    pub fn send_bulk_templated_email(&self) -> fluent_builders::SendBulkTemplatedEmail<C> {
        fluent_builders::SendBulkTemplatedEmail::new(self.handle.clone())
    }
    pub fn send_custom_verification_email(
        &self,
    ) -> fluent_builders::SendCustomVerificationEmail<C> {
        fluent_builders::SendCustomVerificationEmail::new(self.handle.clone())
    }
    pub fn send_email(&self) -> fluent_builders::SendEmail<C> {
        fluent_builders::SendEmail::new(self.handle.clone())
    }
    pub fn send_raw_email(&self) -> fluent_builders::SendRawEmail<C> {
        fluent_builders::SendRawEmail::new(self.handle.clone())
    }
    pub fn send_templated_email(&self) -> fluent_builders::SendTemplatedEmail<C> {
        fluent_builders::SendTemplatedEmail::new(self.handle.clone())
    }
    pub fn set_active_receipt_rule_set(&self) -> fluent_builders::SetActiveReceiptRuleSet<C> {
        fluent_builders::SetActiveReceiptRuleSet::new(self.handle.clone())
    }
    pub fn set_identity_dkim_enabled(&self) -> fluent_builders::SetIdentityDkimEnabled<C> {
        fluent_builders::SetIdentityDkimEnabled::new(self.handle.clone())
    }
    pub fn set_identity_feedback_forwarding_enabled(
        &self,
    ) -> fluent_builders::SetIdentityFeedbackForwardingEnabled<C> {
        fluent_builders::SetIdentityFeedbackForwardingEnabled::new(self.handle.clone())
    }
    pub fn set_identity_headers_in_notifications_enabled(
        &self,
    ) -> fluent_builders::SetIdentityHeadersInNotificationsEnabled<C> {
        fluent_builders::SetIdentityHeadersInNotificationsEnabled::new(self.handle.clone())
    }
    pub fn set_identity_mail_from_domain(&self) -> fluent_builders::SetIdentityMailFromDomain<C> {
        fluent_builders::SetIdentityMailFromDomain::new(self.handle.clone())
    }
    pub fn set_identity_notification_topic(
        &self,
    ) -> fluent_builders::SetIdentityNotificationTopic<C> {
        fluent_builders::SetIdentityNotificationTopic::new(self.handle.clone())
    }
    pub fn set_receipt_rule_position(&self) -> fluent_builders::SetReceiptRulePosition<C> {
        fluent_builders::SetReceiptRulePosition::new(self.handle.clone())
    }
    pub fn test_render_template(&self) -> fluent_builders::TestRenderTemplate<C> {
        fluent_builders::TestRenderTemplate::new(self.handle.clone())
    }
    pub fn update_account_sending_enabled(
        &self,
    ) -> fluent_builders::UpdateAccountSendingEnabled<C> {
        fluent_builders::UpdateAccountSendingEnabled::new(self.handle.clone())
    }
    pub fn update_configuration_set_event_destination(
        &self,
    ) -> fluent_builders::UpdateConfigurationSetEventDestination<C> {
        fluent_builders::UpdateConfigurationSetEventDestination::new(self.handle.clone())
    }
    pub fn update_configuration_set_reputation_metrics_enabled(
        &self,
    ) -> fluent_builders::UpdateConfigurationSetReputationMetricsEnabled<C> {
        fluent_builders::UpdateConfigurationSetReputationMetricsEnabled::new(self.handle.clone())
    }
    pub fn update_configuration_set_sending_enabled(
        &self,
    ) -> fluent_builders::UpdateConfigurationSetSendingEnabled<C> {
        fluent_builders::UpdateConfigurationSetSendingEnabled::new(self.handle.clone())
    }
    pub fn update_configuration_set_tracking_options(
        &self,
    ) -> fluent_builders::UpdateConfigurationSetTrackingOptions<C> {
        fluent_builders::UpdateConfigurationSetTrackingOptions::new(self.handle.clone())
    }
    pub fn update_custom_verification_email_template(
        &self,
    ) -> fluent_builders::UpdateCustomVerificationEmailTemplate<C> {
        fluent_builders::UpdateCustomVerificationEmailTemplate::new(self.handle.clone())
    }
    pub fn update_receipt_rule(&self) -> fluent_builders::UpdateReceiptRule<C> {
        fluent_builders::UpdateReceiptRule::new(self.handle.clone())
    }
    pub fn update_template(&self) -> fluent_builders::UpdateTemplate<C> {
        fluent_builders::UpdateTemplate::new(self.handle.clone())
    }
    pub fn verify_domain_dkim(&self) -> fluent_builders::VerifyDomainDkim<C> {
        fluent_builders::VerifyDomainDkim::new(self.handle.clone())
    }
    pub fn verify_domain_identity(&self) -> fluent_builders::VerifyDomainIdentity<C> {
        fluent_builders::VerifyDomainIdentity::new(self.handle.clone())
    }
    pub fn verify_email_address(&self) -> fluent_builders::VerifyEmailAddress<C> {
        fluent_builders::VerifyEmailAddress::new(self.handle.clone())
    }
    pub fn verify_email_identity(&self) -> fluent_builders::VerifyEmailIdentity<C> {
        fluent_builders::VerifyEmailIdentity::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CloneReceiptRuleSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::clone_receipt_rule_set_input::Builder,
    }
    impl<C> CloneReceiptRuleSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CloneReceiptRuleSetOutput,
            smithy_http::result::SdkError<crate::error::CloneReceiptRuleSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the rule set to create. The name must:</p>
        /// <ul>
        /// <li>
        /// <p>This value can only contain ASCII letters (a-z, A-Z), numbers (0-9),
        /// underscores (_), or dashes (-).</p>
        /// </li>
        /// <li>
        /// <p>Start and end with a letter or number.</p>
        /// </li>
        /// <li>
        /// <p>Contain less than 64 characters.</p>
        /// </li>
        /// </ul>
        pub fn rule_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_set_name(input);
            self
        }
        pub fn set_rule_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rule_set_name(input);
            self
        }
        /// <p>The name of the rule set to clone.</p>
        pub fn original_rule_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.original_rule_set_name(input);
            self
        }
        pub fn set_original_rule_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_original_rule_set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateConfigurationSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_configuration_set_input::Builder,
    }
    impl<C> CreateConfigurationSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateConfigurationSetOutput,
            smithy_http::result::SdkError<crate::error::CreateConfigurationSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A data structure that contains the name of the configuration set.</p>
        pub fn configuration_set(mut self, input: crate::model::ConfigurationSet) -> Self {
            self.inner = self.inner.configuration_set(input);
            self
        }
        pub fn set_configuration_set(
            mut self,
            input: std::option::Option<crate::model::ConfigurationSet>,
        ) -> Self {
            self.inner = self.inner.set_configuration_set(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateConfigurationSetEventDestination<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_configuration_set_event_destination_input::Builder,
    }
    impl<C> CreateConfigurationSetEventDestination<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateConfigurationSetEventDestinationOutput,
            smithy_http::result::SdkError<
                crate::error::CreateConfigurationSetEventDestinationError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the configuration set that the event destination should be associated
        /// with.</p>
        pub fn configuration_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.configuration_set_name(input);
            self
        }
        pub fn set_configuration_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_configuration_set_name(input);
            self
        }
        /// <p>An object that describes the AWS service that email sending event information will
        /// be published to.</p>
        pub fn event_destination(mut self, input: crate::model::EventDestination) -> Self {
            self.inner = self.inner.event_destination(input);
            self
        }
        pub fn set_event_destination(
            mut self,
            input: std::option::Option<crate::model::EventDestination>,
        ) -> Self {
            self.inner = self.inner.set_event_destination(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateConfigurationSetTrackingOptions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_configuration_set_tracking_options_input::Builder,
    }
    impl<C> CreateConfigurationSetTrackingOptions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateConfigurationSetTrackingOptionsOutput,
            smithy_http::result::SdkError<crate::error::CreateConfigurationSetTrackingOptionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the configuration set that the tracking options should be associated
        /// with.</p>
        pub fn configuration_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.configuration_set_name(input);
            self
        }
        pub fn set_configuration_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_configuration_set_name(input);
            self
        }
        /// <p>A domain that is used to redirect email recipients to an Amazon SES-operated domain. This
        /// domain captures open and click events generated by Amazon SES emails.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/configure-custom-open-click-domains.html">Configuring
        /// Custom Domains to Handle Open and Click Tracking</a> in the <i>Amazon SES
        /// Developer Guide</i>.</p>
        pub fn tracking_options(mut self, input: crate::model::TrackingOptions) -> Self {
            self.inner = self.inner.tracking_options(input);
            self
        }
        pub fn set_tracking_options(
            mut self,
            input: std::option::Option<crate::model::TrackingOptions>,
        ) -> Self {
            self.inner = self.inner.set_tracking_options(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateCustomVerificationEmailTemplate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_custom_verification_email_template_input::Builder,
    }
    impl<C> CreateCustomVerificationEmailTemplate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateCustomVerificationEmailTemplateOutput,
            smithy_http::result::SdkError<crate::error::CreateCustomVerificationEmailTemplateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the custom verification email template.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_name(input);
            self
        }
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_name(input);
            self
        }
        /// <p>The email address that the custom verification email is sent from.</p>
        pub fn from_email_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.from_email_address(input);
            self
        }
        pub fn set_from_email_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_from_email_address(input);
            self
        }
        /// <p>The subject line of the custom verification email.</p>
        pub fn template_subject(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_subject(input);
            self
        }
        pub fn set_template_subject(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_subject(input);
            self
        }
        /// <p>The content of the custom verification email. The total size of the email must be less
        /// than 10 MB. The message body may contain HTML, with some limitations. For more
        /// information, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/custom-verification-emails.html#custom-verification-emails-faq">Custom Verification Email Frequently Asked Questions</a> in the <i>Amazon SES
        /// Developer Guide</i>.</p>
        pub fn template_content(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_content(input);
            self
        }
        pub fn set_template_content(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_content(input);
            self
        }
        /// <p>The URL that the recipient of the verification email is sent to if his or her address
        /// is successfully verified.</p>
        pub fn success_redirection_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.success_redirection_url(input);
            self
        }
        pub fn set_success_redirection_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_success_redirection_url(input);
            self
        }
        /// <p>The URL that the recipient of the verification email is sent to if his or her address
        /// is not successfully verified.</p>
        pub fn failure_redirection_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.failure_redirection_url(input);
            self
        }
        pub fn set_failure_redirection_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_failure_redirection_url(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateReceiptFilter<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_receipt_filter_input::Builder,
    }
    impl<C> CreateReceiptFilter<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateReceiptFilterOutput,
            smithy_http::result::SdkError<crate::error::CreateReceiptFilterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A data structure that describes the IP address filter to create, which consists of a
        /// name, an IP address range, and whether to allow or block mail from it.</p>
        pub fn filter(mut self, input: crate::model::ReceiptFilter) -> Self {
            self.inner = self.inner.filter(input);
            self
        }
        pub fn set_filter(
            mut self,
            input: std::option::Option<crate::model::ReceiptFilter>,
        ) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateReceiptRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_receipt_rule_input::Builder,
    }
    impl<C> CreateReceiptRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateReceiptRuleOutput,
            smithy_http::result::SdkError<crate::error::CreateReceiptRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the rule set that the receipt rule will be added to.</p>
        pub fn rule_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_set_name(input);
            self
        }
        pub fn set_rule_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rule_set_name(input);
            self
        }
        /// <p>The name of an existing rule after which the new rule will be placed. If this
        /// parameter is null, the new rule will be inserted at the beginning of the rule
        /// list.</p>
        pub fn after(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.after(input);
            self
        }
        pub fn set_after(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_after(input);
            self
        }
        /// <p>A data structure that contains the specified rule's name, actions, recipients,
        /// domains, enabled status, scan status, and TLS policy.</p>
        pub fn rule(mut self, input: crate::model::ReceiptRule) -> Self {
            self.inner = self.inner.rule(input);
            self
        }
        pub fn set_rule(mut self, input: std::option::Option<crate::model::ReceiptRule>) -> Self {
            self.inner = self.inner.set_rule(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateReceiptRuleSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_receipt_rule_set_input::Builder,
    }
    impl<C> CreateReceiptRuleSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateReceiptRuleSetOutput,
            smithy_http::result::SdkError<crate::error::CreateReceiptRuleSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the rule set to create. The name must:</p>
        /// <ul>
        /// <li>
        /// <p>This value can only contain ASCII letters (a-z, A-Z), numbers (0-9),
        /// underscores (_), or dashes (-).</p>
        /// </li>
        /// <li>
        /// <p>Start and end with a letter or number.</p>
        /// </li>
        /// <li>
        /// <p>Contain less than 64 characters.</p>
        /// </li>
        /// </ul>
        pub fn rule_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_set_name(input);
            self
        }
        pub fn set_rule_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rule_set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTemplate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_template_input::Builder,
    }
    impl<C> CreateTemplate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTemplateOutput,
            smithy_http::result::SdkError<crate::error::CreateTemplateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The content of the email, composed of a subject line, an HTML part, and a text-only
        /// part.</p>
        pub fn template(mut self, input: crate::model::Template) -> Self {
            self.inner = self.inner.template(input);
            self
        }
        pub fn set_template(mut self, input: std::option::Option<crate::model::Template>) -> Self {
            self.inner = self.inner.set_template(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteConfigurationSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_configuration_set_input::Builder,
    }
    impl<C> DeleteConfigurationSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteConfigurationSetOutput,
            smithy_http::result::SdkError<crate::error::DeleteConfigurationSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the configuration set to delete.</p>
        pub fn configuration_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.configuration_set_name(input);
            self
        }
        pub fn set_configuration_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_configuration_set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteConfigurationSetEventDestination<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_configuration_set_event_destination_input::Builder,
    }
    impl<C> DeleteConfigurationSetEventDestination<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteConfigurationSetEventDestinationOutput,
            smithy_http::result::SdkError<
                crate::error::DeleteConfigurationSetEventDestinationError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the configuration set from which to delete the event destination.</p>
        pub fn configuration_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.configuration_set_name(input);
            self
        }
        pub fn set_configuration_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_configuration_set_name(input);
            self
        }
        /// <p>The name of the event destination to delete.</p>
        pub fn event_destination_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.event_destination_name(input);
            self
        }
        pub fn set_event_destination_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_event_destination_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteConfigurationSetTrackingOptions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_configuration_set_tracking_options_input::Builder,
    }
    impl<C> DeleteConfigurationSetTrackingOptions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteConfigurationSetTrackingOptionsOutput,
            smithy_http::result::SdkError<crate::error::DeleteConfigurationSetTrackingOptionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the configuration set from which you want to delete the tracking
        /// options.</p>
        pub fn configuration_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.configuration_set_name(input);
            self
        }
        pub fn set_configuration_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_configuration_set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCustomVerificationEmailTemplate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_custom_verification_email_template_input::Builder,
    }
    impl<C> DeleteCustomVerificationEmailTemplate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteCustomVerificationEmailTemplateOutput,
            smithy_http::result::SdkError<crate::error::DeleteCustomVerificationEmailTemplateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the custom verification email template that you want to delete.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_name(input);
            self
        }
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteIdentity<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_identity_input::Builder,
    }
    impl<C> DeleteIdentity<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteIdentityOutput,
            smithy_http::result::SdkError<crate::error::DeleteIdentityError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identity to be removed from the list of identities for the AWS Account.</p>
        pub fn identity(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.identity(input);
            self
        }
        pub fn set_identity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_identity(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteIdentityPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_identity_policy_input::Builder,
    }
    impl<C> DeleteIdentityPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteIdentityPolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteIdentityPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identity that is associated with the policy that you want to delete. You can
        /// specify the identity by using its name or by using its Amazon Resource Name (ARN).
        /// Examples: <code>user@example.com</code>, <code>example.com</code>,
        /// <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>.</p>
        /// <p>To successfully call this API, you must own the identity.</p>
        pub fn identity(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.identity(input);
            self
        }
        pub fn set_identity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_identity(input);
            self
        }
        /// <p>The name of the policy to be deleted.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(input);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteReceiptFilter<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_receipt_filter_input::Builder,
    }
    impl<C> DeleteReceiptFilter<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteReceiptFilterOutput,
            smithy_http::result::SdkError<crate::error::DeleteReceiptFilterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IP address filter to delete.</p>
        pub fn filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_name(input);
            self
        }
        pub fn set_filter_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_filter_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteReceiptRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_receipt_rule_input::Builder,
    }
    impl<C> DeleteReceiptRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteReceiptRuleOutput,
            smithy_http::result::SdkError<crate::error::DeleteReceiptRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the receipt rule set that contains the receipt rule to delete.</p>
        pub fn rule_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_set_name(input);
            self
        }
        pub fn set_rule_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rule_set_name(input);
            self
        }
        /// <p>The name of the receipt rule to delete.</p>
        pub fn rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_name(input);
            self
        }
        pub fn set_rule_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_rule_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteReceiptRuleSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_receipt_rule_set_input::Builder,
    }
    impl<C> DeleteReceiptRuleSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteReceiptRuleSetOutput,
            smithy_http::result::SdkError<crate::error::DeleteReceiptRuleSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the receipt rule set to delete.</p>
        pub fn rule_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_set_name(input);
            self
        }
        pub fn set_rule_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rule_set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTemplate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_template_input::Builder,
    }
    impl<C> DeleteTemplate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTemplateOutput,
            smithy_http::result::SdkError<crate::error::DeleteTemplateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the template to be deleted.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_name(input);
            self
        }
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteVerifiedEmailAddress<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_verified_email_address_input::Builder,
    }
    impl<C> DeleteVerifiedEmailAddress<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteVerifiedEmailAddressOutput,
            smithy_http::result::SdkError<crate::error::DeleteVerifiedEmailAddressError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An email address to be removed from the list of verified addresses.</p>
        pub fn email_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.email_address(input);
            self
        }
        pub fn set_email_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_email_address(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeActiveReceiptRuleSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_active_receipt_rule_set_input::Builder,
    }
    impl<C> DescribeActiveReceiptRuleSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeActiveReceiptRuleSetOutput,
            smithy_http::result::SdkError<crate::error::DescribeActiveReceiptRuleSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeConfigurationSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_configuration_set_input::Builder,
    }
    impl<C> DescribeConfigurationSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeConfigurationSetOutput,
            smithy_http::result::SdkError<crate::error::DescribeConfigurationSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the configuration set to describe.</p>
        pub fn configuration_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.configuration_set_name(input);
            self
        }
        pub fn set_configuration_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_configuration_set_name(input);
            self
        }
        /// <p>A list of configuration set attributes to return.</p>
        pub fn configuration_set_attribute_names(
            mut self,
            inp: impl Into<crate::model::ConfigurationSetAttribute>,
        ) -> Self {
            self.inner = self.inner.configuration_set_attribute_names(inp);
            self
        }
        pub fn set_configuration_set_attribute_names(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ConfigurationSetAttribute>>,
        ) -> Self {
            self.inner = self.inner.set_configuration_set_attribute_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeReceiptRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_receipt_rule_input::Builder,
    }
    impl<C> DescribeReceiptRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeReceiptRuleOutput,
            smithy_http::result::SdkError<crate::error::DescribeReceiptRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the receipt rule set that the receipt rule belongs to.</p>
        pub fn rule_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_set_name(input);
            self
        }
        pub fn set_rule_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rule_set_name(input);
            self
        }
        /// <p>The name of the receipt rule.</p>
        pub fn rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_name(input);
            self
        }
        pub fn set_rule_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_rule_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeReceiptRuleSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_receipt_rule_set_input::Builder,
    }
    impl<C> DescribeReceiptRuleSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeReceiptRuleSetOutput,
            smithy_http::result::SdkError<crate::error::DescribeReceiptRuleSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the receipt rule set to describe.</p>
        pub fn rule_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_set_name(input);
            self
        }
        pub fn set_rule_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rule_set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAccountSendingEnabled<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_account_sending_enabled_input::Builder,
    }
    impl<C> GetAccountSendingEnabled<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetAccountSendingEnabledOutput,
            smithy_http::result::SdkError<crate::error::GetAccountSendingEnabledError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCustomVerificationEmailTemplate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_custom_verification_email_template_input::Builder,
    }
    impl<C> GetCustomVerificationEmailTemplate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCustomVerificationEmailTemplateOutput,
            smithy_http::result::SdkError<crate::error::GetCustomVerificationEmailTemplateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the custom verification email template that you want to retrieve.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_name(input);
            self
        }
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetIdentityDkimAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_identity_dkim_attributes_input::Builder,
    }
    impl<C> GetIdentityDkimAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetIdentityDkimAttributesOutput,
            smithy_http::result::SdkError<crate::error::GetIdentityDkimAttributesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A list of one or more verified identities - email addresses, domains, or both.</p>
        pub fn identities(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.identities(inp);
            self
        }
        pub fn set_identities(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_identities(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetIdentityMailFromDomainAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_identity_mail_from_domain_attributes_input::Builder,
    }
    impl<C> GetIdentityMailFromDomainAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetIdentityMailFromDomainAttributesOutput,
            smithy_http::result::SdkError<crate::error::GetIdentityMailFromDomainAttributesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A list of one or more identities.</p>
        pub fn identities(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.identities(inp);
            self
        }
        pub fn set_identities(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_identities(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetIdentityNotificationAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_identity_notification_attributes_input::Builder,
    }
    impl<C> GetIdentityNotificationAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetIdentityNotificationAttributesOutput,
            smithy_http::result::SdkError<crate::error::GetIdentityNotificationAttributesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A list of one or more identities. You can specify an identity by using its name or by
        /// using its Amazon Resource Name (ARN). Examples: <code>user@example.com</code>,
        /// <code>example.com</code>,
        /// <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>.</p>
        pub fn identities(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.identities(inp);
            self
        }
        pub fn set_identities(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_identities(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetIdentityPolicies<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_identity_policies_input::Builder,
    }
    impl<C> GetIdentityPolicies<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetIdentityPoliciesOutput,
            smithy_http::result::SdkError<crate::error::GetIdentityPoliciesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identity for which the policies will be retrieved. You can specify an identity by
        /// using its name or by using its Amazon Resource Name (ARN). Examples:
        /// <code>user@example.com</code>, <code>example.com</code>,
        /// <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>.</p>
        /// <p>To successfully call this API, you must own the identity.</p>
        pub fn identity(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.identity(input);
            self
        }
        pub fn set_identity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_identity(input);
            self
        }
        /// <p>A list of the names of policies to be retrieved. You can retrieve a maximum of 20
        /// policies at a time. If you do not know the names of the policies that are attached to
        /// the identity, you can use <code>ListIdentityPolicies</code>.</p>
        pub fn policy_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_names(inp);
            self
        }
        pub fn set_policy_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_policy_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetIdentityVerificationAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_identity_verification_attributes_input::Builder,
    }
    impl<C> GetIdentityVerificationAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetIdentityVerificationAttributesOutput,
            smithy_http::result::SdkError<crate::error::GetIdentityVerificationAttributesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A list of identities.</p>
        pub fn identities(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.identities(inp);
            self
        }
        pub fn set_identities(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_identities(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSendQuota<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_send_quota_input::Builder,
    }
    impl<C> GetSendQuota<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSendQuotaOutput,
            smithy_http::result::SdkError<crate::error::GetSendQuotaError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSendStatistics<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_send_statistics_input::Builder,
    }
    impl<C> GetSendStatistics<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSendStatisticsOutput,
            smithy_http::result::SdkError<crate::error::GetSendStatisticsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTemplate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_template_input::Builder,
    }
    impl<C> GetTemplate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetTemplateOutput,
            smithy_http::result::SdkError<crate::error::GetTemplateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the template you want to retrieve.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_name(input);
            self
        }
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListConfigurationSets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_configuration_sets_input::Builder,
    }
    impl<C> ListConfigurationSets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListConfigurationSetsOutput,
            smithy_http::result::SdkError<crate::error::ListConfigurationSetsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A token returned from a previous call to <code>ListConfigurationSets</code> to
        /// indicate the position of the configuration set in the configuration set list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The number of configuration sets to return.</p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListCustomVerificationEmailTemplates<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_custom_verification_email_templates_input::Builder,
    }
    impl<C> ListCustomVerificationEmailTemplates<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListCustomVerificationEmailTemplatesOutput,
            smithy_http::result::SdkError<crate::error::ListCustomVerificationEmailTemplatesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An array the contains the name and creation time stamp for each template in your Amazon SES
        /// account.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of custom verification email templates to return. This value must
        /// be at least 1 and less than or equal to 50. If you do not specify a value, or if you
        /// specify a value less than 1 or greater than 50, the operation will return up to 50
        /// results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListIdentities<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_identities_input::Builder,
    }
    impl<C> ListIdentities<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListIdentitiesOutput,
            smithy_http::result::SdkError<crate::error::ListIdentitiesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The type of the identities to list. Possible values are "EmailAddress" and "Domain".
        /// If this parameter is omitted, then all identities will be listed.</p>
        pub fn identity_type(mut self, input: crate::model::IdentityType) -> Self {
            self.inner = self.inner.identity_type(input);
            self
        }
        pub fn set_identity_type(
            mut self,
            input: std::option::Option<crate::model::IdentityType>,
        ) -> Self {
            self.inner = self.inner.set_identity_type(input);
            self
        }
        /// <p>The token to use for pagination.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of identities per page. Possible values are 1-1000
        /// inclusive.</p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListIdentityPolicies<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_identity_policies_input::Builder,
    }
    impl<C> ListIdentityPolicies<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListIdentityPoliciesOutput,
            smithy_http::result::SdkError<crate::error::ListIdentityPoliciesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identity that is associated with the policy for which the policies will be listed.
        /// You can specify an identity by using its name or by using its Amazon Resource Name
        /// (ARN). Examples: <code>user@example.com</code>, <code>example.com</code>,
        /// <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>.</p>
        /// <p>To successfully call this API, you must own the identity.</p>
        pub fn identity(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.identity(input);
            self
        }
        pub fn set_identity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_identity(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListReceiptFilters<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_receipt_filters_input::Builder,
    }
    impl<C> ListReceiptFilters<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListReceiptFiltersOutput,
            smithy_http::result::SdkError<crate::error::ListReceiptFiltersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListReceiptRuleSets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_receipt_rule_sets_input::Builder,
    }
    impl<C> ListReceiptRuleSets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListReceiptRuleSetsOutput,
            smithy_http::result::SdkError<crate::error::ListReceiptRuleSetsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A token returned from a previous call to <code>ListReceiptRuleSets</code> to indicate
        /// the position in the receipt rule set list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTemplates<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_templates_input::Builder,
    }
    impl<C> ListTemplates<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTemplatesOutput,
            smithy_http::result::SdkError<crate::error::ListTemplatesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A token returned from a previous call to <code>ListTemplates</code> to indicate the
        /// position in the list of email templates.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of templates to return. This value must be at least 1 and less than
        /// or equal to 10. If you do not specify a value, or if you specify a value less than 1 or
        /// greater than 10, the operation will return up to 10 results.</p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListVerifiedEmailAddresses<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_verified_email_addresses_input::Builder,
    }
    impl<C> ListVerifiedEmailAddresses<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListVerifiedEmailAddressesOutput,
            smithy_http::result::SdkError<crate::error::ListVerifiedEmailAddressesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutConfigurationSetDeliveryOptions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_configuration_set_delivery_options_input::Builder,
    }
    impl<C> PutConfigurationSetDeliveryOptions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutConfigurationSetDeliveryOptionsOutput,
            smithy_http::result::SdkError<crate::error::PutConfigurationSetDeliveryOptionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the configuration set that you want to specify the delivery options
        /// for.</p>
        pub fn configuration_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.configuration_set_name(input);
            self
        }
        pub fn set_configuration_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_configuration_set_name(input);
            self
        }
        /// <p>Specifies whether messages that use the configuration set are required to use
        /// Transport Layer Security (TLS).</p>
        pub fn delivery_options(mut self, input: crate::model::DeliveryOptions) -> Self {
            self.inner = self.inner.delivery_options(input);
            self
        }
        pub fn set_delivery_options(
            mut self,
            input: std::option::Option<crate::model::DeliveryOptions>,
        ) -> Self {
            self.inner = self.inner.set_delivery_options(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutIdentityPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_identity_policy_input::Builder,
    }
    impl<C> PutIdentityPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutIdentityPolicyOutput,
            smithy_http::result::SdkError<crate::error::PutIdentityPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identity that the policy will apply to. You can specify an identity by using its
        /// name or by using its Amazon Resource Name (ARN). Examples:
        /// <code>user@example.com</code>, <code>example.com</code>,
        /// <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>.</p>
        /// <p>To successfully call this API, you must own the identity.</p>
        pub fn identity(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.identity(input);
            self
        }
        pub fn set_identity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_identity(input);
            self
        }
        /// <p>The name of the policy.</p>
        /// <p>The policy name cannot exceed 64 characters and can only include alphanumeric
        /// characters, dashes, and underscores.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(input);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
        /// <p>The text of the policy in JSON format. The policy cannot exceed 4 KB.</p>
        /// <p>For information about the syntax of sending authorization policies, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization-policies.html">Amazon SES Developer
        /// Guide</a>. </p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(input);
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ReorderReceiptRuleSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reorder_receipt_rule_set_input::Builder,
    }
    impl<C> ReorderReceiptRuleSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ReorderReceiptRuleSetOutput,
            smithy_http::result::SdkError<crate::error::ReorderReceiptRuleSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the receipt rule set to reorder.</p>
        pub fn rule_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_set_name(input);
            self
        }
        pub fn set_rule_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rule_set_name(input);
            self
        }
        /// <p>A list of the specified receipt rule set's receipt rules in the order that you want to
        /// put them.</p>
        pub fn rule_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_names(inp);
            self
        }
        pub fn set_rule_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_rule_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SendBounce<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::send_bounce_input::Builder,
    }
    impl<C> SendBounce<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SendBounceOutput,
            smithy_http::result::SdkError<crate::error::SendBounceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The message ID of the message to be bounced.</p>
        pub fn original_message_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.original_message_id(input);
            self
        }
        pub fn set_original_message_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_original_message_id(input);
            self
        }
        /// <p>The address to use in the "From" header of the bounce message. This must be an
        /// identity that you have verified with Amazon SES.</p>
        pub fn bounce_sender(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bounce_sender(input);
            self
        }
        pub fn set_bounce_sender(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_bounce_sender(input);
            self
        }
        /// <p>Human-readable text for the bounce message to explain the failure. If not specified,
        /// the text will be auto-generated based on the bounced recipient information.</p>
        pub fn explanation(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.explanation(input);
            self
        }
        pub fn set_explanation(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_explanation(input);
            self
        }
        /// <p>Message-related DSN fields. If not specified, Amazon SES will choose the values.</p>
        pub fn message_dsn(mut self, input: crate::model::MessageDsn) -> Self {
            self.inner = self.inner.message_dsn(input);
            self
        }
        pub fn set_message_dsn(
            mut self,
            input: std::option::Option<crate::model::MessageDsn>,
        ) -> Self {
            self.inner = self.inner.set_message_dsn(input);
            self
        }
        /// <p>A list of recipients of the bounced message, including the information required to
        /// create the Delivery Status Notifications (DSNs) for the recipients. You must specify at
        /// least one <code>BouncedRecipientInfo</code> in the list.</p>
        pub fn bounced_recipient_info_list(
            mut self,
            inp: impl Into<crate::model::BouncedRecipientInfo>,
        ) -> Self {
            self.inner = self.inner.bounced_recipient_info_list(inp);
            self
        }
        pub fn set_bounced_recipient_info_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BouncedRecipientInfo>>,
        ) -> Self {
            self.inner = self.inner.set_bounced_recipient_info_list(input);
            self
        }
        /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
        /// that is associated with the sending authorization policy that permits you to use the
        /// address in the "From" header of the bounce. For more information about sending
        /// authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
        /// Guide</a>.</p>
        pub fn bounce_sender_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bounce_sender_arn(input);
            self
        }
        pub fn set_bounce_sender_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_bounce_sender_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SendBulkTemplatedEmail<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::send_bulk_templated_email_input::Builder,
    }
    impl<C> SendBulkTemplatedEmail<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SendBulkTemplatedEmailOutput,
            smithy_http::result::SdkError<crate::error::SendBulkTemplatedEmailError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The email address that is sending the email. This email address must be either
        /// individually verified with Amazon SES, or from a domain that has been verified with Amazon SES.
        /// For information about verifying identities, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-addresses-and-domains.html">Amazon SES Developer
        /// Guide</a>.</p>
        /// <p>If you are sending on behalf of another user and have been permitted to do so by a
        /// sending authorization policy, then you must also specify the <code>SourceArn</code>
        /// parameter. For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer Guide</a>.</p>
        /// <note>
        /// <p>Amazon SES does not support the SMTPUTF8 extension, as described in <a href="https://tools.ietf.org/html/rfc6531">RFC6531</a>. For this reason, the
        /// <i>local part</i> of a source email address (the part of the email
        /// address that precedes the @ sign) may only contain <a href="https://en.wikipedia.org/wiki/Email_address#Local-part">7-bit ASCII
        /// characters</a>. If the <i>domain part</i> of an address (the
        /// part after the @ sign) contains non-ASCII characters, they must be encoded using
        /// Punycode, as described in <a href="https://tools.ietf.org/html/rfc3492.html">RFC3492</a>. The sender name (also known as the <i>friendly
        /// name</i>) may contain non-ASCII characters. These characters must be
        /// encoded using MIME encoded-word syntax, as described in <a href="https://tools.ietf.org/html/rfc2047">RFC 2047</a>. MIME encoded-word
        /// syntax uses the following form:
        /// <code>=?charset?encoding?encoded-text?=</code>.</p>
        /// </note>
        pub fn source(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source(input);
            self
        }
        pub fn set_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_source(input);
            self
        }
        /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
        /// that is associated with the sending authorization policy that permits you to send for
        /// the email address specified in the <code>Source</code> parameter.</p>
        /// <p>For example, if the owner of <code>example.com</code> (which has ARN
        /// <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>) attaches a
        /// policy to it that authorizes you to send from <code>user@example.com</code>, then you
        /// would specify the <code>SourceArn</code> to be
        /// <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>, and the
        /// <code>Source</code> to be <code>user@example.com</code>.</p>
        /// <p>For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
        /// Guide</a>.</p>
        pub fn source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_arn(input);
            self
        }
        pub fn set_source_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_source_arn(input);
            self
        }
        /// <p>The reply-to email address(es) for the message. If the recipient replies to the
        /// message, each reply-to address will receive the reply.</p>
        pub fn reply_to_addresses(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reply_to_addresses(inp);
            self
        }
        pub fn set_reply_to_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_reply_to_addresses(input);
            self
        }
        /// <p>The email address that bounces and complaints will be forwarded to when feedback
        /// forwarding is enabled. If the message cannot be delivered to the recipient, then an
        /// error message will be returned from the recipient's ISP; this message will then be
        /// forwarded to the email address specified by the <code>ReturnPath</code> parameter. The
        /// <code>ReturnPath</code> parameter is never overwritten. This email address must be
        /// either individually verified with Amazon SES, or from a domain that has been verified with
        /// Amazon SES. </p>
        pub fn return_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.return_path(input);
            self
        }
        pub fn set_return_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_return_path(input);
            self
        }
        /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
        /// that is associated with the sending authorization policy that permits you to use the
        /// email address specified in the <code>ReturnPath</code> parameter.</p>
        /// <p>For example, if the owner of <code>example.com</code> (which has ARN
        /// <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>) attaches a
        /// policy to it that authorizes you to use <code>feedback@example.com</code>, then you
        /// would specify the <code>ReturnPathArn</code> to be
        /// <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>, and the
        /// <code>ReturnPath</code> to be <code>feedback@example.com</code>.</p>
        /// <p>For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
        /// Guide</a>.</p>
        pub fn return_path_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.return_path_arn(input);
            self
        }
        pub fn set_return_path_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_return_path_arn(input);
            self
        }
        /// <p>The name of the configuration set to use when you send an email using
        /// <code>SendBulkTemplatedEmail</code>.</p>
        pub fn configuration_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.configuration_set_name(input);
            self
        }
        pub fn set_configuration_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_configuration_set_name(input);
            self
        }
        /// <p>A list of tags, in the form of name/value pairs, to apply to an email that you send to
        /// a destination using <code>SendBulkTemplatedEmail</code>.</p>
        pub fn default_tags(mut self, inp: impl Into<crate::model::MessageTag>) -> Self {
            self.inner = self.inner.default_tags(inp);
            self
        }
        pub fn set_default_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MessageTag>>,
        ) -> Self {
            self.inner = self.inner.set_default_tags(input);
            self
        }
        /// <p>The template to use when sending this email.</p>
        pub fn template(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template(input);
            self
        }
        pub fn set_template(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_template(input);
            self
        }
        /// <p>The ARN of the template to use when sending this email.</p>
        pub fn template_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_arn(input);
            self
        }
        pub fn set_template_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_template_arn(input);
            self
        }
        /// <p>A list of replacement values to apply to the template when replacement data is not
        /// specified in a Destination object. These values act as a default or fallback option when
        /// no other data is available.</p>
        /// <p>The template data is a JSON object, typically consisting of key-value pairs in which
        /// the keys correspond to replacement tags in the email template.</p>
        pub fn default_template_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.default_template_data(input);
            self
        }
        pub fn set_default_template_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_template_data(input);
            self
        }
        /// <p>One or more <code>Destination</code> objects. All of the recipients in a
        /// <code>Destination</code> will receive the same version of the email. You can specify
        /// up to 50 <code>Destination</code> objects within a <code>Destinations</code>
        /// array.</p>
        pub fn destinations(mut self, inp: impl Into<crate::model::BulkEmailDestination>) -> Self {
            self.inner = self.inner.destinations(inp);
            self
        }
        pub fn set_destinations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BulkEmailDestination>>,
        ) -> Self {
            self.inner = self.inner.set_destinations(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SendCustomVerificationEmail<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::send_custom_verification_email_input::Builder,
    }
    impl<C> SendCustomVerificationEmail<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SendCustomVerificationEmailOutput,
            smithy_http::result::SdkError<crate::error::SendCustomVerificationEmailError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The email address to verify.</p>
        pub fn email_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.email_address(input);
            self
        }
        pub fn set_email_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_email_address(input);
            self
        }
        /// <p>The name of the custom verification email template to use when sending the
        /// verification email.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_name(input);
            self
        }
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_name(input);
            self
        }
        /// <p>Name of a configuration set to use when sending the verification email.</p>
        pub fn configuration_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.configuration_set_name(input);
            self
        }
        pub fn set_configuration_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_configuration_set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SendEmail<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::send_email_input::Builder,
    }
    impl<C> SendEmail<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SendEmailOutput,
            smithy_http::result::SdkError<crate::error::SendEmailError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The email address that is sending the email. This email address must be either
        /// individually verified with Amazon SES, or from a domain that has been verified with Amazon SES.
        /// For information about verifying identities, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-addresses-and-domains.html">Amazon SES Developer
        /// Guide</a>.</p>
        /// <p>If you are sending on behalf of another user and have been permitted to do so by a
        /// sending authorization policy, then you must also specify the <code>SourceArn</code>
        /// parameter. For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer Guide</a>.</p>
        /// <note>
        /// <p>Amazon SES does not support the SMTPUTF8 extension, as described in <a href="https://tools.ietf.org/html/rfc6531">RFC6531</a>. For this reason, the
        /// <i>local part</i> of a source email address (the part of the email
        /// address that precedes the @ sign) may only contain <a href="https://en.wikipedia.org/wiki/Email_address#Local-part">7-bit ASCII
        /// characters</a>. If the <i>domain part</i> of an address (the
        /// part after the @ sign) contains non-ASCII characters, they must be encoded using
        /// Punycode, as described in <a href="https://tools.ietf.org/html/rfc3492.html">RFC3492</a>. The sender name (also known as the <i>friendly
        /// name</i>) may contain non-ASCII characters. These characters must be
        /// encoded using MIME encoded-word syntax, as described in <a href="https://tools.ietf.org/html/rfc2047">RFC 2047</a>. MIME encoded-word
        /// syntax uses the following form:
        /// <code>=?charset?encoding?encoded-text?=</code>.</p>
        /// </note>
        pub fn source(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source(input);
            self
        }
        pub fn set_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_source(input);
            self
        }
        /// <p>The destination for this email, composed of To:, CC:, and BCC: fields.</p>
        pub fn destination(mut self, input: crate::model::Destination) -> Self {
            self.inner = self.inner.destination(input);
            self
        }
        pub fn set_destination(
            mut self,
            input: std::option::Option<crate::model::Destination>,
        ) -> Self {
            self.inner = self.inner.set_destination(input);
            self
        }
        /// <p>The message to be sent.</p>
        pub fn message(mut self, input: crate::model::Message) -> Self {
            self.inner = self.inner.message(input);
            self
        }
        pub fn set_message(mut self, input: std::option::Option<crate::model::Message>) -> Self {
            self.inner = self.inner.set_message(input);
            self
        }
        /// <p>The reply-to email address(es) for the message. If the recipient replies to the
        /// message, each reply-to address will receive the reply.</p>
        pub fn reply_to_addresses(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reply_to_addresses(inp);
            self
        }
        pub fn set_reply_to_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_reply_to_addresses(input);
            self
        }
        /// <p>The email address that bounces and complaints will be forwarded to when feedback
        /// forwarding is enabled. If the message cannot be delivered to the recipient, then an
        /// error message will be returned from the recipient's ISP; this message will then be
        /// forwarded to the email address specified by the <code>ReturnPath</code> parameter. The
        /// <code>ReturnPath</code> parameter is never overwritten. This email address must be
        /// either individually verified with Amazon SES, or from a domain that has been verified with
        /// Amazon SES. </p>
        pub fn return_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.return_path(input);
            self
        }
        pub fn set_return_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_return_path(input);
            self
        }
        /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
        /// that is associated with the sending authorization policy that permits you to send for
        /// the email address specified in the <code>Source</code> parameter.</p>
        /// <p>For example, if the owner of <code>example.com</code> (which has ARN
        /// <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>) attaches a
        /// policy to it that authorizes you to send from <code>user@example.com</code>, then you
        /// would specify the <code>SourceArn</code> to be
        /// <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>, and the
        /// <code>Source</code> to be <code>user@example.com</code>.</p>
        /// <p>For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
        /// Guide</a>.</p>
        pub fn source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_arn(input);
            self
        }
        pub fn set_source_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_source_arn(input);
            self
        }
        /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
        /// that is associated with the sending authorization policy that permits you to use the
        /// email address specified in the <code>ReturnPath</code> parameter.</p>
        /// <p>For example, if the owner of <code>example.com</code> (which has ARN
        /// <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>) attaches a
        /// policy to it that authorizes you to use <code>feedback@example.com</code>, then you
        /// would specify the <code>ReturnPathArn</code> to be
        /// <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>, and the
        /// <code>ReturnPath</code> to be <code>feedback@example.com</code>.</p>
        /// <p>For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
        /// Guide</a>.</p>
        pub fn return_path_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.return_path_arn(input);
            self
        }
        pub fn set_return_path_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_return_path_arn(input);
            self
        }
        /// <p>A list of tags, in the form of name/value pairs, to apply to an email that you send
        /// using <code>SendEmail</code>. Tags correspond to characteristics of the email that you
        /// define, so that you can publish email sending events.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::MessageTag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MessageTag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The name of the configuration set to use when you send an email using
        /// <code>SendEmail</code>.</p>
        pub fn configuration_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.configuration_set_name(input);
            self
        }
        pub fn set_configuration_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_configuration_set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SendRawEmail<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::send_raw_email_input::Builder,
    }
    impl<C> SendRawEmail<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SendRawEmailOutput,
            smithy_http::result::SdkError<crate::error::SendRawEmailError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identity's email address. If you do not provide a value for this parameter, you
        /// must specify a "From" address in the raw text of the message. (You can also specify
        /// both.)</p>
        /// <note>
        /// <p>Amazon SES does not support the SMTPUTF8 extension, as described in<a href="https://tools.ietf.org/html/rfc6531">RFC6531</a>. For this reason, the
        /// <i>local part</i> of a source email address (the part of the email
        /// address that precedes the @ sign) may only contain <a href="https://en.wikipedia.org/wiki/Email_address#Local-part">7-bit ASCII
        /// characters</a>. If the <i>domain part</i> of an address (the
        /// part after the @ sign) contains non-ASCII characters, they must be encoded using
        /// Punycode, as described in <a href="https://tools.ietf.org/html/rfc3492.html">RFC3492</a>. The sender name (also known as the <i>friendly
        /// name</i>) may contain non-ASCII characters. These characters must be
        /// encoded using MIME encoded-word syntax, as described in <a href="https://tools.ietf.org/html/rfc2047">RFC 2047</a>. MIME encoded-word
        /// syntax uses the following form:
        /// <code>=?charset?encoding?encoded-text?=</code>.</p>
        /// </note>
        /// <p>If you specify the <code>Source</code> parameter and have feedback forwarding enabled,
        /// then bounces and complaints will be sent to this email address. This takes precedence
        /// over any Return-Path header that you might include in the raw text of the
        /// message.</p>
        pub fn source(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source(input);
            self
        }
        pub fn set_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_source(input);
            self
        }
        /// <p>A list of destinations for the message, consisting of To:, CC:, and BCC:
        /// addresses.</p>
        pub fn destinations(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destinations(inp);
            self
        }
        pub fn set_destinations(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_destinations(input);
            self
        }
        /// <p>The raw email message itself. The message has to meet the following criteria:</p>
        /// <ul>
        /// <li>
        /// <p>The message has to contain a header and a body, separated by a blank
        /// line.</p>
        /// </li>
        /// <li>
        /// <p>All of the required header fields must be present in the message.</p>
        /// </li>
        /// <li>
        /// <p>Each part of a multipart MIME message must be formatted properly.</p>
        /// </li>
        /// <li>
        /// <p>Attachments must be of a content type that Amazon SES supports. For a list on
        /// unsupported content types, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/mime-types.html">Unsupported Attachment
        /// Types</a> in the <i>Amazon SES Developer Guide</i>.</p>
        /// </li>
        /// <li>
        /// <p>The entire message must be base64-encoded.</p>
        /// </li>
        /// <li>
        /// <p>If any of the MIME parts in your message contain content that is outside of
        /// the 7-bit ASCII character range, we highly recommend that you encode that
        /// content. For more information, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-raw.html">Sending Raw Email</a> in the <i>Amazon SES Developer
        /// Guide</i>.</p>
        /// </li>
        /// <li>
        /// <p>Per <a href="https://tools.ietf.org/html/rfc5321#section-4.5.3.1.6">RFC
        /// 5321</a>, the maximum length of each line of text, including the
        /// <CRLF>, must not exceed 1,000 characters.</p>
        /// </li>
        /// </ul>
        pub fn raw_message(mut self, input: crate::model::RawMessage) -> Self {
            self.inner = self.inner.raw_message(input);
            self
        }
        pub fn set_raw_message(
            mut self,
            input: std::option::Option<crate::model::RawMessage>,
        ) -> Self {
            self.inner = self.inner.set_raw_message(input);
            self
        }
        /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
        /// that is associated with the sending authorization policy that permits you to specify a
        /// particular "From" address in the header of the raw email.</p>
        /// <p>Instead of using this parameter, you can use the X-header <code>X-SES-FROM-ARN</code>
        /// in the raw message of the email. If you use both the <code>FromArn</code> parameter and
        /// the corresponding X-header, Amazon SES uses the value of the <code>FromArn</code>
        /// parameter.</p>
        /// <note>
        /// <p>For information about when to use this parameter, see the description of
        /// <code>SendRawEmail</code> in this guide, or see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization-delegate-sender-tasks-email.html">Amazon SES Developer Guide</a>.</p>
        /// </note>
        pub fn from_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.from_arn(input);
            self
        }
        pub fn set_from_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_from_arn(input);
            self
        }
        /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
        /// that is associated with the sending authorization policy that permits you to send for
        /// the email address specified in the <code>Source</code> parameter.</p>
        /// <p>For example, if the owner of <code>example.com</code> (which has ARN
        /// <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>) attaches a
        /// policy to it that authorizes you to send from <code>user@example.com</code>, then you
        /// would specify the <code>SourceArn</code> to be
        /// <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>, and the
        /// <code>Source</code> to be <code>user@example.com</code>.</p>
        /// <p>Instead of using this parameter, you can use the X-header
        /// <code>X-SES-SOURCE-ARN</code> in the raw message of the email. If you use both the
        /// <code>SourceArn</code> parameter and the corresponding X-header, Amazon SES uses the
        /// value of the <code>SourceArn</code> parameter.</p>
        /// <note>
        /// <p>For information about when to use this parameter, see the description of
        /// <code>SendRawEmail</code> in this guide, or see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization-delegate-sender-tasks-email.html">Amazon SES Developer Guide</a>.</p>
        /// </note>
        pub fn source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_arn(input);
            self
        }
        pub fn set_source_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_source_arn(input);
            self
        }
        /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
        /// that is associated with the sending authorization policy that permits you to use the
        /// email address specified in the <code>ReturnPath</code> parameter.</p>
        /// <p>For example, if the owner of <code>example.com</code> (which has ARN
        /// <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>) attaches a
        /// policy to it that authorizes you to use <code>feedback@example.com</code>, then you
        /// would specify the <code>ReturnPathArn</code> to be
        /// <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>, and the
        /// <code>ReturnPath</code> to be <code>feedback@example.com</code>.</p>
        /// <p>Instead of using this parameter, you can use the X-header
        /// <code>X-SES-RETURN-PATH-ARN</code> in the raw message of the email. If you use both
        /// the <code>ReturnPathArn</code> parameter and the corresponding X-header, Amazon SES uses the
        /// value of the <code>ReturnPathArn</code> parameter.</p>
        /// <note>
        /// <p>For information about when to use this parameter, see the description of
        /// <code>SendRawEmail</code> in this guide, or see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization-delegate-sender-tasks-email.html">Amazon SES Developer Guide</a>.</p>
        /// </note>
        pub fn return_path_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.return_path_arn(input);
            self
        }
        pub fn set_return_path_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_return_path_arn(input);
            self
        }
        /// <p>A list of tags, in the form of name/value pairs, to apply to an email that you send
        /// using <code>SendRawEmail</code>. Tags correspond to characteristics of the email that
        /// you define, so that you can publish email sending events.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::MessageTag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MessageTag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The name of the configuration set to use when you send an email using
        /// <code>SendRawEmail</code>.</p>
        pub fn configuration_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.configuration_set_name(input);
            self
        }
        pub fn set_configuration_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_configuration_set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SendTemplatedEmail<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::send_templated_email_input::Builder,
    }
    impl<C> SendTemplatedEmail<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SendTemplatedEmailOutput,
            smithy_http::result::SdkError<crate::error::SendTemplatedEmailError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The email address that is sending the email. This email address must be either
        /// individually verified with Amazon SES, or from a domain that has been verified with Amazon SES.
        /// For information about verifying identities, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-addresses-and-domains.html">Amazon SES Developer
        /// Guide</a>.</p>
        /// <p>If you are sending on behalf of another user and have been permitted to do so by a
        /// sending authorization policy, then you must also specify the <code>SourceArn</code>
        /// parameter. For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer Guide</a>.</p>
        /// <note>
        /// <p>Amazon SES does not support the SMTPUTF8 extension, as described in <a href="https://tools.ietf.org/html/rfc6531">RFC6531</a>. For this reason, the
        /// <i>local part</i> of a source email address (the part of the email
        /// address that precedes the @ sign) may only contain <a href="https://en.wikipedia.org/wiki/Email_address#Local-part">7-bit ASCII
        /// characters</a>. If the <i>domain part</i> of an address (the
        /// part after the @ sign) contains non-ASCII characters, they must be encoded using
        /// Punycode, as described in <a href="https://tools.ietf.org/html/rfc3492.html">RFC3492</a>. The sender name (also known as the <i>friendly
        /// name</i>) may contain non-ASCII characters. These characters must be
        /// encoded using MIME encoded-word syntax, as described in<a href="https://tools.ietf.org/html/rfc2047">RFC 2047</a>. MIME encoded-word
        /// syntax uses the following form:
        /// <code>=?charset?encoding?encoded-text?=</code>.</p>
        /// </note>
        pub fn source(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source(input);
            self
        }
        pub fn set_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_source(input);
            self
        }
        /// <p>The destination for this email, composed of To:, CC:, and BCC: fields. A Destination
        /// can include up to 50 recipients across these three fields.</p>
        pub fn destination(mut self, input: crate::model::Destination) -> Self {
            self.inner = self.inner.destination(input);
            self
        }
        pub fn set_destination(
            mut self,
            input: std::option::Option<crate::model::Destination>,
        ) -> Self {
            self.inner = self.inner.set_destination(input);
            self
        }
        /// <p>The reply-to email address(es) for the message. If the recipient replies to the
        /// message, each reply-to address will receive the reply.</p>
        pub fn reply_to_addresses(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reply_to_addresses(inp);
            self
        }
        pub fn set_reply_to_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_reply_to_addresses(input);
            self
        }
        /// <p>The email address that bounces and complaints will be forwarded to when feedback
        /// forwarding is enabled. If the message cannot be delivered to the recipient, then an
        /// error message will be returned from the recipient's ISP; this message will then be
        /// forwarded to the email address specified by the <code>ReturnPath</code> parameter. The
        /// <code>ReturnPath</code> parameter is never overwritten. This email address must be
        /// either individually verified with Amazon SES, or from a domain that has been verified with
        /// Amazon SES. </p>
        pub fn return_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.return_path(input);
            self
        }
        pub fn set_return_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_return_path(input);
            self
        }
        /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
        /// that is associated with the sending authorization policy that permits you to send for
        /// the email address specified in the <code>Source</code> parameter.</p>
        /// <p>For example, if the owner of <code>example.com</code> (which has ARN
        /// <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>) attaches a
        /// policy to it that authorizes you to send from <code>user@example.com</code>, then you
        /// would specify the <code>SourceArn</code> to be
        /// <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>, and the
        /// <code>Source</code> to be <code>user@example.com</code>.</p>
        /// <p>For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
        /// Guide</a>.</p>
        pub fn source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_arn(input);
            self
        }
        pub fn set_source_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_source_arn(input);
            self
        }
        /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
        /// that is associated with the sending authorization policy that permits you to use the
        /// email address specified in the <code>ReturnPath</code> parameter.</p>
        /// <p>For example, if the owner of <code>example.com</code> (which has ARN
        /// <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>) attaches a
        /// policy to it that authorizes you to use <code>feedback@example.com</code>, then you
        /// would specify the <code>ReturnPathArn</code> to be
        /// <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>, and the
        /// <code>ReturnPath</code> to be <code>feedback@example.com</code>.</p>
        /// <p>For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
        /// Guide</a>.</p>
        pub fn return_path_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.return_path_arn(input);
            self
        }
        pub fn set_return_path_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_return_path_arn(input);
            self
        }
        /// <p>A list of tags, in the form of name/value pairs, to apply to an email that you send
        /// using <code>SendTemplatedEmail</code>. Tags correspond to characteristics of the email
        /// that you define, so that you can publish email sending events.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::MessageTag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MessageTag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The name of the configuration set to use when you send an email using
        /// <code>SendTemplatedEmail</code>.</p>
        pub fn configuration_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.configuration_set_name(input);
            self
        }
        pub fn set_configuration_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_configuration_set_name(input);
            self
        }
        /// <p>The template to use when sending this email.</p>
        pub fn template(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template(input);
            self
        }
        pub fn set_template(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_template(input);
            self
        }
        /// <p>The ARN of the template to use when sending this email.</p>
        pub fn template_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_arn(input);
            self
        }
        pub fn set_template_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_template_arn(input);
            self
        }
        /// <p>A list of replacement values to apply to the template. This parameter is a JSON
        /// object, typically consisting of key-value pairs in which the keys correspond to
        /// replacement tags in the email template.</p>
        pub fn template_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_data(input);
            self
        }
        pub fn set_template_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_data(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetActiveReceiptRuleSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_active_receipt_rule_set_input::Builder,
    }
    impl<C> SetActiveReceiptRuleSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetActiveReceiptRuleSetOutput,
            smithy_http::result::SdkError<crate::error::SetActiveReceiptRuleSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the receipt rule set to make active. Setting this value to null disables
        /// all email receiving.</p>
        pub fn rule_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_set_name(input);
            self
        }
        pub fn set_rule_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rule_set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetIdentityDkimEnabled<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_identity_dkim_enabled_input::Builder,
    }
    impl<C> SetIdentityDkimEnabled<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetIdentityDkimEnabledOutput,
            smithy_http::result::SdkError<crate::error::SetIdentityDkimEnabledError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identity for which DKIM signing should be enabled or disabled.</p>
        pub fn identity(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.identity(input);
            self
        }
        pub fn set_identity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_identity(input);
            self
        }
        /// <p>Sets whether DKIM signing is enabled for an identity. Set to <code>true</code> to
        /// enable DKIM signing for this identity; <code>false</code> to disable it. </p>
        pub fn dkim_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.dkim_enabled(input);
            self
        }
        pub fn set_dkim_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dkim_enabled(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetIdentityFeedbackForwardingEnabled<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_identity_feedback_forwarding_enabled_input::Builder,
    }
    impl<C> SetIdentityFeedbackForwardingEnabled<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetIdentityFeedbackForwardingEnabledOutput,
            smithy_http::result::SdkError<crate::error::SetIdentityFeedbackForwardingEnabledError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identity for which to set bounce and complaint notification forwarding. Examples:
        /// <code>user@example.com</code>, <code>example.com</code>.</p>
        pub fn identity(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.identity(input);
            self
        }
        pub fn set_identity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_identity(input);
            self
        }
        /// <p>Sets whether Amazon SES will forward bounce and complaint notifications as email.
        /// <code>true</code> specifies that Amazon SES will forward bounce and complaint
        /// notifications as email, in addition to any Amazon SNS topic publishing otherwise specified.
        /// <code>false</code> specifies that Amazon SES will publish bounce and complaint
        /// notifications only through Amazon SNS. This value can only be set to <code>false</code> when
        /// Amazon SNS topics are set for both <code>Bounce</code> and <code>Complaint</code>
        /// notification types.</p>
        pub fn forwarding_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.forwarding_enabled(input);
            self
        }
        pub fn set_forwarding_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_forwarding_enabled(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetIdentityHeadersInNotificationsEnabled<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_identity_headers_in_notifications_enabled_input::Builder,
    }
    impl<C> SetIdentityHeadersInNotificationsEnabled<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetIdentityHeadersInNotificationsEnabledOutput,
            smithy_http::result::SdkError<
                crate::error::SetIdentityHeadersInNotificationsEnabledError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identity for which to enable or disable headers in notifications. Examples:
        /// <code>user@example.com</code>, <code>example.com</code>.</p>
        pub fn identity(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.identity(input);
            self
        }
        pub fn set_identity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_identity(input);
            self
        }
        /// <p>The notification type for which to enable or disable headers in notifications. </p>
        pub fn notification_type(mut self, input: crate::model::NotificationType) -> Self {
            self.inner = self.inner.notification_type(input);
            self
        }
        pub fn set_notification_type(
            mut self,
            input: std::option::Option<crate::model::NotificationType>,
        ) -> Self {
            self.inner = self.inner.set_notification_type(input);
            self
        }
        /// <p>Sets whether Amazon SES includes the original email headers in Amazon SNS notifications of the
        /// specified notification type. A value of <code>true</code> specifies that Amazon SES will
        /// include headers in notifications, and a value of <code>false</code> specifies that Amazon SES
        /// will not include headers in notifications.</p>
        /// <p>This value can only be set when <code>NotificationType</code> is already set to use a
        /// particular Amazon SNS topic.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.enabled(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_enabled(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetIdentityMailFromDomain<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_identity_mail_from_domain_input::Builder,
    }
    impl<C> SetIdentityMailFromDomain<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetIdentityMailFromDomainOutput,
            smithy_http::result::SdkError<crate::error::SetIdentityMailFromDomainError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The verified identity for which you want to enable or disable the specified custom
        /// MAIL FROM domain.</p>
        pub fn identity(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.identity(input);
            self
        }
        pub fn set_identity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_identity(input);
            self
        }
        /// <p>The custom MAIL FROM domain that you want the verified identity to use. The MAIL FROM
        /// domain must 1) be a subdomain of the verified identity, 2) not be used in a "From"
        /// address if the MAIL FROM domain is the destination of email feedback forwarding (for
        /// more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/mail-from.html">Amazon SES Developer Guide</a>), and
        /// 3) not be used to receive emails. A value of <code>null</code> disables the custom MAIL
        /// FROM setting for the identity.</p>
        pub fn mail_from_domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.mail_from_domain(input);
            self
        }
        pub fn set_mail_from_domain(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_mail_from_domain(input);
            self
        }
        /// <p>The action that you want Amazon SES to take if it cannot successfully read the required MX
        /// record when you send an email. If you choose <code>UseDefaultValue</code>, Amazon SES will
        /// use amazonses.com (or a subdomain of that) as the MAIL FROM domain. If you choose
        /// <code>RejectMessage</code>, Amazon SES will return a
        /// <code>MailFromDomainNotVerified</code> error and not send the email.</p>
        /// <p>The action specified in <code>BehaviorOnMXFailure</code> is taken when the custom MAIL
        /// FROM domain setup is in the <code>Pending</code>, <code>Failed</code>, and
        /// <code>TemporaryFailure</code> states.</p>
        pub fn behavior_on_mx_failure(mut self, input: crate::model::BehaviorOnMxFailure) -> Self {
            self.inner = self.inner.behavior_on_mx_failure(input);
            self
        }
        pub fn set_behavior_on_mx_failure(
            mut self,
            input: std::option::Option<crate::model::BehaviorOnMxFailure>,
        ) -> Self {
            self.inner = self.inner.set_behavior_on_mx_failure(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetIdentityNotificationTopic<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_identity_notification_topic_input::Builder,
    }
    impl<C> SetIdentityNotificationTopic<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetIdentityNotificationTopicOutput,
            smithy_http::result::SdkError<crate::error::SetIdentityNotificationTopicError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identity (email address or domain) that you want to set the Amazon SNS topic
        /// for.</p>
        /// <important>
        /// <p>You can only specify a verified identity for this parameter.</p>
        /// </important>
        /// <p>You can specify an identity by using its name or by using its Amazon Resource Name
        /// (ARN). The following examples are all valid identities: <code>sender@example.com</code>,
        /// <code>example.com</code>,
        /// <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>.</p>
        pub fn identity(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.identity(input);
            self
        }
        pub fn set_identity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_identity(input);
            self
        }
        /// <p>The type of notifications that will be published to the specified Amazon SNS topic.</p>
        pub fn notification_type(mut self, input: crate::model::NotificationType) -> Self {
            self.inner = self.inner.notification_type(input);
            self
        }
        pub fn set_notification_type(
            mut self,
            input: std::option::Option<crate::model::NotificationType>,
        ) -> Self {
            self.inner = self.inner.set_notification_type(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic. If the parameter is omitted from
        /// the request or a null value is passed, <code>SnsTopic</code> is cleared and publishing
        /// is disabled.</p>
        pub fn sns_topic(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sns_topic(input);
            self
        }
        pub fn set_sns_topic(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_sns_topic(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetReceiptRulePosition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_receipt_rule_position_input::Builder,
    }
    impl<C> SetReceiptRulePosition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetReceiptRulePositionOutput,
            smithy_http::result::SdkError<crate::error::SetReceiptRulePositionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the receipt rule set that contains the receipt rule to reposition.</p>
        pub fn rule_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_set_name(input);
            self
        }
        pub fn set_rule_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rule_set_name(input);
            self
        }
        /// <p>The name of the receipt rule to reposition.</p>
        pub fn rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_name(input);
            self
        }
        pub fn set_rule_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_rule_name(input);
            self
        }
        /// <p>The name of the receipt rule after which to place the specified receipt rule.</p>
        pub fn after(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.after(input);
            self
        }
        pub fn set_after(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_after(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TestRenderTemplate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::test_render_template_input::Builder,
    }
    impl<C> TestRenderTemplate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TestRenderTemplateOutput,
            smithy_http::result::SdkError<crate::error::TestRenderTemplateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the template that you want to render.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_name(input);
            self
        }
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_name(input);
            self
        }
        /// <p>A list of replacement values to apply to the template. This parameter is a JSON
        /// object, typically consisting of key-value pairs in which the keys correspond to
        /// replacement tags in the email template.</p>
        pub fn template_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_data(input);
            self
        }
        pub fn set_template_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_data(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateAccountSendingEnabled<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_account_sending_enabled_input::Builder,
    }
    impl<C> UpdateAccountSendingEnabled<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateAccountSendingEnabledOutput,
            smithy_http::result::SdkError<crate::error::UpdateAccountSendingEnabledError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Describes whether email sending is enabled or disabled for your Amazon SES account in the
        /// current AWS Region.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.enabled(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_enabled(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateConfigurationSetEventDestination<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_configuration_set_event_destination_input::Builder,
    }
    impl<C> UpdateConfigurationSetEventDestination<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateConfigurationSetEventDestinationOutput,
            smithy_http::result::SdkError<
                crate::error::UpdateConfigurationSetEventDestinationError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the configuration set that contains the event destination that you want to
        /// update.</p>
        pub fn configuration_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.configuration_set_name(input);
            self
        }
        pub fn set_configuration_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_configuration_set_name(input);
            self
        }
        /// <p>The event destination object that you want to apply to the specified configuration
        /// set.</p>
        pub fn event_destination(mut self, input: crate::model::EventDestination) -> Self {
            self.inner = self.inner.event_destination(input);
            self
        }
        pub fn set_event_destination(
            mut self,
            input: std::option::Option<crate::model::EventDestination>,
        ) -> Self {
            self.inner = self.inner.set_event_destination(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateConfigurationSetReputationMetricsEnabled<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_configuration_set_reputation_metrics_enabled_input::Builder,
    }
    impl<C> UpdateConfigurationSetReputationMetricsEnabled<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateConfigurationSetReputationMetricsEnabledOutput,
            smithy_http::result::SdkError<
                crate::error::UpdateConfigurationSetReputationMetricsEnabledError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the configuration set that you want to update.</p>
        pub fn configuration_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.configuration_set_name(input);
            self
        }
        pub fn set_configuration_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_configuration_set_name(input);
            self
        }
        /// <p>Describes whether or not Amazon SES will publish reputation metrics for the configuration
        /// set, such as bounce and complaint rates, to Amazon CloudWatch.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.enabled(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_enabled(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateConfigurationSetSendingEnabled<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_configuration_set_sending_enabled_input::Builder,
    }
    impl<C> UpdateConfigurationSetSendingEnabled<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateConfigurationSetSendingEnabledOutput,
            smithy_http::result::SdkError<crate::error::UpdateConfigurationSetSendingEnabledError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the configuration set that you want to update.</p>
        pub fn configuration_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.configuration_set_name(input);
            self
        }
        pub fn set_configuration_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_configuration_set_name(input);
            self
        }
        /// <p>Describes whether email sending is enabled or disabled for the configuration set.
        /// </p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.enabled(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_enabled(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateConfigurationSetTrackingOptions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_configuration_set_tracking_options_input::Builder,
    }
    impl<C> UpdateConfigurationSetTrackingOptions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateConfigurationSetTrackingOptionsOutput,
            smithy_http::result::SdkError<crate::error::UpdateConfigurationSetTrackingOptionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the configuration set for which you want to update the custom tracking
        /// domain.</p>
        pub fn configuration_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.configuration_set_name(input);
            self
        }
        pub fn set_configuration_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_configuration_set_name(input);
            self
        }
        /// <p>A domain that is used to redirect email recipients to an Amazon SES-operated domain. This
        /// domain captures open and click events generated by Amazon SES emails.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/configure-custom-open-click-domains.html">Configuring
        /// Custom Domains to Handle Open and Click Tracking</a> in the <i>Amazon SES
        /// Developer Guide</i>.</p>
        pub fn tracking_options(mut self, input: crate::model::TrackingOptions) -> Self {
            self.inner = self.inner.tracking_options(input);
            self
        }
        pub fn set_tracking_options(
            mut self,
            input: std::option::Option<crate::model::TrackingOptions>,
        ) -> Self {
            self.inner = self.inner.set_tracking_options(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateCustomVerificationEmailTemplate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_custom_verification_email_template_input::Builder,
    }
    impl<C> UpdateCustomVerificationEmailTemplate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateCustomVerificationEmailTemplateOutput,
            smithy_http::result::SdkError<crate::error::UpdateCustomVerificationEmailTemplateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the custom verification email template that you want to update.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_name(input);
            self
        }
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_name(input);
            self
        }
        /// <p>The email address that the custom verification email is sent from.</p>
        pub fn from_email_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.from_email_address(input);
            self
        }
        pub fn set_from_email_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_from_email_address(input);
            self
        }
        /// <p>The subject line of the custom verification email.</p>
        pub fn template_subject(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_subject(input);
            self
        }
        pub fn set_template_subject(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_subject(input);
            self
        }
        /// <p>The content of the custom verification email. The total size of the email must be less
        /// than 10 MB. The message body may contain HTML, with some limitations. For more
        /// information, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/custom-verification-emails.html#custom-verification-emails-faq">Custom Verification Email Frequently Asked Questions</a> in the <i>Amazon SES
        /// Developer Guide</i>.</p>
        pub fn template_content(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_content(input);
            self
        }
        pub fn set_template_content(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_content(input);
            self
        }
        /// <p>The URL that the recipient of the verification email is sent to if his or her address
        /// is successfully verified.</p>
        pub fn success_redirection_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.success_redirection_url(input);
            self
        }
        pub fn set_success_redirection_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_success_redirection_url(input);
            self
        }
        /// <p>The URL that the recipient of the verification email is sent to if his or her address
        /// is not successfully verified.</p>
        pub fn failure_redirection_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.failure_redirection_url(input);
            self
        }
        pub fn set_failure_redirection_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_failure_redirection_url(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateReceiptRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_receipt_rule_input::Builder,
    }
    impl<C> UpdateReceiptRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateReceiptRuleOutput,
            smithy_http::result::SdkError<crate::error::UpdateReceiptRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the receipt rule set that the receipt rule belongs to.</p>
        pub fn rule_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_set_name(input);
            self
        }
        pub fn set_rule_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rule_set_name(input);
            self
        }
        /// <p>A data structure that contains the updated receipt rule information.</p>
        pub fn rule(mut self, input: crate::model::ReceiptRule) -> Self {
            self.inner = self.inner.rule(input);
            self
        }
        pub fn set_rule(mut self, input: std::option::Option<crate::model::ReceiptRule>) -> Self {
            self.inner = self.inner.set_rule(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateTemplate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_template_input::Builder,
    }
    impl<C> UpdateTemplate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateTemplateOutput,
            smithy_http::result::SdkError<crate::error::UpdateTemplateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The content of the email, composed of a subject line, an HTML part, and a text-only
        /// part.</p>
        pub fn template(mut self, input: crate::model::Template) -> Self {
            self.inner = self.inner.template(input);
            self
        }
        pub fn set_template(mut self, input: std::option::Option<crate::model::Template>) -> Self {
            self.inner = self.inner.set_template(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct VerifyDomainDkim<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::verify_domain_dkim_input::Builder,
    }
    impl<C> VerifyDomainDkim<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::VerifyDomainDkimOutput,
            smithy_http::result::SdkError<crate::error::VerifyDomainDkimError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain to be verified for Easy DKIM signing.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct VerifyDomainIdentity<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::verify_domain_identity_input::Builder,
    }
    impl<C> VerifyDomainIdentity<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::VerifyDomainIdentityOutput,
            smithy_http::result::SdkError<crate::error::VerifyDomainIdentityError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The domain to be verified.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct VerifyEmailAddress<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::verify_email_address_input::Builder,
    }
    impl<C> VerifyEmailAddress<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::VerifyEmailAddressOutput,
            smithy_http::result::SdkError<crate::error::VerifyEmailAddressError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The email address to be verified.</p>
        pub fn email_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.email_address(input);
            self
        }
        pub fn set_email_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_email_address(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct VerifyEmailIdentity<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::verify_email_identity_input::Builder,
    }
    impl<C> VerifyEmailIdentity<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::VerifyEmailIdentityOutput,
            smithy_http::result::SdkError<crate::error::VerifyEmailIdentityError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The email address to be verified.</p>
        pub fn email_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.email_address(input);
            self
        }
        pub fn set_email_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_email_address(input);
            self
        }
    }
}
