// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Creates a receipt rule set by cloning an existing one. All receipt rules and
/// configurations are copied to the new receipt rule set and are completely independent of
/// the source rule set.</p>
/// <p>For information about setting up rule sets, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-receipt-rule-set.html">Amazon SES
/// Developer Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CloneReceiptRuleSet {
    _private: (),
}
impl CloneReceiptRuleSet {
    /// Creates a new builder-style object to manufacture [`CloneReceiptRuleSetInput`](crate::input::CloneReceiptRuleSetInput)
    pub fn builder() -> crate::input::clone_receipt_rule_set_input::Builder {
        crate::input::clone_receipt_rule_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CloneReceiptRuleSet {
    type Output = std::result::Result<
        crate::output::CloneReceiptRuleSetOutput,
        crate::error::CloneReceiptRuleSetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_clone_receipt_rule_set_error(response)
        } else {
            crate::operation_ser::parse_clone_receipt_rule_set_response(response)
        }
    }
}

/// <p>Creates a configuration set.</p>
/// <p>Configuration sets enable you to publish email sending events. For information about
/// using configuration sets, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/monitor-sending-activity.html">Amazon SES Developer
/// Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateConfigurationSet {
    _private: (),
}
impl CreateConfigurationSet {
    /// Creates a new builder-style object to manufacture [`CreateConfigurationSetInput`](crate::input::CreateConfigurationSetInput)
    pub fn builder() -> crate::input::create_configuration_set_input::Builder {
        crate::input::create_configuration_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateConfigurationSet {
    type Output = std::result::Result<
        crate::output::CreateConfigurationSetOutput,
        crate::error::CreateConfigurationSetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_configuration_set_error(response)
        } else {
            crate::operation_ser::parse_create_configuration_set_response(response)
        }
    }
}

/// <p>Creates a configuration set event destination.</p>
/// <note>
/// <p>When you create or update an event destination, you must provide one, and only
/// one, destination. The destination can be CloudWatch, Amazon Kinesis Firehose, or Amazon Simple Notification Service (Amazon SNS).</p>
/// </note>
/// <p>An event destination is the AWS service to which Amazon SES publishes the email sending
/// events associated with a configuration set. For information about using configuration
/// sets, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/monitor-sending-activity.html">Amazon SES Developer
/// Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateConfigurationSetEventDestination {
    _private: (),
}
impl CreateConfigurationSetEventDestination {
    /// Creates a new builder-style object to manufacture [`CreateConfigurationSetEventDestinationInput`](crate::input::CreateConfigurationSetEventDestinationInput)
    pub fn builder() -> crate::input::create_configuration_set_event_destination_input::Builder {
        crate::input::create_configuration_set_event_destination_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateConfigurationSetEventDestination {
    type Output = std::result::Result<
        crate::output::CreateConfigurationSetEventDestinationOutput,
        crate::error::CreateConfigurationSetEventDestinationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_configuration_set_event_destination_error(response)
        } else {
            crate::operation_ser::parse_create_configuration_set_event_destination_response(
                response,
            )
        }
    }
}

/// <p>Creates an association between a configuration set and a custom domain for open and
/// click event tracking. </p>
/// <p>By default, images and links used for tracking open and click events are hosted on
/// domains operated by Amazon SES. You can configure a subdomain of your own to handle these
/// events. For information about using custom domains, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/configure-custom-open-click-domains.html">Amazon SES Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateConfigurationSetTrackingOptions {
    _private: (),
}
impl CreateConfigurationSetTrackingOptions {
    /// Creates a new builder-style object to manufacture [`CreateConfigurationSetTrackingOptionsInput`](crate::input::CreateConfigurationSetTrackingOptionsInput)
    pub fn builder() -> crate::input::create_configuration_set_tracking_options_input::Builder {
        crate::input::create_configuration_set_tracking_options_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateConfigurationSetTrackingOptions {
    type Output = std::result::Result<
        crate::output::CreateConfigurationSetTrackingOptionsOutput,
        crate::error::CreateConfigurationSetTrackingOptionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_configuration_set_tracking_options_error(response)
        } else {
            crate::operation_ser::parse_create_configuration_set_tracking_options_response(response)
        }
    }
}

/// <p>Creates a new custom verification email template.</p>
/// <p>For more information about custom verification email templates, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/custom-verification-emails.html">Using Custom Verification Email Templates</a> in the <i>Amazon SES Developer
/// Guide</i>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateCustomVerificationEmailTemplate {
    _private: (),
}
impl CreateCustomVerificationEmailTemplate {
    /// Creates a new builder-style object to manufacture [`CreateCustomVerificationEmailTemplateInput`](crate::input::CreateCustomVerificationEmailTemplateInput)
    pub fn builder() -> crate::input::create_custom_verification_email_template_input::Builder {
        crate::input::create_custom_verification_email_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateCustomVerificationEmailTemplate {
    type Output = std::result::Result<
        crate::output::CreateCustomVerificationEmailTemplateOutput,
        crate::error::CreateCustomVerificationEmailTemplateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_custom_verification_email_template_error(response)
        } else {
            crate::operation_ser::parse_create_custom_verification_email_template_response(response)
        }
    }
}

/// <p>Creates a new IP address filter.</p>
/// <p>For information about setting up IP address filters, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-ip-filters.html">Amazon SES Developer Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateReceiptFilter {
    _private: (),
}
impl CreateReceiptFilter {
    /// Creates a new builder-style object to manufacture [`CreateReceiptFilterInput`](crate::input::CreateReceiptFilterInput)
    pub fn builder() -> crate::input::create_receipt_filter_input::Builder {
        crate::input::create_receipt_filter_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateReceiptFilter {
    type Output = std::result::Result<
        crate::output::CreateReceiptFilterOutput,
        crate::error::CreateReceiptFilterError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_receipt_filter_error(response)
        } else {
            crate::operation_ser::parse_create_receipt_filter_response(response)
        }
    }
}

/// <p>Creates a receipt rule.</p>
/// <p>For information about setting up receipt rules, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-receipt-rules.html">Amazon SES Developer
/// Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateReceiptRule {
    _private: (),
}
impl CreateReceiptRule {
    /// Creates a new builder-style object to manufacture [`CreateReceiptRuleInput`](crate::input::CreateReceiptRuleInput)
    pub fn builder() -> crate::input::create_receipt_rule_input::Builder {
        crate::input::create_receipt_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateReceiptRule {
    type Output = std::result::Result<
        crate::output::CreateReceiptRuleOutput,
        crate::error::CreateReceiptRuleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_receipt_rule_error(response)
        } else {
            crate::operation_ser::parse_create_receipt_rule_response(response)
        }
    }
}

/// <p>Creates an empty receipt rule set.</p>
/// <p>For information about setting up receipt rule sets, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-receipt-rule-set.html">Amazon SES
/// Developer Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateReceiptRuleSet {
    _private: (),
}
impl CreateReceiptRuleSet {
    /// Creates a new builder-style object to manufacture [`CreateReceiptRuleSetInput`](crate::input::CreateReceiptRuleSetInput)
    pub fn builder() -> crate::input::create_receipt_rule_set_input::Builder {
        crate::input::create_receipt_rule_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateReceiptRuleSet {
    type Output = std::result::Result<
        crate::output::CreateReceiptRuleSetOutput,
        crate::error::CreateReceiptRuleSetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_receipt_rule_set_error(response)
        } else {
            crate::operation_ser::parse_create_receipt_rule_set_response(response)
        }
    }
}

/// <p>Creates an email template. Email templates enable you to send personalized email to
/// one or more destinations in a single API operation. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-personalized-email-api.html">Amazon SES Developer
/// Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateTemplate {
    _private: (),
}
impl CreateTemplate {
    /// Creates a new builder-style object to manufacture [`CreateTemplateInput`](crate::input::CreateTemplateInput)
    pub fn builder() -> crate::input::create_template_input::Builder {
        crate::input::create_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateTemplate {
    type Output =
        std::result::Result<crate::output::CreateTemplateOutput, crate::error::CreateTemplateError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_template_error(response)
        } else {
            crate::operation_ser::parse_create_template_response(response)
        }
    }
}

/// <p>Deletes a configuration set. Configuration sets enable you to publish email sending
/// events. For information about using configuration sets, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/monitor-sending-activity.html">Amazon SES Developer Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteConfigurationSet {
    _private: (),
}
impl DeleteConfigurationSet {
    /// Creates a new builder-style object to manufacture [`DeleteConfigurationSetInput`](crate::input::DeleteConfigurationSetInput)
    pub fn builder() -> crate::input::delete_configuration_set_input::Builder {
        crate::input::delete_configuration_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteConfigurationSet {
    type Output = std::result::Result<
        crate::output::DeleteConfigurationSetOutput,
        crate::error::DeleteConfigurationSetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_configuration_set_error(response)
        } else {
            crate::operation_ser::parse_delete_configuration_set_response(response)
        }
    }
}

/// <p>Deletes a configuration set event destination. Configuration set event destinations
/// are associated with configuration sets, which enable you to publish email sending
/// events. For information about using configuration sets, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/monitor-sending-activity.html">Amazon SES Developer Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteConfigurationSetEventDestination {
    _private: (),
}
impl DeleteConfigurationSetEventDestination {
    /// Creates a new builder-style object to manufacture [`DeleteConfigurationSetEventDestinationInput`](crate::input::DeleteConfigurationSetEventDestinationInput)
    pub fn builder() -> crate::input::delete_configuration_set_event_destination_input::Builder {
        crate::input::delete_configuration_set_event_destination_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteConfigurationSetEventDestination {
    type Output = std::result::Result<
        crate::output::DeleteConfigurationSetEventDestinationOutput,
        crate::error::DeleteConfigurationSetEventDestinationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_configuration_set_event_destination_error(response)
        } else {
            crate::operation_ser::parse_delete_configuration_set_event_destination_response(
                response,
            )
        }
    }
}

/// <p>Deletes an association between a configuration set and a custom domain for open and
/// click event tracking.</p>
/// <p>By default, images and links used for tracking open and click events are hosted on
/// domains operated by Amazon SES. You can configure a subdomain of your own to handle these
/// events. For information about using custom domains, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/configure-custom-open-click-domains.html">Amazon SES Developer Guide</a>.</p>
/// <note>
/// <p>Deleting this kind of association will result in emails sent using the specified
/// configuration set to capture open and click events using the standard,
/// Amazon SES-operated domains.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteConfigurationSetTrackingOptions {
    _private: (),
}
impl DeleteConfigurationSetTrackingOptions {
    /// Creates a new builder-style object to manufacture [`DeleteConfigurationSetTrackingOptionsInput`](crate::input::DeleteConfigurationSetTrackingOptionsInput)
    pub fn builder() -> crate::input::delete_configuration_set_tracking_options_input::Builder {
        crate::input::delete_configuration_set_tracking_options_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteConfigurationSetTrackingOptions {
    type Output = std::result::Result<
        crate::output::DeleteConfigurationSetTrackingOptionsOutput,
        crate::error::DeleteConfigurationSetTrackingOptionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_configuration_set_tracking_options_error(response)
        } else {
            crate::operation_ser::parse_delete_configuration_set_tracking_options_response(response)
        }
    }
}

/// <p>Deletes an existing custom verification email template. </p>
/// <p>For more information about custom verification email templates, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/custom-verification-emails.html">Using Custom Verification Email Templates</a> in the <i>Amazon SES Developer
/// Guide</i>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteCustomVerificationEmailTemplate {
    _private: (),
}
impl DeleteCustomVerificationEmailTemplate {
    /// Creates a new builder-style object to manufacture [`DeleteCustomVerificationEmailTemplateInput`](crate::input::DeleteCustomVerificationEmailTemplateInput)
    pub fn builder() -> crate::input::delete_custom_verification_email_template_input::Builder {
        crate::input::delete_custom_verification_email_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteCustomVerificationEmailTemplate {
    type Output = std::result::Result<
        crate::output::DeleteCustomVerificationEmailTemplateOutput,
        crate::error::DeleteCustomVerificationEmailTemplateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_custom_verification_email_template_error(response)
        } else {
            crate::operation_ser::parse_delete_custom_verification_email_template_response(response)
        }
    }
}

/// <p>Deletes the specified identity (an email address or a domain) from the list of
/// verified identities.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteIdentity {
    _private: (),
}
impl DeleteIdentity {
    /// Creates a new builder-style object to manufacture [`DeleteIdentityInput`](crate::input::DeleteIdentityInput)
    pub fn builder() -> crate::input::delete_identity_input::Builder {
        crate::input::delete_identity_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteIdentity {
    type Output =
        std::result::Result<crate::output::DeleteIdentityOutput, crate::error::DeleteIdentityError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_identity_error(response)
        } else {
            crate::operation_ser::parse_delete_identity_response(response)
        }
    }
}

/// <p>Deletes the specified sending authorization policy for the given identity (an email
/// address or a domain). This API returns successfully even if a policy with the specified
/// name does not exist.</p>
/// <note>
/// <p>This API is for the identity owner only. If you have not verified the identity,
/// this API will return an error.</p>
/// </note>
/// <p>Sending authorization is a feature that enables an identity owner to authorize other
/// senders to use its identities. For information about using sending authorization, see
/// the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
/// Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteIdentityPolicy {
    _private: (),
}
impl DeleteIdentityPolicy {
    /// Creates a new builder-style object to manufacture [`DeleteIdentityPolicyInput`](crate::input::DeleteIdentityPolicyInput)
    pub fn builder() -> crate::input::delete_identity_policy_input::Builder {
        crate::input::delete_identity_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteIdentityPolicy {
    type Output = std::result::Result<
        crate::output::DeleteIdentityPolicyOutput,
        crate::error::DeleteIdentityPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_identity_policy_error(response)
        } else {
            crate::operation_ser::parse_delete_identity_policy_response(response)
        }
    }
}

/// <p>Deletes the specified IP address filter.</p>
/// <p>For information about managing IP address filters, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-managing-ip-filters.html">Amazon SES
/// Developer Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteReceiptFilter {
    _private: (),
}
impl DeleteReceiptFilter {
    /// Creates a new builder-style object to manufacture [`DeleteReceiptFilterInput`](crate::input::DeleteReceiptFilterInput)
    pub fn builder() -> crate::input::delete_receipt_filter_input::Builder {
        crate::input::delete_receipt_filter_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteReceiptFilter {
    type Output = std::result::Result<
        crate::output::DeleteReceiptFilterOutput,
        crate::error::DeleteReceiptFilterError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_receipt_filter_error(response)
        } else {
            crate::operation_ser::parse_delete_receipt_filter_response(response)
        }
    }
}

/// <p>Deletes the specified receipt rule.</p>
/// <p>For information about managing receipt rules, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-managing-receipt-rules.html">Amazon SES
/// Developer Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteReceiptRule {
    _private: (),
}
impl DeleteReceiptRule {
    /// Creates a new builder-style object to manufacture [`DeleteReceiptRuleInput`](crate::input::DeleteReceiptRuleInput)
    pub fn builder() -> crate::input::delete_receipt_rule_input::Builder {
        crate::input::delete_receipt_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteReceiptRule {
    type Output = std::result::Result<
        crate::output::DeleteReceiptRuleOutput,
        crate::error::DeleteReceiptRuleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_receipt_rule_error(response)
        } else {
            crate::operation_ser::parse_delete_receipt_rule_response(response)
        }
    }
}

/// <p>Deletes the specified receipt rule set and all of the receipt rules it
/// contains.</p>
/// <note>
/// <p>The currently active rule set cannot be deleted.</p>
/// </note>
/// <p>For information about managing receipt rule sets, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-managing-receipt-rule-sets.html">Amazon SES Developer Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteReceiptRuleSet {
    _private: (),
}
impl DeleteReceiptRuleSet {
    /// Creates a new builder-style object to manufacture [`DeleteReceiptRuleSetInput`](crate::input::DeleteReceiptRuleSetInput)
    pub fn builder() -> crate::input::delete_receipt_rule_set_input::Builder {
        crate::input::delete_receipt_rule_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteReceiptRuleSet {
    type Output = std::result::Result<
        crate::output::DeleteReceiptRuleSetOutput,
        crate::error::DeleteReceiptRuleSetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_receipt_rule_set_error(response)
        } else {
            crate::operation_ser::parse_delete_receipt_rule_set_response(response)
        }
    }
}

/// <p>Deletes an email template.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteTemplate {
    _private: (),
}
impl DeleteTemplate {
    /// Creates a new builder-style object to manufacture [`DeleteTemplateInput`](crate::input::DeleteTemplateInput)
    pub fn builder() -> crate::input::delete_template_input::Builder {
        crate::input::delete_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteTemplate {
    type Output =
        std::result::Result<crate::output::DeleteTemplateOutput, crate::error::DeleteTemplateError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_template_error(response)
        } else {
            crate::operation_ser::parse_delete_template_response(response)
        }
    }
}

/// <p>Deprecated. Use the <code>DeleteIdentity</code> operation to delete email addresses
/// and domains.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteVerifiedEmailAddress {
    _private: (),
}
impl DeleteVerifiedEmailAddress {
    /// Creates a new builder-style object to manufacture [`DeleteVerifiedEmailAddressInput`](crate::input::DeleteVerifiedEmailAddressInput)
    pub fn builder() -> crate::input::delete_verified_email_address_input::Builder {
        crate::input::delete_verified_email_address_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteVerifiedEmailAddress {
    type Output = std::result::Result<
        crate::output::DeleteVerifiedEmailAddressOutput,
        crate::error::DeleteVerifiedEmailAddressError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_verified_email_address_error(response)
        } else {
            crate::operation_ser::parse_delete_verified_email_address_response(response)
        }
    }
}

/// <p>Returns the metadata and receipt rules for the receipt rule set that is currently
/// active.</p>
/// <p>For information about setting up receipt rule sets, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-receipt-rule-set.html">Amazon SES
/// Developer Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeActiveReceiptRuleSet {
    _private: (),
}
impl DescribeActiveReceiptRuleSet {
    /// Creates a new builder-style object to manufacture [`DescribeActiveReceiptRuleSetInput`](crate::input::DescribeActiveReceiptRuleSetInput)
    pub fn builder() -> crate::input::describe_active_receipt_rule_set_input::Builder {
        crate::input::describe_active_receipt_rule_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeActiveReceiptRuleSet {
    type Output = std::result::Result<
        crate::output::DescribeActiveReceiptRuleSetOutput,
        crate::error::DescribeActiveReceiptRuleSetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_active_receipt_rule_set_error(response)
        } else {
            crate::operation_ser::parse_describe_active_receipt_rule_set_response(response)
        }
    }
}

/// <p>Returns the details of the specified configuration set. For information about using
/// configuration sets, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/monitor-sending-activity.html">Amazon SES Developer
/// Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeConfigurationSet {
    _private: (),
}
impl DescribeConfigurationSet {
    /// Creates a new builder-style object to manufacture [`DescribeConfigurationSetInput`](crate::input::DescribeConfigurationSetInput)
    pub fn builder() -> crate::input::describe_configuration_set_input::Builder {
        crate::input::describe_configuration_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeConfigurationSet {
    type Output = std::result::Result<
        crate::output::DescribeConfigurationSetOutput,
        crate::error::DescribeConfigurationSetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_configuration_set_error(response)
        } else {
            crate::operation_ser::parse_describe_configuration_set_response(response)
        }
    }
}

/// <p>Returns the details of the specified receipt rule.</p>
/// <p>For information about setting up receipt rules, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-receipt-rules.html">Amazon SES Developer
/// Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeReceiptRule {
    _private: (),
}
impl DescribeReceiptRule {
    /// Creates a new builder-style object to manufacture [`DescribeReceiptRuleInput`](crate::input::DescribeReceiptRuleInput)
    pub fn builder() -> crate::input::describe_receipt_rule_input::Builder {
        crate::input::describe_receipt_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeReceiptRule {
    type Output = std::result::Result<
        crate::output::DescribeReceiptRuleOutput,
        crate::error::DescribeReceiptRuleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_receipt_rule_error(response)
        } else {
            crate::operation_ser::parse_describe_receipt_rule_response(response)
        }
    }
}

/// <p>Returns the details of the specified receipt rule set.</p>
/// <p>For information about managing receipt rule sets, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-managing-receipt-rule-sets.html">Amazon SES Developer Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeReceiptRuleSet {
    _private: (),
}
impl DescribeReceiptRuleSet {
    /// Creates a new builder-style object to manufacture [`DescribeReceiptRuleSetInput`](crate::input::DescribeReceiptRuleSetInput)
    pub fn builder() -> crate::input::describe_receipt_rule_set_input::Builder {
        crate::input::describe_receipt_rule_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeReceiptRuleSet {
    type Output = std::result::Result<
        crate::output::DescribeReceiptRuleSetOutput,
        crate::error::DescribeReceiptRuleSetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_receipt_rule_set_error(response)
        } else {
            crate::operation_ser::parse_describe_receipt_rule_set_response(response)
        }
    }
}

/// <p>Returns the email sending status of the Amazon SES account for the current region.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetAccountSendingEnabled {
    _private: (),
}
impl GetAccountSendingEnabled {
    /// Creates a new builder-style object to manufacture [`GetAccountSendingEnabledInput`](crate::input::GetAccountSendingEnabledInput)
    pub fn builder() -> crate::input::get_account_sending_enabled_input::Builder {
        crate::input::get_account_sending_enabled_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetAccountSendingEnabled {
    type Output = std::result::Result<
        crate::output::GetAccountSendingEnabledOutput,
        crate::error::GetAccountSendingEnabledError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_account_sending_enabled_error(response)
        } else {
            crate::operation_ser::parse_get_account_sending_enabled_response(response)
        }
    }
}

/// <p>Returns the custom email verification template for the template name you
/// specify.</p>
/// <p>For more information about custom verification email templates, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/custom-verification-emails.html">Using Custom Verification Email Templates</a> in the <i>Amazon SES Developer
/// Guide</i>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetCustomVerificationEmailTemplate {
    _private: (),
}
impl GetCustomVerificationEmailTemplate {
    /// Creates a new builder-style object to manufacture [`GetCustomVerificationEmailTemplateInput`](crate::input::GetCustomVerificationEmailTemplateInput)
    pub fn builder() -> crate::input::get_custom_verification_email_template_input::Builder {
        crate::input::get_custom_verification_email_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetCustomVerificationEmailTemplate {
    type Output = std::result::Result<
        crate::output::GetCustomVerificationEmailTemplateOutput,
        crate::error::GetCustomVerificationEmailTemplateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_custom_verification_email_template_error(response)
        } else {
            crate::operation_ser::parse_get_custom_verification_email_template_response(response)
        }
    }
}

/// <p>Returns the current status of Easy DKIM signing for an entity. For domain name
/// identities, this operation also returns the DKIM tokens that are required for Easy DKIM
/// signing, and whether Amazon SES has successfully verified that these tokens have been
/// published.</p>
/// <p>This operation takes a list of identities as input and returns the following
/// information for each:</p>
/// <ul>
/// <li>
/// <p>Whether Easy DKIM signing is enabled or disabled.</p>
/// </li>
/// <li>
/// <p>A set of DKIM tokens that represent the identity. If the identity is an email
/// address, the tokens represent the domain of that address.</p>
/// </li>
/// <li>
/// <p>Whether Amazon SES has successfully verified the DKIM tokens published in the
/// domain's DNS. This information is only returned for domain name identities, not
/// for email addresses.</p>
/// </li>
/// </ul>
/// <p>This operation is throttled at one request per second and can only get DKIM attributes
/// for up to 100 identities at a time.</p>
/// <p>For more information about creating DNS records using DKIM tokens, go to the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/easy-dkim-dns-records.html">Amazon SES Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetIdentityDkimAttributes {
    _private: (),
}
impl GetIdentityDkimAttributes {
    /// Creates a new builder-style object to manufacture [`GetIdentityDkimAttributesInput`](crate::input::GetIdentityDkimAttributesInput)
    pub fn builder() -> crate::input::get_identity_dkim_attributes_input::Builder {
        crate::input::get_identity_dkim_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetIdentityDkimAttributes {
    type Output = std::result::Result<
        crate::output::GetIdentityDkimAttributesOutput,
        crate::error::GetIdentityDkimAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_identity_dkim_attributes_error(response)
        } else {
            crate::operation_ser::parse_get_identity_dkim_attributes_response(response)
        }
    }
}

/// <p>Returns the custom MAIL FROM attributes for a list of identities (email addresses :
/// domains).</p>
/// <p>This operation is throttled at one request per second and can only get custom MAIL
/// FROM attributes for up to 100 identities at a time.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetIdentityMailFromDomainAttributes {
    _private: (),
}
impl GetIdentityMailFromDomainAttributes {
    /// Creates a new builder-style object to manufacture [`GetIdentityMailFromDomainAttributesInput`](crate::input::GetIdentityMailFromDomainAttributesInput)
    pub fn builder() -> crate::input::get_identity_mail_from_domain_attributes_input::Builder {
        crate::input::get_identity_mail_from_domain_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetIdentityMailFromDomainAttributes {
    type Output = std::result::Result<
        crate::output::GetIdentityMailFromDomainAttributesOutput,
        crate::error::GetIdentityMailFromDomainAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_identity_mail_from_domain_attributes_error(response)
        } else {
            crate::operation_ser::parse_get_identity_mail_from_domain_attributes_response(response)
        }
    }
}

/// <p>Given a list of verified identities (email addresses and/or domains), returns a
/// structure describing identity notification attributes.</p>
/// <p>This operation is throttled at one request per second and can only get notification
/// attributes for up to 100 identities at a time.</p>
/// <p>For more information about using notifications with Amazon SES, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/notifications.html">Amazon SES
/// Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetIdentityNotificationAttributes {
    _private: (),
}
impl GetIdentityNotificationAttributes {
    /// Creates a new builder-style object to manufacture [`GetIdentityNotificationAttributesInput`](crate::input::GetIdentityNotificationAttributesInput)
    pub fn builder() -> crate::input::get_identity_notification_attributes_input::Builder {
        crate::input::get_identity_notification_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetIdentityNotificationAttributes {
    type Output = std::result::Result<
        crate::output::GetIdentityNotificationAttributesOutput,
        crate::error::GetIdentityNotificationAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_identity_notification_attributes_error(response)
        } else {
            crate::operation_ser::parse_get_identity_notification_attributes_response(response)
        }
    }
}

/// <p>Returns the requested sending authorization policies for the given identity (an email
/// address or a domain). The policies are returned as a map of policy names to policy
/// contents. You can retrieve a maximum of 20 policies at a time.</p>
/// <note>
/// <p>This API is for the identity owner only. If you have not verified the identity,
/// this API will return an error.</p>
/// </note>
/// <p>Sending authorization is a feature that enables an identity owner to authorize other
/// senders to use its identities. For information about using sending authorization, see
/// the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
/// Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetIdentityPolicies {
    _private: (),
}
impl GetIdentityPolicies {
    /// Creates a new builder-style object to manufacture [`GetIdentityPoliciesInput`](crate::input::GetIdentityPoliciesInput)
    pub fn builder() -> crate::input::get_identity_policies_input::Builder {
        crate::input::get_identity_policies_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetIdentityPolicies {
    type Output = std::result::Result<
        crate::output::GetIdentityPoliciesOutput,
        crate::error::GetIdentityPoliciesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_identity_policies_error(response)
        } else {
            crate::operation_ser::parse_get_identity_policies_response(response)
        }
    }
}

/// <p>Given a list of identities (email addresses and/or domains), returns the verification
/// status and (for domain identities) the verification token for each identity.</p>
/// <p>The verification status of an email address is "Pending" until the email address owner
/// clicks the link within the verification email that Amazon SES sent to that address. If the
/// email address owner clicks the link within 24 hours, the verification status of the
/// email address changes to "Success". If the link is not clicked within 24 hours, the
/// verification status changes to "Failed." In that case, if you still want to verify the
/// email address, you must restart the verification process from the beginning.</p>
/// <p>For domain identities, the domain's verification status is "Pending" as Amazon SES searches
/// for the required TXT record in the DNS settings of the domain. When Amazon SES detects the
/// record, the domain's verification status changes to "Success". If Amazon SES is unable to
/// detect the record within 72 hours, the domain's verification status changes to "Failed."
/// In that case, if you still want to verify the domain, you must restart the verification
/// process from the beginning.</p>
/// <p>This operation is throttled at one request per second and can only get verification
/// attributes for up to 100 identities at a time.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetIdentityVerificationAttributes {
    _private: (),
}
impl GetIdentityVerificationAttributes {
    /// Creates a new builder-style object to manufacture [`GetIdentityVerificationAttributesInput`](crate::input::GetIdentityVerificationAttributesInput)
    pub fn builder() -> crate::input::get_identity_verification_attributes_input::Builder {
        crate::input::get_identity_verification_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetIdentityVerificationAttributes {
    type Output = std::result::Result<
        crate::output::GetIdentityVerificationAttributesOutput,
        crate::error::GetIdentityVerificationAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_identity_verification_attributes_error(response)
        } else {
            crate::operation_ser::parse_get_identity_verification_attributes_response(response)
        }
    }
}

/// <p>Provides the sending limits for the Amazon SES account. </p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetSendQuota {
    _private: (),
}
impl GetSendQuota {
    /// Creates a new builder-style object to manufacture [`GetSendQuotaInput`](crate::input::GetSendQuotaInput)
    pub fn builder() -> crate::input::get_send_quota_input::Builder {
        crate::input::get_send_quota_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetSendQuota {
    type Output =
        std::result::Result<crate::output::GetSendQuotaOutput, crate::error::GetSendQuotaError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_send_quota_error(response)
        } else {
            crate::operation_ser::parse_get_send_quota_response(response)
        }
    }
}

/// <p>Provides sending statistics for the current AWS Region. The result is a list of data
/// points, representing the last two weeks of sending activity. Each data point in the list
/// contains statistics for a 15-minute period of time.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetSendStatistics {
    _private: (),
}
impl GetSendStatistics {
    /// Creates a new builder-style object to manufacture [`GetSendStatisticsInput`](crate::input::GetSendStatisticsInput)
    pub fn builder() -> crate::input::get_send_statistics_input::Builder {
        crate::input::get_send_statistics_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetSendStatistics {
    type Output = std::result::Result<
        crate::output::GetSendStatisticsOutput,
        crate::error::GetSendStatisticsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_send_statistics_error(response)
        } else {
            crate::operation_ser::parse_get_send_statistics_response(response)
        }
    }
}

/// <p>Displays the template object (which includes the Subject line, HTML part and text
/// part) for the template you specify.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetTemplate {
    _private: (),
}
impl GetTemplate {
    /// Creates a new builder-style object to manufacture [`GetTemplateInput`](crate::input::GetTemplateInput)
    pub fn builder() -> crate::input::get_template_input::Builder {
        crate::input::get_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetTemplate {
    type Output =
        std::result::Result<crate::output::GetTemplateOutput, crate::error::GetTemplateError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_template_error(response)
        } else {
            crate::operation_ser::parse_get_template_response(response)
        }
    }
}

/// <p>Provides a list of the configuration sets associated with your Amazon SES account in the
/// current AWS Region. For information about using configuration sets, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/monitor-sending-activity.html">Monitoring Your Amazon SES Sending Activity</a> in the <i>Amazon SES Developer
/// Guide.</i>
/// </p>
/// <p>You can execute this operation no more than once per second. This operation will
/// return up to 1,000 configuration sets each time it is run. If your Amazon SES account has
/// more than 1,000 configuration sets, this operation will also return a NextToken element.
/// You can then execute the <code>ListConfigurationSets</code> operation again, passing the
/// <code>NextToken</code> parameter and the value of the NextToken element to retrieve
/// additional results.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListConfigurationSets {
    _private: (),
}
impl ListConfigurationSets {
    /// Creates a new builder-style object to manufacture [`ListConfigurationSetsInput`](crate::input::ListConfigurationSetsInput)
    pub fn builder() -> crate::input::list_configuration_sets_input::Builder {
        crate::input::list_configuration_sets_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListConfigurationSets {
    type Output = std::result::Result<
        crate::output::ListConfigurationSetsOutput,
        crate::error::ListConfigurationSetsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_configuration_sets_error(response)
        } else {
            crate::operation_ser::parse_list_configuration_sets_response(response)
        }
    }
}

/// <p>Lists the existing custom verification email templates for your account in the current
/// AWS Region.</p>
/// <p>For more information about custom verification email templates, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/custom-verification-emails.html">Using Custom Verification Email Templates</a> in the <i>Amazon SES Developer
/// Guide</i>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListCustomVerificationEmailTemplates {
    _private: (),
}
impl ListCustomVerificationEmailTemplates {
    /// Creates a new builder-style object to manufacture [`ListCustomVerificationEmailTemplatesInput`](crate::input::ListCustomVerificationEmailTemplatesInput)
    pub fn builder() -> crate::input::list_custom_verification_email_templates_input::Builder {
        crate::input::list_custom_verification_email_templates_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListCustomVerificationEmailTemplates {
    type Output = std::result::Result<
        crate::output::ListCustomVerificationEmailTemplatesOutput,
        crate::error::ListCustomVerificationEmailTemplatesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_custom_verification_email_templates_error(response)
        } else {
            crate::operation_ser::parse_list_custom_verification_email_templates_response(response)
        }
    }
}

/// <p>Returns a list containing all of the identities (email addresses and domains) for your
/// AWS account in the current AWS Region, regardless of verification status.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListIdentities {
    _private: (),
}
impl ListIdentities {
    /// Creates a new builder-style object to manufacture [`ListIdentitiesInput`](crate::input::ListIdentitiesInput)
    pub fn builder() -> crate::input::list_identities_input::Builder {
        crate::input::list_identities_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListIdentities {
    type Output =
        std::result::Result<crate::output::ListIdentitiesOutput, crate::error::ListIdentitiesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_identities_error(response)
        } else {
            crate::operation_ser::parse_list_identities_response(response)
        }
    }
}

/// <p>Returns a list of sending authorization policies that are attached to the given
/// identity (an email address or a domain). This API returns only a list. If you want the
/// actual policy content, you can use <code>GetIdentityPolicies</code>.</p>
/// <note>
/// <p>This API is for the identity owner only. If you have not verified the identity,
/// this API will return an error.</p>
/// </note>
/// <p>Sending authorization is a feature that enables an identity owner to authorize other
/// senders to use its identities. For information about using sending authorization, see
/// the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
/// Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListIdentityPolicies {
    _private: (),
}
impl ListIdentityPolicies {
    /// Creates a new builder-style object to manufacture [`ListIdentityPoliciesInput`](crate::input::ListIdentityPoliciesInput)
    pub fn builder() -> crate::input::list_identity_policies_input::Builder {
        crate::input::list_identity_policies_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListIdentityPolicies {
    type Output = std::result::Result<
        crate::output::ListIdentityPoliciesOutput,
        crate::error::ListIdentityPoliciesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_identity_policies_error(response)
        } else {
            crate::operation_ser::parse_list_identity_policies_response(response)
        }
    }
}

/// <p>Lists the IP address filters associated with your AWS account in the current AWS
/// Region.</p>
/// <p>For information about managing IP address filters, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-managing-ip-filters.html">Amazon SES
/// Developer Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListReceiptFilters {
    _private: (),
}
impl ListReceiptFilters {
    /// Creates a new builder-style object to manufacture [`ListReceiptFiltersInput`](crate::input::ListReceiptFiltersInput)
    pub fn builder() -> crate::input::list_receipt_filters_input::Builder {
        crate::input::list_receipt_filters_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListReceiptFilters {
    type Output = std::result::Result<
        crate::output::ListReceiptFiltersOutput,
        crate::error::ListReceiptFiltersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_receipt_filters_error(response)
        } else {
            crate::operation_ser::parse_list_receipt_filters_response(response)
        }
    }
}

/// <p>Lists the receipt rule sets that exist under your AWS account in the current AWS
/// Region. If there are additional receipt rule sets to be retrieved, you will receive a
/// <code>NextToken</code> that you can provide to the next call to
/// <code>ListReceiptRuleSets</code> to retrieve the additional entries.</p>
/// <p>For information about managing receipt rule sets, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-managing-receipt-rule-sets.html">Amazon SES Developer Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListReceiptRuleSets {
    _private: (),
}
impl ListReceiptRuleSets {
    /// Creates a new builder-style object to manufacture [`ListReceiptRuleSetsInput`](crate::input::ListReceiptRuleSetsInput)
    pub fn builder() -> crate::input::list_receipt_rule_sets_input::Builder {
        crate::input::list_receipt_rule_sets_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListReceiptRuleSets {
    type Output = std::result::Result<
        crate::output::ListReceiptRuleSetsOutput,
        crate::error::ListReceiptRuleSetsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_receipt_rule_sets_error(response)
        } else {
            crate::operation_ser::parse_list_receipt_rule_sets_response(response)
        }
    }
}

/// <p>Lists the email templates present in your Amazon SES account in the current AWS
/// Region.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTemplates {
    _private: (),
}
impl ListTemplates {
    /// Creates a new builder-style object to manufacture [`ListTemplatesInput`](crate::input::ListTemplatesInput)
    pub fn builder() -> crate::input::list_templates_input::Builder {
        crate::input::list_templates_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTemplates {
    type Output =
        std::result::Result<crate::output::ListTemplatesOutput, crate::error::ListTemplatesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_templates_error(response)
        } else {
            crate::operation_ser::parse_list_templates_response(response)
        }
    }
}

/// <p>Deprecated. Use the <code>ListIdentities</code> operation to list the email addresses
/// and domains associated with your account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListVerifiedEmailAddresses {
    _private: (),
}
impl ListVerifiedEmailAddresses {
    /// Creates a new builder-style object to manufacture [`ListVerifiedEmailAddressesInput`](crate::input::ListVerifiedEmailAddressesInput)
    pub fn builder() -> crate::input::list_verified_email_addresses_input::Builder {
        crate::input::list_verified_email_addresses_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListVerifiedEmailAddresses {
    type Output = std::result::Result<
        crate::output::ListVerifiedEmailAddressesOutput,
        crate::error::ListVerifiedEmailAddressesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_verified_email_addresses_error(response)
        } else {
            crate::operation_ser::parse_list_verified_email_addresses_response(response)
        }
    }
}

/// <p>Adds or updates the delivery options for a configuration set.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutConfigurationSetDeliveryOptions {
    _private: (),
}
impl PutConfigurationSetDeliveryOptions {
    /// Creates a new builder-style object to manufacture [`PutConfigurationSetDeliveryOptionsInput`](crate::input::PutConfigurationSetDeliveryOptionsInput)
    pub fn builder() -> crate::input::put_configuration_set_delivery_options_input::Builder {
        crate::input::put_configuration_set_delivery_options_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutConfigurationSetDeliveryOptions {
    type Output = std::result::Result<
        crate::output::PutConfigurationSetDeliveryOptionsOutput,
        crate::error::PutConfigurationSetDeliveryOptionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_put_configuration_set_delivery_options_error(response)
        } else {
            crate::operation_ser::parse_put_configuration_set_delivery_options_response(response)
        }
    }
}

/// <p>Adds or updates a sending authorization policy for the specified identity (an email
/// address or a domain).</p>
/// <note>
/// <p>This API is for the identity owner only. If you have not verified the identity,
/// this API will return an error.</p>
/// </note>
/// <p>Sending authorization is a feature that enables an identity owner to authorize other
/// senders to use its identities. For information about using sending authorization, see
/// the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
/// Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutIdentityPolicy {
    _private: (),
}
impl PutIdentityPolicy {
    /// Creates a new builder-style object to manufacture [`PutIdentityPolicyInput`](crate::input::PutIdentityPolicyInput)
    pub fn builder() -> crate::input::put_identity_policy_input::Builder {
        crate::input::put_identity_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutIdentityPolicy {
    type Output = std::result::Result<
        crate::output::PutIdentityPolicyOutput,
        crate::error::PutIdentityPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_put_identity_policy_error(response)
        } else {
            crate::operation_ser::parse_put_identity_policy_response(response)
        }
    }
}

/// <p>Reorders the receipt rules within a receipt rule set.</p>
/// <note>
/// <p>All of the rules in the rule set must be represented in this request. That is,
/// this API will return an error if the reorder request doesn't explicitly position all
/// of the rules.</p>
/// </note>
/// <p>For information about managing receipt rule sets, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-managing-receipt-rule-sets.html">Amazon SES Developer Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ReorderReceiptRuleSet {
    _private: (),
}
impl ReorderReceiptRuleSet {
    /// Creates a new builder-style object to manufacture [`ReorderReceiptRuleSetInput`](crate::input::ReorderReceiptRuleSetInput)
    pub fn builder() -> crate::input::reorder_receipt_rule_set_input::Builder {
        crate::input::reorder_receipt_rule_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ReorderReceiptRuleSet {
    type Output = std::result::Result<
        crate::output::ReorderReceiptRuleSetOutput,
        crate::error::ReorderReceiptRuleSetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_reorder_receipt_rule_set_error(response)
        } else {
            crate::operation_ser::parse_reorder_receipt_rule_set_response(response)
        }
    }
}

/// <p>Generates and sends a bounce message to the sender of an email you received through
/// Amazon SES. You can only use this API on an email up to 24 hours after you receive it.</p>
/// <note>
/// <p>You cannot use this API to send generic bounces for mail that was not received by
/// Amazon SES.</p>
/// </note>
/// <p>For information about receiving email through Amazon SES, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email.html">Amazon SES
/// Developer Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SendBounce {
    _private: (),
}
impl SendBounce {
    /// Creates a new builder-style object to manufacture [`SendBounceInput`](crate::input::SendBounceInput)
    pub fn builder() -> crate::input::send_bounce_input::Builder {
        crate::input::send_bounce_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SendBounce {
    type Output =
        std::result::Result<crate::output::SendBounceOutput, crate::error::SendBounceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_send_bounce_error(response)
        } else {
            crate::operation_ser::parse_send_bounce_response(response)
        }
    }
}

/// <p>Composes an email message to multiple destinations. The message body is created using
/// an email template.</p>
/// <p>In order to send email using the <code>SendBulkTemplatedEmail</code> operation, your
/// call to the API must meet the following requirements:</p>
/// <ul>
/// <li>
/// <p>The call must refer to an existing email template. You can create email
/// templates using the <a>CreateTemplate</a> operation.</p>
/// </li>
/// <li>
/// <p>The message must be sent from a verified email address or domain.</p>
/// </li>
/// <li>
/// <p>If your account is still in the Amazon SES sandbox, you may only send to verified
/// addresses or domains, or to email addresses associated with the Amazon SES Mailbox
/// Simulator. For more information, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-addresses-and-domains.html">Verifying
/// Email Addresses and Domains</a> in the <i>Amazon SES Developer
/// Guide.</i>
/// </p>
/// </li>
/// <li>
/// <p>The maximum message size is 10 MB.</p>
/// </li>
/// <li>
/// <p>Each <code>Destination</code> parameter must include at least one recipient
/// email address. The recipient address can be a To: address, a CC: address, or a
/// BCC: address. If a recipient email address is invalid (that is, it is not in the
/// format <i>UserName@[SubDomain.]Domain.TopLevelDomain</i>), the
/// entire message will be rejected, even if the message contains other recipients
/// that are valid.</p>
/// </li>
/// <li>
/// <p>The message may not include more than 50 recipients, across the To:, CC: and
/// BCC: fields. If you need to send an email message to a larger audience, you can
/// divide your recipient list into groups of 50 or fewer, and then call the
/// <code>SendBulkTemplatedEmail</code> operation several times to send the
/// message to each group.</p>
/// </li>
/// <li>
/// <p>The number of destinations you can contact in a single call to the API may be
/// limited by your account's maximum sending rate.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SendBulkTemplatedEmail {
    _private: (),
}
impl SendBulkTemplatedEmail {
    /// Creates a new builder-style object to manufacture [`SendBulkTemplatedEmailInput`](crate::input::SendBulkTemplatedEmailInput)
    pub fn builder() -> crate::input::send_bulk_templated_email_input::Builder {
        crate::input::send_bulk_templated_email_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SendBulkTemplatedEmail {
    type Output = std::result::Result<
        crate::output::SendBulkTemplatedEmailOutput,
        crate::error::SendBulkTemplatedEmailError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_send_bulk_templated_email_error(response)
        } else {
            crate::operation_ser::parse_send_bulk_templated_email_response(response)
        }
    }
}

/// <p>Adds an email address to the list of identities for your Amazon SES account in the current
/// AWS Region and attempts to verify it. As a result of executing this operation, a
/// customized verification email is sent to the specified address.</p>
/// <p>To use this operation, you must first create a custom verification email template. For
/// more information about creating and using custom verification email templates, see
/// <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/custom-verification-emails.html">Using Custom
/// Verification Email Templates</a> in the <i>Amazon SES Developer
/// Guide</i>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SendCustomVerificationEmail {
    _private: (),
}
impl SendCustomVerificationEmail {
    /// Creates a new builder-style object to manufacture [`SendCustomVerificationEmailInput`](crate::input::SendCustomVerificationEmailInput)
    pub fn builder() -> crate::input::send_custom_verification_email_input::Builder {
        crate::input::send_custom_verification_email_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SendCustomVerificationEmail {
    type Output = std::result::Result<
        crate::output::SendCustomVerificationEmailOutput,
        crate::error::SendCustomVerificationEmailError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_send_custom_verification_email_error(response)
        } else {
            crate::operation_ser::parse_send_custom_verification_email_response(response)
        }
    }
}

/// <p>Composes an email message and immediately queues it for sending. In order to send
/// email using the <code>SendEmail</code> operation, your message must meet the following
/// requirements:</p>
/// <ul>
/// <li>
/// <p>The message must be sent from a verified email address or domain. If you
/// attempt to send email using a non-verified address or domain, the operation will
/// result in an "Email address not verified" error. </p>
/// </li>
/// <li>
/// <p>If your account is still in the Amazon SES sandbox, you may only send to verified
/// addresses or domains, or to email addresses associated with the Amazon SES Mailbox
/// Simulator. For more information, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-addresses-and-domains.html">Verifying
/// Email Addresses and Domains</a> in the <i>Amazon SES Developer
/// Guide.</i>
/// </p>
/// </li>
/// <li>
/// <p>The maximum message size is 10 MB.</p>
/// </li>
/// <li>
/// <p>The message must include at least one recipient email address. The recipient
/// address can be a To: address, a CC: address, or a BCC: address. If a recipient
/// email address is invalid (that is, it is not in the format
/// <i>UserName@[SubDomain.]Domain.TopLevelDomain</i>), the entire
/// message will be rejected, even if the message contains other recipients that are
/// valid.</p>
/// </li>
/// <li>
/// <p>The message may not include more than 50 recipients, across the To:, CC: and
/// BCC: fields. If you need to send an email message to a larger audience, you can
/// divide your recipient list into groups of 50 or fewer, and then call the
/// <code>SendEmail</code> operation several times to send the message to each
/// group.</p>
/// </li>
/// </ul>
/// <important>
/// <p>For every message that you send, the total number of recipients (including each
/// recipient in the To:, CC: and BCC: fields) is counted against the maximum number of
/// emails you can send in a 24-hour period (your <i>sending quota</i>).
/// For more information about sending quotas in Amazon SES, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/manage-sending-limits.html">Managing Your Amazon SES
/// Sending Limits</a> in the <i>Amazon SES Developer Guide.</i>
/// </p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SendEmail {
    _private: (),
}
impl SendEmail {
    /// Creates a new builder-style object to manufacture [`SendEmailInput`](crate::input::SendEmailInput)
    pub fn builder() -> crate::input::send_email_input::Builder {
        crate::input::send_email_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SendEmail {
    type Output = std::result::Result<crate::output::SendEmailOutput, crate::error::SendEmailError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_send_email_error(response)
        } else {
            crate::operation_ser::parse_send_email_response(response)
        }
    }
}

/// <p>Composes an email message and immediately queues it for sending.</p>
/// <p>This operation is more flexible than the <code>SendEmail</code> API operation. When
/// you use the <code>SendRawEmail</code> operation, you can specify the headers of the
/// message as well as its content. This flexibility is useful, for example, when you want
/// to send a multipart MIME email (such a message that contains both a text and an HTML
/// version). You can also use this operation to send messages that include
/// attachments.</p>
/// <p>The <code>SendRawEmail</code> operation has the following requirements:</p>
/// <ul>
/// <li>
/// <p>You can only send email from <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-addresses-and-domains.html">verified email addresses or domains</a>. If you try
/// to send email from an address that isn't verified, the operation results in an
/// "Email address not verified" error.</p>
/// </li>
/// <li>
/// <p>If your account is still in the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/request-production-access.html">Amazon SES sandbox</a>, you can only send email to other
/// verified addresses in your account, or to addresses that are associated with the
/// <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/mailbox-simulator.html">Amazon SES mailbox simulator</a>.</p>
/// </li>
/// <li>
/// <p>The maximum message size, including attachments, is 10 MB.</p>
/// </li>
/// <li>
/// <p>Each message has to include at least one recipient address. A recipient
/// address includes any address on the To:, CC:, or BCC: lines.</p>
/// </li>
/// <li>
/// <p>If you send a single message to more than one recipient address, and one of
/// the recipient addresses isn't in a valid format (that is, it's not in the format
/// <i>UserName@[SubDomain.]Domain.TopLevelDomain</i>), Amazon SES
/// rejects the entire message, even if the other addresses are valid.</p>
/// </li>
/// <li>
/// <p>Each message can include up to 50 recipient addresses across the To:, CC:, or
/// BCC: lines. If you need to send a single message to more than 50 recipients, you
/// have to split the list of recipient addresses into groups of less than 50
/// recipients, and send separate messages to each group.</p>
/// </li>
/// <li>
/// <p>Amazon SES allows you to specify 8-bit Content-Transfer-Encoding for MIME message
/// parts. However, if Amazon SES has to modify the contents of your message (for
/// example, if you use open and click tracking), 8-bit content isn't preserved. For
/// this reason, we highly recommend that you encode all content that isn't 7-bit
/// ASCII. For more information, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-raw.html#send-email-mime-encoding">MIME Encoding</a> in the <i>Amazon SES Developer
/// Guide</i>.</p>
/// </li>
/// </ul>
/// <p>Additionally, keep the following considerations in mind when using the
/// <code>SendRawEmail</code> operation:</p>
/// <ul>
/// <li>
/// <p>Although you can customize the message headers when using the
/// <code>SendRawEmail</code> operation, Amazon SES will automatically apply its own
/// <code>Message-ID</code> and <code>Date</code> headers; if you passed these
/// headers when creating the message, they will be overwritten by the values that
/// Amazon SES provides.</p>
/// </li>
/// <li>
/// <p>If you are using sending authorization to send on behalf of another user,
/// <code>SendRawEmail</code> enables you to specify the cross-account identity
/// for the email's Source, From, and Return-Path parameters in one of two ways: you
/// can pass optional parameters <code>SourceArn</code>, <code>FromArn</code>,
/// and/or <code>ReturnPathArn</code> to the API, or you can include the following
/// X-headers in the header of your raw email:</p>
/// <ul>
/// <li>
/// <p>
/// <code>X-SES-SOURCE-ARN</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>X-SES-FROM-ARN</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>X-SES-RETURN-PATH-ARN</code>
/// </p>
/// </li>
/// </ul>
/// <important>
/// <p>Don't include these X-headers in the DKIM signature. Amazon SES removes these
/// before it sends the email.</p>
/// </important>
/// <p>If you only specify the <code>SourceIdentityArn</code> parameter, Amazon SES sets
/// the From and Return-Path addresses to the same identity that you
/// specified.</p>
/// <p>For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Using Sending
/// Authorization with Amazon SES</a> in the <i>Amazon SES Developer
/// Guide.</i>
/// </p>
/// </li>
/// <li>
/// <p>For every message that you send, the total number of recipients (including
/// each recipient in the To:, CC: and BCC: fields) is counted against the maximum
/// number of emails you can send in a 24-hour period (your <i>sending
/// quota</i>). For more information about sending quotas in Amazon SES, see
/// <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/manage-sending-limits.html">Managing Your
/// Amazon SES Sending Limits</a> in the <i>Amazon SES Developer
/// Guide.</i>
/// </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SendRawEmail {
    _private: (),
}
impl SendRawEmail {
    /// Creates a new builder-style object to manufacture [`SendRawEmailInput`](crate::input::SendRawEmailInput)
    pub fn builder() -> crate::input::send_raw_email_input::Builder {
        crate::input::send_raw_email_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SendRawEmail {
    type Output =
        std::result::Result<crate::output::SendRawEmailOutput, crate::error::SendRawEmailError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_send_raw_email_error(response)
        } else {
            crate::operation_ser::parse_send_raw_email_response(response)
        }
    }
}

/// <p>Composes an email message using an email template and immediately queues it for
/// sending.</p>
/// <p>In order to send email using the <code>SendTemplatedEmail</code> operation, your call
/// to the API must meet the following requirements:</p>
/// <ul>
/// <li>
/// <p>The call must refer to an existing email template. You can create email
/// templates using the <a>CreateTemplate</a> operation.</p>
/// </li>
/// <li>
/// <p>The message must be sent from a verified email address or domain.</p>
/// </li>
/// <li>
/// <p>If your account is still in the Amazon SES sandbox, you may only send to verified
/// addresses or domains, or to email addresses associated with the Amazon SES Mailbox
/// Simulator. For more information, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-addresses-and-domains.html">Verifying
/// Email Addresses and Domains</a> in the <i>Amazon SES Developer
/// Guide.</i>
/// </p>
/// </li>
/// <li>
/// <p>The maximum message size is 10 MB.</p>
/// </li>
/// <li>
/// <p>Calls to the <code>SendTemplatedEmail</code> operation may only include one
/// <code>Destination</code> parameter. A destination is a set of recipients who
/// will receive the same version of the email. The <code>Destination</code>
/// parameter can include up to 50 recipients, across the To:, CC: and BCC:
/// fields.</p>
/// </li>
/// <li>
/// <p>The <code>Destination</code> parameter must include at least one recipient
/// email address. The recipient address can be a To: address, a CC: address, or a
/// BCC: address. If a recipient email address is invalid (that is, it is not in the
/// format <i>UserName@[SubDomain.]Domain.TopLevelDomain</i>), the
/// entire message will be rejected, even if the message contains other recipients
/// that are valid.</p>
/// </li>
/// </ul>
/// <important>
/// <p>If your call to the <code>SendTemplatedEmail</code> operation includes all of the
/// required parameters, Amazon SES accepts it and returns a Message ID. However, if Amazon SES
/// can't render the email because the template contains errors, it doesn't send the
/// email. Additionally, because it already accepted the message, Amazon SES doesn't return a
/// message stating that it was unable to send the email.</p>
/// <p>For these reasons, we highly recommend that you set up Amazon SES to send you
/// notifications when Rendering Failure events occur. For more information, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-personalized-email-api.html">Sending
/// Personalized Email Using the Amazon SES API</a> in the <i>Amazon Simple Email Service
/// Developer Guide</i>.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SendTemplatedEmail {
    _private: (),
}
impl SendTemplatedEmail {
    /// Creates a new builder-style object to manufacture [`SendTemplatedEmailInput`](crate::input::SendTemplatedEmailInput)
    pub fn builder() -> crate::input::send_templated_email_input::Builder {
        crate::input::send_templated_email_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SendTemplatedEmail {
    type Output = std::result::Result<
        crate::output::SendTemplatedEmailOutput,
        crate::error::SendTemplatedEmailError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_send_templated_email_error(response)
        } else {
            crate::operation_ser::parse_send_templated_email_response(response)
        }
    }
}

/// <p>Sets the specified receipt rule set as the active receipt rule set.</p>
/// <note>
/// <p>To disable your email-receiving through Amazon SES completely, you can call this API
/// with RuleSetName set to null.</p>
/// </note>
/// <p>For information about managing receipt rule sets, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-managing-receipt-rule-sets.html">Amazon SES Developer Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetActiveReceiptRuleSet {
    _private: (),
}
impl SetActiveReceiptRuleSet {
    /// Creates a new builder-style object to manufacture [`SetActiveReceiptRuleSetInput`](crate::input::SetActiveReceiptRuleSetInput)
    pub fn builder() -> crate::input::set_active_receipt_rule_set_input::Builder {
        crate::input::set_active_receipt_rule_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetActiveReceiptRuleSet {
    type Output = std::result::Result<
        crate::output::SetActiveReceiptRuleSetOutput,
        crate::error::SetActiveReceiptRuleSetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_set_active_receipt_rule_set_error(response)
        } else {
            crate::operation_ser::parse_set_active_receipt_rule_set_response(response)
        }
    }
}

/// <p>Enables or disables Easy DKIM signing of email sent from an identity. If Easy DKIM
/// signing is enabled for a domain, then Amazon SES uses DKIM to sign all email that it sends
/// from addresses on that domain. If Easy DKIM signing is enabled for an email address,
/// then Amazon SES uses DKIM to sign all email it sends from that address.</p>
/// <note>
/// <p>For email addresses (for example, <code>user@example.com</code>), you can only
/// enable DKIM signing if the corresponding domain (in this case,
/// <code>example.com</code>) has been set up to use Easy DKIM.</p>
/// </note>
/// <p>You can enable DKIM signing for an identity at any time after you start the
/// verification process for the identity, even if the verification process isn't complete. </p>
/// <p>You can execute this operation no more than once per second.</p>
/// <p>For more information about Easy DKIM signing, go to the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/easy-dkim.html">Amazon SES Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetIdentityDkimEnabled {
    _private: (),
}
impl SetIdentityDkimEnabled {
    /// Creates a new builder-style object to manufacture [`SetIdentityDkimEnabledInput`](crate::input::SetIdentityDkimEnabledInput)
    pub fn builder() -> crate::input::set_identity_dkim_enabled_input::Builder {
        crate::input::set_identity_dkim_enabled_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetIdentityDkimEnabled {
    type Output = std::result::Result<
        crate::output::SetIdentityDkimEnabledOutput,
        crate::error::SetIdentityDkimEnabledError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_set_identity_dkim_enabled_error(response)
        } else {
            crate::operation_ser::parse_set_identity_dkim_enabled_response(response)
        }
    }
}

/// <p>Given an identity (an email address or a domain), enables or disables whether Amazon SES
/// forwards bounce and complaint notifications as email. Feedback forwarding can only be
/// disabled when Amazon Simple Notification Service (Amazon SNS) topics are specified for both bounces and
/// complaints.</p>
/// <note>
/// <p>Feedback forwarding does not apply to delivery notifications. Delivery
/// notifications are only available through Amazon SNS.</p>
/// </note>
/// <p>You can execute this operation no more than once per second.</p>
/// <p>For more information about using notifications with Amazon SES, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/notifications.html">Amazon SES
/// Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetIdentityFeedbackForwardingEnabled {
    _private: (),
}
impl SetIdentityFeedbackForwardingEnabled {
    /// Creates a new builder-style object to manufacture [`SetIdentityFeedbackForwardingEnabledInput`](crate::input::SetIdentityFeedbackForwardingEnabledInput)
    pub fn builder() -> crate::input::set_identity_feedback_forwarding_enabled_input::Builder {
        crate::input::set_identity_feedback_forwarding_enabled_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetIdentityFeedbackForwardingEnabled {
    type Output = std::result::Result<
        crate::output::SetIdentityFeedbackForwardingEnabledOutput,
        crate::error::SetIdentityFeedbackForwardingEnabledError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_set_identity_feedback_forwarding_enabled_error(response)
        } else {
            crate::operation_ser::parse_set_identity_feedback_forwarding_enabled_response(response)
        }
    }
}

/// <p>Given an identity (an email address or a domain), sets whether Amazon SES includes the
/// original email headers in the Amazon Simple Notification Service (Amazon SNS) notifications of a specified
/// type.</p>
/// <p>You can execute this operation no more than once per second.</p>
/// <p>For more information about using notifications with Amazon SES, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/notifications.html">Amazon SES
/// Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetIdentityHeadersInNotificationsEnabled {
    _private: (),
}
impl SetIdentityHeadersInNotificationsEnabled {
    /// Creates a new builder-style object to manufacture [`SetIdentityHeadersInNotificationsEnabledInput`](crate::input::SetIdentityHeadersInNotificationsEnabledInput)
    pub fn builder() -> crate::input::set_identity_headers_in_notifications_enabled_input::Builder {
        crate::input::set_identity_headers_in_notifications_enabled_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetIdentityHeadersInNotificationsEnabled {
    type Output = std::result::Result<
        crate::output::SetIdentityHeadersInNotificationsEnabledOutput,
        crate::error::SetIdentityHeadersInNotificationsEnabledError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_set_identity_headers_in_notifications_enabled_error(
                response,
            )
        } else {
            crate::operation_ser::parse_set_identity_headers_in_notifications_enabled_response(
                response,
            )
        }
    }
}

/// <p>Enables or disables the custom MAIL FROM domain setup for a verified identity (an
/// email address or a domain).</p>
/// <important>
/// <p>To send emails using the specified MAIL FROM domain, you must add an MX record to
/// your MAIL FROM domain's DNS settings. If you want your emails to pass Sender Policy
/// Framework (SPF) checks, you must also add or update an SPF record. For more
/// information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/mail-from-set.html">Amazon SES Developer
/// Guide</a>.</p>
/// </important>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetIdentityMailFromDomain {
    _private: (),
}
impl SetIdentityMailFromDomain {
    /// Creates a new builder-style object to manufacture [`SetIdentityMailFromDomainInput`](crate::input::SetIdentityMailFromDomainInput)
    pub fn builder() -> crate::input::set_identity_mail_from_domain_input::Builder {
        crate::input::set_identity_mail_from_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetIdentityMailFromDomain {
    type Output = std::result::Result<
        crate::output::SetIdentityMailFromDomainOutput,
        crate::error::SetIdentityMailFromDomainError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_set_identity_mail_from_domain_error(response)
        } else {
            crate::operation_ser::parse_set_identity_mail_from_domain_response(response)
        }
    }
}

/// <p>Sets an Amazon Simple Notification Service (Amazon SNS) topic to use when delivering notifications. When you use
/// this operation, you specify a verified identity, such as an email address or domain.
/// When you send an email that uses the chosen identity in the Source field, Amazon SES sends
/// notifications to the topic you specified. You can send bounce, complaint, or delivery
/// notifications (or any combination of the three) to the Amazon SNS topic that you
/// specify.</p>
/// <p>You can execute this operation no more than once per second.</p>
/// <p>For more information about feedback notification, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/notifications.html">Amazon SES Developer
/// Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetIdentityNotificationTopic {
    _private: (),
}
impl SetIdentityNotificationTopic {
    /// Creates a new builder-style object to manufacture [`SetIdentityNotificationTopicInput`](crate::input::SetIdentityNotificationTopicInput)
    pub fn builder() -> crate::input::set_identity_notification_topic_input::Builder {
        crate::input::set_identity_notification_topic_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetIdentityNotificationTopic {
    type Output = std::result::Result<
        crate::output::SetIdentityNotificationTopicOutput,
        crate::error::SetIdentityNotificationTopicError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_set_identity_notification_topic_error(response)
        } else {
            crate::operation_ser::parse_set_identity_notification_topic_response(response)
        }
    }
}

/// <p>Sets the position of the specified receipt rule in the receipt rule set.</p>
/// <p>For information about managing receipt rules, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-managing-receipt-rules.html">Amazon SES
/// Developer Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetReceiptRulePosition {
    _private: (),
}
impl SetReceiptRulePosition {
    /// Creates a new builder-style object to manufacture [`SetReceiptRulePositionInput`](crate::input::SetReceiptRulePositionInput)
    pub fn builder() -> crate::input::set_receipt_rule_position_input::Builder {
        crate::input::set_receipt_rule_position_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetReceiptRulePosition {
    type Output = std::result::Result<
        crate::output::SetReceiptRulePositionOutput,
        crate::error::SetReceiptRulePositionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_set_receipt_rule_position_error(response)
        } else {
            crate::operation_ser::parse_set_receipt_rule_position_response(response)
        }
    }
}

/// <p>Creates a preview of the MIME content of an email when provided with a template and a
/// set of replacement data.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TestRenderTemplate {
    _private: (),
}
impl TestRenderTemplate {
    /// Creates a new builder-style object to manufacture [`TestRenderTemplateInput`](crate::input::TestRenderTemplateInput)
    pub fn builder() -> crate::input::test_render_template_input::Builder {
        crate::input::test_render_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TestRenderTemplate {
    type Output = std::result::Result<
        crate::output::TestRenderTemplateOutput,
        crate::error::TestRenderTemplateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_test_render_template_error(response)
        } else {
            crate::operation_ser::parse_test_render_template_response(response)
        }
    }
}

/// <p>Enables or disables email sending across your entire Amazon SES account in the current
/// AWS Region. You can use this operation in conjunction with Amazon CloudWatch alarms to
/// temporarily pause email sending across your Amazon SES account in a given AWS Region when
/// reputation metrics (such as your bounce or complaint rates) reach certain
/// thresholds.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateAccountSendingEnabled {
    _private: (),
}
impl UpdateAccountSendingEnabled {
    /// Creates a new builder-style object to manufacture [`UpdateAccountSendingEnabledInput`](crate::input::UpdateAccountSendingEnabledInput)
    pub fn builder() -> crate::input::update_account_sending_enabled_input::Builder {
        crate::input::update_account_sending_enabled_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateAccountSendingEnabled {
    type Output = std::result::Result<
        crate::output::UpdateAccountSendingEnabledOutput,
        crate::error::UpdateAccountSendingEnabledError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_account_sending_enabled_error(response)
        } else {
            crate::operation_ser::parse_update_account_sending_enabled_response(response)
        }
    }
}

/// <p>Updates the event destination of a configuration set. Event destinations are
/// associated with configuration sets, which enable you to publish email sending events to
/// Amazon CloudWatch, Amazon Kinesis Firehose, or Amazon Simple Notification Service (Amazon SNS). For information about using configuration sets,
/// see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/monitor-sending-activity.html">Monitoring Your Amazon SES
/// Sending Activity</a> in the <i>Amazon SES Developer Guide.</i>
/// </p>
/// <note>
/// <p>When you create or update an event destination, you must provide one, and only
/// one, destination. The destination can be Amazon CloudWatch, Amazon Kinesis Firehose, or Amazon Simple Notification Service
/// (Amazon SNS).</p>
/// </note>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateConfigurationSetEventDestination {
    _private: (),
}
impl UpdateConfigurationSetEventDestination {
    /// Creates a new builder-style object to manufacture [`UpdateConfigurationSetEventDestinationInput`](crate::input::UpdateConfigurationSetEventDestinationInput)
    pub fn builder() -> crate::input::update_configuration_set_event_destination_input::Builder {
        crate::input::update_configuration_set_event_destination_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateConfigurationSetEventDestination {
    type Output = std::result::Result<
        crate::output::UpdateConfigurationSetEventDestinationOutput,
        crate::error::UpdateConfigurationSetEventDestinationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_configuration_set_event_destination_error(response)
        } else {
            crate::operation_ser::parse_update_configuration_set_event_destination_response(
                response,
            )
        }
    }
}

/// <p>Enables or disables the publishing of reputation metrics for emails sent using a
/// specific configuration set in a given AWS Region. Reputation metrics include bounce
/// and complaint rates. These metrics are published to Amazon CloudWatch. By using CloudWatch, you can
/// create alarms when bounce or complaint rates exceed certain thresholds.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateConfigurationSetReputationMetricsEnabled {
    _private: (),
}
impl UpdateConfigurationSetReputationMetricsEnabled {
    /// Creates a new builder-style object to manufacture [`UpdateConfigurationSetReputationMetricsEnabledInput`](crate::input::UpdateConfigurationSetReputationMetricsEnabledInput)
    pub fn builder(
    ) -> crate::input::update_configuration_set_reputation_metrics_enabled_input::Builder {
        crate::input::update_configuration_set_reputation_metrics_enabled_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateConfigurationSetReputationMetricsEnabled {
    type Output = std::result::Result<
        crate::output::UpdateConfigurationSetReputationMetricsEnabledOutput,
        crate::error::UpdateConfigurationSetReputationMetricsEnabledError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_configuration_set_reputation_metrics_enabled_error(
                response,
            )
        } else {
            crate::operation_ser::parse_update_configuration_set_reputation_metrics_enabled_response(
                response,
            )
        }
    }
}

/// <p>Enables or disables email sending for messages sent using a specific configuration set
/// in a given AWS Region. You can use this operation in conjunction with Amazon CloudWatch alarms
/// to temporarily pause email sending for a configuration set when the reputation metrics
/// for that configuration set (such as your bounce on complaint rate) exceed certain
/// thresholds.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateConfigurationSetSendingEnabled {
    _private: (),
}
impl UpdateConfigurationSetSendingEnabled {
    /// Creates a new builder-style object to manufacture [`UpdateConfigurationSetSendingEnabledInput`](crate::input::UpdateConfigurationSetSendingEnabledInput)
    pub fn builder() -> crate::input::update_configuration_set_sending_enabled_input::Builder {
        crate::input::update_configuration_set_sending_enabled_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateConfigurationSetSendingEnabled {
    type Output = std::result::Result<
        crate::output::UpdateConfigurationSetSendingEnabledOutput,
        crate::error::UpdateConfigurationSetSendingEnabledError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_configuration_set_sending_enabled_error(response)
        } else {
            crate::operation_ser::parse_update_configuration_set_sending_enabled_response(response)
        }
    }
}

/// <p>Modifies an association between a configuration set and a custom domain for open and
/// click event tracking. </p>
/// <p>By default, images and links used for tracking open and click events are hosted on
/// domains operated by Amazon SES. You can configure a subdomain of your own to handle these
/// events. For information about using custom domains, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/configure-custom-open-click-domains.html">Amazon SES Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateConfigurationSetTrackingOptions {
    _private: (),
}
impl UpdateConfigurationSetTrackingOptions {
    /// Creates a new builder-style object to manufacture [`UpdateConfigurationSetTrackingOptionsInput`](crate::input::UpdateConfigurationSetTrackingOptionsInput)
    pub fn builder() -> crate::input::update_configuration_set_tracking_options_input::Builder {
        crate::input::update_configuration_set_tracking_options_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateConfigurationSetTrackingOptions {
    type Output = std::result::Result<
        crate::output::UpdateConfigurationSetTrackingOptionsOutput,
        crate::error::UpdateConfigurationSetTrackingOptionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_configuration_set_tracking_options_error(response)
        } else {
            crate::operation_ser::parse_update_configuration_set_tracking_options_response(response)
        }
    }
}

/// <p>Updates an existing custom verification email template.</p>
/// <p>For more information about custom verification email templates, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/custom-verification-emails.html">Using Custom Verification Email Templates</a> in the <i>Amazon SES Developer
/// Guide</i>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateCustomVerificationEmailTemplate {
    _private: (),
}
impl UpdateCustomVerificationEmailTemplate {
    /// Creates a new builder-style object to manufacture [`UpdateCustomVerificationEmailTemplateInput`](crate::input::UpdateCustomVerificationEmailTemplateInput)
    pub fn builder() -> crate::input::update_custom_verification_email_template_input::Builder {
        crate::input::update_custom_verification_email_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateCustomVerificationEmailTemplate {
    type Output = std::result::Result<
        crate::output::UpdateCustomVerificationEmailTemplateOutput,
        crate::error::UpdateCustomVerificationEmailTemplateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_custom_verification_email_template_error(response)
        } else {
            crate::operation_ser::parse_update_custom_verification_email_template_response(response)
        }
    }
}

/// <p>Updates a receipt rule.</p>
/// <p>For information about managing receipt rules, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-managing-receipt-rules.html">Amazon SES
/// Developer Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateReceiptRule {
    _private: (),
}
impl UpdateReceiptRule {
    /// Creates a new builder-style object to manufacture [`UpdateReceiptRuleInput`](crate::input::UpdateReceiptRuleInput)
    pub fn builder() -> crate::input::update_receipt_rule_input::Builder {
        crate::input::update_receipt_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateReceiptRule {
    type Output = std::result::Result<
        crate::output::UpdateReceiptRuleOutput,
        crate::error::UpdateReceiptRuleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_receipt_rule_error(response)
        } else {
            crate::operation_ser::parse_update_receipt_rule_response(response)
        }
    }
}

/// <p>Updates an email template. Email templates enable you to send personalized email to
/// one or more destinations in a single API operation. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-personalized-email-api.html">Amazon SES Developer
/// Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateTemplate {
    _private: (),
}
impl UpdateTemplate {
    /// Creates a new builder-style object to manufacture [`UpdateTemplateInput`](crate::input::UpdateTemplateInput)
    pub fn builder() -> crate::input::update_template_input::Builder {
        crate::input::update_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateTemplate {
    type Output =
        std::result::Result<crate::output::UpdateTemplateOutput, crate::error::UpdateTemplateError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_template_error(response)
        } else {
            crate::operation_ser::parse_update_template_response(response)
        }
    }
}

/// <p>Returns a set of DKIM tokens for a domain identity.</p>
/// <important>
/// <p>When you execute the <code>VerifyDomainDkim</code> operation, the domain that you
/// specify is added to the list of identities that are associated with your account.
/// This is true even if you haven't already associated the domain with your account by
/// using the <code>VerifyDomainIdentity</code> operation. However, you can't send email
/// from the domain until you either successfully <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-domains.html">verify it</a> or you
/// successfully <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/easy-dkim.html">set up DKIM for
/// it</a>.</p>
/// </important>
/// <p>You use the tokens that are generated by this operation to create CNAME records. When
/// Amazon SES detects that you've added these records to the DNS configuration for a domain, you
/// can start sending email from that domain. You can start sending email even if you
/// haven't added the TXT record provided by the VerifyDomainIdentity operation to the DNS
/// configuration for your domain. All email that you send from the domain is authenticated
/// using DKIM.</p>
/// <p>To create the CNAME records for DKIM authentication, use the following values:</p>
/// <ul>
/// <li>
/// <p>
/// <b>Name</b>:
/// <i>token</i>._domainkey.<i>example.com</i>
/// </p>
/// </li>
/// <li>
/// <p>
/// <b>Type</b>: CNAME</p>
/// </li>
/// <li>
/// <p>
/// <b>Value</b>:
/// <i>token</i>.dkim.amazonses.com</p>
/// </li>
/// </ul>
/// <p>In the preceding example, replace <i>token</i> with one of the tokens
/// that are generated when you execute this operation. Replace
/// <i>example.com</i> with your domain. Repeat this process for each
/// token that's generated by this operation.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct VerifyDomainDkim {
    _private: (),
}
impl VerifyDomainDkim {
    /// Creates a new builder-style object to manufacture [`VerifyDomainDkimInput`](crate::input::VerifyDomainDkimInput)
    pub fn builder() -> crate::input::verify_domain_dkim_input::Builder {
        crate::input::verify_domain_dkim_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for VerifyDomainDkim {
    type Output = std::result::Result<
        crate::output::VerifyDomainDkimOutput,
        crate::error::VerifyDomainDkimError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_verify_domain_dkim_error(response)
        } else {
            crate::operation_ser::parse_verify_domain_dkim_response(response)
        }
    }
}

/// <p>Adds a domain to the list of identities for your Amazon SES account in the current AWS
/// Region and attempts to verify it. For more information about verifying domains, see
/// <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-addresses-and-domains.html">Verifying Email
/// Addresses and Domains</a> in the <i>Amazon SES Developer
/// Guide.</i>
/// </p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct VerifyDomainIdentity {
    _private: (),
}
impl VerifyDomainIdentity {
    /// Creates a new builder-style object to manufacture [`VerifyDomainIdentityInput`](crate::input::VerifyDomainIdentityInput)
    pub fn builder() -> crate::input::verify_domain_identity_input::Builder {
        crate::input::verify_domain_identity_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for VerifyDomainIdentity {
    type Output = std::result::Result<
        crate::output::VerifyDomainIdentityOutput,
        crate::error::VerifyDomainIdentityError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_verify_domain_identity_error(response)
        } else {
            crate::operation_ser::parse_verify_domain_identity_response(response)
        }
    }
}

/// <p>Deprecated. Use the <code>VerifyEmailIdentity</code> operation to verify a new email
/// address.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct VerifyEmailAddress {
    _private: (),
}
impl VerifyEmailAddress {
    /// Creates a new builder-style object to manufacture [`VerifyEmailAddressInput`](crate::input::VerifyEmailAddressInput)
    pub fn builder() -> crate::input::verify_email_address_input::Builder {
        crate::input::verify_email_address_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for VerifyEmailAddress {
    type Output = std::result::Result<
        crate::output::VerifyEmailAddressOutput,
        crate::error::VerifyEmailAddressError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_verify_email_address_error(response)
        } else {
            crate::operation_ser::parse_verify_email_address_response(response)
        }
    }
}

/// <p>Adds an email address to the list of identities for your Amazon SES account in the current
/// AWS region and attempts to verify it. As a result of executing this operation, a
/// verification email is sent to the specified address.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct VerifyEmailIdentity {
    _private: (),
}
impl VerifyEmailIdentity {
    /// Creates a new builder-style object to manufacture [`VerifyEmailIdentityInput`](crate::input::VerifyEmailIdentityInput)
    pub fn builder() -> crate::input::verify_email_identity_input::Builder {
        crate::input::verify_email_identity_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for VerifyEmailIdentity {
    type Output = std::result::Result<
        crate::output::VerifyEmailIdentityOutput,
        crate::error::VerifyEmailIdentityError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_verify_email_identity_error(response)
        } else {
            crate::operation_ser::parse_verify_email_identity_response(response)
        }
    }
}
