// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub fn serialize_operation_crate_operation_clone_receipt_rule_set(
    input: &crate::input::CloneReceiptRuleSetInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CloneReceiptRuleSet", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_1 = writer.prefix("RuleSetName");
    if let Some(var_2) = &input.rule_set_name {
        scope_1.string(var_2);
    }
    #[allow(unused_mut)]
    let mut scope_3 = writer.prefix("OriginalRuleSetName");
    if let Some(var_4) = &input.original_rule_set_name {
        scope_3.string(var_4);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_configuration_set(
    input: &crate::input::CreateConfigurationSetInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateConfigurationSet", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_5 = writer.prefix("ConfigurationSet");
    if let Some(var_6) = &input.configuration_set {
        crate::query_ser::serialize_structure_crate_model_configuration_set(scope_5, var_6);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_configuration_set_event_destination(
    input: &crate::input::CreateConfigurationSetEventDestinationInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "CreateConfigurationSetEventDestination",
        "2010-12-01",
    );
    #[allow(unused_mut)]
    let mut scope_7 = writer.prefix("ConfigurationSetName");
    if let Some(var_8) = &input.configuration_set_name {
        scope_7.string(var_8);
    }
    #[allow(unused_mut)]
    let mut scope_9 = writer.prefix("EventDestination");
    if let Some(var_10) = &input.event_destination {
        crate::query_ser::serialize_structure_crate_model_event_destination(scope_9, var_10);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_configuration_set_tracking_options(
    input: &crate::input::CreateConfigurationSetTrackingOptionsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "CreateConfigurationSetTrackingOptions",
        "2010-12-01",
    );
    #[allow(unused_mut)]
    let mut scope_11 = writer.prefix("ConfigurationSetName");
    if let Some(var_12) = &input.configuration_set_name {
        scope_11.string(var_12);
    }
    #[allow(unused_mut)]
    let mut scope_13 = writer.prefix("TrackingOptions");
    if let Some(var_14) = &input.tracking_options {
        crate::query_ser::serialize_structure_crate_model_tracking_options(scope_13, var_14);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_custom_verification_email_template(
    input: &crate::input::CreateCustomVerificationEmailTemplateInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "CreateCustomVerificationEmailTemplate",
        "2010-12-01",
    );
    #[allow(unused_mut)]
    let mut scope_15 = writer.prefix("TemplateName");
    if let Some(var_16) = &input.template_name {
        scope_15.string(var_16);
    }
    #[allow(unused_mut)]
    let mut scope_17 = writer.prefix("FromEmailAddress");
    if let Some(var_18) = &input.from_email_address {
        scope_17.string(var_18);
    }
    #[allow(unused_mut)]
    let mut scope_19 = writer.prefix("TemplateSubject");
    if let Some(var_20) = &input.template_subject {
        scope_19.string(var_20);
    }
    #[allow(unused_mut)]
    let mut scope_21 = writer.prefix("TemplateContent");
    if let Some(var_22) = &input.template_content {
        scope_21.string(var_22);
    }
    #[allow(unused_mut)]
    let mut scope_23 = writer.prefix("SuccessRedirectionURL");
    if let Some(var_24) = &input.success_redirection_url {
        scope_23.string(var_24);
    }
    #[allow(unused_mut)]
    let mut scope_25 = writer.prefix("FailureRedirectionURL");
    if let Some(var_26) = &input.failure_redirection_url {
        scope_25.string(var_26);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_receipt_filter(
    input: &crate::input::CreateReceiptFilterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateReceiptFilter", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_27 = writer.prefix("Filter");
    if let Some(var_28) = &input.filter {
        crate::query_ser::serialize_structure_crate_model_receipt_filter(scope_27, var_28);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_receipt_rule(
    input: &crate::input::CreateReceiptRuleInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateReceiptRule", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_29 = writer.prefix("RuleSetName");
    if let Some(var_30) = &input.rule_set_name {
        scope_29.string(var_30);
    }
    #[allow(unused_mut)]
    let mut scope_31 = writer.prefix("After");
    if let Some(var_32) = &input.after {
        scope_31.string(var_32);
    }
    #[allow(unused_mut)]
    let mut scope_33 = writer.prefix("Rule");
    if let Some(var_34) = &input.rule {
        crate::query_ser::serialize_structure_crate_model_receipt_rule(scope_33, var_34);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_receipt_rule_set(
    input: &crate::input::CreateReceiptRuleSetInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateReceiptRuleSet", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_35 = writer.prefix("RuleSetName");
    if let Some(var_36) = &input.rule_set_name {
        scope_35.string(var_36);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_template(
    input: &crate::input::CreateTemplateInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateTemplate", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_37 = writer.prefix("Template");
    if let Some(var_38) = &input.template {
        crate::query_ser::serialize_structure_crate_model_template(scope_37, var_38);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_configuration_set(
    input: &crate::input::DeleteConfigurationSetInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteConfigurationSet", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_39 = writer.prefix("ConfigurationSetName");
    if let Some(var_40) = &input.configuration_set_name {
        scope_39.string(var_40);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_configuration_set_event_destination(
    input: &crate::input::DeleteConfigurationSetEventDestinationInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "DeleteConfigurationSetEventDestination",
        "2010-12-01",
    );
    #[allow(unused_mut)]
    let mut scope_41 = writer.prefix("ConfigurationSetName");
    if let Some(var_42) = &input.configuration_set_name {
        scope_41.string(var_42);
    }
    #[allow(unused_mut)]
    let mut scope_43 = writer.prefix("EventDestinationName");
    if let Some(var_44) = &input.event_destination_name {
        scope_43.string(var_44);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_configuration_set_tracking_options(
    input: &crate::input::DeleteConfigurationSetTrackingOptionsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "DeleteConfigurationSetTrackingOptions",
        "2010-12-01",
    );
    #[allow(unused_mut)]
    let mut scope_45 = writer.prefix("ConfigurationSetName");
    if let Some(var_46) = &input.configuration_set_name {
        scope_45.string(var_46);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_custom_verification_email_template(
    input: &crate::input::DeleteCustomVerificationEmailTemplateInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "DeleteCustomVerificationEmailTemplate",
        "2010-12-01",
    );
    #[allow(unused_mut)]
    let mut scope_47 = writer.prefix("TemplateName");
    if let Some(var_48) = &input.template_name {
        scope_47.string(var_48);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_identity(
    input: &crate::input::DeleteIdentityInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteIdentity", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_49 = writer.prefix("Identity");
    if let Some(var_50) = &input.identity {
        scope_49.string(var_50);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_identity_policy(
    input: &crate::input::DeleteIdentityPolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteIdentityPolicy", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_51 = writer.prefix("Identity");
    if let Some(var_52) = &input.identity {
        scope_51.string(var_52);
    }
    #[allow(unused_mut)]
    let mut scope_53 = writer.prefix("PolicyName");
    if let Some(var_54) = &input.policy_name {
        scope_53.string(var_54);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_receipt_filter(
    input: &crate::input::DeleteReceiptFilterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteReceiptFilter", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_55 = writer.prefix("FilterName");
    if let Some(var_56) = &input.filter_name {
        scope_55.string(var_56);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_receipt_rule(
    input: &crate::input::DeleteReceiptRuleInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteReceiptRule", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_57 = writer.prefix("RuleSetName");
    if let Some(var_58) = &input.rule_set_name {
        scope_57.string(var_58);
    }
    #[allow(unused_mut)]
    let mut scope_59 = writer.prefix("RuleName");
    if let Some(var_60) = &input.rule_name {
        scope_59.string(var_60);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_receipt_rule_set(
    input: &crate::input::DeleteReceiptRuleSetInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteReceiptRuleSet", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_61 = writer.prefix("RuleSetName");
    if let Some(var_62) = &input.rule_set_name {
        scope_61.string(var_62);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_template(
    input: &crate::input::DeleteTemplateInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteTemplate", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_63 = writer.prefix("TemplateName");
    if let Some(var_64) = &input.template_name {
        scope_63.string(var_64);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_verified_email_address(
    input: &crate::input::DeleteVerifiedEmailAddressInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteVerifiedEmailAddress", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_65 = writer.prefix("EmailAddress");
    if let Some(var_66) = &input.email_address {
        scope_65.string(var_66);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_active_receipt_rule_set(
    input: &crate::input::DescribeActiveReceiptRuleSetInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let _ = input;
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeActiveReceiptRuleSet", "2010-12-01");
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_configuration_set(
    input: &crate::input::DescribeConfigurationSetInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeConfigurationSet", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_67 = writer.prefix("ConfigurationSetName");
    if let Some(var_68) = &input.configuration_set_name {
        scope_67.string(var_68);
    }
    #[allow(unused_mut)]
    let mut scope_69 = writer.prefix("ConfigurationSetAttributeNames");
    if let Some(var_70) = &input.configuration_set_attribute_names {
        let mut list_72 = scope_69.start_list(false, None);
        for item_71 in var_70 {
            #[allow(unused_mut)]
            let mut entry_73 = list_72.entry();
            entry_73.string(item_71.as_str());
        }
        list_72.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_receipt_rule(
    input: &crate::input::DescribeReceiptRuleInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DescribeReceiptRule", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_74 = writer.prefix("RuleSetName");
    if let Some(var_75) = &input.rule_set_name {
        scope_74.string(var_75);
    }
    #[allow(unused_mut)]
    let mut scope_76 = writer.prefix("RuleName");
    if let Some(var_77) = &input.rule_name {
        scope_76.string(var_77);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_receipt_rule_set(
    input: &crate::input::DescribeReceiptRuleSetInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeReceiptRuleSet", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_78 = writer.prefix("RuleSetName");
    if let Some(var_79) = &input.rule_set_name {
        scope_78.string(var_79);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_account_sending_enabled(
    input: &crate::input::GetAccountSendingEnabledInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let _ = input;
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "GetAccountSendingEnabled", "2010-12-01");
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_custom_verification_email_template(
    input: &crate::input::GetCustomVerificationEmailTemplateInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "GetCustomVerificationEmailTemplate",
        "2010-12-01",
    );
    #[allow(unused_mut)]
    let mut scope_80 = writer.prefix("TemplateName");
    if let Some(var_81) = &input.template_name {
        scope_80.string(var_81);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_identity_dkim_attributes(
    input: &crate::input::GetIdentityDkimAttributesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "GetIdentityDkimAttributes", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_82 = writer.prefix("Identities");
    if let Some(var_83) = &input.identities {
        let mut list_85 = scope_82.start_list(false, None);
        for item_84 in var_83 {
            #[allow(unused_mut)]
            let mut entry_86 = list_85.entry();
            entry_86.string(item_84);
        }
        list_85.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_identity_mail_from_domain_attributes(
    input: &crate::input::GetIdentityMailFromDomainAttributesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "GetIdentityMailFromDomainAttributes",
        "2010-12-01",
    );
    #[allow(unused_mut)]
    let mut scope_87 = writer.prefix("Identities");
    if let Some(var_88) = &input.identities {
        let mut list_90 = scope_87.start_list(false, None);
        for item_89 in var_88 {
            #[allow(unused_mut)]
            let mut entry_91 = list_90.entry();
            entry_91.string(item_89);
        }
        list_90.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_identity_notification_attributes(
    input: &crate::input::GetIdentityNotificationAttributesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "GetIdentityNotificationAttributes", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_92 = writer.prefix("Identities");
    if let Some(var_93) = &input.identities {
        let mut list_95 = scope_92.start_list(false, None);
        for item_94 in var_93 {
            #[allow(unused_mut)]
            let mut entry_96 = list_95.entry();
            entry_96.string(item_94);
        }
        list_95.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_identity_policies(
    input: &crate::input::GetIdentityPoliciesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "GetIdentityPolicies", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_97 = writer.prefix("Identity");
    if let Some(var_98) = &input.identity {
        scope_97.string(var_98);
    }
    #[allow(unused_mut)]
    let mut scope_99 = writer.prefix("PolicyNames");
    if let Some(var_100) = &input.policy_names {
        let mut list_102 = scope_99.start_list(false, None);
        for item_101 in var_100 {
            #[allow(unused_mut)]
            let mut entry_103 = list_102.entry();
            entry_103.string(item_101);
        }
        list_102.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_identity_verification_attributes(
    input: &crate::input::GetIdentityVerificationAttributesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "GetIdentityVerificationAttributes", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_104 = writer.prefix("Identities");
    if let Some(var_105) = &input.identities {
        let mut list_107 = scope_104.start_list(false, None);
        for item_106 in var_105 {
            #[allow(unused_mut)]
            let mut entry_108 = list_107.entry();
            entry_108.string(item_106);
        }
        list_107.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_send_quota(
    input: &crate::input::GetSendQuotaInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let _ = input;
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "GetSendQuota", "2010-12-01");
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_send_statistics(
    input: &crate::input::GetSendStatisticsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let _ = input;
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "GetSendStatistics", "2010-12-01");
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_template(
    input: &crate::input::GetTemplateInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "GetTemplate", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_109 = writer.prefix("TemplateName");
    if let Some(var_110) = &input.template_name {
        scope_109.string(var_110);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_configuration_sets(
    input: &crate::input::ListConfigurationSetsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ListConfigurationSets", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_111 = writer.prefix("NextToken");
    if let Some(var_112) = &input.next_token {
        scope_111.string(var_112);
    }
    #[allow(unused_mut)]
    let mut scope_113 = writer.prefix("MaxItems");
    if let Some(var_114) = &input.max_items {
        scope_113.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_114).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_custom_verification_email_templates(
    input: &crate::input::ListCustomVerificationEmailTemplatesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "ListCustomVerificationEmailTemplates",
        "2010-12-01",
    );
    #[allow(unused_mut)]
    let mut scope_115 = writer.prefix("NextToken");
    if let Some(var_116) = &input.next_token {
        scope_115.string(var_116);
    }
    #[allow(unused_mut)]
    let mut scope_117 = writer.prefix("MaxResults");
    if let Some(var_118) = &input.max_results {
        scope_117.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_118).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_identities(
    input: &crate::input::ListIdentitiesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListIdentities", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_119 = writer.prefix("IdentityType");
    if let Some(var_120) = &input.identity_type {
        scope_119.string(var_120.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_121 = writer.prefix("NextToken");
    if let Some(var_122) = &input.next_token {
        scope_121.string(var_122);
    }
    #[allow(unused_mut)]
    let mut scope_123 = writer.prefix("MaxItems");
    if let Some(var_124) = &input.max_items {
        scope_123.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_124).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_identity_policies(
    input: &crate::input::ListIdentityPoliciesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListIdentityPolicies", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_125 = writer.prefix("Identity");
    if let Some(var_126) = &input.identity {
        scope_125.string(var_126);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_receipt_filters(
    input: &crate::input::ListReceiptFiltersInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let _ = input;
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListReceiptFilters", "2010-12-01");
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_receipt_rule_sets(
    input: &crate::input::ListReceiptRuleSetsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListReceiptRuleSets", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_127 = writer.prefix("NextToken");
    if let Some(var_128) = &input.next_token {
        scope_127.string(var_128);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_templates(
    input: &crate::input::ListTemplatesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListTemplates", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_129 = writer.prefix("NextToken");
    if let Some(var_130) = &input.next_token {
        scope_129.string(var_130);
    }
    #[allow(unused_mut)]
    let mut scope_131 = writer.prefix("MaxItems");
    if let Some(var_132) = &input.max_items {
        scope_131.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_132).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_verified_email_addresses(
    input: &crate::input::ListVerifiedEmailAddressesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let _ = input;
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ListVerifiedEmailAddresses", "2010-12-01");
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_put_configuration_set_delivery_options(
    input: &crate::input::PutConfigurationSetDeliveryOptionsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "PutConfigurationSetDeliveryOptions",
        "2010-12-01",
    );
    #[allow(unused_mut)]
    let mut scope_133 = writer.prefix("ConfigurationSetName");
    if let Some(var_134) = &input.configuration_set_name {
        scope_133.string(var_134);
    }
    #[allow(unused_mut)]
    let mut scope_135 = writer.prefix("DeliveryOptions");
    if let Some(var_136) = &input.delivery_options {
        crate::query_ser::serialize_structure_crate_model_delivery_options(scope_135, var_136);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_put_identity_policy(
    input: &crate::input::PutIdentityPolicyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "PutIdentityPolicy", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_137 = writer.prefix("Identity");
    if let Some(var_138) = &input.identity {
        scope_137.string(var_138);
    }
    #[allow(unused_mut)]
    let mut scope_139 = writer.prefix("PolicyName");
    if let Some(var_140) = &input.policy_name {
        scope_139.string(var_140);
    }
    #[allow(unused_mut)]
    let mut scope_141 = writer.prefix("Policy");
    if let Some(var_142) = &input.policy {
        scope_141.string(var_142);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_reorder_receipt_rule_set(
    input: &crate::input::ReorderReceiptRuleSetInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ReorderReceiptRuleSet", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_143 = writer.prefix("RuleSetName");
    if let Some(var_144) = &input.rule_set_name {
        scope_143.string(var_144);
    }
    #[allow(unused_mut)]
    let mut scope_145 = writer.prefix("RuleNames");
    if let Some(var_146) = &input.rule_names {
        let mut list_148 = scope_145.start_list(false, None);
        for item_147 in var_146 {
            #[allow(unused_mut)]
            let mut entry_149 = list_148.entry();
            entry_149.string(item_147);
        }
        list_148.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_send_bounce(
    input: &crate::input::SendBounceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "SendBounce", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_150 = writer.prefix("OriginalMessageId");
    if let Some(var_151) = &input.original_message_id {
        scope_150.string(var_151);
    }
    #[allow(unused_mut)]
    let mut scope_152 = writer.prefix("BounceSender");
    if let Some(var_153) = &input.bounce_sender {
        scope_152.string(var_153);
    }
    #[allow(unused_mut)]
    let mut scope_154 = writer.prefix("Explanation");
    if let Some(var_155) = &input.explanation {
        scope_154.string(var_155);
    }
    #[allow(unused_mut)]
    let mut scope_156 = writer.prefix("MessageDsn");
    if let Some(var_157) = &input.message_dsn {
        crate::query_ser::serialize_structure_crate_model_message_dsn(scope_156, var_157);
    }
    #[allow(unused_mut)]
    let mut scope_158 = writer.prefix("BouncedRecipientInfoList");
    if let Some(var_159) = &input.bounced_recipient_info_list {
        let mut list_161 = scope_158.start_list(false, None);
        for item_160 in var_159 {
            #[allow(unused_mut)]
            let mut entry_162 = list_161.entry();
            crate::query_ser::serialize_structure_crate_model_bounced_recipient_info(
                entry_162, item_160,
            );
        }
        list_161.finish();
    }
    #[allow(unused_mut)]
    let mut scope_163 = writer.prefix("BounceSenderArn");
    if let Some(var_164) = &input.bounce_sender_arn {
        scope_163.string(var_164);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_send_bulk_templated_email(
    input: &crate::input::SendBulkTemplatedEmailInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "SendBulkTemplatedEmail", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_165 = writer.prefix("Source");
    if let Some(var_166) = &input.source {
        scope_165.string(var_166);
    }
    #[allow(unused_mut)]
    let mut scope_167 = writer.prefix("SourceArn");
    if let Some(var_168) = &input.source_arn {
        scope_167.string(var_168);
    }
    #[allow(unused_mut)]
    let mut scope_169 = writer.prefix("ReplyToAddresses");
    if let Some(var_170) = &input.reply_to_addresses {
        let mut list_172 = scope_169.start_list(false, None);
        for item_171 in var_170 {
            #[allow(unused_mut)]
            let mut entry_173 = list_172.entry();
            entry_173.string(item_171);
        }
        list_172.finish();
    }
    #[allow(unused_mut)]
    let mut scope_174 = writer.prefix("ReturnPath");
    if let Some(var_175) = &input.return_path {
        scope_174.string(var_175);
    }
    #[allow(unused_mut)]
    let mut scope_176 = writer.prefix("ReturnPathArn");
    if let Some(var_177) = &input.return_path_arn {
        scope_176.string(var_177);
    }
    #[allow(unused_mut)]
    let mut scope_178 = writer.prefix("ConfigurationSetName");
    if let Some(var_179) = &input.configuration_set_name {
        scope_178.string(var_179);
    }
    #[allow(unused_mut)]
    let mut scope_180 = writer.prefix("DefaultTags");
    if let Some(var_181) = &input.default_tags {
        let mut list_183 = scope_180.start_list(false, None);
        for item_182 in var_181 {
            #[allow(unused_mut)]
            let mut entry_184 = list_183.entry();
            crate::query_ser::serialize_structure_crate_model_message_tag(entry_184, item_182);
        }
        list_183.finish();
    }
    #[allow(unused_mut)]
    let mut scope_185 = writer.prefix("Template");
    if let Some(var_186) = &input.template {
        scope_185.string(var_186);
    }
    #[allow(unused_mut)]
    let mut scope_187 = writer.prefix("TemplateArn");
    if let Some(var_188) = &input.template_arn {
        scope_187.string(var_188);
    }
    #[allow(unused_mut)]
    let mut scope_189 = writer.prefix("DefaultTemplateData");
    if let Some(var_190) = &input.default_template_data {
        scope_189.string(var_190);
    }
    #[allow(unused_mut)]
    let mut scope_191 = writer.prefix("Destinations");
    if let Some(var_192) = &input.destinations {
        let mut list_194 = scope_191.start_list(false, None);
        for item_193 in var_192 {
            #[allow(unused_mut)]
            let mut entry_195 = list_194.entry();
            crate::query_ser::serialize_structure_crate_model_bulk_email_destination(
                entry_195, item_193,
            );
        }
        list_194.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_send_custom_verification_email(
    input: &crate::input::SendCustomVerificationEmailInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "SendCustomVerificationEmail", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_196 = writer.prefix("EmailAddress");
    if let Some(var_197) = &input.email_address {
        scope_196.string(var_197);
    }
    #[allow(unused_mut)]
    let mut scope_198 = writer.prefix("TemplateName");
    if let Some(var_199) = &input.template_name {
        scope_198.string(var_199);
    }
    #[allow(unused_mut)]
    let mut scope_200 = writer.prefix("ConfigurationSetName");
    if let Some(var_201) = &input.configuration_set_name {
        scope_200.string(var_201);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_send_email(
    input: &crate::input::SendEmailInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "SendEmail", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_202 = writer.prefix("Source");
    if let Some(var_203) = &input.source {
        scope_202.string(var_203);
    }
    #[allow(unused_mut)]
    let mut scope_204 = writer.prefix("Destination");
    if let Some(var_205) = &input.destination {
        crate::query_ser::serialize_structure_crate_model_destination(scope_204, var_205);
    }
    #[allow(unused_mut)]
    let mut scope_206 = writer.prefix("Message");
    if let Some(var_207) = &input.message {
        crate::query_ser::serialize_structure_crate_model_message(scope_206, var_207);
    }
    #[allow(unused_mut)]
    let mut scope_208 = writer.prefix("ReplyToAddresses");
    if let Some(var_209) = &input.reply_to_addresses {
        let mut list_211 = scope_208.start_list(false, None);
        for item_210 in var_209 {
            #[allow(unused_mut)]
            let mut entry_212 = list_211.entry();
            entry_212.string(item_210);
        }
        list_211.finish();
    }
    #[allow(unused_mut)]
    let mut scope_213 = writer.prefix("ReturnPath");
    if let Some(var_214) = &input.return_path {
        scope_213.string(var_214);
    }
    #[allow(unused_mut)]
    let mut scope_215 = writer.prefix("SourceArn");
    if let Some(var_216) = &input.source_arn {
        scope_215.string(var_216);
    }
    #[allow(unused_mut)]
    let mut scope_217 = writer.prefix("ReturnPathArn");
    if let Some(var_218) = &input.return_path_arn {
        scope_217.string(var_218);
    }
    #[allow(unused_mut)]
    let mut scope_219 = writer.prefix("Tags");
    if let Some(var_220) = &input.tags {
        let mut list_222 = scope_219.start_list(false, None);
        for item_221 in var_220 {
            #[allow(unused_mut)]
            let mut entry_223 = list_222.entry();
            crate::query_ser::serialize_structure_crate_model_message_tag(entry_223, item_221);
        }
        list_222.finish();
    }
    #[allow(unused_mut)]
    let mut scope_224 = writer.prefix("ConfigurationSetName");
    if let Some(var_225) = &input.configuration_set_name {
        scope_224.string(var_225);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_send_raw_email(
    input: &crate::input::SendRawEmailInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "SendRawEmail", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_226 = writer.prefix("Source");
    if let Some(var_227) = &input.source {
        scope_226.string(var_227);
    }
    #[allow(unused_mut)]
    let mut scope_228 = writer.prefix("Destinations");
    if let Some(var_229) = &input.destinations {
        let mut list_231 = scope_228.start_list(false, None);
        for item_230 in var_229 {
            #[allow(unused_mut)]
            let mut entry_232 = list_231.entry();
            entry_232.string(item_230);
        }
        list_231.finish();
    }
    #[allow(unused_mut)]
    let mut scope_233 = writer.prefix("RawMessage");
    if let Some(var_234) = &input.raw_message {
        crate::query_ser::serialize_structure_crate_model_raw_message(scope_233, var_234);
    }
    #[allow(unused_mut)]
    let mut scope_235 = writer.prefix("FromArn");
    if let Some(var_236) = &input.from_arn {
        scope_235.string(var_236);
    }
    #[allow(unused_mut)]
    let mut scope_237 = writer.prefix("SourceArn");
    if let Some(var_238) = &input.source_arn {
        scope_237.string(var_238);
    }
    #[allow(unused_mut)]
    let mut scope_239 = writer.prefix("ReturnPathArn");
    if let Some(var_240) = &input.return_path_arn {
        scope_239.string(var_240);
    }
    #[allow(unused_mut)]
    let mut scope_241 = writer.prefix("Tags");
    if let Some(var_242) = &input.tags {
        let mut list_244 = scope_241.start_list(false, None);
        for item_243 in var_242 {
            #[allow(unused_mut)]
            let mut entry_245 = list_244.entry();
            crate::query_ser::serialize_structure_crate_model_message_tag(entry_245, item_243);
        }
        list_244.finish();
    }
    #[allow(unused_mut)]
    let mut scope_246 = writer.prefix("ConfigurationSetName");
    if let Some(var_247) = &input.configuration_set_name {
        scope_246.string(var_247);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_send_templated_email(
    input: &crate::input::SendTemplatedEmailInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "SendTemplatedEmail", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_248 = writer.prefix("Source");
    if let Some(var_249) = &input.source {
        scope_248.string(var_249);
    }
    #[allow(unused_mut)]
    let mut scope_250 = writer.prefix("Destination");
    if let Some(var_251) = &input.destination {
        crate::query_ser::serialize_structure_crate_model_destination(scope_250, var_251);
    }
    #[allow(unused_mut)]
    let mut scope_252 = writer.prefix("ReplyToAddresses");
    if let Some(var_253) = &input.reply_to_addresses {
        let mut list_255 = scope_252.start_list(false, None);
        for item_254 in var_253 {
            #[allow(unused_mut)]
            let mut entry_256 = list_255.entry();
            entry_256.string(item_254);
        }
        list_255.finish();
    }
    #[allow(unused_mut)]
    let mut scope_257 = writer.prefix("ReturnPath");
    if let Some(var_258) = &input.return_path {
        scope_257.string(var_258);
    }
    #[allow(unused_mut)]
    let mut scope_259 = writer.prefix("SourceArn");
    if let Some(var_260) = &input.source_arn {
        scope_259.string(var_260);
    }
    #[allow(unused_mut)]
    let mut scope_261 = writer.prefix("ReturnPathArn");
    if let Some(var_262) = &input.return_path_arn {
        scope_261.string(var_262);
    }
    #[allow(unused_mut)]
    let mut scope_263 = writer.prefix("Tags");
    if let Some(var_264) = &input.tags {
        let mut list_266 = scope_263.start_list(false, None);
        for item_265 in var_264 {
            #[allow(unused_mut)]
            let mut entry_267 = list_266.entry();
            crate::query_ser::serialize_structure_crate_model_message_tag(entry_267, item_265);
        }
        list_266.finish();
    }
    #[allow(unused_mut)]
    let mut scope_268 = writer.prefix("ConfigurationSetName");
    if let Some(var_269) = &input.configuration_set_name {
        scope_268.string(var_269);
    }
    #[allow(unused_mut)]
    let mut scope_270 = writer.prefix("Template");
    if let Some(var_271) = &input.template {
        scope_270.string(var_271);
    }
    #[allow(unused_mut)]
    let mut scope_272 = writer.prefix("TemplateArn");
    if let Some(var_273) = &input.template_arn {
        scope_272.string(var_273);
    }
    #[allow(unused_mut)]
    let mut scope_274 = writer.prefix("TemplateData");
    if let Some(var_275) = &input.template_data {
        scope_274.string(var_275);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_set_active_receipt_rule_set(
    input: &crate::input::SetActiveReceiptRuleSetInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "SetActiveReceiptRuleSet", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_276 = writer.prefix("RuleSetName");
    if let Some(var_277) = &input.rule_set_name {
        scope_276.string(var_277);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_set_identity_dkim_enabled(
    input: &crate::input::SetIdentityDkimEnabledInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "SetIdentityDkimEnabled", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_278 = writer.prefix("Identity");
    if let Some(var_279) = &input.identity {
        scope_278.string(var_279);
    }
    #[allow(unused_mut)]
    let mut scope_280 = writer.prefix("DkimEnabled");
    {
        scope_280.boolean(input.dkim_enabled);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_set_identity_feedback_forwarding_enabled(
    input: &crate::input::SetIdentityFeedbackForwardingEnabledInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "SetIdentityFeedbackForwardingEnabled",
        "2010-12-01",
    );
    #[allow(unused_mut)]
    let mut scope_281 = writer.prefix("Identity");
    if let Some(var_282) = &input.identity {
        scope_281.string(var_282);
    }
    #[allow(unused_mut)]
    let mut scope_283 = writer.prefix("ForwardingEnabled");
    {
        scope_283.boolean(input.forwarding_enabled);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_set_identity_headers_in_notifications_enabled(
    input: &crate::input::SetIdentityHeadersInNotificationsEnabledInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "SetIdentityHeadersInNotificationsEnabled",
        "2010-12-01",
    );
    #[allow(unused_mut)]
    let mut scope_284 = writer.prefix("Identity");
    if let Some(var_285) = &input.identity {
        scope_284.string(var_285);
    }
    #[allow(unused_mut)]
    let mut scope_286 = writer.prefix("NotificationType");
    if let Some(var_287) = &input.notification_type {
        scope_286.string(var_287.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_288 = writer.prefix("Enabled");
    {
        scope_288.boolean(input.enabled);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_set_identity_mail_from_domain(
    input: &crate::input::SetIdentityMailFromDomainInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "SetIdentityMailFromDomain", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_289 = writer.prefix("Identity");
    if let Some(var_290) = &input.identity {
        scope_289.string(var_290);
    }
    #[allow(unused_mut)]
    let mut scope_291 = writer.prefix("MailFromDomain");
    if let Some(var_292) = &input.mail_from_domain {
        scope_291.string(var_292);
    }
    #[allow(unused_mut)]
    let mut scope_293 = writer.prefix("BehaviorOnMXFailure");
    if let Some(var_294) = &input.behavior_on_mx_failure {
        scope_293.string(var_294.as_str());
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_set_identity_notification_topic(
    input: &crate::input::SetIdentityNotificationTopicInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "SetIdentityNotificationTopic", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_295 = writer.prefix("Identity");
    if let Some(var_296) = &input.identity {
        scope_295.string(var_296);
    }
    #[allow(unused_mut)]
    let mut scope_297 = writer.prefix("NotificationType");
    if let Some(var_298) = &input.notification_type {
        scope_297.string(var_298.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_299 = writer.prefix("SnsTopic");
    if let Some(var_300) = &input.sns_topic {
        scope_299.string(var_300);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_set_receipt_rule_position(
    input: &crate::input::SetReceiptRulePositionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "SetReceiptRulePosition", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_301 = writer.prefix("RuleSetName");
    if let Some(var_302) = &input.rule_set_name {
        scope_301.string(var_302);
    }
    #[allow(unused_mut)]
    let mut scope_303 = writer.prefix("RuleName");
    if let Some(var_304) = &input.rule_name {
        scope_303.string(var_304);
    }
    #[allow(unused_mut)]
    let mut scope_305 = writer.prefix("After");
    if let Some(var_306) = &input.after {
        scope_305.string(var_306);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_test_render_template(
    input: &crate::input::TestRenderTemplateInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "TestRenderTemplate", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_307 = writer.prefix("TemplateName");
    if let Some(var_308) = &input.template_name {
        scope_307.string(var_308);
    }
    #[allow(unused_mut)]
    let mut scope_309 = writer.prefix("TemplateData");
    if let Some(var_310) = &input.template_data {
        scope_309.string(var_310);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_update_account_sending_enabled(
    input: &crate::input::UpdateAccountSendingEnabledInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "UpdateAccountSendingEnabled", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_311 = writer.prefix("Enabled");
    if input.enabled {
        scope_311.boolean(input.enabled);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_update_configuration_set_event_destination(
    input: &crate::input::UpdateConfigurationSetEventDestinationInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "UpdateConfigurationSetEventDestination",
        "2010-12-01",
    );
    #[allow(unused_mut)]
    let mut scope_312 = writer.prefix("ConfigurationSetName");
    if let Some(var_313) = &input.configuration_set_name {
        scope_312.string(var_313);
    }
    #[allow(unused_mut)]
    let mut scope_314 = writer.prefix("EventDestination");
    if let Some(var_315) = &input.event_destination {
        crate::query_ser::serialize_structure_crate_model_event_destination(scope_314, var_315);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_update_configuration_set_reputation_metrics_enabled(
    input: &crate::input::UpdateConfigurationSetReputationMetricsEnabledInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "UpdateConfigurationSetReputationMetricsEnabled",
        "2010-12-01",
    );
    #[allow(unused_mut)]
    let mut scope_316 = writer.prefix("ConfigurationSetName");
    if let Some(var_317) = &input.configuration_set_name {
        scope_316.string(var_317);
    }
    #[allow(unused_mut)]
    let mut scope_318 = writer.prefix("Enabled");
    {
        scope_318.boolean(input.enabled);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_update_configuration_set_sending_enabled(
    input: &crate::input::UpdateConfigurationSetSendingEnabledInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "UpdateConfigurationSetSendingEnabled",
        "2010-12-01",
    );
    #[allow(unused_mut)]
    let mut scope_319 = writer.prefix("ConfigurationSetName");
    if let Some(var_320) = &input.configuration_set_name {
        scope_319.string(var_320);
    }
    #[allow(unused_mut)]
    let mut scope_321 = writer.prefix("Enabled");
    {
        scope_321.boolean(input.enabled);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_update_configuration_set_tracking_options(
    input: &crate::input::UpdateConfigurationSetTrackingOptionsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "UpdateConfigurationSetTrackingOptions",
        "2010-12-01",
    );
    #[allow(unused_mut)]
    let mut scope_322 = writer.prefix("ConfigurationSetName");
    if let Some(var_323) = &input.configuration_set_name {
        scope_322.string(var_323);
    }
    #[allow(unused_mut)]
    let mut scope_324 = writer.prefix("TrackingOptions");
    if let Some(var_325) = &input.tracking_options {
        crate::query_ser::serialize_structure_crate_model_tracking_options(scope_324, var_325);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_update_custom_verification_email_template(
    input: &crate::input::UpdateCustomVerificationEmailTemplateInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "UpdateCustomVerificationEmailTemplate",
        "2010-12-01",
    );
    #[allow(unused_mut)]
    let mut scope_326 = writer.prefix("TemplateName");
    if let Some(var_327) = &input.template_name {
        scope_326.string(var_327);
    }
    #[allow(unused_mut)]
    let mut scope_328 = writer.prefix("FromEmailAddress");
    if let Some(var_329) = &input.from_email_address {
        scope_328.string(var_329);
    }
    #[allow(unused_mut)]
    let mut scope_330 = writer.prefix("TemplateSubject");
    if let Some(var_331) = &input.template_subject {
        scope_330.string(var_331);
    }
    #[allow(unused_mut)]
    let mut scope_332 = writer.prefix("TemplateContent");
    if let Some(var_333) = &input.template_content {
        scope_332.string(var_333);
    }
    #[allow(unused_mut)]
    let mut scope_334 = writer.prefix("SuccessRedirectionURL");
    if let Some(var_335) = &input.success_redirection_url {
        scope_334.string(var_335);
    }
    #[allow(unused_mut)]
    let mut scope_336 = writer.prefix("FailureRedirectionURL");
    if let Some(var_337) = &input.failure_redirection_url {
        scope_336.string(var_337);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_update_receipt_rule(
    input: &crate::input::UpdateReceiptRuleInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "UpdateReceiptRule", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_338 = writer.prefix("RuleSetName");
    if let Some(var_339) = &input.rule_set_name {
        scope_338.string(var_339);
    }
    #[allow(unused_mut)]
    let mut scope_340 = writer.prefix("Rule");
    if let Some(var_341) = &input.rule {
        crate::query_ser::serialize_structure_crate_model_receipt_rule(scope_340, var_341);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_update_template(
    input: &crate::input::UpdateTemplateInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "UpdateTemplate", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_342 = writer.prefix("Template");
    if let Some(var_343) = &input.template {
        crate::query_ser::serialize_structure_crate_model_template(scope_342, var_343);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_verify_domain_dkim(
    input: &crate::input::VerifyDomainDkimInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "VerifyDomainDkim", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_344 = writer.prefix("Domain");
    if let Some(var_345) = &input.domain {
        scope_344.string(var_345);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_verify_domain_identity(
    input: &crate::input::VerifyDomainIdentityInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "VerifyDomainIdentity", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_346 = writer.prefix("Domain");
    if let Some(var_347) = &input.domain {
        scope_346.string(var_347);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_verify_email_address(
    input: &crate::input::VerifyEmailAddressInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "VerifyEmailAddress", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_348 = writer.prefix("EmailAddress");
    if let Some(var_349) = &input.email_address {
        scope_348.string(var_349);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_verify_email_identity(
    input: &crate::input::VerifyEmailIdentityInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "VerifyEmailIdentity", "2010-12-01");
    #[allow(unused_mut)]
    let mut scope_350 = writer.prefix("EmailAddress");
    if let Some(var_351) = &input.email_address {
        scope_350.string(var_351);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_clone_receipt_rule_set_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CloneReceiptRuleSetOutput,
    crate::error::CloneReceiptRuleSetError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CloneReceiptRuleSetError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CloneReceiptRuleSetError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AlreadyExists" => crate::error::CloneReceiptRuleSetError {
            meta: generic,
            kind: crate::error::CloneReceiptRuleSetErrorKind::AlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CloneReceiptRuleSetError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::CloneReceiptRuleSetError {
            meta: generic,
            kind: crate::error::CloneReceiptRuleSetErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CloneReceiptRuleSetError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RuleSetDoesNotExist" => crate::error::CloneReceiptRuleSetError {
            meta: generic,
            kind: crate::error::CloneReceiptRuleSetErrorKind::RuleSetDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::rule_set_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_rule_set_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CloneReceiptRuleSetError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CloneReceiptRuleSetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_clone_receipt_rule_set_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CloneReceiptRuleSetOutput,
    crate::error::CloneReceiptRuleSetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::clone_receipt_rule_set_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_configuration_set_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateConfigurationSetOutput,
    crate::error::CreateConfigurationSetError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateConfigurationSetError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateConfigurationSetError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConfigurationSetAlreadyExists" => crate::error::CreateConfigurationSetError { meta: generic, kind: crate::error::CreateConfigurationSetErrorKind::ConfigurationSetAlreadyExistsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::configuration_set_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_configuration_set_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateConfigurationSetError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConfigurationSet" => crate::error::CreateConfigurationSetError { meta: generic, kind: crate::error::CreateConfigurationSetErrorKind::InvalidConfigurationSetException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_configuration_set_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_configuration_set_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateConfigurationSetError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "LimitExceeded" => crate::error::CreateConfigurationSetError { meta: generic, kind: crate::error::CreateConfigurationSetErrorKind::LimitExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateConfigurationSetError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateConfigurationSetError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_configuration_set_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateConfigurationSetOutput,
    crate::error::CreateConfigurationSetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_configuration_set_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_configuration_set_event_destination_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateConfigurationSetEventDestinationOutput,
    crate::error::CreateConfigurationSetEventDestinationError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateConfigurationSetEventDestinationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::CreateConfigurationSetEventDestinationError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConfigurationSetDoesNotExist" => crate::error::CreateConfigurationSetEventDestinationError { meta: generic, kind: crate::error::CreateConfigurationSetEventDestinationErrorKind::ConfigurationSetDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::configuration_set_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_configuration_set_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateConfigurationSetEventDestinationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EventDestinationAlreadyExists" => crate::error::CreateConfigurationSetEventDestinationError { meta: generic, kind: crate::error::CreateConfigurationSetEventDestinationErrorKind::EventDestinationAlreadyExistsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::event_destination_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_event_destination_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateConfigurationSetEventDestinationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCloudWatchDestination" => crate::error::CreateConfigurationSetEventDestinationError { meta: generic, kind: crate::error::CreateConfigurationSetEventDestinationErrorKind::InvalidCloudWatchDestinationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_cloud_watch_destination_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cloud_watch_destination_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateConfigurationSetEventDestinationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFirehoseDestination" => crate::error::CreateConfigurationSetEventDestinationError { meta: generic, kind: crate::error::CreateConfigurationSetEventDestinationErrorKind::InvalidFirehoseDestinationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_firehose_destination_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_firehose_destination_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateConfigurationSetEventDestinationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidSNSDestination" => crate::error::CreateConfigurationSetEventDestinationError { meta: generic, kind: crate::error::CreateConfigurationSetEventDestinationErrorKind::InvalidSnsDestinationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_sns_destination_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_sns_destination_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateConfigurationSetEventDestinationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "LimitExceeded" => crate::error::CreateConfigurationSetEventDestinationError { meta: generic, kind: crate::error::CreateConfigurationSetEventDestinationErrorKind::LimitExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateConfigurationSetEventDestinationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateConfigurationSetEventDestinationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_configuration_set_event_destination_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateConfigurationSetEventDestinationOutput,
    crate::error::CreateConfigurationSetEventDestinationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_configuration_set_event_destination_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_configuration_set_tracking_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateConfigurationSetTrackingOptionsOutput,
    crate::error::CreateConfigurationSetTrackingOptionsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateConfigurationSetTrackingOptionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::CreateConfigurationSetTrackingOptionsError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConfigurationSetDoesNotExist" => crate::error::CreateConfigurationSetTrackingOptionsError { meta: generic, kind: crate::error::CreateConfigurationSetTrackingOptionsErrorKind::ConfigurationSetDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::configuration_set_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_configuration_set_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateConfigurationSetTrackingOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTrackingOptions" => crate::error::CreateConfigurationSetTrackingOptionsError { meta: generic, kind: crate::error::CreateConfigurationSetTrackingOptionsErrorKind::InvalidTrackingOptionsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_tracking_options_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_tracking_options_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateConfigurationSetTrackingOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TrackingOptionsAlreadyExistsException" => crate::error::CreateConfigurationSetTrackingOptionsError { meta: generic, kind: crate::error::CreateConfigurationSetTrackingOptionsErrorKind::TrackingOptionsAlreadyExistsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::tracking_options_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_tracking_options_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateConfigurationSetTrackingOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateConfigurationSetTrackingOptionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_configuration_set_tracking_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateConfigurationSetTrackingOptionsOutput,
    crate::error::CreateConfigurationSetTrackingOptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_configuration_set_tracking_options_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_custom_verification_email_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCustomVerificationEmailTemplateOutput,
    crate::error::CreateCustomVerificationEmailTemplateError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateCustomVerificationEmailTemplateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::CreateCustomVerificationEmailTemplateError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CustomVerificationEmailInvalidContent" => crate::error::CreateCustomVerificationEmailTemplateError { meta: generic, kind: crate::error::CreateCustomVerificationEmailTemplateErrorKind::CustomVerificationEmailInvalidContentException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::custom_verification_email_invalid_content_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_custom_verification_email_invalid_content_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateCustomVerificationEmailTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CustomVerificationEmailTemplateAlreadyExists" => crate::error::CreateCustomVerificationEmailTemplateError { meta: generic, kind: crate::error::CreateCustomVerificationEmailTemplateErrorKind::CustomVerificationEmailTemplateAlreadyExistsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::custom_verification_email_template_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_custom_verification_email_template_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateCustomVerificationEmailTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FromEmailAddressNotVerified" => crate::error::CreateCustomVerificationEmailTemplateError { meta: generic, kind: crate::error::CreateCustomVerificationEmailTemplateErrorKind::FromEmailAddressNotVerifiedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::from_email_address_not_verified_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_from_email_address_not_verified_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateCustomVerificationEmailTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "LimitExceeded" => crate::error::CreateCustomVerificationEmailTemplateError { meta: generic, kind: crate::error::CreateCustomVerificationEmailTemplateErrorKind::LimitExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateCustomVerificationEmailTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateCustomVerificationEmailTemplateError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_custom_verification_email_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCustomVerificationEmailTemplateOutput,
    crate::error::CreateCustomVerificationEmailTemplateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_custom_verification_email_template_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_receipt_filter_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateReceiptFilterOutput,
    crate::error::CreateReceiptFilterError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateReceiptFilterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateReceiptFilterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AlreadyExists" => crate::error::CreateReceiptFilterError {
            meta: generic,
            kind: crate::error::CreateReceiptFilterErrorKind::AlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateReceiptFilterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::CreateReceiptFilterError {
            meta: generic,
            kind: crate::error::CreateReceiptFilterErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateReceiptFilterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateReceiptFilterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_receipt_filter_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateReceiptFilterOutput,
    crate::error::CreateReceiptFilterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_receipt_filter_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_receipt_rule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateReceiptRuleOutput, crate::error::CreateReceiptRuleError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateReceiptRuleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateReceiptRuleError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AlreadyExists" => crate::error::CreateReceiptRuleError {
            meta: generic,
            kind: crate::error::CreateReceiptRuleErrorKind::AlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateReceiptRuleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidLambdaFunction" => crate::error::CreateReceiptRuleError {
            meta: generic,
            kind: crate::error::CreateReceiptRuleErrorKind::InvalidLambdaFunctionException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_lambda_function_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_lambda_function_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateReceiptRuleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidS3Configuration" => crate::error::CreateReceiptRuleError {
            meta: generic,
            kind: crate::error::CreateReceiptRuleErrorKind::InvalidS3ConfigurationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_s3_configuration_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_s3_configuration_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateReceiptRuleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidSnsTopic" => crate::error::CreateReceiptRuleError {
            meta: generic,
            kind: crate::error::CreateReceiptRuleErrorKind::InvalidSnsTopicException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_sns_topic_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_sns_topic_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateReceiptRuleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::CreateReceiptRuleError {
            meta: generic,
            kind: crate::error::CreateReceiptRuleErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateReceiptRuleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RuleDoesNotExist" => crate::error::CreateReceiptRuleError {
            meta: generic,
            kind: crate::error::CreateReceiptRuleErrorKind::RuleDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::rule_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_rule_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateReceiptRuleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RuleSetDoesNotExist" => crate::error::CreateReceiptRuleError {
            meta: generic,
            kind: crate::error::CreateReceiptRuleErrorKind::RuleSetDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::rule_set_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_rule_set_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateReceiptRuleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateReceiptRuleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_receipt_rule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateReceiptRuleOutput, crate::error::CreateReceiptRuleError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_receipt_rule_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_receipt_rule_set_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateReceiptRuleSetOutput,
    crate::error::CreateReceiptRuleSetError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateReceiptRuleSetError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateReceiptRuleSetError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AlreadyExists" => crate::error::CreateReceiptRuleSetError {
            meta: generic,
            kind: crate::error::CreateReceiptRuleSetErrorKind::AlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateReceiptRuleSetError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::CreateReceiptRuleSetError {
            meta: generic,
            kind: crate::error::CreateReceiptRuleSetErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateReceiptRuleSetError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateReceiptRuleSetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_receipt_rule_set_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateReceiptRuleSetOutput,
    crate::error::CreateReceiptRuleSetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_receipt_rule_set_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateTemplateOutput, crate::error::CreateTemplateError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateTemplateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateTemplateError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AlreadyExists" => crate::error::CreateTemplateError {
            meta: generic,
            kind: crate::error::CreateTemplateErrorKind::AlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateTemplateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidTemplate" => crate::error::CreateTemplateError {
            meta: generic,
            kind: crate::error::CreateTemplateErrorKind::InvalidTemplateException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_template_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_template_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateTemplateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::CreateTemplateError {
            meta: generic,
            kind: crate::error::CreateTemplateErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateTemplateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateTemplateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateTemplateOutput, crate::error::CreateTemplateError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_template_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_configuration_set_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteConfigurationSetOutput,
    crate::error::DeleteConfigurationSetError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteConfigurationSetError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteConfigurationSetError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConfigurationSetDoesNotExist" => crate::error::DeleteConfigurationSetError {
            meta: generic,
            kind:
                crate::error::DeleteConfigurationSetErrorKind::ConfigurationSetDoesNotExistException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::configuration_set_does_not_exist_exception::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_configuration_set_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteConfigurationSetError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::DeleteConfigurationSetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_configuration_set_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteConfigurationSetOutput,
    crate::error::DeleteConfigurationSetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_configuration_set_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_configuration_set_event_destination_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteConfigurationSetEventDestinationOutput,
    crate::error::DeleteConfigurationSetEventDestinationError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteConfigurationSetEventDestinationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DeleteConfigurationSetEventDestinationError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConfigurationSetDoesNotExist" => crate::error::DeleteConfigurationSetEventDestinationError { meta: generic, kind: crate::error::DeleteConfigurationSetEventDestinationErrorKind::ConfigurationSetDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::configuration_set_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_configuration_set_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteConfigurationSetEventDestinationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EventDestinationDoesNotExist" => crate::error::DeleteConfigurationSetEventDestinationError { meta: generic, kind: crate::error::DeleteConfigurationSetEventDestinationErrorKind::EventDestinationDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::event_destination_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_event_destination_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteConfigurationSetEventDestinationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteConfigurationSetEventDestinationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_configuration_set_event_destination_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteConfigurationSetEventDestinationOutput,
    crate::error::DeleteConfigurationSetEventDestinationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_configuration_set_event_destination_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_configuration_set_tracking_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteConfigurationSetTrackingOptionsOutput,
    crate::error::DeleteConfigurationSetTrackingOptionsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteConfigurationSetTrackingOptionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DeleteConfigurationSetTrackingOptionsError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConfigurationSetDoesNotExist" => crate::error::DeleteConfigurationSetTrackingOptionsError { meta: generic, kind: crate::error::DeleteConfigurationSetTrackingOptionsErrorKind::ConfigurationSetDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::configuration_set_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_configuration_set_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteConfigurationSetTrackingOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TrackingOptionsDoesNotExistException" => crate::error::DeleteConfigurationSetTrackingOptionsError { meta: generic, kind: crate::error::DeleteConfigurationSetTrackingOptionsErrorKind::TrackingOptionsDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::tracking_options_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_tracking_options_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteConfigurationSetTrackingOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteConfigurationSetTrackingOptionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_configuration_set_tracking_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteConfigurationSetTrackingOptionsOutput,
    crate::error::DeleteConfigurationSetTrackingOptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_configuration_set_tracking_options_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_custom_verification_email_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCustomVerificationEmailTemplateOutput,
    crate::error::DeleteCustomVerificationEmailTemplateError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteCustomVerificationEmailTemplateError::unhandled)?;
    Err(crate::error::DeleteCustomVerificationEmailTemplateError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_custom_verification_email_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCustomVerificationEmailTemplateOutput,
    crate::error::DeleteCustomVerificationEmailTemplateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_custom_verification_email_template_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_identity_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteIdentityOutput, crate::error::DeleteIdentityError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteIdentityError::unhandled)?;
    Err(crate::error::DeleteIdentityError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_identity_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteIdentityOutput, crate::error::DeleteIdentityError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_identity_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_identity_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteIdentityPolicyOutput,
    crate::error::DeleteIdentityPolicyError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteIdentityPolicyError::unhandled)?;
    Err(crate::error::DeleteIdentityPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_identity_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteIdentityPolicyOutput,
    crate::error::DeleteIdentityPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_identity_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_receipt_filter_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteReceiptFilterOutput,
    crate::error::DeleteReceiptFilterError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteReceiptFilterError::unhandled)?;
    Err(crate::error::DeleteReceiptFilterError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_receipt_filter_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteReceiptFilterOutput,
    crate::error::DeleteReceiptFilterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_receipt_filter_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_receipt_rule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteReceiptRuleOutput, crate::error::DeleteReceiptRuleError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteReceiptRuleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteReceiptRuleError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "RuleSetDoesNotExist" => crate::error::DeleteReceiptRuleError {
            meta: generic,
            kind: crate::error::DeleteReceiptRuleErrorKind::RuleSetDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::rule_set_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_rule_set_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteReceiptRuleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteReceiptRuleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_receipt_rule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteReceiptRuleOutput, crate::error::DeleteReceiptRuleError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_receipt_rule_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_receipt_rule_set_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteReceiptRuleSetOutput,
    crate::error::DeleteReceiptRuleSetError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteReceiptRuleSetError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteReceiptRuleSetError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CannotDelete" => crate::error::DeleteReceiptRuleSetError {
            meta: generic,
            kind: crate::error::DeleteReceiptRuleSetErrorKind::CannotDeleteException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cannot_delete_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cannot_delete_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteReceiptRuleSetError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteReceiptRuleSetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_receipt_rule_set_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteReceiptRuleSetOutput,
    crate::error::DeleteReceiptRuleSetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_receipt_rule_set_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteTemplateOutput, crate::error::DeleteTemplateError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteTemplateError::unhandled)?;
    Err(crate::error::DeleteTemplateError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteTemplateOutput, crate::error::DeleteTemplateError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_template_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_verified_email_address_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVerifiedEmailAddressOutput,
    crate::error::DeleteVerifiedEmailAddressError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteVerifiedEmailAddressError::unhandled)?;
    Err(crate::error::DeleteVerifiedEmailAddressError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_verified_email_address_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVerifiedEmailAddressOutput,
    crate::error::DeleteVerifiedEmailAddressError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_verified_email_address_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_active_receipt_rule_set_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeActiveReceiptRuleSetOutput,
    crate::error::DescribeActiveReceiptRuleSetError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeActiveReceiptRuleSetError::unhandled)?;
    Err(crate::error::DescribeActiveReceiptRuleSetError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_active_receipt_rule_set_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeActiveReceiptRuleSetOutput,
    crate::error::DescribeActiveReceiptRuleSetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_active_receipt_rule_set_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_active_receipt_rule_set(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeActiveReceiptRuleSetError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_configuration_set_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConfigurationSetOutput,
    crate::error::DescribeConfigurationSetError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeConfigurationSetError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeConfigurationSetError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConfigurationSetDoesNotExist" => crate::error::DescribeConfigurationSetError { meta: generic, kind: crate::error::DescribeConfigurationSetErrorKind::ConfigurationSetDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::configuration_set_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_configuration_set_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeConfigurationSetError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeConfigurationSetError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_configuration_set_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConfigurationSetOutput,
    crate::error::DescribeConfigurationSetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_configuration_set_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_configuration_set(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeConfigurationSetError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_receipt_rule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReceiptRuleOutput,
    crate::error::DescribeReceiptRuleError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeReceiptRuleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeReceiptRuleError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "RuleDoesNotExist" => crate::error::DescribeReceiptRuleError {
            meta: generic,
            kind: crate::error::DescribeReceiptRuleErrorKind::RuleDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::rule_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_rule_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeReceiptRuleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RuleSetDoesNotExist" => crate::error::DescribeReceiptRuleError {
            meta: generic,
            kind: crate::error::DescribeReceiptRuleErrorKind::RuleSetDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::rule_set_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_rule_set_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeReceiptRuleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeReceiptRuleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_receipt_rule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReceiptRuleOutput,
    crate::error::DescribeReceiptRuleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_receipt_rule_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_receipt_rule(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeReceiptRuleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_receipt_rule_set_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReceiptRuleSetOutput,
    crate::error::DescribeReceiptRuleSetError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeReceiptRuleSetError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeReceiptRuleSetError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "RuleSetDoesNotExist" => crate::error::DescribeReceiptRuleSetError {
            meta: generic,
            kind: crate::error::DescribeReceiptRuleSetErrorKind::RuleSetDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::rule_set_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_rule_set_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeReceiptRuleSetError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeReceiptRuleSetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_receipt_rule_set_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReceiptRuleSetOutput,
    crate::error::DescribeReceiptRuleSetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_receipt_rule_set_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_receipt_rule_set(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeReceiptRuleSetError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_sending_enabled_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAccountSendingEnabledOutput,
    crate::error::GetAccountSendingEnabledError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetAccountSendingEnabledError::unhandled)?;
    Err(crate::error::GetAccountSendingEnabledError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_sending_enabled_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAccountSendingEnabledOutput,
    crate::error::GetAccountSendingEnabledError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_account_sending_enabled_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_account_sending_enabled(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetAccountSendingEnabledError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_custom_verification_email_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCustomVerificationEmailTemplateOutput,
    crate::error::GetCustomVerificationEmailTemplateError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetCustomVerificationEmailTemplateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetCustomVerificationEmailTemplateError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CustomVerificationEmailTemplateDoesNotExist" => crate::error::GetCustomVerificationEmailTemplateError { meta: generic, kind: crate::error::GetCustomVerificationEmailTemplateErrorKind::CustomVerificationEmailTemplateDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::custom_verification_email_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_custom_verification_email_template_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetCustomVerificationEmailTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetCustomVerificationEmailTemplateError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_custom_verification_email_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCustomVerificationEmailTemplateOutput,
    crate::error::GetCustomVerificationEmailTemplateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_custom_verification_email_template_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_custom_verification_email_template(response.body().as_ref(), output).map_err(crate::error::GetCustomVerificationEmailTemplateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_identity_dkim_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetIdentityDkimAttributesOutput,
    crate::error::GetIdentityDkimAttributesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetIdentityDkimAttributesError::unhandled)?;
    Err(crate::error::GetIdentityDkimAttributesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_identity_dkim_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetIdentityDkimAttributesOutput,
    crate::error::GetIdentityDkimAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_identity_dkim_attributes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_identity_dkim_attributes(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetIdentityDkimAttributesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_identity_mail_from_domain_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetIdentityMailFromDomainAttributesOutput,
    crate::error::GetIdentityMailFromDomainAttributesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetIdentityMailFromDomainAttributesError::unhandled)?;
    Err(crate::error::GetIdentityMailFromDomainAttributesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_identity_mail_from_domain_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetIdentityMailFromDomainAttributesOutput,
    crate::error::GetIdentityMailFromDomainAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_identity_mail_from_domain_attributes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_identity_mail_from_domain_attributes(response.body().as_ref(), output).map_err(crate::error::GetIdentityMailFromDomainAttributesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_identity_notification_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetIdentityNotificationAttributesOutput,
    crate::error::GetIdentityNotificationAttributesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetIdentityNotificationAttributesError::unhandled)?;
    Err(crate::error::GetIdentityNotificationAttributesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_identity_notification_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetIdentityNotificationAttributesOutput,
    crate::error::GetIdentityNotificationAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_identity_notification_attributes_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_get_identity_notification_attributes(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GetIdentityNotificationAttributesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_identity_policies_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetIdentityPoliciesOutput,
    crate::error::GetIdentityPoliciesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetIdentityPoliciesError::unhandled)?;
    Err(crate::error::GetIdentityPoliciesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_identity_policies_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetIdentityPoliciesOutput,
    crate::error::GetIdentityPoliciesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_identity_policies_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_identity_policies(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetIdentityPoliciesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_identity_verification_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetIdentityVerificationAttributesOutput,
    crate::error::GetIdentityVerificationAttributesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetIdentityVerificationAttributesError::unhandled)?;
    Err(crate::error::GetIdentityVerificationAttributesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_identity_verification_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetIdentityVerificationAttributesOutput,
    crate::error::GetIdentityVerificationAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_identity_verification_attributes_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_get_identity_verification_attributes(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GetIdentityVerificationAttributesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_send_quota_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetSendQuotaOutput, crate::error::GetSendQuotaError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetSendQuotaError::unhandled)?;
    Err(crate::error::GetSendQuotaError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_send_quota_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetSendQuotaOutput, crate::error::GetSendQuotaError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_send_quota_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_send_quota(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetSendQuotaError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_send_statistics_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetSendStatisticsOutput, crate::error::GetSendStatisticsError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetSendStatisticsError::unhandled)?;
    Err(crate::error::GetSendStatisticsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_send_statistics_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetSendStatisticsOutput, crate::error::GetSendStatisticsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_send_statistics_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_send_statistics(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetSendStatisticsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetTemplateOutput, crate::error::GetTemplateError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetTemplateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetTemplateError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "TemplateDoesNotExist" => crate::error::GetTemplateError {
            meta: generic,
            kind: crate::error::GetTemplateErrorKind::TemplateDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_template_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetTemplateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetTemplateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetTemplateOutput, crate::error::GetTemplateError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_template_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_template(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetTemplateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_configuration_sets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListConfigurationSetsOutput,
    crate::error::ListConfigurationSetsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListConfigurationSetsError::unhandled)?;
    Err(crate::error::ListConfigurationSetsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_configuration_sets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListConfigurationSetsOutput,
    crate::error::ListConfigurationSetsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_configuration_sets_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_configuration_sets(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListConfigurationSetsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_custom_verification_email_templates_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListCustomVerificationEmailTemplatesOutput,
    crate::error::ListCustomVerificationEmailTemplatesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListCustomVerificationEmailTemplatesError::unhandled)?;
    Err(crate::error::ListCustomVerificationEmailTemplatesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_custom_verification_email_templates_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListCustomVerificationEmailTemplatesOutput,
    crate::error::ListCustomVerificationEmailTemplatesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_custom_verification_email_templates_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_custom_verification_email_templates(response.body().as_ref(), output).map_err(crate::error::ListCustomVerificationEmailTemplatesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_identities_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListIdentitiesOutput, crate::error::ListIdentitiesError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListIdentitiesError::unhandled)?;
    Err(crate::error::ListIdentitiesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_identities_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListIdentitiesOutput, crate::error::ListIdentitiesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_identities_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_identities(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListIdentitiesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_identity_policies_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListIdentityPoliciesOutput,
    crate::error::ListIdentityPoliciesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListIdentityPoliciesError::unhandled)?;
    Err(crate::error::ListIdentityPoliciesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_identity_policies_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListIdentityPoliciesOutput,
    crate::error::ListIdentityPoliciesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_identity_policies_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_identity_policies(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListIdentityPoliciesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_receipt_filters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListReceiptFiltersOutput,
    crate::error::ListReceiptFiltersError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListReceiptFiltersError::unhandled)?;
    Err(crate::error::ListReceiptFiltersError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_receipt_filters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListReceiptFiltersOutput,
    crate::error::ListReceiptFiltersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_receipt_filters_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_receipt_filters(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListReceiptFiltersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_receipt_rule_sets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListReceiptRuleSetsOutput,
    crate::error::ListReceiptRuleSetsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListReceiptRuleSetsError::unhandled)?;
    Err(crate::error::ListReceiptRuleSetsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_receipt_rule_sets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListReceiptRuleSetsOutput,
    crate::error::ListReceiptRuleSetsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_receipt_rule_sets_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_receipt_rule_sets(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListReceiptRuleSetsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_templates_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListTemplatesOutput, crate::error::ListTemplatesError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListTemplatesError::unhandled)?;
    Err(crate::error::ListTemplatesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_templates_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListTemplatesOutput, crate::error::ListTemplatesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_templates_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_templates(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTemplatesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_verified_email_addresses_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListVerifiedEmailAddressesOutput,
    crate::error::ListVerifiedEmailAddressesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListVerifiedEmailAddressesError::unhandled)?;
    Err(crate::error::ListVerifiedEmailAddressesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_verified_email_addresses_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListVerifiedEmailAddressesOutput,
    crate::error::ListVerifiedEmailAddressesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_verified_email_addresses_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_verified_email_addresses(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListVerifiedEmailAddressesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_configuration_set_delivery_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutConfigurationSetDeliveryOptionsOutput,
    crate::error::PutConfigurationSetDeliveryOptionsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutConfigurationSetDeliveryOptionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutConfigurationSetDeliveryOptionsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConfigurationSetDoesNotExist" => crate::error::PutConfigurationSetDeliveryOptionsError { meta: generic, kind: crate::error::PutConfigurationSetDeliveryOptionsErrorKind::ConfigurationSetDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::configuration_set_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_configuration_set_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PutConfigurationSetDeliveryOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDeliveryOptions" => crate::error::PutConfigurationSetDeliveryOptionsError { meta: generic, kind: crate::error::PutConfigurationSetDeliveryOptionsErrorKind::InvalidDeliveryOptionsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_delivery_options_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_delivery_options_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PutConfigurationSetDeliveryOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PutConfigurationSetDeliveryOptionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_configuration_set_delivery_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutConfigurationSetDeliveryOptionsOutput,
    crate::error::PutConfigurationSetDeliveryOptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::put_configuration_set_delivery_options_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_identity_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutIdentityPolicyOutput, crate::error::PutIdentityPolicyError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutIdentityPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutIdentityPolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidPolicy" => crate::error::PutIdentityPolicyError {
            meta: generic,
            kind: crate::error::PutIdentityPolicyErrorKind::InvalidPolicyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_policy_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_policy_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PutIdentityPolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::PutIdentityPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_identity_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutIdentityPolicyOutput, crate::error::PutIdentityPolicyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_identity_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reorder_receipt_rule_set_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ReorderReceiptRuleSetOutput,
    crate::error::ReorderReceiptRuleSetError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ReorderReceiptRuleSetError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ReorderReceiptRuleSetError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "RuleDoesNotExist" => crate::error::ReorderReceiptRuleSetError {
            meta: generic,
            kind: crate::error::ReorderReceiptRuleSetErrorKind::RuleDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::rule_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_rule_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ReorderReceiptRuleSetError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RuleSetDoesNotExist" => crate::error::ReorderReceiptRuleSetError {
            meta: generic,
            kind: crate::error::ReorderReceiptRuleSetErrorKind::RuleSetDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::rule_set_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_rule_set_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ReorderReceiptRuleSetError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ReorderReceiptRuleSetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reorder_receipt_rule_set_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ReorderReceiptRuleSetOutput,
    crate::error::ReorderReceiptRuleSetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reorder_receipt_rule_set_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_bounce_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SendBounceOutput, crate::error::SendBounceError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::SendBounceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::SendBounceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "MessageRejected" => crate::error::SendBounceError {
            meta: generic,
            kind: crate::error::SendBounceErrorKind::MessageRejected({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::message_rejected::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_message_rejected_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::SendBounceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::SendBounceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_bounce_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SendBounceOutput, crate::error::SendBounceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::send_bounce_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_send_bounce(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::SendBounceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_bulk_templated_email_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SendBulkTemplatedEmailOutput,
    crate::error::SendBulkTemplatedEmailError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::SendBulkTemplatedEmailError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::SendBulkTemplatedEmailError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccountSendingPausedException" => crate::error::SendBulkTemplatedEmailError { meta: generic, kind: crate::error::SendBulkTemplatedEmailErrorKind::AccountSendingPausedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::account_sending_paused_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_account_sending_paused_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SendBulkTemplatedEmailError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ConfigurationSetDoesNotExist" => crate::error::SendBulkTemplatedEmailError { meta: generic, kind: crate::error::SendBulkTemplatedEmailErrorKind::ConfigurationSetDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::configuration_set_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_configuration_set_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SendBulkTemplatedEmailError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ConfigurationSetSendingPausedException" => crate::error::SendBulkTemplatedEmailError { meta: generic, kind: crate::error::SendBulkTemplatedEmailErrorKind::ConfigurationSetSendingPausedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::configuration_set_sending_paused_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_configuration_set_sending_paused_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SendBulkTemplatedEmailError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MailFromDomainNotVerifiedException" => crate::error::SendBulkTemplatedEmailError { meta: generic, kind: crate::error::SendBulkTemplatedEmailErrorKind::MailFromDomainNotVerifiedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::mail_from_domain_not_verified_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_mail_from_domain_not_verified_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SendBulkTemplatedEmailError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MessageRejected" => crate::error::SendBulkTemplatedEmailError { meta: generic, kind: crate::error::SendBulkTemplatedEmailErrorKind::MessageRejected({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::message_rejected::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_message_rejected_xml_err(response.body().as_ref(), output).map_err(crate::error::SendBulkTemplatedEmailError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TemplateDoesNotExist" => crate::error::SendBulkTemplatedEmailError { meta: generic, kind: crate::error::SendBulkTemplatedEmailErrorKind::TemplateDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_template_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SendBulkTemplatedEmailError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::SendBulkTemplatedEmailError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_bulk_templated_email_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SendBulkTemplatedEmailOutput,
    crate::error::SendBulkTemplatedEmailError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::send_bulk_templated_email_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_send_bulk_templated_email(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::SendBulkTemplatedEmailError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_custom_verification_email_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SendCustomVerificationEmailOutput,
    crate::error::SendCustomVerificationEmailError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::SendCustomVerificationEmailError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::SendCustomVerificationEmailError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConfigurationSetDoesNotExist" => crate::error::SendCustomVerificationEmailError { meta: generic, kind: crate::error::SendCustomVerificationEmailErrorKind::ConfigurationSetDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::configuration_set_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_configuration_set_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SendCustomVerificationEmailError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CustomVerificationEmailTemplateDoesNotExist" => crate::error::SendCustomVerificationEmailError { meta: generic, kind: crate::error::SendCustomVerificationEmailErrorKind::CustomVerificationEmailTemplateDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::custom_verification_email_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_custom_verification_email_template_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SendCustomVerificationEmailError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FromEmailAddressNotVerified" => crate::error::SendCustomVerificationEmailError { meta: generic, kind: crate::error::SendCustomVerificationEmailErrorKind::FromEmailAddressNotVerifiedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::from_email_address_not_verified_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_from_email_address_not_verified_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SendCustomVerificationEmailError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MessageRejected" => crate::error::SendCustomVerificationEmailError { meta: generic, kind: crate::error::SendCustomVerificationEmailErrorKind::MessageRejected({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::message_rejected::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_message_rejected_xml_err(response.body().as_ref(), output).map_err(crate::error::SendCustomVerificationEmailError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ProductionAccessNotGranted" => crate::error::SendCustomVerificationEmailError { meta: generic, kind: crate::error::SendCustomVerificationEmailErrorKind::ProductionAccessNotGrantedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::production_access_not_granted_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_production_access_not_granted_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SendCustomVerificationEmailError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::SendCustomVerificationEmailError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_custom_verification_email_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SendCustomVerificationEmailOutput,
    crate::error::SendCustomVerificationEmailError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::send_custom_verification_email_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_send_custom_verification_email(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::SendCustomVerificationEmailError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_email_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SendEmailOutput, crate::error::SendEmailError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::SendEmailError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::SendEmailError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccountSendingPausedException" => crate::error::SendEmailError {
            meta: generic,
            kind: crate::error::SendEmailErrorKind::AccountSendingPausedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::account_sending_paused_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_account_sending_paused_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SendEmailError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ConfigurationSetDoesNotExist" => {
            crate::error::SendEmailError {
                meta: generic,
                kind: crate::error::SendEmailErrorKind::ConfigurationSetDoesNotExistException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::configuration_set_does_not_exist_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_configuration_set_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SendEmailError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "ConfigurationSetSendingPausedException" => {
            crate::error::SendEmailError {
                meta: generic,
                kind: crate::error::SendEmailErrorKind::ConfigurationSetSendingPausedException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::configuration_set_sending_paused_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_configuration_set_sending_paused_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SendEmailError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "MailFromDomainNotVerifiedException" => crate::error::SendEmailError {
            meta: generic,
            kind: crate::error::SendEmailErrorKind::MailFromDomainNotVerifiedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::mail_from_domain_not_verified_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_mail_from_domain_not_verified_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SendEmailError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "MessageRejected" => crate::error::SendEmailError {
            meta: generic,
            kind: crate::error::SendEmailErrorKind::MessageRejected({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::message_rejected::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_message_rejected_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::SendEmailError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::SendEmailError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_email_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SendEmailOutput, crate::error::SendEmailError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::send_email_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_send_email(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::SendEmailError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_raw_email_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SendRawEmailOutput, crate::error::SendRawEmailError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::SendRawEmailError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::SendRawEmailError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccountSendingPausedException" => crate::error::SendRawEmailError {
            meta: generic,
            kind: crate::error::SendRawEmailErrorKind::AccountSendingPausedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::account_sending_paused_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_account_sending_paused_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SendRawEmailError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ConfigurationSetDoesNotExist" => {
            crate::error::SendRawEmailError {
                meta: generic,
                kind: crate::error::SendRawEmailErrorKind::ConfigurationSetDoesNotExistException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::configuration_set_does_not_exist_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_configuration_set_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SendRawEmailError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "ConfigurationSetSendingPausedException" => crate::error::SendRawEmailError {
            meta: generic,
            kind: crate::error::SendRawEmailErrorKind::ConfigurationSetSendingPausedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::configuration_set_sending_paused_exception::Builder::default(
                        );
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_configuration_set_sending_paused_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SendRawEmailError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "MailFromDomainNotVerifiedException" => crate::error::SendRawEmailError {
            meta: generic,
            kind: crate::error::SendRawEmailErrorKind::MailFromDomainNotVerifiedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::mail_from_domain_not_verified_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_mail_from_domain_not_verified_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SendRawEmailError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "MessageRejected" => crate::error::SendRawEmailError {
            meta: generic,
            kind: crate::error::SendRawEmailErrorKind::MessageRejected({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::message_rejected::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_message_rejected_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::SendRawEmailError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::SendRawEmailError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_raw_email_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SendRawEmailOutput, crate::error::SendRawEmailError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::send_raw_email_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_send_raw_email(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::SendRawEmailError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_templated_email_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SendTemplatedEmailOutput,
    crate::error::SendTemplatedEmailError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::SendTemplatedEmailError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::SendTemplatedEmailError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccountSendingPausedException" => crate::error::SendTemplatedEmailError {
            meta: generic,
            kind: crate::error::SendTemplatedEmailErrorKind::AccountSendingPausedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::account_sending_paused_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_account_sending_paused_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SendTemplatedEmailError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ConfigurationSetDoesNotExist" => crate::error::SendTemplatedEmailError {
            meta: generic,
            kind: crate::error::SendTemplatedEmailErrorKind::ConfigurationSetDoesNotExistException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::configuration_set_does_not_exist_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_configuration_set_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SendTemplatedEmailError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "ConfigurationSetSendingPausedException" => crate::error::SendTemplatedEmailError {
            meta: generic,
            kind: crate::error::SendTemplatedEmailErrorKind::ConfigurationSetSendingPausedException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::configuration_set_sending_paused_exception::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_configuration_set_sending_paused_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SendTemplatedEmailError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "MailFromDomainNotVerifiedException" => crate::error::SendTemplatedEmailError {
            meta: generic,
            kind: crate::error::SendTemplatedEmailErrorKind::MailFromDomainNotVerifiedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::mail_from_domain_not_verified_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_mail_from_domain_not_verified_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SendTemplatedEmailError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "MessageRejected" => crate::error::SendTemplatedEmailError {
            meta: generic,
            kind: crate::error::SendTemplatedEmailErrorKind::MessageRejected({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::message_rejected::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_message_rejected_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::SendTemplatedEmailError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TemplateDoesNotExist" => crate::error::SendTemplatedEmailError {
            meta: generic,
            kind: crate::error::SendTemplatedEmailErrorKind::TemplateDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_template_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SendTemplatedEmailError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::SendTemplatedEmailError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_templated_email_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SendTemplatedEmailOutput,
    crate::error::SendTemplatedEmailError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::send_templated_email_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_send_templated_email(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::SendTemplatedEmailError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_active_receipt_rule_set_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetActiveReceiptRuleSetOutput,
    crate::error::SetActiveReceiptRuleSetError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::SetActiveReceiptRuleSetError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::SetActiveReceiptRuleSetError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "RuleSetDoesNotExist" => crate::error::SetActiveReceiptRuleSetError {
            meta: generic,
            kind: crate::error::SetActiveReceiptRuleSetErrorKind::RuleSetDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::rule_set_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_rule_set_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SetActiveReceiptRuleSetError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::SetActiveReceiptRuleSetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_active_receipt_rule_set_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetActiveReceiptRuleSetOutput,
    crate::error::SetActiveReceiptRuleSetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::set_active_receipt_rule_set_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_identity_dkim_enabled_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetIdentityDkimEnabledOutput,
    crate::error::SetIdentityDkimEnabledError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::SetIdentityDkimEnabledError::unhandled)?;
    Err(crate::error::SetIdentityDkimEnabledError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_identity_dkim_enabled_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetIdentityDkimEnabledOutput,
    crate::error::SetIdentityDkimEnabledError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::set_identity_dkim_enabled_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_identity_feedback_forwarding_enabled_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetIdentityFeedbackForwardingEnabledOutput,
    crate::error::SetIdentityFeedbackForwardingEnabledError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::SetIdentityFeedbackForwardingEnabledError::unhandled)?;
    Err(crate::error::SetIdentityFeedbackForwardingEnabledError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_identity_feedback_forwarding_enabled_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetIdentityFeedbackForwardingEnabledOutput,
    crate::error::SetIdentityFeedbackForwardingEnabledError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::set_identity_feedback_forwarding_enabled_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_identity_headers_in_notifications_enabled_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetIdentityHeadersInNotificationsEnabledOutput,
    crate::error::SetIdentityHeadersInNotificationsEnabledError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::SetIdentityHeadersInNotificationsEnabledError::unhandled)?;
    Err(crate::error::SetIdentityHeadersInNotificationsEnabledError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_identity_headers_in_notifications_enabled_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetIdentityHeadersInNotificationsEnabledOutput,
    crate::error::SetIdentityHeadersInNotificationsEnabledError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::set_identity_headers_in_notifications_enabled_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_identity_mail_from_domain_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetIdentityMailFromDomainOutput,
    crate::error::SetIdentityMailFromDomainError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::SetIdentityMailFromDomainError::unhandled)?;
    Err(crate::error::SetIdentityMailFromDomainError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_identity_mail_from_domain_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetIdentityMailFromDomainOutput,
    crate::error::SetIdentityMailFromDomainError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::set_identity_mail_from_domain_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_identity_notification_topic_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetIdentityNotificationTopicOutput,
    crate::error::SetIdentityNotificationTopicError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::SetIdentityNotificationTopicError::unhandled)?;
    Err(crate::error::SetIdentityNotificationTopicError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_identity_notification_topic_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetIdentityNotificationTopicOutput,
    crate::error::SetIdentityNotificationTopicError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::set_identity_notification_topic_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_receipt_rule_position_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetReceiptRulePositionOutput,
    crate::error::SetReceiptRulePositionError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::SetReceiptRulePositionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::SetReceiptRulePositionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "RuleDoesNotExist" => crate::error::SetReceiptRulePositionError {
            meta: generic,
            kind: crate::error::SetReceiptRulePositionErrorKind::RuleDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::rule_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_rule_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SetReceiptRulePositionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RuleSetDoesNotExist" => crate::error::SetReceiptRulePositionError {
            meta: generic,
            kind: crate::error::SetReceiptRulePositionErrorKind::RuleSetDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::rule_set_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_rule_set_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SetReceiptRulePositionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::SetReceiptRulePositionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_receipt_rule_position_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetReceiptRulePositionOutput,
    crate::error::SetReceiptRulePositionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::set_receipt_rule_position_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_test_render_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::TestRenderTemplateOutput,
    crate::error::TestRenderTemplateError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::TestRenderTemplateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TestRenderTemplateError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidRenderingParameter" => crate::error::TestRenderTemplateError {
            meta: generic,
            kind: crate::error::TestRenderTemplateErrorKind::InvalidRenderingParameterException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_rendering_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_rendering_parameter_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TestRenderTemplateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "MissingRenderingAttribute" => crate::error::TestRenderTemplateError {
            meta: generic,
            kind: crate::error::TestRenderTemplateErrorKind::MissingRenderingAttributeException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::missing_rendering_attribute_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_missing_rendering_attribute_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TestRenderTemplateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TemplateDoesNotExist" => crate::error::TestRenderTemplateError {
            meta: generic,
            kind: crate::error::TestRenderTemplateErrorKind::TemplateDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_template_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TestRenderTemplateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::TestRenderTemplateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_test_render_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::TestRenderTemplateOutput,
    crate::error::TestRenderTemplateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::test_render_template_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_test_render_template(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::TestRenderTemplateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_account_sending_enabled_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateAccountSendingEnabledOutput,
    crate::error::UpdateAccountSendingEnabledError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateAccountSendingEnabledError::unhandled)?;
    Err(crate::error::UpdateAccountSendingEnabledError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_account_sending_enabled_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateAccountSendingEnabledOutput,
    crate::error::UpdateAccountSendingEnabledError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_account_sending_enabled_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_configuration_set_event_destination_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateConfigurationSetEventDestinationOutput,
    crate::error::UpdateConfigurationSetEventDestinationError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateConfigurationSetEventDestinationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::UpdateConfigurationSetEventDestinationError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConfigurationSetDoesNotExist" => crate::error::UpdateConfigurationSetEventDestinationError { meta: generic, kind: crate::error::UpdateConfigurationSetEventDestinationErrorKind::ConfigurationSetDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::configuration_set_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_configuration_set_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateConfigurationSetEventDestinationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EventDestinationDoesNotExist" => crate::error::UpdateConfigurationSetEventDestinationError { meta: generic, kind: crate::error::UpdateConfigurationSetEventDestinationErrorKind::EventDestinationDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::event_destination_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_event_destination_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateConfigurationSetEventDestinationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCloudWatchDestination" => crate::error::UpdateConfigurationSetEventDestinationError { meta: generic, kind: crate::error::UpdateConfigurationSetEventDestinationErrorKind::InvalidCloudWatchDestinationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_cloud_watch_destination_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cloud_watch_destination_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateConfigurationSetEventDestinationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFirehoseDestination" => crate::error::UpdateConfigurationSetEventDestinationError { meta: generic, kind: crate::error::UpdateConfigurationSetEventDestinationErrorKind::InvalidFirehoseDestinationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_firehose_destination_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_firehose_destination_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateConfigurationSetEventDestinationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidSNSDestination" => crate::error::UpdateConfigurationSetEventDestinationError { meta: generic, kind: crate::error::UpdateConfigurationSetEventDestinationErrorKind::InvalidSnsDestinationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_sns_destination_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_sns_destination_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateConfigurationSetEventDestinationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateConfigurationSetEventDestinationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_configuration_set_event_destination_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateConfigurationSetEventDestinationOutput,
    crate::error::UpdateConfigurationSetEventDestinationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_configuration_set_event_destination_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_configuration_set_reputation_metrics_enabled_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateConfigurationSetReputationMetricsEnabledOutput,
    crate::error::UpdateConfigurationSetReputationMetricsEnabledError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateConfigurationSetReputationMetricsEnabledError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::UpdateConfigurationSetReputationMetricsEnabledError::unhandled(
                    generic,
                ),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConfigurationSetDoesNotExist" => crate::error::UpdateConfigurationSetReputationMetricsEnabledError { meta: generic, kind: crate::error::UpdateConfigurationSetReputationMetricsEnabledErrorKind::ConfigurationSetDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::configuration_set_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_configuration_set_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateConfigurationSetReputationMetricsEnabledError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateConfigurationSetReputationMetricsEnabledError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_configuration_set_reputation_metrics_enabled_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateConfigurationSetReputationMetricsEnabledOutput,
    crate::error::UpdateConfigurationSetReputationMetricsEnabledError,
> {
    Ok({
        #[allow(unused_mut)]let mut output = crate::output::update_configuration_set_reputation_metrics_enabled_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_configuration_set_sending_enabled_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateConfigurationSetSendingEnabledOutput,
    crate::error::UpdateConfigurationSetSendingEnabledError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateConfigurationSetSendingEnabledError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateConfigurationSetSendingEnabledError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConfigurationSetDoesNotExist" => crate::error::UpdateConfigurationSetSendingEnabledError { meta: generic, kind: crate::error::UpdateConfigurationSetSendingEnabledErrorKind::ConfigurationSetDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::configuration_set_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_configuration_set_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateConfigurationSetSendingEnabledError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateConfigurationSetSendingEnabledError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_configuration_set_sending_enabled_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateConfigurationSetSendingEnabledOutput,
    crate::error::UpdateConfigurationSetSendingEnabledError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_configuration_set_sending_enabled_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_configuration_set_tracking_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateConfigurationSetTrackingOptionsOutput,
    crate::error::UpdateConfigurationSetTrackingOptionsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateConfigurationSetTrackingOptionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::UpdateConfigurationSetTrackingOptionsError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConfigurationSetDoesNotExist" => crate::error::UpdateConfigurationSetTrackingOptionsError { meta: generic, kind: crate::error::UpdateConfigurationSetTrackingOptionsErrorKind::ConfigurationSetDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::configuration_set_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_configuration_set_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateConfigurationSetTrackingOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTrackingOptions" => crate::error::UpdateConfigurationSetTrackingOptionsError { meta: generic, kind: crate::error::UpdateConfigurationSetTrackingOptionsErrorKind::InvalidTrackingOptionsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_tracking_options_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_tracking_options_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateConfigurationSetTrackingOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TrackingOptionsDoesNotExistException" => crate::error::UpdateConfigurationSetTrackingOptionsError { meta: generic, kind: crate::error::UpdateConfigurationSetTrackingOptionsErrorKind::TrackingOptionsDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::tracking_options_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_tracking_options_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateConfigurationSetTrackingOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateConfigurationSetTrackingOptionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_configuration_set_tracking_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateConfigurationSetTrackingOptionsOutput,
    crate::error::UpdateConfigurationSetTrackingOptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_configuration_set_tracking_options_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_custom_verification_email_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateCustomVerificationEmailTemplateOutput,
    crate::error::UpdateCustomVerificationEmailTemplateError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateCustomVerificationEmailTemplateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::UpdateCustomVerificationEmailTemplateError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CustomVerificationEmailInvalidContent" => crate::error::UpdateCustomVerificationEmailTemplateError { meta: generic, kind: crate::error::UpdateCustomVerificationEmailTemplateErrorKind::CustomVerificationEmailInvalidContentException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::custom_verification_email_invalid_content_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_custom_verification_email_invalid_content_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateCustomVerificationEmailTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CustomVerificationEmailTemplateDoesNotExist" => crate::error::UpdateCustomVerificationEmailTemplateError { meta: generic, kind: crate::error::UpdateCustomVerificationEmailTemplateErrorKind::CustomVerificationEmailTemplateDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::custom_verification_email_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_custom_verification_email_template_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateCustomVerificationEmailTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FromEmailAddressNotVerified" => crate::error::UpdateCustomVerificationEmailTemplateError { meta: generic, kind: crate::error::UpdateCustomVerificationEmailTemplateErrorKind::FromEmailAddressNotVerifiedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::from_email_address_not_verified_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_from_email_address_not_verified_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateCustomVerificationEmailTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateCustomVerificationEmailTemplateError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_custom_verification_email_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateCustomVerificationEmailTemplateOutput,
    crate::error::UpdateCustomVerificationEmailTemplateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_custom_verification_email_template_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_receipt_rule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateReceiptRuleOutput, crate::error::UpdateReceiptRuleError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateReceiptRuleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateReceiptRuleError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidLambdaFunction" => crate::error::UpdateReceiptRuleError {
            meta: generic,
            kind: crate::error::UpdateReceiptRuleErrorKind::InvalidLambdaFunctionException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_lambda_function_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_lambda_function_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateReceiptRuleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidS3Configuration" => crate::error::UpdateReceiptRuleError {
            meta: generic,
            kind: crate::error::UpdateReceiptRuleErrorKind::InvalidS3ConfigurationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_s3_configuration_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_s3_configuration_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateReceiptRuleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidSnsTopic" => crate::error::UpdateReceiptRuleError {
            meta: generic,
            kind: crate::error::UpdateReceiptRuleErrorKind::InvalidSnsTopicException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_sns_topic_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_sns_topic_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateReceiptRuleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceeded" => crate::error::UpdateReceiptRuleError {
            meta: generic,
            kind: crate::error::UpdateReceiptRuleErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateReceiptRuleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RuleDoesNotExist" => crate::error::UpdateReceiptRuleError {
            meta: generic,
            kind: crate::error::UpdateReceiptRuleErrorKind::RuleDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::rule_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_rule_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateReceiptRuleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RuleSetDoesNotExist" => crate::error::UpdateReceiptRuleError {
            meta: generic,
            kind: crate::error::UpdateReceiptRuleErrorKind::RuleSetDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::rule_set_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_rule_set_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateReceiptRuleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateReceiptRuleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_receipt_rule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateReceiptRuleOutput, crate::error::UpdateReceiptRuleError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_receipt_rule_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateTemplateOutput, crate::error::UpdateTemplateError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateTemplateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateTemplateError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidTemplate" => crate::error::UpdateTemplateError {
            meta: generic,
            kind: crate::error::UpdateTemplateErrorKind::InvalidTemplateException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_template_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_template_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateTemplateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TemplateDoesNotExist" => crate::error::UpdateTemplateError {
            meta: generic,
            kind: crate::error::UpdateTemplateErrorKind::TemplateDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_template_does_not_exist_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateTemplateError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateTemplateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateTemplateOutput, crate::error::UpdateTemplateError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_template_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_verify_domain_dkim_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::VerifyDomainDkimOutput, crate::error::VerifyDomainDkimError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::VerifyDomainDkimError::unhandled)?;
    Err(crate::error::VerifyDomainDkimError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_verify_domain_dkim_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::VerifyDomainDkimOutput, crate::error::VerifyDomainDkimError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::verify_domain_dkim_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_verify_domain_dkim(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::VerifyDomainDkimError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_verify_domain_identity_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::VerifyDomainIdentityOutput,
    crate::error::VerifyDomainIdentityError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::VerifyDomainIdentityError::unhandled)?;
    Err(crate::error::VerifyDomainIdentityError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_verify_domain_identity_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::VerifyDomainIdentityOutput,
    crate::error::VerifyDomainIdentityError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::verify_domain_identity_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_verify_domain_identity(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::VerifyDomainIdentityError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_verify_email_address_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::VerifyEmailAddressOutput,
    crate::error::VerifyEmailAddressError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::VerifyEmailAddressError::unhandled)?;
    Err(crate::error::VerifyEmailAddressError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_verify_email_address_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::VerifyEmailAddressOutput,
    crate::error::VerifyEmailAddressError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::verify_email_address_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_verify_email_identity_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::VerifyEmailIdentityOutput,
    crate::error::VerifyEmailIdentityError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::VerifyEmailIdentityError::unhandled)?;
    Err(crate::error::VerifyEmailIdentityError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_verify_email_identity_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::VerifyEmailIdentityOutput,
    crate::error::VerifyEmailIdentityError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::verify_email_identity_output::Builder::default();
        let _ = response;
        output.build()
    })
}
