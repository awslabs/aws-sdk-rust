// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>For queries that originate in your VPC, detailed information about a Resolver rule, which specifies how to route DNS queries out of the VPC. The <code>ResolverRule</code> parameter appears in the response to a <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverRule.html">CreateResolverRule</a>, <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DeleteResolverRule.html">DeleteResolverRule</a>, <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRule.html">GetResolverRule</a>, <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html">ListResolverRules</a>, or <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_UpdateResolverRule.html">UpdateResolverRule</a> request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResolverRule {
    /// <p>The ID that Resolver assigned to the Resolver rule when you created it.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>A unique string that you specified when you created the Resolver rule. <code>CreatorRequestId</code> identifies the request and allows failed requests to be retried without the risk of running the operation twice. </p>
    #[doc(hidden)]
    pub creator_request_id: std::option::Option<std::string::String>,
    /// <p>The ARN (Amazon Resource Name) for the Resolver rule specified by <code>Id</code>.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>DNS queries for this domain name are forwarded to the IP addresses that are specified in <code>TargetIps</code>. If a query matches multiple Resolver rules (example.com and www.example.com), the query is routed using the Resolver rule that contains the most specific domain name (www.example.com).</p>
    #[doc(hidden)]
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>A code that specifies the current status of the Resolver rule.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::types::ResolverRuleStatus>,
    /// <p>A detailed description of the status of a Resolver rule.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
    /// <p>When you want to forward DNS queries for specified domain name to resolvers on your network, specify <code>FORWARD</code>.</p>
    /// <p>When you have a forwarding rule to forward DNS queries for a domain to your network and you want Resolver to process queries for a subdomain of that domain, specify <code>SYSTEM</code>.</p>
    /// <p>For example, to forward DNS queries for example.com to resolvers on your network, you create a rule and specify <code>FORWARD</code> for <code>RuleType</code>. To then have Resolver process queries for apex.example.com, you create a rule and specify <code>SYSTEM</code> for <code>RuleType</code>.</p>
    /// <p>Currently, only Resolver can create rules that have a value of <code>RECURSIVE</code> for <code>RuleType</code>.</p>
    #[doc(hidden)]
    pub rule_type: std::option::Option<crate::types::RuleTypeOption>,
    /// <p>The name for the Resolver rule, which you specified when you created the Resolver rule.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>An array that contains the IP addresses and ports that an outbound endpoint forwards DNS queries to. Typically, these are the IP addresses of DNS resolvers on your network. Specify IPv4 addresses. IPv6 is not supported.</p>
    #[doc(hidden)]
    pub target_ips: std::option::Option<std::vec::Vec<crate::types::TargetAddress>>,
    /// <p>The ID of the endpoint that the rule is associated with.</p>
    #[doc(hidden)]
    pub resolver_endpoint_id: std::option::Option<std::string::String>,
    /// <p>When a rule is shared with another Amazon Web Services account, the account ID of the account that the rule is shared with.</p>
    #[doc(hidden)]
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>Whether the rule is shared and, if so, whether the current account is sharing the rule with another account, or another account is sharing the rule with the current account.</p>
    #[doc(hidden)]
    pub share_status: std::option::Option<crate::types::ShareStatus>,
    /// <p>The date and time that the Resolver rule was created, in Unix time format and Coordinated Universal Time (UTC).</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<std::string::String>,
    /// <p>The date and time that the Resolver rule was last updated, in Unix time format and Coordinated Universal Time (UTC).</p>
    #[doc(hidden)]
    pub modification_time: std::option::Option<std::string::String>,
}
impl ResolverRule {
    /// <p>The ID that Resolver assigned to the Resolver rule when you created it.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>A unique string that you specified when you created the Resolver rule. <code>CreatorRequestId</code> identifies the request and allows failed requests to be retried without the risk of running the operation twice. </p>
    pub fn creator_request_id(&self) -> std::option::Option<&str> {
        self.creator_request_id.as_deref()
    }
    /// <p>The ARN (Amazon Resource Name) for the Resolver rule specified by <code>Id</code>.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>DNS queries for this domain name are forwarded to the IP addresses that are specified in <code>TargetIps</code>. If a query matches multiple Resolver rules (example.com and www.example.com), the query is routed using the Resolver rule that contains the most specific domain name (www.example.com).</p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>A code that specifies the current status of the Resolver rule.</p>
    pub fn status(&self) -> std::option::Option<&crate::types::ResolverRuleStatus> {
        self.status.as_ref()
    }
    /// <p>A detailed description of the status of a Resolver rule.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>When you want to forward DNS queries for specified domain name to resolvers on your network, specify <code>FORWARD</code>.</p>
    /// <p>When you have a forwarding rule to forward DNS queries for a domain to your network and you want Resolver to process queries for a subdomain of that domain, specify <code>SYSTEM</code>.</p>
    /// <p>For example, to forward DNS queries for example.com to resolvers on your network, you create a rule and specify <code>FORWARD</code> for <code>RuleType</code>. To then have Resolver process queries for apex.example.com, you create a rule and specify <code>SYSTEM</code> for <code>RuleType</code>.</p>
    /// <p>Currently, only Resolver can create rules that have a value of <code>RECURSIVE</code> for <code>RuleType</code>.</p>
    pub fn rule_type(&self) -> std::option::Option<&crate::types::RuleTypeOption> {
        self.rule_type.as_ref()
    }
    /// <p>The name for the Resolver rule, which you specified when you created the Resolver rule.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>An array that contains the IP addresses and ports that an outbound endpoint forwards DNS queries to. Typically, these are the IP addresses of DNS resolvers on your network. Specify IPv4 addresses. IPv6 is not supported.</p>
    pub fn target_ips(&self) -> std::option::Option<&[crate::types::TargetAddress]> {
        self.target_ips.as_deref()
    }
    /// <p>The ID of the endpoint that the rule is associated with.</p>
    pub fn resolver_endpoint_id(&self) -> std::option::Option<&str> {
        self.resolver_endpoint_id.as_deref()
    }
    /// <p>When a rule is shared with another Amazon Web Services account, the account ID of the account that the rule is shared with.</p>
    pub fn owner_id(&self) -> std::option::Option<&str> {
        self.owner_id.as_deref()
    }
    /// <p>Whether the rule is shared and, if so, whether the current account is sharing the rule with another account, or another account is sharing the rule with the current account.</p>
    pub fn share_status(&self) -> std::option::Option<&crate::types::ShareStatus> {
        self.share_status.as_ref()
    }
    /// <p>The date and time that the Resolver rule was created, in Unix time format and Coordinated Universal Time (UTC).</p>
    pub fn creation_time(&self) -> std::option::Option<&str> {
        self.creation_time.as_deref()
    }
    /// <p>The date and time that the Resolver rule was last updated, in Unix time format and Coordinated Universal Time (UTC).</p>
    pub fn modification_time(&self) -> std::option::Option<&str> {
        self.modification_time.as_deref()
    }
}
impl ResolverRule {
    /// Creates a new builder-style object to manufacture [`ResolverRule`](crate::types::ResolverRule).
    pub fn builder() -> crate::types::builders::ResolverRuleBuilder {
        crate::types::builders::ResolverRuleBuilder::default()
    }
}

/// A builder for [`ResolverRule`](crate::types::ResolverRule).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct ResolverRuleBuilder {
    pub(crate) id: std::option::Option<std::string::String>,
    pub(crate) creator_request_id: std::option::Option<std::string::String>,
    pub(crate) arn: std::option::Option<std::string::String>,
    pub(crate) domain_name: std::option::Option<std::string::String>,
    pub(crate) status: std::option::Option<crate::types::ResolverRuleStatus>,
    pub(crate) status_message: std::option::Option<std::string::String>,
    pub(crate) rule_type: std::option::Option<crate::types::RuleTypeOption>,
    pub(crate) name: std::option::Option<std::string::String>,
    pub(crate) target_ips: std::option::Option<std::vec::Vec<crate::types::TargetAddress>>,
    pub(crate) resolver_endpoint_id: std::option::Option<std::string::String>,
    pub(crate) owner_id: std::option::Option<std::string::String>,
    pub(crate) share_status: std::option::Option<crate::types::ShareStatus>,
    pub(crate) creation_time: std::option::Option<std::string::String>,
    pub(crate) modification_time: std::option::Option<std::string::String>,
}
impl ResolverRuleBuilder {
    /// <p>The ID that Resolver assigned to the Resolver rule when you created it.</p>
    pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
        self.id = Some(input.into());
        self
    }
    /// <p>The ID that Resolver assigned to the Resolver rule when you created it.</p>
    pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.id = input;
        self
    }
    /// <p>A unique string that you specified when you created the Resolver rule. <code>CreatorRequestId</code> identifies the request and allows failed requests to be retried without the risk of running the operation twice. </p>
    pub fn creator_request_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.creator_request_id = Some(input.into());
        self
    }
    /// <p>A unique string that you specified when you created the Resolver rule. <code>CreatorRequestId</code> identifies the request and allows failed requests to be retried without the risk of running the operation twice. </p>
    pub fn set_creator_request_id(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.creator_request_id = input;
        self
    }
    /// <p>The ARN (Amazon Resource Name) for the Resolver rule specified by <code>Id</code>.</p>
    pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.arn = Some(input.into());
        self
    }
    /// <p>The ARN (Amazon Resource Name) for the Resolver rule specified by <code>Id</code>.</p>
    pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.arn = input;
        self
    }
    /// <p>DNS queries for this domain name are forwarded to the IP addresses that are specified in <code>TargetIps</code>. If a query matches multiple Resolver rules (example.com and www.example.com), the query is routed using the Resolver rule that contains the most specific domain name (www.example.com).</p>
    pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.domain_name = Some(input.into());
        self
    }
    /// <p>DNS queries for this domain name are forwarded to the IP addresses that are specified in <code>TargetIps</code>. If a query matches multiple Resolver rules (example.com and www.example.com), the query is routed using the Resolver rule that contains the most specific domain name (www.example.com).</p>
    pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.domain_name = input;
        self
    }
    /// <p>A code that specifies the current status of the Resolver rule.</p>
    pub fn status(mut self, input: crate::types::ResolverRuleStatus) -> Self {
        self.status = Some(input);
        self
    }
    /// <p>A code that specifies the current status of the Resolver rule.</p>
    pub fn set_status(
        mut self,
        input: std::option::Option<crate::types::ResolverRuleStatus>,
    ) -> Self {
        self.status = input;
        self
    }
    /// <p>A detailed description of the status of a Resolver rule.</p>
    pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
        self.status_message = Some(input.into());
        self
    }
    /// <p>A detailed description of the status of a Resolver rule.</p>
    pub fn set_status_message(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.status_message = input;
        self
    }
    /// <p>When you want to forward DNS queries for specified domain name to resolvers on your network, specify <code>FORWARD</code>.</p>
    /// <p>When you have a forwarding rule to forward DNS queries for a domain to your network and you want Resolver to process queries for a subdomain of that domain, specify <code>SYSTEM</code>.</p>
    /// <p>For example, to forward DNS queries for example.com to resolvers on your network, you create a rule and specify <code>FORWARD</code> for <code>RuleType</code>. To then have Resolver process queries for apex.example.com, you create a rule and specify <code>SYSTEM</code> for <code>RuleType</code>.</p>
    /// <p>Currently, only Resolver can create rules that have a value of <code>RECURSIVE</code> for <code>RuleType</code>.</p>
    pub fn rule_type(mut self, input: crate::types::RuleTypeOption) -> Self {
        self.rule_type = Some(input);
        self
    }
    /// <p>When you want to forward DNS queries for specified domain name to resolvers on your network, specify <code>FORWARD</code>.</p>
    /// <p>When you have a forwarding rule to forward DNS queries for a domain to your network and you want Resolver to process queries for a subdomain of that domain, specify <code>SYSTEM</code>.</p>
    /// <p>For example, to forward DNS queries for example.com to resolvers on your network, you create a rule and specify <code>FORWARD</code> for <code>RuleType</code>. To then have Resolver process queries for apex.example.com, you create a rule and specify <code>SYSTEM</code> for <code>RuleType</code>.</p>
    /// <p>Currently, only Resolver can create rules that have a value of <code>RECURSIVE</code> for <code>RuleType</code>.</p>
    pub fn set_rule_type(
        mut self,
        input: std::option::Option<crate::types::RuleTypeOption>,
    ) -> Self {
        self.rule_type = input;
        self
    }
    /// <p>The name for the Resolver rule, which you specified when you created the Resolver rule.</p>
    pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
        self.name = Some(input.into());
        self
    }
    /// <p>The name for the Resolver rule, which you specified when you created the Resolver rule.</p>
    pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// Appends an item to `target_ips`.
    ///
    /// To override the contents of this collection use [`set_target_ips`](Self::set_target_ips).
    ///
    /// <p>An array that contains the IP addresses and ports that an outbound endpoint forwards DNS queries to. Typically, these are the IP addresses of DNS resolvers on your network. Specify IPv4 addresses. IPv6 is not supported.</p>
    pub fn target_ips(mut self, input: crate::types::TargetAddress) -> Self {
        let mut v = self.target_ips.unwrap_or_default();
        v.push(input);
        self.target_ips = Some(v);
        self
    }
    /// <p>An array that contains the IP addresses and ports that an outbound endpoint forwards DNS queries to. Typically, these are the IP addresses of DNS resolvers on your network. Specify IPv4 addresses. IPv6 is not supported.</p>
    pub fn set_target_ips(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::TargetAddress>>,
    ) -> Self {
        self.target_ips = input;
        self
    }
    /// <p>The ID of the endpoint that the rule is associated with.</p>
    pub fn resolver_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.resolver_endpoint_id = Some(input.into());
        self
    }
    /// <p>The ID of the endpoint that the rule is associated with.</p>
    pub fn set_resolver_endpoint_id(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.resolver_endpoint_id = input;
        self
    }
    /// <p>When a rule is shared with another Amazon Web Services account, the account ID of the account that the rule is shared with.</p>
    pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.owner_id = Some(input.into());
        self
    }
    /// <p>When a rule is shared with another Amazon Web Services account, the account ID of the account that the rule is shared with.</p>
    pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.owner_id = input;
        self
    }
    /// <p>Whether the rule is shared and, if so, whether the current account is sharing the rule with another account, or another account is sharing the rule with the current account.</p>
    pub fn share_status(mut self, input: crate::types::ShareStatus) -> Self {
        self.share_status = Some(input);
        self
    }
    /// <p>Whether the rule is shared and, if so, whether the current account is sharing the rule with another account, or another account is sharing the rule with the current account.</p>
    pub fn set_share_status(
        mut self,
        input: std::option::Option<crate::types::ShareStatus>,
    ) -> Self {
        self.share_status = input;
        self
    }
    /// <p>The date and time that the Resolver rule was created, in Unix time format and Coordinated Universal Time (UTC).</p>
    pub fn creation_time(mut self, input: impl Into<std::string::String>) -> Self {
        self.creation_time = Some(input.into());
        self
    }
    /// <p>The date and time that the Resolver rule was created, in Unix time format and Coordinated Universal Time (UTC).</p>
    pub fn set_creation_time(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.creation_time = input;
        self
    }
    /// <p>The date and time that the Resolver rule was last updated, in Unix time format and Coordinated Universal Time (UTC).</p>
    pub fn modification_time(mut self, input: impl Into<std::string::String>) -> Self {
        self.modification_time = Some(input.into());
        self
    }
    /// <p>The date and time that the Resolver rule was last updated, in Unix time format and Coordinated Universal Time (UTC).</p>
    pub fn set_modification_time(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.modification_time = input;
        self
    }
    /// Consumes the builder and constructs a [`ResolverRule`](crate::types::ResolverRule).
    pub fn build(self) -> crate::types::ResolverRule {
        crate::types::ResolverRule {
            id: self.id,
            creator_request_id: self.creator_request_id,
            arn: self.arn,
            domain_name: self.domain_name,
            status: self.status,
            status_message: self.status_message,
            rule_type: self.rule_type,
            name: self.name,
            target_ips: self.target_ips,
            resolver_endpoint_id: self.resolver_endpoint_id,
            owner_id: self.owner_id,
            share_status: self.share_status,
            creation_time: self.creation_time,
            modification_time: self.modification_time,
        }
    }
}
