// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Associates a <a>FirewallRuleGroup</a> with a VPC, to provide DNS filtering for the VPC. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AssociateFirewallRuleGroup {
    _private: (),
}
impl AssociateFirewallRuleGroup {
    /// Creates a new builder-style object to manufacture [`AssociateFirewallRuleGroupInput`](crate::input::AssociateFirewallRuleGroupInput)
    pub fn builder() -> crate::input::associate_firewall_rule_group_input::Builder {
        crate::input::associate_firewall_rule_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AssociateFirewallRuleGroup {
    type Output = std::result::Result<
        crate::output::AssociateFirewallRuleGroupOutput,
        crate::error::AssociateFirewallRuleGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_associate_firewall_rule_group_error(response)
        } else {
            crate::operation_deser::parse_associate_firewall_rule_group_response(response)
        }
    }
}

/// <p>Adds IP addresses to an inbound or an outbound Resolver endpoint. If you want to add more than one IP address,
/// submit one <code>AssociateResolverEndpointIpAddress</code> request for each IP address.</p>
/// <p>To remove an IP address from an endpoint, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverEndpointIpAddress.html">DisassociateResolverEndpointIpAddress</a>.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AssociateResolverEndpointIpAddress {
    _private: (),
}
impl AssociateResolverEndpointIpAddress {
    /// Creates a new builder-style object to manufacture [`AssociateResolverEndpointIpAddressInput`](crate::input::AssociateResolverEndpointIpAddressInput)
    pub fn builder() -> crate::input::associate_resolver_endpoint_ip_address_input::Builder {
        crate::input::associate_resolver_endpoint_ip_address_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AssociateResolverEndpointIpAddress {
    type Output = std::result::Result<
        crate::output::AssociateResolverEndpointIpAddressOutput,
        crate::error::AssociateResolverEndpointIpAddressError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_associate_resolver_endpoint_ip_address_error(response)
        } else {
            crate::operation_deser::parse_associate_resolver_endpoint_ip_address_response(response)
        }
    }
}

/// <p>Associates an Amazon VPC with a specified query logging configuration. Route 53 Resolver logs DNS queries that originate in all of the Amazon VPCs
/// that are associated with a specified query logging configuration. To associate more than one VPC with a configuration, submit one <code>AssociateResolverQueryLogConfig</code>
/// request for each VPC.</p>
/// <note>
/// <p>The VPCs that you associate with a query logging configuration must be in the same Region as the configuration.</p>
/// </note>
/// <p>To remove a VPC from a query logging configuration, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverQueryLogConfig.html">DisassociateResolverQueryLogConfig</a>.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AssociateResolverQueryLogConfig {
    _private: (),
}
impl AssociateResolverQueryLogConfig {
    /// Creates a new builder-style object to manufacture [`AssociateResolverQueryLogConfigInput`](crate::input::AssociateResolverQueryLogConfigInput)
    pub fn builder() -> crate::input::associate_resolver_query_log_config_input::Builder {
        crate::input::associate_resolver_query_log_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AssociateResolverQueryLogConfig {
    type Output = std::result::Result<
        crate::output::AssociateResolverQueryLogConfigOutput,
        crate::error::AssociateResolverQueryLogConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_associate_resolver_query_log_config_error(response)
        } else {
            crate::operation_deser::parse_associate_resolver_query_log_config_response(response)
        }
    }
}

/// <p>Associates a Resolver rule with a VPC. When you associate a rule with a VPC, Resolver forwards all DNS queries
/// for the domain name that is specified in the rule and that originate in the VPC. The queries are forwarded to the
/// IP addresses for the DNS resolvers that are specified in the rule. For more information about rules, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverRule.html">CreateResolverRule</a>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AssociateResolverRule {
    _private: (),
}
impl AssociateResolverRule {
    /// Creates a new builder-style object to manufacture [`AssociateResolverRuleInput`](crate::input::AssociateResolverRuleInput)
    pub fn builder() -> crate::input::associate_resolver_rule_input::Builder {
        crate::input::associate_resolver_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AssociateResolverRule {
    type Output = std::result::Result<
        crate::output::AssociateResolverRuleOutput,
        crate::error::AssociateResolverRuleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_associate_resolver_rule_error(response)
        } else {
            crate::operation_deser::parse_associate_resolver_rule_response(response)
        }
    }
}

/// <p>Creates an empty firewall domain list for use in DNS Firewall rules. You can populate the domains for the new list with a file, using <a>ImportFirewallDomains</a>, or with domain strings, using <a>UpdateFirewallDomains</a>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateFirewallDomainList {
    _private: (),
}
impl CreateFirewallDomainList {
    /// Creates a new builder-style object to manufacture [`CreateFirewallDomainListInput`](crate::input::CreateFirewallDomainListInput)
    pub fn builder() -> crate::input::create_firewall_domain_list_input::Builder {
        crate::input::create_firewall_domain_list_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateFirewallDomainList {
    type Output = std::result::Result<
        crate::output::CreateFirewallDomainListOutput,
        crate::error::CreateFirewallDomainListError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_firewall_domain_list_error(response)
        } else {
            crate::operation_deser::parse_create_firewall_domain_list_response(response)
        }
    }
}

/// <p>Creates a single DNS Firewall rule in the specified rule group, using the specified domain list.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateFirewallRule {
    _private: (),
}
impl CreateFirewallRule {
    /// Creates a new builder-style object to manufacture [`CreateFirewallRuleInput`](crate::input::CreateFirewallRuleInput)
    pub fn builder() -> crate::input::create_firewall_rule_input::Builder {
        crate::input::create_firewall_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateFirewallRule {
    type Output = std::result::Result<
        crate::output::CreateFirewallRuleOutput,
        crate::error::CreateFirewallRuleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_firewall_rule_error(response)
        } else {
            crate::operation_deser::parse_create_firewall_rule_response(response)
        }
    }
}

/// <p>Creates an empty DNS Firewall rule group for filtering DNS network traffic in a VPC. You can add rules to the new rule group
/// by calling <a>CreateFirewallRule</a>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateFirewallRuleGroup {
    _private: (),
}
impl CreateFirewallRuleGroup {
    /// Creates a new builder-style object to manufacture [`CreateFirewallRuleGroupInput`](crate::input::CreateFirewallRuleGroupInput)
    pub fn builder() -> crate::input::create_firewall_rule_group_input::Builder {
        crate::input::create_firewall_rule_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateFirewallRuleGroup {
    type Output = std::result::Result<
        crate::output::CreateFirewallRuleGroupOutput,
        crate::error::CreateFirewallRuleGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_firewall_rule_group_error(response)
        } else {
            crate::operation_deser::parse_create_firewall_rule_group_response(response)
        }
    }
}

/// <p>Creates a Resolver endpoint. There are two types of Resolver endpoints, inbound and outbound:</p>
/// <ul>
/// <li>
/// <p>An <i>inbound Resolver endpoint</i> forwards DNS queries to the DNS service for a VPC
/// from your network.</p>
/// </li>
/// <li>
/// <p>An <i>outbound Resolver endpoint</i> forwards DNS queries from the DNS service for a VPC
/// to your network.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateResolverEndpoint {
    _private: (),
}
impl CreateResolverEndpoint {
    /// Creates a new builder-style object to manufacture [`CreateResolverEndpointInput`](crate::input::CreateResolverEndpointInput)
    pub fn builder() -> crate::input::create_resolver_endpoint_input::Builder {
        crate::input::create_resolver_endpoint_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateResolverEndpoint {
    type Output = std::result::Result<
        crate::output::CreateResolverEndpointOutput,
        crate::error::CreateResolverEndpointError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_resolver_endpoint_error(response)
        } else {
            crate::operation_deser::parse_create_resolver_endpoint_response(response)
        }
    }
}

/// <p>Creates a Resolver query logging configuration, which defines where you want Resolver to save DNS query logs that originate in your VPCs.
/// Resolver can log queries only for VPCs that are in the same Region as the query logging configuration.</p>
/// <p>To specify which VPCs you want to log queries for, you use <code>AssociateResolverQueryLogConfig</code>. For more information, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverQueryLogConfig.html">AssociateResolverQueryLogConfig</a>. </p>
/// <p>You can optionally use Resource Access Manager (RAM) to share a query logging configuration with other Amazon Web Services accounts. The other accounts
/// can then associate VPCs with the configuration. The query logs that Resolver creates for a configuration include all DNS queries that originate in all
/// VPCs that are associated with the configuration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateResolverQueryLogConfig {
    _private: (),
}
impl CreateResolverQueryLogConfig {
    /// Creates a new builder-style object to manufacture [`CreateResolverQueryLogConfigInput`](crate::input::CreateResolverQueryLogConfigInput)
    pub fn builder() -> crate::input::create_resolver_query_log_config_input::Builder {
        crate::input::create_resolver_query_log_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateResolverQueryLogConfig {
    type Output = std::result::Result<
        crate::output::CreateResolverQueryLogConfigOutput,
        crate::error::CreateResolverQueryLogConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_resolver_query_log_config_error(response)
        } else {
            crate::operation_deser::parse_create_resolver_query_log_config_response(response)
        }
    }
}

/// <p>For DNS queries that originate in your VPCs, specifies which Resolver endpoint the queries pass through,
/// one domain name that you want to forward to your network, and the IP addresses of the DNS resolvers in your network.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateResolverRule {
    _private: (),
}
impl CreateResolverRule {
    /// Creates a new builder-style object to manufacture [`CreateResolverRuleInput`](crate::input::CreateResolverRuleInput)
    pub fn builder() -> crate::input::create_resolver_rule_input::Builder {
        crate::input::create_resolver_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateResolverRule {
    type Output = std::result::Result<
        crate::output::CreateResolverRuleOutput,
        crate::error::CreateResolverRuleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_resolver_rule_error(response)
        } else {
            crate::operation_deser::parse_create_resolver_rule_response(response)
        }
    }
}

/// <p>Deletes the specified domain list. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteFirewallDomainList {
    _private: (),
}
impl DeleteFirewallDomainList {
    /// Creates a new builder-style object to manufacture [`DeleteFirewallDomainListInput`](crate::input::DeleteFirewallDomainListInput)
    pub fn builder() -> crate::input::delete_firewall_domain_list_input::Builder {
        crate::input::delete_firewall_domain_list_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteFirewallDomainList {
    type Output = std::result::Result<
        crate::output::DeleteFirewallDomainListOutput,
        crate::error::DeleteFirewallDomainListError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_firewall_domain_list_error(response)
        } else {
            crate::operation_deser::parse_delete_firewall_domain_list_response(response)
        }
    }
}

/// <p>Deletes the specified firewall rule.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteFirewallRule {
    _private: (),
}
impl DeleteFirewallRule {
    /// Creates a new builder-style object to manufacture [`DeleteFirewallRuleInput`](crate::input::DeleteFirewallRuleInput)
    pub fn builder() -> crate::input::delete_firewall_rule_input::Builder {
        crate::input::delete_firewall_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteFirewallRule {
    type Output = std::result::Result<
        crate::output::DeleteFirewallRuleOutput,
        crate::error::DeleteFirewallRuleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_firewall_rule_error(response)
        } else {
            crate::operation_deser::parse_delete_firewall_rule_response(response)
        }
    }
}

/// <p>Deletes the specified firewall rule group. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteFirewallRuleGroup {
    _private: (),
}
impl DeleteFirewallRuleGroup {
    /// Creates a new builder-style object to manufacture [`DeleteFirewallRuleGroupInput`](crate::input::DeleteFirewallRuleGroupInput)
    pub fn builder() -> crate::input::delete_firewall_rule_group_input::Builder {
        crate::input::delete_firewall_rule_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteFirewallRuleGroup {
    type Output = std::result::Result<
        crate::output::DeleteFirewallRuleGroupOutput,
        crate::error::DeleteFirewallRuleGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_firewall_rule_group_error(response)
        } else {
            crate::operation_deser::parse_delete_firewall_rule_group_response(response)
        }
    }
}

/// <p>Deletes a Resolver endpoint. The effect of deleting a Resolver endpoint depends on whether it's an inbound or an outbound
/// Resolver endpoint:</p>
/// <ul>
/// <li>
/// <p>
/// <b>Inbound</b>: DNS queries from your network are no longer routed
/// to the DNS service for the specified VPC.</p>
/// </li>
/// <li>
/// <p>
/// <b>Outbound</b>: DNS queries from a VPC are no longer routed to your network.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteResolverEndpoint {
    _private: (),
}
impl DeleteResolverEndpoint {
    /// Creates a new builder-style object to manufacture [`DeleteResolverEndpointInput`](crate::input::DeleteResolverEndpointInput)
    pub fn builder() -> crate::input::delete_resolver_endpoint_input::Builder {
        crate::input::delete_resolver_endpoint_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteResolverEndpoint {
    type Output = std::result::Result<
        crate::output::DeleteResolverEndpointOutput,
        crate::error::DeleteResolverEndpointError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_resolver_endpoint_error(response)
        } else {
            crate::operation_deser::parse_delete_resolver_endpoint_response(response)
        }
    }
}

/// <p>Deletes a query logging configuration. When you delete a configuration, Resolver stops logging DNS queries for all of the Amazon VPCs that are
/// associated with the configuration. This also applies if the query logging configuration is shared with other Amazon Web Services accounts, and
/// the other accounts have associated VPCs with the shared configuration.</p>
/// <p>Before you can delete a query logging configuration, you must first disassociate all VPCs from the configuration. See
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverQueryLogConfig.html">DisassociateResolverQueryLogConfig</a>.</p>
/// <p>If you used Resource Access Manager (RAM) to share a query logging configuration with other accounts, you must stop sharing
/// the configuration before you can delete a configuration. The accounts that you shared the configuration with can first disassociate VPCs
/// that they associated with the configuration, but that's not necessary. If you stop sharing the configuration, those VPCs are automatically
/// disassociated from the configuration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteResolverQueryLogConfig {
    _private: (),
}
impl DeleteResolverQueryLogConfig {
    /// Creates a new builder-style object to manufacture [`DeleteResolverQueryLogConfigInput`](crate::input::DeleteResolverQueryLogConfigInput)
    pub fn builder() -> crate::input::delete_resolver_query_log_config_input::Builder {
        crate::input::delete_resolver_query_log_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteResolverQueryLogConfig {
    type Output = std::result::Result<
        crate::output::DeleteResolverQueryLogConfigOutput,
        crate::error::DeleteResolverQueryLogConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_resolver_query_log_config_error(response)
        } else {
            crate::operation_deser::parse_delete_resolver_query_log_config_response(response)
        }
    }
}

/// <p>Deletes a Resolver rule. Before you can delete a Resolver rule, you must disassociate it from all the VPCs that you
/// associated the Resolver rule with. For more information, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverRule.html">DisassociateResolverRule</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteResolverRule {
    _private: (),
}
impl DeleteResolverRule {
    /// Creates a new builder-style object to manufacture [`DeleteResolverRuleInput`](crate::input::DeleteResolverRuleInput)
    pub fn builder() -> crate::input::delete_resolver_rule_input::Builder {
        crate::input::delete_resolver_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteResolverRule {
    type Output = std::result::Result<
        crate::output::DeleteResolverRuleOutput,
        crate::error::DeleteResolverRuleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_resolver_rule_error(response)
        } else {
            crate::operation_deser::parse_delete_resolver_rule_response(response)
        }
    }
}

/// <p>Disassociates a <a>FirewallRuleGroup</a> from a VPC, to remove DNS filtering from the VPC. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisassociateFirewallRuleGroup {
    _private: (),
}
impl DisassociateFirewallRuleGroup {
    /// Creates a new builder-style object to manufacture [`DisassociateFirewallRuleGroupInput`](crate::input::DisassociateFirewallRuleGroupInput)
    pub fn builder() -> crate::input::disassociate_firewall_rule_group_input::Builder {
        crate::input::disassociate_firewall_rule_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisassociateFirewallRuleGroup {
    type Output = std::result::Result<
        crate::output::DisassociateFirewallRuleGroupOutput,
        crate::error::DisassociateFirewallRuleGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_disassociate_firewall_rule_group_error(response)
        } else {
            crate::operation_deser::parse_disassociate_firewall_rule_group_response(response)
        }
    }
}

/// <p>Removes IP addresses from an inbound or an outbound Resolver endpoint. If you want to remove more than one IP address,
/// submit one <code>DisassociateResolverEndpointIpAddress</code> request for each IP address.</p>
/// <p>To add an IP address to an endpoint, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverEndpointIpAddress.html">AssociateResolverEndpointIpAddress</a>.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisassociateResolverEndpointIpAddress {
    _private: (),
}
impl DisassociateResolverEndpointIpAddress {
    /// Creates a new builder-style object to manufacture [`DisassociateResolverEndpointIpAddressInput`](crate::input::DisassociateResolverEndpointIpAddressInput)
    pub fn builder() -> crate::input::disassociate_resolver_endpoint_ip_address_input::Builder {
        crate::input::disassociate_resolver_endpoint_ip_address_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisassociateResolverEndpointIpAddress {
    type Output = std::result::Result<
        crate::output::DisassociateResolverEndpointIpAddressOutput,
        crate::error::DisassociateResolverEndpointIpAddressError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_disassociate_resolver_endpoint_ip_address_error(response)
        } else {
            crate::operation_deser::parse_disassociate_resolver_endpoint_ip_address_response(
                response,
            )
        }
    }
}

/// <p>Disassociates a VPC from a query logging configuration.</p>
/// <note>
/// <p>Before you can delete a query logging configuration, you must first disassociate all VPCs
/// from the configuration. If you used Resource Access Manager (RAM) to share a
/// query logging configuration with other accounts, VPCs can be disassociated from the
/// configuration in the following ways:</p>
/// <ul>
/// <li>
/// <p>The accounts that you shared the configuration with can disassociate VPCs from the configuration.</p>
/// </li>
/// <li>
/// <p>You can stop sharing the configuration.</p>
/// </li>
/// </ul>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisassociateResolverQueryLogConfig {
    _private: (),
}
impl DisassociateResolverQueryLogConfig {
    /// Creates a new builder-style object to manufacture [`DisassociateResolverQueryLogConfigInput`](crate::input::DisassociateResolverQueryLogConfigInput)
    pub fn builder() -> crate::input::disassociate_resolver_query_log_config_input::Builder {
        crate::input::disassociate_resolver_query_log_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisassociateResolverQueryLogConfig {
    type Output = std::result::Result<
        crate::output::DisassociateResolverQueryLogConfigOutput,
        crate::error::DisassociateResolverQueryLogConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_disassociate_resolver_query_log_config_error(response)
        } else {
            crate::operation_deser::parse_disassociate_resolver_query_log_config_response(response)
        }
    }
}

/// <p>Removes the association between a specified Resolver rule and a specified VPC.</p>
/// <important>
/// <p>If you disassociate a Resolver rule from a VPC, Resolver stops forwarding DNS queries for the
/// domain name that you specified in the Resolver rule. </p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisassociateResolverRule {
    _private: (),
}
impl DisassociateResolverRule {
    /// Creates a new builder-style object to manufacture [`DisassociateResolverRuleInput`](crate::input::DisassociateResolverRuleInput)
    pub fn builder() -> crate::input::disassociate_resolver_rule_input::Builder {
        crate::input::disassociate_resolver_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisassociateResolverRule {
    type Output = std::result::Result<
        crate::output::DisassociateResolverRuleOutput,
        crate::error::DisassociateResolverRuleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_disassociate_resolver_rule_error(response)
        } else {
            crate::operation_deser::parse_disassociate_resolver_rule_response(response)
        }
    }
}

/// <p>Retrieves the configuration of the firewall behavior provided by DNS Firewall for a
/// single VPC from Amazon Virtual Private Cloud (Amazon VPC). </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetFirewallConfig {
    _private: (),
}
impl GetFirewallConfig {
    /// Creates a new builder-style object to manufacture [`GetFirewallConfigInput`](crate::input::GetFirewallConfigInput)
    pub fn builder() -> crate::input::get_firewall_config_input::Builder {
        crate::input::get_firewall_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetFirewallConfig {
    type Output = std::result::Result<
        crate::output::GetFirewallConfigOutput,
        crate::error::GetFirewallConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_firewall_config_error(response)
        } else {
            crate::operation_deser::parse_get_firewall_config_response(response)
        }
    }
}

/// <p>Retrieves the specified firewall domain list.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetFirewallDomainList {
    _private: (),
}
impl GetFirewallDomainList {
    /// Creates a new builder-style object to manufacture [`GetFirewallDomainListInput`](crate::input::GetFirewallDomainListInput)
    pub fn builder() -> crate::input::get_firewall_domain_list_input::Builder {
        crate::input::get_firewall_domain_list_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetFirewallDomainList {
    type Output = std::result::Result<
        crate::output::GetFirewallDomainListOutput,
        crate::error::GetFirewallDomainListError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_firewall_domain_list_error(response)
        } else {
            crate::operation_deser::parse_get_firewall_domain_list_response(response)
        }
    }
}

/// <p>Retrieves the specified firewall rule group. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetFirewallRuleGroup {
    _private: (),
}
impl GetFirewallRuleGroup {
    /// Creates a new builder-style object to manufacture [`GetFirewallRuleGroupInput`](crate::input::GetFirewallRuleGroupInput)
    pub fn builder() -> crate::input::get_firewall_rule_group_input::Builder {
        crate::input::get_firewall_rule_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetFirewallRuleGroup {
    type Output = std::result::Result<
        crate::output::GetFirewallRuleGroupOutput,
        crate::error::GetFirewallRuleGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_firewall_rule_group_error(response)
        } else {
            crate::operation_deser::parse_get_firewall_rule_group_response(response)
        }
    }
}

/// <p>Retrieves a firewall rule group association, which enables DNS filtering for a VPC with one rule group. A VPC can have more than one firewall rule group association, and a rule group can be associated with more than one VPC.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetFirewallRuleGroupAssociation {
    _private: (),
}
impl GetFirewallRuleGroupAssociation {
    /// Creates a new builder-style object to manufacture [`GetFirewallRuleGroupAssociationInput`](crate::input::GetFirewallRuleGroupAssociationInput)
    pub fn builder() -> crate::input::get_firewall_rule_group_association_input::Builder {
        crate::input::get_firewall_rule_group_association_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetFirewallRuleGroupAssociation {
    type Output = std::result::Result<
        crate::output::GetFirewallRuleGroupAssociationOutput,
        crate::error::GetFirewallRuleGroupAssociationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_firewall_rule_group_association_error(response)
        } else {
            crate::operation_deser::parse_get_firewall_rule_group_association_response(response)
        }
    }
}

/// <p>Returns the Identity and Access Management (Amazon Web Services IAM) policy for sharing the
/// specified rule group. You can use the policy to share the rule group using Resource Access Manager (RAM). </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetFirewallRuleGroupPolicy {
    _private: (),
}
impl GetFirewallRuleGroupPolicy {
    /// Creates a new builder-style object to manufacture [`GetFirewallRuleGroupPolicyInput`](crate::input::GetFirewallRuleGroupPolicyInput)
    pub fn builder() -> crate::input::get_firewall_rule_group_policy_input::Builder {
        crate::input::get_firewall_rule_group_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetFirewallRuleGroupPolicy {
    type Output = std::result::Result<
        crate::output::GetFirewallRuleGroupPolicyOutput,
        crate::error::GetFirewallRuleGroupPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_firewall_rule_group_policy_error(response)
        } else {
            crate::operation_deser::parse_get_firewall_rule_group_policy_response(response)
        }
    }
}

/// <p>Gets DNSSEC validation information for a specified resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetResolverDnssecConfig {
    _private: (),
}
impl GetResolverDnssecConfig {
    /// Creates a new builder-style object to manufacture [`GetResolverDnssecConfigInput`](crate::input::GetResolverDnssecConfigInput)
    pub fn builder() -> crate::input::get_resolver_dnssec_config_input::Builder {
        crate::input::get_resolver_dnssec_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetResolverDnssecConfig {
    type Output = std::result::Result<
        crate::output::GetResolverDnssecConfigOutput,
        crate::error::GetResolverDnssecConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_resolver_dnssec_config_error(response)
        } else {
            crate::operation_deser::parse_get_resolver_dnssec_config_response(response)
        }
    }
}

/// <p>Gets information about a specified Resolver endpoint, such as whether it's an inbound or an outbound Resolver endpoint, and the
/// current status of the endpoint.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetResolverEndpoint {
    _private: (),
}
impl GetResolverEndpoint {
    /// Creates a new builder-style object to manufacture [`GetResolverEndpointInput`](crate::input::GetResolverEndpointInput)
    pub fn builder() -> crate::input::get_resolver_endpoint_input::Builder {
        crate::input::get_resolver_endpoint_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetResolverEndpoint {
    type Output = std::result::Result<
        crate::output::GetResolverEndpointOutput,
        crate::error::GetResolverEndpointError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_resolver_endpoint_error(response)
        } else {
            crate::operation_deser::parse_get_resolver_endpoint_response(response)
        }
    }
}

/// <p>Gets information about a specified Resolver query logging configuration, such as the number of VPCs that the configuration
/// is logging queries for and the location that logs are sent to. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetResolverQueryLogConfig {
    _private: (),
}
impl GetResolverQueryLogConfig {
    /// Creates a new builder-style object to manufacture [`GetResolverQueryLogConfigInput`](crate::input::GetResolverQueryLogConfigInput)
    pub fn builder() -> crate::input::get_resolver_query_log_config_input::Builder {
        crate::input::get_resolver_query_log_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetResolverQueryLogConfig {
    type Output = std::result::Result<
        crate::output::GetResolverQueryLogConfigOutput,
        crate::error::GetResolverQueryLogConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_resolver_query_log_config_error(response)
        } else {
            crate::operation_deser::parse_get_resolver_query_log_config_response(response)
        }
    }
}

/// <p>Gets information about a specified association between a Resolver query logging configuration and an Amazon VPC. When you associate a VPC
/// with a query logging configuration, Resolver logs DNS queries that originate in that VPC.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetResolverQueryLogConfigAssociation {
    _private: (),
}
impl GetResolverQueryLogConfigAssociation {
    /// Creates a new builder-style object to manufacture [`GetResolverQueryLogConfigAssociationInput`](crate::input::GetResolverQueryLogConfigAssociationInput)
    pub fn builder() -> crate::input::get_resolver_query_log_config_association_input::Builder {
        crate::input::get_resolver_query_log_config_association_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetResolverQueryLogConfigAssociation {
    type Output = std::result::Result<
        crate::output::GetResolverQueryLogConfigAssociationOutput,
        crate::error::GetResolverQueryLogConfigAssociationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_resolver_query_log_config_association_error(response)
        } else {
            crate::operation_deser::parse_get_resolver_query_log_config_association_response(
                response,
            )
        }
    }
}

/// <p>Gets information about a query logging policy. A query logging policy specifies the Resolver query logging
/// operations and resources that you want to allow another Amazon Web Services account to be able to use.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetResolverQueryLogConfigPolicy {
    _private: (),
}
impl GetResolverQueryLogConfigPolicy {
    /// Creates a new builder-style object to manufacture [`GetResolverQueryLogConfigPolicyInput`](crate::input::GetResolverQueryLogConfigPolicyInput)
    pub fn builder() -> crate::input::get_resolver_query_log_config_policy_input::Builder {
        crate::input::get_resolver_query_log_config_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetResolverQueryLogConfigPolicy {
    type Output = std::result::Result<
        crate::output::GetResolverQueryLogConfigPolicyOutput,
        crate::error::GetResolverQueryLogConfigPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_resolver_query_log_config_policy_error(response)
        } else {
            crate::operation_deser::parse_get_resolver_query_log_config_policy_response(response)
        }
    }
}

/// <p>Gets information about a specified Resolver rule, such as the domain name that the rule forwards DNS queries for and the ID of the
/// outbound Resolver endpoint that the rule is associated with.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetResolverRule {
    _private: (),
}
impl GetResolverRule {
    /// Creates a new builder-style object to manufacture [`GetResolverRuleInput`](crate::input::GetResolverRuleInput)
    pub fn builder() -> crate::input::get_resolver_rule_input::Builder {
        crate::input::get_resolver_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetResolverRule {
    type Output = std::result::Result<
        crate::output::GetResolverRuleOutput,
        crate::error::GetResolverRuleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_resolver_rule_error(response)
        } else {
            crate::operation_deser::parse_get_resolver_rule_response(response)
        }
    }
}

/// <p>Gets information about an association between a specified Resolver rule and a VPC. You associate a Resolver rule and a VPC using
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverRule.html">AssociateResolverRule</a>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetResolverRuleAssociation {
    _private: (),
}
impl GetResolverRuleAssociation {
    /// Creates a new builder-style object to manufacture [`GetResolverRuleAssociationInput`](crate::input::GetResolverRuleAssociationInput)
    pub fn builder() -> crate::input::get_resolver_rule_association_input::Builder {
        crate::input::get_resolver_rule_association_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetResolverRuleAssociation {
    type Output = std::result::Result<
        crate::output::GetResolverRuleAssociationOutput,
        crate::error::GetResolverRuleAssociationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_resolver_rule_association_error(response)
        } else {
            crate::operation_deser::parse_get_resolver_rule_association_response(response)
        }
    }
}

/// <p>Gets information about the Resolver rule policy for a specified rule. A Resolver rule policy includes the rule that you want to share
/// with another account, the account that you want to share the rule with, and the Resolver operations that you want to allow the account to use. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetResolverRulePolicy {
    _private: (),
}
impl GetResolverRulePolicy {
    /// Creates a new builder-style object to manufacture [`GetResolverRulePolicyInput`](crate::input::GetResolverRulePolicyInput)
    pub fn builder() -> crate::input::get_resolver_rule_policy_input::Builder {
        crate::input::get_resolver_rule_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetResolverRulePolicy {
    type Output = std::result::Result<
        crate::output::GetResolverRulePolicyOutput,
        crate::error::GetResolverRulePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_resolver_rule_policy_error(response)
        } else {
            crate::operation_deser::parse_get_resolver_rule_policy_response(response)
        }
    }
}

/// <p>Imports domain names from a file into a domain list, for use in a DNS firewall rule group. </p>
/// <p>Each domain specification in your domain list must satisfy the following
/// requirements: </p>
/// <ul>
/// <li>
/// <p>It can optionally start with <code>*</code> (asterisk).</p>
/// </li>
/// <li>
/// <p>With the exception of the optional starting asterisk, it must only contain
/// the following characters: <code>A-Z</code>, <code>a-z</code>,
/// <code>0-9</code>, <code>-</code> (hyphen).</p>
/// </li>
/// <li>
/// <p>It must be from 1-255 characters in length. </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ImportFirewallDomains {
    _private: (),
}
impl ImportFirewallDomains {
    /// Creates a new builder-style object to manufacture [`ImportFirewallDomainsInput`](crate::input::ImportFirewallDomainsInput)
    pub fn builder() -> crate::input::import_firewall_domains_input::Builder {
        crate::input::import_firewall_domains_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ImportFirewallDomains {
    type Output = std::result::Result<
        crate::output::ImportFirewallDomainsOutput,
        crate::error::ImportFirewallDomainsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_import_firewall_domains_error(response)
        } else {
            crate::operation_deser::parse_import_firewall_domains_response(response)
        }
    }
}

/// <p>Retrieves the firewall configurations that you have defined. DNS Firewall uses the configurations to manage firewall behavior for your VPCs. </p>
/// <p>A single call might return only a partial list of the configurations. For information, see <code>MaxResults</code>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListFirewallConfigs {
    _private: (),
}
impl ListFirewallConfigs {
    /// Creates a new builder-style object to manufacture [`ListFirewallConfigsInput`](crate::input::ListFirewallConfigsInput)
    pub fn builder() -> crate::input::list_firewall_configs_input::Builder {
        crate::input::list_firewall_configs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListFirewallConfigs {
    type Output = std::result::Result<
        crate::output::ListFirewallConfigsOutput,
        crate::error::ListFirewallConfigsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_firewall_configs_error(response)
        } else {
            crate::operation_deser::parse_list_firewall_configs_response(response)
        }
    }
}

/// <p>Retrieves the firewall domain lists that you have defined. For each firewall domain list, you can retrieve the domains that are defined for a list by calling <a>ListFirewallDomains</a>. </p>
/// <p>A single call to this list operation might return only a partial list of the domain lists. For information, see <code>MaxResults</code>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListFirewallDomainLists {
    _private: (),
}
impl ListFirewallDomainLists {
    /// Creates a new builder-style object to manufacture [`ListFirewallDomainListsInput`](crate::input::ListFirewallDomainListsInput)
    pub fn builder() -> crate::input::list_firewall_domain_lists_input::Builder {
        crate::input::list_firewall_domain_lists_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListFirewallDomainLists {
    type Output = std::result::Result<
        crate::output::ListFirewallDomainListsOutput,
        crate::error::ListFirewallDomainListsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_firewall_domain_lists_error(response)
        } else {
            crate::operation_deser::parse_list_firewall_domain_lists_response(response)
        }
    }
}

/// <p>Retrieves the domains that you have defined for the specified firewall domain list.  </p>
/// <p>A single call might return only a partial list of the domains. For information, see <code>MaxResults</code>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListFirewallDomains {
    _private: (),
}
impl ListFirewallDomains {
    /// Creates a new builder-style object to manufacture [`ListFirewallDomainsInput`](crate::input::ListFirewallDomainsInput)
    pub fn builder() -> crate::input::list_firewall_domains_input::Builder {
        crate::input::list_firewall_domains_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListFirewallDomains {
    type Output = std::result::Result<
        crate::output::ListFirewallDomainsOutput,
        crate::error::ListFirewallDomainsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_firewall_domains_error(response)
        } else {
            crate::operation_deser::parse_list_firewall_domains_response(response)
        }
    }
}

/// <p>Retrieves the firewall rule group associations that you have defined. Each association enables DNS filtering for a VPC with one rule group. </p>
/// <p>A single call might return only a partial list of the associations. For information, see <code>MaxResults</code>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListFirewallRuleGroupAssociations {
    _private: (),
}
impl ListFirewallRuleGroupAssociations {
    /// Creates a new builder-style object to manufacture [`ListFirewallRuleGroupAssociationsInput`](crate::input::ListFirewallRuleGroupAssociationsInput)
    pub fn builder() -> crate::input::list_firewall_rule_group_associations_input::Builder {
        crate::input::list_firewall_rule_group_associations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListFirewallRuleGroupAssociations {
    type Output = std::result::Result<
        crate::output::ListFirewallRuleGroupAssociationsOutput,
        crate::error::ListFirewallRuleGroupAssociationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_firewall_rule_group_associations_error(response)
        } else {
            crate::operation_deser::parse_list_firewall_rule_group_associations_response(response)
        }
    }
}

/// <p>Retrieves the minimal high-level information for the rule groups that you have defined.  </p>
/// <p>A single call might return only a partial list of the rule groups. For information, see <code>MaxResults</code>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListFirewallRuleGroups {
    _private: (),
}
impl ListFirewallRuleGroups {
    /// Creates a new builder-style object to manufacture [`ListFirewallRuleGroupsInput`](crate::input::ListFirewallRuleGroupsInput)
    pub fn builder() -> crate::input::list_firewall_rule_groups_input::Builder {
        crate::input::list_firewall_rule_groups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListFirewallRuleGroups {
    type Output = std::result::Result<
        crate::output::ListFirewallRuleGroupsOutput,
        crate::error::ListFirewallRuleGroupsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_firewall_rule_groups_error(response)
        } else {
            crate::operation_deser::parse_list_firewall_rule_groups_response(response)
        }
    }
}

/// <p>Retrieves the firewall rules that you have defined for the specified firewall rule group. DNS Firewall uses the rules in a rule group to filter DNS network traffic for a VPC. </p>
/// <p>A single call might return only a partial list of the rules. For information, see <code>MaxResults</code>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListFirewallRules {
    _private: (),
}
impl ListFirewallRules {
    /// Creates a new builder-style object to manufacture [`ListFirewallRulesInput`](crate::input::ListFirewallRulesInput)
    pub fn builder() -> crate::input::list_firewall_rules_input::Builder {
        crate::input::list_firewall_rules_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListFirewallRules {
    type Output = std::result::Result<
        crate::output::ListFirewallRulesOutput,
        crate::error::ListFirewallRulesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_firewall_rules_error(response)
        } else {
            crate::operation_deser::parse_list_firewall_rules_response(response)
        }
    }
}

/// <p>Lists the configurations for DNSSEC validation that are associated with the current Amazon Web Services account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListResolverDnssecConfigs {
    _private: (),
}
impl ListResolverDnssecConfigs {
    /// Creates a new builder-style object to manufacture [`ListResolverDnssecConfigsInput`](crate::input::ListResolverDnssecConfigsInput)
    pub fn builder() -> crate::input::list_resolver_dnssec_configs_input::Builder {
        crate::input::list_resolver_dnssec_configs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListResolverDnssecConfigs {
    type Output = std::result::Result<
        crate::output::ListResolverDnssecConfigsOutput,
        crate::error::ListResolverDnssecConfigsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_resolver_dnssec_configs_error(response)
        } else {
            crate::operation_deser::parse_list_resolver_dnssec_configs_response(response)
        }
    }
}

/// <p>Gets the IP addresses for a specified Resolver endpoint.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListResolverEndpointIpAddresses {
    _private: (),
}
impl ListResolverEndpointIpAddresses {
    /// Creates a new builder-style object to manufacture [`ListResolverEndpointIpAddressesInput`](crate::input::ListResolverEndpointIpAddressesInput)
    pub fn builder() -> crate::input::list_resolver_endpoint_ip_addresses_input::Builder {
        crate::input::list_resolver_endpoint_ip_addresses_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListResolverEndpointIpAddresses {
    type Output = std::result::Result<
        crate::output::ListResolverEndpointIpAddressesOutput,
        crate::error::ListResolverEndpointIpAddressesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_resolver_endpoint_ip_addresses_error(response)
        } else {
            crate::operation_deser::parse_list_resolver_endpoint_ip_addresses_response(response)
        }
    }
}

/// <p>Lists all the Resolver endpoints that were created using the current Amazon Web Services account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListResolverEndpoints {
    _private: (),
}
impl ListResolverEndpoints {
    /// Creates a new builder-style object to manufacture [`ListResolverEndpointsInput`](crate::input::ListResolverEndpointsInput)
    pub fn builder() -> crate::input::list_resolver_endpoints_input::Builder {
        crate::input::list_resolver_endpoints_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListResolverEndpoints {
    type Output = std::result::Result<
        crate::output::ListResolverEndpointsOutput,
        crate::error::ListResolverEndpointsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_resolver_endpoints_error(response)
        } else {
            crate::operation_deser::parse_list_resolver_endpoints_response(response)
        }
    }
}

/// <p>Lists information about associations between Amazon VPCs and query logging configurations.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListResolverQueryLogConfigAssociations {
    _private: (),
}
impl ListResolverQueryLogConfigAssociations {
    /// Creates a new builder-style object to manufacture [`ListResolverQueryLogConfigAssociationsInput`](crate::input::ListResolverQueryLogConfigAssociationsInput)
    pub fn builder() -> crate::input::list_resolver_query_log_config_associations_input::Builder {
        crate::input::list_resolver_query_log_config_associations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListResolverQueryLogConfigAssociations {
    type Output = std::result::Result<
        crate::output::ListResolverQueryLogConfigAssociationsOutput,
        crate::error::ListResolverQueryLogConfigAssociationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_resolver_query_log_config_associations_error(
                response,
            )
        } else {
            crate::operation_deser::parse_list_resolver_query_log_config_associations_response(
                response,
            )
        }
    }
}

/// <p>Lists information about the specified query logging configurations. Each configuration defines where you want Resolver to save
/// DNS query logs and specifies the VPCs that you want to log queries for.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListResolverQueryLogConfigs {
    _private: (),
}
impl ListResolverQueryLogConfigs {
    /// Creates a new builder-style object to manufacture [`ListResolverQueryLogConfigsInput`](crate::input::ListResolverQueryLogConfigsInput)
    pub fn builder() -> crate::input::list_resolver_query_log_configs_input::Builder {
        crate::input::list_resolver_query_log_configs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListResolverQueryLogConfigs {
    type Output = std::result::Result<
        crate::output::ListResolverQueryLogConfigsOutput,
        crate::error::ListResolverQueryLogConfigsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_resolver_query_log_configs_error(response)
        } else {
            crate::operation_deser::parse_list_resolver_query_log_configs_response(response)
        }
    }
}

/// <p>Lists the associations that were created between Resolver rules and VPCs using the current Amazon Web Services account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListResolverRuleAssociations {
    _private: (),
}
impl ListResolverRuleAssociations {
    /// Creates a new builder-style object to manufacture [`ListResolverRuleAssociationsInput`](crate::input::ListResolverRuleAssociationsInput)
    pub fn builder() -> crate::input::list_resolver_rule_associations_input::Builder {
        crate::input::list_resolver_rule_associations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListResolverRuleAssociations {
    type Output = std::result::Result<
        crate::output::ListResolverRuleAssociationsOutput,
        crate::error::ListResolverRuleAssociationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_resolver_rule_associations_error(response)
        } else {
            crate::operation_deser::parse_list_resolver_rule_associations_response(response)
        }
    }
}

/// <p>Lists the Resolver rules that were created using the current Amazon Web Services account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListResolverRules {
    _private: (),
}
impl ListResolverRules {
    /// Creates a new builder-style object to manufacture [`ListResolverRulesInput`](crate::input::ListResolverRulesInput)
    pub fn builder() -> crate::input::list_resolver_rules_input::Builder {
        crate::input::list_resolver_rules_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListResolverRules {
    type Output = std::result::Result<
        crate::output::ListResolverRulesOutput,
        crate::error::ListResolverRulesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_resolver_rules_error(response)
        } else {
            crate::operation_deser::parse_list_resolver_rules_response(response)
        }
    }
}

/// <p>Lists the tags that you associated with the specified resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Attaches an Identity and Access Management (Amazon Web Services IAM) policy for sharing the rule
/// group. You can use the policy to share the rule group using Resource Access Manager
/// (RAM). </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutFirewallRuleGroupPolicy {
    _private: (),
}
impl PutFirewallRuleGroupPolicy {
    /// Creates a new builder-style object to manufacture [`PutFirewallRuleGroupPolicyInput`](crate::input::PutFirewallRuleGroupPolicyInput)
    pub fn builder() -> crate::input::put_firewall_rule_group_policy_input::Builder {
        crate::input::put_firewall_rule_group_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutFirewallRuleGroupPolicy {
    type Output = std::result::Result<
        crate::output::PutFirewallRuleGroupPolicyOutput,
        crate::error::PutFirewallRuleGroupPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_firewall_rule_group_policy_error(response)
        } else {
            crate::operation_deser::parse_put_firewall_rule_group_policy_response(response)
        }
    }
}

/// <p>Specifies an Amazon Web Services account that you want to share a query logging configuration with, the query logging configuration that you want to share,
/// and the operations that you want the account to be able to perform on the configuration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutResolverQueryLogConfigPolicy {
    _private: (),
}
impl PutResolverQueryLogConfigPolicy {
    /// Creates a new builder-style object to manufacture [`PutResolverQueryLogConfigPolicyInput`](crate::input::PutResolverQueryLogConfigPolicyInput)
    pub fn builder() -> crate::input::put_resolver_query_log_config_policy_input::Builder {
        crate::input::put_resolver_query_log_config_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutResolverQueryLogConfigPolicy {
    type Output = std::result::Result<
        crate::output::PutResolverQueryLogConfigPolicyOutput,
        crate::error::PutResolverQueryLogConfigPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_resolver_query_log_config_policy_error(response)
        } else {
            crate::operation_deser::parse_put_resolver_query_log_config_policy_response(response)
        }
    }
}

/// <p>Specifies an Amazon Web Services rule that you want to share with another account, the account that you want to share the rule with,
/// and the operations that you want the account to be able to perform on the rule.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutResolverRulePolicy {
    _private: (),
}
impl PutResolverRulePolicy {
    /// Creates a new builder-style object to manufacture [`PutResolverRulePolicyInput`](crate::input::PutResolverRulePolicyInput)
    pub fn builder() -> crate::input::put_resolver_rule_policy_input::Builder {
        crate::input::put_resolver_rule_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutResolverRulePolicy {
    type Output = std::result::Result<
        crate::output::PutResolverRulePolicyOutput,
        crate::error::PutResolverRulePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_resolver_rule_policy_error(response)
        } else {
            crate::operation_deser::parse_put_resolver_rule_policy_response(response)
        }
    }
}

/// <p>Adds one or more tags to a specified resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Removes one or more tags from a specified resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Updates the configuration of the firewall behavior provided by DNS Firewall for a single
/// VPC from Amazon Virtual Private Cloud (Amazon VPC). </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateFirewallConfig {
    _private: (),
}
impl UpdateFirewallConfig {
    /// Creates a new builder-style object to manufacture [`UpdateFirewallConfigInput`](crate::input::UpdateFirewallConfigInput)
    pub fn builder() -> crate::input::update_firewall_config_input::Builder {
        crate::input::update_firewall_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateFirewallConfig {
    type Output = std::result::Result<
        crate::output::UpdateFirewallConfigOutput,
        crate::error::UpdateFirewallConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_firewall_config_error(response)
        } else {
            crate::operation_deser::parse_update_firewall_config_response(response)
        }
    }
}

/// <p>Updates the firewall domain list from an array of domain specifications. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateFirewallDomains {
    _private: (),
}
impl UpdateFirewallDomains {
    /// Creates a new builder-style object to manufacture [`UpdateFirewallDomainsInput`](crate::input::UpdateFirewallDomainsInput)
    pub fn builder() -> crate::input::update_firewall_domains_input::Builder {
        crate::input::update_firewall_domains_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateFirewallDomains {
    type Output = std::result::Result<
        crate::output::UpdateFirewallDomainsOutput,
        crate::error::UpdateFirewallDomainsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_firewall_domains_error(response)
        } else {
            crate::operation_deser::parse_update_firewall_domains_response(response)
        }
    }
}

/// <p>Updates the specified firewall rule. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateFirewallRule {
    _private: (),
}
impl UpdateFirewallRule {
    /// Creates a new builder-style object to manufacture [`UpdateFirewallRuleInput`](crate::input::UpdateFirewallRuleInput)
    pub fn builder() -> crate::input::update_firewall_rule_input::Builder {
        crate::input::update_firewall_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateFirewallRule {
    type Output = std::result::Result<
        crate::output::UpdateFirewallRuleOutput,
        crate::error::UpdateFirewallRuleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_firewall_rule_error(response)
        } else {
            crate::operation_deser::parse_update_firewall_rule_response(response)
        }
    }
}

/// <p>Changes the association of a <a>FirewallRuleGroup</a> with a VPC. The association enables DNS filtering for the VPC. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateFirewallRuleGroupAssociation {
    _private: (),
}
impl UpdateFirewallRuleGroupAssociation {
    /// Creates a new builder-style object to manufacture [`UpdateFirewallRuleGroupAssociationInput`](crate::input::UpdateFirewallRuleGroupAssociationInput)
    pub fn builder() -> crate::input::update_firewall_rule_group_association_input::Builder {
        crate::input::update_firewall_rule_group_association_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateFirewallRuleGroupAssociation {
    type Output = std::result::Result<
        crate::output::UpdateFirewallRuleGroupAssociationOutput,
        crate::error::UpdateFirewallRuleGroupAssociationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_firewall_rule_group_association_error(response)
        } else {
            crate::operation_deser::parse_update_firewall_rule_group_association_response(response)
        }
    }
}

/// <p>Updates an existing DNSSEC validation configuration. If there is no existing DNSSEC validation configuration, one is created.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateResolverDnssecConfig {
    _private: (),
}
impl UpdateResolverDnssecConfig {
    /// Creates a new builder-style object to manufacture [`UpdateResolverDnssecConfigInput`](crate::input::UpdateResolverDnssecConfigInput)
    pub fn builder() -> crate::input::update_resolver_dnssec_config_input::Builder {
        crate::input::update_resolver_dnssec_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateResolverDnssecConfig {
    type Output = std::result::Result<
        crate::output::UpdateResolverDnssecConfigOutput,
        crate::error::UpdateResolverDnssecConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_resolver_dnssec_config_error(response)
        } else {
            crate::operation_deser::parse_update_resolver_dnssec_config_response(response)
        }
    }
}

/// <p>Updates the name of an inbound or an outbound Resolver endpoint.  </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateResolverEndpoint {
    _private: (),
}
impl UpdateResolverEndpoint {
    /// Creates a new builder-style object to manufacture [`UpdateResolverEndpointInput`](crate::input::UpdateResolverEndpointInput)
    pub fn builder() -> crate::input::update_resolver_endpoint_input::Builder {
        crate::input::update_resolver_endpoint_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateResolverEndpoint {
    type Output = std::result::Result<
        crate::output::UpdateResolverEndpointOutput,
        crate::error::UpdateResolverEndpointError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_resolver_endpoint_error(response)
        } else {
            crate::operation_deser::parse_update_resolver_endpoint_response(response)
        }
    }
}

/// <p>Updates settings for a specified Resolver rule. <code>ResolverRuleId</code> is required, and all other parameters are optional.
/// If you don't specify a parameter, it retains its current value.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateResolverRule {
    _private: (),
}
impl UpdateResolverRule {
    /// Creates a new builder-style object to manufacture [`UpdateResolverRuleInput`](crate::input::UpdateResolverRuleInput)
    pub fn builder() -> crate::input::update_resolver_rule_input::Builder {
        crate::input::update_resolver_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateResolverRule {
    type Output = std::result::Result<
        crate::output::UpdateResolverRuleOutput,
        crate::error::UpdateResolverRuleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_resolver_rule_error(response)
        } else {
            crate::operation_deser::parse_update_resolver_rule_response(response)
        }
    }
}
