// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateFirewallRuleGroupError {
    pub kind: AssociateFirewallRuleGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateFirewallRuleGroupErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateFirewallRuleGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateFirewallRuleGroupErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            AssociateFirewallRuleGroupErrorKind::ConflictException(_inner) => _inner.fmt(f),
            AssociateFirewallRuleGroupErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            AssociateFirewallRuleGroupErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            AssociateFirewallRuleGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AssociateFirewallRuleGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AssociateFirewallRuleGroupErrorKind::ValidationException(_inner) => _inner.fmt(f),
            AssociateFirewallRuleGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateFirewallRuleGroupError {
    fn code(&self) -> Option<&str> {
        AssociateFirewallRuleGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateFirewallRuleGroupError {
    pub fn new(kind: AssociateFirewallRuleGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateFirewallRuleGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateFirewallRuleGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateFirewallRuleGroupErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateFirewallRuleGroupErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateFirewallRuleGroupErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateFirewallRuleGroupErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateFirewallRuleGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateFirewallRuleGroupErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateFirewallRuleGroupErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for AssociateFirewallRuleGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateFirewallRuleGroupErrorKind::AccessDeniedException(_inner) => Some(_inner),
            AssociateFirewallRuleGroupErrorKind::ConflictException(_inner) => Some(_inner),
            AssociateFirewallRuleGroupErrorKind::InternalServiceErrorException(_inner) => {
                Some(_inner)
            }
            AssociateFirewallRuleGroupErrorKind::LimitExceededException(_inner) => Some(_inner),
            AssociateFirewallRuleGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AssociateFirewallRuleGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            AssociateFirewallRuleGroupErrorKind::ValidationException(_inner) => Some(_inner),
            AssociateFirewallRuleGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateResolverEndpointIpAddressError {
    pub kind: AssociateResolverEndpointIpAddressErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateResolverEndpointIpAddressErrorKind {
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateResolverEndpointIpAddressError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateResolverEndpointIpAddressErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            AssociateResolverEndpointIpAddressErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            AssociateResolverEndpointIpAddressErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            AssociateResolverEndpointIpAddressErrorKind::LimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            AssociateResolverEndpointIpAddressErrorKind::ResourceExistsException(_inner) => {
                _inner.fmt(f)
            }
            AssociateResolverEndpointIpAddressErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AssociateResolverEndpointIpAddressErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            AssociateResolverEndpointIpAddressErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateResolverEndpointIpAddressError {
    fn code(&self) -> Option<&str> {
        AssociateResolverEndpointIpAddressError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateResolverEndpointIpAddressError {
    pub fn new(
        kind: AssociateResolverEndpointIpAddressErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateResolverEndpointIpAddressErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateResolverEndpointIpAddressErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateResolverEndpointIpAddressErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateResolverEndpointIpAddressErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateResolverEndpointIpAddressErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateResolverEndpointIpAddressErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateResolverEndpointIpAddressErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateResolverEndpointIpAddressErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateResolverEndpointIpAddressErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for AssociateResolverEndpointIpAddressError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateResolverEndpointIpAddressErrorKind::InternalServiceErrorException(_inner) => {
                Some(_inner)
            }
            AssociateResolverEndpointIpAddressErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            AssociateResolverEndpointIpAddressErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            AssociateResolverEndpointIpAddressErrorKind::LimitExceededException(_inner) => {
                Some(_inner)
            }
            AssociateResolverEndpointIpAddressErrorKind::ResourceExistsException(_inner) => {
                Some(_inner)
            }
            AssociateResolverEndpointIpAddressErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            AssociateResolverEndpointIpAddressErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            AssociateResolverEndpointIpAddressErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateResolverQueryLogConfigError {
    pub kind: AssociateResolverQueryLogConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateResolverQueryLogConfigErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateResolverQueryLogConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateResolverQueryLogConfigErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            AssociateResolverQueryLogConfigErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            AssociateResolverQueryLogConfigErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            AssociateResolverQueryLogConfigErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            AssociateResolverQueryLogConfigErrorKind::LimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            AssociateResolverQueryLogConfigErrorKind::ResourceExistsException(_inner) => {
                _inner.fmt(f)
            }
            AssociateResolverQueryLogConfigErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AssociateResolverQueryLogConfigErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AssociateResolverQueryLogConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateResolverQueryLogConfigError {
    fn code(&self) -> Option<&str> {
        AssociateResolverQueryLogConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateResolverQueryLogConfigError {
    pub fn new(kind: AssociateResolverQueryLogConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateResolverQueryLogConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateResolverQueryLogConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateResolverQueryLogConfigErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateResolverQueryLogConfigErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateResolverQueryLogConfigErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateResolverQueryLogConfigErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateResolverQueryLogConfigErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateResolverQueryLogConfigErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateResolverQueryLogConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateResolverQueryLogConfigErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for AssociateResolverQueryLogConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateResolverQueryLogConfigErrorKind::AccessDeniedException(_inner) => Some(_inner),
            AssociateResolverQueryLogConfigErrorKind::InternalServiceErrorException(_inner) => {
                Some(_inner)
            }
            AssociateResolverQueryLogConfigErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            AssociateResolverQueryLogConfigErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            AssociateResolverQueryLogConfigErrorKind::LimitExceededException(_inner) => {
                Some(_inner)
            }
            AssociateResolverQueryLogConfigErrorKind::ResourceExistsException(_inner) => {
                Some(_inner)
            }
            AssociateResolverQueryLogConfigErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            AssociateResolverQueryLogConfigErrorKind::ThrottlingException(_inner) => Some(_inner),
            AssociateResolverQueryLogConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateResolverRuleError {
    pub kind: AssociateResolverRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateResolverRuleErrorKind {
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateResolverRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateResolverRuleErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            AssociateResolverRuleErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AssociateResolverRuleErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            AssociateResolverRuleErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            AssociateResolverRuleErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            AssociateResolverRuleErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AssociateResolverRuleErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            AssociateResolverRuleErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AssociateResolverRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateResolverRuleError {
    fn code(&self) -> Option<&str> {
        AssociateResolverRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateResolverRuleError {
    pub fn new(kind: AssociateResolverRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateResolverRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateResolverRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateResolverRuleErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateResolverRuleErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateResolverRuleErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateResolverRuleErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateResolverRuleErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateResolverRuleErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateResolverRuleErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateResolverRuleErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for AssociateResolverRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateResolverRuleErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            AssociateResolverRuleErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AssociateResolverRuleErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AssociateResolverRuleErrorKind::LimitExceededException(_inner) => Some(_inner),
            AssociateResolverRuleErrorKind::ResourceExistsException(_inner) => Some(_inner),
            AssociateResolverRuleErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AssociateResolverRuleErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            AssociateResolverRuleErrorKind::ThrottlingException(_inner) => Some(_inner),
            AssociateResolverRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateFirewallDomainListError {
    pub kind: CreateFirewallDomainListErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateFirewallDomainListErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    LimitExceededException(crate::error::LimitExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateFirewallDomainListError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateFirewallDomainListErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateFirewallDomainListErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            CreateFirewallDomainListErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateFirewallDomainListErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateFirewallDomainListErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateFirewallDomainListErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateFirewallDomainListError {
    fn code(&self) -> Option<&str> {
        CreateFirewallDomainListError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateFirewallDomainListError {
    pub fn new(kind: CreateFirewallDomainListErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateFirewallDomainListErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateFirewallDomainListErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFirewallDomainListErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFirewallDomainListErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFirewallDomainListErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFirewallDomainListErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFirewallDomainListErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateFirewallDomainListError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateFirewallDomainListErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateFirewallDomainListErrorKind::InternalServiceErrorException(_inner) => {
                Some(_inner)
            }
            CreateFirewallDomainListErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateFirewallDomainListErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateFirewallDomainListErrorKind::ValidationException(_inner) => Some(_inner),
            CreateFirewallDomainListErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateFirewallRuleError {
    pub kind: CreateFirewallRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateFirewallRuleErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateFirewallRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateFirewallRuleErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateFirewallRuleErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            CreateFirewallRuleErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateFirewallRuleErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateFirewallRuleErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateFirewallRuleErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateFirewallRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateFirewallRuleError {
    fn code(&self) -> Option<&str> {
        CreateFirewallRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateFirewallRuleError {
    pub fn new(kind: CreateFirewallRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateFirewallRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateFirewallRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFirewallRuleErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFirewallRuleErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFirewallRuleErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFirewallRuleErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFirewallRuleErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFirewallRuleErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateFirewallRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateFirewallRuleErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateFirewallRuleErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            CreateFirewallRuleErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateFirewallRuleErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateFirewallRuleErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateFirewallRuleErrorKind::ValidationException(_inner) => Some(_inner),
            CreateFirewallRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateFirewallRuleGroupError {
    pub kind: CreateFirewallRuleGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateFirewallRuleGroupErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    LimitExceededException(crate::error::LimitExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateFirewallRuleGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateFirewallRuleGroupErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateFirewallRuleGroupErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            CreateFirewallRuleGroupErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateFirewallRuleGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateFirewallRuleGroupErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateFirewallRuleGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateFirewallRuleGroupError {
    fn code(&self) -> Option<&str> {
        CreateFirewallRuleGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateFirewallRuleGroupError {
    pub fn new(kind: CreateFirewallRuleGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateFirewallRuleGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateFirewallRuleGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFirewallRuleGroupErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFirewallRuleGroupErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFirewallRuleGroupErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFirewallRuleGroupErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFirewallRuleGroupErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateFirewallRuleGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateFirewallRuleGroupErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateFirewallRuleGroupErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            CreateFirewallRuleGroupErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateFirewallRuleGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateFirewallRuleGroupErrorKind::ValidationException(_inner) => Some(_inner),
            CreateFirewallRuleGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateResolverEndpointError {
    pub kind: CreateResolverEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateResolverEndpointErrorKind {
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateResolverEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateResolverEndpointErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            CreateResolverEndpointErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateResolverEndpointErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateResolverEndpointErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateResolverEndpointErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            CreateResolverEndpointErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateResolverEndpointErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateResolverEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateResolverEndpointError {
    fn code(&self) -> Option<&str> {
        CreateResolverEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateResolverEndpointError {
    pub fn new(kind: CreateResolverEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateResolverEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateResolverEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverEndpointErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverEndpointErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverEndpointErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverEndpointErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverEndpointErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverEndpointErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverEndpointErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateResolverEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateResolverEndpointErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            CreateResolverEndpointErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateResolverEndpointErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateResolverEndpointErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateResolverEndpointErrorKind::ResourceExistsException(_inner) => Some(_inner),
            CreateResolverEndpointErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateResolverEndpointErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateResolverEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateResolverQueryLogConfigError {
    pub kind: CreateResolverQueryLogConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateResolverQueryLogConfigErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateResolverQueryLogConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateResolverQueryLogConfigErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateResolverQueryLogConfigErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            CreateResolverQueryLogConfigErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            CreateResolverQueryLogConfigErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateResolverQueryLogConfigErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateResolverQueryLogConfigErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            CreateResolverQueryLogConfigErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CreateResolverQueryLogConfigErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateResolverQueryLogConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateResolverQueryLogConfigError {
    fn code(&self) -> Option<&str> {
        CreateResolverQueryLogConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateResolverQueryLogConfigError {
    pub fn new(kind: CreateResolverQueryLogConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateResolverQueryLogConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateResolverQueryLogConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverQueryLogConfigErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverQueryLogConfigErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverQueryLogConfigErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverQueryLogConfigErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverQueryLogConfigErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverQueryLogConfigErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverQueryLogConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverQueryLogConfigErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateResolverQueryLogConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateResolverQueryLogConfigErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateResolverQueryLogConfigErrorKind::InternalServiceErrorException(_inner) => {
                Some(_inner)
            }
            CreateResolverQueryLogConfigErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            CreateResolverQueryLogConfigErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateResolverQueryLogConfigErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateResolverQueryLogConfigErrorKind::ResourceExistsException(_inner) => Some(_inner),
            CreateResolverQueryLogConfigErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            CreateResolverQueryLogConfigErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateResolverQueryLogConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateResolverRuleError {
    pub kind: CreateResolverRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateResolverRuleErrorKind {
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateResolverRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateResolverRuleErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            CreateResolverRuleErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateResolverRuleErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateResolverRuleErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateResolverRuleErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            CreateResolverRuleErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateResolverRuleErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            CreateResolverRuleErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateResolverRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateResolverRuleError {
    fn code(&self) -> Option<&str> {
        CreateResolverRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateResolverRuleError {
    pub fn new(kind: CreateResolverRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateResolverRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateResolverRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverRuleErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverRuleErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverRuleErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverRuleErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverRuleErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverRuleErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverRuleErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverRuleErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateResolverRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateResolverRuleErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            CreateResolverRuleErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateResolverRuleErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateResolverRuleErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateResolverRuleErrorKind::ResourceExistsException(_inner) => Some(_inner),
            CreateResolverRuleErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateResolverRuleErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            CreateResolverRuleErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateResolverRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFirewallDomainListError {
    pub kind: DeleteFirewallDomainListErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFirewallDomainListErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFirewallDomainListError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFirewallDomainListErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteFirewallDomainListErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteFirewallDomainListErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            DeleteFirewallDomainListErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteFirewallDomainListErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteFirewallDomainListErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteFirewallDomainListError {
    fn code(&self) -> Option<&str> {
        DeleteFirewallDomainListError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFirewallDomainListError {
    pub fn new(kind: DeleteFirewallDomainListErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFirewallDomainListErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFirewallDomainListErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFirewallDomainListErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFirewallDomainListErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFirewallDomainListErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFirewallDomainListErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFirewallDomainListErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteFirewallDomainListError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFirewallDomainListErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteFirewallDomainListErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteFirewallDomainListErrorKind::InternalServiceErrorException(_inner) => {
                Some(_inner)
            }
            DeleteFirewallDomainListErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteFirewallDomainListErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteFirewallDomainListErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFirewallRuleError {
    pub kind: DeleteFirewallRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFirewallRuleErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFirewallRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFirewallRuleErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteFirewallRuleErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            DeleteFirewallRuleErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteFirewallRuleErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteFirewallRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteFirewallRuleError {
    fn code(&self) -> Option<&str> {
        DeleteFirewallRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFirewallRuleError {
    pub fn new(kind: DeleteFirewallRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFirewallRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFirewallRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFirewallRuleErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFirewallRuleErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFirewallRuleErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFirewallRuleErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteFirewallRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFirewallRuleErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteFirewallRuleErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            DeleteFirewallRuleErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteFirewallRuleErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteFirewallRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFirewallRuleGroupError {
    pub kind: DeleteFirewallRuleGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFirewallRuleGroupErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFirewallRuleGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFirewallRuleGroupErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteFirewallRuleGroupErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteFirewallRuleGroupErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            DeleteFirewallRuleGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteFirewallRuleGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteFirewallRuleGroupErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteFirewallRuleGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteFirewallRuleGroupError {
    fn code(&self) -> Option<&str> {
        DeleteFirewallRuleGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFirewallRuleGroupError {
    pub fn new(kind: DeleteFirewallRuleGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFirewallRuleGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFirewallRuleGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFirewallRuleGroupErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFirewallRuleGroupErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFirewallRuleGroupErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFirewallRuleGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFirewallRuleGroupErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFirewallRuleGroupErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteFirewallRuleGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFirewallRuleGroupErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteFirewallRuleGroupErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteFirewallRuleGroupErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            DeleteFirewallRuleGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteFirewallRuleGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteFirewallRuleGroupErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteFirewallRuleGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteResolverEndpointError {
    pub kind: DeleteResolverEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteResolverEndpointErrorKind {
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteResolverEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteResolverEndpointErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            DeleteResolverEndpointErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteResolverEndpointErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteResolverEndpointErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteResolverEndpointErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteResolverEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteResolverEndpointError {
    fn code(&self) -> Option<&str> {
        DeleteResolverEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteResolverEndpointError {
    pub fn new(kind: DeleteResolverEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteResolverEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteResolverEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResolverEndpointErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResolverEndpointErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResolverEndpointErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResolverEndpointErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResolverEndpointErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteResolverEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteResolverEndpointErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            DeleteResolverEndpointErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteResolverEndpointErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteResolverEndpointErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteResolverEndpointErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteResolverEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteResolverQueryLogConfigError {
    pub kind: DeleteResolverQueryLogConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteResolverQueryLogConfigErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteResolverQueryLogConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteResolverQueryLogConfigErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteResolverQueryLogConfigErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            DeleteResolverQueryLogConfigErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            DeleteResolverQueryLogConfigErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteResolverQueryLogConfigErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteResolverQueryLogConfigErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteResolverQueryLogConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteResolverQueryLogConfigError {
    fn code(&self) -> Option<&str> {
        DeleteResolverQueryLogConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteResolverQueryLogConfigError {
    pub fn new(kind: DeleteResolverQueryLogConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteResolverQueryLogConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteResolverQueryLogConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResolverQueryLogConfigErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResolverQueryLogConfigErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResolverQueryLogConfigErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResolverQueryLogConfigErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResolverQueryLogConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResolverQueryLogConfigErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteResolverQueryLogConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteResolverQueryLogConfigErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteResolverQueryLogConfigErrorKind::InternalServiceErrorException(_inner) => {
                Some(_inner)
            }
            DeleteResolverQueryLogConfigErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            DeleteResolverQueryLogConfigErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteResolverQueryLogConfigErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteResolverQueryLogConfigErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteResolverQueryLogConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteResolverRuleError {
    pub kind: DeleteResolverRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteResolverRuleErrorKind {
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceInUseException(crate::error::ResourceInUseException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteResolverRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteResolverRuleErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            DeleteResolverRuleErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteResolverRuleErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteResolverRuleErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteResolverRuleErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteResolverRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteResolverRuleError {
    fn code(&self) -> Option<&str> {
        DeleteResolverRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteResolverRuleError {
    pub fn new(kind: DeleteResolverRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteResolverRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteResolverRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResolverRuleErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResolverRuleErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResolverRuleErrorKind::ResourceInUseException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResolverRuleErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResolverRuleErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteResolverRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteResolverRuleErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            DeleteResolverRuleErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteResolverRuleErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteResolverRuleErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteResolverRuleErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteResolverRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateFirewallRuleGroupError {
    pub kind: DisassociateFirewallRuleGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateFirewallRuleGroupErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateFirewallRuleGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateFirewallRuleGroupErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DisassociateFirewallRuleGroupErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DisassociateFirewallRuleGroupErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateFirewallRuleGroupErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateFirewallRuleGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DisassociateFirewallRuleGroupErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DisassociateFirewallRuleGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateFirewallRuleGroupError {
    fn code(&self) -> Option<&str> {
        DisassociateFirewallRuleGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateFirewallRuleGroupError {
    pub fn new(kind: DisassociateFirewallRuleGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateFirewallRuleGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateFirewallRuleGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateFirewallRuleGroupErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateFirewallRuleGroupErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateFirewallRuleGroupErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateFirewallRuleGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateFirewallRuleGroupErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateFirewallRuleGroupErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DisassociateFirewallRuleGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateFirewallRuleGroupErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DisassociateFirewallRuleGroupErrorKind::ConflictException(_inner) => Some(_inner),
            DisassociateFirewallRuleGroupErrorKind::InternalServiceErrorException(_inner) => {
                Some(_inner)
            }
            DisassociateFirewallRuleGroupErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DisassociateFirewallRuleGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            DisassociateFirewallRuleGroupErrorKind::ValidationException(_inner) => Some(_inner),
            DisassociateFirewallRuleGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateResolverEndpointIpAddressError {
    pub kind: DisassociateResolverEndpointIpAddressErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateResolverEndpointIpAddressErrorKind {
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateResolverEndpointIpAddressError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateResolverEndpointIpAddressErrorKind::InternalServiceErrorException(
                _inner,
            ) => _inner.fmt(f),
            DisassociateResolverEndpointIpAddressErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateResolverEndpointIpAddressErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateResolverEndpointIpAddressErrorKind::ResourceExistsException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateResolverEndpointIpAddressErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateResolverEndpointIpAddressErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateResolverEndpointIpAddressErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateResolverEndpointIpAddressError {
    fn code(&self) -> Option<&str> {
        DisassociateResolverEndpointIpAddressError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateResolverEndpointIpAddressError {
    pub fn new(
        kind: DisassociateResolverEndpointIpAddressErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateResolverEndpointIpAddressErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateResolverEndpointIpAddressErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateResolverEndpointIpAddressErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateResolverEndpointIpAddressErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateResolverEndpointIpAddressErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateResolverEndpointIpAddressErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateResolverEndpointIpAddressErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateResolverEndpointIpAddressErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DisassociateResolverEndpointIpAddressError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateResolverEndpointIpAddressErrorKind::InternalServiceErrorException(
                _inner,
            ) => Some(_inner),
            DisassociateResolverEndpointIpAddressErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            DisassociateResolverEndpointIpAddressErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            DisassociateResolverEndpointIpAddressErrorKind::ResourceExistsException(_inner) => {
                Some(_inner)
            }
            DisassociateResolverEndpointIpAddressErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DisassociateResolverEndpointIpAddressErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            DisassociateResolverEndpointIpAddressErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateResolverQueryLogConfigError {
    pub kind: DisassociateResolverQueryLogConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateResolverQueryLogConfigErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateResolverQueryLogConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateResolverQueryLogConfigErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateResolverQueryLogConfigErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateResolverQueryLogConfigErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateResolverQueryLogConfigErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateResolverQueryLogConfigErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateResolverQueryLogConfigErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateResolverQueryLogConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateResolverQueryLogConfigError {
    fn code(&self) -> Option<&str> {
        DisassociateResolverQueryLogConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateResolverQueryLogConfigError {
    pub fn new(
        kind: DisassociateResolverQueryLogConfigErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateResolverQueryLogConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateResolverQueryLogConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateResolverQueryLogConfigErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateResolverQueryLogConfigErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateResolverQueryLogConfigErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateResolverQueryLogConfigErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateResolverQueryLogConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateResolverQueryLogConfigErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DisassociateResolverQueryLogConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateResolverQueryLogConfigErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            DisassociateResolverQueryLogConfigErrorKind::InternalServiceErrorException(_inner) => {
                Some(_inner)
            }
            DisassociateResolverQueryLogConfigErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            DisassociateResolverQueryLogConfigErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            DisassociateResolverQueryLogConfigErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DisassociateResolverQueryLogConfigErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            DisassociateResolverQueryLogConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateResolverRuleError {
    pub kind: DisassociateResolverRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateResolverRuleErrorKind {
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateResolverRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateResolverRuleErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateResolverRuleErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DisassociateResolverRuleErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DisassociateResolverRuleErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DisassociateResolverRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateResolverRuleError {
    fn code(&self) -> Option<&str> {
        DisassociateResolverRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateResolverRuleError {
    pub fn new(kind: DisassociateResolverRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateResolverRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateResolverRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateResolverRuleErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateResolverRuleErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateResolverRuleErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateResolverRuleErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DisassociateResolverRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateResolverRuleErrorKind::InternalServiceErrorException(_inner) => {
                Some(_inner)
            }
            DisassociateResolverRuleErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DisassociateResolverRuleErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DisassociateResolverRuleErrorKind::ThrottlingException(_inner) => Some(_inner),
            DisassociateResolverRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFirewallConfigError {
    pub kind: GetFirewallConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFirewallConfigErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFirewallConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFirewallConfigErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetFirewallConfigErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            GetFirewallConfigErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetFirewallConfigErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetFirewallConfigErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetFirewallConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetFirewallConfigError {
    fn code(&self) -> Option<&str> {
        GetFirewallConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFirewallConfigError {
    pub fn new(kind: GetFirewallConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFirewallConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFirewallConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFirewallConfigErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFirewallConfigErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFirewallConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFirewallConfigErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFirewallConfigErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetFirewallConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFirewallConfigErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetFirewallConfigErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            GetFirewallConfigErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetFirewallConfigErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetFirewallConfigErrorKind::ValidationException(_inner) => Some(_inner),
            GetFirewallConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFirewallDomainListError {
    pub kind: GetFirewallDomainListErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFirewallDomainListErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFirewallDomainListError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFirewallDomainListErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetFirewallDomainListErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            GetFirewallDomainListErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetFirewallDomainListErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetFirewallDomainListErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetFirewallDomainListError {
    fn code(&self) -> Option<&str> {
        GetFirewallDomainListError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFirewallDomainListError {
    pub fn new(kind: GetFirewallDomainListErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFirewallDomainListErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFirewallDomainListErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFirewallDomainListErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFirewallDomainListErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFirewallDomainListErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFirewallDomainListErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetFirewallDomainListError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFirewallDomainListErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetFirewallDomainListErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            GetFirewallDomainListErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetFirewallDomainListErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetFirewallDomainListErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFirewallRuleGroupError {
    pub kind: GetFirewallRuleGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFirewallRuleGroupErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFirewallRuleGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFirewallRuleGroupErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetFirewallRuleGroupErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            GetFirewallRuleGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetFirewallRuleGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetFirewallRuleGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetFirewallRuleGroupError {
    fn code(&self) -> Option<&str> {
        GetFirewallRuleGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFirewallRuleGroupError {
    pub fn new(kind: GetFirewallRuleGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFirewallRuleGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFirewallRuleGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFirewallRuleGroupErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFirewallRuleGroupErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFirewallRuleGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFirewallRuleGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetFirewallRuleGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFirewallRuleGroupErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetFirewallRuleGroupErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            GetFirewallRuleGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetFirewallRuleGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetFirewallRuleGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFirewallRuleGroupAssociationError {
    pub kind: GetFirewallRuleGroupAssociationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFirewallRuleGroupAssociationErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFirewallRuleGroupAssociationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFirewallRuleGroupAssociationErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            GetFirewallRuleGroupAssociationErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            GetFirewallRuleGroupAssociationErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetFirewallRuleGroupAssociationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetFirewallRuleGroupAssociationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetFirewallRuleGroupAssociationError {
    fn code(&self) -> Option<&str> {
        GetFirewallRuleGroupAssociationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFirewallRuleGroupAssociationError {
    pub fn new(kind: GetFirewallRuleGroupAssociationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFirewallRuleGroupAssociationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFirewallRuleGroupAssociationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFirewallRuleGroupAssociationErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFirewallRuleGroupAssociationErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFirewallRuleGroupAssociationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFirewallRuleGroupAssociationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetFirewallRuleGroupAssociationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFirewallRuleGroupAssociationErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetFirewallRuleGroupAssociationErrorKind::InternalServiceErrorException(_inner) => {
                Some(_inner)
            }
            GetFirewallRuleGroupAssociationErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            GetFirewallRuleGroupAssociationErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetFirewallRuleGroupAssociationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFirewallRuleGroupPolicyError {
    pub kind: GetFirewallRuleGroupPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFirewallRuleGroupPolicyErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFirewallRuleGroupPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFirewallRuleGroupPolicyErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetFirewallRuleGroupPolicyErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            GetFirewallRuleGroupPolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetFirewallRuleGroupPolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetFirewallRuleGroupPolicyErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetFirewallRuleGroupPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetFirewallRuleGroupPolicyError {
    fn code(&self) -> Option<&str> {
        GetFirewallRuleGroupPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFirewallRuleGroupPolicyError {
    pub fn new(kind: GetFirewallRuleGroupPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFirewallRuleGroupPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFirewallRuleGroupPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFirewallRuleGroupPolicyErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFirewallRuleGroupPolicyErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFirewallRuleGroupPolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFirewallRuleGroupPolicyErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFirewallRuleGroupPolicyErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetFirewallRuleGroupPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFirewallRuleGroupPolicyErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetFirewallRuleGroupPolicyErrorKind::InternalServiceErrorException(_inner) => {
                Some(_inner)
            }
            GetFirewallRuleGroupPolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetFirewallRuleGroupPolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetFirewallRuleGroupPolicyErrorKind::ValidationException(_inner) => Some(_inner),
            GetFirewallRuleGroupPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetResolverDnssecConfigError {
    pub kind: GetResolverDnssecConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetResolverDnssecConfigErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetResolverDnssecConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetResolverDnssecConfigErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetResolverDnssecConfigErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            GetResolverDnssecConfigErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetResolverDnssecConfigErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetResolverDnssecConfigErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetResolverDnssecConfigErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetResolverDnssecConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetResolverDnssecConfigError {
    fn code(&self) -> Option<&str> {
        GetResolverDnssecConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetResolverDnssecConfigError {
    pub fn new(kind: GetResolverDnssecConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetResolverDnssecConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetResolverDnssecConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverDnssecConfigErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverDnssecConfigErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverDnssecConfigErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverDnssecConfigErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverDnssecConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverDnssecConfigErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetResolverDnssecConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetResolverDnssecConfigErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetResolverDnssecConfigErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            GetResolverDnssecConfigErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetResolverDnssecConfigErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetResolverDnssecConfigErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetResolverDnssecConfigErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetResolverDnssecConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetResolverEndpointError {
    pub kind: GetResolverEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetResolverEndpointErrorKind {
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetResolverEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetResolverEndpointErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            GetResolverEndpointErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetResolverEndpointErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetResolverEndpointErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetResolverEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetResolverEndpointError {
    fn code(&self) -> Option<&str> {
        GetResolverEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetResolverEndpointError {
    pub fn new(kind: GetResolverEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetResolverEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetResolverEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverEndpointErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverEndpointErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverEndpointErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverEndpointErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetResolverEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetResolverEndpointErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            GetResolverEndpointErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetResolverEndpointErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetResolverEndpointErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetResolverEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetResolverQueryLogConfigError {
    pub kind: GetResolverQueryLogConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetResolverQueryLogConfigErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetResolverQueryLogConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetResolverQueryLogConfigErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetResolverQueryLogConfigErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            GetResolverQueryLogConfigErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetResolverQueryLogConfigErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetResolverQueryLogConfigErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetResolverQueryLogConfigErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetResolverQueryLogConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetResolverQueryLogConfigError {
    fn code(&self) -> Option<&str> {
        GetResolverQueryLogConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetResolverQueryLogConfigError {
    pub fn new(kind: GetResolverQueryLogConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetResolverQueryLogConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetResolverQueryLogConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverQueryLogConfigErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverQueryLogConfigErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverQueryLogConfigErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverQueryLogConfigErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverQueryLogConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverQueryLogConfigErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetResolverQueryLogConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetResolverQueryLogConfigErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetResolverQueryLogConfigErrorKind::InternalServiceErrorException(_inner) => {
                Some(_inner)
            }
            GetResolverQueryLogConfigErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetResolverQueryLogConfigErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetResolverQueryLogConfigErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetResolverQueryLogConfigErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetResolverQueryLogConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetResolverQueryLogConfigAssociationError {
    pub kind: GetResolverQueryLogConfigAssociationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetResolverQueryLogConfigAssociationErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetResolverQueryLogConfigAssociationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetResolverQueryLogConfigAssociationErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            GetResolverQueryLogConfigAssociationErrorKind::InternalServiceErrorException(
                _inner,
            ) => _inner.fmt(f),
            GetResolverQueryLogConfigAssociationErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            GetResolverQueryLogConfigAssociationErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            GetResolverQueryLogConfigAssociationErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetResolverQueryLogConfigAssociationErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            GetResolverQueryLogConfigAssociationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetResolverQueryLogConfigAssociationError {
    fn code(&self) -> Option<&str> {
        GetResolverQueryLogConfigAssociationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetResolverQueryLogConfigAssociationError {
    pub fn new(
        kind: GetResolverQueryLogConfigAssociationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetResolverQueryLogConfigAssociationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetResolverQueryLogConfigAssociationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverQueryLogConfigAssociationErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverQueryLogConfigAssociationErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverQueryLogConfigAssociationErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverQueryLogConfigAssociationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverQueryLogConfigAssociationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverQueryLogConfigAssociationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetResolverQueryLogConfigAssociationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetResolverQueryLogConfigAssociationErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            GetResolverQueryLogConfigAssociationErrorKind::InternalServiceErrorException(
                _inner,
            ) => Some(_inner),
            GetResolverQueryLogConfigAssociationErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            GetResolverQueryLogConfigAssociationErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            GetResolverQueryLogConfigAssociationErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            GetResolverQueryLogConfigAssociationErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            GetResolverQueryLogConfigAssociationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetResolverQueryLogConfigPolicyError {
    pub kind: GetResolverQueryLogConfigPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetResolverQueryLogConfigPolicyErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    UnknownResourceException(crate::error::UnknownResourceException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetResolverQueryLogConfigPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetResolverQueryLogConfigPolicyErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            GetResolverQueryLogConfigPolicyErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            GetResolverQueryLogConfigPolicyErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            GetResolverQueryLogConfigPolicyErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            GetResolverQueryLogConfigPolicyErrorKind::UnknownResourceException(_inner) => {
                _inner.fmt(f)
            }
            GetResolverQueryLogConfigPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetResolverQueryLogConfigPolicyError {
    fn code(&self) -> Option<&str> {
        GetResolverQueryLogConfigPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetResolverQueryLogConfigPolicyError {
    pub fn new(kind: GetResolverQueryLogConfigPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetResolverQueryLogConfigPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetResolverQueryLogConfigPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverQueryLogConfigPolicyErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverQueryLogConfigPolicyErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverQueryLogConfigPolicyErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverQueryLogConfigPolicyErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_unknown_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverQueryLogConfigPolicyErrorKind::UnknownResourceException(_)
        )
    }
}
impl std::error::Error for GetResolverQueryLogConfigPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetResolverQueryLogConfigPolicyErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetResolverQueryLogConfigPolicyErrorKind::InternalServiceErrorException(_inner) => {
                Some(_inner)
            }
            GetResolverQueryLogConfigPolicyErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            GetResolverQueryLogConfigPolicyErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            GetResolverQueryLogConfigPolicyErrorKind::UnknownResourceException(_inner) => {
                Some(_inner)
            }
            GetResolverQueryLogConfigPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetResolverRuleError {
    pub kind: GetResolverRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetResolverRuleErrorKind {
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetResolverRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetResolverRuleErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            GetResolverRuleErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetResolverRuleErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetResolverRuleErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetResolverRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetResolverRuleError {
    fn code(&self) -> Option<&str> {
        GetResolverRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetResolverRuleError {
    pub fn new(kind: GetResolverRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetResolverRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetResolverRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverRuleErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverRuleErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverRuleErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetResolverRuleErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for GetResolverRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetResolverRuleErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            GetResolverRuleErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetResolverRuleErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetResolverRuleErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetResolverRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetResolverRuleAssociationError {
    pub kind: GetResolverRuleAssociationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetResolverRuleAssociationErrorKind {
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetResolverRuleAssociationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetResolverRuleAssociationErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            GetResolverRuleAssociationErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetResolverRuleAssociationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetResolverRuleAssociationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetResolverRuleAssociationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetResolverRuleAssociationError {
    fn code(&self) -> Option<&str> {
        GetResolverRuleAssociationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetResolverRuleAssociationError {
    pub fn new(kind: GetResolverRuleAssociationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetResolverRuleAssociationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetResolverRuleAssociationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverRuleAssociationErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverRuleAssociationErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverRuleAssociationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverRuleAssociationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetResolverRuleAssociationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetResolverRuleAssociationErrorKind::InternalServiceErrorException(_inner) => {
                Some(_inner)
            }
            GetResolverRuleAssociationErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetResolverRuleAssociationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetResolverRuleAssociationErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetResolverRuleAssociationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetResolverRulePolicyError {
    pub kind: GetResolverRulePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetResolverRulePolicyErrorKind {
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    UnknownResourceException(crate::error::UnknownResourceException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetResolverRulePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetResolverRulePolicyErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            GetResolverRulePolicyErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetResolverRulePolicyErrorKind::UnknownResourceException(_inner) => _inner.fmt(f),
            GetResolverRulePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetResolverRulePolicyError {
    fn code(&self) -> Option<&str> {
        GetResolverRulePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetResolverRulePolicyError {
    pub fn new(kind: GetResolverRulePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetResolverRulePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetResolverRulePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverRulePolicyErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverRulePolicyErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_unknown_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverRulePolicyErrorKind::UnknownResourceException(_)
        )
    }
}
impl std::error::Error for GetResolverRulePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetResolverRulePolicyErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            GetResolverRulePolicyErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetResolverRulePolicyErrorKind::UnknownResourceException(_inner) => Some(_inner),
            GetResolverRulePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ImportFirewallDomainsError {
    pub kind: ImportFirewallDomainsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ImportFirewallDomainsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ImportFirewallDomainsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ImportFirewallDomainsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ImportFirewallDomainsErrorKind::ConflictException(_inner) => _inner.fmt(f),
            ImportFirewallDomainsErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            ImportFirewallDomainsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ImportFirewallDomainsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ImportFirewallDomainsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ImportFirewallDomainsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ImportFirewallDomainsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ImportFirewallDomainsError {
    fn code(&self) -> Option<&str> {
        ImportFirewallDomainsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ImportFirewallDomainsError {
    pub fn new(kind: ImportFirewallDomainsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ImportFirewallDomainsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ImportFirewallDomainsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportFirewallDomainsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportFirewallDomainsErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportFirewallDomainsErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportFirewallDomainsErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportFirewallDomainsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportFirewallDomainsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportFirewallDomainsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ImportFirewallDomainsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ImportFirewallDomainsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ImportFirewallDomainsErrorKind::ConflictException(_inner) => Some(_inner),
            ImportFirewallDomainsErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            ImportFirewallDomainsErrorKind::LimitExceededException(_inner) => Some(_inner),
            ImportFirewallDomainsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ImportFirewallDomainsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ImportFirewallDomainsErrorKind::ValidationException(_inner) => Some(_inner),
            ImportFirewallDomainsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFirewallConfigsError {
    pub kind: ListFirewallConfigsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFirewallConfigsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFirewallConfigsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFirewallConfigsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListFirewallConfigsErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            ListFirewallConfigsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListFirewallConfigsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListFirewallConfigsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListFirewallConfigsError {
    fn code(&self) -> Option<&str> {
        ListFirewallConfigsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFirewallConfigsError {
    pub fn new(kind: ListFirewallConfigsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFirewallConfigsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFirewallConfigsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallConfigsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallConfigsErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallConfigsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallConfigsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListFirewallConfigsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFirewallConfigsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListFirewallConfigsErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            ListFirewallConfigsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListFirewallConfigsErrorKind::ValidationException(_inner) => Some(_inner),
            ListFirewallConfigsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFirewallDomainListsError {
    pub kind: ListFirewallDomainListsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFirewallDomainListsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFirewallDomainListsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFirewallDomainListsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListFirewallDomainListsErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            ListFirewallDomainListsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListFirewallDomainListsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListFirewallDomainListsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListFirewallDomainListsError {
    fn code(&self) -> Option<&str> {
        ListFirewallDomainListsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFirewallDomainListsError {
    pub fn new(kind: ListFirewallDomainListsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFirewallDomainListsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFirewallDomainListsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallDomainListsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallDomainListsErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallDomainListsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallDomainListsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListFirewallDomainListsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFirewallDomainListsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListFirewallDomainListsErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            ListFirewallDomainListsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListFirewallDomainListsErrorKind::ValidationException(_inner) => Some(_inner),
            ListFirewallDomainListsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFirewallDomainsError {
    pub kind: ListFirewallDomainsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFirewallDomainsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFirewallDomainsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFirewallDomainsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListFirewallDomainsErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            ListFirewallDomainsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListFirewallDomainsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListFirewallDomainsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListFirewallDomainsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListFirewallDomainsError {
    fn code(&self) -> Option<&str> {
        ListFirewallDomainsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFirewallDomainsError {
    pub fn new(kind: ListFirewallDomainsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFirewallDomainsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFirewallDomainsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallDomainsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallDomainsErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallDomainsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallDomainsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallDomainsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListFirewallDomainsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFirewallDomainsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListFirewallDomainsErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            ListFirewallDomainsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListFirewallDomainsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListFirewallDomainsErrorKind::ValidationException(_inner) => Some(_inner),
            ListFirewallDomainsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFirewallRuleGroupAssociationsError {
    pub kind: ListFirewallRuleGroupAssociationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFirewallRuleGroupAssociationsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFirewallRuleGroupAssociationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFirewallRuleGroupAssociationsErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            ListFirewallRuleGroupAssociationsErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            ListFirewallRuleGroupAssociationsErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            ListFirewallRuleGroupAssociationsErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            ListFirewallRuleGroupAssociationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListFirewallRuleGroupAssociationsError {
    fn code(&self) -> Option<&str> {
        ListFirewallRuleGroupAssociationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFirewallRuleGroupAssociationsError {
    pub fn new(
        kind: ListFirewallRuleGroupAssociationsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFirewallRuleGroupAssociationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFirewallRuleGroupAssociationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallRuleGroupAssociationsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallRuleGroupAssociationsErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallRuleGroupAssociationsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallRuleGroupAssociationsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListFirewallRuleGroupAssociationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFirewallRuleGroupAssociationsErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            ListFirewallRuleGroupAssociationsErrorKind::InternalServiceErrorException(_inner) => {
                Some(_inner)
            }
            ListFirewallRuleGroupAssociationsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListFirewallRuleGroupAssociationsErrorKind::ValidationException(_inner) => Some(_inner),
            ListFirewallRuleGroupAssociationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFirewallRuleGroupsError {
    pub kind: ListFirewallRuleGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFirewallRuleGroupsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFirewallRuleGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFirewallRuleGroupsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListFirewallRuleGroupsErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            ListFirewallRuleGroupsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListFirewallRuleGroupsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListFirewallRuleGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListFirewallRuleGroupsError {
    fn code(&self) -> Option<&str> {
        ListFirewallRuleGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFirewallRuleGroupsError {
    pub fn new(kind: ListFirewallRuleGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFirewallRuleGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFirewallRuleGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallRuleGroupsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallRuleGroupsErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallRuleGroupsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallRuleGroupsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListFirewallRuleGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFirewallRuleGroupsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListFirewallRuleGroupsErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            ListFirewallRuleGroupsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListFirewallRuleGroupsErrorKind::ValidationException(_inner) => Some(_inner),
            ListFirewallRuleGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFirewallRulesError {
    pub kind: ListFirewallRulesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFirewallRulesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFirewallRulesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFirewallRulesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListFirewallRulesErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            ListFirewallRulesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListFirewallRulesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListFirewallRulesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListFirewallRulesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListFirewallRulesError {
    fn code(&self) -> Option<&str> {
        ListFirewallRulesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFirewallRulesError {
    pub fn new(kind: ListFirewallRulesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFirewallRulesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFirewallRulesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallRulesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallRulesErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallRulesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallRulesErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFirewallRulesErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListFirewallRulesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFirewallRulesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListFirewallRulesErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            ListFirewallRulesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListFirewallRulesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListFirewallRulesErrorKind::ValidationException(_inner) => Some(_inner),
            ListFirewallRulesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListResolverDnssecConfigsError {
    pub kind: ListResolverDnssecConfigsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListResolverDnssecConfigsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListResolverDnssecConfigsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListResolverDnssecConfigsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListResolverDnssecConfigsErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            ListResolverDnssecConfigsErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListResolverDnssecConfigsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListResolverDnssecConfigsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListResolverDnssecConfigsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListResolverDnssecConfigsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListResolverDnssecConfigsError {
    fn code(&self) -> Option<&str> {
        ListResolverDnssecConfigsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListResolverDnssecConfigsError {
    pub fn new(kind: ListResolverDnssecConfigsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListResolverDnssecConfigsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListResolverDnssecConfigsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverDnssecConfigsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverDnssecConfigsErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverDnssecConfigsErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverDnssecConfigsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverDnssecConfigsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverDnssecConfigsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListResolverDnssecConfigsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListResolverDnssecConfigsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListResolverDnssecConfigsErrorKind::InternalServiceErrorException(_inner) => {
                Some(_inner)
            }
            ListResolverDnssecConfigsErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListResolverDnssecConfigsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListResolverDnssecConfigsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListResolverDnssecConfigsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListResolverDnssecConfigsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListResolverEndpointIpAddressesError {
    pub kind: ListResolverEndpointIpAddressesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListResolverEndpointIpAddressesErrorKind {
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListResolverEndpointIpAddressesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListResolverEndpointIpAddressesErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            ListResolverEndpointIpAddressesErrorKind::InvalidNextTokenException(_inner) => {
                _inner.fmt(f)
            }
            ListResolverEndpointIpAddressesErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            ListResolverEndpointIpAddressesErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListResolverEndpointIpAddressesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListResolverEndpointIpAddressesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListResolverEndpointIpAddressesError {
    fn code(&self) -> Option<&str> {
        ListResolverEndpointIpAddressesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListResolverEndpointIpAddressesError {
    pub fn new(kind: ListResolverEndpointIpAddressesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListResolverEndpointIpAddressesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListResolverEndpointIpAddressesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverEndpointIpAddressesErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverEndpointIpAddressesErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverEndpointIpAddressesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverEndpointIpAddressesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverEndpointIpAddressesErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListResolverEndpointIpAddressesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListResolverEndpointIpAddressesErrorKind::InternalServiceErrorException(_inner) => {
                Some(_inner)
            }
            ListResolverEndpointIpAddressesErrorKind::InvalidNextTokenException(_inner) => {
                Some(_inner)
            }
            ListResolverEndpointIpAddressesErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            ListResolverEndpointIpAddressesErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ListResolverEndpointIpAddressesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListResolverEndpointIpAddressesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListResolverEndpointsError {
    pub kind: ListResolverEndpointsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListResolverEndpointsErrorKind {
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListResolverEndpointsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListResolverEndpointsErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            ListResolverEndpointsErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListResolverEndpointsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListResolverEndpointsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListResolverEndpointsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListResolverEndpointsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListResolverEndpointsError {
    fn code(&self) -> Option<&str> {
        ListResolverEndpointsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListResolverEndpointsError {
    pub fn new(kind: ListResolverEndpointsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListResolverEndpointsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListResolverEndpointsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverEndpointsErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverEndpointsErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverEndpointsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverEndpointsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverEndpointsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListResolverEndpointsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListResolverEndpointsErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            ListResolverEndpointsErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListResolverEndpointsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListResolverEndpointsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListResolverEndpointsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListResolverEndpointsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListResolverQueryLogConfigAssociationsError {
    pub kind: ListResolverQueryLogConfigAssociationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListResolverQueryLogConfigAssociationsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListResolverQueryLogConfigAssociationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListResolverQueryLogConfigAssociationsErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            ListResolverQueryLogConfigAssociationsErrorKind::InternalServiceErrorException(
                _inner,
            ) => _inner.fmt(f),
            ListResolverQueryLogConfigAssociationsErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            ListResolverQueryLogConfigAssociationsErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListResolverQueryLogConfigAssociationsErrorKind::LimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            ListResolverQueryLogConfigAssociationsErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            ListResolverQueryLogConfigAssociationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListResolverQueryLogConfigAssociationsError {
    fn code(&self) -> Option<&str> {
        ListResolverQueryLogConfigAssociationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListResolverQueryLogConfigAssociationsError {
    pub fn new(
        kind: ListResolverQueryLogConfigAssociationsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListResolverQueryLogConfigAssociationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListResolverQueryLogConfigAssociationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverQueryLogConfigAssociationsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverQueryLogConfigAssociationsErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverQueryLogConfigAssociationsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverQueryLogConfigAssociationsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverQueryLogConfigAssociationsErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverQueryLogConfigAssociationsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListResolverQueryLogConfigAssociationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListResolverQueryLogConfigAssociationsErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            ListResolverQueryLogConfigAssociationsErrorKind::InternalServiceErrorException(
                _inner,
            ) => Some(_inner),
            ListResolverQueryLogConfigAssociationsErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            ListResolverQueryLogConfigAssociationsErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            ListResolverQueryLogConfigAssociationsErrorKind::LimitExceededException(_inner) => {
                Some(_inner)
            }
            ListResolverQueryLogConfigAssociationsErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            ListResolverQueryLogConfigAssociationsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListResolverQueryLogConfigsError {
    pub kind: ListResolverQueryLogConfigsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListResolverQueryLogConfigsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListResolverQueryLogConfigsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListResolverQueryLogConfigsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListResolverQueryLogConfigsErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            ListResolverQueryLogConfigsErrorKind::InvalidNextTokenException(_inner) => {
                _inner.fmt(f)
            }
            ListResolverQueryLogConfigsErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            ListResolverQueryLogConfigsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListResolverQueryLogConfigsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListResolverQueryLogConfigsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListResolverQueryLogConfigsError {
    fn code(&self) -> Option<&str> {
        ListResolverQueryLogConfigsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListResolverQueryLogConfigsError {
    pub fn new(kind: ListResolverQueryLogConfigsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListResolverQueryLogConfigsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListResolverQueryLogConfigsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverQueryLogConfigsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverQueryLogConfigsErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverQueryLogConfigsErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverQueryLogConfigsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverQueryLogConfigsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverQueryLogConfigsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListResolverQueryLogConfigsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListResolverQueryLogConfigsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListResolverQueryLogConfigsErrorKind::InternalServiceErrorException(_inner) => {
                Some(_inner)
            }
            ListResolverQueryLogConfigsErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListResolverQueryLogConfigsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListResolverQueryLogConfigsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListResolverQueryLogConfigsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListResolverQueryLogConfigsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListResolverRuleAssociationsError {
    pub kind: ListResolverRuleAssociationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListResolverRuleAssociationsErrorKind {
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListResolverRuleAssociationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListResolverRuleAssociationsErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            ListResolverRuleAssociationsErrorKind::InvalidNextTokenException(_inner) => {
                _inner.fmt(f)
            }
            ListResolverRuleAssociationsErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            ListResolverRuleAssociationsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListResolverRuleAssociationsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListResolverRuleAssociationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListResolverRuleAssociationsError {
    fn code(&self) -> Option<&str> {
        ListResolverRuleAssociationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListResolverRuleAssociationsError {
    pub fn new(kind: ListResolverRuleAssociationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListResolverRuleAssociationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListResolverRuleAssociationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverRuleAssociationsErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverRuleAssociationsErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverRuleAssociationsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverRuleAssociationsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverRuleAssociationsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListResolverRuleAssociationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListResolverRuleAssociationsErrorKind::InternalServiceErrorException(_inner) => {
                Some(_inner)
            }
            ListResolverRuleAssociationsErrorKind::InvalidNextTokenException(_inner) => {
                Some(_inner)
            }
            ListResolverRuleAssociationsErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            ListResolverRuleAssociationsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListResolverRuleAssociationsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListResolverRuleAssociationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListResolverRulesError {
    pub kind: ListResolverRulesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListResolverRulesErrorKind {
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListResolverRulesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListResolverRulesErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            ListResolverRulesErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListResolverRulesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListResolverRulesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListResolverRulesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListResolverRulesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListResolverRulesError {
    fn code(&self) -> Option<&str> {
        ListResolverRulesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListResolverRulesError {
    pub fn new(kind: ListResolverRulesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListResolverRulesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListResolverRulesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverRulesErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverRulesErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverRulesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverRulesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolverRulesErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListResolverRulesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListResolverRulesErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            ListResolverRulesErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListResolverRulesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListResolverRulesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListResolverRulesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListResolverRulesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutFirewallRuleGroupPolicyError {
    pub kind: PutFirewallRuleGroupPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutFirewallRuleGroupPolicyErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutFirewallRuleGroupPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutFirewallRuleGroupPolicyErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            PutFirewallRuleGroupPolicyErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            PutFirewallRuleGroupPolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            PutFirewallRuleGroupPolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            PutFirewallRuleGroupPolicyErrorKind::ValidationException(_inner) => _inner.fmt(f),
            PutFirewallRuleGroupPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutFirewallRuleGroupPolicyError {
    fn code(&self) -> Option<&str> {
        PutFirewallRuleGroupPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutFirewallRuleGroupPolicyError {
    pub fn new(kind: PutFirewallRuleGroupPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutFirewallRuleGroupPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutFirewallRuleGroupPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFirewallRuleGroupPolicyErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFirewallRuleGroupPolicyErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFirewallRuleGroupPolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFirewallRuleGroupPolicyErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFirewallRuleGroupPolicyErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for PutFirewallRuleGroupPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutFirewallRuleGroupPolicyErrorKind::AccessDeniedException(_inner) => Some(_inner),
            PutFirewallRuleGroupPolicyErrorKind::InternalServiceErrorException(_inner) => {
                Some(_inner)
            }
            PutFirewallRuleGroupPolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            PutFirewallRuleGroupPolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            PutFirewallRuleGroupPolicyErrorKind::ValidationException(_inner) => Some(_inner),
            PutFirewallRuleGroupPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutResolverQueryLogConfigPolicyError {
    pub kind: PutResolverQueryLogConfigPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutResolverQueryLogConfigPolicyErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidPolicyDocument(crate::error::InvalidPolicyDocument),
    InvalidRequestException(crate::error::InvalidRequestException),
    UnknownResourceException(crate::error::UnknownResourceException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutResolverQueryLogConfigPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutResolverQueryLogConfigPolicyErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            PutResolverQueryLogConfigPolicyErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            PutResolverQueryLogConfigPolicyErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            PutResolverQueryLogConfigPolicyErrorKind::InvalidPolicyDocument(_inner) => {
                _inner.fmt(f)
            }
            PutResolverQueryLogConfigPolicyErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            PutResolverQueryLogConfigPolicyErrorKind::UnknownResourceException(_inner) => {
                _inner.fmt(f)
            }
            PutResolverQueryLogConfigPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutResolverQueryLogConfigPolicyError {
    fn code(&self) -> Option<&str> {
        PutResolverQueryLogConfigPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutResolverQueryLogConfigPolicyError {
    pub fn new(kind: PutResolverQueryLogConfigPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutResolverQueryLogConfigPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutResolverQueryLogConfigPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutResolverQueryLogConfigPolicyErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutResolverQueryLogConfigPolicyErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutResolverQueryLogConfigPolicyErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_policy_document(&self) -> bool {
        matches!(
            &self.kind,
            PutResolverQueryLogConfigPolicyErrorKind::InvalidPolicyDocument(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutResolverQueryLogConfigPolicyErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_unknown_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutResolverQueryLogConfigPolicyErrorKind::UnknownResourceException(_)
        )
    }
}
impl std::error::Error for PutResolverQueryLogConfigPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutResolverQueryLogConfigPolicyErrorKind::AccessDeniedException(_inner) => Some(_inner),
            PutResolverQueryLogConfigPolicyErrorKind::InternalServiceErrorException(_inner) => {
                Some(_inner)
            }
            PutResolverQueryLogConfigPolicyErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            PutResolverQueryLogConfigPolicyErrorKind::InvalidPolicyDocument(_inner) => Some(_inner),
            PutResolverQueryLogConfigPolicyErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            PutResolverQueryLogConfigPolicyErrorKind::UnknownResourceException(_inner) => {
                Some(_inner)
            }
            PutResolverQueryLogConfigPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutResolverRulePolicyError {
    pub kind: PutResolverRulePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutResolverRulePolicyErrorKind {
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidPolicyDocument(crate::error::InvalidPolicyDocument),
    UnknownResourceException(crate::error::UnknownResourceException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutResolverRulePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutResolverRulePolicyErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            PutResolverRulePolicyErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            PutResolverRulePolicyErrorKind::InvalidPolicyDocument(_inner) => _inner.fmt(f),
            PutResolverRulePolicyErrorKind::UnknownResourceException(_inner) => _inner.fmt(f),
            PutResolverRulePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutResolverRulePolicyError {
    fn code(&self) -> Option<&str> {
        PutResolverRulePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutResolverRulePolicyError {
    pub fn new(kind: PutResolverRulePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutResolverRulePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutResolverRulePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutResolverRulePolicyErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutResolverRulePolicyErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_policy_document(&self) -> bool {
        matches!(
            &self.kind,
            PutResolverRulePolicyErrorKind::InvalidPolicyDocument(_)
        )
    }
    pub fn is_unknown_resource_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutResolverRulePolicyErrorKind::UnknownResourceException(_)
        )
    }
}
impl std::error::Error for PutResolverRulePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutResolverRulePolicyErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            PutResolverRulePolicyErrorKind::InvalidParameterException(_inner) => Some(_inner),
            PutResolverRulePolicyErrorKind::InvalidPolicyDocument(_inner) => Some(_inner),
            PutResolverRulePolicyErrorKind::UnknownResourceException(_inner) => Some(_inner),
            PutResolverRulePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    InvalidTagException(crate::error::InvalidTagException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidTagException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InvalidRequestException(_))
    }
    pub fn is_invalid_tag_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InvalidTagException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::LimitExceededException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidRequestException(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidTagException(_inner) => Some(_inner),
            TagResourceErrorKind::LimitExceededException(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateFirewallConfigError {
    pub kind: UpdateFirewallConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFirewallConfigErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateFirewallConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateFirewallConfigErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateFirewallConfigErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            UpdateFirewallConfigErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateFirewallConfigErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateFirewallConfigErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateFirewallConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateFirewallConfigError {
    fn code(&self) -> Option<&str> {
        UpdateFirewallConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateFirewallConfigError {
    pub fn new(kind: UpdateFirewallConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateFirewallConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateFirewallConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFirewallConfigErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFirewallConfigErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFirewallConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFirewallConfigErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFirewallConfigErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateFirewallConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateFirewallConfigErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateFirewallConfigErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            UpdateFirewallConfigErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateFirewallConfigErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateFirewallConfigErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateFirewallConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateFirewallDomainsError {
    pub kind: UpdateFirewallDomainsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFirewallDomainsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateFirewallDomainsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateFirewallDomainsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateFirewallDomainsErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateFirewallDomainsErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            UpdateFirewallDomainsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateFirewallDomainsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateFirewallDomainsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateFirewallDomainsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateFirewallDomainsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateFirewallDomainsError {
    fn code(&self) -> Option<&str> {
        UpdateFirewallDomainsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateFirewallDomainsError {
    pub fn new(kind: UpdateFirewallDomainsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateFirewallDomainsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateFirewallDomainsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFirewallDomainsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFirewallDomainsErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFirewallDomainsErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFirewallDomainsErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFirewallDomainsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFirewallDomainsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFirewallDomainsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateFirewallDomainsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateFirewallDomainsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateFirewallDomainsErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateFirewallDomainsErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            UpdateFirewallDomainsErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateFirewallDomainsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateFirewallDomainsErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateFirewallDomainsErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateFirewallDomainsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateFirewallRuleError {
    pub kind: UpdateFirewallRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFirewallRuleErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateFirewallRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateFirewallRuleErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateFirewallRuleErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateFirewallRuleErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            UpdateFirewallRuleErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateFirewallRuleErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateFirewallRuleErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateFirewallRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateFirewallRuleError {
    fn code(&self) -> Option<&str> {
        UpdateFirewallRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateFirewallRuleError {
    pub fn new(kind: UpdateFirewallRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateFirewallRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateFirewallRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFirewallRuleErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFirewallRuleErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFirewallRuleErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFirewallRuleErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFirewallRuleErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFirewallRuleErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateFirewallRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateFirewallRuleErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateFirewallRuleErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateFirewallRuleErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            UpdateFirewallRuleErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateFirewallRuleErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateFirewallRuleErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateFirewallRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateFirewallRuleGroupAssociationError {
    pub kind: UpdateFirewallRuleGroupAssociationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFirewallRuleGroupAssociationErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateFirewallRuleGroupAssociationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateFirewallRuleGroupAssociationErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateFirewallRuleGroupAssociationErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateFirewallRuleGroupAssociationErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            UpdateFirewallRuleGroupAssociationErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateFirewallRuleGroupAssociationErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            UpdateFirewallRuleGroupAssociationErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            UpdateFirewallRuleGroupAssociationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateFirewallRuleGroupAssociationError {
    fn code(&self) -> Option<&str> {
        UpdateFirewallRuleGroupAssociationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateFirewallRuleGroupAssociationError {
    pub fn new(
        kind: UpdateFirewallRuleGroupAssociationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateFirewallRuleGroupAssociationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateFirewallRuleGroupAssociationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFirewallRuleGroupAssociationErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFirewallRuleGroupAssociationErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFirewallRuleGroupAssociationErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFirewallRuleGroupAssociationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFirewallRuleGroupAssociationErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFirewallRuleGroupAssociationErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateFirewallRuleGroupAssociationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateFirewallRuleGroupAssociationErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            UpdateFirewallRuleGroupAssociationErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateFirewallRuleGroupAssociationErrorKind::InternalServiceErrorException(_inner) => {
                Some(_inner)
            }
            UpdateFirewallRuleGroupAssociationErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateFirewallRuleGroupAssociationErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            UpdateFirewallRuleGroupAssociationErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            UpdateFirewallRuleGroupAssociationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateResolverDnssecConfigError {
    pub kind: UpdateResolverDnssecConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateResolverDnssecConfigErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateResolverDnssecConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateResolverDnssecConfigErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateResolverDnssecConfigErrorKind::InternalServiceErrorException(_inner) => {
                _inner.fmt(f)
            }
            UpdateResolverDnssecConfigErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateResolverDnssecConfigErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateResolverDnssecConfigErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateResolverDnssecConfigErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateResolverDnssecConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateResolverDnssecConfigError {
    fn code(&self) -> Option<&str> {
        UpdateResolverDnssecConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateResolverDnssecConfigError {
    pub fn new(kind: UpdateResolverDnssecConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateResolverDnssecConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateResolverDnssecConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResolverDnssecConfigErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResolverDnssecConfigErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResolverDnssecConfigErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResolverDnssecConfigErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResolverDnssecConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResolverDnssecConfigErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateResolverDnssecConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateResolverDnssecConfigErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateResolverDnssecConfigErrorKind::InternalServiceErrorException(_inner) => {
                Some(_inner)
            }
            UpdateResolverDnssecConfigErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateResolverDnssecConfigErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateResolverDnssecConfigErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateResolverDnssecConfigErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateResolverDnssecConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateResolverEndpointError {
    pub kind: UpdateResolverEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateResolverEndpointErrorKind {
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateResolverEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateResolverEndpointErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            UpdateResolverEndpointErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateResolverEndpointErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateResolverEndpointErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateResolverEndpointErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateResolverEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateResolverEndpointError {
    fn code(&self) -> Option<&str> {
        UpdateResolverEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateResolverEndpointError {
    pub fn new(kind: UpdateResolverEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateResolverEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateResolverEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResolverEndpointErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResolverEndpointErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResolverEndpointErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResolverEndpointErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResolverEndpointErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateResolverEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateResolverEndpointErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            UpdateResolverEndpointErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateResolverEndpointErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateResolverEndpointErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateResolverEndpointErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateResolverEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateResolverRuleError {
    pub kind: UpdateResolverRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateResolverRuleErrorKind {
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateResolverRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateResolverRuleErrorKind::InternalServiceErrorException(_inner) => _inner.fmt(f),
            UpdateResolverRuleErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateResolverRuleErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateResolverRuleErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateResolverRuleErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateResolverRuleErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            UpdateResolverRuleErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateResolverRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateResolverRuleError {
    fn code(&self) -> Option<&str> {
        UpdateResolverRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateResolverRuleError {
    pub fn new(kind: UpdateResolverRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateResolverRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateResolverRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResolverRuleErrorKind::InternalServiceErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResolverRuleErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResolverRuleErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResolverRuleErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResolverRuleErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResolverRuleErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResolverRuleErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateResolverRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateResolverRuleErrorKind::InternalServiceErrorException(_inner) => Some(_inner),
            UpdateResolverRuleErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateResolverRuleErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateResolverRuleErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateResolverRuleErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateResolverRuleErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            UpdateResolverRuleErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateResolverRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The request was throttled. Try again in a few minutes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ThrottlingException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ThrottlingException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ThrottlingException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottlingException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ThrottlingException {}
/// See [`ThrottlingException`](crate::error::ThrottlingException)
pub mod throttling_exception {
    /// A builder for [`ThrottlingException`](crate::error::ThrottlingException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ThrottlingException`](crate::error::ThrottlingException)
        pub fn build(self) -> crate::error::ThrottlingException {
            crate::error::ThrottlingException {
                message: self.message,
            }
        }
    }
}
impl ThrottlingException {
    /// Creates a new builder-style object to manufacture [`ThrottlingException`](crate::error::ThrottlingException)
    pub fn builder() -> crate::error::throttling_exception::Builder {
        crate::error::throttling_exception::Builder::default()
    }
}

/// <p>The specified resource isn't available.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceUnavailableException {
    pub message: std::option::Option<std::string::String>,
    /// <p>For a <code>ResourceUnavailableException</code> error, the type of resource that isn't available.</p>
    pub resource_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceUnavailableException");
        formatter.field("message", &self.message);
        formatter.field("resource_type", &self.resource_type);
        formatter.finish()
    }
}
impl ResourceUnavailableException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceUnavailableException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceUnavailableException {}
/// See [`ResourceUnavailableException`](crate::error::ResourceUnavailableException)
pub mod resource_unavailable_exception {
    /// A builder for [`ResourceUnavailableException`](crate::error::ResourceUnavailableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>For a <code>ResourceUnavailableException</code> error, the type of resource that isn't available.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceUnavailableException`](crate::error::ResourceUnavailableException)
        pub fn build(self) -> crate::error::ResourceUnavailableException {
            crate::error::ResourceUnavailableException {
                message: self.message,
                resource_type: self.resource_type,
            }
        }
    }
}
impl ResourceUnavailableException {
    /// Creates a new builder-style object to manufacture [`ResourceUnavailableException`](crate::error::ResourceUnavailableException)
    pub fn builder() -> crate::error::resource_unavailable_exception::Builder {
        crate::error::resource_unavailable_exception::Builder::default()
    }
}

/// <p>The specified resource doesn't exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    pub message: std::option::Option<std::string::String>,
    /// <p>For a <code>ResourceNotFoundException</code> error, the type of resource that doesn't exist.</p>
    pub resource_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &self.message);
        formatter.field("resource_type", &self.resource_type);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>For a <code>ResourceNotFoundException</code> error, the type of resource that doesn't exist.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
                resource_type: self.resource_type,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>The request caused one or more limits to be exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    pub message: std::option::Option<std::string::String>,
    /// <p>For a <code>LimitExceededException</code> error, the type of resource that exceeded the current limit.</p>
    pub resource_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.field("resource_type", &self.resource_type);
        formatter.finish()
    }
}
impl LimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>For a <code>LimitExceededException</code> error, the type of resource that exceeded the current limit.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
                resource_type: self.resource_type,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>The request is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRequestException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRequestException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRequestException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRequestException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRequestException {}
/// See [`InvalidRequestException`](crate::error::InvalidRequestException)
pub mod invalid_request_exception {
    /// A builder for [`InvalidRequestException`](crate::error::InvalidRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRequestException`](crate::error::InvalidRequestException)
        pub fn build(self) -> crate::error::InvalidRequestException {
            crate::error::InvalidRequestException {
                message: self.message,
            }
        }
    }
}
impl InvalidRequestException {
    /// Creates a new builder-style object to manufacture [`InvalidRequestException`](crate::error::InvalidRequestException)
    pub fn builder() -> crate::error::invalid_request_exception::Builder {
        crate::error::invalid_request_exception::Builder::default()
    }
}

/// <p>One or more parameters in this request are not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParameterException {
    pub message: std::option::Option<std::string::String>,
    /// <p>For an <code>InvalidParameterException</code> error, the name of the parameter that's invalid.</p>
    pub field_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParameterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParameterException");
        formatter.field("message", &self.message);
        formatter.field("field_name", &self.field_name);
        formatter.finish()
    }
}
impl InvalidParameterException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterException {}
/// See [`InvalidParameterException`](crate::error::InvalidParameterException)
pub mod invalid_parameter_exception {
    /// A builder for [`InvalidParameterException`](crate::error::InvalidParameterException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) field_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>For an <code>InvalidParameterException</code> error, the name of the parameter that's invalid.</p>
        pub fn field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_name = Some(input.into());
            self
        }
        pub fn set_field_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_name = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterException`](crate::error::InvalidParameterException)
        pub fn build(self) -> crate::error::InvalidParameterException {
            crate::error::InvalidParameterException {
                message: self.message,
                field_name: self.field_name,
            }
        }
    }
}
impl InvalidParameterException {
    /// Creates a new builder-style object to manufacture [`InvalidParameterException`](crate::error::InvalidParameterException)
    pub fn builder() -> crate::error::invalid_parameter_exception::Builder {
        crate::error::invalid_parameter_exception::Builder::default()
    }
}

/// <p>We encountered an unknown error. Try again in a few minutes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServiceErrorException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServiceErrorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServiceErrorException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServiceErrorException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServiceErrorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServiceErrorException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServiceErrorException {}
/// See [`InternalServiceErrorException`](crate::error::InternalServiceErrorException)
pub mod internal_service_error_exception {
    /// A builder for [`InternalServiceErrorException`](crate::error::InternalServiceErrorException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServiceErrorException`](crate::error::InternalServiceErrorException)
        pub fn build(self) -> crate::error::InternalServiceErrorException {
            crate::error::InternalServiceErrorException {
                message: self.message,
            }
        }
    }
}
impl InternalServiceErrorException {
    /// Creates a new builder-style object to manufacture [`InternalServiceErrorException`](crate::error::InternalServiceErrorException)
    pub fn builder() -> crate::error::internal_service_error_exception::Builder {
        crate::error::internal_service_error_exception::Builder::default()
    }
}

/// <p>The current account doesn't have the IAM permissions required to perform the specified Resolver operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccessDeniedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccessDeniedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AccessDeniedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException)
pub mod access_denied_exception {
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException)
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message,
            }
        }
    }
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException)
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ValidationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ValidationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ValidationException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for ValidationException {}
/// See [`ValidationException`](crate::error::ValidationException)
pub mod validation_exception {
    /// A builder for [`ValidationException`](crate::error::ValidationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationException`](crate::error::ValidationException)
        pub fn build(self) -> crate::error::ValidationException {
            crate::error::ValidationException {
                message: self.message,
            }
        }
    }
}
impl ValidationException {
    /// Creates a new builder-style object to manufacture [`ValidationException`](crate::error::ValidationException)
    pub fn builder() -> crate::error::validation_exception::Builder {
        crate::error::validation_exception::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// <p>The specified tag is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidTagException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidTagException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidTagException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidTagException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTagException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTagException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTagException {}
/// See [`InvalidTagException`](crate::error::InvalidTagException)
pub mod invalid_tag_exception {
    /// A builder for [`InvalidTagException`](crate::error::InvalidTagException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTagException`](crate::error::InvalidTagException)
        pub fn build(self) -> crate::error::InvalidTagException {
            crate::error::InvalidTagException {
                message: self.message,
            }
        }
    }
}
impl InvalidTagException {
    /// Creates a new builder-style object to manufacture [`InvalidTagException`](crate::error::InvalidTagException)
    pub fn builder() -> crate::error::invalid_tag_exception::Builder {
        crate::error::invalid_tag_exception::Builder::default()
    }
}

/// <p>The specified resource doesn't exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnknownResourceException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnknownResourceException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnknownResourceException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnknownResourceException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnknownResourceException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnknownResourceException")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnknownResourceException {}
/// See [`UnknownResourceException`](crate::error::UnknownResourceException)
pub mod unknown_resource_exception {
    /// A builder for [`UnknownResourceException`](crate::error::UnknownResourceException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnknownResourceException`](crate::error::UnknownResourceException)
        pub fn build(self) -> crate::error::UnknownResourceException {
            crate::error::UnknownResourceException {
                message: self.message,
            }
        }
    }
}
impl UnknownResourceException {
    /// Creates a new builder-style object to manufacture [`UnknownResourceException`](crate::error::UnknownResourceException)
    pub fn builder() -> crate::error::unknown_resource_exception::Builder {
        crate::error::unknown_resource_exception::Builder::default()
    }
}

/// <p>The specified Resolver rule policy is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidPolicyDocument {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidPolicyDocument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidPolicyDocument");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidPolicyDocument {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPolicyDocument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPolicyDocument")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPolicyDocument {}
/// See [`InvalidPolicyDocument`](crate::error::InvalidPolicyDocument)
pub mod invalid_policy_document {
    /// A builder for [`InvalidPolicyDocument`](crate::error::InvalidPolicyDocument)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPolicyDocument`](crate::error::InvalidPolicyDocument)
        pub fn build(self) -> crate::error::InvalidPolicyDocument {
            crate::error::InvalidPolicyDocument {
                message: self.message,
            }
        }
    }
}
impl InvalidPolicyDocument {
    /// Creates a new builder-style object to manufacture [`InvalidPolicyDocument`](crate::error::InvalidPolicyDocument)
    pub fn builder() -> crate::error::invalid_policy_document::Builder {
        crate::error::invalid_policy_document::Builder::default()
    }
}

/// <p>The value that you specified for <code>NextToken</code> in a <code>List</code> request isn't valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidNextTokenException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidNextTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidNextTokenException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidNextTokenException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidNextTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidNextTokenException")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidNextTokenException {}
/// See [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
pub mod invalid_next_token_exception {
    /// A builder for [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
        pub fn build(self) -> crate::error::InvalidNextTokenException {
            crate::error::InvalidNextTokenException {
                message: self.message,
            }
        }
    }
}
impl InvalidNextTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
    pub fn builder() -> crate::error::invalid_next_token_exception::Builder {
        crate::error::invalid_next_token_exception::Builder::default()
    }
}

/// <p>The resource that you tried to create already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceExistsException {
    pub message: std::option::Option<std::string::String>,
    /// <p>For a <code>ResourceExistsException</code> error, the type of resource that the error applies to.</p>
    pub resource_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceExistsException");
        formatter.field("message", &self.message);
        formatter.field("resource_type", &self.resource_type);
        formatter.finish()
    }
}
impl ResourceExistsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceExistsException")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceExistsException {}
/// See [`ResourceExistsException`](crate::error::ResourceExistsException)
pub mod resource_exists_exception {
    /// A builder for [`ResourceExistsException`](crate::error::ResourceExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>For a <code>ResourceExistsException</code> error, the type of resource that the error applies to.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceExistsException`](crate::error::ResourceExistsException)
        pub fn build(self) -> crate::error::ResourceExistsException {
            crate::error::ResourceExistsException {
                message: self.message,
                resource_type: self.resource_type,
            }
        }
    }
}
impl ResourceExistsException {
    /// Creates a new builder-style object to manufacture [`ResourceExistsException`](crate::error::ResourceExistsException)
    pub fn builder() -> crate::error::resource_exists_exception::Builder {
        crate::error::resource_exists_exception::Builder::default()
    }
}

/// <p>The resource that you tried to update or delete is currently in use.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceInUseException {
    pub message: std::option::Option<std::string::String>,
    /// <p>For a <code>ResourceInUseException</code> error, the type of resource that is currently in use.</p>
    pub resource_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceInUseException");
        formatter.field("message", &self.message);
        formatter.field("resource_type", &self.resource_type);
        formatter.finish()
    }
}
impl ResourceInUseException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceInUseException")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceInUseException {}
/// See [`ResourceInUseException`](crate::error::ResourceInUseException)
pub mod resource_in_use_exception {
    /// A builder for [`ResourceInUseException`](crate::error::ResourceInUseException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>For a <code>ResourceInUseException</code> error, the type of resource that is currently in use.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceInUseException`](crate::error::ResourceInUseException)
        pub fn build(self) -> crate::error::ResourceInUseException {
            crate::error::ResourceInUseException {
                message: self.message,
                resource_type: self.resource_type,
            }
        }
    }
}
impl ResourceInUseException {
    /// Creates a new builder-style object to manufacture [`ResourceInUseException`](crate::error::ResourceInUseException)
    pub fn builder() -> crate::error::resource_in_use_exception::Builder {
        crate::error::resource_in_use_exception::Builder::default()
    }
}
