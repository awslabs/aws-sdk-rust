// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::update_resolver_endpoint::_update_resolver_endpoint_output::UpdateResolverEndpointOutputBuilder;

pub use crate::operation::update_resolver_endpoint::_update_resolver_endpoint_input::UpdateResolverEndpointInputBuilder;

impl crate::operation::update_resolver_endpoint::builders::UpdateResolverEndpointInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::update_resolver_endpoint::UpdateResolverEndpointOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::update_resolver_endpoint::UpdateResolverEndpointError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.update_resolver_endpoint();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `UpdateResolverEndpoint`.
///
/// <p>Updates the name, or endpoint type for an inbound or an outbound Resolver endpoint. You can only update between IPV4 and DUALSTACK, IPV6 endpoint type can't be updated to other type.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct UpdateResolverEndpointFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::update_resolver_endpoint::builders::UpdateResolverEndpointInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::update_resolver_endpoint::UpdateResolverEndpointOutput,
        crate::operation::update_resolver_endpoint::UpdateResolverEndpointError,
    > for UpdateResolverEndpointFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::update_resolver_endpoint::UpdateResolverEndpointOutput,
            crate::operation::update_resolver_endpoint::UpdateResolverEndpointError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl UpdateResolverEndpointFluentBuilder {
    /// Creates a new `UpdateResolverEndpoint`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the UpdateResolverEndpoint as a reference.
    pub fn as_input(&self) -> &crate::operation::update_resolver_endpoint::builders::UpdateResolverEndpointInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::update_resolver_endpoint::UpdateResolverEndpointOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::update_resolver_endpoint::UpdateResolverEndpointError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::update_resolver_endpoint::UpdateResolverEndpoint::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::update_resolver_endpoint::UpdateResolverEndpoint::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::update_resolver_endpoint::UpdateResolverEndpointOutput,
        crate::operation::update_resolver_endpoint::UpdateResolverEndpointError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The ID of the Resolver endpoint that you want to update.</p>
    pub fn resolver_endpoint_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.resolver_endpoint_id(input.into());
        self
    }
    /// <p>The ID of the Resolver endpoint that you want to update.</p>
    pub fn set_resolver_endpoint_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_resolver_endpoint_id(input);
        self
    }
    /// <p>The ID of the Resolver endpoint that you want to update.</p>
    pub fn get_resolver_endpoint_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_resolver_endpoint_id()
    }
    /// <p>The name of the Resolver endpoint that you want to update.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.name(input.into());
        self
    }
    /// <p>The name of the Resolver endpoint that you want to update.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_name(input);
        self
    }
    /// <p>The name of the Resolver endpoint that you want to update.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_name()
    }
    /// <p>Specifies the endpoint type for what type of IP address the endpoint uses to forward DNS queries.</p>
    /// <p>Updating to <code>IPV6</code> type isn't currently supported.</p>
    pub fn resolver_endpoint_type(mut self, input: crate::types::ResolverEndpointType) -> Self {
        self.inner = self.inner.resolver_endpoint_type(input);
        self
    }
    /// <p>Specifies the endpoint type for what type of IP address the endpoint uses to forward DNS queries.</p>
    /// <p>Updating to <code>IPV6</code> type isn't currently supported.</p>
    pub fn set_resolver_endpoint_type(mut self, input: ::std::option::Option<crate::types::ResolverEndpointType>) -> Self {
        self.inner = self.inner.set_resolver_endpoint_type(input);
        self
    }
    /// <p>Specifies the endpoint type for what type of IP address the endpoint uses to forward DNS queries.</p>
    /// <p>Updating to <code>IPV6</code> type isn't currently supported.</p>
    pub fn get_resolver_endpoint_type(&self) -> &::std::option::Option<crate::types::ResolverEndpointType> {
        self.inner.get_resolver_endpoint_type()
    }
    ///
    /// Appends an item to `UpdateIpAddresses`.
    ///
    /// To override the contents of this collection use [`set_update_ip_addresses`](Self::set_update_ip_addresses).
    ///
    /// <p>Specifies the IPv6 address when you update the Resolver endpoint from IPv4 to dual-stack. If you don't specify an IPv6 address, one will be automatically chosen from your subnet.</p>
    pub fn update_ip_addresses(mut self, input: crate::types::UpdateIpAddress) -> Self {
        self.inner = self.inner.update_ip_addresses(input);
        self
    }
    /// <p>Specifies the IPv6 address when you update the Resolver endpoint from IPv4 to dual-stack. If you don't specify an IPv6 address, one will be automatically chosen from your subnet.</p>
    pub fn set_update_ip_addresses(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::UpdateIpAddress>>) -> Self {
        self.inner = self.inner.set_update_ip_addresses(input);
        self
    }
    /// <p>Specifies the IPv6 address when you update the Resolver endpoint from IPv4 to dual-stack. If you don't specify an IPv6 address, one will be automatically chosen from your subnet.</p>
    pub fn get_update_ip_addresses(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::UpdateIpAddress>> {
        self.inner.get_update_ip_addresses()
    }
    ///
    /// Appends an item to `Protocols`.
    ///
    /// To override the contents of this collection use [`set_protocols`](Self::set_protocols).
    ///
    /// <p>The protocols you want to use for the endpoint. DoH-FIPS is applicable for inbound endpoints only.</p>
    /// <p>For an inbound endpoint you can apply the protocols as follows:</p>
    /// <ul>
    /// <li>
    /// <p>Do53 and DoH in combination.</p></li>
    /// <li>
    /// <p>Do53 and DoH-FIPS in combination.</p></li>
    /// <li>
    /// <p>Do53 alone.</p></li>
    /// <li>
    /// <p>DoH alone.</p></li>
    /// <li>
    /// <p>DoH-FIPS alone.</p></li>
    /// <li>
    /// <p>None, which is treated as Do53.</p></li>
    /// </ul>
    /// <p>For an outbound endpoint you can apply the protocols as follows:</p>
    /// <ul>
    /// <li>
    /// <p>Do53 and DoH in combination.</p></li>
    /// <li>
    /// <p>Do53 alone.</p></li>
    /// <li>
    /// <p>DoH alone.</p></li>
    /// <li>
    /// <p>None, which is treated as Do53.</p></li>
    /// </ul><important>
    /// <p>You can't change the protocol of an inbound endpoint directly from only Do53 to only DoH, or DoH-FIPS. This is to prevent a sudden disruption to incoming traffic that relies on Do53. To change the protocol from Do53 to DoH, or DoH-FIPS, you must first enable both Do53 and DoH, or Do53 and DoH-FIPS, to make sure that all incoming traffic has transferred to using the DoH protocol, or DoH-FIPS, and then remove the Do53.</p>
    /// </important>
    pub fn protocols(mut self, input: crate::types::Protocol) -> Self {
        self.inner = self.inner.protocols(input);
        self
    }
    /// <p>The protocols you want to use for the endpoint. DoH-FIPS is applicable for inbound endpoints only.</p>
    /// <p>For an inbound endpoint you can apply the protocols as follows:</p>
    /// <ul>
    /// <li>
    /// <p>Do53 and DoH in combination.</p></li>
    /// <li>
    /// <p>Do53 and DoH-FIPS in combination.</p></li>
    /// <li>
    /// <p>Do53 alone.</p></li>
    /// <li>
    /// <p>DoH alone.</p></li>
    /// <li>
    /// <p>DoH-FIPS alone.</p></li>
    /// <li>
    /// <p>None, which is treated as Do53.</p></li>
    /// </ul>
    /// <p>For an outbound endpoint you can apply the protocols as follows:</p>
    /// <ul>
    /// <li>
    /// <p>Do53 and DoH in combination.</p></li>
    /// <li>
    /// <p>Do53 alone.</p></li>
    /// <li>
    /// <p>DoH alone.</p></li>
    /// <li>
    /// <p>None, which is treated as Do53.</p></li>
    /// </ul><important>
    /// <p>You can't change the protocol of an inbound endpoint directly from only Do53 to only DoH, or DoH-FIPS. This is to prevent a sudden disruption to incoming traffic that relies on Do53. To change the protocol from Do53 to DoH, or DoH-FIPS, you must first enable both Do53 and DoH, or Do53 and DoH-FIPS, to make sure that all incoming traffic has transferred to using the DoH protocol, or DoH-FIPS, and then remove the Do53.</p>
    /// </important>
    pub fn set_protocols(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Protocol>>) -> Self {
        self.inner = self.inner.set_protocols(input);
        self
    }
    /// <p>The protocols you want to use for the endpoint. DoH-FIPS is applicable for inbound endpoints only.</p>
    /// <p>For an inbound endpoint you can apply the protocols as follows:</p>
    /// <ul>
    /// <li>
    /// <p>Do53 and DoH in combination.</p></li>
    /// <li>
    /// <p>Do53 and DoH-FIPS in combination.</p></li>
    /// <li>
    /// <p>Do53 alone.</p></li>
    /// <li>
    /// <p>DoH alone.</p></li>
    /// <li>
    /// <p>DoH-FIPS alone.</p></li>
    /// <li>
    /// <p>None, which is treated as Do53.</p></li>
    /// </ul>
    /// <p>For an outbound endpoint you can apply the protocols as follows:</p>
    /// <ul>
    /// <li>
    /// <p>Do53 and DoH in combination.</p></li>
    /// <li>
    /// <p>Do53 alone.</p></li>
    /// <li>
    /// <p>DoH alone.</p></li>
    /// <li>
    /// <p>None, which is treated as Do53.</p></li>
    /// </ul><important>
    /// <p>You can't change the protocol of an inbound endpoint directly from only Do53 to only DoH, or DoH-FIPS. This is to prevent a sudden disruption to incoming traffic that relies on Do53. To change the protocol from Do53 to DoH, or DoH-FIPS, you must first enable both Do53 and DoH, or Do53 and DoH-FIPS, to make sure that all incoming traffic has transferred to using the DoH protocol, or DoH-FIPS, and then remove the Do53.</p>
    /// </important>
    pub fn get_protocols(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Protocol>> {
        self.inner.get_protocols()
    }
}
