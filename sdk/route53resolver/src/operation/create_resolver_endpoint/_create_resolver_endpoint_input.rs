// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateResolverEndpointInput {
    /// <p>A unique string that identifies the request and that allows failed requests to be retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any unique string, for example, a date/time stamp. </p>
    #[doc(hidden)]
    pub creator_request_id: std::option::Option<std::string::String>,
    /// <p>A friendly name that lets you easily find a configuration in the Resolver dashboard in the Route 53 console.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ID of one or more security groups that you want to use to control access to this VPC. The security group that you specify must include one or more inbound rules (for inbound Resolver endpoints) or outbound rules (for outbound Resolver endpoints). Inbound and outbound rules must allow TCP and UDP access. For inbound access, open port 53. For outbound access, open the port that you're using for DNS queries on your network.</p>
    #[doc(hidden)]
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specify the applicable value:</p>
    /// <ul>
    /// <li> <p> <code>INBOUND</code>: Resolver forwards DNS queries to the DNS service for a VPC from your network</p> </li>
    /// <li> <p> <code>OUTBOUND</code>: Resolver forwards DNS queries from the DNS service for a VPC to your network</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub direction: std::option::Option<crate::types::ResolverEndpointDirection>,
    /// <p>The subnets and IP addresses in your VPC that DNS queries originate from (for outbound endpoints) or that you forward DNS queries to (for inbound endpoints). The subnet ID uniquely identifies a VPC. </p>
    #[doc(hidden)]
    pub ip_addresses: std::option::Option<std::vec::Vec<crate::types::IpAddressRequest>>,
    /// <p>A list of the tag keys and values that you want to associate with the endpoint.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::types::Tag>>,
}
impl CreateResolverEndpointInput {
    /// <p>A unique string that identifies the request and that allows failed requests to be retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any unique string, for example, a date/time stamp. </p>
    pub fn creator_request_id(&self) -> std::option::Option<&str> {
        self.creator_request_id.as_deref()
    }
    /// <p>A friendly name that lets you easily find a configuration in the Resolver dashboard in the Route 53 console.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ID of one or more security groups that you want to use to control access to this VPC. The security group that you specify must include one or more inbound rules (for inbound Resolver endpoints) or outbound rules (for outbound Resolver endpoints). Inbound and outbound rules must allow TCP and UDP access. For inbound access, open port 53. For outbound access, open the port that you're using for DNS queries on your network.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
    /// <p>Specify the applicable value:</p>
    /// <ul>
    /// <li> <p> <code>INBOUND</code>: Resolver forwards DNS queries to the DNS service for a VPC from your network</p> </li>
    /// <li> <p> <code>OUTBOUND</code>: Resolver forwards DNS queries from the DNS service for a VPC to your network</p> </li>
    /// </ul>
    pub fn direction(&self) -> std::option::Option<&crate::types::ResolverEndpointDirection> {
        self.direction.as_ref()
    }
    /// <p>The subnets and IP addresses in your VPC that DNS queries originate from (for outbound endpoints) or that you forward DNS queries to (for inbound endpoints). The subnet ID uniquely identifies a VPC. </p>
    pub fn ip_addresses(&self) -> std::option::Option<&[crate::types::IpAddressRequest]> {
        self.ip_addresses.as_deref()
    }
    /// <p>A list of the tag keys and values that you want to associate with the endpoint.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::types::Tag]> {
        self.tags.as_deref()
    }
}
impl CreateResolverEndpointInput {
    /// Creates a new builder-style object to manufacture [`CreateResolverEndpointInput`](crate::operation::create_resolver_endpoint::CreateResolverEndpointInput).
    pub fn builder(
    ) -> crate::operation::create_resolver_endpoint::builders::CreateResolverEndpointInputBuilder
    {
        crate::operation::create_resolver_endpoint::builders::CreateResolverEndpointInputBuilder::default()
    }
}

/// A builder for [`CreateResolverEndpointInput`](crate::operation::create_resolver_endpoint::CreateResolverEndpointInput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct CreateResolverEndpointInputBuilder {
    pub(crate) creator_request_id: std::option::Option<std::string::String>,
    pub(crate) name: std::option::Option<std::string::String>,
    pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) direction: std::option::Option<crate::types::ResolverEndpointDirection>,
    pub(crate) ip_addresses: std::option::Option<std::vec::Vec<crate::types::IpAddressRequest>>,
    pub(crate) tags: std::option::Option<std::vec::Vec<crate::types::Tag>>,
}
impl CreateResolverEndpointInputBuilder {
    /// <p>A unique string that identifies the request and that allows failed requests to be retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any unique string, for example, a date/time stamp. </p>
    pub fn creator_request_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.creator_request_id = Some(input.into());
        self
    }
    /// <p>A unique string that identifies the request and that allows failed requests to be retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any unique string, for example, a date/time stamp. </p>
    pub fn set_creator_request_id(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.creator_request_id = input;
        self
    }
    /// <p>A friendly name that lets you easily find a configuration in the Resolver dashboard in the Route 53 console.</p>
    pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
        self.name = Some(input.into());
        self
    }
    /// <p>A friendly name that lets you easily find a configuration in the Resolver dashboard in the Route 53 console.</p>
    pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// Appends an item to `security_group_ids`.
    ///
    /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
    ///
    /// <p>The ID of one or more security groups that you want to use to control access to this VPC. The security group that you specify must include one or more inbound rules (for inbound Resolver endpoints) or outbound rules (for outbound Resolver endpoints). Inbound and outbound rules must allow TCP and UDP access. For inbound access, open port 53. For outbound access, open the port that you're using for DNS queries on your network.</p>
    pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.security_group_ids.unwrap_or_default();
        v.push(input.into());
        self.security_group_ids = Some(v);
        self
    }
    /// <p>The ID of one or more security groups that you want to use to control access to this VPC. The security group that you specify must include one or more inbound rules (for inbound Resolver endpoints) or outbound rules (for outbound Resolver endpoints). Inbound and outbound rules must allow TCP and UDP access. For inbound access, open port 53. For outbound access, open the port that you're using for DNS queries on your network.</p>
    pub fn set_security_group_ids(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.security_group_ids = input;
        self
    }
    /// <p>Specify the applicable value:</p>
    /// <ul>
    /// <li> <p> <code>INBOUND</code>: Resolver forwards DNS queries to the DNS service for a VPC from your network</p> </li>
    /// <li> <p> <code>OUTBOUND</code>: Resolver forwards DNS queries from the DNS service for a VPC to your network</p> </li>
    /// </ul>
    pub fn direction(mut self, input: crate::types::ResolverEndpointDirection) -> Self {
        self.direction = Some(input);
        self
    }
    /// <p>Specify the applicable value:</p>
    /// <ul>
    /// <li> <p> <code>INBOUND</code>: Resolver forwards DNS queries to the DNS service for a VPC from your network</p> </li>
    /// <li> <p> <code>OUTBOUND</code>: Resolver forwards DNS queries from the DNS service for a VPC to your network</p> </li>
    /// </ul>
    pub fn set_direction(
        mut self,
        input: std::option::Option<crate::types::ResolverEndpointDirection>,
    ) -> Self {
        self.direction = input;
        self
    }
    /// Appends an item to `ip_addresses`.
    ///
    /// To override the contents of this collection use [`set_ip_addresses`](Self::set_ip_addresses).
    ///
    /// <p>The subnets and IP addresses in your VPC that DNS queries originate from (for outbound endpoints) or that you forward DNS queries to (for inbound endpoints). The subnet ID uniquely identifies a VPC. </p>
    pub fn ip_addresses(mut self, input: crate::types::IpAddressRequest) -> Self {
        let mut v = self.ip_addresses.unwrap_or_default();
        v.push(input);
        self.ip_addresses = Some(v);
        self
    }
    /// <p>The subnets and IP addresses in your VPC that DNS queries originate from (for outbound endpoints) or that you forward DNS queries to (for inbound endpoints). The subnet ID uniquely identifies a VPC. </p>
    pub fn set_ip_addresses(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::IpAddressRequest>>,
    ) -> Self {
        self.ip_addresses = input;
        self
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>A list of the tag keys and values that you want to associate with the endpoint.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tags.unwrap_or_default();
        v.push(input);
        self.tags = Some(v);
        self
    }
    /// <p>A list of the tag keys and values that you want to associate with the endpoint.</p>
    pub fn set_tags(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::Tag>>,
    ) -> Self {
        self.tags = input;
        self
    }
    /// Consumes the builder and constructs a [`CreateResolverEndpointInput`](crate::operation::create_resolver_endpoint::CreateResolverEndpointInput).
    pub fn build(
        self,
    ) -> Result<
        crate::operation::create_resolver_endpoint::CreateResolverEndpointInput,
        aws_smithy_http::operation::error::BuildError,
    > {
        Ok(
            crate::operation::create_resolver_endpoint::CreateResolverEndpointInput {
                creator_request_id: self.creator_request_id,
                name: self.name,
                security_group_ids: self.security_group_ids,
                direction: self.direction,
                ip_addresses: self.ip_addresses,
                tags: self.tags,
            },
        )
    }
}
