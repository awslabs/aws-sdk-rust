// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn associate_firewall_rule_group(&self) -> fluent_builders::AssociateFirewallRuleGroup<C> {
        fluent_builders::AssociateFirewallRuleGroup::new(self.handle.clone())
    }
    pub fn associate_resolver_endpoint_ip_address(
        &self,
    ) -> fluent_builders::AssociateResolverEndpointIpAddress<C> {
        fluent_builders::AssociateResolverEndpointIpAddress::new(self.handle.clone())
    }
    pub fn associate_resolver_query_log_config(
        &self,
    ) -> fluent_builders::AssociateResolverQueryLogConfig<C> {
        fluent_builders::AssociateResolverQueryLogConfig::new(self.handle.clone())
    }
    pub fn associate_resolver_rule(&self) -> fluent_builders::AssociateResolverRule<C> {
        fluent_builders::AssociateResolverRule::new(self.handle.clone())
    }
    pub fn create_firewall_domain_list(&self) -> fluent_builders::CreateFirewallDomainList<C> {
        fluent_builders::CreateFirewallDomainList::new(self.handle.clone())
    }
    pub fn create_firewall_rule(&self) -> fluent_builders::CreateFirewallRule<C> {
        fluent_builders::CreateFirewallRule::new(self.handle.clone())
    }
    pub fn create_firewall_rule_group(&self) -> fluent_builders::CreateFirewallRuleGroup<C> {
        fluent_builders::CreateFirewallRuleGroup::new(self.handle.clone())
    }
    pub fn create_resolver_endpoint(&self) -> fluent_builders::CreateResolverEndpoint<C> {
        fluent_builders::CreateResolverEndpoint::new(self.handle.clone())
    }
    pub fn create_resolver_query_log_config(
        &self,
    ) -> fluent_builders::CreateResolverQueryLogConfig<C> {
        fluent_builders::CreateResolverQueryLogConfig::new(self.handle.clone())
    }
    pub fn create_resolver_rule(&self) -> fluent_builders::CreateResolverRule<C> {
        fluent_builders::CreateResolverRule::new(self.handle.clone())
    }
    pub fn delete_firewall_domain_list(&self) -> fluent_builders::DeleteFirewallDomainList<C> {
        fluent_builders::DeleteFirewallDomainList::new(self.handle.clone())
    }
    pub fn delete_firewall_rule(&self) -> fluent_builders::DeleteFirewallRule<C> {
        fluent_builders::DeleteFirewallRule::new(self.handle.clone())
    }
    pub fn delete_firewall_rule_group(&self) -> fluent_builders::DeleteFirewallRuleGroup<C> {
        fluent_builders::DeleteFirewallRuleGroup::new(self.handle.clone())
    }
    pub fn delete_resolver_endpoint(&self) -> fluent_builders::DeleteResolverEndpoint<C> {
        fluent_builders::DeleteResolverEndpoint::new(self.handle.clone())
    }
    pub fn delete_resolver_query_log_config(
        &self,
    ) -> fluent_builders::DeleteResolverQueryLogConfig<C> {
        fluent_builders::DeleteResolverQueryLogConfig::new(self.handle.clone())
    }
    pub fn delete_resolver_rule(&self) -> fluent_builders::DeleteResolverRule<C> {
        fluent_builders::DeleteResolverRule::new(self.handle.clone())
    }
    pub fn disassociate_firewall_rule_group(
        &self,
    ) -> fluent_builders::DisassociateFirewallRuleGroup<C> {
        fluent_builders::DisassociateFirewallRuleGroup::new(self.handle.clone())
    }
    pub fn disassociate_resolver_endpoint_ip_address(
        &self,
    ) -> fluent_builders::DisassociateResolverEndpointIpAddress<C> {
        fluent_builders::DisassociateResolverEndpointIpAddress::new(self.handle.clone())
    }
    pub fn disassociate_resolver_query_log_config(
        &self,
    ) -> fluent_builders::DisassociateResolverQueryLogConfig<C> {
        fluent_builders::DisassociateResolverQueryLogConfig::new(self.handle.clone())
    }
    pub fn disassociate_resolver_rule(&self) -> fluent_builders::DisassociateResolverRule<C> {
        fluent_builders::DisassociateResolverRule::new(self.handle.clone())
    }
    pub fn get_firewall_config(&self) -> fluent_builders::GetFirewallConfig<C> {
        fluent_builders::GetFirewallConfig::new(self.handle.clone())
    }
    pub fn get_firewall_domain_list(&self) -> fluent_builders::GetFirewallDomainList<C> {
        fluent_builders::GetFirewallDomainList::new(self.handle.clone())
    }
    pub fn get_firewall_rule_group(&self) -> fluent_builders::GetFirewallRuleGroup<C> {
        fluent_builders::GetFirewallRuleGroup::new(self.handle.clone())
    }
    pub fn get_firewall_rule_group_association(
        &self,
    ) -> fluent_builders::GetFirewallRuleGroupAssociation<C> {
        fluent_builders::GetFirewallRuleGroupAssociation::new(self.handle.clone())
    }
    pub fn get_firewall_rule_group_policy(&self) -> fluent_builders::GetFirewallRuleGroupPolicy<C> {
        fluent_builders::GetFirewallRuleGroupPolicy::new(self.handle.clone())
    }
    pub fn get_resolver_dnssec_config(&self) -> fluent_builders::GetResolverDnssecConfig<C> {
        fluent_builders::GetResolverDnssecConfig::new(self.handle.clone())
    }
    pub fn get_resolver_endpoint(&self) -> fluent_builders::GetResolverEndpoint<C> {
        fluent_builders::GetResolverEndpoint::new(self.handle.clone())
    }
    pub fn get_resolver_query_log_config(&self) -> fluent_builders::GetResolverQueryLogConfig<C> {
        fluent_builders::GetResolverQueryLogConfig::new(self.handle.clone())
    }
    pub fn get_resolver_query_log_config_association(
        &self,
    ) -> fluent_builders::GetResolverQueryLogConfigAssociation<C> {
        fluent_builders::GetResolverQueryLogConfigAssociation::new(self.handle.clone())
    }
    pub fn get_resolver_query_log_config_policy(
        &self,
    ) -> fluent_builders::GetResolverQueryLogConfigPolicy<C> {
        fluent_builders::GetResolverQueryLogConfigPolicy::new(self.handle.clone())
    }
    pub fn get_resolver_rule(&self) -> fluent_builders::GetResolverRule<C> {
        fluent_builders::GetResolverRule::new(self.handle.clone())
    }
    pub fn get_resolver_rule_association(&self) -> fluent_builders::GetResolverRuleAssociation<C> {
        fluent_builders::GetResolverRuleAssociation::new(self.handle.clone())
    }
    pub fn get_resolver_rule_policy(&self) -> fluent_builders::GetResolverRulePolicy<C> {
        fluent_builders::GetResolverRulePolicy::new(self.handle.clone())
    }
    pub fn import_firewall_domains(&self) -> fluent_builders::ImportFirewallDomains<C> {
        fluent_builders::ImportFirewallDomains::new(self.handle.clone())
    }
    pub fn list_firewall_configs(&self) -> fluent_builders::ListFirewallConfigs<C> {
        fluent_builders::ListFirewallConfigs::new(self.handle.clone())
    }
    pub fn list_firewall_domain_lists(&self) -> fluent_builders::ListFirewallDomainLists<C> {
        fluent_builders::ListFirewallDomainLists::new(self.handle.clone())
    }
    pub fn list_firewall_domains(&self) -> fluent_builders::ListFirewallDomains<C> {
        fluent_builders::ListFirewallDomains::new(self.handle.clone())
    }
    pub fn list_firewall_rule_group_associations(
        &self,
    ) -> fluent_builders::ListFirewallRuleGroupAssociations<C> {
        fluent_builders::ListFirewallRuleGroupAssociations::new(self.handle.clone())
    }
    pub fn list_firewall_rule_groups(&self) -> fluent_builders::ListFirewallRuleGroups<C> {
        fluent_builders::ListFirewallRuleGroups::new(self.handle.clone())
    }
    pub fn list_firewall_rules(&self) -> fluent_builders::ListFirewallRules<C> {
        fluent_builders::ListFirewallRules::new(self.handle.clone())
    }
    pub fn list_resolver_dnssec_configs(&self) -> fluent_builders::ListResolverDnssecConfigs<C> {
        fluent_builders::ListResolverDnssecConfigs::new(self.handle.clone())
    }
    pub fn list_resolver_endpoint_ip_addresses(
        &self,
    ) -> fluent_builders::ListResolverEndpointIpAddresses<C> {
        fluent_builders::ListResolverEndpointIpAddresses::new(self.handle.clone())
    }
    pub fn list_resolver_endpoints(&self) -> fluent_builders::ListResolverEndpoints<C> {
        fluent_builders::ListResolverEndpoints::new(self.handle.clone())
    }
    pub fn list_resolver_query_log_config_associations(
        &self,
    ) -> fluent_builders::ListResolverQueryLogConfigAssociations<C> {
        fluent_builders::ListResolverQueryLogConfigAssociations::new(self.handle.clone())
    }
    pub fn list_resolver_query_log_configs(
        &self,
    ) -> fluent_builders::ListResolverQueryLogConfigs<C> {
        fluent_builders::ListResolverQueryLogConfigs::new(self.handle.clone())
    }
    pub fn list_resolver_rule_associations(
        &self,
    ) -> fluent_builders::ListResolverRuleAssociations<C> {
        fluent_builders::ListResolverRuleAssociations::new(self.handle.clone())
    }
    pub fn list_resolver_rules(&self) -> fluent_builders::ListResolverRules<C> {
        fluent_builders::ListResolverRules::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn put_firewall_rule_group_policy(&self) -> fluent_builders::PutFirewallRuleGroupPolicy<C> {
        fluent_builders::PutFirewallRuleGroupPolicy::new(self.handle.clone())
    }
    pub fn put_resolver_query_log_config_policy(
        &self,
    ) -> fluent_builders::PutResolverQueryLogConfigPolicy<C> {
        fluent_builders::PutResolverQueryLogConfigPolicy::new(self.handle.clone())
    }
    pub fn put_resolver_rule_policy(&self) -> fluent_builders::PutResolverRulePolicy<C> {
        fluent_builders::PutResolverRulePolicy::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_firewall_config(&self) -> fluent_builders::UpdateFirewallConfig<C> {
        fluent_builders::UpdateFirewallConfig::new(self.handle.clone())
    }
    pub fn update_firewall_domains(&self) -> fluent_builders::UpdateFirewallDomains<C> {
        fluent_builders::UpdateFirewallDomains::new(self.handle.clone())
    }
    pub fn update_firewall_rule(&self) -> fluent_builders::UpdateFirewallRule<C> {
        fluent_builders::UpdateFirewallRule::new(self.handle.clone())
    }
    pub fn update_firewall_rule_group_association(
        &self,
    ) -> fluent_builders::UpdateFirewallRuleGroupAssociation<C> {
        fluent_builders::UpdateFirewallRuleGroupAssociation::new(self.handle.clone())
    }
    pub fn update_resolver_dnssec_config(&self) -> fluent_builders::UpdateResolverDnssecConfig<C> {
        fluent_builders::UpdateResolverDnssecConfig::new(self.handle.clone())
    }
    pub fn update_resolver_endpoint(&self) -> fluent_builders::UpdateResolverEndpoint<C> {
        fluent_builders::UpdateResolverEndpoint::new(self.handle.clone())
    }
    pub fn update_resolver_rule(&self) -> fluent_builders::UpdateResolverRule<C> {
        fluent_builders::UpdateResolverRule::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AssociateFirewallRuleGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_firewall_rule_group_input::Builder,
    }
    impl<C> AssociateFirewallRuleGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateFirewallRuleGroupOutput,
            smithy_http::result::SdkError<crate::error::AssociateFirewallRuleGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique string that identifies the request and that allows failed requests to be
        /// retried without the risk of running the operation twice. <code>CreatorRequestId</code>
        /// can be any unique string, for example, a date/time stamp. </p>
        pub fn creator_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.creator_request_id(input);
            self
        }
        pub fn set_creator_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_creator_request_id(input);
            self
        }
        /// <p>The unique identifier of the firewall rule group. </p>
        pub fn firewall_rule_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_rule_group_id(input);
            self
        }
        pub fn set_firewall_rule_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_rule_group_id(input);
            self
        }
        /// <p>The unique identifier of the VPC that you want to associate with the rule group. </p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>The setting that determines the processing order of the rule group among the rule
        /// groups that you associate with the specified VPC. DNS Firewall filters VPC traffic
        /// starting from the rule group with the lowest numeric priority setting. </p>
        /// <p>You must specify a unique priority for each rule group that you associate with a single VPC.
        /// To make it easier to insert rule groups later, leave space between the numbers, for example, use 101, 200, and so on. You
        /// can change the priority setting for a rule group association after you create it.</p>
        /// <p>The allowed values for <code>Priority</code> are between 100 and 9900.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.inner = self.inner.priority(input);
            self
        }
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_priority(input);
            self
        }
        /// <p>A name that lets you identify the association, to manage and use it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>If enabled, this setting disallows modification or removal of the association, to help prevent against accidentally altering DNS firewall protections.
        /// When you create the association, the default setting is <code>DISABLED</code>. </p>
        pub fn mutation_protection(
            mut self,
            input: crate::model::MutationProtectionStatus,
        ) -> Self {
            self.inner = self.inner.mutation_protection(input);
            self
        }
        pub fn set_mutation_protection(
            mut self,
            input: std::option::Option<crate::model::MutationProtectionStatus>,
        ) -> Self {
            self.inner = self.inner.set_mutation_protection(input);
            self
        }
        /// <p>A list of the tag keys and values that you want to associate with the rule group association. </p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AssociateResolverEndpointIpAddress<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_resolver_endpoint_ip_address_input::Builder,
    }
    impl<C> AssociateResolverEndpointIpAddress<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateResolverEndpointIpAddressOutput,
            smithy_http::result::SdkError<crate::error::AssociateResolverEndpointIpAddressError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Resolver endpoint that you want to associate IP addresses with.</p>
        pub fn resolver_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resolver_endpoint_id(input);
            self
        }
        pub fn set_resolver_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resolver_endpoint_id(input);
            self
        }
        /// <p>Either the IPv4 address that you want to add to a Resolver endpoint or a subnet ID. If you specify a subnet ID,
        /// Resolver chooses an IP address for you from the available IPs in the specified subnet.</p>
        pub fn ip_address(mut self, input: crate::model::IpAddressUpdate) -> Self {
            self.inner = self.inner.ip_address(input);
            self
        }
        pub fn set_ip_address(
            mut self,
            input: std::option::Option<crate::model::IpAddressUpdate>,
        ) -> Self {
            self.inner = self.inner.set_ip_address(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AssociateResolverQueryLogConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_resolver_query_log_config_input::Builder,
    }
    impl<C> AssociateResolverQueryLogConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateResolverQueryLogConfigOutput,
            smithy_http::result::SdkError<crate::error::AssociateResolverQueryLogConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the query logging configuration that you want to associate a VPC with.</p>
        pub fn resolver_query_log_config_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.resolver_query_log_config_id(input);
            self
        }
        pub fn set_resolver_query_log_config_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resolver_query_log_config_id(input);
            self
        }
        /// <p>The ID of an Amazon VPC that you want this query logging configuration to log queries for.</p>
        /// <note>
        /// <p>The VPCs and the query logging configuration must be in the same Region.</p>
        /// </note>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(input);
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AssociateResolverRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_resolver_rule_input::Builder,
    }
    impl<C> AssociateResolverRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateResolverRuleOutput,
            smithy_http::result::SdkError<crate::error::AssociateResolverRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Resolver rule that you want to associate with the VPC. To list the existing Resolver rules, use
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html">ListResolverRules</a>.</p>
        pub fn resolver_rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resolver_rule_id(input);
            self
        }
        pub fn set_resolver_rule_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resolver_rule_id(input);
            self
        }
        /// <p>A name for the association that you're creating between a Resolver rule and a VPC.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The ID of the VPC that you want to associate the Resolver rule with.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateFirewallDomainList<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_firewall_domain_list_input::Builder,
    }
    impl<C> CreateFirewallDomainList<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateFirewallDomainListOutput,
            smithy_http::result::SdkError<crate::error::CreateFirewallDomainListError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique string that identifies the request and that allows you to retry failed requests
        /// without the risk of running the operation twice. <code>CreatorRequestId</code> can be
        /// any unique string, for example, a date/time stamp. </p>
        pub fn creator_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.creator_request_id(input);
            self
        }
        pub fn set_creator_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_creator_request_id(input);
            self
        }
        /// <p>A name that lets you identify the domain list to manage and use it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A list of the tag keys and values that you want to associate with the domain list. </p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateFirewallRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_firewall_rule_input::Builder,
    }
    impl<C> CreateFirewallRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateFirewallRuleOutput,
            smithy_http::result::SdkError<crate::error::CreateFirewallRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique string that identifies the request and that allows you to retry failed requests
        /// without the risk of running the operation twice. <code>CreatorRequestId</code> can be
        /// any unique string, for example, a date/time stamp. </p>
        pub fn creator_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.creator_request_id(input);
            self
        }
        pub fn set_creator_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_creator_request_id(input);
            self
        }
        /// <p>The unique identifier of the firewall rule group where you want to create the rule. </p>
        pub fn firewall_rule_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_rule_group_id(input);
            self
        }
        pub fn set_firewall_rule_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_rule_group_id(input);
            self
        }
        /// <p>The ID of the domain list that you want to use in the rule. </p>
        pub fn firewall_domain_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_domain_list_id(input);
            self
        }
        pub fn set_firewall_domain_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_domain_list_id(input);
            self
        }
        /// <p>The setting that determines the processing order of the rule in the rule group. DNS Firewall
        /// processes the rules in a rule group by order of priority, starting from the lowest setting.</p>
        /// <p>You must specify a unique priority for each rule in a rule group.
        /// To make it easier to insert rules later, leave space between the numbers, for example, use 100, 200, and so on. You
        /// can change the priority setting for the rules in a rule group at any time.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.inner = self.inner.priority(input);
            self
        }
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_priority(input);
            self
        }
        /// <p>The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ALLOW</code> - Permit the request to go through.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ALERT</code> - Permit the request and send metrics and logs to Cloud Watch.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>BLOCK</code> - Disallow the request. This option requires additional details in the rule's <code>BlockResponse</code>. </p>
        /// </li>
        /// </ul>
        pub fn action(mut self, input: crate::model::Action) -> Self {
            self.inner = self.inner.action(input);
            self
        }
        pub fn set_action(mut self, input: std::option::Option<crate::model::Action>) -> Self {
            self.inner = self.inner.set_action(input);
            self
        }
        /// <p>The way that you want DNS Firewall to block the request, used with the rule action
        /// setting <code>BLOCK</code>. </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>NODATA</code> - Respond indicating that the query was successful, but no response is available for it.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NXDOMAIN</code> - Respond indicating that the domain name that's in the query doesn't exist.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OVERRIDE</code> - Provide a custom override in the response. This option requires custom handling details in the rule's <code>BlockOverride*</code> settings. </p>
        /// </li>
        /// </ul>
        /// <p>This setting is required if the rule action setting is <code>BLOCK</code>.</p>
        pub fn block_response(mut self, input: crate::model::BlockResponse) -> Self {
            self.inner = self.inner.block_response(input);
            self
        }
        pub fn set_block_response(
            mut self,
            input: std::option::Option<crate::model::BlockResponse>,
        ) -> Self {
            self.inner = self.inner.set_block_response(input);
            self
        }
        /// <p>The custom DNS record to send back in response to the query. Used for the rule action <code>BLOCK</code> with a <code>BlockResponse</code> setting of <code>OVERRIDE</code>.</p>
        /// <p>This setting is required if the <code>BlockResponse</code> setting is <code>OVERRIDE</code>.</p>
        pub fn block_override_domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.block_override_domain(input);
            self
        }
        pub fn set_block_override_domain(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_block_override_domain(input);
            self
        }
        /// <p>The DNS record's type. This determines the format of the record value that you provided in <code>BlockOverrideDomain</code>. Used for the rule action <code>BLOCK</code> with a <code>BlockResponse</code> setting of <code>OVERRIDE</code>.</p>
        /// <p>This setting is required if the <code>BlockResponse</code> setting is <code>OVERRIDE</code>.</p>
        pub fn block_override_dns_type(
            mut self,
            input: crate::model::BlockOverrideDnsType,
        ) -> Self {
            self.inner = self.inner.block_override_dns_type(input);
            self
        }
        pub fn set_block_override_dns_type(
            mut self,
            input: std::option::Option<crate::model::BlockOverrideDnsType>,
        ) -> Self {
            self.inner = self.inner.set_block_override_dns_type(input);
            self
        }
        /// <p>The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action <code>BLOCK</code> with a <code>BlockResponse</code> setting of <code>OVERRIDE</code>.</p>
        /// <p>This setting is required if the <code>BlockResponse</code> setting is <code>OVERRIDE</code>.</p>
        pub fn block_override_ttl(mut self, input: i32) -> Self {
            self.inner = self.inner.block_override_ttl(input);
            self
        }
        pub fn set_block_override_ttl(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_block_override_ttl(input);
            self
        }
        /// <p>A name that lets you identify the rule in the rule group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateFirewallRuleGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_firewall_rule_group_input::Builder,
    }
    impl<C> CreateFirewallRuleGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateFirewallRuleGroupOutput,
            smithy_http::result::SdkError<crate::error::CreateFirewallRuleGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique string defined by you to identify the request. This allows you to retry failed
        /// requests without the risk of running the operation twice. This can be any unique string,
        /// for example, a timestamp. </p>
        pub fn creator_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.creator_request_id(input);
            self
        }
        pub fn set_creator_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_creator_request_id(input);
            self
        }
        /// <p>A name that lets you identify the rule group, to manage and use it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A list of the tag keys and values that you want to associate with the rule group. </p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateResolverEndpoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_resolver_endpoint_input::Builder,
    }
    impl<C> CreateResolverEndpoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateResolverEndpointOutput,
            smithy_http::result::SdkError<crate::error::CreateResolverEndpointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique string that identifies the request and that allows failed requests to be retried
        /// without the risk of running the operation twice. <code>CreatorRequestId</code> can be
        /// any unique string, for example, a date/time stamp. </p>
        pub fn creator_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.creator_request_id(input);
            self
        }
        pub fn set_creator_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_creator_request_id(input);
            self
        }
        /// <p>A friendly name that lets you easily find a configuration in the Resolver dashboard in the Route 53 console.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The ID of one or more security groups that you want to use to control access to this VPC. The security group that you specify
        /// must include one or more inbound rules (for inbound Resolver endpoints) or outbound rules (for outbound Resolver endpoints).
        /// Inbound and outbound rules must allow TCP and UDP access. For inbound access, open port 53. For outbound access, open the port
        /// that you're using for DNS queries on your network.</p>
        pub fn security_group_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_group_ids(inp);
            self
        }
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_security_group_ids(input);
            self
        }
        /// <p>Specify the applicable value:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>INBOUND</code>: Resolver forwards DNS queries to the DNS service for a VPC from your network</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OUTBOUND</code>: Resolver forwards DNS queries from the DNS service for a VPC to your network</p>
        /// </li>
        /// </ul>
        pub fn direction(mut self, input: crate::model::ResolverEndpointDirection) -> Self {
            self.inner = self.inner.direction(input);
            self
        }
        pub fn set_direction(
            mut self,
            input: std::option::Option<crate::model::ResolverEndpointDirection>,
        ) -> Self {
            self.inner = self.inner.set_direction(input);
            self
        }
        /// <p>The subnets and IP addresses in your VPC that DNS queries originate from (for outbound endpoints) or that you forward
        /// DNS queries to (for inbound endpoints). The subnet ID uniquely identifies a VPC. </p>
        pub fn ip_addresses(mut self, inp: impl Into<crate::model::IpAddressRequest>) -> Self {
            self.inner = self.inner.ip_addresses(inp);
            self
        }
        pub fn set_ip_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IpAddressRequest>>,
        ) -> Self {
            self.inner = self.inner.set_ip_addresses(input);
            self
        }
        /// <p>A list of the tag keys and values that you want to associate with the endpoint.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateResolverQueryLogConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_resolver_query_log_config_input::Builder,
    }
    impl<C> CreateResolverQueryLogConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateResolverQueryLogConfigOutput,
            smithy_http::result::SdkError<crate::error::CreateResolverQueryLogConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name that you want to give the query logging configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The ARN of the resource that you want Resolver to send query logs. You can send query logs to an S3 bucket, a CloudWatch Logs log group,
        /// or a Kinesis Data Firehose delivery stream. Examples of valid values include the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>S3 bucket</b>: </p>
        /// <p>
        /// <code>arn:aws:s3:::examplebucket</code>
        /// </p>
        /// <p>You can optionally append a file prefix to the end of the ARN.</p>
        /// <p>
        /// <code>arn:aws:s3:::examplebucket/development/</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>CloudWatch Logs log group</b>: </p>
        /// <p>
        /// <code>arn:aws:logs:us-west-1:123456789012:log-group:/mystack-testgroup-12ABC1AB12A1:*</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Kinesis Data Firehose delivery stream</b>:</p>
        /// <p>
        /// <code>arn:aws:kinesis:us-east-2:0123456789:stream/my_stream_name</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn destination_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_arn(input);
            self
        }
        pub fn set_destination_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_arn(input);
            self
        }
        /// <p>A unique string that identifies the request and that allows failed requests to be retried
        /// without the risk of running the operation twice. <code>CreatorRequestId</code> can be
        /// any unique string, for example, a date/time stamp. </p>
        pub fn creator_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.creator_request_id(input);
            self
        }
        pub fn set_creator_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_creator_request_id(input);
            self
        }
        /// <p>A list of the tag keys and values that you want to associate with the query logging configuration.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateResolverRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_resolver_rule_input::Builder,
    }
    impl<C> CreateResolverRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateResolverRuleOutput,
            smithy_http::result::SdkError<crate::error::CreateResolverRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique string that identifies the request and that allows failed requests to be retried
        /// without the risk of running the operation twice. <code>CreatorRequestId</code> can be
        /// any unique string, for example, a date/time stamp. </p>
        pub fn creator_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.creator_request_id(input);
            self
        }
        pub fn set_creator_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_creator_request_id(input);
            self
        }
        /// <p>A friendly name that lets you easily find a rule in the Resolver dashboard in the Route 53 console.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>When you want to forward DNS queries for specified domain name to resolvers on your network, specify <code>FORWARD</code>.</p>
        /// <p>When you have a forwarding rule to forward DNS queries for a domain to your network and you want Resolver to process queries for
        /// a subdomain of that domain, specify <code>SYSTEM</code>.</p>
        /// <p>For example, to forward DNS queries for example.com to resolvers on your network, you create a rule and specify <code>FORWARD</code>
        /// for <code>RuleType</code>. To then have Resolver process queries for apex.example.com, you create a rule and specify
        /// <code>SYSTEM</code> for <code>RuleType</code>.</p>
        /// <p>Currently, only Resolver can create rules that have a value of <code>RECURSIVE</code> for <code>RuleType</code>.</p>
        pub fn rule_type(mut self, input: crate::model::RuleTypeOption) -> Self {
            self.inner = self.inner.rule_type(input);
            self
        }
        pub fn set_rule_type(
            mut self,
            input: std::option::Option<crate::model::RuleTypeOption>,
        ) -> Self {
            self.inner = self.inner.set_rule_type(input);
            self
        }
        /// <p>DNS queries for this domain name are forwarded to the IP addresses that you specify in <code>TargetIps</code>. If a query matches
        /// multiple Resolver rules (example.com and www.example.com), outbound DNS queries are routed using the Resolver rule that contains
        /// the most specific domain name (www.example.com).</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>The IPs that you want Resolver to forward DNS queries to. You can specify only IPv4 addresses. Separate IP addresses with a space.</p>
        /// <p>
        /// <code>TargetIps</code> is available only when the value of <code>Rule type</code> is <code>FORWARD</code>.</p>
        pub fn target_ips(mut self, inp: impl Into<crate::model::TargetAddress>) -> Self {
            self.inner = self.inner.target_ips(inp);
            self
        }
        pub fn set_target_ips(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TargetAddress>>,
        ) -> Self {
            self.inner = self.inner.set_target_ips(input);
            self
        }
        /// <p>The ID of the outbound Resolver endpoint that you want to use to route DNS queries to the IP addresses that you specify
        /// in <code>TargetIps</code>.</p>
        pub fn resolver_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resolver_endpoint_id(input);
            self
        }
        pub fn set_resolver_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resolver_endpoint_id(input);
            self
        }
        /// <p>A list of the tag keys and values that you want to associate with the endpoint.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFirewallDomainList<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_firewall_domain_list_input::Builder,
    }
    impl<C> DeleteFirewallDomainList<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFirewallDomainListOutput,
            smithy_http::result::SdkError<crate::error::DeleteFirewallDomainListError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the domain list that you want to delete. </p>
        pub fn firewall_domain_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_domain_list_id(input);
            self
        }
        pub fn set_firewall_domain_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_domain_list_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFirewallRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_firewall_rule_input::Builder,
    }
    impl<C> DeleteFirewallRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFirewallRuleOutput,
            smithy_http::result::SdkError<crate::error::DeleteFirewallRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier of the firewall rule group that you want to delete the rule from. </p>
        pub fn firewall_rule_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_rule_group_id(input);
            self
        }
        pub fn set_firewall_rule_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_rule_group_id(input);
            self
        }
        /// <p>The ID of the domain list that's used in the rule.  </p>
        pub fn firewall_domain_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_domain_list_id(input);
            self
        }
        pub fn set_firewall_domain_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_domain_list_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFirewallRuleGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_firewall_rule_group_input::Builder,
    }
    impl<C> DeleteFirewallRuleGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFirewallRuleGroupOutput,
            smithy_http::result::SdkError<crate::error::DeleteFirewallRuleGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier of the firewall rule group that you want to delete. </p>
        pub fn firewall_rule_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_rule_group_id(input);
            self
        }
        pub fn set_firewall_rule_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_rule_group_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteResolverEndpoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_resolver_endpoint_input::Builder,
    }
    impl<C> DeleteResolverEndpoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteResolverEndpointOutput,
            smithy_http::result::SdkError<crate::error::DeleteResolverEndpointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Resolver endpoint that you want to delete.</p>
        pub fn resolver_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resolver_endpoint_id(input);
            self
        }
        pub fn set_resolver_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resolver_endpoint_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteResolverQueryLogConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_resolver_query_log_config_input::Builder,
    }
    impl<C> DeleteResolverQueryLogConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteResolverQueryLogConfigOutput,
            smithy_http::result::SdkError<crate::error::DeleteResolverQueryLogConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the query logging configuration that you want to delete.</p>
        pub fn resolver_query_log_config_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.resolver_query_log_config_id(input);
            self
        }
        pub fn set_resolver_query_log_config_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resolver_query_log_config_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteResolverRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_resolver_rule_input::Builder,
    }
    impl<C> DeleteResolverRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteResolverRuleOutput,
            smithy_http::result::SdkError<crate::error::DeleteResolverRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Resolver rule that you want to delete.</p>
        pub fn resolver_rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resolver_rule_id(input);
            self
        }
        pub fn set_resolver_rule_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resolver_rule_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateFirewallRuleGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disassociate_firewall_rule_group_input::Builder,
    }
    impl<C> DisassociateFirewallRuleGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateFirewallRuleGroupOutput,
            smithy_http::result::SdkError<crate::error::DisassociateFirewallRuleGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the <a>FirewallRuleGroupAssociation</a>. </p>
        pub fn firewall_rule_group_association_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.firewall_rule_group_association_id(input);
            self
        }
        pub fn set_firewall_rule_group_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_rule_group_association_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateResolverEndpointIpAddress<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disassociate_resolver_endpoint_ip_address_input::Builder,
    }
    impl<C> DisassociateResolverEndpointIpAddress<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateResolverEndpointIpAddressOutput,
            smithy_http::result::SdkError<crate::error::DisassociateResolverEndpointIpAddressError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Resolver endpoint that you want to disassociate an IP address from.</p>
        pub fn resolver_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resolver_endpoint_id(input);
            self
        }
        pub fn set_resolver_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resolver_endpoint_id(input);
            self
        }
        /// <p>The IPv4 address that you want to remove from a Resolver endpoint.</p>
        pub fn ip_address(mut self, input: crate::model::IpAddressUpdate) -> Self {
            self.inner = self.inner.ip_address(input);
            self
        }
        pub fn set_ip_address(
            mut self,
            input: std::option::Option<crate::model::IpAddressUpdate>,
        ) -> Self {
            self.inner = self.inner.set_ip_address(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateResolverQueryLogConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disassociate_resolver_query_log_config_input::Builder,
    }
    impl<C> DisassociateResolverQueryLogConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateResolverQueryLogConfigOutput,
            smithy_http::result::SdkError<crate::error::DisassociateResolverQueryLogConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the query logging configuration that you want to disassociate a specified VPC from.</p>
        pub fn resolver_query_log_config_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.resolver_query_log_config_id(input);
            self
        }
        pub fn set_resolver_query_log_config_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resolver_query_log_config_id(input);
            self
        }
        /// <p>The ID of the Amazon VPC that you want to disassociate from a specified query logging configuration.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(input);
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateResolverRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disassociate_resolver_rule_input::Builder,
    }
    impl<C> DisassociateResolverRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateResolverRuleOutput,
            smithy_http::result::SdkError<crate::error::DisassociateResolverRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the VPC that you want to disassociate the Resolver rule from.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>The ID of the Resolver rule that you want to disassociate from the specified VPC.</p>
        pub fn resolver_rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resolver_rule_id(input);
            self
        }
        pub fn set_resolver_rule_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resolver_rule_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFirewallConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_firewall_config_input::Builder,
    }
    impl<C> GetFirewallConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetFirewallConfigOutput,
            smithy_http::result::SdkError<crate::error::GetFirewallConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the VPC from Amazon VPC that the configuration is for.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(input);
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFirewallDomainList<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_firewall_domain_list_input::Builder,
    }
    impl<C> GetFirewallDomainList<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetFirewallDomainListOutput,
            smithy_http::result::SdkError<crate::error::GetFirewallDomainListError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the domain list.  </p>
        pub fn firewall_domain_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_domain_list_id(input);
            self
        }
        pub fn set_firewall_domain_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_domain_list_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFirewallRuleGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_firewall_rule_group_input::Builder,
    }
    impl<C> GetFirewallRuleGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetFirewallRuleGroupOutput,
            smithy_http::result::SdkError<crate::error::GetFirewallRuleGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier of the firewall rule group. </p>
        pub fn firewall_rule_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_rule_group_id(input);
            self
        }
        pub fn set_firewall_rule_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_rule_group_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFirewallRuleGroupAssociation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_firewall_rule_group_association_input::Builder,
    }
    impl<C> GetFirewallRuleGroupAssociation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetFirewallRuleGroupAssociationOutput,
            smithy_http::result::SdkError<crate::error::GetFirewallRuleGroupAssociationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the <a>FirewallRuleGroupAssociation</a>. </p>
        pub fn firewall_rule_group_association_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.firewall_rule_group_association_id(input);
            self
        }
        pub fn set_firewall_rule_group_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_rule_group_association_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFirewallRuleGroupPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_firewall_rule_group_policy_input::Builder,
    }
    impl<C> GetFirewallRuleGroupPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetFirewallRuleGroupPolicyOutput,
            smithy_http::result::SdkError<crate::error::GetFirewallRuleGroupPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN (Amazon Resource Name) for the rule group.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetResolverDnssecConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_resolver_dnssec_config_input::Builder,
    }
    impl<C> GetResolverDnssecConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetResolverDnssecConfigOutput,
            smithy_http::result::SdkError<crate::error::GetResolverDnssecConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the virtual private cloud (VPC) for the DNSSEC validation status.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(input);
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetResolverEndpoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_resolver_endpoint_input::Builder,
    }
    impl<C> GetResolverEndpoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetResolverEndpointOutput,
            smithy_http::result::SdkError<crate::error::GetResolverEndpointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Resolver endpoint that you want to get information about.</p>
        pub fn resolver_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resolver_endpoint_id(input);
            self
        }
        pub fn set_resolver_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resolver_endpoint_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetResolverQueryLogConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_resolver_query_log_config_input::Builder,
    }
    impl<C> GetResolverQueryLogConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetResolverQueryLogConfigOutput,
            smithy_http::result::SdkError<crate::error::GetResolverQueryLogConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Resolver query logging configuration that you want to get information about.</p>
        pub fn resolver_query_log_config_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.resolver_query_log_config_id(input);
            self
        }
        pub fn set_resolver_query_log_config_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resolver_query_log_config_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetResolverQueryLogConfigAssociation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_resolver_query_log_config_association_input::Builder,
    }
    impl<C> GetResolverQueryLogConfigAssociation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetResolverQueryLogConfigAssociationOutput,
            smithy_http::result::SdkError<crate::error::GetResolverQueryLogConfigAssociationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Resolver query logging configuration association that you want to get information about.</p>
        pub fn resolver_query_log_config_association_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.resolver_query_log_config_association_id(input);
            self
        }
        pub fn set_resolver_query_log_config_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self
                .inner
                .set_resolver_query_log_config_association_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetResolverQueryLogConfigPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_resolver_query_log_config_policy_input::Builder,
    }
    impl<C> GetResolverQueryLogConfigPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetResolverQueryLogConfigPolicyOutput,
            smithy_http::result::SdkError<crate::error::GetResolverQueryLogConfigPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the query logging configuration that you want to get the query logging policy for.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetResolverRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_resolver_rule_input::Builder,
    }
    impl<C> GetResolverRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetResolverRuleOutput,
            smithy_http::result::SdkError<crate::error::GetResolverRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Resolver rule that you want to get information about.</p>
        pub fn resolver_rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resolver_rule_id(input);
            self
        }
        pub fn set_resolver_rule_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resolver_rule_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetResolverRuleAssociation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_resolver_rule_association_input::Builder,
    }
    impl<C> GetResolverRuleAssociation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetResolverRuleAssociationOutput,
            smithy_http::result::SdkError<crate::error::GetResolverRuleAssociationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Resolver rule association that you want to get information about.</p>
        pub fn resolver_rule_association_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.resolver_rule_association_id(input);
            self
        }
        pub fn set_resolver_rule_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resolver_rule_association_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetResolverRulePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_resolver_rule_policy_input::Builder,
    }
    impl<C> GetResolverRulePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetResolverRulePolicyOutput,
            smithy_http::result::SdkError<crate::error::GetResolverRulePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Resolver rule that you want to get the Resolver rule policy for.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ImportFirewallDomains<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::import_firewall_domains_input::Builder,
    }
    impl<C> ImportFirewallDomains<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ImportFirewallDomainsOutput,
            smithy_http::result::SdkError<crate::error::ImportFirewallDomainsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the domain list that you want to modify with the import operation.</p>
        pub fn firewall_domain_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_domain_list_id(input);
            self
        }
        pub fn set_firewall_domain_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_domain_list_id(input);
            self
        }
        /// <p>What you want DNS Firewall to do with the domains that are listed in the file. This must be set to <code>REPLACE</code>, which updates the domain list to exactly match the list in the file. </p>
        pub fn operation(mut self, input: crate::model::FirewallDomainImportOperation) -> Self {
            self.inner = self.inner.operation(input);
            self
        }
        pub fn set_operation(
            mut self,
            input: std::option::Option<crate::model::FirewallDomainImportOperation>,
        ) -> Self {
            self.inner = self.inner.set_operation(input);
            self
        }
        /// <p>The fully qualified URL or URI of the file stored in Amazon Simple Storage Service
        /// (Amazon S3) that contains the list of domains to import.</p>
        /// <p>The file must be in an S3 bucket that's in the same Region
        /// as your DNS Firewall. The file must be a text file and must contain a single domain per line.</p>
        pub fn domain_file_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_file_url(input);
            self
        }
        pub fn set_domain_file_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_domain_file_url(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFirewallConfigs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_firewall_configs_input::Builder,
    }
    impl<C> ListFirewallConfigs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFirewallConfigsOutput,
            smithy_http::result::SdkError<crate::error::ListFirewallConfigsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of objects that you want Resolver to return for this request. If more
        /// objects are available, in the response, Resolver provides a
        /// <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
        /// <p>If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 objects. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>For the first call to this list request, omit this value.</p>
        /// <p>When you request a list of objects, Resolver returns at most the number of objects
        /// specified in <code>MaxResults</code>. If more objects are available for retrieval,
        /// Resolver returns a <code>NextToken</code> value in the response. To retrieve the next
        /// batch of objects, use the token that was returned for the prior request in your next request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFirewallDomainLists<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_firewall_domain_lists_input::Builder,
    }
    impl<C> ListFirewallDomainLists<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFirewallDomainListsOutput,
            smithy_http::result::SdkError<crate::error::ListFirewallDomainListsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of objects that you want Resolver to return for this request. If more
        /// objects are available, in the response, Resolver provides a
        /// <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
        /// <p>If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 objects. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>For the first call to this list request, omit this value.</p>
        /// <p>When you request a list of objects, Resolver returns at most the number of objects
        /// specified in <code>MaxResults</code>. If more objects are available for retrieval,
        /// Resolver returns a <code>NextToken</code> value in the response. To retrieve the next
        /// batch of objects, use the token that was returned for the prior request in your next request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFirewallDomains<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_firewall_domains_input::Builder,
    }
    impl<C> ListFirewallDomains<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFirewallDomainsOutput,
            smithy_http::result::SdkError<crate::error::ListFirewallDomainsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the domain list whose domains you want to retrieve. </p>
        pub fn firewall_domain_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_domain_list_id(input);
            self
        }
        pub fn set_firewall_domain_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_domain_list_id(input);
            self
        }
        /// <p>The maximum number of objects that you want Resolver to return for this request. If more
        /// objects are available, in the response, Resolver provides a
        /// <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
        /// <p>If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 objects. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>For the first call to this list request, omit this value.</p>
        /// <p>When you request a list of objects, Resolver returns at most the number of objects
        /// specified in <code>MaxResults</code>. If more objects are available for retrieval,
        /// Resolver returns a <code>NextToken</code> value in the response. To retrieve the next
        /// batch of objects, use the token that was returned for the prior request in your next request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFirewallRuleGroupAssociations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_firewall_rule_group_associations_input::Builder,
    }
    impl<C> ListFirewallRuleGroupAssociations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFirewallRuleGroupAssociationsOutput,
            smithy_http::result::SdkError<crate::error::ListFirewallRuleGroupAssociationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier of the firewall rule group that you want to retrieve the associations
        /// for. Leave this blank to retrieve associations for any rule group. </p>
        pub fn firewall_rule_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_rule_group_id(input);
            self
        }
        pub fn set_firewall_rule_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_rule_group_id(input);
            self
        }
        /// <p>The unique identifier of the VPC that you want to retrieve the associations
        /// for. Leave this blank to retrieve associations for any VPC. </p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>The setting that determines the processing order of the rule group among the rule
        /// groups that are associated with a single VPC. DNS Firewall filters VPC traffic starting
        /// from the rule group with the lowest numeric priority setting. </p>
        pub fn priority(mut self, input: i32) -> Self {
            self.inner = self.inner.priority(input);
            self
        }
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_priority(input);
            self
        }
        /// <p>The association <code>Status</code> setting that you want DNS Firewall to filter on for the list. If you don't specify this, then DNS Firewall returns all associations, regardless of status.</p>
        pub fn status(mut self, input: crate::model::FirewallRuleGroupAssociationStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::FirewallRuleGroupAssociationStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
        /// <p>The maximum number of objects that you want Resolver to return for this request. If more
        /// objects are available, in the response, Resolver provides a
        /// <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
        /// <p>If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 objects. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>For the first call to this list request, omit this value.</p>
        /// <p>When you request a list of objects, Resolver returns at most the number of objects
        /// specified in <code>MaxResults</code>. If more objects are available for retrieval,
        /// Resolver returns a <code>NextToken</code> value in the response. To retrieve the next
        /// batch of objects, use the token that was returned for the prior request in your next request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFirewallRuleGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_firewall_rule_groups_input::Builder,
    }
    impl<C> ListFirewallRuleGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFirewallRuleGroupsOutput,
            smithy_http::result::SdkError<crate::error::ListFirewallRuleGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of objects that you want Resolver to return for this request. If more
        /// objects are available, in the response, Resolver provides a
        /// <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
        /// <p>If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 objects. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>For the first call to this list request, omit this value.</p>
        /// <p>When you request a list of objects, Resolver returns at most the number of objects
        /// specified in <code>MaxResults</code>. If more objects are available for retrieval,
        /// Resolver returns a <code>NextToken</code> value in the response. To retrieve the next
        /// batch of objects, use the token that was returned for the prior request in your next request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFirewallRules<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_firewall_rules_input::Builder,
    }
    impl<C> ListFirewallRules<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFirewallRulesOutput,
            smithy_http::result::SdkError<crate::error::ListFirewallRulesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier of the firewall rule group that you want to retrieve the rules for. </p>
        pub fn firewall_rule_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_rule_group_id(input);
            self
        }
        pub fn set_firewall_rule_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_rule_group_id(input);
            self
        }
        /// <p>Optional additional filter for the rules to retrieve.</p>
        /// <p>The setting that determines the processing order of the rules in a rule group. DNS Firewall
        /// processes the rules in a rule group by order of priority, starting from the lowest setting.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.inner = self.inner.priority(input);
            self
        }
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_priority(input);
            self
        }
        /// <p>Optional additional filter for the rules to retrieve.</p>
        /// <p>The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ALLOW</code> - Permit the request to go through.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ALERT</code> - Permit the request to go through but send an alert to the logs.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>BLOCK</code> - Disallow the request. If this is specified, additional handling details are provided in the rule's <code>BlockResponse</code> setting. </p>
        /// </li>
        /// </ul>
        pub fn action(mut self, input: crate::model::Action) -> Self {
            self.inner = self.inner.action(input);
            self
        }
        pub fn set_action(mut self, input: std::option::Option<crate::model::Action>) -> Self {
            self.inner = self.inner.set_action(input);
            self
        }
        /// <p>The maximum number of objects that you want Resolver to return for this request. If more
        /// objects are available, in the response, Resolver provides a
        /// <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
        /// <p>If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 objects. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>For the first call to this list request, omit this value.</p>
        /// <p>When you request a list of objects, Resolver returns at most the number of objects
        /// specified in <code>MaxResults</code>. If more objects are available for retrieval,
        /// Resolver returns a <code>NextToken</code> value in the response. To retrieve the next
        /// batch of objects, use the token that was returned for the prior request in your next request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListResolverDnssecConfigs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_resolver_dnssec_configs_input::Builder,
    }
    impl<C> ListResolverDnssecConfigs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListResolverDnssecConfigsOutput,
            smithy_http::result::SdkError<crate::error::ListResolverDnssecConfigsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// <i>Optional</i>: An integer that specifies the maximum number of DNSSEC configuration results that you want Amazon Route 53 to return.
        /// If you don't specify a value for <code>MaxResults</code>, Route 53 returns up to 100 configuration per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>(Optional) If the current AWS account has more than <code>MaxResults</code> DNSSEC configurations, use <code>NextToken</code>
        /// to get the second and subsequent pages of results.</p>
        /// <p>For the first <code>ListResolverDnssecConfigs</code> request, omit this value.</p>
        /// <p>For the second and subsequent requests, get the value of <code>NextToken</code> from the previous response and specify that value
        /// for <code>NextToken</code> in the request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>An optional specification to return a subset of objects.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListResolverEndpointIpAddresses<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_resolver_endpoint_ip_addresses_input::Builder,
    }
    impl<C> ListResolverEndpointIpAddresses<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListResolverEndpointIpAddressesOutput,
            smithy_http::result::SdkError<crate::error::ListResolverEndpointIpAddressesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Resolver endpoint that you want to get IP addresses for.</p>
        pub fn resolver_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resolver_endpoint_id(input);
            self
        }
        pub fn set_resolver_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resolver_endpoint_id(input);
            self
        }
        /// <p>The maximum number of IP addresses that you want to return in the response to a <code>ListResolverEndpointIpAddresses</code> request.
        /// If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 IP addresses. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>For the first <code>ListResolverEndpointIpAddresses</code> request, omit this value.</p>
        /// <p>If the specified Resolver endpoint has more than <code>MaxResults</code> IP addresses, you can submit another
        /// <code>ListResolverEndpointIpAddresses</code> request to get the next group of IP addresses. In the next request, specify the value of
        /// <code>NextToken</code> from the previous response. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListResolverEndpoints<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_resolver_endpoints_input::Builder,
    }
    impl<C> ListResolverEndpoints<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListResolverEndpointsOutput,
            smithy_http::result::SdkError<crate::error::ListResolverEndpointsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of Resolver endpoints that you want to return in the response to a <code>ListResolverEndpoints</code> request.
        /// If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 Resolver endpoints. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>For the first <code>ListResolverEndpoints</code> request, omit this value.</p>
        /// <p>If you have more than <code>MaxResults</code> Resolver endpoints, you can submit another <code>ListResolverEndpoints</code> request
        /// to get the next group of Resolver endpoints. In the next request, specify the value of <code>NextToken</code> from the previous response. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>An optional specification to return a subset of Resolver endpoints, such as all inbound Resolver endpoints.</p>
        /// <note>
        /// <p>If you submit a second or subsequent <code>ListResolverEndpoints</code> request and specify the <code>NextToken</code> parameter,
        /// you must use the same values for <code>Filters</code>, if any, as in the previous request.</p>
        /// </note>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListResolverQueryLogConfigAssociations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_resolver_query_log_config_associations_input::Builder,
    }
    impl<C> ListResolverQueryLogConfigAssociations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListResolverQueryLogConfigAssociationsOutput,
            smithy_http::result::SdkError<
                crate::error::ListResolverQueryLogConfigAssociationsError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of query logging associations that you want to return in the response to a <code>ListResolverQueryLogConfigAssociations</code> request.
        /// If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 query logging associations. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>For the first <code>ListResolverQueryLogConfigAssociations</code> request, omit this value.</p>
        /// <p>If there are more than <code>MaxResults</code> query logging associations that match the values that you specify for <code>Filters</code>,
        /// you can submit another <code>ListResolverQueryLogConfigAssociations</code> request to get the next group of associations. In the next request, specify the value of
        /// <code>NextToken</code> from the previous response. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>An optional specification to return a subset of query logging associations.</p>
        /// <note>
        /// <p>If you submit a second or subsequent <code>ListResolverQueryLogConfigAssociations</code> request and specify the <code>NextToken</code> parameter,
        /// you must use the same values for <code>Filters</code>, if any, as in the previous request.</p>
        /// </note>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The element that you want Resolver to sort query logging associations by. </p>
        /// <note>
        /// <p>If you submit a second or subsequent <code>ListResolverQueryLogConfigAssociations</code> request and specify the <code>NextToken</code> parameter,
        /// you must use the same value for <code>SortBy</code>, if any, as in the previous request.</p>
        /// </note>
        /// <p>Valid values include the following elements:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>CreationTime</code>: The ID of the query logging association.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Error</code>: If the value of <code>Status</code> is <code>FAILED</code>, the value of <code>Error</code>
        /// indicates the cause: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DESTINATION_NOT_FOUND</code>: The specified destination (for example, an Amazon S3 bucket) was deleted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ACCESS_DENIED</code>: Permissions don't allow sending logs to the destination.</p>
        /// </li>
        /// </ul>
        /// <p>If <code>Status</code> is a value other than <code>FAILED</code>, <code>ERROR</code> is null.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Id</code>: The ID of the query logging association</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ResolverQueryLogConfigId</code>: The ID of the query logging configuration</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ResourceId</code>: The ID of the VPC that is associated with the query logging configuration</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Status</code>: The current status of the configuration. Valid values include the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>CREATING</code>: Resolver is creating an association between an Amazon VPC and a query logging configuration.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>CREATED</code>: The association between an Amazon VPC and a query logging configuration
        /// was successfully created. Resolver is logging queries that originate in the specified VPC.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DELETING</code>: Resolver is deleting this query logging association.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FAILED</code>: Resolver either couldn't create or couldn't delete the query logging association.
        /// Here are two common causes:</p>
        /// <ul>
        /// <li>
        /// <p>The specified destination (for example, an Amazon S3 bucket) was deleted.</p>
        /// </li>
        /// <li>
        /// <p>Permissions don't allow sending logs to the destination.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// </ul>
        /// </li>
        /// </ul>
        pub fn sort_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sort_by(input);
            self
        }
        pub fn set_sort_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_sort_by(input);
            self
        }
        /// <p>If you specified a value for <code>SortBy</code>, the order that you want query logging associations to be listed in,
        /// <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
        /// <note>
        /// <p>If you submit a second or subsequent <code>ListResolverQueryLogConfigAssociations</code> request and specify the <code>NextToken</code> parameter,
        /// you must use the same value for <code>SortOrder</code>, if any, as in the previous request.</p>
        /// </note>
        pub fn sort_order(mut self, input: crate::model::SortOrder) -> Self {
            self.inner = self.inner.sort_order(input);
            self
        }
        pub fn set_sort_order(
            mut self,
            input: std::option::Option<crate::model::SortOrder>,
        ) -> Self {
            self.inner = self.inner.set_sort_order(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListResolverQueryLogConfigs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_resolver_query_log_configs_input::Builder,
    }
    impl<C> ListResolverQueryLogConfigs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListResolverQueryLogConfigsOutput,
            smithy_http::result::SdkError<crate::error::ListResolverQueryLogConfigsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of query logging configurations that you want to return in the response to a <code>ListResolverQueryLogConfigs</code> request.
        /// If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 query logging configurations. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>For the first <code>ListResolverQueryLogConfigs</code> request, omit this value.</p>
        /// <p>If there are more than <code>MaxResults</code> query logging configurations that match the values that you specify for <code>Filters</code>,
        /// you can submit another <code>ListResolverQueryLogConfigs</code> request to get the next group of configurations. In the next request, specify the value of
        /// <code>NextToken</code> from the previous response. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>An optional specification to return a subset of query logging configurations.</p>
        /// <note>
        /// <p>If you submit a second or subsequent <code>ListResolverQueryLogConfigs</code> request and specify the <code>NextToken</code> parameter,
        /// you must use the same values for <code>Filters</code>, if any, as in the previous request.</p>
        /// </note>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The element that you want Resolver to sort query logging configurations by. </p>
        /// <note>
        /// <p>If you submit a second or subsequent <code>ListResolverQueryLogConfigs</code> request and specify the <code>NextToken</code> parameter,
        /// you must use the same value for <code>SortBy</code>, if any, as in the previous request.</p>
        /// </note>
        /// <p>Valid values include the following elements:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Arn</code>: The ARN of the query logging configuration</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AssociationCount</code>: The number of VPCs that are associated with the specified configuration </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>CreationTime</code>: The date and time that Resolver returned when the configuration was created</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>CreatorRequestId</code>: The value that was specified for <code>CreatorRequestId</code> when the configuration was created</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DestinationArn</code>: The location that logs are sent to</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Id</code>: The ID of the configuration</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Name</code>: The name of the configuration</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OwnerId</code>: The AWS account number of the account that created the configuration</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ShareStatus</code>: Whether the configuration is shared with other AWS accounts or shared with the current account by
        /// another AWS account. Sharing is configured through AWS Resource Access Manager (AWS RAM).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Status</code>: The current status of the configuration. Valid values include the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>CREATING</code>: Resolver is creating the query logging configuration.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>CREATED</code>: The query logging configuration was successfully created.
        /// Resolver is logging queries that originate in the specified VPC.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DELETING</code>: Resolver is deleting this query logging configuration.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FAILED</code>: Resolver either couldn't create or couldn't delete the query logging configuration.
        /// Here are two common causes:</p>
        /// <ul>
        /// <li>
        /// <p>The specified destination (for example, an Amazon S3 bucket) was deleted.</p>
        /// </li>
        /// <li>
        /// <p>Permissions don't allow sending logs to the destination.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// </ul>
        /// </li>
        /// </ul>
        pub fn sort_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sort_by(input);
            self
        }
        pub fn set_sort_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_sort_by(input);
            self
        }
        /// <p>If you specified a value for <code>SortBy</code>, the order that you want query logging configurations to be listed in,
        /// <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
        /// <note>
        /// <p>If you submit a second or subsequent <code>ListResolverQueryLogConfigs</code> request and specify the <code>NextToken</code> parameter,
        /// you must use the same value for <code>SortOrder</code>, if any, as in the previous request.</p>
        /// </note>
        pub fn sort_order(mut self, input: crate::model::SortOrder) -> Self {
            self.inner = self.inner.sort_order(input);
            self
        }
        pub fn set_sort_order(
            mut self,
            input: std::option::Option<crate::model::SortOrder>,
        ) -> Self {
            self.inner = self.inner.set_sort_order(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListResolverRuleAssociations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_resolver_rule_associations_input::Builder,
    }
    impl<C> ListResolverRuleAssociations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListResolverRuleAssociationsOutput,
            smithy_http::result::SdkError<crate::error::ListResolverRuleAssociationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of rule associations that you want to return in the response to a <code>ListResolverRuleAssociations</code> request.
        /// If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 rule associations. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>For the first <code>ListResolverRuleAssociation</code> request, omit this value.</p>
        /// <p>If you have more than <code>MaxResults</code> rule associations, you can submit another <code>ListResolverRuleAssociation</code> request
        /// to get the next group of rule associations. In the next request, specify the value of <code>NextToken</code> from the previous response. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>An optional specification to return a subset of Resolver rules, such as Resolver rules that are associated with the same VPC ID.</p>
        /// <note>
        /// <p>If you submit a second or subsequent <code>ListResolverRuleAssociations</code> request and specify the <code>NextToken</code> parameter,
        /// you must use the same values for <code>Filters</code>, if any, as in the previous request.</p>
        /// </note>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListResolverRules<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_resolver_rules_input::Builder,
    }
    impl<C> ListResolverRules<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListResolverRulesOutput,
            smithy_http::result::SdkError<crate::error::ListResolverRulesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of Resolver rules that you want to return in the response to a <code>ListResolverRules</code> request.
        /// If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 Resolver rules.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>For the first <code>ListResolverRules</code> request, omit this value.</p>
        /// <p>If you have more than <code>MaxResults</code> Resolver rules, you can submit another <code>ListResolverRules</code> request
        /// to get the next group of Resolver rules. In the next request, specify the value of <code>NextToken</code> from the previous response. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>An optional specification to return a subset of Resolver rules, such as all Resolver rules that are associated with the same Resolver endpoint.</p>
        /// <note>
        /// <p>If you submit a second or subsequent <code>ListResolverRules</code> request and specify the <code>NextToken</code> parameter,
        /// you must use the same values for <code>Filters</code>, if any, as in the previous request.</p>
        /// </note>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) for the resource that you want to list tags for.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The maximum number of tags that you want to return in the response to a <code>ListTagsForResource</code> request.
        /// If you don't specify a value for <code>MaxResults</code>, Resolver returns up to 100 tags.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>For the first <code>ListTagsForResource</code> request, omit this value.</p>
        /// <p>If you have more than <code>MaxResults</code> tags, you can submit another <code>ListTagsForResource</code> request
        /// to get the next group of tags for the resource. In the next request, specify the value of <code>NextToken</code> from the previous response. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutFirewallRuleGroupPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_firewall_rule_group_policy_input::Builder,
    }
    impl<C> PutFirewallRuleGroupPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutFirewallRuleGroupPolicyOutput,
            smithy_http::result::SdkError<crate::error::PutFirewallRuleGroupPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN (Amazon Resource Name) for the rule group that you want to share.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>The AWS Identity and Access Management (AWS IAM) policy to attach to the rule group.</p>
        pub fn firewall_rule_group_policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_rule_group_policy(input);
            self
        }
        pub fn set_firewall_rule_group_policy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_rule_group_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutResolverQueryLogConfigPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_resolver_query_log_config_policy_input::Builder,
    }
    impl<C> PutResolverQueryLogConfigPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutResolverQueryLogConfigPolicyOutput,
            smithy_http::result::SdkError<crate::error::PutResolverQueryLogConfigPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the account that you want to share rules with.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>An AWS Identity and Access Management policy statement that lists the query logging configurations that you want to share with another AWS account
        /// and the operations that you want the account to be able to perform. You can specify the following operations in the <code>Actions</code> section
        /// of the statement:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>route53resolver:AssociateResolverQueryLogConfig</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route53resolver:DisassociateResolverQueryLogConfig</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route53resolver:ListResolverQueryLogConfigAssociations</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route53resolver:ListResolverQueryLogConfigs</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>In the <code>Resource</code> section of the statement, you specify the ARNs for the query logging configurations that you want to share
        /// with the account that you specified in <code>Arn</code>. </p>
        pub fn resolver_query_log_config_policy(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.resolver_query_log_config_policy(input);
            self
        }
        pub fn set_resolver_query_log_config_policy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resolver_query_log_config_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutResolverRulePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_resolver_rule_policy_input::Builder,
    }
    impl<C> PutResolverRulePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutResolverRulePolicyOutput,
            smithy_http::result::SdkError<crate::error::PutResolverRulePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the rule that you want to share with another account.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>An AWS Identity and Access Management policy statement that lists the rules that you want to share with another AWS account and the operations that you want the account
        /// to be able to perform. You can specify the following operations in the <code>Action</code> section of the statement:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>route53resolver:GetResolverRule</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route53resolver:AssociateResolverRule</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route53resolver:DisassociateResolverRule</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route53resolver:ListResolverRules</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route53resolver:ListResolverRuleAssociations</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>In the <code>Resource</code> section of the statement, specify the ARN for the rule that you want to share with another account. Specify the same ARN
        /// that you specified in <code>Arn</code>.</p>
        pub fn resolver_rule_policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resolver_rule_policy(input);
            self
        }
        pub fn set_resolver_rule_policy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resolver_rule_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) for the resource that you want to add tags to. To get the ARN for a resource, use the applicable
        /// <code>Get</code> or <code>List</code> command: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html">GetResolverEndpoint</a>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRule.html">GetResolverRule</a>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRuleAssociation.html">GetResolverRuleAssociation</a>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverEndpoints.html">ListResolverEndpoints</a>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html">ListResolverRuleAssociations</a>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html">ListResolverRules</a>
        /// </p>
        /// </li>
        /// </ul>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The tags that you want to add to the specified resource.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) for the resource that you want to remove tags from. To get the ARN for a resource, use the applicable
        /// <code>Get</code> or <code>List</code> command: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html">GetResolverEndpoint</a>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRule.html">GetResolverRule</a>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRuleAssociation.html">GetResolverRuleAssociation</a>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverEndpoints.html">ListResolverEndpoints</a>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html">ListResolverRuleAssociations</a>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html">ListResolverRules</a>
        /// </p>
        /// </li>
        /// </ul>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The tags that you want to remove to the specified resource.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFirewallConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_firewall_config_input::Builder,
    }
    impl<C> UpdateFirewallConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateFirewallConfigOutput,
            smithy_http::result::SdkError<crate::error::UpdateFirewallConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the VPC that the configuration is for.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(input);
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(input);
            self
        }
        /// <p>Determines how Route 53 Resolver handles queries during failures, for example when all traffic that is sent to DNS Firewall fails to receive a reply. </p>
        /// <ul>
        /// <li>
        /// <p>By default, fail open is disabled, which means the failure mode is closed. This approach favors security over availability.
        /// DNS Firewall blocks queries that it is unable to evaluate properly. </p>
        /// </li>
        /// <li>
        /// <p>If you enable this option, the failure mode is open. This approach favors availability over security. DNS Firewall allows queries to proceed if it
        /// is unable to properly evaluate them. </p>
        /// </li>
        /// </ul>
        /// <p>This behavior is only enforced for VPCs that have at least one DNS Firewall rule group association. </p>
        pub fn firewall_fail_open(mut self, input: crate::model::FirewallFailOpenStatus) -> Self {
            self.inner = self.inner.firewall_fail_open(input);
            self
        }
        pub fn set_firewall_fail_open(
            mut self,
            input: std::option::Option<crate::model::FirewallFailOpenStatus>,
        ) -> Self {
            self.inner = self.inner.set_firewall_fail_open(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFirewallDomains<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_firewall_domains_input::Builder,
    }
    impl<C> UpdateFirewallDomains<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateFirewallDomainsOutput,
            smithy_http::result::SdkError<crate::error::UpdateFirewallDomainsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the domain list whose domains you want to update. </p>
        pub fn firewall_domain_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_domain_list_id(input);
            self
        }
        pub fn set_firewall_domain_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_domain_list_id(input);
            self
        }
        /// <p>What you want DNS Firewall to do with the domains that you are providing: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ADD</code> - Add the domains to the ones that are already in the domain list. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>REMOVE</code> - Search the domain list for the domains and remove them from the list.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>REPLACE</code> - Update the domain list to exactly match the list that you are providing. </p>
        /// </li>
        /// </ul>
        pub fn operation(mut self, input: crate::model::FirewallDomainUpdateOperation) -> Self {
            self.inner = self.inner.operation(input);
            self
        }
        pub fn set_operation(
            mut self,
            input: std::option::Option<crate::model::FirewallDomainUpdateOperation>,
        ) -> Self {
            self.inner = self.inner.set_operation(input);
            self
        }
        /// <p>A list of domains to use in the update operation.</p>
        /// <p>Each domain specification in your domain list must satisfy the following
        /// requirements: </p>
        /// <ul>
        /// <li>
        /// <p>It can optionally start with <code>*</code> (asterisk).</p>
        /// </li>
        /// <li>
        /// <p>With the exception of the optional starting asterisk, it must only contain
        /// the following characters: <code>A-Z</code>, <code>a-z</code>,
        /// <code>0-9</code>, <code>-</code> (hyphen).</p>
        /// </li>
        /// <li>
        /// <p>It must be from 1-255 characters in length. </p>
        /// </li>
        /// </ul>
        pub fn domains(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domains(inp);
            self
        }
        pub fn set_domains(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_domains(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFirewallRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_firewall_rule_input::Builder,
    }
    impl<C> UpdateFirewallRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateFirewallRuleOutput,
            smithy_http::result::SdkError<crate::error::UpdateFirewallRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier of the firewall rule group for the rule. </p>
        pub fn firewall_rule_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_rule_group_id(input);
            self
        }
        pub fn set_firewall_rule_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_rule_group_id(input);
            self
        }
        /// <p>The ID of the domain list to use in the rule.  </p>
        pub fn firewall_domain_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_domain_list_id(input);
            self
        }
        pub fn set_firewall_domain_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_domain_list_id(input);
            self
        }
        /// <p>The setting that determines the processing order of the rule in the rule group. DNS Firewall
        /// processes the rules in a rule group by order of priority, starting from the lowest setting.</p>
        /// <p>You must specify a unique priority for each rule in a rule group.
        /// To make it easier to insert rules later, leave space between the numbers, for example, use 100, 200, and so on. You
        /// can change the priority setting for the rules in a rule group at any time.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.inner = self.inner.priority(input);
            self
        }
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_priority(input);
            self
        }
        /// <p>The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ALLOW</code> - Permit the request to go through.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ALERT</code> - Permit the request to go through but send an alert to the logs.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>BLOCK</code> - Disallow the request. This option requires additional details in the rule's <code>BlockResponse</code>. </p>
        /// </li>
        /// </ul>
        pub fn action(mut self, input: crate::model::Action) -> Self {
            self.inner = self.inner.action(input);
            self
        }
        pub fn set_action(mut self, input: std::option::Option<crate::model::Action>) -> Self {
            self.inner = self.inner.set_action(input);
            self
        }
        /// <p>The way that you want DNS Firewall to block the request. Used for the rule action setting <code>BLOCK</code>.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>NODATA</code> - Respond indicating that the query was successful, but no response is available for it.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NXDOMAIN</code> - Respond indicating that the domain name that's in the query doesn't exist.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OVERRIDE</code> - Provide a custom override in the response. This option requires custom handling details in the rule's <code>BlockOverride*</code> settings. </p>
        /// </li>
        /// </ul>
        pub fn block_response(mut self, input: crate::model::BlockResponse) -> Self {
            self.inner = self.inner.block_response(input);
            self
        }
        pub fn set_block_response(
            mut self,
            input: std::option::Option<crate::model::BlockResponse>,
        ) -> Self {
            self.inner = self.inner.set_block_response(input);
            self
        }
        /// <p>The custom DNS record to send back in response to the query. Used for the rule action <code>BLOCK</code> with a <code>BlockResponse</code> setting of <code>OVERRIDE</code>.</p>
        pub fn block_override_domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.block_override_domain(input);
            self
        }
        pub fn set_block_override_domain(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_block_override_domain(input);
            self
        }
        /// <p>The DNS record's type. This determines the format of the record value that you provided in <code>BlockOverrideDomain</code>. Used for the rule action <code>BLOCK</code> with a <code>BlockResponse</code> setting of <code>OVERRIDE</code>.</p>
        pub fn block_override_dns_type(
            mut self,
            input: crate::model::BlockOverrideDnsType,
        ) -> Self {
            self.inner = self.inner.block_override_dns_type(input);
            self
        }
        pub fn set_block_override_dns_type(
            mut self,
            input: std::option::Option<crate::model::BlockOverrideDnsType>,
        ) -> Self {
            self.inner = self.inner.set_block_override_dns_type(input);
            self
        }
        /// <p>The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action <code>BLOCK</code> with a <code>BlockResponse</code> setting of <code>OVERRIDE</code>.</p>
        pub fn block_override_ttl(mut self, input: i32) -> Self {
            self.inner = self.inner.block_override_ttl(input);
            self
        }
        pub fn set_block_override_ttl(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_block_override_ttl(input);
            self
        }
        /// <p>The name of the rule.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFirewallRuleGroupAssociation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_firewall_rule_group_association_input::Builder,
    }
    impl<C> UpdateFirewallRuleGroupAssociation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateFirewallRuleGroupAssociationOutput,
            smithy_http::result::SdkError<crate::error::UpdateFirewallRuleGroupAssociationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the <a>FirewallRuleGroupAssociation</a>. </p>
        pub fn firewall_rule_group_association_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.firewall_rule_group_association_id(input);
            self
        }
        pub fn set_firewall_rule_group_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_rule_group_association_id(input);
            self
        }
        /// <p>The setting that determines the processing order of the rule group among the rule
        /// groups that you associate with the specified VPC. DNS Firewall filters VPC traffic
        /// starting from the rule group with the lowest numeric priority setting. </p>
        /// <p>You must specify a unique priority for each rule group that you associate with a single VPC.
        /// To make it easier to insert rule groups later, leave space between the numbers, for example, use 100, 200, and so on. You
        /// can change the priority setting for a rule group association after you create it.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.inner = self.inner.priority(input);
            self
        }
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_priority(input);
            self
        }
        /// <p>If enabled, this setting disallows modification or removal of the association, to help prevent against accidentally altering DNS firewall protections. </p>
        pub fn mutation_protection(
            mut self,
            input: crate::model::MutationProtectionStatus,
        ) -> Self {
            self.inner = self.inner.mutation_protection(input);
            self
        }
        pub fn set_mutation_protection(
            mut self,
            input: std::option::Option<crate::model::MutationProtectionStatus>,
        ) -> Self {
            self.inner = self.inner.set_mutation_protection(input);
            self
        }
        /// <p>The name of the rule group association.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateResolverDnssecConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_resolver_dnssec_config_input::Builder,
    }
    impl<C> UpdateResolverDnssecConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateResolverDnssecConfigOutput,
            smithy_http::result::SdkError<crate::error::UpdateResolverDnssecConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the virtual private cloud (VPC) that you're updating the DNSSEC validation status for.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(input);
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(input);
            self
        }
        /// <p>The new value that you are specifying for DNSSEC validation for the VPC. The value can be <code>ENABLE</code>
        /// or <code>DISABLE</code>. Be aware that it can take time for a validation status change to be completed.</p>
        pub fn validation(mut self, input: crate::model::Validation) -> Self {
            self.inner = self.inner.validation(input);
            self
        }
        pub fn set_validation(
            mut self,
            input: std::option::Option<crate::model::Validation>,
        ) -> Self {
            self.inner = self.inner.set_validation(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateResolverEndpoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_resolver_endpoint_input::Builder,
    }
    impl<C> UpdateResolverEndpoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateResolverEndpointOutput,
            smithy_http::result::SdkError<crate::error::UpdateResolverEndpointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Resolver endpoint that you want to update.</p>
        pub fn resolver_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resolver_endpoint_id(input);
            self
        }
        pub fn set_resolver_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resolver_endpoint_id(input);
            self
        }
        /// <p>The name of the Resolver endpoint that you want to update.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateResolverRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_resolver_rule_input::Builder,
    }
    impl<C> UpdateResolverRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateResolverRuleOutput,
            smithy_http::result::SdkError<crate::error::UpdateResolverRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Resolver rule that you want to update.</p>
        pub fn resolver_rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resolver_rule_id(input);
            self
        }
        pub fn set_resolver_rule_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resolver_rule_id(input);
            self
        }
        /// <p>The new settings for the Resolver rule.</p>
        pub fn config(mut self, input: crate::model::ResolverRuleConfig) -> Self {
            self.inner = self.inner.config(input);
            self
        }
        pub fn set_config(
            mut self,
            input: std::option::Option<crate::model::ResolverRuleConfig>,
        ) -> Self {
            self.inner = self.inner.set_config(input);
            self
        }
    }
}
