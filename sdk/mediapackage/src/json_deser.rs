// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub fn parse_generic_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<smithy_types::Error, serde_json::Error> {
    let body =
        serde_json::from_slice(response.body().as_ref()).unwrap_or_else(|_| serde_json::json!({}));
    Ok(crate::aws_json_errors::parse_generic_error(
        &response, &body,
    ))
}

pub fn forbidden_exception(
    input: &[u8],
    mut builder: crate::error::forbidden_error::Builder,
) -> std::result::Result<crate::error::forbidden_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::ForbiddenError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn internal_server_error_exception(
    input: &[u8],
    mut builder: crate::error::internal_server_error_error::Builder,
) -> std::result::Result<crate::error::internal_server_error_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::InternalServerErrorError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn not_found_exception(
    input: &[u8],
    mut builder: crate::error::not_found_error::Builder,
) -> std::result::Result<crate::error::not_found_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::NotFoundError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn service_unavailable_exception(
    input: &[u8],
    mut builder: crate::error::service_unavailable_error::Builder,
) -> std::result::Result<crate::error::service_unavailable_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::ServiceUnavailableError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn too_many_requests_exception(
    input: &[u8],
    mut builder: crate::error::too_many_requests_error::Builder,
) -> std::result::Result<crate::error::too_many_requests_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::TooManyRequestsError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn unprocessable_entity_exception(
    input: &[u8],
    mut builder: crate::error::unprocessable_entity_error::Builder,
) -> std::result::Result<crate::error::unprocessable_entity_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::UnprocessableEntityError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn configure_logs_deser_operation(
    input: &[u8],
    mut builder: crate::output::configure_logs_output::Builder,
) -> std::result::Result<crate::output::configure_logs_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ConfigureLogsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_egress_access_logs(parsed_body.egress_access_logs);
    builder = builder.set_hls_ingest(parsed_body.hls_ingest);
    builder = builder.set_id(parsed_body.id);
    builder = builder.set_ingress_access_logs(parsed_body.ingress_access_logs);
    builder = builder.set_tags(parsed_body.tags);
    Ok(builder)
}

pub fn create_channel_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_channel_output::Builder,
) -> std::result::Result<crate::output::create_channel_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateChannelOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_egress_access_logs(parsed_body.egress_access_logs);
    builder = builder.set_hls_ingest(parsed_body.hls_ingest);
    builder = builder.set_id(parsed_body.id);
    builder = builder.set_ingress_access_logs(parsed_body.ingress_access_logs);
    builder = builder.set_tags(parsed_body.tags);
    Ok(builder)
}

pub fn create_harvest_job_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_harvest_job_output::Builder,
) -> std::result::Result<crate::output::create_harvest_job_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateHarvestJobOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_channel_id(parsed_body.channel_id);
    builder = builder.set_created_at(parsed_body.created_at);
    builder = builder.set_end_time(parsed_body.end_time);
    builder = builder.set_id(parsed_body.id);
    builder = builder.set_origin_endpoint_id(parsed_body.origin_endpoint_id);
    builder = builder.set_s3_destination(parsed_body.s3_destination);
    builder = builder.set_start_time(parsed_body.start_time);
    builder = builder.set_status(parsed_body.status);
    Ok(builder)
}

pub fn create_origin_endpoint_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_origin_endpoint_output::Builder,
) -> std::result::Result<crate::output::create_origin_endpoint_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateOriginEndpointOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_authorization(parsed_body.authorization);
    builder = builder.set_channel_id(parsed_body.channel_id);
    builder = builder.set_cmaf_package(parsed_body.cmaf_package);
    builder = builder.set_dash_package(parsed_body.dash_package);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_hls_package(parsed_body.hls_package);
    builder = builder.set_id(parsed_body.id);
    builder = builder.set_manifest_name(parsed_body.manifest_name);
    builder = builder.set_mss_package(parsed_body.mss_package);
    builder = builder.set_origination(parsed_body.origination);
    builder = builder.set_startover_window_seconds(Some(parsed_body.startover_window_seconds));
    builder = builder.set_tags(parsed_body.tags);
    builder = builder.set_time_delay_seconds(Some(parsed_body.time_delay_seconds));
    builder = builder.set_url(parsed_body.url);
    builder = builder.set_whitelist(parsed_body.whitelist);
    Ok(builder)
}

pub fn describe_channel_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_channel_output::Builder,
) -> std::result::Result<crate::output::describe_channel_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeChannelOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_egress_access_logs(parsed_body.egress_access_logs);
    builder = builder.set_hls_ingest(parsed_body.hls_ingest);
    builder = builder.set_id(parsed_body.id);
    builder = builder.set_ingress_access_logs(parsed_body.ingress_access_logs);
    builder = builder.set_tags(parsed_body.tags);
    Ok(builder)
}

pub fn describe_harvest_job_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_harvest_job_output::Builder,
) -> std::result::Result<crate::output::describe_harvest_job_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeHarvestJobOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_channel_id(parsed_body.channel_id);
    builder = builder.set_created_at(parsed_body.created_at);
    builder = builder.set_end_time(parsed_body.end_time);
    builder = builder.set_id(parsed_body.id);
    builder = builder.set_origin_endpoint_id(parsed_body.origin_endpoint_id);
    builder = builder.set_s3_destination(parsed_body.s3_destination);
    builder = builder.set_start_time(parsed_body.start_time);
    builder = builder.set_status(parsed_body.status);
    Ok(builder)
}

pub fn describe_origin_endpoint_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_origin_endpoint_output::Builder,
) -> std::result::Result<crate::output::describe_origin_endpoint_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::DescribeOriginEndpointOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_authorization(parsed_body.authorization);
    builder = builder.set_channel_id(parsed_body.channel_id);
    builder = builder.set_cmaf_package(parsed_body.cmaf_package);
    builder = builder.set_dash_package(parsed_body.dash_package);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_hls_package(parsed_body.hls_package);
    builder = builder.set_id(parsed_body.id);
    builder = builder.set_manifest_name(parsed_body.manifest_name);
    builder = builder.set_mss_package(parsed_body.mss_package);
    builder = builder.set_origination(parsed_body.origination);
    builder = builder.set_startover_window_seconds(Some(parsed_body.startover_window_seconds));
    builder = builder.set_tags(parsed_body.tags);
    builder = builder.set_time_delay_seconds(Some(parsed_body.time_delay_seconds));
    builder = builder.set_url(parsed_body.url);
    builder = builder.set_whitelist(parsed_body.whitelist);
    Ok(builder)
}

pub fn list_channels_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_channels_output::Builder,
) -> std::result::Result<crate::output::list_channels_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListChannelsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_channels(parsed_body.channels);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_harvest_jobs_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_harvest_jobs_output::Builder,
) -> std::result::Result<crate::output::list_harvest_jobs_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListHarvestJobsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_harvest_jobs(parsed_body.harvest_jobs);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_origin_endpoints_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_origin_endpoints_output::Builder,
) -> std::result::Result<crate::output::list_origin_endpoints_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListOriginEndpointsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_next_token(parsed_body.next_token);
    builder = builder.set_origin_endpoints(parsed_body.origin_endpoints);
    Ok(builder)
}

pub fn list_tags_for_resource_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_tags_for_resource_output::Builder,
) -> std::result::Result<crate::output::list_tags_for_resource_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListTagsForResourceOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_tags(parsed_body.tags);
    Ok(builder)
}

pub fn rotate_channel_credentials_deser_operation(
    input: &[u8],
    mut builder: crate::output::rotate_channel_credentials_output::Builder,
) -> std::result::Result<crate::output::rotate_channel_credentials_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::RotateChannelCredentialsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_egress_access_logs(parsed_body.egress_access_logs);
    builder = builder.set_hls_ingest(parsed_body.hls_ingest);
    builder = builder.set_id(parsed_body.id);
    builder = builder.set_ingress_access_logs(parsed_body.ingress_access_logs);
    builder = builder.set_tags(parsed_body.tags);
    Ok(builder)
}

pub fn rotate_ingest_endpoint_credentials_deser_operation(
    input: &[u8],
    mut builder: crate::output::rotate_ingest_endpoint_credentials_output::Builder,
) -> std::result::Result<
    crate::output::rotate_ingest_endpoint_credentials_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::RotateIngestEndpointCredentialsOutputBody =
        if input.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(input)?
        };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_egress_access_logs(parsed_body.egress_access_logs);
    builder = builder.set_hls_ingest(parsed_body.hls_ingest);
    builder = builder.set_id(parsed_body.id);
    builder = builder.set_ingress_access_logs(parsed_body.ingress_access_logs);
    builder = builder.set_tags(parsed_body.tags);
    Ok(builder)
}

pub fn update_channel_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_channel_output::Builder,
) -> std::result::Result<crate::output::update_channel_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateChannelOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_egress_access_logs(parsed_body.egress_access_logs);
    builder = builder.set_hls_ingest(parsed_body.hls_ingest);
    builder = builder.set_id(parsed_body.id);
    builder = builder.set_ingress_access_logs(parsed_body.ingress_access_logs);
    builder = builder.set_tags(parsed_body.tags);
    Ok(builder)
}

pub fn update_origin_endpoint_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_origin_endpoint_output::Builder,
) -> std::result::Result<crate::output::update_origin_endpoint_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateOriginEndpointOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_authorization(parsed_body.authorization);
    builder = builder.set_channel_id(parsed_body.channel_id);
    builder = builder.set_cmaf_package(parsed_body.cmaf_package);
    builder = builder.set_dash_package(parsed_body.dash_package);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_hls_package(parsed_body.hls_package);
    builder = builder.set_id(parsed_body.id);
    builder = builder.set_manifest_name(parsed_body.manifest_name);
    builder = builder.set_mss_package(parsed_body.mss_package);
    builder = builder.set_origination(parsed_body.origination);
    builder = builder.set_startover_window_seconds(Some(parsed_body.startover_window_seconds));
    builder = builder.set_tags(parsed_body.tags);
    builder = builder.set_time_delay_seconds(Some(parsed_body.time_delay_seconds));
    builder = builder.set_url(parsed_body.url);
    builder = builder.set_whitelist(parsed_body.whitelist);
    Ok(builder)
}
