// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ConfigureLogsError {
    pub kind: ConfigureLogsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ConfigureLogsErrorKind {
    ForbiddenError(crate::error::ForbiddenError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ConfigureLogsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ConfigureLogsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            ConfigureLogsErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            ConfigureLogsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            ConfigureLogsErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            ConfigureLogsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ConfigureLogsErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            ConfigureLogsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ConfigureLogsError {
    fn code(&self) -> Option<&str> {
        ConfigureLogsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ConfigureLogsError {
    pub fn new(kind: ConfigureLogsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ConfigureLogsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ConfigureLogsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, ConfigureLogsErrorKind::ForbiddenError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            ConfigureLogsErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, ConfigureLogsErrorKind::NotFoundError(_))
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            ConfigureLogsErrorKind::ServiceUnavailableError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, ConfigureLogsErrorKind::TooManyRequestsError(_))
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            ConfigureLogsErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for ConfigureLogsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ConfigureLogsErrorKind::ForbiddenError(_inner) => Some(_inner),
            ConfigureLogsErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            ConfigureLogsErrorKind::NotFoundError(_inner) => Some(_inner),
            ConfigureLogsErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            ConfigureLogsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ConfigureLogsErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            ConfigureLogsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateChannelError {
    pub kind: CreateChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateChannelErrorKind {
    ForbiddenError(crate::error::ForbiddenError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateChannelErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateChannelError {
    fn code(&self) -> Option<&str> {
        CreateChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateChannelError {
    pub fn new(kind: CreateChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, CreateChannelErrorKind::ForbiddenError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, CreateChannelErrorKind::NotFoundError(_))
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelErrorKind::ServiceUnavailableError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, CreateChannelErrorKind::TooManyRequestsError(_))
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for CreateChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateChannelErrorKind::ForbiddenError(_inner) => Some(_inner),
            CreateChannelErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            CreateChannelErrorKind::NotFoundError(_inner) => Some(_inner),
            CreateChannelErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            CreateChannelErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateChannelErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            CreateChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateHarvestJobError {
    pub kind: CreateHarvestJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateHarvestJobErrorKind {
    ForbiddenError(crate::error::ForbiddenError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateHarvestJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateHarvestJobErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            CreateHarvestJobErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            CreateHarvestJobErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreateHarvestJobErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            CreateHarvestJobErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateHarvestJobErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            CreateHarvestJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateHarvestJobError {
    fn code(&self) -> Option<&str> {
        CreateHarvestJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateHarvestJobError {
    pub fn new(kind: CreateHarvestJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateHarvestJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateHarvestJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, CreateHarvestJobErrorKind::ForbiddenError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateHarvestJobErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, CreateHarvestJobErrorKind::NotFoundError(_))
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateHarvestJobErrorKind::ServiceUnavailableError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateHarvestJobErrorKind::TooManyRequestsError(_)
        )
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateHarvestJobErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for CreateHarvestJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateHarvestJobErrorKind::ForbiddenError(_inner) => Some(_inner),
            CreateHarvestJobErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            CreateHarvestJobErrorKind::NotFoundError(_inner) => Some(_inner),
            CreateHarvestJobErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            CreateHarvestJobErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateHarvestJobErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            CreateHarvestJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateOriginEndpointError {
    pub kind: CreateOriginEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateOriginEndpointErrorKind {
    ForbiddenError(crate::error::ForbiddenError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateOriginEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateOriginEndpointErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            CreateOriginEndpointErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            CreateOriginEndpointErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreateOriginEndpointErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            CreateOriginEndpointErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateOriginEndpointErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            CreateOriginEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateOriginEndpointError {
    fn code(&self) -> Option<&str> {
        CreateOriginEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateOriginEndpointError {
    pub fn new(kind: CreateOriginEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateOriginEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateOriginEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, CreateOriginEndpointErrorKind::ForbiddenError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateOriginEndpointErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, CreateOriginEndpointErrorKind::NotFoundError(_))
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateOriginEndpointErrorKind::ServiceUnavailableError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateOriginEndpointErrorKind::TooManyRequestsError(_)
        )
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateOriginEndpointErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for CreateOriginEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateOriginEndpointErrorKind::ForbiddenError(_inner) => Some(_inner),
            CreateOriginEndpointErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            CreateOriginEndpointErrorKind::NotFoundError(_inner) => Some(_inner),
            CreateOriginEndpointErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            CreateOriginEndpointErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateOriginEndpointErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            CreateOriginEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteChannelError {
    pub kind: DeleteChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteChannelErrorKind {
    ForbiddenError(crate::error::ForbiddenError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteChannelErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteChannelError {
    fn code(&self) -> Option<&str> {
        DeleteChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteChannelError {
    pub fn new(kind: DeleteChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, DeleteChannelErrorKind::ForbiddenError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, DeleteChannelErrorKind::NotFoundError(_))
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelErrorKind::ServiceUnavailableError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, DeleteChannelErrorKind::TooManyRequestsError(_))
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for DeleteChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteChannelErrorKind::ForbiddenError(_inner) => Some(_inner),
            DeleteChannelErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            DeleteChannelErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteChannelErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            DeleteChannelErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteChannelErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            DeleteChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteOriginEndpointError {
    pub kind: DeleteOriginEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteOriginEndpointErrorKind {
    ForbiddenError(crate::error::ForbiddenError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteOriginEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteOriginEndpointErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            DeleteOriginEndpointErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            DeleteOriginEndpointErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteOriginEndpointErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            DeleteOriginEndpointErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteOriginEndpointErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            DeleteOriginEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteOriginEndpointError {
    fn code(&self) -> Option<&str> {
        DeleteOriginEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteOriginEndpointError {
    pub fn new(kind: DeleteOriginEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteOriginEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteOriginEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, DeleteOriginEndpointErrorKind::ForbiddenError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOriginEndpointErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, DeleteOriginEndpointErrorKind::NotFoundError(_))
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOriginEndpointErrorKind::ServiceUnavailableError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOriginEndpointErrorKind::TooManyRequestsError(_)
        )
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOriginEndpointErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for DeleteOriginEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteOriginEndpointErrorKind::ForbiddenError(_inner) => Some(_inner),
            DeleteOriginEndpointErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            DeleteOriginEndpointErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteOriginEndpointErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            DeleteOriginEndpointErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteOriginEndpointErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            DeleteOriginEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeChannelError {
    pub kind: DescribeChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeChannelErrorKind {
    ForbiddenError(crate::error::ForbiddenError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeChannelErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeChannelError {
    fn code(&self) -> Option<&str> {
        DescribeChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeChannelError {
    pub fn new(kind: DescribeChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, DescribeChannelErrorKind::ForbiddenError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, DescribeChannelErrorKind::NotFoundError(_))
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelErrorKind::ServiceUnavailableError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelErrorKind::TooManyRequestsError(_)
        )
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for DescribeChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeChannelErrorKind::ForbiddenError(_inner) => Some(_inner),
            DescribeChannelErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            DescribeChannelErrorKind::NotFoundError(_inner) => Some(_inner),
            DescribeChannelErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            DescribeChannelErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DescribeChannelErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            DescribeChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeHarvestJobError {
    pub kind: DescribeHarvestJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeHarvestJobErrorKind {
    ForbiddenError(crate::error::ForbiddenError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeHarvestJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeHarvestJobErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            DescribeHarvestJobErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            DescribeHarvestJobErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DescribeHarvestJobErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            DescribeHarvestJobErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DescribeHarvestJobErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            DescribeHarvestJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeHarvestJobError {
    fn code(&self) -> Option<&str> {
        DescribeHarvestJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeHarvestJobError {
    pub fn new(kind: DescribeHarvestJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeHarvestJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeHarvestJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, DescribeHarvestJobErrorKind::ForbiddenError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeHarvestJobErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, DescribeHarvestJobErrorKind::NotFoundError(_))
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeHarvestJobErrorKind::ServiceUnavailableError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeHarvestJobErrorKind::TooManyRequestsError(_)
        )
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeHarvestJobErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for DescribeHarvestJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeHarvestJobErrorKind::ForbiddenError(_inner) => Some(_inner),
            DescribeHarvestJobErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            DescribeHarvestJobErrorKind::NotFoundError(_inner) => Some(_inner),
            DescribeHarvestJobErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            DescribeHarvestJobErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DescribeHarvestJobErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            DescribeHarvestJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeOriginEndpointError {
    pub kind: DescribeOriginEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeOriginEndpointErrorKind {
    ForbiddenError(crate::error::ForbiddenError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeOriginEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeOriginEndpointErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            DescribeOriginEndpointErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            DescribeOriginEndpointErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DescribeOriginEndpointErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            DescribeOriginEndpointErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DescribeOriginEndpointErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            DescribeOriginEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeOriginEndpointError {
    fn code(&self) -> Option<&str> {
        DescribeOriginEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeOriginEndpointError {
    pub fn new(kind: DescribeOriginEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeOriginEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeOriginEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOriginEndpointErrorKind::ForbiddenError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOriginEndpointErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOriginEndpointErrorKind::NotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOriginEndpointErrorKind::ServiceUnavailableError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOriginEndpointErrorKind::TooManyRequestsError(_)
        )
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeOriginEndpointErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for DescribeOriginEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeOriginEndpointErrorKind::ForbiddenError(_inner) => Some(_inner),
            DescribeOriginEndpointErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            DescribeOriginEndpointErrorKind::NotFoundError(_inner) => Some(_inner),
            DescribeOriginEndpointErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            DescribeOriginEndpointErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DescribeOriginEndpointErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            DescribeOriginEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListChannelsError {
    pub kind: ListChannelsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListChannelsErrorKind {
    ForbiddenError(crate::error::ForbiddenError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListChannelsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListChannelsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListChannelsError {
    fn code(&self) -> Option<&str> {
        ListChannelsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListChannelsError {
    pub fn new(kind: ListChannelsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListChannelsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListChannelsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, ListChannelsErrorKind::ForbiddenError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, ListChannelsErrorKind::NotFoundError(_))
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsErrorKind::ServiceUnavailableError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, ListChannelsErrorKind::TooManyRequestsError(_))
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for ListChannelsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListChannelsErrorKind::ForbiddenError(_inner) => Some(_inner),
            ListChannelsErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            ListChannelsErrorKind::NotFoundError(_inner) => Some(_inner),
            ListChannelsErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            ListChannelsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListChannelsErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            ListChannelsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListHarvestJobsError {
    pub kind: ListHarvestJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListHarvestJobsErrorKind {
    ForbiddenError(crate::error::ForbiddenError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListHarvestJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListHarvestJobsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            ListHarvestJobsErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            ListHarvestJobsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            ListHarvestJobsErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            ListHarvestJobsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListHarvestJobsErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            ListHarvestJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListHarvestJobsError {
    fn code(&self) -> Option<&str> {
        ListHarvestJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListHarvestJobsError {
    pub fn new(kind: ListHarvestJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListHarvestJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListHarvestJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, ListHarvestJobsErrorKind::ForbiddenError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            ListHarvestJobsErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, ListHarvestJobsErrorKind::NotFoundError(_))
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            ListHarvestJobsErrorKind::ServiceUnavailableError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            ListHarvestJobsErrorKind::TooManyRequestsError(_)
        )
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            ListHarvestJobsErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for ListHarvestJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListHarvestJobsErrorKind::ForbiddenError(_inner) => Some(_inner),
            ListHarvestJobsErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            ListHarvestJobsErrorKind::NotFoundError(_inner) => Some(_inner),
            ListHarvestJobsErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            ListHarvestJobsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListHarvestJobsErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            ListHarvestJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListOriginEndpointsError {
    pub kind: ListOriginEndpointsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListOriginEndpointsErrorKind {
    ForbiddenError(crate::error::ForbiddenError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListOriginEndpointsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListOriginEndpointsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            ListOriginEndpointsErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            ListOriginEndpointsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            ListOriginEndpointsErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            ListOriginEndpointsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListOriginEndpointsErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            ListOriginEndpointsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListOriginEndpointsError {
    fn code(&self) -> Option<&str> {
        ListOriginEndpointsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListOriginEndpointsError {
    pub fn new(kind: ListOriginEndpointsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListOriginEndpointsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListOriginEndpointsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, ListOriginEndpointsErrorKind::ForbiddenError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            ListOriginEndpointsErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, ListOriginEndpointsErrorKind::NotFoundError(_))
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            ListOriginEndpointsErrorKind::ServiceUnavailableError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            ListOriginEndpointsErrorKind::TooManyRequestsError(_)
        )
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            ListOriginEndpointsErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for ListOriginEndpointsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListOriginEndpointsErrorKind::ForbiddenError(_inner) => Some(_inner),
            ListOriginEndpointsErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            ListOriginEndpointsErrorKind::NotFoundError(_inner) => Some(_inner),
            ListOriginEndpointsErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            ListOriginEndpointsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListOriginEndpointsErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            ListOriginEndpointsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RotateChannelCredentialsError {
    pub kind: RotateChannelCredentialsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RotateChannelCredentialsErrorKind {
    ForbiddenError(crate::error::ForbiddenError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RotateChannelCredentialsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RotateChannelCredentialsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            RotateChannelCredentialsErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            RotateChannelCredentialsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            RotateChannelCredentialsErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            RotateChannelCredentialsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            RotateChannelCredentialsErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            RotateChannelCredentialsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RotateChannelCredentialsError {
    fn code(&self) -> Option<&str> {
        RotateChannelCredentialsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RotateChannelCredentialsError {
    pub fn new(kind: RotateChannelCredentialsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RotateChannelCredentialsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RotateChannelCredentialsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(
            &self.kind,
            RotateChannelCredentialsErrorKind::ForbiddenError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            RotateChannelCredentialsErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            RotateChannelCredentialsErrorKind::NotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            RotateChannelCredentialsErrorKind::ServiceUnavailableError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            RotateChannelCredentialsErrorKind::TooManyRequestsError(_)
        )
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            RotateChannelCredentialsErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for RotateChannelCredentialsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RotateChannelCredentialsErrorKind::ForbiddenError(_inner) => Some(_inner),
            RotateChannelCredentialsErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            RotateChannelCredentialsErrorKind::NotFoundError(_inner) => Some(_inner),
            RotateChannelCredentialsErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            RotateChannelCredentialsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            RotateChannelCredentialsErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            RotateChannelCredentialsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RotateIngestEndpointCredentialsError {
    pub kind: RotateIngestEndpointCredentialsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RotateIngestEndpointCredentialsErrorKind {
    ForbiddenError(crate::error::ForbiddenError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RotateIngestEndpointCredentialsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RotateIngestEndpointCredentialsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            RotateIngestEndpointCredentialsErrorKind::InternalServerErrorError(_inner) => {
                _inner.fmt(f)
            }
            RotateIngestEndpointCredentialsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            RotateIngestEndpointCredentialsErrorKind::ServiceUnavailableError(_inner) => {
                _inner.fmt(f)
            }
            RotateIngestEndpointCredentialsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            RotateIngestEndpointCredentialsErrorKind::UnprocessableEntityError(_inner) => {
                _inner.fmt(f)
            }
            RotateIngestEndpointCredentialsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RotateIngestEndpointCredentialsError {
    fn code(&self) -> Option<&str> {
        RotateIngestEndpointCredentialsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RotateIngestEndpointCredentialsError {
    pub fn new(kind: RotateIngestEndpointCredentialsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RotateIngestEndpointCredentialsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RotateIngestEndpointCredentialsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(
            &self.kind,
            RotateIngestEndpointCredentialsErrorKind::ForbiddenError(_)
        )
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            RotateIngestEndpointCredentialsErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            RotateIngestEndpointCredentialsErrorKind::NotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            RotateIngestEndpointCredentialsErrorKind::ServiceUnavailableError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            RotateIngestEndpointCredentialsErrorKind::TooManyRequestsError(_)
        )
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            RotateIngestEndpointCredentialsErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for RotateIngestEndpointCredentialsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RotateIngestEndpointCredentialsErrorKind::ForbiddenError(_inner) => Some(_inner),
            RotateIngestEndpointCredentialsErrorKind::InternalServerErrorError(_inner) => {
                Some(_inner)
            }
            RotateIngestEndpointCredentialsErrorKind::NotFoundError(_inner) => Some(_inner),
            RotateIngestEndpointCredentialsErrorKind::ServiceUnavailableError(_inner) => {
                Some(_inner)
            }
            RotateIngestEndpointCredentialsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            RotateIngestEndpointCredentialsErrorKind::UnprocessableEntityError(_inner) => {
                Some(_inner)
            }
            RotateIngestEndpointCredentialsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateChannelError {
    pub kind: UpdateChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateChannelErrorKind {
    ForbiddenError(crate::error::ForbiddenError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateChannelErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateChannelError {
    fn code(&self) -> Option<&str> {
        UpdateChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateChannelError {
    pub fn new(kind: UpdateChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, UpdateChannelErrorKind::ForbiddenError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, UpdateChannelErrorKind::NotFoundError(_))
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelErrorKind::ServiceUnavailableError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, UpdateChannelErrorKind::TooManyRequestsError(_))
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for UpdateChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateChannelErrorKind::ForbiddenError(_inner) => Some(_inner),
            UpdateChannelErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            UpdateChannelErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateChannelErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            UpdateChannelErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateChannelErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            UpdateChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateOriginEndpointError {
    pub kind: UpdateOriginEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateOriginEndpointErrorKind {
    ForbiddenError(crate::error::ForbiddenError),
    InternalServerErrorError(crate::error::InternalServerErrorError),
    NotFoundError(crate::error::NotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnprocessableEntityError(crate::error::UnprocessableEntityError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateOriginEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateOriginEndpointErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
            UpdateOriginEndpointErrorKind::InternalServerErrorError(_inner) => _inner.fmt(f),
            UpdateOriginEndpointErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateOriginEndpointErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            UpdateOriginEndpointErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateOriginEndpointErrorKind::UnprocessableEntityError(_inner) => _inner.fmt(f),
            UpdateOriginEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateOriginEndpointError {
    fn code(&self) -> Option<&str> {
        UpdateOriginEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateOriginEndpointError {
    pub fn new(kind: UpdateOriginEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateOriginEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateOriginEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_forbidden_error(&self) -> bool {
        matches!(&self.kind, UpdateOriginEndpointErrorKind::ForbiddenError(_))
    }
    pub fn is_internal_server_error_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateOriginEndpointErrorKind::InternalServerErrorError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, UpdateOriginEndpointErrorKind::NotFoundError(_))
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateOriginEndpointErrorKind::ServiceUnavailableError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateOriginEndpointErrorKind::TooManyRequestsError(_)
        )
    }
    pub fn is_unprocessable_entity_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateOriginEndpointErrorKind::UnprocessableEntityError(_)
        )
    }
}
impl std::error::Error for UpdateOriginEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateOriginEndpointErrorKind::ForbiddenError(_inner) => Some(_inner),
            UpdateOriginEndpointErrorKind::InternalServerErrorError(_inner) => Some(_inner),
            UpdateOriginEndpointErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateOriginEndpointErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            UpdateOriginEndpointErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateOriginEndpointErrorKind::UnprocessableEntityError(_inner) => Some(_inner),
            UpdateOriginEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// The parameters sent in the request are not valid.
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UnprocessableEntityError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnprocessableEntityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnprocessableEntityError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnprocessableEntityError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnprocessableEntityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnprocessableEntityError [UnprocessableEntityException]")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnprocessableEntityError {}
/// See [`UnprocessableEntityError`](crate::error::UnprocessableEntityError)
pub mod unprocessable_entity_error {
    /// A builder for [`UnprocessableEntityError`](crate::error::UnprocessableEntityError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnprocessableEntityError`](crate::error::UnprocessableEntityError)
        pub fn build(self) -> crate::error::UnprocessableEntityError {
            crate::error::UnprocessableEntityError {
                message: self.message,
            }
        }
    }
}
impl UnprocessableEntityError {
    /// Creates a new builder-style object to manufacture [`UnprocessableEntityError`](crate::error::UnprocessableEntityError)
    pub fn builder() -> crate::error::unprocessable_entity_error::Builder {
        crate::error::unprocessable_entity_error::Builder::default()
    }
}

/// The client has exceeded their resource or throttling limits.
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyRequestsError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TooManyRequestsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyRequestsError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TooManyRequestsError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyRequestsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyRequestsError [TooManyRequestsException]")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyRequestsError {}
/// See [`TooManyRequestsError`](crate::error::TooManyRequestsError)
pub mod too_many_requests_error {
    /// A builder for [`TooManyRequestsError`](crate::error::TooManyRequestsError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TooManyRequestsError`](crate::error::TooManyRequestsError)
        pub fn build(self) -> crate::error::TooManyRequestsError {
            crate::error::TooManyRequestsError {
                message: self.message,
            }
        }
    }
}
impl TooManyRequestsError {
    /// Creates a new builder-style object to manufacture [`TooManyRequestsError`](crate::error::TooManyRequestsError)
    pub fn builder() -> crate::error::too_many_requests_error::Builder {
        crate::error::too_many_requests_error::Builder::default()
    }
}

/// An unexpected error occurred.
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceUnavailableError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceUnavailableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceUnavailableError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceUnavailableError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceUnavailableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceUnavailableError [ServiceUnavailableException]")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceUnavailableError {}
/// See [`ServiceUnavailableError`](crate::error::ServiceUnavailableError)
pub mod service_unavailable_error {
    /// A builder for [`ServiceUnavailableError`](crate::error::ServiceUnavailableError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceUnavailableError`](crate::error::ServiceUnavailableError)
        pub fn build(self) -> crate::error::ServiceUnavailableError {
            crate::error::ServiceUnavailableError {
                message: self.message,
            }
        }
    }
}
impl ServiceUnavailableError {
    /// Creates a new builder-style object to manufacture [`ServiceUnavailableError`](crate::error::ServiceUnavailableError)
    pub fn builder() -> crate::error::service_unavailable_error::Builder {
        crate::error::service_unavailable_error::Builder::default()
    }
}

/// The requested resource does not exist.
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundError [NotFoundException]")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotFoundError {}
/// See [`NotFoundError`](crate::error::NotFoundError)
pub mod not_found_error {
    /// A builder for [`NotFoundError`](crate::error::NotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotFoundError`](crate::error::NotFoundError)
        pub fn build(self) -> crate::error::NotFoundError {
            crate::error::NotFoundError {
                message: self.message,
            }
        }
    }
}
impl NotFoundError {
    /// Creates a new builder-style object to manufacture [`NotFoundError`](crate::error::NotFoundError)
    pub fn builder() -> crate::error::not_found_error::Builder {
        crate::error::not_found_error::Builder::default()
    }
}

/// An unexpected error occurred.
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServerErrorError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServerErrorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServerErrorError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServerErrorError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerErrorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerErrorError [InternalServerErrorException]")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerErrorError {}
/// See [`InternalServerErrorError`](crate::error::InternalServerErrorError)
pub mod internal_server_error_error {
    /// A builder for [`InternalServerErrorError`](crate::error::InternalServerErrorError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerErrorError`](crate::error::InternalServerErrorError)
        pub fn build(self) -> crate::error::InternalServerErrorError {
            crate::error::InternalServerErrorError {
                message: self.message,
            }
        }
    }
}
impl InternalServerErrorError {
    /// Creates a new builder-style object to manufacture [`InternalServerErrorError`](crate::error::InternalServerErrorError)
    pub fn builder() -> crate::error::internal_server_error_error::Builder {
        crate::error::internal_server_error_error::Builder::default()
    }
}

/// The client is not authorized to access the requested resource.
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ForbiddenError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ForbiddenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ForbiddenError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ForbiddenError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ForbiddenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ForbiddenError [ForbiddenException]")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for ForbiddenError {}
/// See [`ForbiddenError`](crate::error::ForbiddenError)
pub mod forbidden_error {
    /// A builder for [`ForbiddenError`](crate::error::ForbiddenError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ForbiddenError`](crate::error::ForbiddenError)
        pub fn build(self) -> crate::error::ForbiddenError {
            crate::error::ForbiddenError {
                message: self.message,
            }
        }
    }
}
impl ForbiddenError {
    /// Creates a new builder-style object to manufacture [`ForbiddenError`](crate::error::ForbiddenError)
    pub fn builder() -> crate::error::forbidden_error::Builder {
        crate::error::forbidden_error::Builder::default()
    }
}
