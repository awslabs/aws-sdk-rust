// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `UpdatePermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdatePermissionSetError {
    /// Kind of error that occurred.
                    pub kind: UpdatePermissionSetErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UpdatePermissionSetError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdatePermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UpdatePermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePermissionSetErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdatePermissionSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdatePermissionSetErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePermissionSetErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePermissionSetErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePermissionSetErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePermissionSetErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePermissionSetErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdatePermissionSetError {
    fn code(&self) -> Option<&str> {
        UpdatePermissionSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePermissionSetError {
    /// Creates a new `UpdatePermissionSetError`.
                    pub fn new(kind: UpdatePermissionSetErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UpdatePermissionSetError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UpdatePermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UpdatePermissionSetError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UpdatePermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UpdatePermissionSetErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UpdatePermissionSetErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UpdatePermissionSetErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdatePermissionSetErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `UpdatePermissionSetErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, UpdatePermissionSetErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `UpdatePermissionSetErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdatePermissionSetErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdatePermissionSetErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdatePermissionSetErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `UpdatePermissionSetErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdatePermissionSetErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdatePermissionSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdatePermissionSetErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            UpdatePermissionSetErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            UpdatePermissionSetErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            UpdatePermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            UpdatePermissionSetErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            UpdatePermissionSetErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            UpdatePermissionSetErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>The request failed because it contains a syntax error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ValidationException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ValidationException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ValidationException")?;
        if let Some(inner_1) = &self.message {
             {
                write!(f, ": {}", inner_1)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ValidationException {}
/// See [`ValidationException`](crate::error::ValidationException).
pub mod validation_exception {
    
    /// A builder for [`ValidationException`](crate::error::ValidationException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ValidationException`](crate::error::ValidationException).
        pub fn build(self) -> crate::error::ValidationException {
            crate::error::ValidationException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ValidationException {
    /// Creates a new builder-style object to manufacture [`ValidationException`](crate::error::ValidationException).
    pub fn builder() -> crate::error::validation_exception::Builder {
        crate::error::validation_exception::Builder::default()
    }
}

/// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ThrottlingException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ThrottlingException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottlingException")?;
        if let Some(inner_2) = &self.message {
             {
                write!(f, ": {}", inner_2)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ThrottlingException {}
/// See [`ThrottlingException`](crate::error::ThrottlingException).
pub mod throttling_exception {
    
    /// A builder for [`ThrottlingException`](crate::error::ThrottlingException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ThrottlingException`](crate::error::ThrottlingException).
        pub fn build(self) -> crate::error::ThrottlingException {
            crate::error::ThrottlingException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ThrottlingException {
    /// Creates a new builder-style object to manufacture [`ThrottlingException`](crate::error::ThrottlingException).
    pub fn builder() -> crate::error::throttling_exception::Builder {
        crate::error::throttling_exception::Builder::default()
    }
}

/// <p>Indicates that a requested resource is not found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceNotFoundException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ResourceNotFoundException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_3) = &self.message {
             {
                write!(f, ": {}", inner_3)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
pub mod resource_not_found_exception {
    
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InternalServerException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl InternalServerException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for InternalServerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerException")?;
        if let Some(inner_4) = &self.message {
             {
                write!(f, ": {}", inner_4)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerException {}
/// See [`InternalServerException`](crate::error::InternalServerException).
pub mod internal_server_exception {
    
    /// A builder for [`InternalServerException`](crate::error::InternalServerException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`InternalServerException`](crate::error::InternalServerException).
        pub fn build(self) -> crate::error::InternalServerException {
            crate::error::InternalServerException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl InternalServerException {
    /// Creates a new builder-style object to manufacture [`InternalServerException`](crate::error::InternalServerException).
    pub fn builder() -> crate::error::internal_server_exception::Builder {
        crate::error::internal_server_exception::Builder::default()
    }
}

/// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConflictException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ConflictException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_5) = &self.message {
             {
                write!(f, ": {}", inner_5)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException).
pub mod conflict_exception {
    
    /// A builder for [`ConflictException`](crate::error::ConflictException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException).
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException).
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// <p>You do not have sufficient access to perform this action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccessDeniedException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl AccessDeniedException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_6) = &self.message {
             {
                write!(f, ": {}", inner_6)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException).
pub mod access_denied_exception {
    
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException).
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException).
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}

/// Error type for the `UpdateInstanceAccessControlAttributeConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateInstanceAccessControlAttributeConfigurationError {
    /// Kind of error that occurred.
                    pub kind: UpdateInstanceAccessControlAttributeConfigurationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateInstanceAccessControlAttributeConfigurationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateInstanceAccessControlAttributeConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UpdateInstanceAccessControlAttributeConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateInstanceAccessControlAttributeConfigurationErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateInstanceAccessControlAttributeConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateInstanceAccessControlAttributeConfigurationErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateInstanceAccessControlAttributeConfigurationErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateInstanceAccessControlAttributeConfigurationErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateInstanceAccessControlAttributeConfigurationErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateInstanceAccessControlAttributeConfigurationErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateInstanceAccessControlAttributeConfigurationErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateInstanceAccessControlAttributeConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateInstanceAccessControlAttributeConfigurationError {
    fn code(&self) -> Option<&str> {
        UpdateInstanceAccessControlAttributeConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateInstanceAccessControlAttributeConfigurationError {
    /// Creates a new `UpdateInstanceAccessControlAttributeConfigurationError`.
                    pub fn new(kind: UpdateInstanceAccessControlAttributeConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UpdateInstanceAccessControlAttributeConfigurationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UpdateInstanceAccessControlAttributeConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UpdateInstanceAccessControlAttributeConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UpdateInstanceAccessControlAttributeConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UpdateInstanceAccessControlAttributeConfigurationErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UpdateInstanceAccessControlAttributeConfigurationErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UpdateInstanceAccessControlAttributeConfigurationErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateInstanceAccessControlAttributeConfigurationErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `UpdateInstanceAccessControlAttributeConfigurationErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, UpdateInstanceAccessControlAttributeConfigurationErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `UpdateInstanceAccessControlAttributeConfigurationErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateInstanceAccessControlAttributeConfigurationErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateInstanceAccessControlAttributeConfigurationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateInstanceAccessControlAttributeConfigurationErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `UpdateInstanceAccessControlAttributeConfigurationErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateInstanceAccessControlAttributeConfigurationErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateInstanceAccessControlAttributeConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateInstanceAccessControlAttributeConfigurationErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            UpdateInstanceAccessControlAttributeConfigurationErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            UpdateInstanceAccessControlAttributeConfigurationErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            UpdateInstanceAccessControlAttributeConfigurationErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            UpdateInstanceAccessControlAttributeConfigurationErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            UpdateInstanceAccessControlAttributeConfigurationErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            UpdateInstanceAccessControlAttributeConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `UntagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    /// Kind of error that occurred.
                    pub kind: UntagResourceErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UntagResourceError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UntagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            UntagResourceErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            UntagResourceErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            UntagResourceErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UntagResourceErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            UntagResourceErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            UntagResourceErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    /// Creates a new `UntagResourceError`.
                    pub fn new(kind: UntagResourceErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UntagResourceError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UntagResourceErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UntagResourceError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UntagResourceErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            UntagResourceErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            UntagResourceErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            UntagResourceErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            UntagResourceErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            UntagResourceErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            UntagResourceErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `TagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    /// Kind of error that occurred.
                    pub kind: TagResourceErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for TagResourceError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `TagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the permitted number of resources that can be created.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            TagResourceErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            TagResourceErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            TagResourceErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            TagResourceErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            TagResourceErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            TagResourceErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            TagResourceErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    /// Creates a new `TagResourceError`.
                    pub fn new(kind: TagResourceErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `TagResourceError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: TagResourceErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `TagResourceError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: TagResourceErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ValidationException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            TagResourceErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            TagResourceErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            TagResourceErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            TagResourceErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            TagResourceErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            TagResourceErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            TagResourceErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>Indicates that the principal has crossed the permitted number of resources that can be created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceQuotaExceededException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ServiceQuotaExceededException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ServiceQuotaExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceQuotaExceededException")?;
        if let Some(inner_7) = &self.message {
             {
                write!(f, ": {}", inner_7)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ServiceQuotaExceededException {}
/// See [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException).
pub mod service_quota_exceeded_exception {
    
    /// A builder for [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException).
        pub fn build(self) -> crate::error::ServiceQuotaExceededException {
            crate::error::ServiceQuotaExceededException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ServiceQuotaExceededException {
    /// Creates a new builder-style object to manufacture [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException).
    pub fn builder() -> crate::error::service_quota_exceeded_exception::Builder {
        crate::error::service_quota_exceeded_exception::Builder::default()
    }
}

/// Error type for the `PutPermissionsBoundaryToPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutPermissionsBoundaryToPermissionSetError {
    /// Kind of error that occurred.
                    pub kind: PutPermissionsBoundaryToPermissionSetErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for PutPermissionsBoundaryToPermissionSetError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: PutPermissionsBoundaryToPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `PutPermissionsBoundaryToPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutPermissionsBoundaryToPermissionSetErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for PutPermissionsBoundaryToPermissionSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutPermissionsBoundaryToPermissionSetErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            PutPermissionsBoundaryToPermissionSetErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            PutPermissionsBoundaryToPermissionSetErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            PutPermissionsBoundaryToPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            PutPermissionsBoundaryToPermissionSetErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            PutPermissionsBoundaryToPermissionSetErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            PutPermissionsBoundaryToPermissionSetErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutPermissionsBoundaryToPermissionSetError {
    fn code(&self) -> Option<&str> {
        PutPermissionsBoundaryToPermissionSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutPermissionsBoundaryToPermissionSetError {
    /// Creates a new `PutPermissionsBoundaryToPermissionSetError`.
                    pub fn new(kind: PutPermissionsBoundaryToPermissionSetErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `PutPermissionsBoundaryToPermissionSetError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: PutPermissionsBoundaryToPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `PutPermissionsBoundaryToPermissionSetError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: PutPermissionsBoundaryToPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `PutPermissionsBoundaryToPermissionSetErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, PutPermissionsBoundaryToPermissionSetErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `PutPermissionsBoundaryToPermissionSetErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, PutPermissionsBoundaryToPermissionSetErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `PutPermissionsBoundaryToPermissionSetErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, PutPermissionsBoundaryToPermissionSetErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `PutPermissionsBoundaryToPermissionSetErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, PutPermissionsBoundaryToPermissionSetErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `PutPermissionsBoundaryToPermissionSetErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, PutPermissionsBoundaryToPermissionSetErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `PutPermissionsBoundaryToPermissionSetErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, PutPermissionsBoundaryToPermissionSetErrorKind::ValidationException(_))
    }
}
impl std::error::Error for PutPermissionsBoundaryToPermissionSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutPermissionsBoundaryToPermissionSetErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            PutPermissionsBoundaryToPermissionSetErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            PutPermissionsBoundaryToPermissionSetErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            PutPermissionsBoundaryToPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            PutPermissionsBoundaryToPermissionSetErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            PutPermissionsBoundaryToPermissionSetErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            PutPermissionsBoundaryToPermissionSetErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `PutInlinePolicyToPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutInlinePolicyToPermissionSetError {
    /// Kind of error that occurred.
                    pub kind: PutInlinePolicyToPermissionSetErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for PutInlinePolicyToPermissionSetError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: PutInlinePolicyToPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `PutInlinePolicyToPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutInlinePolicyToPermissionSetErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the permitted number of resources that can be created.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for PutInlinePolicyToPermissionSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutInlinePolicyToPermissionSetErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            PutInlinePolicyToPermissionSetErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            PutInlinePolicyToPermissionSetErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            PutInlinePolicyToPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            PutInlinePolicyToPermissionSetErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            PutInlinePolicyToPermissionSetErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            PutInlinePolicyToPermissionSetErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            PutInlinePolicyToPermissionSetErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutInlinePolicyToPermissionSetError {
    fn code(&self) -> Option<&str> {
        PutInlinePolicyToPermissionSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutInlinePolicyToPermissionSetError {
    /// Creates a new `PutInlinePolicyToPermissionSetError`.
                    pub fn new(kind: PutInlinePolicyToPermissionSetErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `PutInlinePolicyToPermissionSetError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: PutInlinePolicyToPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `PutInlinePolicyToPermissionSetError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: PutInlinePolicyToPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `PutInlinePolicyToPermissionSetErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, PutInlinePolicyToPermissionSetErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `PutInlinePolicyToPermissionSetErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, PutInlinePolicyToPermissionSetErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `PutInlinePolicyToPermissionSetErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, PutInlinePolicyToPermissionSetErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `PutInlinePolicyToPermissionSetErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, PutInlinePolicyToPermissionSetErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `PutInlinePolicyToPermissionSetErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, PutInlinePolicyToPermissionSetErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `PutInlinePolicyToPermissionSetErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, PutInlinePolicyToPermissionSetErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `PutInlinePolicyToPermissionSetErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, PutInlinePolicyToPermissionSetErrorKind::ValidationException(_))
    }
}
impl std::error::Error for PutInlinePolicyToPermissionSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutInlinePolicyToPermissionSetErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            PutInlinePolicyToPermissionSetErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            PutInlinePolicyToPermissionSetErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            PutInlinePolicyToPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            PutInlinePolicyToPermissionSetErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            PutInlinePolicyToPermissionSetErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            PutInlinePolicyToPermissionSetErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            PutInlinePolicyToPermissionSetErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ProvisionPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ProvisionPermissionSetError {
    /// Kind of error that occurred.
                    pub kind: ProvisionPermissionSetErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ProvisionPermissionSetError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ProvisionPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ProvisionPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ProvisionPermissionSetErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ProvisionPermissionSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ProvisionPermissionSetErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ProvisionPermissionSetErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            ProvisionPermissionSetErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ProvisionPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ProvisionPermissionSetErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ProvisionPermissionSetErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ProvisionPermissionSetErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ProvisionPermissionSetError {
    fn code(&self) -> Option<&str> {
        ProvisionPermissionSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ProvisionPermissionSetError {
    /// Creates a new `ProvisionPermissionSetError`.
                    pub fn new(kind: ProvisionPermissionSetErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ProvisionPermissionSetError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ProvisionPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ProvisionPermissionSetError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ProvisionPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ProvisionPermissionSetErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ProvisionPermissionSetErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ProvisionPermissionSetErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, ProvisionPermissionSetErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `ProvisionPermissionSetErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ProvisionPermissionSetErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ProvisionPermissionSetErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ProvisionPermissionSetErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ProvisionPermissionSetErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ProvisionPermissionSetErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ProvisionPermissionSetErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ProvisionPermissionSetErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ProvisionPermissionSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ProvisionPermissionSetErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ProvisionPermissionSetErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            ProvisionPermissionSetErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ProvisionPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            ProvisionPermissionSetErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ProvisionPermissionSetErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ProvisionPermissionSetErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListTagsForResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    /// Kind of error that occurred.
                    pub kind: ListTagsForResourceErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListTagsForResourceError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListTagsForResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListTagsForResourceErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListTagsForResourceErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListTagsForResourceErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListTagsForResourceErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    /// Creates a new `ListTagsForResourceError`.
                    pub fn new(kind: ListTagsForResourceErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListTagsForResourceError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListTagsForResourceErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListTagsForResourceError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListTagsForResourceErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListTagsForResourceErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListTagsForResourceErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListTagsForResourceErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListTagsForResourceErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListTagsForResourceErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListTagsForResourceErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListTagsForResourceErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListTagsForResourceErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListTagsForResourceErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListPermissionSetsProvisionedToAccount` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPermissionSetsProvisionedToAccountError {
    /// Kind of error that occurred.
                    pub kind: ListPermissionSetsProvisionedToAccountErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListPermissionSetsProvisionedToAccountError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListPermissionSetsProvisionedToAccountErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListPermissionSetsProvisionedToAccount` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPermissionSetsProvisionedToAccountErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListPermissionSetsProvisionedToAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPermissionSetsProvisionedToAccountErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListPermissionSetsProvisionedToAccountErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListPermissionSetsProvisionedToAccountErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListPermissionSetsProvisionedToAccountErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListPermissionSetsProvisionedToAccountErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListPermissionSetsProvisionedToAccountErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListPermissionSetsProvisionedToAccountError {
    fn code(&self) -> Option<&str> {
        ListPermissionSetsProvisionedToAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPermissionSetsProvisionedToAccountError {
    /// Creates a new `ListPermissionSetsProvisionedToAccountError`.
                    pub fn new(kind: ListPermissionSetsProvisionedToAccountErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListPermissionSetsProvisionedToAccountError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListPermissionSetsProvisionedToAccountErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListPermissionSetsProvisionedToAccountError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListPermissionSetsProvisionedToAccountErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListPermissionSetsProvisionedToAccountErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListPermissionSetsProvisionedToAccountErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListPermissionSetsProvisionedToAccountErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListPermissionSetsProvisionedToAccountErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListPermissionSetsProvisionedToAccountErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListPermissionSetsProvisionedToAccountErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListPermissionSetsProvisionedToAccountErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListPermissionSetsProvisionedToAccountErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListPermissionSetsProvisionedToAccountErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListPermissionSetsProvisionedToAccountErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListPermissionSetsProvisionedToAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPermissionSetsProvisionedToAccountErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListPermissionSetsProvisionedToAccountErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListPermissionSetsProvisionedToAccountErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListPermissionSetsProvisionedToAccountErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListPermissionSetsProvisionedToAccountErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListPermissionSetsProvisionedToAccountErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListPermissionSets` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPermissionSetsError {
    /// Kind of error that occurred.
                    pub kind: ListPermissionSetsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListPermissionSetsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListPermissionSetsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListPermissionSets` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPermissionSetsErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListPermissionSetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPermissionSetsErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListPermissionSetsErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListPermissionSetsErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListPermissionSetsErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListPermissionSetsErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListPermissionSetsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListPermissionSetsError {
    fn code(&self) -> Option<&str> {
        ListPermissionSetsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPermissionSetsError {
    /// Creates a new `ListPermissionSetsError`.
                    pub fn new(kind: ListPermissionSetsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListPermissionSetsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListPermissionSetsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListPermissionSetsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListPermissionSetsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListPermissionSetsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListPermissionSetsErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListPermissionSetsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListPermissionSetsErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListPermissionSetsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListPermissionSetsErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListPermissionSetsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListPermissionSetsErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListPermissionSetsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListPermissionSetsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListPermissionSetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPermissionSetsErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListPermissionSetsErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListPermissionSetsErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListPermissionSetsErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListPermissionSetsErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListPermissionSetsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListPermissionSetProvisioningStatus` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPermissionSetProvisioningStatusError {
    /// Kind of error that occurred.
                    pub kind: ListPermissionSetProvisioningStatusErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListPermissionSetProvisioningStatusError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListPermissionSetProvisioningStatusErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListPermissionSetProvisioningStatus` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPermissionSetProvisioningStatusErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListPermissionSetProvisioningStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPermissionSetProvisioningStatusErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListPermissionSetProvisioningStatusErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListPermissionSetProvisioningStatusErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListPermissionSetProvisioningStatusErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListPermissionSetProvisioningStatusErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListPermissionSetProvisioningStatusErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListPermissionSetProvisioningStatusError {
    fn code(&self) -> Option<&str> {
        ListPermissionSetProvisioningStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPermissionSetProvisioningStatusError {
    /// Creates a new `ListPermissionSetProvisioningStatusError`.
                    pub fn new(kind: ListPermissionSetProvisioningStatusErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListPermissionSetProvisioningStatusError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListPermissionSetProvisioningStatusErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListPermissionSetProvisioningStatusError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListPermissionSetProvisioningStatusErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListPermissionSetProvisioningStatusErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListPermissionSetProvisioningStatusErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListPermissionSetProvisioningStatusErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListPermissionSetProvisioningStatusErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListPermissionSetProvisioningStatusErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListPermissionSetProvisioningStatusErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListPermissionSetProvisioningStatusErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListPermissionSetProvisioningStatusErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListPermissionSetProvisioningStatusErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListPermissionSetProvisioningStatusErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListPermissionSetProvisioningStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPermissionSetProvisioningStatusErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListPermissionSetProvisioningStatusErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListPermissionSetProvisioningStatusErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListPermissionSetProvisioningStatusErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListPermissionSetProvisioningStatusErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListPermissionSetProvisioningStatusErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListManagedPoliciesInPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListManagedPoliciesInPermissionSetError {
    /// Kind of error that occurred.
                    pub kind: ListManagedPoliciesInPermissionSetErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListManagedPoliciesInPermissionSetError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListManagedPoliciesInPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListManagedPoliciesInPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListManagedPoliciesInPermissionSetErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListManagedPoliciesInPermissionSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListManagedPoliciesInPermissionSetErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListManagedPoliciesInPermissionSetErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListManagedPoliciesInPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListManagedPoliciesInPermissionSetErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListManagedPoliciesInPermissionSetErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListManagedPoliciesInPermissionSetErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListManagedPoliciesInPermissionSetError {
    fn code(&self) -> Option<&str> {
        ListManagedPoliciesInPermissionSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListManagedPoliciesInPermissionSetError {
    /// Creates a new `ListManagedPoliciesInPermissionSetError`.
                    pub fn new(kind: ListManagedPoliciesInPermissionSetErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListManagedPoliciesInPermissionSetError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListManagedPoliciesInPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListManagedPoliciesInPermissionSetError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListManagedPoliciesInPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListManagedPoliciesInPermissionSetErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListManagedPoliciesInPermissionSetErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListManagedPoliciesInPermissionSetErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListManagedPoliciesInPermissionSetErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListManagedPoliciesInPermissionSetErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListManagedPoliciesInPermissionSetErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListManagedPoliciesInPermissionSetErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListManagedPoliciesInPermissionSetErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListManagedPoliciesInPermissionSetErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListManagedPoliciesInPermissionSetErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListManagedPoliciesInPermissionSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListManagedPoliciesInPermissionSetErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListManagedPoliciesInPermissionSetErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListManagedPoliciesInPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListManagedPoliciesInPermissionSetErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListManagedPoliciesInPermissionSetErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListManagedPoliciesInPermissionSetErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListInstances` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListInstancesError {
    /// Kind of error that occurred.
                    pub kind: ListInstancesErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListInstancesError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListInstancesErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListInstances` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListInstancesErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListInstancesErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListInstancesErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListInstancesErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListInstancesErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListInstancesErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListInstancesError {
    fn code(&self) -> Option<&str> {
        ListInstancesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListInstancesError {
    /// Creates a new `ListInstancesError`.
                    pub fn new(kind: ListInstancesErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListInstancesError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListInstancesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListInstancesError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListInstancesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListInstancesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListInstancesErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListInstancesErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListInstancesErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListInstancesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListInstancesErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListInstancesErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListInstancesErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListInstancesErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListInstancesErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListInstancesErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListInstancesErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListInstancesErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListCustomerManagedPolicyReferencesInPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCustomerManagedPolicyReferencesInPermissionSetError {
    /// Kind of error that occurred.
                    pub kind: ListCustomerManagedPolicyReferencesInPermissionSetErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListCustomerManagedPolicyReferencesInPermissionSetError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListCustomerManagedPolicyReferencesInPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListCustomerManagedPolicyReferencesInPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCustomerManagedPolicyReferencesInPermissionSetErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListCustomerManagedPolicyReferencesInPermissionSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCustomerManagedPolicyReferencesInPermissionSetErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListCustomerManagedPolicyReferencesInPermissionSetErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListCustomerManagedPolicyReferencesInPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListCustomerManagedPolicyReferencesInPermissionSetErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListCustomerManagedPolicyReferencesInPermissionSetErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListCustomerManagedPolicyReferencesInPermissionSetErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListCustomerManagedPolicyReferencesInPermissionSetError {
    fn code(&self) -> Option<&str> {
        ListCustomerManagedPolicyReferencesInPermissionSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCustomerManagedPolicyReferencesInPermissionSetError {
    /// Creates a new `ListCustomerManagedPolicyReferencesInPermissionSetError`.
                    pub fn new(kind: ListCustomerManagedPolicyReferencesInPermissionSetErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListCustomerManagedPolicyReferencesInPermissionSetError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListCustomerManagedPolicyReferencesInPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListCustomerManagedPolicyReferencesInPermissionSetError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListCustomerManagedPolicyReferencesInPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListCustomerManagedPolicyReferencesInPermissionSetErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListCustomerManagedPolicyReferencesInPermissionSetErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListCustomerManagedPolicyReferencesInPermissionSetErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListCustomerManagedPolicyReferencesInPermissionSetErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListCustomerManagedPolicyReferencesInPermissionSetErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListCustomerManagedPolicyReferencesInPermissionSetErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListCustomerManagedPolicyReferencesInPermissionSetErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListCustomerManagedPolicyReferencesInPermissionSetErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListCustomerManagedPolicyReferencesInPermissionSetErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListCustomerManagedPolicyReferencesInPermissionSetErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListCustomerManagedPolicyReferencesInPermissionSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCustomerManagedPolicyReferencesInPermissionSetErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListCustomerManagedPolicyReferencesInPermissionSetErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListCustomerManagedPolicyReferencesInPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListCustomerManagedPolicyReferencesInPermissionSetErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListCustomerManagedPolicyReferencesInPermissionSetErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListCustomerManagedPolicyReferencesInPermissionSetErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListAccountsForProvisionedPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAccountsForProvisionedPermissionSetError {
    /// Kind of error that occurred.
                    pub kind: ListAccountsForProvisionedPermissionSetErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListAccountsForProvisionedPermissionSetError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListAccountsForProvisionedPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListAccountsForProvisionedPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAccountsForProvisionedPermissionSetErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListAccountsForProvisionedPermissionSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAccountsForProvisionedPermissionSetErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListAccountsForProvisionedPermissionSetErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListAccountsForProvisionedPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListAccountsForProvisionedPermissionSetErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListAccountsForProvisionedPermissionSetErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListAccountsForProvisionedPermissionSetErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListAccountsForProvisionedPermissionSetError {
    fn code(&self) -> Option<&str> {
        ListAccountsForProvisionedPermissionSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAccountsForProvisionedPermissionSetError {
    /// Creates a new `ListAccountsForProvisionedPermissionSetError`.
                    pub fn new(kind: ListAccountsForProvisionedPermissionSetErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListAccountsForProvisionedPermissionSetError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListAccountsForProvisionedPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListAccountsForProvisionedPermissionSetError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListAccountsForProvisionedPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListAccountsForProvisionedPermissionSetErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListAccountsForProvisionedPermissionSetErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListAccountsForProvisionedPermissionSetErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListAccountsForProvisionedPermissionSetErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListAccountsForProvisionedPermissionSetErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListAccountsForProvisionedPermissionSetErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListAccountsForProvisionedPermissionSetErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListAccountsForProvisionedPermissionSetErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListAccountsForProvisionedPermissionSetErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListAccountsForProvisionedPermissionSetErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListAccountsForProvisionedPermissionSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAccountsForProvisionedPermissionSetErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListAccountsForProvisionedPermissionSetErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListAccountsForProvisionedPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListAccountsForProvisionedPermissionSetErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListAccountsForProvisionedPermissionSetErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListAccountsForProvisionedPermissionSetErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListAccountAssignments` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAccountAssignmentsError {
    /// Kind of error that occurred.
                    pub kind: ListAccountAssignmentsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListAccountAssignmentsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListAccountAssignmentsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListAccountAssignments` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAccountAssignmentsErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListAccountAssignmentsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAccountAssignmentsErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListAccountAssignmentsErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListAccountAssignmentsErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListAccountAssignmentsErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListAccountAssignmentsErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListAccountAssignmentsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListAccountAssignmentsError {
    fn code(&self) -> Option<&str> {
        ListAccountAssignmentsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAccountAssignmentsError {
    /// Creates a new `ListAccountAssignmentsError`.
                    pub fn new(kind: ListAccountAssignmentsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListAccountAssignmentsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListAccountAssignmentsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListAccountAssignmentsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListAccountAssignmentsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListAccountAssignmentsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListAccountAssignmentsErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListAccountAssignmentsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListAccountAssignmentsErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListAccountAssignmentsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListAccountAssignmentsErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListAccountAssignmentsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListAccountAssignmentsErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListAccountAssignmentsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListAccountAssignmentsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListAccountAssignmentsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAccountAssignmentsErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListAccountAssignmentsErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListAccountAssignmentsErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListAccountAssignmentsErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListAccountAssignmentsErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListAccountAssignmentsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListAccountAssignmentDeletionStatus` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAccountAssignmentDeletionStatusError {
    /// Kind of error that occurred.
                    pub kind: ListAccountAssignmentDeletionStatusErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListAccountAssignmentDeletionStatusError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListAccountAssignmentDeletionStatusErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListAccountAssignmentDeletionStatus` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAccountAssignmentDeletionStatusErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListAccountAssignmentDeletionStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAccountAssignmentDeletionStatusErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListAccountAssignmentDeletionStatusErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListAccountAssignmentDeletionStatusErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListAccountAssignmentDeletionStatusErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListAccountAssignmentDeletionStatusErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListAccountAssignmentDeletionStatusErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListAccountAssignmentDeletionStatusError {
    fn code(&self) -> Option<&str> {
        ListAccountAssignmentDeletionStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAccountAssignmentDeletionStatusError {
    /// Creates a new `ListAccountAssignmentDeletionStatusError`.
                    pub fn new(kind: ListAccountAssignmentDeletionStatusErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListAccountAssignmentDeletionStatusError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListAccountAssignmentDeletionStatusErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListAccountAssignmentDeletionStatusError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListAccountAssignmentDeletionStatusErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListAccountAssignmentDeletionStatusErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListAccountAssignmentDeletionStatusErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListAccountAssignmentDeletionStatusErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListAccountAssignmentDeletionStatusErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListAccountAssignmentDeletionStatusErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListAccountAssignmentDeletionStatusErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListAccountAssignmentDeletionStatusErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListAccountAssignmentDeletionStatusErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListAccountAssignmentDeletionStatusErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListAccountAssignmentDeletionStatusErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListAccountAssignmentDeletionStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAccountAssignmentDeletionStatusErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListAccountAssignmentDeletionStatusErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListAccountAssignmentDeletionStatusErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListAccountAssignmentDeletionStatusErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListAccountAssignmentDeletionStatusErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListAccountAssignmentDeletionStatusErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListAccountAssignmentCreationStatus` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAccountAssignmentCreationStatusError {
    /// Kind of error that occurred.
                    pub kind: ListAccountAssignmentCreationStatusErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListAccountAssignmentCreationStatusError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListAccountAssignmentCreationStatusErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListAccountAssignmentCreationStatus` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAccountAssignmentCreationStatusErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListAccountAssignmentCreationStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAccountAssignmentCreationStatusErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListAccountAssignmentCreationStatusErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListAccountAssignmentCreationStatusErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListAccountAssignmentCreationStatusErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListAccountAssignmentCreationStatusErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListAccountAssignmentCreationStatusErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListAccountAssignmentCreationStatusError {
    fn code(&self) -> Option<&str> {
        ListAccountAssignmentCreationStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAccountAssignmentCreationStatusError {
    /// Creates a new `ListAccountAssignmentCreationStatusError`.
                    pub fn new(kind: ListAccountAssignmentCreationStatusErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListAccountAssignmentCreationStatusError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListAccountAssignmentCreationStatusErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListAccountAssignmentCreationStatusError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListAccountAssignmentCreationStatusErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListAccountAssignmentCreationStatusErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListAccountAssignmentCreationStatusErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListAccountAssignmentCreationStatusErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListAccountAssignmentCreationStatusErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListAccountAssignmentCreationStatusErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListAccountAssignmentCreationStatusErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListAccountAssignmentCreationStatusErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListAccountAssignmentCreationStatusErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListAccountAssignmentCreationStatusErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListAccountAssignmentCreationStatusErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListAccountAssignmentCreationStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAccountAssignmentCreationStatusErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListAccountAssignmentCreationStatusErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListAccountAssignmentCreationStatusErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListAccountAssignmentCreationStatusErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListAccountAssignmentCreationStatusErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListAccountAssignmentCreationStatusErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetPermissionsBoundaryForPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPermissionsBoundaryForPermissionSetError {
    /// Kind of error that occurred.
                    pub kind: GetPermissionsBoundaryForPermissionSetErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetPermissionsBoundaryForPermissionSetError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetPermissionsBoundaryForPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetPermissionsBoundaryForPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPermissionsBoundaryForPermissionSetErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetPermissionsBoundaryForPermissionSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPermissionsBoundaryForPermissionSetErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GetPermissionsBoundaryForPermissionSetErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            GetPermissionsBoundaryForPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetPermissionsBoundaryForPermissionSetErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            GetPermissionsBoundaryForPermissionSetErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            GetPermissionsBoundaryForPermissionSetErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetPermissionsBoundaryForPermissionSetError {
    fn code(&self) -> Option<&str> {
        GetPermissionsBoundaryForPermissionSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPermissionsBoundaryForPermissionSetError {
    /// Creates a new `GetPermissionsBoundaryForPermissionSetError`.
                    pub fn new(kind: GetPermissionsBoundaryForPermissionSetErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetPermissionsBoundaryForPermissionSetError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetPermissionsBoundaryForPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetPermissionsBoundaryForPermissionSetError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetPermissionsBoundaryForPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetPermissionsBoundaryForPermissionSetErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetPermissionsBoundaryForPermissionSetErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetPermissionsBoundaryForPermissionSetErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetPermissionsBoundaryForPermissionSetErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `GetPermissionsBoundaryForPermissionSetErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetPermissionsBoundaryForPermissionSetErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetPermissionsBoundaryForPermissionSetErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetPermissionsBoundaryForPermissionSetErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `GetPermissionsBoundaryForPermissionSetErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetPermissionsBoundaryForPermissionSetErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetPermissionsBoundaryForPermissionSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPermissionsBoundaryForPermissionSetErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GetPermissionsBoundaryForPermissionSetErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            GetPermissionsBoundaryForPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            GetPermissionsBoundaryForPermissionSetErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            GetPermissionsBoundaryForPermissionSetErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            GetPermissionsBoundaryForPermissionSetErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetInlinePolicyForPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetInlinePolicyForPermissionSetError {
    /// Kind of error that occurred.
                    pub kind: GetInlinePolicyForPermissionSetErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetInlinePolicyForPermissionSetError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetInlinePolicyForPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetInlinePolicyForPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetInlinePolicyForPermissionSetErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetInlinePolicyForPermissionSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetInlinePolicyForPermissionSetErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GetInlinePolicyForPermissionSetErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            GetInlinePolicyForPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetInlinePolicyForPermissionSetErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            GetInlinePolicyForPermissionSetErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            GetInlinePolicyForPermissionSetErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetInlinePolicyForPermissionSetError {
    fn code(&self) -> Option<&str> {
        GetInlinePolicyForPermissionSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetInlinePolicyForPermissionSetError {
    /// Creates a new `GetInlinePolicyForPermissionSetError`.
                    pub fn new(kind: GetInlinePolicyForPermissionSetErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetInlinePolicyForPermissionSetError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetInlinePolicyForPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetInlinePolicyForPermissionSetError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetInlinePolicyForPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetInlinePolicyForPermissionSetErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetInlinePolicyForPermissionSetErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetInlinePolicyForPermissionSetErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetInlinePolicyForPermissionSetErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `GetInlinePolicyForPermissionSetErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetInlinePolicyForPermissionSetErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetInlinePolicyForPermissionSetErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetInlinePolicyForPermissionSetErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `GetInlinePolicyForPermissionSetErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetInlinePolicyForPermissionSetErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetInlinePolicyForPermissionSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetInlinePolicyForPermissionSetErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GetInlinePolicyForPermissionSetErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            GetInlinePolicyForPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            GetInlinePolicyForPermissionSetErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            GetInlinePolicyForPermissionSetErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            GetInlinePolicyForPermissionSetErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DetachManagedPolicyFromPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetachManagedPolicyFromPermissionSetError {
    /// Kind of error that occurred.
                    pub kind: DetachManagedPolicyFromPermissionSetErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DetachManagedPolicyFromPermissionSetError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DetachManagedPolicyFromPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DetachManagedPolicyFromPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetachManagedPolicyFromPermissionSetErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DetachManagedPolicyFromPermissionSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetachManagedPolicyFromPermissionSetErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DetachManagedPolicyFromPermissionSetErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            DetachManagedPolicyFromPermissionSetErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            DetachManagedPolicyFromPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DetachManagedPolicyFromPermissionSetErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            DetachManagedPolicyFromPermissionSetErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            DetachManagedPolicyFromPermissionSetErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DetachManagedPolicyFromPermissionSetError {
    fn code(&self) -> Option<&str> {
        DetachManagedPolicyFromPermissionSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetachManagedPolicyFromPermissionSetError {
    /// Creates a new `DetachManagedPolicyFromPermissionSetError`.
                    pub fn new(kind: DetachManagedPolicyFromPermissionSetErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DetachManagedPolicyFromPermissionSetError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DetachManagedPolicyFromPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DetachManagedPolicyFromPermissionSetError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DetachManagedPolicyFromPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DetachManagedPolicyFromPermissionSetErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DetachManagedPolicyFromPermissionSetErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DetachManagedPolicyFromPermissionSetErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DetachManagedPolicyFromPermissionSetErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `DetachManagedPolicyFromPermissionSetErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DetachManagedPolicyFromPermissionSetErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `DetachManagedPolicyFromPermissionSetErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, DetachManagedPolicyFromPermissionSetErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DetachManagedPolicyFromPermissionSetErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DetachManagedPolicyFromPermissionSetErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DetachManagedPolicyFromPermissionSetErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DetachManagedPolicyFromPermissionSetErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DetachManagedPolicyFromPermissionSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetachManagedPolicyFromPermissionSetErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DetachManagedPolicyFromPermissionSetErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            DetachManagedPolicyFromPermissionSetErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            DetachManagedPolicyFromPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            DetachManagedPolicyFromPermissionSetErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            DetachManagedPolicyFromPermissionSetErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            DetachManagedPolicyFromPermissionSetErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DetachCustomerManagedPolicyReferenceFromPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetachCustomerManagedPolicyReferenceFromPermissionSetError {
    /// Kind of error that occurred.
                    pub kind: DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DetachCustomerManagedPolicyReferenceFromPermissionSetError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DetachCustomerManagedPolicyReferenceFromPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DetachCustomerManagedPolicyReferenceFromPermissionSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DetachCustomerManagedPolicyReferenceFromPermissionSetError {
    fn code(&self) -> Option<&str> {
        DetachCustomerManagedPolicyReferenceFromPermissionSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetachCustomerManagedPolicyReferenceFromPermissionSetError {
    /// Creates a new `DetachCustomerManagedPolicyReferenceFromPermissionSetError`.
                    pub fn new(kind: DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DetachCustomerManagedPolicyReferenceFromPermissionSetError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DetachCustomerManagedPolicyReferenceFromPermissionSetError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DetachCustomerManagedPolicyReferenceFromPermissionSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            DetachCustomerManagedPolicyReferenceFromPermissionSetErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DescribePermissionSetProvisioningStatus` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribePermissionSetProvisioningStatusError {
    /// Kind of error that occurred.
                    pub kind: DescribePermissionSetProvisioningStatusErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DescribePermissionSetProvisioningStatusError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DescribePermissionSetProvisioningStatusErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DescribePermissionSetProvisioningStatus` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribePermissionSetProvisioningStatusErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DescribePermissionSetProvisioningStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribePermissionSetProvisioningStatusErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DescribePermissionSetProvisioningStatusErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            DescribePermissionSetProvisioningStatusErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DescribePermissionSetProvisioningStatusErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            DescribePermissionSetProvisioningStatusErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            DescribePermissionSetProvisioningStatusErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribePermissionSetProvisioningStatusError {
    fn code(&self) -> Option<&str> {
        DescribePermissionSetProvisioningStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribePermissionSetProvisioningStatusError {
    /// Creates a new `DescribePermissionSetProvisioningStatusError`.
                    pub fn new(kind: DescribePermissionSetProvisioningStatusErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DescribePermissionSetProvisioningStatusError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DescribePermissionSetProvisioningStatusErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DescribePermissionSetProvisioningStatusError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DescribePermissionSetProvisioningStatusErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DescribePermissionSetProvisioningStatusErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DescribePermissionSetProvisioningStatusErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DescribePermissionSetProvisioningStatusErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DescribePermissionSetProvisioningStatusErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `DescribePermissionSetProvisioningStatusErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, DescribePermissionSetProvisioningStatusErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DescribePermissionSetProvisioningStatusErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribePermissionSetProvisioningStatusErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DescribePermissionSetProvisioningStatusErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DescribePermissionSetProvisioningStatusErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DescribePermissionSetProvisioningStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribePermissionSetProvisioningStatusErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DescribePermissionSetProvisioningStatusErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            DescribePermissionSetProvisioningStatusErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            DescribePermissionSetProvisioningStatusErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            DescribePermissionSetProvisioningStatusErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            DescribePermissionSetProvisioningStatusErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DescribePermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribePermissionSetError {
    /// Kind of error that occurred.
                    pub kind: DescribePermissionSetErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DescribePermissionSetError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DescribePermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DescribePermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribePermissionSetErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DescribePermissionSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribePermissionSetErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DescribePermissionSetErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            DescribePermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DescribePermissionSetErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            DescribePermissionSetErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            DescribePermissionSetErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribePermissionSetError {
    fn code(&self) -> Option<&str> {
        DescribePermissionSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribePermissionSetError {
    /// Creates a new `DescribePermissionSetError`.
                    pub fn new(kind: DescribePermissionSetErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DescribePermissionSetError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DescribePermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DescribePermissionSetError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DescribePermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DescribePermissionSetErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DescribePermissionSetErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DescribePermissionSetErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DescribePermissionSetErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `DescribePermissionSetErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, DescribePermissionSetErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DescribePermissionSetErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribePermissionSetErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DescribePermissionSetErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DescribePermissionSetErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DescribePermissionSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribePermissionSetErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DescribePermissionSetErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            DescribePermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            DescribePermissionSetErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            DescribePermissionSetErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            DescribePermissionSetErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DescribeInstanceAccessControlAttributeConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeInstanceAccessControlAttributeConfigurationError {
    /// Kind of error that occurred.
                    pub kind: DescribeInstanceAccessControlAttributeConfigurationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeInstanceAccessControlAttributeConfigurationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DescribeInstanceAccessControlAttributeConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DescribeInstanceAccessControlAttributeConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeInstanceAccessControlAttributeConfigurationErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DescribeInstanceAccessControlAttributeConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeInstanceAccessControlAttributeConfigurationErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeInstanceAccessControlAttributeConfigurationErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeInstanceAccessControlAttributeConfigurationErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeInstanceAccessControlAttributeConfigurationErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeInstanceAccessControlAttributeConfigurationErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeInstanceAccessControlAttributeConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeInstanceAccessControlAttributeConfigurationError {
    fn code(&self) -> Option<&str> {
        DescribeInstanceAccessControlAttributeConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeInstanceAccessControlAttributeConfigurationError {
    /// Creates a new `DescribeInstanceAccessControlAttributeConfigurationError`.
                    pub fn new(kind: DescribeInstanceAccessControlAttributeConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DescribeInstanceAccessControlAttributeConfigurationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DescribeInstanceAccessControlAttributeConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DescribeInstanceAccessControlAttributeConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DescribeInstanceAccessControlAttributeConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DescribeInstanceAccessControlAttributeConfigurationErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DescribeInstanceAccessControlAttributeConfigurationErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DescribeInstanceAccessControlAttributeConfigurationErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DescribeInstanceAccessControlAttributeConfigurationErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `DescribeInstanceAccessControlAttributeConfigurationErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, DescribeInstanceAccessControlAttributeConfigurationErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DescribeInstanceAccessControlAttributeConfigurationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeInstanceAccessControlAttributeConfigurationErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DescribeInstanceAccessControlAttributeConfigurationErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DescribeInstanceAccessControlAttributeConfigurationErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DescribeInstanceAccessControlAttributeConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeInstanceAccessControlAttributeConfigurationErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DescribeInstanceAccessControlAttributeConfigurationErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            DescribeInstanceAccessControlAttributeConfigurationErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            DescribeInstanceAccessControlAttributeConfigurationErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            DescribeInstanceAccessControlAttributeConfigurationErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            DescribeInstanceAccessControlAttributeConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DescribeAccountAssignmentDeletionStatus` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAccountAssignmentDeletionStatusError {
    /// Kind of error that occurred.
                    pub kind: DescribeAccountAssignmentDeletionStatusErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeAccountAssignmentDeletionStatusError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DescribeAccountAssignmentDeletionStatusErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DescribeAccountAssignmentDeletionStatus` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAccountAssignmentDeletionStatusErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DescribeAccountAssignmentDeletionStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAccountAssignmentDeletionStatusErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeAccountAssignmentDeletionStatusErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeAccountAssignmentDeletionStatusErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeAccountAssignmentDeletionStatusErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeAccountAssignmentDeletionStatusErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeAccountAssignmentDeletionStatusErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeAccountAssignmentDeletionStatusError {
    fn code(&self) -> Option<&str> {
        DescribeAccountAssignmentDeletionStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAccountAssignmentDeletionStatusError {
    /// Creates a new `DescribeAccountAssignmentDeletionStatusError`.
                    pub fn new(kind: DescribeAccountAssignmentDeletionStatusErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DescribeAccountAssignmentDeletionStatusError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DescribeAccountAssignmentDeletionStatusErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DescribeAccountAssignmentDeletionStatusError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DescribeAccountAssignmentDeletionStatusErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DescribeAccountAssignmentDeletionStatusErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DescribeAccountAssignmentDeletionStatusErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DescribeAccountAssignmentDeletionStatusErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DescribeAccountAssignmentDeletionStatusErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `DescribeAccountAssignmentDeletionStatusErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, DescribeAccountAssignmentDeletionStatusErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DescribeAccountAssignmentDeletionStatusErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeAccountAssignmentDeletionStatusErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DescribeAccountAssignmentDeletionStatusErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DescribeAccountAssignmentDeletionStatusErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DescribeAccountAssignmentDeletionStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAccountAssignmentDeletionStatusErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DescribeAccountAssignmentDeletionStatusErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            DescribeAccountAssignmentDeletionStatusErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            DescribeAccountAssignmentDeletionStatusErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            DescribeAccountAssignmentDeletionStatusErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            DescribeAccountAssignmentDeletionStatusErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DescribeAccountAssignmentCreationStatus` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAccountAssignmentCreationStatusError {
    /// Kind of error that occurred.
                    pub kind: DescribeAccountAssignmentCreationStatusErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeAccountAssignmentCreationStatusError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DescribeAccountAssignmentCreationStatusErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DescribeAccountAssignmentCreationStatus` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAccountAssignmentCreationStatusErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DescribeAccountAssignmentCreationStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAccountAssignmentCreationStatusErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeAccountAssignmentCreationStatusErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeAccountAssignmentCreationStatusErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeAccountAssignmentCreationStatusErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeAccountAssignmentCreationStatusErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeAccountAssignmentCreationStatusErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeAccountAssignmentCreationStatusError {
    fn code(&self) -> Option<&str> {
        DescribeAccountAssignmentCreationStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAccountAssignmentCreationStatusError {
    /// Creates a new `DescribeAccountAssignmentCreationStatusError`.
                    pub fn new(kind: DescribeAccountAssignmentCreationStatusErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DescribeAccountAssignmentCreationStatusError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DescribeAccountAssignmentCreationStatusErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DescribeAccountAssignmentCreationStatusError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DescribeAccountAssignmentCreationStatusErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DescribeAccountAssignmentCreationStatusErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DescribeAccountAssignmentCreationStatusErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DescribeAccountAssignmentCreationStatusErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DescribeAccountAssignmentCreationStatusErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `DescribeAccountAssignmentCreationStatusErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, DescribeAccountAssignmentCreationStatusErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DescribeAccountAssignmentCreationStatusErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeAccountAssignmentCreationStatusErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DescribeAccountAssignmentCreationStatusErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DescribeAccountAssignmentCreationStatusErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DescribeAccountAssignmentCreationStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAccountAssignmentCreationStatusErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DescribeAccountAssignmentCreationStatusErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            DescribeAccountAssignmentCreationStatusErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            DescribeAccountAssignmentCreationStatusErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            DescribeAccountAssignmentCreationStatusErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            DescribeAccountAssignmentCreationStatusErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DeletePermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeletePermissionSetError {
    /// Kind of error that occurred.
                    pub kind: DeletePermissionSetErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DeletePermissionSetError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeletePermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DeletePermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePermissionSetErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeletePermissionSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeletePermissionSetErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePermissionSetErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePermissionSetErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePermissionSetErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePermissionSetErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePermissionSetErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeletePermissionSetError {
    fn code(&self) -> Option<&str> {
        DeletePermissionSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePermissionSetError {
    /// Creates a new `DeletePermissionSetError`.
                    pub fn new(kind: DeletePermissionSetErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DeletePermissionSetError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DeletePermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DeletePermissionSetError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DeletePermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DeletePermissionSetErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeletePermissionSetErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DeletePermissionSetErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeletePermissionSetErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `DeletePermissionSetErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DeletePermissionSetErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `DeletePermissionSetErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeletePermissionSetErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeletePermissionSetErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeletePermissionSetErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DeletePermissionSetErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeletePermissionSetErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeletePermissionSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeletePermissionSetErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DeletePermissionSetErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            DeletePermissionSetErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            DeletePermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            DeletePermissionSetErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            DeletePermissionSetErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            DeletePermissionSetErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DeletePermissionsBoundaryFromPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeletePermissionsBoundaryFromPermissionSetError {
    /// Kind of error that occurred.
                    pub kind: DeletePermissionsBoundaryFromPermissionSetErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DeletePermissionsBoundaryFromPermissionSetError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeletePermissionsBoundaryFromPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DeletePermissionsBoundaryFromPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePermissionsBoundaryFromPermissionSetErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeletePermissionsBoundaryFromPermissionSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeletePermissionsBoundaryFromPermissionSetErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePermissionsBoundaryFromPermissionSetErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePermissionsBoundaryFromPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePermissionsBoundaryFromPermissionSetErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePermissionsBoundaryFromPermissionSetErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePermissionsBoundaryFromPermissionSetErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeletePermissionsBoundaryFromPermissionSetError {
    fn code(&self) -> Option<&str> {
        DeletePermissionsBoundaryFromPermissionSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePermissionsBoundaryFromPermissionSetError {
    /// Creates a new `DeletePermissionsBoundaryFromPermissionSetError`.
                    pub fn new(kind: DeletePermissionsBoundaryFromPermissionSetErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DeletePermissionsBoundaryFromPermissionSetError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DeletePermissionsBoundaryFromPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DeletePermissionsBoundaryFromPermissionSetError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DeletePermissionsBoundaryFromPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DeletePermissionsBoundaryFromPermissionSetErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeletePermissionsBoundaryFromPermissionSetErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DeletePermissionsBoundaryFromPermissionSetErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DeletePermissionsBoundaryFromPermissionSetErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `DeletePermissionsBoundaryFromPermissionSetErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeletePermissionsBoundaryFromPermissionSetErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeletePermissionsBoundaryFromPermissionSetErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeletePermissionsBoundaryFromPermissionSetErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DeletePermissionsBoundaryFromPermissionSetErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeletePermissionsBoundaryFromPermissionSetErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeletePermissionsBoundaryFromPermissionSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeletePermissionsBoundaryFromPermissionSetErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DeletePermissionsBoundaryFromPermissionSetErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            DeletePermissionsBoundaryFromPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            DeletePermissionsBoundaryFromPermissionSetErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            DeletePermissionsBoundaryFromPermissionSetErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            DeletePermissionsBoundaryFromPermissionSetErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DeleteInstanceAccessControlAttributeConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteInstanceAccessControlAttributeConfigurationError {
    /// Kind of error that occurred.
                    pub kind: DeleteInstanceAccessControlAttributeConfigurationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteInstanceAccessControlAttributeConfigurationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteInstanceAccessControlAttributeConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DeleteInstanceAccessControlAttributeConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteInstanceAccessControlAttributeConfigurationErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteInstanceAccessControlAttributeConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteInstanceAccessControlAttributeConfigurationErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteInstanceAccessControlAttributeConfigurationErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteInstanceAccessControlAttributeConfigurationErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteInstanceAccessControlAttributeConfigurationErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteInstanceAccessControlAttributeConfigurationErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteInstanceAccessControlAttributeConfigurationErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteInstanceAccessControlAttributeConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteInstanceAccessControlAttributeConfigurationError {
    fn code(&self) -> Option<&str> {
        DeleteInstanceAccessControlAttributeConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteInstanceAccessControlAttributeConfigurationError {
    /// Creates a new `DeleteInstanceAccessControlAttributeConfigurationError`.
                    pub fn new(kind: DeleteInstanceAccessControlAttributeConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DeleteInstanceAccessControlAttributeConfigurationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DeleteInstanceAccessControlAttributeConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DeleteInstanceAccessControlAttributeConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DeleteInstanceAccessControlAttributeConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DeleteInstanceAccessControlAttributeConfigurationErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteInstanceAccessControlAttributeConfigurationErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DeleteInstanceAccessControlAttributeConfigurationErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteInstanceAccessControlAttributeConfigurationErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `DeleteInstanceAccessControlAttributeConfigurationErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DeleteInstanceAccessControlAttributeConfigurationErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `DeleteInstanceAccessControlAttributeConfigurationErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteInstanceAccessControlAttributeConfigurationErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteInstanceAccessControlAttributeConfigurationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteInstanceAccessControlAttributeConfigurationErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DeleteInstanceAccessControlAttributeConfigurationErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteInstanceAccessControlAttributeConfigurationErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteInstanceAccessControlAttributeConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteInstanceAccessControlAttributeConfigurationErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DeleteInstanceAccessControlAttributeConfigurationErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            DeleteInstanceAccessControlAttributeConfigurationErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            DeleteInstanceAccessControlAttributeConfigurationErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            DeleteInstanceAccessControlAttributeConfigurationErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            DeleteInstanceAccessControlAttributeConfigurationErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            DeleteInstanceAccessControlAttributeConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DeleteInlinePolicyFromPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteInlinePolicyFromPermissionSetError {
    /// Kind of error that occurred.
                    pub kind: DeleteInlinePolicyFromPermissionSetErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteInlinePolicyFromPermissionSetError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteInlinePolicyFromPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DeleteInlinePolicyFromPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteInlinePolicyFromPermissionSetErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteInlinePolicyFromPermissionSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteInlinePolicyFromPermissionSetErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteInlinePolicyFromPermissionSetErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteInlinePolicyFromPermissionSetErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteInlinePolicyFromPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteInlinePolicyFromPermissionSetErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteInlinePolicyFromPermissionSetErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteInlinePolicyFromPermissionSetErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteInlinePolicyFromPermissionSetError {
    fn code(&self) -> Option<&str> {
        DeleteInlinePolicyFromPermissionSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteInlinePolicyFromPermissionSetError {
    /// Creates a new `DeleteInlinePolicyFromPermissionSetError`.
                    pub fn new(kind: DeleteInlinePolicyFromPermissionSetErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DeleteInlinePolicyFromPermissionSetError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DeleteInlinePolicyFromPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DeleteInlinePolicyFromPermissionSetError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DeleteInlinePolicyFromPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DeleteInlinePolicyFromPermissionSetErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteInlinePolicyFromPermissionSetErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DeleteInlinePolicyFromPermissionSetErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteInlinePolicyFromPermissionSetErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `DeleteInlinePolicyFromPermissionSetErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DeleteInlinePolicyFromPermissionSetErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `DeleteInlinePolicyFromPermissionSetErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteInlinePolicyFromPermissionSetErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteInlinePolicyFromPermissionSetErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteInlinePolicyFromPermissionSetErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DeleteInlinePolicyFromPermissionSetErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteInlinePolicyFromPermissionSetErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteInlinePolicyFromPermissionSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteInlinePolicyFromPermissionSetErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DeleteInlinePolicyFromPermissionSetErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            DeleteInlinePolicyFromPermissionSetErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            DeleteInlinePolicyFromPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            DeleteInlinePolicyFromPermissionSetErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            DeleteInlinePolicyFromPermissionSetErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            DeleteInlinePolicyFromPermissionSetErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DeleteAccountAssignment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAccountAssignmentError {
    /// Kind of error that occurred.
                    pub kind: DeleteAccountAssignmentErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteAccountAssignmentError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteAccountAssignmentErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DeleteAccountAssignment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAccountAssignmentErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteAccountAssignmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAccountAssignmentErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteAccountAssignmentErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteAccountAssignmentErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteAccountAssignmentErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteAccountAssignmentErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteAccountAssignmentErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteAccountAssignmentErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteAccountAssignmentError {
    fn code(&self) -> Option<&str> {
        DeleteAccountAssignmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAccountAssignmentError {
    /// Creates a new `DeleteAccountAssignmentError`.
                    pub fn new(kind: DeleteAccountAssignmentErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DeleteAccountAssignmentError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DeleteAccountAssignmentErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DeleteAccountAssignmentError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DeleteAccountAssignmentErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DeleteAccountAssignmentErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteAccountAssignmentErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DeleteAccountAssignmentErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteAccountAssignmentErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `DeleteAccountAssignmentErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DeleteAccountAssignmentErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `DeleteAccountAssignmentErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteAccountAssignmentErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteAccountAssignmentErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteAccountAssignmentErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DeleteAccountAssignmentErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteAccountAssignmentErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteAccountAssignmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAccountAssignmentErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DeleteAccountAssignmentErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            DeleteAccountAssignmentErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            DeleteAccountAssignmentErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            DeleteAccountAssignmentErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            DeleteAccountAssignmentErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            DeleteAccountAssignmentErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `CreatePermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePermissionSetError {
    /// Kind of error that occurred.
                    pub kind: CreatePermissionSetErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for CreatePermissionSetError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreatePermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `CreatePermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePermissionSetErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the permitted number of resources that can be created.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreatePermissionSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePermissionSetErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            CreatePermissionSetErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            CreatePermissionSetErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            CreatePermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            CreatePermissionSetErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreatePermissionSetErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            CreatePermissionSetErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            CreatePermissionSetErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreatePermissionSetError {
    fn code(&self) -> Option<&str> {
        CreatePermissionSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePermissionSetError {
    /// Creates a new `CreatePermissionSetError`.
                    pub fn new(kind: CreatePermissionSetErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `CreatePermissionSetError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: CreatePermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `CreatePermissionSetError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: CreatePermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `CreatePermissionSetErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreatePermissionSetErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreatePermissionSetErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreatePermissionSetErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `CreatePermissionSetErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, CreatePermissionSetErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `CreatePermissionSetErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreatePermissionSetErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreatePermissionSetErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreatePermissionSetErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `CreatePermissionSetErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreatePermissionSetErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `CreatePermissionSetErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreatePermissionSetErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreatePermissionSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePermissionSetErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            CreatePermissionSetErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            CreatePermissionSetErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            CreatePermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            CreatePermissionSetErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            CreatePermissionSetErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            CreatePermissionSetErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            CreatePermissionSetErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `CreateInstanceAccessControlAttributeConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateInstanceAccessControlAttributeConfigurationError {
    /// Kind of error that occurred.
                    pub kind: CreateInstanceAccessControlAttributeConfigurationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for CreateInstanceAccessControlAttributeConfigurationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreateInstanceAccessControlAttributeConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `CreateInstanceAccessControlAttributeConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateInstanceAccessControlAttributeConfigurationErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreateInstanceAccessControlAttributeConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateInstanceAccessControlAttributeConfigurationErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            CreateInstanceAccessControlAttributeConfigurationErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            CreateInstanceAccessControlAttributeConfigurationErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            CreateInstanceAccessControlAttributeConfigurationErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            CreateInstanceAccessControlAttributeConfigurationErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            CreateInstanceAccessControlAttributeConfigurationErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            CreateInstanceAccessControlAttributeConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateInstanceAccessControlAttributeConfigurationError {
    fn code(&self) -> Option<&str> {
        CreateInstanceAccessControlAttributeConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateInstanceAccessControlAttributeConfigurationError {
    /// Creates a new `CreateInstanceAccessControlAttributeConfigurationError`.
                    pub fn new(kind: CreateInstanceAccessControlAttributeConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `CreateInstanceAccessControlAttributeConfigurationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: CreateInstanceAccessControlAttributeConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `CreateInstanceAccessControlAttributeConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: CreateInstanceAccessControlAttributeConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `CreateInstanceAccessControlAttributeConfigurationErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateInstanceAccessControlAttributeConfigurationErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateInstanceAccessControlAttributeConfigurationErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateInstanceAccessControlAttributeConfigurationErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `CreateInstanceAccessControlAttributeConfigurationErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, CreateInstanceAccessControlAttributeConfigurationErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `CreateInstanceAccessControlAttributeConfigurationErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateInstanceAccessControlAttributeConfigurationErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreateInstanceAccessControlAttributeConfigurationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateInstanceAccessControlAttributeConfigurationErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `CreateInstanceAccessControlAttributeConfigurationErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateInstanceAccessControlAttributeConfigurationErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateInstanceAccessControlAttributeConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateInstanceAccessControlAttributeConfigurationErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            CreateInstanceAccessControlAttributeConfigurationErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            CreateInstanceAccessControlAttributeConfigurationErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            CreateInstanceAccessControlAttributeConfigurationErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            CreateInstanceAccessControlAttributeConfigurationErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            CreateInstanceAccessControlAttributeConfigurationErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            CreateInstanceAccessControlAttributeConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `CreateAccountAssignment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAccountAssignmentError {
    /// Kind of error that occurred.
                    pub kind: CreateAccountAssignmentErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for CreateAccountAssignmentError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreateAccountAssignmentErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `CreateAccountAssignment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAccountAssignmentErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the permitted number of resources that can be created.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreateAccountAssignmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAccountAssignmentErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            CreateAccountAssignmentErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            CreateAccountAssignmentErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            CreateAccountAssignmentErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            CreateAccountAssignmentErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateAccountAssignmentErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            CreateAccountAssignmentErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            CreateAccountAssignmentErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateAccountAssignmentError {
    fn code(&self) -> Option<&str> {
        CreateAccountAssignmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAccountAssignmentError {
    /// Creates a new `CreateAccountAssignmentError`.
                    pub fn new(kind: CreateAccountAssignmentErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `CreateAccountAssignmentError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: CreateAccountAssignmentErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `CreateAccountAssignmentError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: CreateAccountAssignmentErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `CreateAccountAssignmentErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateAccountAssignmentErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateAccountAssignmentErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateAccountAssignmentErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `CreateAccountAssignmentErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, CreateAccountAssignmentErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `CreateAccountAssignmentErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateAccountAssignmentErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreateAccountAssignmentErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateAccountAssignmentErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateAccountAssignmentErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateAccountAssignmentErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `CreateAccountAssignmentErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateAccountAssignmentErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateAccountAssignmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAccountAssignmentErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            CreateAccountAssignmentErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            CreateAccountAssignmentErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            CreateAccountAssignmentErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            CreateAccountAssignmentErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            CreateAccountAssignmentErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            CreateAccountAssignmentErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            CreateAccountAssignmentErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `AttachManagedPolicyToPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AttachManagedPolicyToPermissionSetError {
    /// Kind of error that occurred.
                    pub kind: AttachManagedPolicyToPermissionSetErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for AttachManagedPolicyToPermissionSetError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: AttachManagedPolicyToPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `AttachManagedPolicyToPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AttachManagedPolicyToPermissionSetErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the permitted number of resources that can be created.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for AttachManagedPolicyToPermissionSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AttachManagedPolicyToPermissionSetErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            AttachManagedPolicyToPermissionSetErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            AttachManagedPolicyToPermissionSetErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            AttachManagedPolicyToPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            AttachManagedPolicyToPermissionSetErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            AttachManagedPolicyToPermissionSetErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            AttachManagedPolicyToPermissionSetErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            AttachManagedPolicyToPermissionSetErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AttachManagedPolicyToPermissionSetError {
    fn code(&self) -> Option<&str> {
        AttachManagedPolicyToPermissionSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AttachManagedPolicyToPermissionSetError {
    /// Creates a new `AttachManagedPolicyToPermissionSetError`.
                    pub fn new(kind: AttachManagedPolicyToPermissionSetErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `AttachManagedPolicyToPermissionSetError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: AttachManagedPolicyToPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `AttachManagedPolicyToPermissionSetError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: AttachManagedPolicyToPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `AttachManagedPolicyToPermissionSetErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, AttachManagedPolicyToPermissionSetErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `AttachManagedPolicyToPermissionSetErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, AttachManagedPolicyToPermissionSetErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `AttachManagedPolicyToPermissionSetErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, AttachManagedPolicyToPermissionSetErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `AttachManagedPolicyToPermissionSetErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, AttachManagedPolicyToPermissionSetErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `AttachManagedPolicyToPermissionSetErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, AttachManagedPolicyToPermissionSetErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `AttachManagedPolicyToPermissionSetErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, AttachManagedPolicyToPermissionSetErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `AttachManagedPolicyToPermissionSetErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, AttachManagedPolicyToPermissionSetErrorKind::ValidationException(_))
    }
}
impl std::error::Error for AttachManagedPolicyToPermissionSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AttachManagedPolicyToPermissionSetErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            AttachManagedPolicyToPermissionSetErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            AttachManagedPolicyToPermissionSetErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            AttachManagedPolicyToPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            AttachManagedPolicyToPermissionSetErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            AttachManagedPolicyToPermissionSetErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            AttachManagedPolicyToPermissionSetErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            AttachManagedPolicyToPermissionSetErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `AttachCustomerManagedPolicyReferenceToPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AttachCustomerManagedPolicyReferenceToPermissionSetError {
    /// Kind of error that occurred.
                    pub kind: AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for AttachCustomerManagedPolicyReferenceToPermissionSetError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `AttachCustomerManagedPolicyReferenceToPermissionSet` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>The request processing has failed because of an unknown error, exception, or failure with an internal server.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>Indicates that a requested resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>Indicates that the principal has crossed the permitted number of resources that can be created.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>Indicates that the principal has crossed the throttling limits of the API operations.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request failed because it contains a syntax error.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for AttachCustomerManagedPolicyReferenceToPermissionSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AttachCustomerManagedPolicyReferenceToPermissionSetError {
    fn code(&self) -> Option<&str> {
        AttachCustomerManagedPolicyReferenceToPermissionSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AttachCustomerManagedPolicyReferenceToPermissionSetError {
    /// Creates a new `AttachCustomerManagedPolicyReferenceToPermissionSetError`.
                    pub fn new(kind: AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `AttachCustomerManagedPolicyReferenceToPermissionSetError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `AttachCustomerManagedPolicyReferenceToPermissionSetError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::ValidationException(_))
    }
}
impl std::error::Error for AttachCustomerManagedPolicyReferenceToPermissionSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            AttachCustomerManagedPolicyReferenceToPermissionSetErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// 
/// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
/// 
/// When logging an error from the SDK, it is recommended that you either wrap the error in
/// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
/// error reporter library that visits the error's cause/source chain, or call
/// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
/// 
#[derive(Debug)]
        pub struct Unhandled {
            source: Box<dyn std::error::Error + Send + Sync + 'static>,
        }
        impl Unhandled {
            #[allow(unused)]
            pub(crate) fn new(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
                Self { source }
            }
        }
        impl std::fmt::Display for Unhandled {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                write!(f, "unhandled error")
            }
        }
        impl std::error::Error for Unhandled {
            fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                Some(self.source.as_ref() as _)
            }
        }

