// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Cancels execution of a task. </p>
/// <p>When you cancel a task execution, the transfer of some files is abruptly interrupted.
/// The contents of files that are transferred to the destination might be incomplete or
/// inconsistent with the source files. However, if you start a new task execution on the same
/// task and you allow the task execution to complete, file content on the destination is complete
/// and consistent. This applies to other unexpected failures that interrupt a task execution. In
/// all of these cases, AWS DataSync successfully complete the transfer when you start the next
/// task execution.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CancelTaskExecution {
    _private: (),
}
impl CancelTaskExecution {
    /// Creates a new builder-style object to manufacture [`CancelTaskExecutionInput`](crate::input::CancelTaskExecutionInput)
    pub fn builder() -> crate::input::cancel_task_execution_input::Builder {
        crate::input::cancel_task_execution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CancelTaskExecution {
    type Output = std::result::Result<
        crate::output::CancelTaskExecutionOutput,
        crate::error::CancelTaskExecutionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_cancel_task_execution_error(response)
        } else {
            crate::operation_deser::parse_cancel_task_execution_response(response)
        }
    }
}

/// <p>Activates an AWS DataSync agent that you have deployed on your host. The activation
/// process associates your agent with your account. In the activation process, you specify
/// information such as the AWS Region that you want to activate the agent in. You activate the
/// agent in the AWS Region where your target locations (in Amazon S3 or Amazon EFS) reside. Your
/// tasks are created in this AWS Region.</p>
/// <p>You can activate the agent in a VPC (virtual private cloud) or provide the agent access to
/// a VPC endpoint so you can run tasks without going over the public internet.</p>
/// <p>You can use an agent for more than one location. If a task uses multiple agents, all of
/// them need to have status AVAILABLE for the task to run. If you use multiple agents for a
/// source location, the status of all the agents must be AVAILABLE for the task to run. </p>
/// <p>Agents are automatically updated by AWS on a regular basis, using a mechanism that
/// ensures minimal interruption to your tasks.</p>
/// <p></p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateAgent {
    _private: (),
}
impl CreateAgent {
    /// Creates a new builder-style object to manufacture [`CreateAgentInput`](crate::input::CreateAgentInput)
    pub fn builder() -> crate::input::create_agent_input::Builder {
        crate::input::create_agent_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateAgent {
    type Output =
        std::result::Result<crate::output::CreateAgentOutput, crate::error::CreateAgentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_agent_error(response)
        } else {
            crate::operation_deser::parse_create_agent_response(response)
        }
    }
}

/// <p>Creates an endpoint for an Amazon EFS file system.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateLocationEfs {
    _private: (),
}
impl CreateLocationEfs {
    /// Creates a new builder-style object to manufacture [`CreateLocationEfsInput`](crate::input::CreateLocationEfsInput)
    pub fn builder() -> crate::input::create_location_efs_input::Builder {
        crate::input::create_location_efs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateLocationEfs {
    type Output = std::result::Result<
        crate::output::CreateLocationEfsOutput,
        crate::error::CreateLocationEfsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_location_efs_error(response)
        } else {
            crate::operation_deser::parse_create_location_efs_response(response)
        }
    }
}

/// <p>Creates an endpoint for an Amazon FSx for Windows File Server file system.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateLocationFsxWindows {
    _private: (),
}
impl CreateLocationFsxWindows {
    /// Creates a new builder-style object to manufacture [`CreateLocationFsxWindowsInput`](crate::input::CreateLocationFsxWindowsInput)
    pub fn builder() -> crate::input::create_location_fsx_windows_input::Builder {
        crate::input::create_location_fsx_windows_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateLocationFsxWindows {
    type Output = std::result::Result<
        crate::output::CreateLocationFsxWindowsOutput,
        crate::error::CreateLocationFsxWindowsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_location_fsx_windows_error(response)
        } else {
            crate::operation_deser::parse_create_location_fsx_windows_response(response)
        }
    }
}

/// <p>Defines a file system on a Network File System (NFS) server that can be read from or
/// written to.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateLocationNfs {
    _private: (),
}
impl CreateLocationNfs {
    /// Creates a new builder-style object to manufacture [`CreateLocationNfsInput`](crate::input::CreateLocationNfsInput)
    pub fn builder() -> crate::input::create_location_nfs_input::Builder {
        crate::input::create_location_nfs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateLocationNfs {
    type Output = std::result::Result<
        crate::output::CreateLocationNfsOutput,
        crate::error::CreateLocationNfsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_location_nfs_error(response)
        } else {
            crate::operation_deser::parse_create_location_nfs_response(response)
        }
    }
}

/// <p>Creates an endpoint for a self-managed object storage bucket. For more information
/// about self-managed object storage locations, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-object-location.html">Creating a location for object storage</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateLocationObjectStorage {
    _private: (),
}
impl CreateLocationObjectStorage {
    /// Creates a new builder-style object to manufacture [`CreateLocationObjectStorageInput`](crate::input::CreateLocationObjectStorageInput)
    pub fn builder() -> crate::input::create_location_object_storage_input::Builder {
        crate::input::create_location_object_storage_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateLocationObjectStorage {
    type Output = std::result::Result<
        crate::output::CreateLocationObjectStorageOutput,
        crate::error::CreateLocationObjectStorageError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_location_object_storage_error(response)
        } else {
            crate::operation_deser::parse_create_location_object_storage_response(response)
        }
    }
}

/// <p>Creates an endpoint for an Amazon S3 bucket.</p>
/// <p>For
/// more information, see
/// https://docs.aws.amazon.com/datasync/latest/userguide/create-locations-cli.html#create-location-s3-cli
/// in the <i>AWS DataSync User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateLocationS3 {
    _private: (),
}
impl CreateLocationS3 {
    /// Creates a new builder-style object to manufacture [`CreateLocationS3Input`](crate::input::CreateLocationS3Input)
    pub fn builder() -> crate::input::create_location_s3_input::Builder {
        crate::input::create_location_s3_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateLocationS3 {
    type Output = std::result::Result<
        crate::output::CreateLocationS3Output,
        crate::error::CreateLocationS3Error,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_location_s3_error(response)
        } else {
            crate::operation_deser::parse_create_location_s3_response(response)
        }
    }
}

/// <p>Defines a file system on a Server Message Block (SMB) server that can be read from or
/// written to.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateLocationSmb {
    _private: (),
}
impl CreateLocationSmb {
    /// Creates a new builder-style object to manufacture [`CreateLocationSmbInput`](crate::input::CreateLocationSmbInput)
    pub fn builder() -> crate::input::create_location_smb_input::Builder {
        crate::input::create_location_smb_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateLocationSmb {
    type Output = std::result::Result<
        crate::output::CreateLocationSmbOutput,
        crate::error::CreateLocationSmbError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_location_smb_error(response)
        } else {
            crate::operation_deser::parse_create_location_smb_response(response)
        }
    }
}

/// <p>Creates a task.</p>
/// <p>A task includes a source location and a destination location, and a configuration
/// that specifies how data is transferred. A task always transfers data from the source
/// location to the destination location. The configuration specifies options such as
/// task scheduling, bandwidth limits, etc. A task is the complete definition of a data
/// transfer.</p>
/// <p>When you create a task that transfers data between AWS services in different AWS Regions,
/// one of the two locations that you specify must reside in the Region where DataSync is being
/// used. The other location must be specified in a different Region.</p>
/// <p>You can transfer data between commercial AWS Regions except for China, or between AWS
/// GovCloud (US-East and US-West) Regions.</p>
/// <important>
/// <p>When you use DataSync to copy files or objects between AWS Regions,
/// you pay for data transfer between Regions. This is billed as data transfer OUT
/// from your source Region to your destination Region. For more information,
/// see <a href="http://aws.amazon.com/ec2/pricing/on-demand/#Data_Transfer">Data Transfer pricing</a>.
/// </p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateTask {
    _private: (),
}
impl CreateTask {
    /// Creates a new builder-style object to manufacture [`CreateTaskInput`](crate::input::CreateTaskInput)
    pub fn builder() -> crate::input::create_task_input::Builder {
        crate::input::create_task_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateTask {
    type Output =
        std::result::Result<crate::output::CreateTaskOutput, crate::error::CreateTaskError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_task_error(response)
        } else {
            crate::operation_deser::parse_create_task_response(response)
        }
    }
}

/// <p>Deletes an agent. To specify which agent to delete, use the Amazon Resource Name (ARN)
/// of the agent in your request. The operation disassociates the agent from your AWS account.
/// However, it doesn't delete the agent virtual machine (VM) from your on-premises
/// environment.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteAgent {
    _private: (),
}
impl DeleteAgent {
    /// Creates a new builder-style object to manufacture [`DeleteAgentInput`](crate::input::DeleteAgentInput)
    pub fn builder() -> crate::input::delete_agent_input::Builder {
        crate::input::delete_agent_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteAgent {
    type Output =
        std::result::Result<crate::output::DeleteAgentOutput, crate::error::DeleteAgentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_agent_error(response)
        } else {
            crate::operation_deser::parse_delete_agent_response(response)
        }
    }
}

/// <p>Deletes the configuration of a location used by AWS DataSync. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteLocation {
    _private: (),
}
impl DeleteLocation {
    /// Creates a new builder-style object to manufacture [`DeleteLocationInput`](crate::input::DeleteLocationInput)
    pub fn builder() -> crate::input::delete_location_input::Builder {
        crate::input::delete_location_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteLocation {
    type Output =
        std::result::Result<crate::output::DeleteLocationOutput, crate::error::DeleteLocationError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_location_error(response)
        } else {
            crate::operation_deser::parse_delete_location_response(response)
        }
    }
}

/// <p>Deletes a task.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteTask {
    _private: (),
}
impl DeleteTask {
    /// Creates a new builder-style object to manufacture [`DeleteTaskInput`](crate::input::DeleteTaskInput)
    pub fn builder() -> crate::input::delete_task_input::Builder {
        crate::input::delete_task_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteTask {
    type Output =
        std::result::Result<crate::output::DeleteTaskOutput, crate::error::DeleteTaskError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_task_error(response)
        } else {
            crate::operation_deser::parse_delete_task_response(response)
        }
    }
}

/// <p>Returns metadata such as the name, the network interfaces, and the status (that is,
/// whether the agent is running or not) for an agent. To specify which agent to describe, use the
/// Amazon Resource Name (ARN) of the agent in your request. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAgent {
    _private: (),
}
impl DescribeAgent {
    /// Creates a new builder-style object to manufacture [`DescribeAgentInput`](crate::input::DescribeAgentInput)
    pub fn builder() -> crate::input::describe_agent_input::Builder {
        crate::input::describe_agent_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAgent {
    type Output =
        std::result::Result<crate::output::DescribeAgentOutput, crate::error::DescribeAgentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_agent_error(response)
        } else {
            crate::operation_deser::parse_describe_agent_response(response)
        }
    }
}

/// <p>Returns metadata, such as the path information about an Amazon EFS location.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeLocationEfs {
    _private: (),
}
impl DescribeLocationEfs {
    /// Creates a new builder-style object to manufacture [`DescribeLocationEfsInput`](crate::input::DescribeLocationEfsInput)
    pub fn builder() -> crate::input::describe_location_efs_input::Builder {
        crate::input::describe_location_efs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeLocationEfs {
    type Output = std::result::Result<
        crate::output::DescribeLocationEfsOutput,
        crate::error::DescribeLocationEfsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_location_efs_error(response)
        } else {
            crate::operation_deser::parse_describe_location_efs_response(response)
        }
    }
}

/// <p>Returns metadata, such as the path information about an Amazon FSx for Windows File Server
/// location.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeLocationFsxWindows {
    _private: (),
}
impl DescribeLocationFsxWindows {
    /// Creates a new builder-style object to manufacture [`DescribeLocationFsxWindowsInput`](crate::input::DescribeLocationFsxWindowsInput)
    pub fn builder() -> crate::input::describe_location_fsx_windows_input::Builder {
        crate::input::describe_location_fsx_windows_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeLocationFsxWindows {
    type Output = std::result::Result<
        crate::output::DescribeLocationFsxWindowsOutput,
        crate::error::DescribeLocationFsxWindowsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_location_fsx_windows_error(response)
        } else {
            crate::operation_deser::parse_describe_location_fsx_windows_response(response)
        }
    }
}

/// <p>Returns metadata, such as the path information, about an NFS location.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeLocationNfs {
    _private: (),
}
impl DescribeLocationNfs {
    /// Creates a new builder-style object to manufacture [`DescribeLocationNfsInput`](crate::input::DescribeLocationNfsInput)
    pub fn builder() -> crate::input::describe_location_nfs_input::Builder {
        crate::input::describe_location_nfs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeLocationNfs {
    type Output = std::result::Result<
        crate::output::DescribeLocationNfsOutput,
        crate::error::DescribeLocationNfsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_location_nfs_error(response)
        } else {
            crate::operation_deser::parse_describe_location_nfs_response(response)
        }
    }
}

/// <p>Returns metadata about a self-managed object storage server location. For more information
/// about self-managed object storage locations, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-object-location.html">Creating a location for object storage</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeLocationObjectStorage {
    _private: (),
}
impl DescribeLocationObjectStorage {
    /// Creates a new builder-style object to manufacture [`DescribeLocationObjectStorageInput`](crate::input::DescribeLocationObjectStorageInput)
    pub fn builder() -> crate::input::describe_location_object_storage_input::Builder {
        crate::input::describe_location_object_storage_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeLocationObjectStorage {
    type Output = std::result::Result<
        crate::output::DescribeLocationObjectStorageOutput,
        crate::error::DescribeLocationObjectStorageError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_location_object_storage_error(response)
        } else {
            crate::operation_deser::parse_describe_location_object_storage_response(response)
        }
    }
}

/// <p>Returns metadata, such as bucket name, about an Amazon S3 bucket location.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeLocationS3 {
    _private: (),
}
impl DescribeLocationS3 {
    /// Creates a new builder-style object to manufacture [`DescribeLocationS3Input`](crate::input::DescribeLocationS3Input)
    pub fn builder() -> crate::input::describe_location_s3_input::Builder {
        crate::input::describe_location_s3_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeLocationS3 {
    type Output = std::result::Result<
        crate::output::DescribeLocationS3Output,
        crate::error::DescribeLocationS3Error,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_location_s3_error(response)
        } else {
            crate::operation_deser::parse_describe_location_s3_response(response)
        }
    }
}

/// <p>Returns metadata, such as the path and user information about an SMB location.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeLocationSmb {
    _private: (),
}
impl DescribeLocationSmb {
    /// Creates a new builder-style object to manufacture [`DescribeLocationSmbInput`](crate::input::DescribeLocationSmbInput)
    pub fn builder() -> crate::input::describe_location_smb_input::Builder {
        crate::input::describe_location_smb_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeLocationSmb {
    type Output = std::result::Result<
        crate::output::DescribeLocationSmbOutput,
        crate::error::DescribeLocationSmbError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_location_smb_error(response)
        } else {
            crate::operation_deser::parse_describe_location_smb_response(response)
        }
    }
}

/// <p>Returns metadata about a task.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTask {
    _private: (),
}
impl DescribeTask {
    /// Creates a new builder-style object to manufacture [`DescribeTaskInput`](crate::input::DescribeTaskInput)
    pub fn builder() -> crate::input::describe_task_input::Builder {
        crate::input::describe_task_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTask {
    type Output =
        std::result::Result<crate::output::DescribeTaskOutput, crate::error::DescribeTaskError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_task_error(response)
        } else {
            crate::operation_deser::parse_describe_task_response(response)
        }
    }
}

/// <p>Returns detailed metadata about a task that is being executed.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTaskExecution {
    _private: (),
}
impl DescribeTaskExecution {
    /// Creates a new builder-style object to manufacture [`DescribeTaskExecutionInput`](crate::input::DescribeTaskExecutionInput)
    pub fn builder() -> crate::input::describe_task_execution_input::Builder {
        crate::input::describe_task_execution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTaskExecution {
    type Output = std::result::Result<
        crate::output::DescribeTaskExecutionOutput,
        crate::error::DescribeTaskExecutionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_task_execution_error(response)
        } else {
            crate::operation_deser::parse_describe_task_execution_response(response)
        }
    }
}

/// <p>Returns a list of agents owned by an AWS account in the AWS Region specified in the
/// request. The returned list is ordered by agent Amazon Resource Name (ARN).</p>
/// <p>By default, this operation returns a maximum of 100 agents. This operation supports
/// pagination that enables you to optionally reduce the number of agents returned in a
/// response.</p>
/// <p>If you have more agents than are returned in a response (that is, the response returns
/// only a truncated list of your agents), the response contains a marker that you can specify in
/// your next request to fetch the next page of agents.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListAgents {
    _private: (),
}
impl ListAgents {
    /// Creates a new builder-style object to manufacture [`ListAgentsInput`](crate::input::ListAgentsInput)
    pub fn builder() -> crate::input::list_agents_input::Builder {
        crate::input::list_agents_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListAgents {
    type Output =
        std::result::Result<crate::output::ListAgentsOutput, crate::error::ListAgentsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_agents_error(response)
        } else {
            crate::operation_deser::parse_list_agents_response(response)
        }
    }
}

/// <p>Returns a list of source and destination locations.</p>
/// <p>If you have more locations than are returned in a response (that is, the response
/// returns only a truncated list of your agents), the response contains a token that you can
/// specify in your next request to fetch the next page of locations.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListLocations {
    _private: (),
}
impl ListLocations {
    /// Creates a new builder-style object to manufacture [`ListLocationsInput`](crate::input::ListLocationsInput)
    pub fn builder() -> crate::input::list_locations_input::Builder {
        crate::input::list_locations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListLocations {
    type Output =
        std::result::Result<crate::output::ListLocationsOutput, crate::error::ListLocationsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_locations_error(response)
        } else {
            crate::operation_deser::parse_list_locations_response(response)
        }
    }
}

/// <p>Returns all the tags associated with a specified resource. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Returns a list of executed tasks.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTaskExecutions {
    _private: (),
}
impl ListTaskExecutions {
    /// Creates a new builder-style object to manufacture [`ListTaskExecutionsInput`](crate::input::ListTaskExecutionsInput)
    pub fn builder() -> crate::input::list_task_executions_input::Builder {
        crate::input::list_task_executions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTaskExecutions {
    type Output = std::result::Result<
        crate::output::ListTaskExecutionsOutput,
        crate::error::ListTaskExecutionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_task_executions_error(response)
        } else {
            crate::operation_deser::parse_list_task_executions_response(response)
        }
    }
}

/// <p>Returns a list of all the tasks.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTasks {
    _private: (),
}
impl ListTasks {
    /// Creates a new builder-style object to manufacture [`ListTasksInput`](crate::input::ListTasksInput)
    pub fn builder() -> crate::input::list_tasks_input::Builder {
        crate::input::list_tasks_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTasks {
    type Output = std::result::Result<crate::output::ListTasksOutput, crate::error::ListTasksError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tasks_error(response)
        } else {
            crate::operation_deser::parse_list_tasks_response(response)
        }
    }
}

/// <p>Starts a specific invocation of a task. A <code>TaskExecution</code> value represents
/// an individual run of a task. Each task can have at most one <code>TaskExecution</code> at a
/// time.</p>
/// <p>
/// <code>TaskExecution</code> has the following transition phases: INITIALIZING |
/// PREPARING | TRANSFERRING | VERIFYING | SUCCESS/FAILURE. </p>
/// <p>For detailed information, see the Task Execution section in the Components and
/// Terminology topic in the <i>AWS DataSync User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartTaskExecution {
    _private: (),
}
impl StartTaskExecution {
    /// Creates a new builder-style object to manufacture [`StartTaskExecutionInput`](crate::input::StartTaskExecutionInput)
    pub fn builder() -> crate::input::start_task_execution_input::Builder {
        crate::input::start_task_execution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartTaskExecution {
    type Output = std::result::Result<
        crate::output::StartTaskExecutionOutput,
        crate::error::StartTaskExecutionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_task_execution_error(response)
        } else {
            crate::operation_deser::parse_start_task_execution_response(response)
        }
    }
}

/// <p>Applies a key-value pair to an AWS resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Removes a tag from an AWS resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Updates the name of an agent.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateAgent {
    _private: (),
}
impl UpdateAgent {
    /// Creates a new builder-style object to manufacture [`UpdateAgentInput`](crate::input::UpdateAgentInput)
    pub fn builder() -> crate::input::update_agent_input::Builder {
        crate::input::update_agent_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateAgent {
    type Output =
        std::result::Result<crate::output::UpdateAgentOutput, crate::error::UpdateAgentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_agent_error(response)
        } else {
            crate::operation_deser::parse_update_agent_response(response)
        }
    }
}

/// <p>Updates some of the parameters of a previously created location for Network File System (NFS) access.
/// For information about creating an NFS location, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-nfs-location.html">Creating a location for NFS</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateLocationNfs {
    _private: (),
}
impl UpdateLocationNfs {
    /// Creates a new builder-style object to manufacture [`UpdateLocationNfsInput`](crate::input::UpdateLocationNfsInput)
    pub fn builder() -> crate::input::update_location_nfs_input::Builder {
        crate::input::update_location_nfs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateLocationNfs {
    type Output = std::result::Result<
        crate::output::UpdateLocationNfsOutput,
        crate::error::UpdateLocationNfsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_location_nfs_error(response)
        } else {
            crate::operation_deser::parse_update_location_nfs_response(response)
        }
    }
}

/// <p>Updates some of the parameters of a previously created location for self-managed object
/// storage server access. For information about creating a self-managed object storage location,
/// see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-object-location.html">Creating a location for object storage</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateLocationObjectStorage {
    _private: (),
}
impl UpdateLocationObjectStorage {
    /// Creates a new builder-style object to manufacture [`UpdateLocationObjectStorageInput`](crate::input::UpdateLocationObjectStorageInput)
    pub fn builder() -> crate::input::update_location_object_storage_input::Builder {
        crate::input::update_location_object_storage_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateLocationObjectStorage {
    type Output = std::result::Result<
        crate::output::UpdateLocationObjectStorageOutput,
        crate::error::UpdateLocationObjectStorageError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_location_object_storage_error(response)
        } else {
            crate::operation_deser::parse_update_location_object_storage_response(response)
        }
    }
}

/// <p>Updates some of the parameters of a previously created location for Server Message Block
/// (SMB) file system access. For information about creating an SMB location, see
/// <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-smb-location.html">Creating a location for SMB</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateLocationSmb {
    _private: (),
}
impl UpdateLocationSmb {
    /// Creates a new builder-style object to manufacture [`UpdateLocationSmbInput`](crate::input::UpdateLocationSmbInput)
    pub fn builder() -> crate::input::update_location_smb_input::Builder {
        crate::input::update_location_smb_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateLocationSmb {
    type Output = std::result::Result<
        crate::output::UpdateLocationSmbOutput,
        crate::error::UpdateLocationSmbError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_location_smb_error(response)
        } else {
            crate::operation_deser::parse_update_location_smb_response(response)
        }
    }
}

/// <p>Updates the metadata associated with a task.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateTask {
    _private: (),
}
impl UpdateTask {
    /// Creates a new builder-style object to manufacture [`UpdateTaskInput`](crate::input::UpdateTaskInput)
    pub fn builder() -> crate::input::update_task_input::Builder {
        crate::input::update_task_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateTask {
    type Output =
        std::result::Result<crate::output::UpdateTaskOutput, crate::error::UpdateTaskError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_task_error(response)
        } else {
            crate::operation_deser::parse_update_task_response(response)
        }
    }
}

/// <p>Updates execution of a task.</p>
/// <p>You can modify bandwidth throttling for a task execution that is running or queued.
/// For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/working-with-task-executions.html#adjust-bandwidth-throttling">Adjusting Bandwidth Throttling for a Task Execution</a>.</p>
/// <note>
/// <p>The only <code>Option</code> that can be modified by <code>UpdateTaskExecution</code>
/// is <code>
/// <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_Options.html#DataSync-Type-Options-BytesPerSecond">BytesPerSecond</a>
/// </code>.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateTaskExecution {
    _private: (),
}
impl UpdateTaskExecution {
    /// Creates a new builder-style object to manufacture [`UpdateTaskExecutionInput`](crate::input::UpdateTaskExecutionInput)
    pub fn builder() -> crate::input::update_task_execution_input::Builder {
        crate::input::update_task_execution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateTaskExecution {
    type Output = std::result::Result<
        crate::output::UpdateTaskExecutionOutput,
        crate::error::UpdateTaskExecutionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_task_execution_error(response)
        } else {
            crate::operation_deser::parse_update_task_execution_response(response)
        }
    }
}
