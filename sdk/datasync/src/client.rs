// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(Debug)]
pub(crate) struct Handle<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    client: smithy_client::Client<C, M, R>,
    conf: crate::Config,
}

/// An ergonomic service client for `FmrsService`.
///
/// This client allows ergonomic access to a `FmrsService`-shaped service.
/// Each method corresponds to an endpoint defined in the service's Smithy model,
/// and the request and response shapes are auto-generated from that same model.
///
/// # Using a Client
///
/// Once you have a client set up, you can access the service's endpoints
/// by calling the appropriate method on [`Client`]. Each such method
/// returns a request builder for that endpoint, with methods for setting
/// the various fields of the request. Once your request is complete, use
/// the `send` method to send the request. `send` returns a future, which
/// you then have to `.await` to get the service's response.
///
/// [builder pattern]: https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder
/// [SigV4-signed requests]: https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
#[derive(std::fmt::Debug)]
pub struct Client<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    handle: std::sync::Arc<Handle<C, M, R>>,
}

impl<C, M, R> std::clone::Clone for Client<C, M, R> {
    fn clone(&self) -> Self {
        Self {
            handle: self.handle.clone(),
        }
    }
}

#[doc(inline)]
pub use smithy_client::Builder;

impl<C, M, R> From<smithy_client::Client<C, M, R>> for Client<C, M, R> {
    fn from(client: smithy_client::Client<C, M, R>) -> Self {
        Self::with_config(client, crate::Config::builder().build())
    }
}

impl<C, M, R> Client<C, M, R> {
    pub fn with_config(client: smithy_client::Client<C, M, R>, conf: crate::Config) -> Self {
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl<C, M, R> Client<C, M, R>
where
    C: smithy_client::bounds::SmithyConnector,
    M: smithy_client::bounds::SmithyMiddleware<C>,
    R: smithy_client::retry::NewRequestPolicy,
{
    pub fn cancel_task_execution(&self) -> fluent_builders::CancelTaskExecution<C, M, R> {
        fluent_builders::CancelTaskExecution::new(self.handle.clone())
    }
    pub fn create_agent(&self) -> fluent_builders::CreateAgent<C, M, R> {
        fluent_builders::CreateAgent::new(self.handle.clone())
    }
    pub fn create_location_efs(&self) -> fluent_builders::CreateLocationEfs<C, M, R> {
        fluent_builders::CreateLocationEfs::new(self.handle.clone())
    }
    pub fn create_location_fsx_windows(
        &self,
    ) -> fluent_builders::CreateLocationFsxWindows<C, M, R> {
        fluent_builders::CreateLocationFsxWindows::new(self.handle.clone())
    }
    pub fn create_location_nfs(&self) -> fluent_builders::CreateLocationNfs<C, M, R> {
        fluent_builders::CreateLocationNfs::new(self.handle.clone())
    }
    pub fn create_location_object_storage(
        &self,
    ) -> fluent_builders::CreateLocationObjectStorage<C, M, R> {
        fluent_builders::CreateLocationObjectStorage::new(self.handle.clone())
    }
    pub fn create_location_s3(&self) -> fluent_builders::CreateLocationS3<C, M, R> {
        fluent_builders::CreateLocationS3::new(self.handle.clone())
    }
    pub fn create_location_smb(&self) -> fluent_builders::CreateLocationSmb<C, M, R> {
        fluent_builders::CreateLocationSmb::new(self.handle.clone())
    }
    pub fn create_task(&self) -> fluent_builders::CreateTask<C, M, R> {
        fluent_builders::CreateTask::new(self.handle.clone())
    }
    pub fn delete_agent(&self) -> fluent_builders::DeleteAgent<C, M, R> {
        fluent_builders::DeleteAgent::new(self.handle.clone())
    }
    pub fn delete_location(&self) -> fluent_builders::DeleteLocation<C, M, R> {
        fluent_builders::DeleteLocation::new(self.handle.clone())
    }
    pub fn delete_task(&self) -> fluent_builders::DeleteTask<C, M, R> {
        fluent_builders::DeleteTask::new(self.handle.clone())
    }
    pub fn describe_agent(&self) -> fluent_builders::DescribeAgent<C, M, R> {
        fluent_builders::DescribeAgent::new(self.handle.clone())
    }
    pub fn describe_location_efs(&self) -> fluent_builders::DescribeLocationEfs<C, M, R> {
        fluent_builders::DescribeLocationEfs::new(self.handle.clone())
    }
    pub fn describe_location_fsx_windows(
        &self,
    ) -> fluent_builders::DescribeLocationFsxWindows<C, M, R> {
        fluent_builders::DescribeLocationFsxWindows::new(self.handle.clone())
    }
    pub fn describe_location_nfs(&self) -> fluent_builders::DescribeLocationNfs<C, M, R> {
        fluent_builders::DescribeLocationNfs::new(self.handle.clone())
    }
    pub fn describe_location_object_storage(
        &self,
    ) -> fluent_builders::DescribeLocationObjectStorage<C, M, R> {
        fluent_builders::DescribeLocationObjectStorage::new(self.handle.clone())
    }
    pub fn describe_location_s3(&self) -> fluent_builders::DescribeLocationS3<C, M, R> {
        fluent_builders::DescribeLocationS3::new(self.handle.clone())
    }
    pub fn describe_location_smb(&self) -> fluent_builders::DescribeLocationSmb<C, M, R> {
        fluent_builders::DescribeLocationSmb::new(self.handle.clone())
    }
    pub fn describe_task(&self) -> fluent_builders::DescribeTask<C, M, R> {
        fluent_builders::DescribeTask::new(self.handle.clone())
    }
    pub fn describe_task_execution(&self) -> fluent_builders::DescribeTaskExecution<C, M, R> {
        fluent_builders::DescribeTaskExecution::new(self.handle.clone())
    }
    pub fn list_agents(&self) -> fluent_builders::ListAgents<C, M, R> {
        fluent_builders::ListAgents::new(self.handle.clone())
    }
    pub fn list_locations(&self) -> fluent_builders::ListLocations<C, M, R> {
        fluent_builders::ListLocations::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C, M, R> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn list_task_executions(&self) -> fluent_builders::ListTaskExecutions<C, M, R> {
        fluent_builders::ListTaskExecutions::new(self.handle.clone())
    }
    pub fn list_tasks(&self) -> fluent_builders::ListTasks<C, M, R> {
        fluent_builders::ListTasks::new(self.handle.clone())
    }
    pub fn start_task_execution(&self) -> fluent_builders::StartTaskExecution<C, M, R> {
        fluent_builders::StartTaskExecution::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C, M, R> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C, M, R> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_agent(&self) -> fluent_builders::UpdateAgent<C, M, R> {
        fluent_builders::UpdateAgent::new(self.handle.clone())
    }
    pub fn update_location_nfs(&self) -> fluent_builders::UpdateLocationNfs<C, M, R> {
        fluent_builders::UpdateLocationNfs::new(self.handle.clone())
    }
    pub fn update_location_object_storage(
        &self,
    ) -> fluent_builders::UpdateLocationObjectStorage<C, M, R> {
        fluent_builders::UpdateLocationObjectStorage::new(self.handle.clone())
    }
    pub fn update_location_smb(&self) -> fluent_builders::UpdateLocationSmb<C, M, R> {
        fluent_builders::UpdateLocationSmb::new(self.handle.clone())
    }
    pub fn update_task(&self) -> fluent_builders::UpdateTask<C, M, R> {
        fluent_builders::UpdateTask::new(self.handle.clone())
    }
    pub fn update_task_execution(&self) -> fluent_builders::UpdateTaskExecution<C, M, R> {
        fluent_builders::UpdateTaskExecution::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CancelTaskExecution<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::cancel_task_execution_input::Builder,
    }
    impl<C, M, R> CancelTaskExecution<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelTaskExecutionOutput,
            smithy_http::result::SdkError<crate::error::CancelTaskExecutionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CancelTaskExecutionInputOperationOutputAlias,
                crate::output::CancelTaskExecutionOutput,
                crate::error::CancelTaskExecutionError,
                crate::input::CancelTaskExecutionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the task execution to cancel.</p>
        pub fn task_execution_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_execution_arn(inp);
            self
        }
        pub fn set_task_execution_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_task_execution_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateAgent<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_agent_input::Builder,
    }
    impl<C, M, R> CreateAgent<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateAgentOutput,
            smithy_http::result::SdkError<crate::error::CreateAgentError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateAgentInputOperationOutputAlias,
                crate::output::CreateAgentOutput,
                crate::error::CreateAgentError,
                crate::input::CreateAgentInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Your agent activation key. You can get the activation key either by sending an HTTP GET
        /// request with redirects that enable you to get the agent IP address (port 80). Alternatively,
        /// you can get it from the DataSync console.</p>
        /// <p>The redirect URL returned in the response provides you the activation key for your
        /// agent in the query string parameter <code>activationKey</code>. It might also include other
        /// activation-related parameters; however, these are merely defaults. The arguments you pass to
        /// this API call determine the actual configuration of your agent.</p>
        /// <p>For more information, see Activating an Agent in the <i>DataSync
        /// User Guide.</i>
        /// </p>
        pub fn activation_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.activation_key(inp);
            self
        }
        pub fn set_activation_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_activation_key(input);
            self
        }
        /// <p>The name you configured for your agent. This value is a text reference that is used to
        /// identify the agent in the console.</p>
        pub fn agent_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.agent_name(inp);
            self
        }
        pub fn set_agent_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_agent_name(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The key-value pair that represents the tag that you want to associate with the agent.
        /// The value can be an empty string. This value helps you manage, filter, and search for your
        /// agents.</p>
        /// <note>
        /// <p>Valid characters for key and value are letters, spaces, and numbers representable in
        /// UTF-8 format, and the following special characters: + - = . _ : / @. </p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::TagListEntry>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagListEntry>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The ID of the VPC (virtual private cloud) endpoint that the agent has access to. This is
        /// the client-side VPC endpoint, also called a PrivateLink. If you don't have a PrivateLink VPC
        /// endpoint, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/endpoint-service.html#create-endpoint-service">Creating a VPC Endpoint Service Configuration</a> in the Amazon VPC User Guide.</p>
        /// <p>VPC endpoint ID looks like this: <code>vpce-01234d5aff67890e1</code>.</p>
        pub fn vpc_endpoint_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_endpoint_id(inp);
            self
        }
        pub fn set_vpc_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpc_endpoint_id(input);
            self
        }
        /// Appends an item to `SubnetArns`.
        ///
        /// To override the contents of this collection use [`set_subnet_arns`](Self::set_subnet_arns).
        /// <p>The Amazon Resource Names (ARNs) of the subnets in which DataSync will create elastic
        /// network interfaces for each data transfer task. The agent that runs a task must be private.
        /// When you start a task that is associated with an agent created in a VPC, or one that has
        /// access to an IP address in a VPC, then the task is also private. In this case, DataSync
        /// creates four network interfaces for each task in your subnet. For a data transfer to work, the
        /// agent must be able to route to all these four network interfaces.</p>
        pub fn subnet_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_arns(inp);
            self
        }
        pub fn set_subnet_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subnet_arns(input);
            self
        }
        /// Appends an item to `SecurityGroupArns`.
        ///
        /// To override the contents of this collection use [`set_security_group_arns`](Self::set_security_group_arns).
        /// <p>The ARNs of the security groups used to protect your data transfer task subnets. See <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_Ec2Config.html#DataSync-Type-Ec2Config-SecurityGroupArns">SecurityGroupArns</a>.</p>
        pub fn security_group_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_group_arns(inp);
            self
        }
        pub fn set_security_group_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_security_group_arns(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLocationEfs<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_location_efs_input::Builder,
    }
    impl<C, M, R> CreateLocationEfs<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLocationEfsOutput,
            smithy_http::result::SdkError<crate::error::CreateLocationEfsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateLocationEfsInputOperationOutputAlias,
                crate::output::CreateLocationEfsOutput,
                crate::error::CreateLocationEfsError,
                crate::input::CreateLocationEfsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A subdirectory in the location’s path. This subdirectory in the EFS file system is used
        /// to read data from the EFS source location or write data to the EFS destination. By default,
        /// DataSync uses the root directory.</p>
        /// <note>
        /// <p>
        /// <code>Subdirectory</code> must be specified with forward slashes. For example,
        /// <code>/path/to/folder</code>.</p>
        /// </note>
        pub fn subdirectory(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subdirectory(inp);
            self
        }
        pub fn set_subdirectory(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_subdirectory(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the Amazon EFS file system.</p>
        pub fn efs_filesystem_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.efs_filesystem_arn(inp);
            self
        }
        pub fn set_efs_filesystem_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_efs_filesystem_arn(input);
            self
        }
        /// <p>The subnet and security group that the Amazon EFS file system uses. The security group
        /// that you provide needs to be able to communicate with the security group on the mount target
        /// in the subnet specified.</p>
        /// <p>The exact relationship between security group M (of the mount target) and security
        /// group S (which you provide for DataSync to use at this stage) is as follows: </p>
        /// <ul>
        /// <li>
        /// <p> Security group M (which you associate with the mount target) must allow inbound
        /// access for the Transmission Control Protocol (TCP) on the NFS port (2049) from security
        /// group S. You can enable inbound connections either by IP address (CIDR range) or security
        /// group. </p>
        /// </li>
        /// <li>
        /// <p>Security group S (provided to DataSync to access EFS) should have a rule that
        /// enables outbound connections to the NFS port on one of the file system’s mount targets.
        /// You can enable outbound connections either by IP address (CIDR range) or security
        /// group.</p>
        /// <p>For information about security groups and mount targets, see Security
        /// Groups for Amazon EC2 Instances and Mount Targets in the <i>Amazon EFS User
        /// Guide.</i>
        /// </p>
        /// </li>
        /// </ul>
        pub fn ec2_config(mut self, inp: crate::model::Ec2Config) -> Self {
            self.inner = self.inner.ec2_config(inp);
            self
        }
        pub fn set_ec2_config(
            mut self,
            input: std::option::Option<crate::model::Ec2Config>,
        ) -> Self {
            self.inner = self.inner.set_ec2_config(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The key-value pair that represents a tag that you want to add to the resource. The
        /// value can be an empty string. This value helps you manage, filter, and search for your
        /// resources. We recommend that you create a name tag for your location.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::TagListEntry>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagListEntry>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLocationFsxWindows<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_location_fsx_windows_input::Builder,
    }
    impl<C, M, R> CreateLocationFsxWindows<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLocationFsxWindowsOutput,
            smithy_http::result::SdkError<crate::error::CreateLocationFsxWindowsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateLocationFsxWindowsInputOperationOutputAlias,
                crate::output::CreateLocationFsxWindowsOutput,
                crate::error::CreateLocationFsxWindowsError,
                crate::input::CreateLocationFsxWindowsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A subdirectory in the location’s path. This subdirectory in the Amazon FSx for Windows
        /// File Server file system is used to read data from the Amazon FSx for Windows File Server
        /// source location or write data to the FSx for Windows File Server destination.</p>
        pub fn subdirectory(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subdirectory(inp);
            self
        }
        pub fn set_subdirectory(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_subdirectory(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the FSx for Windows File Server file system.</p>
        pub fn fsx_filesystem_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fsx_filesystem_arn(inp);
            self
        }
        pub fn set_fsx_filesystem_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_fsx_filesystem_arn(input);
            self
        }
        /// Appends an item to `SecurityGroupArns`.
        ///
        /// To override the contents of this collection use [`set_security_group_arns`](Self::set_security_group_arns).
        /// <p>The Amazon Resource Names (ARNs) of the security groups that are to use to configure the
        /// FSx for Windows File Server file system.</p>
        pub fn security_group_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_group_arns(inp);
            self
        }
        pub fn set_security_group_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_security_group_arns(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The key-value pair that represents a tag that you want to add to the resource. The
        /// value can be an empty string. This value helps you manage, filter, and search for your
        /// resources. We recommend that you create a name tag for your location.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::TagListEntry>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagListEntry>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The user who has the permissions to access files and folders in the FSx for Windows File
        /// Server file system.</p>
        /// <p>For information about choosing a user name that ensures sufficient permissions to files,
        /// folders, and metadata, see <a href="create-fsx-location.html#FSxWuser">user</a>.</p>
        pub fn user(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user(inp);
            self
        }
        pub fn set_user(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user(input);
            self
        }
        /// <p>The name of the Windows domain that the FSx for Windows File Server belongs to.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The password of the user who has the permissions to access files and folders in the FSx
        /// for Windows File Server file system.</p>
        pub fn password(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.password(inp);
            self
        }
        pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_password(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLocationNfs<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_location_nfs_input::Builder,
    }
    impl<C, M, R> CreateLocationNfs<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLocationNfsOutput,
            smithy_http::result::SdkError<crate::error::CreateLocationNfsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateLocationNfsInputOperationOutputAlias,
                crate::output::CreateLocationNfsOutput,
                crate::error::CreateLocationNfsError,
                crate::input::CreateLocationNfsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The subdirectory in the NFS file system that is used to read data from the NFS source
        /// location or write data to the NFS destination. The NFS path should be a path that's
        /// exported by the NFS server, or a subdirectory of that path. The path should be such that it
        /// can be mounted by other NFS clients in your network. </p>
        /// <p>To see all the paths exported by your NFS server, run "<code>showmount -e
        /// nfs-server-name</code>" from an NFS client that has access to your server. You can specify
        /// any directory that appears in the results, and any subdirectory of that directory. Ensure that
        /// the NFS export is accessible without Kerberos authentication. </p>
        /// <p>To transfer all the data in the folder you specified, DataSync needs to have
        /// permissions to read all the data. To ensure this, either configure the NFS export with
        /// <code>no_root_squash,</code> or ensure that the permissions for all of the files that you
        /// want DataSync allow read access for all users. Doing either enables the agent to read the
        /// files. For the agent to access directories, you must additionally enable all execute
        /// access.</p>
        /// <p>If you are copying data to or from your Snowcone device, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-nfs-location.html#nfs-on-snowcone">NFS Server on Snowcone</a> for more information.</p>
        /// <p>For information about NFS export configuration, see 18.7. The /etc/exports
        /// Configuration File in the Red Hat Enterprise Linux documentation.</p>
        pub fn subdirectory(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subdirectory(inp);
            self
        }
        pub fn set_subdirectory(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_subdirectory(input);
            self
        }
        /// <p>The name of the NFS server. This value is the IP address or Domain Name Service (DNS)
        /// name of the NFS server. An agent that is installed on-premises uses this host name to mount
        /// the NFS server in a network. </p>
        /// <p>If you are copying data to or from your Snowcone device, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-nfs-location.html#nfs-on-snowcone">NFS Server on Snowcone</a> for more information.</p>
        /// <note>
        /// <p>This name must either be DNS-compliant or must be an IP version 4 (IPv4)
        /// address.</p>
        /// </note>
        pub fn server_hostname(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_hostname(inp);
            self
        }
        pub fn set_server_hostname(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_server_hostname(input);
            self
        }
        /// <p>Contains a list of Amazon Resource Names (ARNs) of agents that are used to connect to
        /// an NFS server. </p>
        /// <p>If you are copying data to or from your Snowcone device, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-nfs-location.html#nfs-on-snowcone">NFS Server on Snowcone</a> for more information.</p>
        pub fn on_prem_config(mut self, inp: crate::model::OnPremConfig) -> Self {
            self.inner = self.inner.on_prem_config(inp);
            self
        }
        pub fn set_on_prem_config(
            mut self,
            input: std::option::Option<crate::model::OnPremConfig>,
        ) -> Self {
            self.inner = self.inner.set_on_prem_config(input);
            self
        }
        /// <p>The NFS mount options that DataSync can use to mount your NFS share.</p>
        pub fn mount_options(mut self, inp: crate::model::NfsMountOptions) -> Self {
            self.inner = self.inner.mount_options(inp);
            self
        }
        pub fn set_mount_options(
            mut self,
            input: std::option::Option<crate::model::NfsMountOptions>,
        ) -> Self {
            self.inner = self.inner.set_mount_options(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The key-value pair that represents the tag that you want to add to the location. The
        /// value can be an empty string. We recommend using tags to name your resources.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::TagListEntry>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagListEntry>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLocationObjectStorage<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_location_object_storage_input::Builder,
    }
    impl<C, M, R> CreateLocationObjectStorage<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLocationObjectStorageOutput,
            smithy_http::result::SdkError<crate::error::CreateLocationObjectStorageError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateLocationObjectStorageInputOperationOutputAlias,
                crate::output::CreateLocationObjectStorageOutput,
                crate::error::CreateLocationObjectStorageError,
                crate::input::CreateLocationObjectStorageInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the self-managed object storage server. This value is the
        /// IP address or Domain Name Service (DNS) name of the object storage server.
        /// An agent uses this host name to mount the object storage server in a network. </p>
        pub fn server_hostname(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_hostname(inp);
            self
        }
        pub fn set_server_hostname(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_server_hostname(input);
            self
        }
        /// <p>The port that your self-managed object storage server accepts inbound network traffic on.
        /// The server port is set by default to TCP 80 (HTTP) or TCP 443 (HTTPS). You can
        /// specify a custom port if your self-managed object storage server requires one.</p>
        pub fn server_port(mut self, inp: i32) -> Self {
            self.inner = self.inner.server_port(inp);
            self
        }
        pub fn set_server_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_server_port(input);
            self
        }
        /// <p>The protocol that the object storage server uses to communicate.
        /// Valid values are HTTP or HTTPS.</p>
        pub fn server_protocol(mut self, inp: crate::model::ObjectStorageServerProtocol) -> Self {
            self.inner = self.inner.server_protocol(inp);
            self
        }
        pub fn set_server_protocol(
            mut self,
            input: std::option::Option<crate::model::ObjectStorageServerProtocol>,
        ) -> Self {
            self.inner = self.inner.set_server_protocol(input);
            self
        }
        /// <p>The subdirectory in the self-managed object storage server that is used
        /// to read data from.</p>
        pub fn subdirectory(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subdirectory(inp);
            self
        }
        pub fn set_subdirectory(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_subdirectory(input);
            self
        }
        /// <p>The bucket on the self-managed object storage server that is used
        /// to read data from.</p>
        pub fn bucket_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket_name(inp);
            self
        }
        pub fn set_bucket_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_bucket_name(input);
            self
        }
        /// <p>Optional. The access key is used if credentials are required to access the self-managed
        /// object storage server. If your object storage requires a user name and password to
        /// authenticate, use <code>AccessKey</code> and <code>SecretKey</code> to provide the user name
        /// and password, respectively.</p>
        pub fn access_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.access_key(inp);
            self
        }
        pub fn set_access_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_access_key(input);
            self
        }
        /// <p>Optional. The secret key is used if credentials are required to access the self-managed
        /// object storage server. If your object storage requires a user name and password to
        /// authenticate, use <code>AccessKey</code> and <code>SecretKey</code> to provide the user name
        /// and password, respectively.</p>
        pub fn secret_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_key(inp);
            self
        }
        pub fn set_secret_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_key(input);
            self
        }
        /// Appends an item to `AgentArns`.
        ///
        /// To override the contents of this collection use [`set_agent_arns`](Self::set_agent_arns).
        /// <p>The Amazon Resource Name (ARN) of the agents associated with the
        /// self-managed object storage server location.</p>
        pub fn agent_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.agent_arns(inp);
            self
        }
        pub fn set_agent_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_agent_arns(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The key-value pair that represents the tag that you want to add to the location. The
        /// value can be an empty string. We recommend using tags to name your resources.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::TagListEntry>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagListEntry>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLocationS3<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_location_s3_input::Builder,
    }
    impl<C, M, R> CreateLocationS3<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLocationS3Output,
            smithy_http::result::SdkError<crate::error::CreateLocationS3Error>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateLocationS3InputOperationOutputAlias,
                crate::output::CreateLocationS3Output,
                crate::error::CreateLocationS3Error,
                crate::input::CreateLocationS3InputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A subdirectory in the Amazon S3 bucket. This subdirectory in Amazon S3 is used to read
        /// data from the S3 source location or write data to the S3 destination.</p>
        pub fn subdirectory(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subdirectory(inp);
            self
        }
        pub fn set_subdirectory(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_subdirectory(input);
            self
        }
        /// <p>The ARN of the Amazon S3 bucket. If the bucket is on an Amazon Web Services Outpost, this must be an
        /// access point ARN.</p>
        pub fn s3_bucket_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.s3_bucket_arn(inp);
            self
        }
        pub fn set_s3_bucket_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_s3_bucket_arn(input);
            self
        }
        /// <p>The Amazon S3 storage class that you want to store your files in when this location is
        /// used as a task destination. For buckets in Amazon Web Services Regions, the storage class defaults to Standard.
        /// For buckets on Outposts, the storage class defaults to Amazon Web Services S3 Outposts.</p>
        /// <p>For more information about S3 storage classes, see <a href="http://aws.amazon.com/s3/storage-classes/">Amazon S3 Storage Classes</a>. Some storage classes have behaviors that
        /// can affect your S3 storage cost. For detailed information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-s3-location.html#using-storage-classes">Considerations when working with S3 storage classes in DataSync</a>.</p>
        pub fn s3_storage_class(mut self, inp: crate::model::S3StorageClass) -> Self {
            self.inner = self.inner.s3_storage_class(inp);
            self
        }
        pub fn set_s3_storage_class(
            mut self,
            input: std::option::Option<crate::model::S3StorageClass>,
        ) -> Self {
            self.inner = self.inner.set_s3_storage_class(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role
        /// that is used to access an Amazon S3 bucket.</p>
        /// <p>For detailed information about using such a role, see Creating a Location for
        /// Amazon S3 in the <i>DataSync User Guide</i>.</p>
        pub fn s3_config(mut self, inp: crate::model::S3Config) -> Self {
            self.inner = self.inner.s3_config(inp);
            self
        }
        pub fn set_s3_config(mut self, input: std::option::Option<crate::model::S3Config>) -> Self {
            self.inner = self.inner.set_s3_config(input);
            self
        }
        /// Appends an item to `AgentArns`.
        ///
        /// To override the contents of this collection use [`set_agent_arns`](Self::set_agent_arns).
        /// <p>If you are using DataSync on an Amazon Web Services Outpost, specify the Amazon Resource Names (ARNs) of
        /// the DataSync agents deployed on your Outpost. For more information about launching a DataSync
        /// agent on an Amazon Web Services Outpost, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/deploy-agents.html#outposts-agent">Deploy your DataSync agent on Outposts</a>.</p>
        pub fn agent_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.agent_arns(inp);
            self
        }
        pub fn set_agent_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_agent_arns(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The key-value pair that represents the tag that you want to add to the location. The
        /// value can be an empty string. We recommend using tags to name your resources.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::TagListEntry>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagListEntry>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLocationSmb<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_location_smb_input::Builder,
    }
    impl<C, M, R> CreateLocationSmb<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLocationSmbOutput,
            smithy_http::result::SdkError<crate::error::CreateLocationSmbError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateLocationSmbInputOperationOutputAlias,
                crate::output::CreateLocationSmbOutput,
                crate::error::CreateLocationSmbError,
                crate::input::CreateLocationSmbInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The subdirectory in the SMB file system that is used to read data from the SMB source
        /// location or write data to the SMB destination. The SMB path should be a path that's
        /// exported by the SMB server, or a subdirectory of that path. The path should be such that it
        /// can be mounted by other SMB clients in your network.</p>
        /// <note>
        /// <p>
        /// <code>Subdirectory</code> must be specified with forward slashes. For example,
        /// <code>/path/to/folder</code>.</p>
        /// </note>
        /// <p>To transfer all the data in the folder you specified, DataSync needs to have permissions
        /// to mount the SMB share, as well as to access all the data in that share. To ensure this,
        /// either ensure that the user/password specified belongs to the user who can mount the share,
        /// and who has the appropriate permissions for all of the files and directories that you want
        /// DataSync to access, or use credentials of a member of the Backup Operators group to mount
        /// the share. Doing either enables the agent to access the data. For the agent to access
        /// directories, you must additionally enable all execute access.</p>
        pub fn subdirectory(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subdirectory(inp);
            self
        }
        pub fn set_subdirectory(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_subdirectory(input);
            self
        }
        /// <p>The name of the SMB server. This value is the IP address or Domain Name Service (DNS) name
        /// of the SMB server. An agent that is installed on-premises uses this hostname to mount the SMB
        /// server in a network.</p>
        /// <note>
        /// <p>This name must either be DNS-compliant or must be an IP version 4 (IPv4) address.</p>
        /// </note>
        pub fn server_hostname(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_hostname(inp);
            self
        }
        pub fn set_server_hostname(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_server_hostname(input);
            self
        }
        /// <p>The user who can mount the share, has the permissions to access files and folders in the
        /// SMB share.</p>
        /// <p>For information about choosing a user name that ensures sufficient permissions to files,
        /// folders, and metadata, see <a href="create-smb-location.html#SMBuser">user</a>.</p>
        pub fn user(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user(inp);
            self
        }
        pub fn set_user(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user(input);
            self
        }
        /// <p>The name of the Windows domain that the SMB server belongs to.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The password of the user who can mount the share, has the permissions to access files and
        /// folders in the SMB share.</p>
        pub fn password(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.password(inp);
            self
        }
        pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_password(input);
            self
        }
        /// Appends an item to `AgentArns`.
        ///
        /// To override the contents of this collection use [`set_agent_arns`](Self::set_agent_arns).
        /// <p>The Amazon Resource Names (ARNs) of agents to use for a Simple Message Block (SMB)
        /// location. </p>
        pub fn agent_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.agent_arns(inp);
            self
        }
        pub fn set_agent_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_agent_arns(input);
            self
        }
        /// <p>The mount options used by DataSync to access the SMB server.</p>
        pub fn mount_options(mut self, inp: crate::model::SmbMountOptions) -> Self {
            self.inner = self.inner.mount_options(inp);
            self
        }
        pub fn set_mount_options(
            mut self,
            input: std::option::Option<crate::model::SmbMountOptions>,
        ) -> Self {
            self.inner = self.inner.set_mount_options(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The key-value pair that represents the tag that you want to add to the location. The value
        /// can be an empty string. We recommend using tags to name your resources.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::TagListEntry>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagListEntry>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTask<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_task_input::Builder,
    }
    impl<C, M, R> CreateTask<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTaskOutput,
            smithy_http::result::SdkError<crate::error::CreateTaskError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateTaskInputOperationOutputAlias,
                crate::output::CreateTaskOutput,
                crate::error::CreateTaskError,
                crate::input::CreateTaskInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the source location for the task.</p>
        pub fn source_location_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_location_arn(inp);
            self
        }
        pub fn set_source_location_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_location_arn(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an Amazon Web Services storage resource's location. </p>
        pub fn destination_location_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_location_arn(inp);
            self
        }
        pub fn set_destination_location_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_location_arn(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon CloudWatch log group that is used to
        /// monitor and log events in the task. </p>
        pub fn cloud_watch_log_group_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cloud_watch_log_group_arn(inp);
            self
        }
        pub fn set_cloud_watch_log_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_cloud_watch_log_group_arn(input);
            self
        }
        /// <p>The name of a task. This value is a text reference that is used to identify the task in
        /// the console. </p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The set of configuration options that control the behavior of a single execution of the
        /// task that occurs when you call <code>StartTaskExecution</code>. You can configure these
        /// options to preserve metadata such as user ID (UID) and group ID (GID), file permissions, data
        /// integrity verification, and so on.</p>
        /// <p>For each individual task execution, you can override these options by specifying the
        /// <code>OverrideOptions</code> before starting the task execution. For more information, see
        /// the <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a> operation. </p>
        pub fn options(mut self, inp: crate::model::Options) -> Self {
            self.inner = self.inner.options(inp);
            self
        }
        pub fn set_options(mut self, input: std::option::Option<crate::model::Options>) -> Self {
            self.inner = self.inner.set_options(input);
            self
        }
        /// Appends an item to `Excludes`.
        ///
        /// To override the contents of this collection use [`set_excludes`](Self::set_excludes).
        /// <p>A list of filter rules that determines which files to exclude from a task. The list should
        /// contain a single filter string that consists of the patterns to exclude. The patterns are
        /// delimited by "|" (that is, a pipe), for example, <code>"/folder1|/folder2"</code>. </p>
        /// <p>
        /// </p>
        pub fn excludes(mut self, inp: impl Into<crate::model::FilterRule>) -> Self {
            self.inner = self.inner.excludes(inp);
            self
        }
        pub fn set_excludes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FilterRule>>,
        ) -> Self {
            self.inner = self.inner.set_excludes(input);
            self
        }
        /// <p>Specifies a schedule used to periodically transfer files from a source to a destination
        /// location. The schedule should be specified in UTC time. For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/task-scheduling.html">Scheduling your task</a>.</p>
        pub fn schedule(mut self, inp: crate::model::TaskSchedule) -> Self {
            self.inner = self.inner.schedule(inp);
            self
        }
        pub fn set_schedule(
            mut self,
            input: std::option::Option<crate::model::TaskSchedule>,
        ) -> Self {
            self.inner = self.inner.set_schedule(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The key-value pair that represents the tag that you want to add to the resource. The
        /// value can be an empty string. </p>
        pub fn tags(mut self, inp: impl Into<crate::model::TagListEntry>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagListEntry>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// Appends an item to `Includes`.
        ///
        /// To override the contents of this collection use [`set_includes`](Self::set_includes).
        /// <p>A list of filter rules that determines which files to include when running a task. The
        /// pattern should contain a single filter string that consists of the patterns to include. The
        /// patterns are delimited by "|" (that is, a pipe). For example:
        /// <code>"/folder1|/folder2</code>"</p>
        pub fn includes(mut self, inp: impl Into<crate::model::FilterRule>) -> Self {
            self.inner = self.inner.includes(inp);
            self
        }
        pub fn set_includes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FilterRule>>,
        ) -> Self {
            self.inner = self.inner.set_includes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAgent<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_agent_input::Builder,
    }
    impl<C, M, R> DeleteAgent<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteAgentOutput,
            smithy_http::result::SdkError<crate::error::DeleteAgentError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteAgentInputOperationOutputAlias,
                crate::output::DeleteAgentOutput,
                crate::error::DeleteAgentError,
                crate::input::DeleteAgentInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the agent to delete. Use the <code>ListAgents</code>
        /// operation to return a list of agents for your account and Amazon Web Services Region.</p>
        pub fn agent_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.agent_arn(inp);
            self
        }
        pub fn set_agent_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_agent_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLocation<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_location_input::Builder,
    }
    impl<C, M, R> DeleteLocation<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLocationOutput,
            smithy_http::result::SdkError<crate::error::DeleteLocationError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteLocationInputOperationOutputAlias,
                crate::output::DeleteLocationOutput,
                crate::error::DeleteLocationError,
                crate::input::DeleteLocationInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the location to delete.</p>
        pub fn location_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location_arn(inp);
            self
        }
        pub fn set_location_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTask<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_task_input::Builder,
    }
    impl<C, M, R> DeleteTask<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTaskOutput,
            smithy_http::result::SdkError<crate::error::DeleteTaskError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteTaskInputOperationOutputAlias,
                crate::output::DeleteTaskOutput,
                crate::error::DeleteTaskError,
                crate::input::DeleteTaskInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the task to delete.</p>
        pub fn task_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_arn(inp);
            self
        }
        pub fn set_task_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAgent<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_agent_input::Builder,
    }
    impl<C, M, R> DescribeAgent<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAgentOutput,
            smithy_http::result::SdkError<crate::error::DescribeAgentError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeAgentInputOperationOutputAlias,
                crate::output::DescribeAgentOutput,
                crate::error::DescribeAgentError,
                crate::input::DescribeAgentInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the agent to describe.</p>
        pub fn agent_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.agent_arn(inp);
            self
        }
        pub fn set_agent_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_agent_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLocationEfs<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_location_efs_input::Builder,
    }
    impl<C, M, R> DescribeLocationEfs<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLocationEfsOutput,
            smithy_http::result::SdkError<crate::error::DescribeLocationEfsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeLocationEfsInputOperationOutputAlias,
                crate::output::DescribeLocationEfsOutput,
                crate::error::DescribeLocationEfsError,
                crate::input::DescribeLocationEfsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the EFS location to describe.</p>
        pub fn location_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location_arn(inp);
            self
        }
        pub fn set_location_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLocationFsxWindows<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_location_fsx_windows_input::Builder,
    }
    impl<C, M, R> DescribeLocationFsxWindows<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLocationFsxWindowsOutput,
            smithy_http::result::SdkError<crate::error::DescribeLocationFsxWindowsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeLocationFsxWindowsInputOperationOutputAlias,
                crate::output::DescribeLocationFsxWindowsOutput,
                crate::error::DescribeLocationFsxWindowsError,
                crate::input::DescribeLocationFsxWindowsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the FSx for Windows File Server location to
        /// describe.</p>
        pub fn location_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location_arn(inp);
            self
        }
        pub fn set_location_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLocationNfs<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_location_nfs_input::Builder,
    }
    impl<C, M, R> DescribeLocationNfs<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLocationNfsOutput,
            smithy_http::result::SdkError<crate::error::DescribeLocationNfsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeLocationNfsInputOperationOutputAlias,
                crate::output::DescribeLocationNfsOutput,
                crate::error::DescribeLocationNfsError,
                crate::input::DescribeLocationNfsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the NFS location to describe.</p>
        pub fn location_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location_arn(inp);
            self
        }
        pub fn set_location_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLocationObjectStorage<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_location_object_storage_input::Builder,
    }
    impl<C, M, R> DescribeLocationObjectStorage<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLocationObjectStorageOutput,
            smithy_http::result::SdkError<crate::error::DescribeLocationObjectStorageError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeLocationObjectStorageInputOperationOutputAlias,
                crate::output::DescribeLocationObjectStorageOutput,
                crate::error::DescribeLocationObjectStorageError,
                crate::input::DescribeLocationObjectStorageInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the self-managed object storage server location that was described.</p>
        pub fn location_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location_arn(inp);
            self
        }
        pub fn set_location_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLocationS3<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_location_s3_input::Builder,
    }
    impl<C, M, R> DescribeLocationS3<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLocationS3Output,
            smithy_http::result::SdkError<crate::error::DescribeLocationS3Error>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeLocationS3InputOperationOutputAlias,
                crate::output::DescribeLocationS3Output,
                crate::error::DescribeLocationS3Error,
                crate::input::DescribeLocationS3InputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon S3 bucket location to describe.</p>
        pub fn location_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location_arn(inp);
            self
        }
        pub fn set_location_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLocationSmb<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_location_smb_input::Builder,
    }
    impl<C, M, R> DescribeLocationSmb<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLocationSmbOutput,
            smithy_http::result::SdkError<crate::error::DescribeLocationSmbError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeLocationSmbInputOperationOutputAlias,
                crate::output::DescribeLocationSmbOutput,
                crate::error::DescribeLocationSmbError,
                crate::input::DescribeLocationSmbInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the SMB location to describe.</p>
        pub fn location_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location_arn(inp);
            self
        }
        pub fn set_location_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTask<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_task_input::Builder,
    }
    impl<C, M, R> DescribeTask<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTaskOutput,
            smithy_http::result::SdkError<crate::error::DescribeTaskError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeTaskInputOperationOutputAlias,
                crate::output::DescribeTaskOutput,
                crate::error::DescribeTaskError,
                crate::input::DescribeTaskInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the task to describe.</p>
        pub fn task_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_arn(inp);
            self
        }
        pub fn set_task_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTaskExecution<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_task_execution_input::Builder,
    }
    impl<C, M, R> DescribeTaskExecution<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTaskExecutionOutput,
            smithy_http::result::SdkError<crate::error::DescribeTaskExecutionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeTaskExecutionInputOperationOutputAlias,
                crate::output::DescribeTaskExecutionOutput,
                crate::error::DescribeTaskExecutionError,
                crate::input::DescribeTaskExecutionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the task that is being executed.</p>
        pub fn task_execution_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_execution_arn(inp);
            self
        }
        pub fn set_task_execution_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_task_execution_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAgents<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_agents_input::Builder,
    }
    impl<C, M, R> ListAgents<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListAgentsOutput,
            smithy_http::result::SdkError<crate::error::ListAgentsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListAgentsInputOperationOutputAlias,
                crate::output::ListAgentsOutput,
                crate::error::ListAgentsError,
                crate::input::ListAgentsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of agents to list.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>An opaque string that indicates the position at which to begin the next list of
        /// agents.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListLocations<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_locations_input::Builder,
    }
    impl<C, M, R> ListLocations<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListLocationsOutput,
            smithy_http::result::SdkError<crate::error::ListLocationsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListLocationsInputOperationOutputAlias,
                crate::output::ListLocationsOutput,
                crate::error::ListLocationsError,
                crate::input::ListLocationsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of locations to return.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>An opaque string that indicates the position at which to begin the next list of
        /// locations.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// Appends an item to `Filters`.
        ///
        /// To override the contents of this collection use [`set_filters`](Self::set_filters).
        /// <p>You can use API filters to narrow down the list of resources returned by <code>ListLocations</code>.
        /// For example, to retrieve all tasks on a specific source location, you can use <code>ListLocations</code>
        /// with filter name <code>LocationType S3</code> and <code>Operator Equals</code>.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::LocationFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LocationFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C, M, R> ListTagsForResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListTagsForResourceInputOperationOutputAlias,
                crate::output::ListTagsForResourceOutput,
                crate::error::ListTagsForResourceError,
                crate::input::ListTagsForResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource whose tags to list.</p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The maximum number of locations to return.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>An opaque string that indicates the position at which to begin the next list of
        /// locations.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTaskExecutions<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_task_executions_input::Builder,
    }
    impl<C, M, R> ListTaskExecutions<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTaskExecutionsOutput,
            smithy_http::result::SdkError<crate::error::ListTaskExecutionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListTaskExecutionsInputOperationOutputAlias,
                crate::output::ListTaskExecutionsOutput,
                crate::error::ListTaskExecutionsError,
                crate::input::ListTaskExecutionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the task whose tasks you want to list.</p>
        pub fn task_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_arn(inp);
            self
        }
        pub fn set_task_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_arn(input);
            self
        }
        /// <p>The maximum number of executed tasks to list.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>An opaque string that indicates the position at which to begin the next list of the
        /// executed tasks.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTasks<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_tasks_input::Builder,
    }
    impl<C, M, R> ListTasks<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTasksOutput,
            smithy_http::result::SdkError<crate::error::ListTasksError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListTasksInputOperationOutputAlias,
                crate::output::ListTasksOutput,
                crate::error::ListTasksError,
                crate::input::ListTasksInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of tasks to return.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>An opaque string that indicates the position at which to begin the next list of
        /// tasks.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// Appends an item to `Filters`.
        ///
        /// To override the contents of this collection use [`set_filters`](Self::set_filters).
        /// <p>You can use API filters to narrow down the list of resources returned by <code>ListTasks</code>.
        /// For example, to retrieve all tasks on a specific source location, you can use <code>ListTasks</code>
        /// with filter name <code>LocationId</code> and <code>Operator Equals</code> with the ARN for the
        /// location.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::TaskFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TaskFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartTaskExecution<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::start_task_execution_input::Builder,
    }
    impl<C, M, R> StartTaskExecution<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartTaskExecutionOutput,
            smithy_http::result::SdkError<crate::error::StartTaskExecutionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StartTaskExecutionInputOperationOutputAlias,
                crate::output::StartTaskExecutionOutput,
                crate::error::StartTaskExecutionError,
                crate::input::StartTaskExecutionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the task to start.</p>
        pub fn task_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_arn(inp);
            self
        }
        pub fn set_task_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_arn(input);
            self
        }
        /// <p>Represents the options that are available to control the behavior of a
        /// <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a>
        /// operation. Behavior includes preserving metadata such as user
        /// ID (UID), group ID (GID), and file permissions, and also overwriting files in the destination,
        /// data integrity verification, and so on.</p>
        /// <p>A task has a set of default options associated with it. If you don't specify an option
        /// in <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a>,
        /// the default value is used. You can override the
        /// defaults options on each task execution by specifying an overriding <code>Options</code> value
        /// to <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a>.</p>
        pub fn override_options(mut self, inp: crate::model::Options) -> Self {
            self.inner = self.inner.override_options(inp);
            self
        }
        pub fn set_override_options(
            mut self,
            input: std::option::Option<crate::model::Options>,
        ) -> Self {
            self.inner = self.inner.set_override_options(input);
            self
        }
        /// Appends an item to `Includes`.
        ///
        /// To override the contents of this collection use [`set_includes`](Self::set_includes).
        /// <p>A list of filter rules that determines which files to include when running a task. The
        /// pattern should contain a single filter string that consists of the patterns to include. The
        /// patterns are delimited by "|" (that is, a pipe). For example: <code>"/folder1|/folder2"</code>
        /// </p>
        /// <p>
        /// </p>
        pub fn includes(mut self, inp: impl Into<crate::model::FilterRule>) -> Self {
            self.inner = self.inner.includes(inp);
            self
        }
        pub fn set_includes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FilterRule>>,
        ) -> Self {
            self.inner = self.inner.set_includes(input);
            self
        }
        /// Appends an item to `Excludes`.
        ///
        /// To override the contents of this collection use [`set_excludes`](Self::set_excludes).
        /// <p>A list of filter rules that determines which files to exclude from a task. The list
        /// should contain a single filter string that consists of the patterns to exclude. The
        /// patterns are delimited by "|" (that is, a pipe), for example,
        /// <code>"/folder1|/folder2"</code>. </p>
        pub fn excludes(mut self, inp: impl Into<crate::model::FilterRule>) -> Self {
            self.inner = self.inner.excludes(inp);
            self
        }
        pub fn set_excludes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FilterRule>>,
        ) -> Self {
            self.inner = self.inner.set_excludes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C, M, R> TagResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::TagResourceInputOperationOutputAlias,
                crate::output::TagResourceOutput,
                crate::error::TagResourceError,
                crate::input::TagResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource to apply the tag to.</p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The tags to apply.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::TagListEntry>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagListEntry>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C, M, R> UntagResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UntagResourceInputOperationOutputAlias,
                crate::output::UntagResourceOutput,
                crate::error::UntagResourceError,
                crate::input::UntagResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource to remove the tag from.</p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// Appends an item to `Keys`.
        ///
        /// To override the contents of this collection use [`set_keys`](Self::set_keys).
        /// <p>The keys in the key-value pair in the tag to remove.</p>
        pub fn keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.keys(inp);
            self
        }
        pub fn set_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateAgent<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_agent_input::Builder,
    }
    impl<C, M, R> UpdateAgent<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateAgentOutput,
            smithy_http::result::SdkError<crate::error::UpdateAgentError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateAgentInputOperationOutputAlias,
                crate::output::UpdateAgentOutput,
                crate::error::UpdateAgentError,
                crate::input::UpdateAgentInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the agent to update.</p>
        pub fn agent_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.agent_arn(inp);
            self
        }
        pub fn set_agent_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_agent_arn(input);
            self
        }
        /// <p>The name that you want to use to configure the agent.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateLocationNfs<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_location_nfs_input::Builder,
    }
    impl<C, M, R> UpdateLocationNfs<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateLocationNfsOutput,
            smithy_http::result::SdkError<crate::error::UpdateLocationNfsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateLocationNfsInputOperationOutputAlias,
                crate::output::UpdateLocationNfsOutput,
                crate::error::UpdateLocationNfsError,
                crate::input::UpdateLocationNfsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the NFS location to update.</p>
        pub fn location_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location_arn(inp);
            self
        }
        pub fn set_location_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location_arn(input);
            self
        }
        /// <p>The subdirectory in the NFS file system that is used to read data from the NFS source
        /// location or write data to the NFS destination. The NFS path should be a path that's
        /// exported by the NFS server, or a subdirectory of that path. The path should be such that it
        /// can be mounted by other NFS clients in your network.</p>
        /// <p>To see all the paths exported by your NFS server, run "<code>showmount -e
        /// nfs-server-name</code>" from an NFS client that has access to your server. You can specify
        /// any directory that appears in the results, and any subdirectory of that directory. Ensure that
        /// the NFS export is accessible without Kerberos authentication. </p>
        /// <p>To transfer all the data in the folder that you specified, DataSync must have
        /// permissions to read all the data. To ensure this, either configure the NFS export with
        /// <code>no_root_squash</code>, or ensure that the files you want DataSync to
        /// access have permissions that allow read access for all users. Doing either option enables the
        /// agent to read the files. For the agent to access directories, you must additionally enable all
        /// execute access.</p>
        /// <p>If you are copying data to or from your Snowcone device, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-nfs-location.html#nfs-on-snowcone">NFS Server on Snowcone</a> for more information.</p>
        /// <p>For information about NFS export configuration, see 18.7. The /etc/exports
        /// Configuration File in the Red Hat Enterprise Linux documentation.</p>
        pub fn subdirectory(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subdirectory(inp);
            self
        }
        pub fn set_subdirectory(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_subdirectory(input);
            self
        }
        /// <p>A list of Amazon Resource Names (ARNs) of agents to use for a Network File System (NFS)
        /// location.</p>
        pub fn on_prem_config(mut self, inp: crate::model::OnPremConfig) -> Self {
            self.inner = self.inner.on_prem_config(inp);
            self
        }
        pub fn set_on_prem_config(
            mut self,
            input: std::option::Option<crate::model::OnPremConfig>,
        ) -> Self {
            self.inner = self.inner.set_on_prem_config(input);
            self
        }
        /// <p>Represents the mount options that are available for DataSync to access an NFS
        /// location.</p>
        pub fn mount_options(mut self, inp: crate::model::NfsMountOptions) -> Self {
            self.inner = self.inner.mount_options(inp);
            self
        }
        pub fn set_mount_options(
            mut self,
            input: std::option::Option<crate::model::NfsMountOptions>,
        ) -> Self {
            self.inner = self.inner.set_mount_options(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateLocationObjectStorage<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_location_object_storage_input::Builder,
    }
    impl<C, M, R> UpdateLocationObjectStorage<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateLocationObjectStorageOutput,
            smithy_http::result::SdkError<crate::error::UpdateLocationObjectStorageError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateLocationObjectStorageInputOperationOutputAlias,
                crate::output::UpdateLocationObjectStorageOutput,
                crate::error::UpdateLocationObjectStorageError,
                crate::input::UpdateLocationObjectStorageInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the self-managed object storage server location to be updated.</p>
        pub fn location_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location_arn(inp);
            self
        }
        pub fn set_location_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location_arn(input);
            self
        }
        /// <p>The port that your self-managed object storage server accepts inbound network traffic on.
        /// The server port is set by default to TCP 80 (HTTP) or TCP 443 (HTTPS). You can
        /// specify a custom port if your self-managed object storage server requires one.</p>
        pub fn server_port(mut self, inp: i32) -> Self {
            self.inner = self.inner.server_port(inp);
            self
        }
        pub fn set_server_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_server_port(input);
            self
        }
        /// <p>The protocol that the object storage server uses to communicate. Valid values are
        /// <code>HTTP</code> or <code>HTTPS</code>.</p>
        pub fn server_protocol(mut self, inp: crate::model::ObjectStorageServerProtocol) -> Self {
            self.inner = self.inner.server_protocol(inp);
            self
        }
        pub fn set_server_protocol(
            mut self,
            input: std::option::Option<crate::model::ObjectStorageServerProtocol>,
        ) -> Self {
            self.inner = self.inner.set_server_protocol(input);
            self
        }
        /// <p>The subdirectory in the self-managed object storage server that is used
        /// to read data from.</p>
        pub fn subdirectory(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subdirectory(inp);
            self
        }
        pub fn set_subdirectory(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_subdirectory(input);
            self
        }
        /// <p>Optional. The access key is used if credentials are required to access the self-managed
        /// object storage server. If your object storage requires a user name and password to
        /// authenticate, use <code>AccessKey</code> and <code>SecretKey</code> to provide the user name
        /// and password, respectively.</p>
        pub fn access_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.access_key(inp);
            self
        }
        pub fn set_access_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_access_key(input);
            self
        }
        /// <p>Optional. The secret key is used if credentials are required to access the self-managed
        /// object storage server. If your object storage requires a user name and password to
        /// authenticate, use <code>AccessKey</code> and <code>SecretKey</code> to provide the user name
        /// and password, respectively.</p>
        pub fn secret_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_key(inp);
            self
        }
        pub fn set_secret_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_key(input);
            self
        }
        /// Appends an item to `AgentArns`.
        ///
        /// To override the contents of this collection use [`set_agent_arns`](Self::set_agent_arns).
        /// <p>The Amazon Resource Name (ARN) of the agents associated with the
        /// self-managed object storage server location.</p>
        pub fn agent_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.agent_arns(inp);
            self
        }
        pub fn set_agent_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_agent_arns(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateLocationSmb<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_location_smb_input::Builder,
    }
    impl<C, M, R> UpdateLocationSmb<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateLocationSmbOutput,
            smithy_http::result::SdkError<crate::error::UpdateLocationSmbError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateLocationSmbInputOperationOutputAlias,
                crate::output::UpdateLocationSmbOutput,
                crate::error::UpdateLocationSmbError,
                crate::input::UpdateLocationSmbInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the SMB location to update.</p>
        pub fn location_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location_arn(inp);
            self
        }
        pub fn set_location_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location_arn(input);
            self
        }
        /// <p>The subdirectory in the SMB file system that is used to read data from the SMB source
        /// location or write data to the SMB destination. The SMB path should be a path that's
        /// exported by the SMB server, or a subdirectory of that path. The path should be such that it
        /// can be mounted by other SMB clients in your network.</p>
        /// <note>
        /// <p>
        /// <code>Subdirectory</code> must be specified with forward slashes. For example,
        /// <code>/path/to/folder</code>.</p>
        /// </note>
        /// <p>To transfer all the data in the folder that you specified, DataSync must have
        /// permissions to mount the SMB share and to access all the data in that share. To ensure this,
        /// do either of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Ensure that the user/password specified belongs to the user who can mount the share
        /// and who has the appropriate permissions for all of the files and directories that you want
        /// DataSync to access.</p>
        /// </li>
        /// <li>
        /// <p>Use credentials of a member of the Backup Operators group to mount the share. </p>
        /// </li>
        /// </ul>
        /// <p>Doing either of these options enables the agent to access the data. For the agent to
        /// access directories, you must also enable all execute access.</p>
        pub fn subdirectory(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subdirectory(inp);
            self
        }
        pub fn set_subdirectory(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_subdirectory(input);
            self
        }
        /// <p>The user who can mount the share has the permissions to access files and folders in the
        /// SMB share.</p>
        pub fn user(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user(inp);
            self
        }
        pub fn set_user(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user(input);
            self
        }
        /// <p>The name of the Windows domain that the SMB server belongs to.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The password of the user who can mount the share has the permissions to access files and
        /// folders in the SMB share.</p>
        pub fn password(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.password(inp);
            self
        }
        pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_password(input);
            self
        }
        /// Appends an item to `AgentArns`.
        ///
        /// To override the contents of this collection use [`set_agent_arns`](Self::set_agent_arns).
        /// <p>The Amazon Resource Names (ARNs) of agents to use for a Simple Message Block (SMB)
        /// location.</p>
        pub fn agent_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.agent_arns(inp);
            self
        }
        pub fn set_agent_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_agent_arns(input);
            self
        }
        /// <p>Represents the mount options that are available for DataSync to access an SMB
        /// location.</p>
        pub fn mount_options(mut self, inp: crate::model::SmbMountOptions) -> Self {
            self.inner = self.inner.mount_options(inp);
            self
        }
        pub fn set_mount_options(
            mut self,
            input: std::option::Option<crate::model::SmbMountOptions>,
        ) -> Self {
            self.inner = self.inner.set_mount_options(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateTask<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_task_input::Builder,
    }
    impl<C, M, R> UpdateTask<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateTaskOutput,
            smithy_http::result::SdkError<crate::error::UpdateTaskError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateTaskInputOperationOutputAlias,
                crate::output::UpdateTaskOutput,
                crate::error::UpdateTaskError,
                crate::input::UpdateTaskInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource name of the task to update.</p>
        pub fn task_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_arn(inp);
            self
        }
        pub fn set_task_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_arn(input);
            self
        }
        /// <p>Represents the options that are available to control the behavior of a
        /// <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a>
        /// operation. Behavior includes preserving metadata such as user
        /// ID (UID), group ID (GID), and file permissions, and also overwriting files in the destination,
        /// data integrity verification, and so on.</p>
        /// <p>A task has a set of default options associated with it. If you don't specify an option
        /// in <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a>,
        /// the default value is used. You can override the
        /// defaults options on each task execution by specifying an overriding <code>Options</code> value
        /// to <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a>.</p>
        pub fn options(mut self, inp: crate::model::Options) -> Self {
            self.inner = self.inner.options(inp);
            self
        }
        pub fn set_options(mut self, input: std::option::Option<crate::model::Options>) -> Self {
            self.inner = self.inner.set_options(input);
            self
        }
        /// Appends an item to `Excludes`.
        ///
        /// To override the contents of this collection use [`set_excludes`](Self::set_excludes).
        /// <p>A list of filter rules that determines which files to exclude from a task. The list should
        /// contain a single filter string that consists of the patterns to exclude. The patterns are
        /// delimited by "|" (that is, a pipe), for example: <code>"/folder1|/folder2"</code>
        /// </p>
        /// <p>
        /// </p>
        pub fn excludes(mut self, inp: impl Into<crate::model::FilterRule>) -> Self {
            self.inner = self.inner.excludes(inp);
            self
        }
        pub fn set_excludes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FilterRule>>,
        ) -> Self {
            self.inner = self.inner.set_excludes(input);
            self
        }
        /// <p>Specifies a schedule used to periodically transfer files from a source to a destination
        /// location. You can configure your task to execute hourly, daily, weekly or on specific days of
        /// the week. You control when in the day or hour you want the task to execute. The time you
        /// specify is UTC time. For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/task-scheduling.html">Scheduling your task</a>.</p>
        pub fn schedule(mut self, inp: crate::model::TaskSchedule) -> Self {
            self.inner = self.inner.schedule(inp);
            self
        }
        pub fn set_schedule(
            mut self,
            input: std::option::Option<crate::model::TaskSchedule>,
        ) -> Self {
            self.inner = self.inner.set_schedule(input);
            self
        }
        /// <p>The name of the task to update.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource name of the CloudWatch
        /// LogGroup.</p>
        pub fn cloud_watch_log_group_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cloud_watch_log_group_arn(inp);
            self
        }
        pub fn set_cloud_watch_log_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_cloud_watch_log_group_arn(input);
            self
        }
        /// Appends an item to `Includes`.
        ///
        /// To override the contents of this collection use [`set_includes`](Self::set_includes).
        /// <p>A list of filter rules that determines which files to include when running a task. The
        /// pattern should contain a single filter string that consists of the patterns to include. The
        /// patterns are delimited by "|" (that is, a pipe). For example:
        /// <code>"/folder1|/folder2</code>"</p>
        pub fn includes(mut self, inp: impl Into<crate::model::FilterRule>) -> Self {
            self.inner = self.inner.includes(inp);
            self
        }
        pub fn set_includes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FilterRule>>,
        ) -> Self {
            self.inner = self.inner.set_includes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateTaskExecution<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_task_execution_input::Builder,
    }
    impl<C, M, R> UpdateTaskExecution<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateTaskExecutionOutput,
            smithy_http::result::SdkError<crate::error::UpdateTaskExecutionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateTaskExecutionInputOperationOutputAlias,
                crate::output::UpdateTaskExecutionOutput,
                crate::error::UpdateTaskExecutionError,
                crate::input::UpdateTaskExecutionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the specific task execution that is being updated. </p>
        pub fn task_execution_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_execution_arn(inp);
            self
        }
        pub fn set_task_execution_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_task_execution_arn(input);
            self
        }
        /// <p>Represents the options that are available to control the behavior of a
        /// <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a>
        /// operation. Behavior includes preserving metadata such as user
        /// ID (UID), group ID (GID), and file permissions, and also overwriting files in the destination,
        /// data integrity verification, and so on.</p>
        /// <p>A task has a set of default options associated with it. If you don't specify an option
        /// in <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a>,
        /// the default value is used. You can override the
        /// defaults options on each task execution by specifying an overriding <code>Options</code> value
        /// to <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_StartTaskExecution.html">StartTaskExecution</a>.</p>
        pub fn options(mut self, inp: crate::model::Options) -> Self {
            self.inner = self.inner.options(inp);
            self
        }
        pub fn set_options(mut self, input: std::option::Option<crate::model::Options>) -> Self {
            self.inner = self.inner.set_options(input);
            self
        }
    }
}
impl<C> Client<C, aws_hyper::AwsMiddleware, smithy_client::retry::Standard> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl
    Client<
        smithy_client::erase::DynConnector,
        aws_hyper::AwsMiddleware,
        smithy_client::retry::Standard,
    >
{
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn new(config: &aws_types::config::Config) -> Self {
        Self::from_conf(config.into())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
