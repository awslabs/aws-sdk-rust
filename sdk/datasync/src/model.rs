// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Configures your DataSync task settings. These options include how DataSync handles files, objects, and their associated metadata. You also can specify how DataSync verifies data integrity, set bandwidth limits for your task, among other options.</p>
/// <p>Each task setting has a default value. Unless you need to, you don't have to configure any of these <code>Options</code> before starting your task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Options {
    /// <p>Specifies how and when DataSync checks the integrity of your data during a transfer. </p>
    /// <p>Default value: <code>POINT_IN_TIME_CONSISTENT</code> </p>
    /// <p> <code>ONLY_FILES_TRANSFERRED</code> (recommended): DataSync calculates the checksum of transferred files and metadata at the source location. At the end of the transfer, DataSync then compares this checksum to the checksum calculated on those files at the destination.</p>
    /// <p>We recommend this option when transferring to S3 Glacier Flexible Retrieval or S3 Glacier Deep Archive storage classes. For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-s3-location.html#using-storage-classes">Storage class considerations with Amazon S3 locations</a>.</p>
    /// <p> <code>POINT_IN_TIME_CONSISTENT</code>: At the end of the transfer, DataSync scans the entire source and destination to verify that both locations are fully synchronized.</p>
    /// <p>You can't use this option when transferring to S3 Glacier Flexible Retrieval or S3 Glacier Deep Archive storage classes. For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-s3-location.html#using-storage-classes">Storage class considerations with Amazon S3 locations</a>.</p>
    /// <p> <code>NONE</code>: DataSync doesn't run additional verification at the end of the transfer. All data transmissions are still integrity-checked with checksum verification during the transfer.</p>
    #[doc(hidden)]
    pub verify_mode: std::option::Option<crate::model::VerifyMode>,
    /// <p>Specifies whether data at the destination location should be overwritten or preserved. If set to <code>NEVER</code>, a destination file for example will not be replaced by a source file (even if the destination file differs from the source file). If you modify files in the destination and you sync the files, you can use this value to protect against overwriting those changes. </p>
    /// <p>Some storage classes have specific behaviors that can affect your Amazon S3 storage cost. For detailed information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-s3-location.html#using-storage-classes">Considerations when working with Amazon S3 storage classes in DataSync </a>.</p>
    #[doc(hidden)]
    pub overwrite_mode: std::option::Option<crate::model::OverwriteMode>,
    /// <p>Specifies whether to preserve metadata indicating the last time a file was read or written to. If you set <code>Atime</code> to <code>BEST_EFFORT</code>, DataSync attempts to preserve the original <code>Atime</code> attribute on all source files (that is, the version before the <code>PREPARING</code> phase of the task execution).</p> <note>
    /// <p>The behavior of <code>Atime</code> isn't fully standard across platforms, so DataSync can only do this on a best-effort basis.</p>
    /// </note>
    /// <p>Default value: <code>BEST_EFFORT</code> </p>
    /// <p> <code>BEST_EFFORT</code>: Attempt to preserve the per-file <code>Atime</code> value (recommended).</p>
    /// <p> <code>NONE</code>: Ignore <code>Atime</code>.</p> <note>
    /// <p>If <code>Atime</code> is set to <code>BEST_EFFORT</code>, <code>Mtime</code> must be set to <code>PRESERVE</code>. </p>
    /// <p>If <code>Atime</code> is set to <code>NONE</code>, <code>Mtime</code> must also be <code>NONE</code>. </p>
    /// </note>
    #[doc(hidden)]
    pub atime: std::option::Option<crate::model::Atime>,
    /// <p>Specifies whether to preserve metadata indicating the last time that a file was written to before the <code>PREPARING</code> phase of your task execution. This option is required when you need to run the a task more than once.</p>
    /// <p>Default Value: <code>PRESERVE</code> </p>
    /// <p> <code>PRESERVE</code>: Preserve original <code>Mtime</code> (recommended)</p>
    /// <p> <code>NONE</code>: Ignore <code>Mtime</code>. </p> <note>
    /// <p>If <code>Mtime</code> is set to <code>PRESERVE</code>, <code>Atime</code> must be set to <code>BEST_EFFORT</code>.</p>
    /// <p>If <code>Mtime</code> is set to <code>NONE</code>, <code>Atime</code> must also be set to <code>NONE</code>. </p>
    /// </note>
    #[doc(hidden)]
    pub mtime: std::option::Option<crate::model::Mtime>,
    /// <p>Specifies the POSIX user ID (UID) of the file's owner.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/special-files.html#metadata-copied">Metadata copied by DataSync</a>.</p>
    /// <p>Default value: <code>INT_VALUE</code>. This preserves the integer value of the ID.</p>
    /// <p> <code>INT_VALUE</code>: Preserve the integer value of UID and group ID (GID) (recommended).</p>
    /// <p> <code>NONE</code>: Ignore UID and GID. </p>
    #[doc(hidden)]
    pub uid: std::option::Option<crate::model::Uid>,
    /// <p>Specifies the POSIX group ID (GID) of the file's owners.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/special-files.html#metadata-copied">Metadata copied by DataSync</a>.</p>
    /// <p>Default value: <code>INT_VALUE</code>. This preserves the integer value of the ID.</p>
    /// <p> <code>INT_VALUE</code>: Preserve the integer value of user ID (UID) and GID (recommended).</p>
    /// <p> <code>NONE</code>: Ignore UID and GID.</p>
    #[doc(hidden)]
    pub gid: std::option::Option<crate::model::Gid>,
    /// <p>Specifies whether files in the destination location that don't exist in the source should be preserved. This option can affect your Amazon S3 storage cost. If your task deletes objects, you might incur minimum storage duration charges for certain storage classes. For detailed information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-s3-location.html#using-storage-classes">Considerations when working with Amazon S3 storage classes in DataSync </a>.</p>
    /// <p>Default value: <code>PRESERVE</code> </p>
    /// <p> <code>PRESERVE</code>: Ignore such destination files (recommended). </p>
    /// <p> <code>REMOVE</code>: Delete destination files that arenâ€™t present in the source.</p>
    #[doc(hidden)]
    pub preserve_deleted_files: std::option::Option<crate::model::PreserveDeletedFiles>,
    /// <p>Specifies whether DataSync should preserve the metadata of block and character devices in the source location and recreate the files with that device name and metadata on the destination. DataSync copies only the name and metadata of such devices.</p> <note>
    /// <p>DataSync can't copy the actual contents of these devices because they're nonterminal and don't return an end-of-file (EOF) marker.</p>
    /// </note>
    /// <p>Default value: <code>NONE</code> </p>
    /// <p> <code>NONE</code>: Ignore special devices (recommended). </p>
    /// <p> <code>PRESERVE</code>: Preserve character and block device metadata. This option currently isn't supported for Amazon EFS. </p>
    #[doc(hidden)]
    pub preserve_devices: std::option::Option<crate::model::PreserveDevices>,
    /// <p>Specifies which users or groups can access a file for a specific purpose such as reading, writing, or execution of the file.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/special-files.html#metadata-copied">Metadata copied by DataSync</a>.</p>
    /// <p>Default value: <code>PRESERVE</code> </p>
    /// <p> <code>PRESERVE</code>: Preserve POSIX-style permissions (recommended).</p>
    /// <p> <code>NONE</code>: Ignore permissions. </p> <note>
    /// <p>DataSync can preserve extant permissions of a source location.</p>
    /// </note>
    #[doc(hidden)]
    pub posix_permissions: std::option::Option<crate::model::PosixPermissions>,
    /// <p>Limits the bandwidth used by a DataSync task. For example, if you want DataSync to use a maximum of 1 MB, set this value to <code>1048576</code> (<code>=1024*1024</code>).</p>
    #[doc(hidden)]
    pub bytes_per_second: std::option::Option<i64>,
    /// <p>Specifies whether tasks should be queued before executing the tasks. The default is <code>ENABLED</code>, which means the tasks will be queued.</p>
    /// <p>If you use the same agent to run multiple tasks, you can enable the tasks to run in series. For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/run-task.html#queue-task-execution">Queueing task executions</a>.</p>
    #[doc(hidden)]
    pub task_queueing: std::option::Option<crate::model::TaskQueueing>,
    /// <p>Specifies the type of logs that DataSync publishes to a Amazon CloudWatch Logs log group. To specify the log group, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_CreateTask.html#DataSync-CreateTask-request-CloudWatchLogGroupArn">CloudWatchLogGroupArn</a>.</p>
    /// <p>If you set <code>LogLevel</code> to <code>OFF</code>, no logs are published. <code>BASIC</code> publishes logs on errors for individual files transferred. <code>TRANSFER</code> publishes logs for every file or object that is transferred and integrity checked.</p>
    #[doc(hidden)]
    pub log_level: std::option::Option<crate::model::LogLevel>,
    /// <p>Determines whether DataSync transfers only the data and metadata that differ between the source and the destination location or transfers all the content from the source (without comparing what's in the destination).</p>
    /// <p> <code>CHANGED</code>: DataSync copies only data or metadata that is new or different content from the source location to the destination location.</p>
    /// <p> <code>ALL</code>: DataSync copies all source location content to the destination (without comparing what's in the destination).</p>
    #[doc(hidden)]
    pub transfer_mode: std::option::Option<crate::model::TransferMode>,
    /// <p>Specifies which components of the SMB security descriptor are copied from source to destination objects. </p>
    /// <p>This value is only used for transfers between SMB and Amazon FSx for Windows File Server locations or between two FSx for Windows File Server locations. For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/special-files.html">how DataSync handles metadata</a>.</p>
    /// <p>Default value: <code>OWNER_DACL</code> </p>
    /// <p> <code>OWNER_DACL</code>: For each copied object, DataSync copies the following metadata:</p>
    /// <ul>
    /// <li> <p>The object owner.</p> </li>
    /// <li> <p>NTFS discretionary access control lists (DACLs), which determine whether to grant access to an object.</p> <p>DataSync won't copy NTFS system access control lists (SACLs) with this option.</p> </li>
    /// </ul>
    /// <p> <code>OWNER_DACL_SACL</code>: For each copied object, DataSync copies the following metadata:</p>
    /// <ul>
    /// <li> <p>The object owner.</p> </li>
    /// <li> <p>NTFS discretionary access control lists (DACLs), which determine whether to grant access to an object.</p> </li>
    /// <li> <p>SACLs, which are used by administrators to log attempts to access a secured object.</p> <p>Copying SACLs requires granting additional permissions to the Windows user that DataSync uses to access your SMB location. For information about choosing a user that ensures sufficient permissions to files, folders, and metadata, see <a href="create-smb-location.html#SMBuser">user</a>.</p> </li>
    /// </ul>
    /// <p> <code>NONE</code>: None of the SMB security descriptor components are copied. Destination objects are owned by the user that was provided for accessing the destination location. DACLs and SACLs are set based on the destination serverâ€™s configuration. </p>
    #[doc(hidden)]
    pub security_descriptor_copy_flags:
        std::option::Option<crate::model::SmbSecurityDescriptorCopyFlags>,
    /// <p>Specifies whether object tags are preserved when transferring between object storage systems. If you want your DataSync task to ignore object tags, specify the <code>NONE</code> value.</p>
    /// <p>Default Value: <code>PRESERVE</code> </p>
    #[doc(hidden)]
    pub object_tags: std::option::Option<crate::model::ObjectTags>,
}
impl Options {
    /// <p>Specifies how and when DataSync checks the integrity of your data during a transfer. </p>
    /// <p>Default value: <code>POINT_IN_TIME_CONSISTENT</code> </p>
    /// <p> <code>ONLY_FILES_TRANSFERRED</code> (recommended): DataSync calculates the checksum of transferred files and metadata at the source location. At the end of the transfer, DataSync then compares this checksum to the checksum calculated on those files at the destination.</p>
    /// <p>We recommend this option when transferring to S3 Glacier Flexible Retrieval or S3 Glacier Deep Archive storage classes. For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-s3-location.html#using-storage-classes">Storage class considerations with Amazon S3 locations</a>.</p>
    /// <p> <code>POINT_IN_TIME_CONSISTENT</code>: At the end of the transfer, DataSync scans the entire source and destination to verify that both locations are fully synchronized.</p>
    /// <p>You can't use this option when transferring to S3 Glacier Flexible Retrieval or S3 Glacier Deep Archive storage classes. For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-s3-location.html#using-storage-classes">Storage class considerations with Amazon S3 locations</a>.</p>
    /// <p> <code>NONE</code>: DataSync doesn't run additional verification at the end of the transfer. All data transmissions are still integrity-checked with checksum verification during the transfer.</p>
    pub fn verify_mode(&self) -> std::option::Option<&crate::model::VerifyMode> {
        self.verify_mode.as_ref()
    }
    /// <p>Specifies whether data at the destination location should be overwritten or preserved. If set to <code>NEVER</code>, a destination file for example will not be replaced by a source file (even if the destination file differs from the source file). If you modify files in the destination and you sync the files, you can use this value to protect against overwriting those changes. </p>
    /// <p>Some storage classes have specific behaviors that can affect your Amazon S3 storage cost. For detailed information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-s3-location.html#using-storage-classes">Considerations when working with Amazon S3 storage classes in DataSync </a>.</p>
    pub fn overwrite_mode(&self) -> std::option::Option<&crate::model::OverwriteMode> {
        self.overwrite_mode.as_ref()
    }
    /// <p>Specifies whether to preserve metadata indicating the last time a file was read or written to. If you set <code>Atime</code> to <code>BEST_EFFORT</code>, DataSync attempts to preserve the original <code>Atime</code> attribute on all source files (that is, the version before the <code>PREPARING</code> phase of the task execution).</p> <note>
    /// <p>The behavior of <code>Atime</code> isn't fully standard across platforms, so DataSync can only do this on a best-effort basis.</p>
    /// </note>
    /// <p>Default value: <code>BEST_EFFORT</code> </p>
    /// <p> <code>BEST_EFFORT</code>: Attempt to preserve the per-file <code>Atime</code> value (recommended).</p>
    /// <p> <code>NONE</code>: Ignore <code>Atime</code>.</p> <note>
    /// <p>If <code>Atime</code> is set to <code>BEST_EFFORT</code>, <code>Mtime</code> must be set to <code>PRESERVE</code>. </p>
    /// <p>If <code>Atime</code> is set to <code>NONE</code>, <code>Mtime</code> must also be <code>NONE</code>. </p>
    /// </note>
    pub fn atime(&self) -> std::option::Option<&crate::model::Atime> {
        self.atime.as_ref()
    }
    /// <p>Specifies whether to preserve metadata indicating the last time that a file was written to before the <code>PREPARING</code> phase of your task execution. This option is required when you need to run the a task more than once.</p>
    /// <p>Default Value: <code>PRESERVE</code> </p>
    /// <p> <code>PRESERVE</code>: Preserve original <code>Mtime</code> (recommended)</p>
    /// <p> <code>NONE</code>: Ignore <code>Mtime</code>. </p> <note>
    /// <p>If <code>Mtime</code> is set to <code>PRESERVE</code>, <code>Atime</code> must be set to <code>BEST_EFFORT</code>.</p>
    /// <p>If <code>Mtime</code> is set to <code>NONE</code>, <code>Atime</code> must also be set to <code>NONE</code>. </p>
    /// </note>
    pub fn mtime(&self) -> std::option::Option<&crate::model::Mtime> {
        self.mtime.as_ref()
    }
    /// <p>Specifies the POSIX user ID (UID) of the file's owner.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/special-files.html#metadata-copied">Metadata copied by DataSync</a>.</p>
    /// <p>Default value: <code>INT_VALUE</code>. This preserves the integer value of the ID.</p>
    /// <p> <code>INT_VALUE</code>: Preserve the integer value of UID and group ID (GID) (recommended).</p>
    /// <p> <code>NONE</code>: Ignore UID and GID. </p>
    pub fn uid(&self) -> std::option::Option<&crate::model::Uid> {
        self.uid.as_ref()
    }
    /// <p>Specifies the POSIX group ID (GID) of the file's owners.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/special-files.html#metadata-copied">Metadata copied by DataSync</a>.</p>
    /// <p>Default value: <code>INT_VALUE</code>. This preserves the integer value of the ID.</p>
    /// <p> <code>INT_VALUE</code>: Preserve the integer value of user ID (UID) and GID (recommended).</p>
    /// <p> <code>NONE</code>: Ignore UID and GID.</p>
    pub fn gid(&self) -> std::option::Option<&crate::model::Gid> {
        self.gid.as_ref()
    }
    /// <p>Specifies whether files in the destination location that don't exist in the source should be preserved. This option can affect your Amazon S3 storage cost. If your task deletes objects, you might incur minimum storage duration charges for certain storage classes. For detailed information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-s3-location.html#using-storage-classes">Considerations when working with Amazon S3 storage classes in DataSync </a>.</p>
    /// <p>Default value: <code>PRESERVE</code> </p>
    /// <p> <code>PRESERVE</code>: Ignore such destination files (recommended). </p>
    /// <p> <code>REMOVE</code>: Delete destination files that arenâ€™t present in the source.</p>
    pub fn preserve_deleted_files(
        &self,
    ) -> std::option::Option<&crate::model::PreserveDeletedFiles> {
        self.preserve_deleted_files.as_ref()
    }
    /// <p>Specifies whether DataSync should preserve the metadata of block and character devices in the source location and recreate the files with that device name and metadata on the destination. DataSync copies only the name and metadata of such devices.</p> <note>
    /// <p>DataSync can't copy the actual contents of these devices because they're nonterminal and don't return an end-of-file (EOF) marker.</p>
    /// </note>
    /// <p>Default value: <code>NONE</code> </p>
    /// <p> <code>NONE</code>: Ignore special devices (recommended). </p>
    /// <p> <code>PRESERVE</code>: Preserve character and block device metadata. This option currently isn't supported for Amazon EFS. </p>
    pub fn preserve_devices(&self) -> std::option::Option<&crate::model::PreserveDevices> {
        self.preserve_devices.as_ref()
    }
    /// <p>Specifies which users or groups can access a file for a specific purpose such as reading, writing, or execution of the file.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/special-files.html#metadata-copied">Metadata copied by DataSync</a>.</p>
    /// <p>Default value: <code>PRESERVE</code> </p>
    /// <p> <code>PRESERVE</code>: Preserve POSIX-style permissions (recommended).</p>
    /// <p> <code>NONE</code>: Ignore permissions. </p> <note>
    /// <p>DataSync can preserve extant permissions of a source location.</p>
    /// </note>
    pub fn posix_permissions(&self) -> std::option::Option<&crate::model::PosixPermissions> {
        self.posix_permissions.as_ref()
    }
    /// <p>Limits the bandwidth used by a DataSync task. For example, if you want DataSync to use a maximum of 1 MB, set this value to <code>1048576</code> (<code>=1024*1024</code>).</p>
    pub fn bytes_per_second(&self) -> std::option::Option<i64> {
        self.bytes_per_second
    }
    /// <p>Specifies whether tasks should be queued before executing the tasks. The default is <code>ENABLED</code>, which means the tasks will be queued.</p>
    /// <p>If you use the same agent to run multiple tasks, you can enable the tasks to run in series. For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/run-task.html#queue-task-execution">Queueing task executions</a>.</p>
    pub fn task_queueing(&self) -> std::option::Option<&crate::model::TaskQueueing> {
        self.task_queueing.as_ref()
    }
    /// <p>Specifies the type of logs that DataSync publishes to a Amazon CloudWatch Logs log group. To specify the log group, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_CreateTask.html#DataSync-CreateTask-request-CloudWatchLogGroupArn">CloudWatchLogGroupArn</a>.</p>
    /// <p>If you set <code>LogLevel</code> to <code>OFF</code>, no logs are published. <code>BASIC</code> publishes logs on errors for individual files transferred. <code>TRANSFER</code> publishes logs for every file or object that is transferred and integrity checked.</p>
    pub fn log_level(&self) -> std::option::Option<&crate::model::LogLevel> {
        self.log_level.as_ref()
    }
    /// <p>Determines whether DataSync transfers only the data and metadata that differ between the source and the destination location or transfers all the content from the source (without comparing what's in the destination).</p>
    /// <p> <code>CHANGED</code>: DataSync copies only data or metadata that is new or different content from the source location to the destination location.</p>
    /// <p> <code>ALL</code>: DataSync copies all source location content to the destination (without comparing what's in the destination).</p>
    pub fn transfer_mode(&self) -> std::option::Option<&crate::model::TransferMode> {
        self.transfer_mode.as_ref()
    }
    /// <p>Specifies which components of the SMB security descriptor are copied from source to destination objects. </p>
    /// <p>This value is only used for transfers between SMB and Amazon FSx for Windows File Server locations or between two FSx for Windows File Server locations. For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/special-files.html">how DataSync handles metadata</a>.</p>
    /// <p>Default value: <code>OWNER_DACL</code> </p>
    /// <p> <code>OWNER_DACL</code>: For each copied object, DataSync copies the following metadata:</p>
    /// <ul>
    /// <li> <p>The object owner.</p> </li>
    /// <li> <p>NTFS discretionary access control lists (DACLs), which determine whether to grant access to an object.</p> <p>DataSync won't copy NTFS system access control lists (SACLs) with this option.</p> </li>
    /// </ul>
    /// <p> <code>OWNER_DACL_SACL</code>: For each copied object, DataSync copies the following metadata:</p>
    /// <ul>
    /// <li> <p>The object owner.</p> </li>
    /// <li> <p>NTFS discretionary access control lists (DACLs), which determine whether to grant access to an object.</p> </li>
    /// <li> <p>SACLs, which are used by administrators to log attempts to access a secured object.</p> <p>Copying SACLs requires granting additional permissions to the Windows user that DataSync uses to access your SMB location. For information about choosing a user that ensures sufficient permissions to files, folders, and metadata, see <a href="create-smb-location.html#SMBuser">user</a>.</p> </li>
    /// </ul>
    /// <p> <code>NONE</code>: None of the SMB security descriptor components are copied. Destination objects are owned by the user that was provided for accessing the destination location. DACLs and SACLs are set based on the destination serverâ€™s configuration. </p>
    pub fn security_descriptor_copy_flags(
        &self,
    ) -> std::option::Option<&crate::model::SmbSecurityDescriptorCopyFlags> {
        self.security_descriptor_copy_flags.as_ref()
    }
    /// <p>Specifies whether object tags are preserved when transferring between object storage systems. If you want your DataSync task to ignore object tags, specify the <code>NONE</code> value.</p>
    /// <p>Default Value: <code>PRESERVE</code> </p>
    pub fn object_tags(&self) -> std::option::Option<&crate::model::ObjectTags> {
        self.object_tags.as_ref()
    }
}
/// See [`Options`](crate::model::Options).
pub mod options {

    /// A builder for [`Options`](crate::model::Options).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) verify_mode: std::option::Option<crate::model::VerifyMode>,
        pub(crate) overwrite_mode: std::option::Option<crate::model::OverwriteMode>,
        pub(crate) atime: std::option::Option<crate::model::Atime>,
        pub(crate) mtime: std::option::Option<crate::model::Mtime>,
        pub(crate) uid: std::option::Option<crate::model::Uid>,
        pub(crate) gid: std::option::Option<crate::model::Gid>,
        pub(crate) preserve_deleted_files: std::option::Option<crate::model::PreserveDeletedFiles>,
        pub(crate) preserve_devices: std::option::Option<crate::model::PreserveDevices>,
        pub(crate) posix_permissions: std::option::Option<crate::model::PosixPermissions>,
        pub(crate) bytes_per_second: std::option::Option<i64>,
        pub(crate) task_queueing: std::option::Option<crate::model::TaskQueueing>,
        pub(crate) log_level: std::option::Option<crate::model::LogLevel>,
        pub(crate) transfer_mode: std::option::Option<crate::model::TransferMode>,
        pub(crate) security_descriptor_copy_flags:
            std::option::Option<crate::model::SmbSecurityDescriptorCopyFlags>,
        pub(crate) object_tags: std::option::Option<crate::model::ObjectTags>,
    }
    impl Builder {
        /// <p>Specifies how and when DataSync checks the integrity of your data during a transfer. </p>
        /// <p>Default value: <code>POINT_IN_TIME_CONSISTENT</code> </p>
        /// <p> <code>ONLY_FILES_TRANSFERRED</code> (recommended): DataSync calculates the checksum of transferred files and metadata at the source location. At the end of the transfer, DataSync then compares this checksum to the checksum calculated on those files at the destination.</p>
        /// <p>We recommend this option when transferring to S3 Glacier Flexible Retrieval or S3 Glacier Deep Archive storage classes. For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-s3-location.html#using-storage-classes">Storage class considerations with Amazon S3 locations</a>.</p>
        /// <p> <code>POINT_IN_TIME_CONSISTENT</code>: At the end of the transfer, DataSync scans the entire source and destination to verify that both locations are fully synchronized.</p>
        /// <p>You can't use this option when transferring to S3 Glacier Flexible Retrieval or S3 Glacier Deep Archive storage classes. For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-s3-location.html#using-storage-classes">Storage class considerations with Amazon S3 locations</a>.</p>
        /// <p> <code>NONE</code>: DataSync doesn't run additional verification at the end of the transfer. All data transmissions are still integrity-checked with checksum verification during the transfer.</p>
        pub fn verify_mode(mut self, input: crate::model::VerifyMode) -> Self {
            self.verify_mode = Some(input);
            self
        }
        /// <p>Specifies how and when DataSync checks the integrity of your data during a transfer. </p>
        /// <p>Default value: <code>POINT_IN_TIME_CONSISTENT</code> </p>
        /// <p> <code>ONLY_FILES_TRANSFERRED</code> (recommended): DataSync calculates the checksum of transferred files and metadata at the source location. At the end of the transfer, DataSync then compares this checksum to the checksum calculated on those files at the destination.</p>
        /// <p>We recommend this option when transferring to S3 Glacier Flexible Retrieval or S3 Glacier Deep Archive storage classes. For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-s3-location.html#using-storage-classes">Storage class considerations with Amazon S3 locations</a>.</p>
        /// <p> <code>POINT_IN_TIME_CONSISTENT</code>: At the end of the transfer, DataSync scans the entire source and destination to verify that both locations are fully synchronized.</p>
        /// <p>You can't use this option when transferring to S3 Glacier Flexible Retrieval or S3 Glacier Deep Archive storage classes. For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-s3-location.html#using-storage-classes">Storage class considerations with Amazon S3 locations</a>.</p>
        /// <p> <code>NONE</code>: DataSync doesn't run additional verification at the end of the transfer. All data transmissions are still integrity-checked with checksum verification during the transfer.</p>
        pub fn set_verify_mode(
            mut self,
            input: std::option::Option<crate::model::VerifyMode>,
        ) -> Self {
            self.verify_mode = input;
            self
        }
        /// <p>Specifies whether data at the destination location should be overwritten or preserved. If set to <code>NEVER</code>, a destination file for example will not be replaced by a source file (even if the destination file differs from the source file). If you modify files in the destination and you sync the files, you can use this value to protect against overwriting those changes. </p>
        /// <p>Some storage classes have specific behaviors that can affect your Amazon S3 storage cost. For detailed information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-s3-location.html#using-storage-classes">Considerations when working with Amazon S3 storage classes in DataSync </a>.</p>
        pub fn overwrite_mode(mut self, input: crate::model::OverwriteMode) -> Self {
            self.overwrite_mode = Some(input);
            self
        }
        /// <p>Specifies whether data at the destination location should be overwritten or preserved. If set to <code>NEVER</code>, a destination file for example will not be replaced by a source file (even if the destination file differs from the source file). If you modify files in the destination and you sync the files, you can use this value to protect against overwriting those changes. </p>
        /// <p>Some storage classes have specific behaviors that can affect your Amazon S3 storage cost. For detailed information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-s3-location.html#using-storage-classes">Considerations when working with Amazon S3 storage classes in DataSync </a>.</p>
        pub fn set_overwrite_mode(
            mut self,
            input: std::option::Option<crate::model::OverwriteMode>,
        ) -> Self {
            self.overwrite_mode = input;
            self
        }
        /// <p>Specifies whether to preserve metadata indicating the last time a file was read or written to. If you set <code>Atime</code> to <code>BEST_EFFORT</code>, DataSync attempts to preserve the original <code>Atime</code> attribute on all source files (that is, the version before the <code>PREPARING</code> phase of the task execution).</p> <note>
        /// <p>The behavior of <code>Atime</code> isn't fully standard across platforms, so DataSync can only do this on a best-effort basis.</p>
        /// </note>
        /// <p>Default value: <code>BEST_EFFORT</code> </p>
        /// <p> <code>BEST_EFFORT</code>: Attempt to preserve the per-file <code>Atime</code> value (recommended).</p>
        /// <p> <code>NONE</code>: Ignore <code>Atime</code>.</p> <note>
        /// <p>If <code>Atime</code> is set to <code>BEST_EFFORT</code>, <code>Mtime</code> must be set to <code>PRESERVE</code>. </p>
        /// <p>If <code>Atime</code> is set to <code>NONE</code>, <code>Mtime</code> must also be <code>NONE</code>. </p>
        /// </note>
        pub fn atime(mut self, input: crate::model::Atime) -> Self {
            self.atime = Some(input);
            self
        }
        /// <p>Specifies whether to preserve metadata indicating the last time a file was read or written to. If you set <code>Atime</code> to <code>BEST_EFFORT</code>, DataSync attempts to preserve the original <code>Atime</code> attribute on all source files (that is, the version before the <code>PREPARING</code> phase of the task execution).</p> <note>
        /// <p>The behavior of <code>Atime</code> isn't fully standard across platforms, so DataSync can only do this on a best-effort basis.</p>
        /// </note>
        /// <p>Default value: <code>BEST_EFFORT</code> </p>
        /// <p> <code>BEST_EFFORT</code>: Attempt to preserve the per-file <code>Atime</code> value (recommended).</p>
        /// <p> <code>NONE</code>: Ignore <code>Atime</code>.</p> <note>
        /// <p>If <code>Atime</code> is set to <code>BEST_EFFORT</code>, <code>Mtime</code> must be set to <code>PRESERVE</code>. </p>
        /// <p>If <code>Atime</code> is set to <code>NONE</code>, <code>Mtime</code> must also be <code>NONE</code>. </p>
        /// </note>
        pub fn set_atime(mut self, input: std::option::Option<crate::model::Atime>) -> Self {
            self.atime = input;
            self
        }
        /// <p>Specifies whether to preserve metadata indicating the last time that a file was written to before the <code>PREPARING</code> phase of your task execution. This option is required when you need to run the a task more than once.</p>
        /// <p>Default Value: <code>PRESERVE</code> </p>
        /// <p> <code>PRESERVE</code>: Preserve original <code>Mtime</code> (recommended)</p>
        /// <p> <code>NONE</code>: Ignore <code>Mtime</code>. </p> <note>
        /// <p>If <code>Mtime</code> is set to <code>PRESERVE</code>, <code>Atime</code> must be set to <code>BEST_EFFORT</code>.</p>
        /// <p>If <code>Mtime</code> is set to <code>NONE</code>, <code>Atime</code> must also be set to <code>NONE</code>. </p>
        /// </note>
        pub fn mtime(mut self, input: crate::model::Mtime) -> Self {
            self.mtime = Some(input);
            self
        }
        /// <p>Specifies whether to preserve metadata indicating the last time that a file was written to before the <code>PREPARING</code> phase of your task execution. This option is required when you need to run the a task more than once.</p>
        /// <p>Default Value: <code>PRESERVE</code> </p>
        /// <p> <code>PRESERVE</code>: Preserve original <code>Mtime</code> (recommended)</p>
        /// <p> <code>NONE</code>: Ignore <code>Mtime</code>. </p> <note>
        /// <p>If <code>Mtime</code> is set to <code>PRESERVE</code>, <code>Atime</code> must be set to <code>BEST_EFFORT</code>.</p>
        /// <p>If <code>Mtime</code> is set to <code>NONE</code>, <code>Atime</code> must also be set to <code>NONE</code>. </p>
        /// </note>
        pub fn set_mtime(mut self, input: std::option::Option<crate::model::Mtime>) -> Self {
            self.mtime = input;
            self
        }
        /// <p>Specifies the POSIX user ID (UID) of the file's owner.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/special-files.html#metadata-copied">Metadata copied by DataSync</a>.</p>
        /// <p>Default value: <code>INT_VALUE</code>. This preserves the integer value of the ID.</p>
        /// <p> <code>INT_VALUE</code>: Preserve the integer value of UID and group ID (GID) (recommended).</p>
        /// <p> <code>NONE</code>: Ignore UID and GID. </p>
        pub fn uid(mut self, input: crate::model::Uid) -> Self {
            self.uid = Some(input);
            self
        }
        /// <p>Specifies the POSIX user ID (UID) of the file's owner.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/special-files.html#metadata-copied">Metadata copied by DataSync</a>.</p>
        /// <p>Default value: <code>INT_VALUE</code>. This preserves the integer value of the ID.</p>
        /// <p> <code>INT_VALUE</code>: Preserve the integer value of UID and group ID (GID) (recommended).</p>
        /// <p> <code>NONE</code>: Ignore UID and GID. </p>
        pub fn set_uid(mut self, input: std::option::Option<crate::model::Uid>) -> Self {
            self.uid = input;
            self
        }
        /// <p>Specifies the POSIX group ID (GID) of the file's owners.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/special-files.html#metadata-copied">Metadata copied by DataSync</a>.</p>
        /// <p>Default value: <code>INT_VALUE</code>. This preserves the integer value of the ID.</p>
        /// <p> <code>INT_VALUE</code>: Preserve the integer value of user ID (UID) and GID (recommended).</p>
        /// <p> <code>NONE</code>: Ignore UID and GID.</p>
        pub fn gid(mut self, input: crate::model::Gid) -> Self {
            self.gid = Some(input);
            self
        }
        /// <p>Specifies the POSIX group ID (GID) of the file's owners.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/special-files.html#metadata-copied">Metadata copied by DataSync</a>.</p>
        /// <p>Default value: <code>INT_VALUE</code>. This preserves the integer value of the ID.</p>
        /// <p> <code>INT_VALUE</code>: Preserve the integer value of user ID (UID) and GID (recommended).</p>
        /// <p> <code>NONE</code>: Ignore UID and GID.</p>
        pub fn set_gid(mut self, input: std::option::Option<crate::model::Gid>) -> Self {
            self.gid = input;
            self
        }
        /// <p>Specifies whether files in the destination location that don't exist in the source should be preserved. This option can affect your Amazon S3 storage cost. If your task deletes objects, you might incur minimum storage duration charges for certain storage classes. For detailed information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-s3-location.html#using-storage-classes">Considerations when working with Amazon S3 storage classes in DataSync </a>.</p>
        /// <p>Default value: <code>PRESERVE</code> </p>
        /// <p> <code>PRESERVE</code>: Ignore such destination files (recommended). </p>
        /// <p> <code>REMOVE</code>: Delete destination files that arenâ€™t present in the source.</p>
        pub fn preserve_deleted_files(mut self, input: crate::model::PreserveDeletedFiles) -> Self {
            self.preserve_deleted_files = Some(input);
            self
        }
        /// <p>Specifies whether files in the destination location that don't exist in the source should be preserved. This option can affect your Amazon S3 storage cost. If your task deletes objects, you might incur minimum storage duration charges for certain storage classes. For detailed information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-s3-location.html#using-storage-classes">Considerations when working with Amazon S3 storage classes in DataSync </a>.</p>
        /// <p>Default value: <code>PRESERVE</code> </p>
        /// <p> <code>PRESERVE</code>: Ignore such destination files (recommended). </p>
        /// <p> <code>REMOVE</code>: Delete destination files that arenâ€™t present in the source.</p>
        pub fn set_preserve_deleted_files(
            mut self,
            input: std::option::Option<crate::model::PreserveDeletedFiles>,
        ) -> Self {
            self.preserve_deleted_files = input;
            self
        }
        /// <p>Specifies whether DataSync should preserve the metadata of block and character devices in the source location and recreate the files with that device name and metadata on the destination. DataSync copies only the name and metadata of such devices.</p> <note>
        /// <p>DataSync can't copy the actual contents of these devices because they're nonterminal and don't return an end-of-file (EOF) marker.</p>
        /// </note>
        /// <p>Default value: <code>NONE</code> </p>
        /// <p> <code>NONE</code>: Ignore special devices (recommended). </p>
        /// <p> <code>PRESERVE</code>: Preserve character and block device metadata. This option currently isn't supported for Amazon EFS. </p>
        pub fn preserve_devices(mut self, input: crate::model::PreserveDevices) -> Self {
            self.preserve_devices = Some(input);
            self
        }
        /// <p>Specifies whether DataSync should preserve the metadata of block and character devices in the source location and recreate the files with that device name and metadata on the destination. DataSync copies only the name and metadata of such devices.</p> <note>
        /// <p>DataSync can't copy the actual contents of these devices because they're nonterminal and don't return an end-of-file (EOF) marker.</p>
        /// </note>
        /// <p>Default value: <code>NONE</code> </p>
        /// <p> <code>NONE</code>: Ignore special devices (recommended). </p>
        /// <p> <code>PRESERVE</code>: Preserve character and block device metadata. This option currently isn't supported for Amazon EFS. </p>
        pub fn set_preserve_devices(
            mut self,
            input: std::option::Option<crate::model::PreserveDevices>,
        ) -> Self {
            self.preserve_devices = input;
            self
        }
        /// <p>Specifies which users or groups can access a file for a specific purpose such as reading, writing, or execution of the file.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/special-files.html#metadata-copied">Metadata copied by DataSync</a>.</p>
        /// <p>Default value: <code>PRESERVE</code> </p>
        /// <p> <code>PRESERVE</code>: Preserve POSIX-style permissions (recommended).</p>
        /// <p> <code>NONE</code>: Ignore permissions. </p> <note>
        /// <p>DataSync can preserve extant permissions of a source location.</p>
        /// </note>
        pub fn posix_permissions(mut self, input: crate::model::PosixPermissions) -> Self {
            self.posix_permissions = Some(input);
            self
        }
        /// <p>Specifies which users or groups can access a file for a specific purpose such as reading, writing, or execution of the file.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/special-files.html#metadata-copied">Metadata copied by DataSync</a>.</p>
        /// <p>Default value: <code>PRESERVE</code> </p>
        /// <p> <code>PRESERVE</code>: Preserve POSIX-style permissions (recommended).</p>
        /// <p> <code>NONE</code>: Ignore permissions. </p> <note>
        /// <p>DataSync can preserve extant permissions of a source location.</p>
        /// </note>
        pub fn set_posix_permissions(
            mut self,
            input: std::option::Option<crate::model::PosixPermissions>,
        ) -> Self {
            self.posix_permissions = input;
            self
        }
        /// <p>Limits the bandwidth used by a DataSync task. For example, if you want DataSync to use a maximum of 1 MB, set this value to <code>1048576</code> (<code>=1024*1024</code>).</p>
        pub fn bytes_per_second(mut self, input: i64) -> Self {
            self.bytes_per_second = Some(input);
            self
        }
        /// <p>Limits the bandwidth used by a DataSync task. For example, if you want DataSync to use a maximum of 1 MB, set this value to <code>1048576</code> (<code>=1024*1024</code>).</p>
        pub fn set_bytes_per_second(mut self, input: std::option::Option<i64>) -> Self {
            self.bytes_per_second = input;
            self
        }
        /// <p>Specifies whether tasks should be queued before executing the tasks. The default is <code>ENABLED</code>, which means the tasks will be queued.</p>
        /// <p>If you use the same agent to run multiple tasks, you can enable the tasks to run in series. For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/run-task.html#queue-task-execution">Queueing task executions</a>.</p>
        pub fn task_queueing(mut self, input: crate::model::TaskQueueing) -> Self {
            self.task_queueing = Some(input);
            self
        }
        /// <p>Specifies whether tasks should be queued before executing the tasks. The default is <code>ENABLED</code>, which means the tasks will be queued.</p>
        /// <p>If you use the same agent to run multiple tasks, you can enable the tasks to run in series. For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/run-task.html#queue-task-execution">Queueing task executions</a>.</p>
        pub fn set_task_queueing(
            mut self,
            input: std::option::Option<crate::model::TaskQueueing>,
        ) -> Self {
            self.task_queueing = input;
            self
        }
        /// <p>Specifies the type of logs that DataSync publishes to a Amazon CloudWatch Logs log group. To specify the log group, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_CreateTask.html#DataSync-CreateTask-request-CloudWatchLogGroupArn">CloudWatchLogGroupArn</a>.</p>
        /// <p>If you set <code>LogLevel</code> to <code>OFF</code>, no logs are published. <code>BASIC</code> publishes logs on errors for individual files transferred. <code>TRANSFER</code> publishes logs for every file or object that is transferred and integrity checked.</p>
        pub fn log_level(mut self, input: crate::model::LogLevel) -> Self {
            self.log_level = Some(input);
            self
        }
        /// <p>Specifies the type of logs that DataSync publishes to a Amazon CloudWatch Logs log group. To specify the log group, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_CreateTask.html#DataSync-CreateTask-request-CloudWatchLogGroupArn">CloudWatchLogGroupArn</a>.</p>
        /// <p>If you set <code>LogLevel</code> to <code>OFF</code>, no logs are published. <code>BASIC</code> publishes logs on errors for individual files transferred. <code>TRANSFER</code> publishes logs for every file or object that is transferred and integrity checked.</p>
        pub fn set_log_level(mut self, input: std::option::Option<crate::model::LogLevel>) -> Self {
            self.log_level = input;
            self
        }
        /// <p>Determines whether DataSync transfers only the data and metadata that differ between the source and the destination location or transfers all the content from the source (without comparing what's in the destination).</p>
        /// <p> <code>CHANGED</code>: DataSync copies only data or metadata that is new or different content from the source location to the destination location.</p>
        /// <p> <code>ALL</code>: DataSync copies all source location content to the destination (without comparing what's in the destination).</p>
        pub fn transfer_mode(mut self, input: crate::model::TransferMode) -> Self {
            self.transfer_mode = Some(input);
            self
        }
        /// <p>Determines whether DataSync transfers only the data and metadata that differ between the source and the destination location or transfers all the content from the source (without comparing what's in the destination).</p>
        /// <p> <code>CHANGED</code>: DataSync copies only data or metadata that is new or different content from the source location to the destination location.</p>
        /// <p> <code>ALL</code>: DataSync copies all source location content to the destination (without comparing what's in the destination).</p>
        pub fn set_transfer_mode(
            mut self,
            input: std::option::Option<crate::model::TransferMode>,
        ) -> Self {
            self.transfer_mode = input;
            self
        }
        /// <p>Specifies which components of the SMB security descriptor are copied from source to destination objects. </p>
        /// <p>This value is only used for transfers between SMB and Amazon FSx for Windows File Server locations or between two FSx for Windows File Server locations. For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/special-files.html">how DataSync handles metadata</a>.</p>
        /// <p>Default value: <code>OWNER_DACL</code> </p>
        /// <p> <code>OWNER_DACL</code>: For each copied object, DataSync copies the following metadata:</p>
        /// <ul>
        /// <li> <p>The object owner.</p> </li>
        /// <li> <p>NTFS discretionary access control lists (DACLs), which determine whether to grant access to an object.</p> <p>DataSync won't copy NTFS system access control lists (SACLs) with this option.</p> </li>
        /// </ul>
        /// <p> <code>OWNER_DACL_SACL</code>: For each copied object, DataSync copies the following metadata:</p>
        /// <ul>
        /// <li> <p>The object owner.</p> </li>
        /// <li> <p>NTFS discretionary access control lists (DACLs), which determine whether to grant access to an object.</p> </li>
        /// <li> <p>SACLs, which are used by administrators to log attempts to access a secured object.</p> <p>Copying SACLs requires granting additional permissions to the Windows user that DataSync uses to access your SMB location. For information about choosing a user that ensures sufficient permissions to files, folders, and metadata, see <a href="create-smb-location.html#SMBuser">user</a>.</p> </li>
        /// </ul>
        /// <p> <code>NONE</code>: None of the SMB security descriptor components are copied. Destination objects are owned by the user that was provided for accessing the destination location. DACLs and SACLs are set based on the destination serverâ€™s configuration. </p>
        pub fn security_descriptor_copy_flags(
            mut self,
            input: crate::model::SmbSecurityDescriptorCopyFlags,
        ) -> Self {
            self.security_descriptor_copy_flags = Some(input);
            self
        }
        /// <p>Specifies which components of the SMB security descriptor are copied from source to destination objects. </p>
        /// <p>This value is only used for transfers between SMB and Amazon FSx for Windows File Server locations or between two FSx for Windows File Server locations. For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/special-files.html">how DataSync handles metadata</a>.</p>
        /// <p>Default value: <code>OWNER_DACL</code> </p>
        /// <p> <code>OWNER_DACL</code>: For each copied object, DataSync copies the following metadata:</p>
        /// <ul>
        /// <li> <p>The object owner.</p> </li>
        /// <li> <p>NTFS discretionary access control lists (DACLs), which determine whether to grant access to an object.</p> <p>DataSync won't copy NTFS system access control lists (SACLs) with this option.</p> </li>
        /// </ul>
        /// <p> <code>OWNER_DACL_SACL</code>: For each copied object, DataSync copies the following metadata:</p>
        /// <ul>
        /// <li> <p>The object owner.</p> </li>
        /// <li> <p>NTFS discretionary access control lists (DACLs), which determine whether to grant access to an object.</p> </li>
        /// <li> <p>SACLs, which are used by administrators to log attempts to access a secured object.</p> <p>Copying SACLs requires granting additional permissions to the Windows user that DataSync uses to access your SMB location. For information about choosing a user that ensures sufficient permissions to files, folders, and metadata, see <a href="create-smb-location.html#SMBuser">user</a>.</p> </li>
        /// </ul>
        /// <p> <code>NONE</code>: None of the SMB security descriptor components are copied. Destination objects are owned by the user that was provided for accessing the destination location. DACLs and SACLs are set based on the destination serverâ€™s configuration. </p>
        pub fn set_security_descriptor_copy_flags(
            mut self,
            input: std::option::Option<crate::model::SmbSecurityDescriptorCopyFlags>,
        ) -> Self {
            self.security_descriptor_copy_flags = input;
            self
        }
        /// <p>Specifies whether object tags are preserved when transferring between object storage systems. If you want your DataSync task to ignore object tags, specify the <code>NONE</code> value.</p>
        /// <p>Default Value: <code>PRESERVE</code> </p>
        pub fn object_tags(mut self, input: crate::model::ObjectTags) -> Self {
            self.object_tags = Some(input);
            self
        }
        /// <p>Specifies whether object tags are preserved when transferring between object storage systems. If you want your DataSync task to ignore object tags, specify the <code>NONE</code> value.</p>
        /// <p>Default Value: <code>PRESERVE</code> </p>
        pub fn set_object_tags(
            mut self,
            input: std::option::Option<crate::model::ObjectTags>,
        ) -> Self {
            self.object_tags = input;
            self
        }
        /// Consumes the builder and constructs a [`Options`](crate::model::Options).
        pub fn build(self) -> crate::model::Options {
            crate::model::Options {
                verify_mode: self.verify_mode,
                overwrite_mode: self.overwrite_mode,
                atime: self.atime,
                mtime: self.mtime,
                uid: self.uid,
                gid: self.gid,
                preserve_deleted_files: self.preserve_deleted_files,
                preserve_devices: self.preserve_devices,
                posix_permissions: self.posix_permissions,
                bytes_per_second: self.bytes_per_second,
                task_queueing: self.task_queueing,
                log_level: self.log_level,
                transfer_mode: self.transfer_mode,
                security_descriptor_copy_flags: self.security_descriptor_copy_flags,
                object_tags: self.object_tags,
            }
        }
    }
}
impl Options {
    /// Creates a new builder-style object to manufacture [`Options`](crate::model::Options).
    pub fn builder() -> crate::model::options::Builder {
        crate::model::options::Builder::default()
    }
}

/// When writing a match expression against `ObjectTags`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let objecttags = unimplemented!();
/// match objecttags {
///     ObjectTags::None => { /* ... */ },
///     ObjectTags::Preserve => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `objecttags` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ObjectTags::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ObjectTags::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ObjectTags::NewFeature` is defined.
/// Specifically, when `objecttags` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ObjectTags::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ObjectTags {
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    Preserve,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ObjectTags {
    fn from(s: &str) -> Self {
        match s {
            "NONE" => ObjectTags::None,
            "PRESERVE" => ObjectTags::Preserve,
            other => ObjectTags::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ObjectTags {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ObjectTags::from(s))
    }
}
impl ObjectTags {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ObjectTags::None => "NONE",
            ObjectTags::Preserve => "PRESERVE",
            ObjectTags::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["NONE", "PRESERVE"]
    }
}
impl AsRef<str> for ObjectTags {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SmbSecurityDescriptorCopyFlags`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let smbsecuritydescriptorcopyflags = unimplemented!();
/// match smbsecuritydescriptorcopyflags {
///     SmbSecurityDescriptorCopyFlags::None => { /* ... */ },
///     SmbSecurityDescriptorCopyFlags::OwnerDacl => { /* ... */ },
///     SmbSecurityDescriptorCopyFlags::OwnerDaclSacl => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `smbsecuritydescriptorcopyflags` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SmbSecurityDescriptorCopyFlags::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SmbSecurityDescriptorCopyFlags::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SmbSecurityDescriptorCopyFlags::NewFeature` is defined.
/// Specifically, when `smbsecuritydescriptorcopyflags` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SmbSecurityDescriptorCopyFlags::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SmbSecurityDescriptorCopyFlags {
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    OwnerDacl,
    #[allow(missing_docs)] // documentation missing in model
    OwnerDaclSacl,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SmbSecurityDescriptorCopyFlags {
    fn from(s: &str) -> Self {
        match s {
            "NONE" => SmbSecurityDescriptorCopyFlags::None,
            "OWNER_DACL" => SmbSecurityDescriptorCopyFlags::OwnerDacl,
            "OWNER_DACL_SACL" => SmbSecurityDescriptorCopyFlags::OwnerDaclSacl,
            other => SmbSecurityDescriptorCopyFlags::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for SmbSecurityDescriptorCopyFlags {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SmbSecurityDescriptorCopyFlags::from(s))
    }
}
impl SmbSecurityDescriptorCopyFlags {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SmbSecurityDescriptorCopyFlags::None => "NONE",
            SmbSecurityDescriptorCopyFlags::OwnerDacl => "OWNER_DACL",
            SmbSecurityDescriptorCopyFlags::OwnerDaclSacl => "OWNER_DACL_SACL",
            SmbSecurityDescriptorCopyFlags::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["NONE", "OWNER_DACL", "OWNER_DACL_SACL"]
    }
}
impl AsRef<str> for SmbSecurityDescriptorCopyFlags {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TransferMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let transfermode = unimplemented!();
/// match transfermode {
///     TransferMode::All => { /* ... */ },
///     TransferMode::Changed => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `transfermode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TransferMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TransferMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TransferMode::NewFeature` is defined.
/// Specifically, when `transfermode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TransferMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TransferMode {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    Changed,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TransferMode {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => TransferMode::All,
            "CHANGED" => TransferMode::Changed,
            other => TransferMode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TransferMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TransferMode::from(s))
    }
}
impl TransferMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TransferMode::All => "ALL",
            TransferMode::Changed => "CHANGED",
            TransferMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL", "CHANGED"]
    }
}
impl AsRef<str> for TransferMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `LogLevel`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let loglevel = unimplemented!();
/// match loglevel {
///     LogLevel::Basic => { /* ... */ },
///     LogLevel::Off => { /* ... */ },
///     LogLevel::Transfer => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `loglevel` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LogLevel::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LogLevel::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LogLevel::NewFeature` is defined.
/// Specifically, when `loglevel` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LogLevel::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LogLevel {
    #[allow(missing_docs)] // documentation missing in model
    Basic,
    #[allow(missing_docs)] // documentation missing in model
    Off,
    #[allow(missing_docs)] // documentation missing in model
    Transfer,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LogLevel {
    fn from(s: &str) -> Self {
        match s {
            "BASIC" => LogLevel::Basic,
            "OFF" => LogLevel::Off,
            "TRANSFER" => LogLevel::Transfer,
            other => LogLevel::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LogLevel {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LogLevel::from(s))
    }
}
impl LogLevel {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LogLevel::Basic => "BASIC",
            LogLevel::Off => "OFF",
            LogLevel::Transfer => "TRANSFER",
            LogLevel::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BASIC", "OFF", "TRANSFER"]
    }
}
impl AsRef<str> for LogLevel {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TaskQueueing`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let taskqueueing = unimplemented!();
/// match taskqueueing {
///     TaskQueueing::Disabled => { /* ... */ },
///     TaskQueueing::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `taskqueueing` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TaskQueueing::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TaskQueueing::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TaskQueueing::NewFeature` is defined.
/// Specifically, when `taskqueueing` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TaskQueueing::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TaskQueueing {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TaskQueueing {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => TaskQueueing::Disabled,
            "ENABLED" => TaskQueueing::Enabled,
            other => TaskQueueing::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TaskQueueing {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TaskQueueing::from(s))
    }
}
impl TaskQueueing {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TaskQueueing::Disabled => "DISABLED",
            TaskQueueing::Enabled => "ENABLED",
            TaskQueueing::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for TaskQueueing {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PosixPermissions`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let posixpermissions = unimplemented!();
/// match posixpermissions {
///     PosixPermissions::None => { /* ... */ },
///     PosixPermissions::Preserve => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `posixpermissions` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PosixPermissions::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PosixPermissions::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PosixPermissions::NewFeature` is defined.
/// Specifically, when `posixpermissions` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PosixPermissions::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PosixPermissions {
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    Preserve,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PosixPermissions {
    fn from(s: &str) -> Self {
        match s {
            "NONE" => PosixPermissions::None,
            "PRESERVE" => PosixPermissions::Preserve,
            other => PosixPermissions::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PosixPermissions {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PosixPermissions::from(s))
    }
}
impl PosixPermissions {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PosixPermissions::None => "NONE",
            PosixPermissions::Preserve => "PRESERVE",
            PosixPermissions::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["NONE", "PRESERVE"]
    }
}
impl AsRef<str> for PosixPermissions {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PreserveDevices`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let preservedevices = unimplemented!();
/// match preservedevices {
///     PreserveDevices::None => { /* ... */ },
///     PreserveDevices::Preserve => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `preservedevices` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PreserveDevices::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PreserveDevices::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PreserveDevices::NewFeature` is defined.
/// Specifically, when `preservedevices` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PreserveDevices::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PreserveDevices {
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    Preserve,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PreserveDevices {
    fn from(s: &str) -> Self {
        match s {
            "NONE" => PreserveDevices::None,
            "PRESERVE" => PreserveDevices::Preserve,
            other => PreserveDevices::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PreserveDevices {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PreserveDevices::from(s))
    }
}
impl PreserveDevices {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PreserveDevices::None => "NONE",
            PreserveDevices::Preserve => "PRESERVE",
            PreserveDevices::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["NONE", "PRESERVE"]
    }
}
impl AsRef<str> for PreserveDevices {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PreserveDeletedFiles`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let preservedeletedfiles = unimplemented!();
/// match preservedeletedfiles {
///     PreserveDeletedFiles::Preserve => { /* ... */ },
///     PreserveDeletedFiles::Remove => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `preservedeletedfiles` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PreserveDeletedFiles::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PreserveDeletedFiles::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PreserveDeletedFiles::NewFeature` is defined.
/// Specifically, when `preservedeletedfiles` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PreserveDeletedFiles::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PreserveDeletedFiles {
    #[allow(missing_docs)] // documentation missing in model
    Preserve,
    #[allow(missing_docs)] // documentation missing in model
    Remove,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PreserveDeletedFiles {
    fn from(s: &str) -> Self {
        match s {
            "PRESERVE" => PreserveDeletedFiles::Preserve,
            "REMOVE" => PreserveDeletedFiles::Remove,
            other => {
                PreserveDeletedFiles::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for PreserveDeletedFiles {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PreserveDeletedFiles::from(s))
    }
}
impl PreserveDeletedFiles {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PreserveDeletedFiles::Preserve => "PRESERVE",
            PreserveDeletedFiles::Remove => "REMOVE",
            PreserveDeletedFiles::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PRESERVE", "REMOVE"]
    }
}
impl AsRef<str> for PreserveDeletedFiles {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Gid`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let gid = unimplemented!();
/// match gid {
///     Gid::Both => { /* ... */ },
///     Gid::IntValue => { /* ... */ },
///     Gid::Name => { /* ... */ },
///     Gid::None => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `gid` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Gid::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Gid::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Gid::NewFeature` is defined.
/// Specifically, when `gid` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Gid::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Gid {
    #[allow(missing_docs)] // documentation missing in model
    Both,
    #[allow(missing_docs)] // documentation missing in model
    IntValue,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    #[allow(missing_docs)] // documentation missing in model
    None,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Gid {
    fn from(s: &str) -> Self {
        match s {
            "BOTH" => Gid::Both,
            "INT_VALUE" => Gid::IntValue,
            "NAME" => Gid::Name,
            "NONE" => Gid::None,
            other => Gid::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Gid {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Gid::from(s))
    }
}
impl Gid {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Gid::Both => "BOTH",
            Gid::IntValue => "INT_VALUE",
            Gid::Name => "NAME",
            Gid::None => "NONE",
            Gid::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BOTH", "INT_VALUE", "NAME", "NONE"]
    }
}
impl AsRef<str> for Gid {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Uid`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let uid = unimplemented!();
/// match uid {
///     Uid::Both => { /* ... */ },
///     Uid::IntValue => { /* ... */ },
///     Uid::Name => { /* ... */ },
///     Uid::None => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `uid` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Uid::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Uid::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Uid::NewFeature` is defined.
/// Specifically, when `uid` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Uid::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Uid {
    #[allow(missing_docs)] // documentation missing in model
    Both,
    #[allow(missing_docs)] // documentation missing in model
    IntValue,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    #[allow(missing_docs)] // documentation missing in model
    None,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Uid {
    fn from(s: &str) -> Self {
        match s {
            "BOTH" => Uid::Both,
            "INT_VALUE" => Uid::IntValue,
            "NAME" => Uid::Name,
            "NONE" => Uid::None,
            other => Uid::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Uid {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Uid::from(s))
    }
}
impl Uid {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Uid::Both => "BOTH",
            Uid::IntValue => "INT_VALUE",
            Uid::Name => "NAME",
            Uid::None => "NONE",
            Uid::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BOTH", "INT_VALUE", "NAME", "NONE"]
    }
}
impl AsRef<str> for Uid {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Mtime`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let mtime = unimplemented!();
/// match mtime {
///     Mtime::None => { /* ... */ },
///     Mtime::Preserve => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `mtime` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Mtime::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Mtime::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Mtime::NewFeature` is defined.
/// Specifically, when `mtime` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Mtime::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Mtime {
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    Preserve,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Mtime {
    fn from(s: &str) -> Self {
        match s {
            "NONE" => Mtime::None,
            "PRESERVE" => Mtime::Preserve,
            other => Mtime::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Mtime {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Mtime::from(s))
    }
}
impl Mtime {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Mtime::None => "NONE",
            Mtime::Preserve => "PRESERVE",
            Mtime::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["NONE", "PRESERVE"]
    }
}
impl AsRef<str> for Mtime {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Atime`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let atime = unimplemented!();
/// match atime {
///     Atime::BestEffort => { /* ... */ },
///     Atime::None => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `atime` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Atime::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Atime::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Atime::NewFeature` is defined.
/// Specifically, when `atime` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Atime::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Atime {
    #[allow(missing_docs)] // documentation missing in model
    BestEffort,
    #[allow(missing_docs)] // documentation missing in model
    None,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Atime {
    fn from(s: &str) -> Self {
        match s {
            "BEST_EFFORT" => Atime::BestEffort,
            "NONE" => Atime::None,
            other => Atime::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Atime {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Atime::from(s))
    }
}
impl Atime {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Atime::BestEffort => "BEST_EFFORT",
            Atime::None => "NONE",
            Atime::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BEST_EFFORT", "NONE"]
    }
}
impl AsRef<str> for Atime {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `OverwriteMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let overwritemode = unimplemented!();
/// match overwritemode {
///     OverwriteMode::Always => { /* ... */ },
///     OverwriteMode::Never => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `overwritemode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OverwriteMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OverwriteMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OverwriteMode::NewFeature` is defined.
/// Specifically, when `overwritemode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OverwriteMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OverwriteMode {
    #[allow(missing_docs)] // documentation missing in model
    Always,
    #[allow(missing_docs)] // documentation missing in model
    Never,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OverwriteMode {
    fn from(s: &str) -> Self {
        match s {
            "ALWAYS" => OverwriteMode::Always,
            "NEVER" => OverwriteMode::Never,
            other => OverwriteMode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for OverwriteMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OverwriteMode::from(s))
    }
}
impl OverwriteMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OverwriteMode::Always => "ALWAYS",
            OverwriteMode::Never => "NEVER",
            OverwriteMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALWAYS", "NEVER"]
    }
}
impl AsRef<str> for OverwriteMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `VerifyMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let verifymode = unimplemented!();
/// match verifymode {
///     VerifyMode::None => { /* ... */ },
///     VerifyMode::OnlyFilesTransferred => { /* ... */ },
///     VerifyMode::PointInTimeConsistent => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `verifymode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `VerifyMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `VerifyMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `VerifyMode::NewFeature` is defined.
/// Specifically, when `verifymode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `VerifyMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VerifyMode {
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    OnlyFilesTransferred,
    #[allow(missing_docs)] // documentation missing in model
    PointInTimeConsistent,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for VerifyMode {
    fn from(s: &str) -> Self {
        match s {
            "NONE" => VerifyMode::None,
            "ONLY_FILES_TRANSFERRED" => VerifyMode::OnlyFilesTransferred,
            "POINT_IN_TIME_CONSISTENT" => VerifyMode::PointInTimeConsistent,
            other => VerifyMode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for VerifyMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VerifyMode::from(s))
    }
}
impl VerifyMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VerifyMode::None => "NONE",
            VerifyMode::OnlyFilesTransferred => "ONLY_FILES_TRANSFERRED",
            VerifyMode::PointInTimeConsistent => "POINT_IN_TIME_CONSISTENT",
            VerifyMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["NONE", "ONLY_FILES_TRANSFERRED", "POINT_IN_TIME_CONSISTENT"]
    }
}
impl AsRef<str> for VerifyMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies which files, folders, and objects to include or exclude when transferring files from source to destination.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilterRule {
    /// <p>The type of filter rule to apply. DataSync only supports the SIMPLE_PATTERN rule type.</p>
    #[doc(hidden)]
    pub filter_type: std::option::Option<crate::model::FilterType>,
    /// <p>A single filter string that consists of the patterns to include or exclude. The patterns are delimited by "|" (that is, a pipe), for example: <code>/folder1|/folder2</code> </p>
    /// <p> </p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl FilterRule {
    /// <p>The type of filter rule to apply. DataSync only supports the SIMPLE_PATTERN rule type.</p>
    pub fn filter_type(&self) -> std::option::Option<&crate::model::FilterType> {
        self.filter_type.as_ref()
    }
    /// <p>A single filter string that consists of the patterns to include or exclude. The patterns are delimited by "|" (that is, a pipe), for example: <code>/folder1|/folder2</code> </p>
    /// <p> </p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`FilterRule`](crate::model::FilterRule).
pub mod filter_rule {

    /// A builder for [`FilterRule`](crate::model::FilterRule).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter_type: std::option::Option<crate::model::FilterType>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of filter rule to apply. DataSync only supports the SIMPLE_PATTERN rule type.</p>
        pub fn filter_type(mut self, input: crate::model::FilterType) -> Self {
            self.filter_type = Some(input);
            self
        }
        /// <p>The type of filter rule to apply. DataSync only supports the SIMPLE_PATTERN rule type.</p>
        pub fn set_filter_type(
            mut self,
            input: std::option::Option<crate::model::FilterType>,
        ) -> Self {
            self.filter_type = input;
            self
        }
        /// <p>A single filter string that consists of the patterns to include or exclude. The patterns are delimited by "|" (that is, a pipe), for example: <code>/folder1|/folder2</code> </p>
        /// <p> </p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>A single filter string that consists of the patterns to include or exclude. The patterns are delimited by "|" (that is, a pipe), for example: <code>/folder1|/folder2</code> </p>
        /// <p> </p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`FilterRule`](crate::model::FilterRule).
        pub fn build(self) -> crate::model::FilterRule {
            crate::model::FilterRule {
                filter_type: self.filter_type,
                value: self.value,
            }
        }
    }
}
impl FilterRule {
    /// Creates a new builder-style object to manufacture [`FilterRule`](crate::model::FilterRule).
    pub fn builder() -> crate::model::filter_rule::Builder {
        crate::model::filter_rule::Builder::default()
    }
}

/// When writing a match expression against `FilterType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let filtertype = unimplemented!();
/// match filtertype {
///     FilterType::SimplePattern => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `filtertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FilterType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FilterType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FilterType::NewFeature` is defined.
/// Specifically, when `filtertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FilterType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FilterType {
    #[allow(missing_docs)] // documentation missing in model
    SimplePattern,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FilterType {
    fn from(s: &str) -> Self {
        match s {
            "SIMPLE_PATTERN" => FilterType::SimplePattern,
            other => FilterType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FilterType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FilterType::from(s))
    }
}
impl FilterType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FilterType::SimplePattern => "SIMPLE_PATTERN",
            FilterType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SIMPLE_PATTERN"]
    }
}
impl AsRef<str> for FilterType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies the schedule you want your task to use for repeated executions. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html">Schedule Expressions for Rules</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TaskSchedule {
    /// <p>A cron expression that specifies when DataSync initiates a scheduled transfer from a source to a destination location. </p>
    #[doc(hidden)]
    pub schedule_expression: std::option::Option<std::string::String>,
}
impl TaskSchedule {
    /// <p>A cron expression that specifies when DataSync initiates a scheduled transfer from a source to a destination location. </p>
    pub fn schedule_expression(&self) -> std::option::Option<&str> {
        self.schedule_expression.as_deref()
    }
}
/// See [`TaskSchedule`](crate::model::TaskSchedule).
pub mod task_schedule {

    /// A builder for [`TaskSchedule`](crate::model::TaskSchedule).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) schedule_expression: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A cron expression that specifies when DataSync initiates a scheduled transfer from a source to a destination location. </p>
        pub fn schedule_expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.schedule_expression = Some(input.into());
            self
        }
        /// <p>A cron expression that specifies when DataSync initiates a scheduled transfer from a source to a destination location. </p>
        pub fn set_schedule_expression(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.schedule_expression = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskSchedule`](crate::model::TaskSchedule).
        pub fn build(self) -> crate::model::TaskSchedule {
            crate::model::TaskSchedule {
                schedule_expression: self.schedule_expression,
            }
        }
    }
}
impl TaskSchedule {
    /// Creates a new builder-style object to manufacture [`TaskSchedule`](crate::model::TaskSchedule).
    pub fn builder() -> crate::model::task_schedule::Builder {
        crate::model::task_schedule::Builder::default()
    }
}

/// <p>Specifies how DataSync can access a location using the SMB protocol.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SmbMountOptions {
    /// <p>Specifies the SMB version that you want DataSync to use when mounting your SMB share. If you don't specify a version, DataSync defaults to <code>AUTOMATIC</code> and chooses a version based on negotiation with the SMB server.</p>
    #[doc(hidden)]
    pub version: std::option::Option<crate::model::SmbVersion>,
}
impl SmbMountOptions {
    /// <p>Specifies the SMB version that you want DataSync to use when mounting your SMB share. If you don't specify a version, DataSync defaults to <code>AUTOMATIC</code> and chooses a version based on negotiation with the SMB server.</p>
    pub fn version(&self) -> std::option::Option<&crate::model::SmbVersion> {
        self.version.as_ref()
    }
}
/// See [`SmbMountOptions`](crate::model::SmbMountOptions).
pub mod smb_mount_options {

    /// A builder for [`SmbMountOptions`](crate::model::SmbMountOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) version: std::option::Option<crate::model::SmbVersion>,
    }
    impl Builder {
        /// <p>Specifies the SMB version that you want DataSync to use when mounting your SMB share. If you don't specify a version, DataSync defaults to <code>AUTOMATIC</code> and chooses a version based on negotiation with the SMB server.</p>
        pub fn version(mut self, input: crate::model::SmbVersion) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>Specifies the SMB version that you want DataSync to use when mounting your SMB share. If you don't specify a version, DataSync defaults to <code>AUTOMATIC</code> and chooses a version based on negotiation with the SMB server.</p>
        pub fn set_version(mut self, input: std::option::Option<crate::model::SmbVersion>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`SmbMountOptions`](crate::model::SmbMountOptions).
        pub fn build(self) -> crate::model::SmbMountOptions {
            crate::model::SmbMountOptions {
                version: self.version,
            }
        }
    }
}
impl SmbMountOptions {
    /// Creates a new builder-style object to manufacture [`SmbMountOptions`](crate::model::SmbMountOptions).
    pub fn builder() -> crate::model::smb_mount_options::Builder {
        crate::model::smb_mount_options::Builder::default()
    }
}

/// When writing a match expression against `SmbVersion`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let smbversion = unimplemented!();
/// match smbversion {
///     SmbVersion::Automatic => { /* ... */ },
///     SmbVersion::Smb2 => { /* ... */ },
///     SmbVersion::Smb3 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `smbversion` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SmbVersion::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SmbVersion::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SmbVersion::NewFeature` is defined.
/// Specifically, when `smbversion` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SmbVersion::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SmbVersion {
    #[allow(missing_docs)] // documentation missing in model
    Automatic,
    #[allow(missing_docs)] // documentation missing in model
    Smb2,
    #[allow(missing_docs)] // documentation missing in model
    Smb3,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SmbVersion {
    fn from(s: &str) -> Self {
        match s {
            "AUTOMATIC" => SmbVersion::Automatic,
            "SMB2" => SmbVersion::Smb2,
            "SMB3" => SmbVersion::Smb3,
            other => SmbVersion::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SmbVersion {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SmbVersion::from(s))
    }
}
impl SmbVersion {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SmbVersion::Automatic => "AUTOMATIC",
            SmbVersion::Smb2 => "SMB2",
            SmbVersion::Smb3 => "SMB3",
            SmbVersion::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AUTOMATIC", "SMB2", "SMB3"]
    }
}
impl AsRef<str> for SmbVersion {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ObjectStorageServerProtocol`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let objectstorageserverprotocol = unimplemented!();
/// match objectstorageserverprotocol {
///     ObjectStorageServerProtocol::Http => { /* ... */ },
///     ObjectStorageServerProtocol::Https => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `objectstorageserverprotocol` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ObjectStorageServerProtocol::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ObjectStorageServerProtocol::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ObjectStorageServerProtocol::NewFeature` is defined.
/// Specifically, when `objectstorageserverprotocol` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ObjectStorageServerProtocol::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ObjectStorageServerProtocol {
    #[allow(missing_docs)] // documentation missing in model
    Http,
    #[allow(missing_docs)] // documentation missing in model
    Https,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ObjectStorageServerProtocol {
    fn from(s: &str) -> Self {
        match s {
            "HTTP" => ObjectStorageServerProtocol::Http,
            "HTTPS" => ObjectStorageServerProtocol::Https,
            other => ObjectStorageServerProtocol::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ObjectStorageServerProtocol {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ObjectStorageServerProtocol::from(s))
    }
}
impl ObjectStorageServerProtocol {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ObjectStorageServerProtocol::Http => "HTTP",
            ObjectStorageServerProtocol::Https => "HTTPS",
            ObjectStorageServerProtocol::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["HTTP", "HTTPS"]
    }
}
impl AsRef<str> for ObjectStorageServerProtocol {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies how DataSync can access a location using the NFS protocol.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NfsMountOptions {
    /// <p>Specifies the NFS version that you want DataSync to use when mounting your NFS share. If the server refuses to use the version specified, the task fails.</p>
    /// <p>You can specify the following options:</p>
    /// <ul>
    /// <li> <p> <code>AUTOMATIC</code> (default): DataSync chooses NFS version 4.1.</p> </li>
    /// <li> <p> <code>NFS3</code>: Stateless protocol version that allows for asynchronous writes on the server.</p> </li>
    /// <li> <p> <code>NFSv4_0</code>: Stateful, firewall-friendly protocol version that supports delegations and pseudo file systems.</p> </li>
    /// <li> <p> <code>NFSv4_1</code>: Stateful protocol version that supports sessions, directory delegations, and parallel data processing. NFS version 4.1 also includes all features available in version 4.0.</p> </li>
    /// </ul> <note>
    /// <p>DataSync currently only supports NFS version 3 with Amazon FSx for NetApp ONTAP locations.</p>
    /// </note>
    #[doc(hidden)]
    pub version: std::option::Option<crate::model::NfsVersion>,
}
impl NfsMountOptions {
    /// <p>Specifies the NFS version that you want DataSync to use when mounting your NFS share. If the server refuses to use the version specified, the task fails.</p>
    /// <p>You can specify the following options:</p>
    /// <ul>
    /// <li> <p> <code>AUTOMATIC</code> (default): DataSync chooses NFS version 4.1.</p> </li>
    /// <li> <p> <code>NFS3</code>: Stateless protocol version that allows for asynchronous writes on the server.</p> </li>
    /// <li> <p> <code>NFSv4_0</code>: Stateful, firewall-friendly protocol version that supports delegations and pseudo file systems.</p> </li>
    /// <li> <p> <code>NFSv4_1</code>: Stateful protocol version that supports sessions, directory delegations, and parallel data processing. NFS version 4.1 also includes all features available in version 4.0.</p> </li>
    /// </ul> <note>
    /// <p>DataSync currently only supports NFS version 3 with Amazon FSx for NetApp ONTAP locations.</p>
    /// </note>
    pub fn version(&self) -> std::option::Option<&crate::model::NfsVersion> {
        self.version.as_ref()
    }
}
/// See [`NfsMountOptions`](crate::model::NfsMountOptions).
pub mod nfs_mount_options {

    /// A builder for [`NfsMountOptions`](crate::model::NfsMountOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) version: std::option::Option<crate::model::NfsVersion>,
    }
    impl Builder {
        /// <p>Specifies the NFS version that you want DataSync to use when mounting your NFS share. If the server refuses to use the version specified, the task fails.</p>
        /// <p>You can specify the following options:</p>
        /// <ul>
        /// <li> <p> <code>AUTOMATIC</code> (default): DataSync chooses NFS version 4.1.</p> </li>
        /// <li> <p> <code>NFS3</code>: Stateless protocol version that allows for asynchronous writes on the server.</p> </li>
        /// <li> <p> <code>NFSv4_0</code>: Stateful, firewall-friendly protocol version that supports delegations and pseudo file systems.</p> </li>
        /// <li> <p> <code>NFSv4_1</code>: Stateful protocol version that supports sessions, directory delegations, and parallel data processing. NFS version 4.1 also includes all features available in version 4.0.</p> </li>
        /// </ul> <note>
        /// <p>DataSync currently only supports NFS version 3 with Amazon FSx for NetApp ONTAP locations.</p>
        /// </note>
        pub fn version(mut self, input: crate::model::NfsVersion) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>Specifies the NFS version that you want DataSync to use when mounting your NFS share. If the server refuses to use the version specified, the task fails.</p>
        /// <p>You can specify the following options:</p>
        /// <ul>
        /// <li> <p> <code>AUTOMATIC</code> (default): DataSync chooses NFS version 4.1.</p> </li>
        /// <li> <p> <code>NFS3</code>: Stateless protocol version that allows for asynchronous writes on the server.</p> </li>
        /// <li> <p> <code>NFSv4_0</code>: Stateful, firewall-friendly protocol version that supports delegations and pseudo file systems.</p> </li>
        /// <li> <p> <code>NFSv4_1</code>: Stateful protocol version that supports sessions, directory delegations, and parallel data processing. NFS version 4.1 also includes all features available in version 4.0.</p> </li>
        /// </ul> <note>
        /// <p>DataSync currently only supports NFS version 3 with Amazon FSx for NetApp ONTAP locations.</p>
        /// </note>
        pub fn set_version(mut self, input: std::option::Option<crate::model::NfsVersion>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`NfsMountOptions`](crate::model::NfsMountOptions).
        pub fn build(self) -> crate::model::NfsMountOptions {
            crate::model::NfsMountOptions {
                version: self.version,
            }
        }
    }
}
impl NfsMountOptions {
    /// Creates a new builder-style object to manufacture [`NfsMountOptions`](crate::model::NfsMountOptions).
    pub fn builder() -> crate::model::nfs_mount_options::Builder {
        crate::model::nfs_mount_options::Builder::default()
    }
}

/// When writing a match expression against `NfsVersion`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let nfsversion = unimplemented!();
/// match nfsversion {
///     NfsVersion::Automatic => { /* ... */ },
///     NfsVersion::Nfs3 => { /* ... */ },
///     NfsVersion::Nfs40 => { /* ... */ },
///     NfsVersion::Nfs41 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `nfsversion` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NfsVersion::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NfsVersion::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NfsVersion::NewFeature` is defined.
/// Specifically, when `nfsversion` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NfsVersion::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NfsVersion {
    #[allow(missing_docs)] // documentation missing in model
    Automatic,
    #[allow(missing_docs)] // documentation missing in model
    Nfs3,
    #[allow(missing_docs)] // documentation missing in model
    Nfs40,
    #[allow(missing_docs)] // documentation missing in model
    Nfs41,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NfsVersion {
    fn from(s: &str) -> Self {
        match s {
            "AUTOMATIC" => NfsVersion::Automatic,
            "NFS3" => NfsVersion::Nfs3,
            "NFS4_0" => NfsVersion::Nfs40,
            "NFS4_1" => NfsVersion::Nfs41,
            other => NfsVersion::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for NfsVersion {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NfsVersion::from(s))
    }
}
impl NfsVersion {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NfsVersion::Automatic => "AUTOMATIC",
            NfsVersion::Nfs3 => "NFS3",
            NfsVersion::Nfs40 => "NFS4_0",
            NfsVersion::Nfs41 => "NFS4_1",
            NfsVersion::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AUTOMATIC", "NFS3", "NFS4_0", "NFS4_1"]
    }
}
impl AsRef<str> for NfsVersion {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A list of Amazon Resource Names (ARNs) of agents to use for a Network File System (NFS) location.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OnPremConfig {
    /// <p>ARNs of the agents to use for an NFS location.</p>
    #[doc(hidden)]
    pub agent_arns: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl OnPremConfig {
    /// <p>ARNs of the agents to use for an NFS location.</p>
    pub fn agent_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.agent_arns.as_deref()
    }
}
/// See [`OnPremConfig`](crate::model::OnPremConfig).
pub mod on_prem_config {

    /// A builder for [`OnPremConfig`](crate::model::OnPremConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) agent_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `agent_arns`.
        ///
        /// To override the contents of this collection use [`set_agent_arns`](Self::set_agent_arns).
        ///
        /// <p>ARNs of the agents to use for an NFS location.</p>
        pub fn agent_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.agent_arns.unwrap_or_default();
            v.push(input.into());
            self.agent_arns = Some(v);
            self
        }
        /// <p>ARNs of the agents to use for an NFS location.</p>
        pub fn set_agent_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.agent_arns = input;
            self
        }
        /// Consumes the builder and constructs a [`OnPremConfig`](crate::model::OnPremConfig).
        pub fn build(self) -> crate::model::OnPremConfig {
            crate::model::OnPremConfig {
                agent_arns: self.agent_arns,
            }
        }
    }
}
impl OnPremConfig {
    /// Creates a new builder-style object to manufacture [`OnPremConfig`](crate::model::OnPremConfig).
    pub fn builder() -> crate::model::on_prem_config::Builder {
        crate::model::on_prem_config::Builder::default()
    }
}

/// When writing a match expression against `HdfsAuthenticationType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let hdfsauthenticationtype = unimplemented!();
/// match hdfsauthenticationtype {
///     HdfsAuthenticationType::Kerberos => { /* ... */ },
///     HdfsAuthenticationType::Simple => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `hdfsauthenticationtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `HdfsAuthenticationType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `HdfsAuthenticationType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `HdfsAuthenticationType::NewFeature` is defined.
/// Specifically, when `hdfsauthenticationtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `HdfsAuthenticationType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HdfsAuthenticationType {
    #[allow(missing_docs)] // documentation missing in model
    Kerberos,
    #[allow(missing_docs)] // documentation missing in model
    Simple,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for HdfsAuthenticationType {
    fn from(s: &str) -> Self {
        match s {
            "KERBEROS" => HdfsAuthenticationType::Kerberos,
            "SIMPLE" => HdfsAuthenticationType::Simple,
            other => {
                HdfsAuthenticationType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for HdfsAuthenticationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HdfsAuthenticationType::from(s))
    }
}
impl HdfsAuthenticationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HdfsAuthenticationType::Kerberos => "KERBEROS",
            HdfsAuthenticationType::Simple => "SIMPLE",
            HdfsAuthenticationType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["KERBEROS", "SIMPLE"]
    }
}
impl AsRef<str> for HdfsAuthenticationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The Quality of Protection (QOP) configuration specifies the Remote Procedure Call (RPC) and data transfer privacy settings configured on the Hadoop Distributed File System (HDFS) cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QopConfiguration {
    /// <p>The RPC protection setting configured on the HDFS cluster. This setting corresponds to your <code>hadoop.rpc.protection</code> setting in your <code>core-site.xml</code> file on your Hadoop cluster.</p>
    #[doc(hidden)]
    pub rpc_protection: std::option::Option<crate::model::HdfsRpcProtection>,
    /// <p>The data transfer protection setting configured on the HDFS cluster. This setting corresponds to your <code>dfs.data.transfer.protection</code> setting in the <code>hdfs-site.xml</code> file on your Hadoop cluster.</p>
    #[doc(hidden)]
    pub data_transfer_protection: std::option::Option<crate::model::HdfsDataTransferProtection>,
}
impl QopConfiguration {
    /// <p>The RPC protection setting configured on the HDFS cluster. This setting corresponds to your <code>hadoop.rpc.protection</code> setting in your <code>core-site.xml</code> file on your Hadoop cluster.</p>
    pub fn rpc_protection(&self) -> std::option::Option<&crate::model::HdfsRpcProtection> {
        self.rpc_protection.as_ref()
    }
    /// <p>The data transfer protection setting configured on the HDFS cluster. This setting corresponds to your <code>dfs.data.transfer.protection</code> setting in the <code>hdfs-site.xml</code> file on your Hadoop cluster.</p>
    pub fn data_transfer_protection(
        &self,
    ) -> std::option::Option<&crate::model::HdfsDataTransferProtection> {
        self.data_transfer_protection.as_ref()
    }
}
/// See [`QopConfiguration`](crate::model::QopConfiguration).
pub mod qop_configuration {

    /// A builder for [`QopConfiguration`](crate::model::QopConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rpc_protection: std::option::Option<crate::model::HdfsRpcProtection>,
        pub(crate) data_transfer_protection:
            std::option::Option<crate::model::HdfsDataTransferProtection>,
    }
    impl Builder {
        /// <p>The RPC protection setting configured on the HDFS cluster. This setting corresponds to your <code>hadoop.rpc.protection</code> setting in your <code>core-site.xml</code> file on your Hadoop cluster.</p>
        pub fn rpc_protection(mut self, input: crate::model::HdfsRpcProtection) -> Self {
            self.rpc_protection = Some(input);
            self
        }
        /// <p>The RPC protection setting configured on the HDFS cluster. This setting corresponds to your <code>hadoop.rpc.protection</code> setting in your <code>core-site.xml</code> file on your Hadoop cluster.</p>
        pub fn set_rpc_protection(
            mut self,
            input: std::option::Option<crate::model::HdfsRpcProtection>,
        ) -> Self {
            self.rpc_protection = input;
            self
        }
        /// <p>The data transfer protection setting configured on the HDFS cluster. This setting corresponds to your <code>dfs.data.transfer.protection</code> setting in the <code>hdfs-site.xml</code> file on your Hadoop cluster.</p>
        pub fn data_transfer_protection(
            mut self,
            input: crate::model::HdfsDataTransferProtection,
        ) -> Self {
            self.data_transfer_protection = Some(input);
            self
        }
        /// <p>The data transfer protection setting configured on the HDFS cluster. This setting corresponds to your <code>dfs.data.transfer.protection</code> setting in the <code>hdfs-site.xml</code> file on your Hadoop cluster.</p>
        pub fn set_data_transfer_protection(
            mut self,
            input: std::option::Option<crate::model::HdfsDataTransferProtection>,
        ) -> Self {
            self.data_transfer_protection = input;
            self
        }
        /// Consumes the builder and constructs a [`QopConfiguration`](crate::model::QopConfiguration).
        pub fn build(self) -> crate::model::QopConfiguration {
            crate::model::QopConfiguration {
                rpc_protection: self.rpc_protection,
                data_transfer_protection: self.data_transfer_protection,
            }
        }
    }
}
impl QopConfiguration {
    /// Creates a new builder-style object to manufacture [`QopConfiguration`](crate::model::QopConfiguration).
    pub fn builder() -> crate::model::qop_configuration::Builder {
        crate::model::qop_configuration::Builder::default()
    }
}

/// When writing a match expression against `HdfsDataTransferProtection`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let hdfsdatatransferprotection = unimplemented!();
/// match hdfsdatatransferprotection {
///     HdfsDataTransferProtection::Authentication => { /* ... */ },
///     HdfsDataTransferProtection::Disabled => { /* ... */ },
///     HdfsDataTransferProtection::Integrity => { /* ... */ },
///     HdfsDataTransferProtection::Privacy => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `hdfsdatatransferprotection` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `HdfsDataTransferProtection::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `HdfsDataTransferProtection::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `HdfsDataTransferProtection::NewFeature` is defined.
/// Specifically, when `hdfsdatatransferprotection` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `HdfsDataTransferProtection::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HdfsDataTransferProtection {
    #[allow(missing_docs)] // documentation missing in model
    Authentication,
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Integrity,
    #[allow(missing_docs)] // documentation missing in model
    Privacy,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for HdfsDataTransferProtection {
    fn from(s: &str) -> Self {
        match s {
            "AUTHENTICATION" => HdfsDataTransferProtection::Authentication,
            "DISABLED" => HdfsDataTransferProtection::Disabled,
            "INTEGRITY" => HdfsDataTransferProtection::Integrity,
            "PRIVACY" => HdfsDataTransferProtection::Privacy,
            other => HdfsDataTransferProtection::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for HdfsDataTransferProtection {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HdfsDataTransferProtection::from(s))
    }
}
impl HdfsDataTransferProtection {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HdfsDataTransferProtection::Authentication => "AUTHENTICATION",
            HdfsDataTransferProtection::Disabled => "DISABLED",
            HdfsDataTransferProtection::Integrity => "INTEGRITY",
            HdfsDataTransferProtection::Privacy => "PRIVACY",
            HdfsDataTransferProtection::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AUTHENTICATION", "DISABLED", "INTEGRITY", "PRIVACY"]
    }
}
impl AsRef<str> for HdfsDataTransferProtection {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `HdfsRpcProtection`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let hdfsrpcprotection = unimplemented!();
/// match hdfsrpcprotection {
///     HdfsRpcProtection::Authentication => { /* ... */ },
///     HdfsRpcProtection::Disabled => { /* ... */ },
///     HdfsRpcProtection::Integrity => { /* ... */ },
///     HdfsRpcProtection::Privacy => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `hdfsrpcprotection` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `HdfsRpcProtection::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `HdfsRpcProtection::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `HdfsRpcProtection::NewFeature` is defined.
/// Specifically, when `hdfsrpcprotection` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `HdfsRpcProtection::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HdfsRpcProtection {
    #[allow(missing_docs)] // documentation missing in model
    Authentication,
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Integrity,
    #[allow(missing_docs)] // documentation missing in model
    Privacy,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for HdfsRpcProtection {
    fn from(s: &str) -> Self {
        match s {
            "AUTHENTICATION" => HdfsRpcProtection::Authentication,
            "DISABLED" => HdfsRpcProtection::Disabled,
            "INTEGRITY" => HdfsRpcProtection::Integrity,
            "PRIVACY" => HdfsRpcProtection::Privacy,
            other => {
                HdfsRpcProtection::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for HdfsRpcProtection {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HdfsRpcProtection::from(s))
    }
}
impl HdfsRpcProtection {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HdfsRpcProtection::Authentication => "AUTHENTICATION",
            HdfsRpcProtection::Disabled => "DISABLED",
            HdfsRpcProtection::Integrity => "INTEGRITY",
            HdfsRpcProtection::Privacy => "PRIVACY",
            HdfsRpcProtection::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AUTHENTICATION", "DISABLED", "INTEGRITY", "PRIVACY"]
    }
}
impl AsRef<str> for HdfsRpcProtection {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The NameNode of the Hadoop Distributed File System (HDFS). The NameNode manages the file system's namespace. The NameNode performs operations such as opening, closing, and renaming files and directories. The NameNode contains the information to map blocks of data to the DataNodes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HdfsNameNode {
    /// <p>The hostname of the NameNode in the HDFS cluster. This value is the IP address or Domain Name Service (DNS) name of the NameNode. An agent that's installed on-premises uses this hostname to communicate with the NameNode in the network.</p>
    #[doc(hidden)]
    pub hostname: std::option::Option<std::string::String>,
    /// <p>The port that the NameNode uses to listen to client requests.</p>
    #[doc(hidden)]
    pub port: std::option::Option<i32>,
}
impl HdfsNameNode {
    /// <p>The hostname of the NameNode in the HDFS cluster. This value is the IP address or Domain Name Service (DNS) name of the NameNode. An agent that's installed on-premises uses this hostname to communicate with the NameNode in the network.</p>
    pub fn hostname(&self) -> std::option::Option<&str> {
        self.hostname.as_deref()
    }
    /// <p>The port that the NameNode uses to listen to client requests.</p>
    pub fn port(&self) -> std::option::Option<i32> {
        self.port
    }
}
/// See [`HdfsNameNode`](crate::model::HdfsNameNode).
pub mod hdfs_name_node {

    /// A builder for [`HdfsNameNode`](crate::model::HdfsNameNode).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hostname: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The hostname of the NameNode in the HDFS cluster. This value is the IP address or Domain Name Service (DNS) name of the NameNode. An agent that's installed on-premises uses this hostname to communicate with the NameNode in the network.</p>
        pub fn hostname(mut self, input: impl Into<std::string::String>) -> Self {
            self.hostname = Some(input.into());
            self
        }
        /// <p>The hostname of the NameNode in the HDFS cluster. This value is the IP address or Domain Name Service (DNS) name of the NameNode. An agent that's installed on-premises uses this hostname to communicate with the NameNode in the network.</p>
        pub fn set_hostname(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hostname = input;
            self
        }
        /// <p>The port that the NameNode uses to listen to client requests.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>The port that the NameNode uses to listen to client requests.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// Consumes the builder and constructs a [`HdfsNameNode`](crate::model::HdfsNameNode).
        pub fn build(self) -> crate::model::HdfsNameNode {
            crate::model::HdfsNameNode {
                hostname: self.hostname,
                port: self.port,
            }
        }
    }
}
impl HdfsNameNode {
    /// Creates a new builder-style object to manufacture [`HdfsNameNode`](crate::model::HdfsNameNode).
    pub fn builder() -> crate::model::hdfs_name_node::Builder {
        crate::model::hdfs_name_node::Builder::default()
    }
}

/// <p>A key-value pair representing a single tag that's been applied to an Amazon Web Services resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagListEntry {
    /// <p>The key for an Amazon Web Services resource tag.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The value for an Amazon Web Services resource tag.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl TagListEntry {
    /// <p>The key for an Amazon Web Services resource tag.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value for an Amazon Web Services resource tag.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`TagListEntry`](crate::model::TagListEntry).
pub mod tag_list_entry {

    /// A builder for [`TagListEntry`](crate::model::TagListEntry).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key for an Amazon Web Services resource tag.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The key for an Amazon Web Services resource tag.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value for an Amazon Web Services resource tag.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value for an Amazon Web Services resource tag.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`TagListEntry`](crate::model::TagListEntry).
        pub fn build(self) -> crate::model::TagListEntry {
            crate::model::TagListEntry {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl TagListEntry {
    /// Creates a new builder-style object to manufacture [`TagListEntry`](crate::model::TagListEntry).
    pub fn builder() -> crate::model::tag_list_entry::Builder {
        crate::model::tag_list_entry::Builder::default()
    }
}

/// <p>Represents a single entry in a list of tasks. <code>TaskListEntry</code> returns an array that contains a list of tasks when the <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_ListTasks.html">ListTasks</a> operation is called. A task includes the source and destination file systems to sync and the options to use for the tasks.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TaskListEntry {
    /// <p>The Amazon Resource Name (ARN) of the task.</p>
    #[doc(hidden)]
    pub task_arn: std::option::Option<std::string::String>,
    /// <p>The status of the task.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::TaskStatus>,
    /// <p>The name of the task.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl TaskListEntry {
    /// <p>The Amazon Resource Name (ARN) of the task.</p>
    pub fn task_arn(&self) -> std::option::Option<&str> {
        self.task_arn.as_deref()
    }
    /// <p>The status of the task.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::TaskStatus> {
        self.status.as_ref()
    }
    /// <p>The name of the task.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
/// See [`TaskListEntry`](crate::model::TaskListEntry).
pub mod task_list_entry {

    /// A builder for [`TaskListEntry`](crate::model::TaskListEntry).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::TaskStatus>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the task.</p>
        pub fn task_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the task.</p>
        pub fn set_task_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_arn = input;
            self
        }
        /// <p>The status of the task.</p>
        pub fn status(mut self, input: crate::model::TaskStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the task.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::TaskStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>The name of the task.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the task.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskListEntry`](crate::model::TaskListEntry).
        pub fn build(self) -> crate::model::TaskListEntry {
            crate::model::TaskListEntry {
                task_arn: self.task_arn,
                status: self.status,
                name: self.name,
            }
        }
    }
}
impl TaskListEntry {
    /// Creates a new builder-style object to manufacture [`TaskListEntry`](crate::model::TaskListEntry).
    pub fn builder() -> crate::model::task_list_entry::Builder {
        crate::model::task_list_entry::Builder::default()
    }
}

/// When writing a match expression against `TaskStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let taskstatus = unimplemented!();
/// match taskstatus {
///     TaskStatus::Available => { /* ... */ },
///     TaskStatus::Creating => { /* ... */ },
///     TaskStatus::Queued => { /* ... */ },
///     TaskStatus::Running => { /* ... */ },
///     TaskStatus::Unavailable => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `taskstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TaskStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TaskStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TaskStatus::NewFeature` is defined.
/// Specifically, when `taskstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TaskStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TaskStatus {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Queued,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Unavailable,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TaskStatus {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => TaskStatus::Available,
            "CREATING" => TaskStatus::Creating,
            "QUEUED" => TaskStatus::Queued,
            "RUNNING" => TaskStatus::Running,
            "UNAVAILABLE" => TaskStatus::Unavailable,
            other => TaskStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TaskStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TaskStatus::from(s))
    }
}
impl TaskStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TaskStatus::Available => "AVAILABLE",
            TaskStatus::Creating => "CREATING",
            TaskStatus::Queued => "QUEUED",
            TaskStatus::Running => "RUNNING",
            TaskStatus::Unavailable => "UNAVAILABLE",
            TaskStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AVAILABLE", "CREATING", "QUEUED", "RUNNING", "UNAVAILABLE"]
    }
}
impl AsRef<str> for TaskStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>You can use API filters to narrow down the list of resources returned by <code>ListTasks</code>. For example, to retrieve all tasks on a source location, you can use <code>ListTasks</code> with filter name <code>LocationId</code> and <code>Operator Equals</code> with the ARN for the location.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/query-resources.html">filtering DataSync resources</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TaskFilter {
    /// <p>The name of the filter being used. Each API call supports a list of filters that are available for it. For example, <code>LocationId</code> for <code>ListTasks</code>.</p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::TaskFilterName>,
    /// <p>The values that you want to filter for. For example, you might want to display only tasks for a specific destination location.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The operator that is used to compare filter values (for example, <code>Equals</code> or <code>Contains</code>).</p>
    #[doc(hidden)]
    pub operator: std::option::Option<crate::model::Operator>,
}
impl TaskFilter {
    /// <p>The name of the filter being used. Each API call supports a list of filters that are available for it. For example, <code>LocationId</code> for <code>ListTasks</code>.</p>
    pub fn name(&self) -> std::option::Option<&crate::model::TaskFilterName> {
        self.name.as_ref()
    }
    /// <p>The values that you want to filter for. For example, you might want to display only tasks for a specific destination location.</p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
    /// <p>The operator that is used to compare filter values (for example, <code>Equals</code> or <code>Contains</code>).</p>
    pub fn operator(&self) -> std::option::Option<&crate::model::Operator> {
        self.operator.as_ref()
    }
}
/// See [`TaskFilter`](crate::model::TaskFilter).
pub mod task_filter {

    /// A builder for [`TaskFilter`](crate::model::TaskFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::TaskFilterName>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) operator: std::option::Option<crate::model::Operator>,
    }
    impl Builder {
        /// <p>The name of the filter being used. Each API call supports a list of filters that are available for it. For example, <code>LocationId</code> for <code>ListTasks</code>.</p>
        pub fn name(mut self, input: crate::model::TaskFilterName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the filter being used. Each API call supports a list of filters that are available for it. For example, <code>LocationId</code> for <code>ListTasks</code>.</p>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::TaskFilterName>,
        ) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The values that you want to filter for. For example, you might want to display only tasks for a specific destination location.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>The values that you want to filter for. For example, you might want to display only tasks for a specific destination location.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// <p>The operator that is used to compare filter values (for example, <code>Equals</code> or <code>Contains</code>).</p>
        pub fn operator(mut self, input: crate::model::Operator) -> Self {
            self.operator = Some(input);
            self
        }
        /// <p>The operator that is used to compare filter values (for example, <code>Equals</code> or <code>Contains</code>).</p>
        pub fn set_operator(mut self, input: std::option::Option<crate::model::Operator>) -> Self {
            self.operator = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskFilter`](crate::model::TaskFilter).
        pub fn build(self) -> crate::model::TaskFilter {
            crate::model::TaskFilter {
                name: self.name,
                values: self.values,
                operator: self.operator,
            }
        }
    }
}
impl TaskFilter {
    /// Creates a new builder-style object to manufacture [`TaskFilter`](crate::model::TaskFilter).
    pub fn builder() -> crate::model::task_filter::Builder {
        crate::model::task_filter::Builder::default()
    }
}

/// When writing a match expression against `Operator`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let operator = unimplemented!();
/// match operator {
///     Operator::BeginsWith => { /* ... */ },
///     Operator::Contains => { /* ... */ },
///     Operator::Eq => { /* ... */ },
///     Operator::Gt => { /* ... */ },
///     Operator::Ge => { /* ... */ },
///     Operator::In => { /* ... */ },
///     Operator::Lt => { /* ... */ },
///     Operator::Le => { /* ... */ },
///     Operator::NotContains => { /* ... */ },
///     Operator::Ne => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `operator` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Operator::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Operator::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Operator::NewFeature` is defined.
/// Specifically, when `operator` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Operator::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Operator {
    #[allow(missing_docs)] // documentation missing in model
    BeginsWith,
    #[allow(missing_docs)] // documentation missing in model
    Contains,
    #[allow(missing_docs)] // documentation missing in model
    Eq,
    #[allow(missing_docs)] // documentation missing in model
    Gt,
    #[allow(missing_docs)] // documentation missing in model
    Ge,
    #[allow(missing_docs)] // documentation missing in model
    In,
    #[allow(missing_docs)] // documentation missing in model
    Lt,
    #[allow(missing_docs)] // documentation missing in model
    Le,
    #[allow(missing_docs)] // documentation missing in model
    NotContains,
    #[allow(missing_docs)] // documentation missing in model
    Ne,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Operator {
    fn from(s: &str) -> Self {
        match s {
            "BeginsWith" => Operator::BeginsWith,
            "Contains" => Operator::Contains,
            "Equals" => Operator::Eq,
            "GreaterThan" => Operator::Gt,
            "GreaterThanOrEqual" => Operator::Ge,
            "In" => Operator::In,
            "LessThan" => Operator::Lt,
            "LessThanOrEqual" => Operator::Le,
            "NotContains" => Operator::NotContains,
            "NotEquals" => Operator::Ne,
            other => Operator::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Operator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Operator::from(s))
    }
}
impl Operator {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Operator::BeginsWith => "BeginsWith",
            Operator::Contains => "Contains",
            Operator::Eq => "Equals",
            Operator::Gt => "GreaterThan",
            Operator::Ge => "GreaterThanOrEqual",
            Operator::In => "In",
            Operator::Lt => "LessThan",
            Operator::Le => "LessThanOrEqual",
            Operator::NotContains => "NotContains",
            Operator::Ne => "NotEquals",
            Operator::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BeginsWith",
            "Contains",
            "Equals",
            "GreaterThan",
            "GreaterThanOrEqual",
            "In",
            "LessThan",
            "LessThanOrEqual",
            "NotContains",
            "NotEquals",
        ]
    }
}
impl AsRef<str> for Operator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TaskFilterName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let taskfiltername = unimplemented!();
/// match taskfiltername {
///     TaskFilterName::CreationTime => { /* ... */ },
///     TaskFilterName::LocationId => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `taskfiltername` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TaskFilterName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TaskFilterName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TaskFilterName::NewFeature` is defined.
/// Specifically, when `taskfiltername` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TaskFilterName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TaskFilterName {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    LocationId,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TaskFilterName {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => TaskFilterName::CreationTime,
            "LocationId" => TaskFilterName::LocationId,
            other => TaskFilterName::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TaskFilterName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TaskFilterName::from(s))
    }
}
impl TaskFilterName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TaskFilterName::CreationTime => "CreationTime",
            TaskFilterName::LocationId => "LocationId",
            TaskFilterName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CreationTime", "LocationId"]
    }
}
impl AsRef<str> for TaskFilterName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Represents a single entry in a list of task executions. <code>TaskExecutionListEntry</code> returns an array that contains a list of specific invocations of a task when the <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_ListTaskExecutions.html">ListTaskExecutions</a> operation is called.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TaskExecutionListEntry {
    /// <p>The Amazon Resource Name (ARN) of the task that was executed.</p>
    #[doc(hidden)]
    pub task_execution_arn: std::option::Option<std::string::String>,
    /// <p>The status of a task execution.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::TaskExecutionStatus>,
}
impl TaskExecutionListEntry {
    /// <p>The Amazon Resource Name (ARN) of the task that was executed.</p>
    pub fn task_execution_arn(&self) -> std::option::Option<&str> {
        self.task_execution_arn.as_deref()
    }
    /// <p>The status of a task execution.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::TaskExecutionStatus> {
        self.status.as_ref()
    }
}
/// See [`TaskExecutionListEntry`](crate::model::TaskExecutionListEntry).
pub mod task_execution_list_entry {

    /// A builder for [`TaskExecutionListEntry`](crate::model::TaskExecutionListEntry).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_execution_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::TaskExecutionStatus>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the task that was executed.</p>
        pub fn task_execution_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_execution_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the task that was executed.</p>
        pub fn set_task_execution_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.task_execution_arn = input;
            self
        }
        /// <p>The status of a task execution.</p>
        pub fn status(mut self, input: crate::model::TaskExecutionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of a task execution.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TaskExecutionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskExecutionListEntry`](crate::model::TaskExecutionListEntry).
        pub fn build(self) -> crate::model::TaskExecutionListEntry {
            crate::model::TaskExecutionListEntry {
                task_execution_arn: self.task_execution_arn,
                status: self.status,
            }
        }
    }
}
impl TaskExecutionListEntry {
    /// Creates a new builder-style object to manufacture [`TaskExecutionListEntry`](crate::model::TaskExecutionListEntry).
    pub fn builder() -> crate::model::task_execution_list_entry::Builder {
        crate::model::task_execution_list_entry::Builder::default()
    }
}

/// When writing a match expression against `TaskExecutionStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let taskexecutionstatus = unimplemented!();
/// match taskexecutionstatus {
///     TaskExecutionStatus::Error => { /* ... */ },
///     TaskExecutionStatus::Launching => { /* ... */ },
///     TaskExecutionStatus::Preparing => { /* ... */ },
///     TaskExecutionStatus::Queued => { /* ... */ },
///     TaskExecutionStatus::Success => { /* ... */ },
///     TaskExecutionStatus::Transferring => { /* ... */ },
///     TaskExecutionStatus::Verifying => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `taskexecutionstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TaskExecutionStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TaskExecutionStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TaskExecutionStatus::NewFeature` is defined.
/// Specifically, when `taskexecutionstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TaskExecutionStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TaskExecutionStatus {
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Launching,
    #[allow(missing_docs)] // documentation missing in model
    Preparing,
    #[allow(missing_docs)] // documentation missing in model
    Queued,
    #[allow(missing_docs)] // documentation missing in model
    Success,
    #[allow(missing_docs)] // documentation missing in model
    Transferring,
    #[allow(missing_docs)] // documentation missing in model
    Verifying,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TaskExecutionStatus {
    fn from(s: &str) -> Self {
        match s {
            "ERROR" => TaskExecutionStatus::Error,
            "LAUNCHING" => TaskExecutionStatus::Launching,
            "PREPARING" => TaskExecutionStatus::Preparing,
            "QUEUED" => TaskExecutionStatus::Queued,
            "SUCCESS" => TaskExecutionStatus::Success,
            "TRANSFERRING" => TaskExecutionStatus::Transferring,
            "VERIFYING" => TaskExecutionStatus::Verifying,
            other => {
                TaskExecutionStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for TaskExecutionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TaskExecutionStatus::from(s))
    }
}
impl TaskExecutionStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TaskExecutionStatus::Error => "ERROR",
            TaskExecutionStatus::Launching => "LAUNCHING",
            TaskExecutionStatus::Preparing => "PREPARING",
            TaskExecutionStatus::Queued => "QUEUED",
            TaskExecutionStatus::Success => "SUCCESS",
            TaskExecutionStatus::Transferring => "TRANSFERRING",
            TaskExecutionStatus::Verifying => "VERIFYING",
            TaskExecutionStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ERROR",
            "LAUNCHING",
            "PREPARING",
            "QUEUED",
            "SUCCESS",
            "TRANSFERRING",
            "VERIFYING",
        ]
    }
}
impl AsRef<str> for TaskExecutionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Represents a single entry in a list of locations. <code>LocationListEntry</code> returns an array that contains a list of locations when the <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_ListLocations.html">ListLocations</a> operation is called.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LocationListEntry {
    /// <p>The Amazon Resource Name (ARN) of the location. For Network File System (NFS) or Amazon EFS, the location is the export path. For Amazon S3, the location is the prefix path that you want to mount and use as the root of the location.</p>
    #[doc(hidden)]
    pub location_arn: std::option::Option<std::string::String>,
    /// <p>Represents a list of URIs of a location. <code>LocationUri</code> returns an array that contains a list of locations when the <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_ListLocations.html">ListLocations</a> operation is called.</p>
    /// <p>Format: <code>TYPE://GLOBAL_ID/SUBDIR</code>.</p>
    /// <p>TYPE designates the type of location (for example, <code>nfs</code> or <code>s3</code>).</p>
    /// <p>GLOBAL_ID is the globally unique identifier of the resource that backs the location. An example for EFS is <code>us-east-2.fs-abcd1234</code>. An example for Amazon S3 is the bucket name, such as <code>myBucket</code>. An example for NFS is a valid IPv4 address or a hostname that is compliant with Domain Name Service (DNS).</p>
    /// <p>SUBDIR is a valid file system path, delimited by forward slashes as is the *nix convention. For NFS and Amazon EFS, it's the export path to mount the location. For Amazon S3, it's the prefix path that you mount to and treat as the root of the location.</p>
    /// <p></p>
    #[doc(hidden)]
    pub location_uri: std::option::Option<std::string::String>,
}
impl LocationListEntry {
    /// <p>The Amazon Resource Name (ARN) of the location. For Network File System (NFS) or Amazon EFS, the location is the export path. For Amazon S3, the location is the prefix path that you want to mount and use as the root of the location.</p>
    pub fn location_arn(&self) -> std::option::Option<&str> {
        self.location_arn.as_deref()
    }
    /// <p>Represents a list of URIs of a location. <code>LocationUri</code> returns an array that contains a list of locations when the <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_ListLocations.html">ListLocations</a> operation is called.</p>
    /// <p>Format: <code>TYPE://GLOBAL_ID/SUBDIR</code>.</p>
    /// <p>TYPE designates the type of location (for example, <code>nfs</code> or <code>s3</code>).</p>
    /// <p>GLOBAL_ID is the globally unique identifier of the resource that backs the location. An example for EFS is <code>us-east-2.fs-abcd1234</code>. An example for Amazon S3 is the bucket name, such as <code>myBucket</code>. An example for NFS is a valid IPv4 address or a hostname that is compliant with Domain Name Service (DNS).</p>
    /// <p>SUBDIR is a valid file system path, delimited by forward slashes as is the *nix convention. For NFS and Amazon EFS, it's the export path to mount the location. For Amazon S3, it's the prefix path that you mount to and treat as the root of the location.</p>
    /// <p></p>
    pub fn location_uri(&self) -> std::option::Option<&str> {
        self.location_uri.as_deref()
    }
}
/// See [`LocationListEntry`](crate::model::LocationListEntry).
pub mod location_list_entry {

    /// A builder for [`LocationListEntry`](crate::model::LocationListEntry).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) location_arn: std::option::Option<std::string::String>,
        pub(crate) location_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the location. For Network File System (NFS) or Amazon EFS, the location is the export path. For Amazon S3, the location is the prefix path that you want to mount and use as the root of the location.</p>
        pub fn location_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.location_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the location. For Network File System (NFS) or Amazon EFS, the location is the export path. For Amazon S3, the location is the prefix path that you want to mount and use as the root of the location.</p>
        pub fn set_location_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.location_arn = input;
            self
        }
        /// <p>Represents a list of URIs of a location. <code>LocationUri</code> returns an array that contains a list of locations when the <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_ListLocations.html">ListLocations</a> operation is called.</p>
        /// <p>Format: <code>TYPE://GLOBAL_ID/SUBDIR</code>.</p>
        /// <p>TYPE designates the type of location (for example, <code>nfs</code> or <code>s3</code>).</p>
        /// <p>GLOBAL_ID is the globally unique identifier of the resource that backs the location. An example for EFS is <code>us-east-2.fs-abcd1234</code>. An example for Amazon S3 is the bucket name, such as <code>myBucket</code>. An example for NFS is a valid IPv4 address or a hostname that is compliant with Domain Name Service (DNS).</p>
        /// <p>SUBDIR is a valid file system path, delimited by forward slashes as is the *nix convention. For NFS and Amazon EFS, it's the export path to mount the location. For Amazon S3, it's the prefix path that you mount to and treat as the root of the location.</p>
        /// <p></p>
        pub fn location_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.location_uri = Some(input.into());
            self
        }
        /// <p>Represents a list of URIs of a location. <code>LocationUri</code> returns an array that contains a list of locations when the <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_ListLocations.html">ListLocations</a> operation is called.</p>
        /// <p>Format: <code>TYPE://GLOBAL_ID/SUBDIR</code>.</p>
        /// <p>TYPE designates the type of location (for example, <code>nfs</code> or <code>s3</code>).</p>
        /// <p>GLOBAL_ID is the globally unique identifier of the resource that backs the location. An example for EFS is <code>us-east-2.fs-abcd1234</code>. An example for Amazon S3 is the bucket name, such as <code>myBucket</code>. An example for NFS is a valid IPv4 address or a hostname that is compliant with Domain Name Service (DNS).</p>
        /// <p>SUBDIR is a valid file system path, delimited by forward slashes as is the *nix convention. For NFS and Amazon EFS, it's the export path to mount the location. For Amazon S3, it's the prefix path that you mount to and treat as the root of the location.</p>
        /// <p></p>
        pub fn set_location_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.location_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`LocationListEntry`](crate::model::LocationListEntry).
        pub fn build(self) -> crate::model::LocationListEntry {
            crate::model::LocationListEntry {
                location_arn: self.location_arn,
                location_uri: self.location_uri,
            }
        }
    }
}
impl LocationListEntry {
    /// Creates a new builder-style object to manufacture [`LocationListEntry`](crate::model::LocationListEntry).
    pub fn builder() -> crate::model::location_list_entry::Builder {
        crate::model::location_list_entry::Builder::default()
    }
}

/// <p>Narrow down the list of resources returned by <code>ListLocations</code>. For example, to see all your Amazon S3 locations, create a filter using <code>"Name": "LocationType"</code>, <code>"Operator": "Equals"</code>, and <code>"Values": "S3"</code>.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/query-resources.html">filtering resources</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LocationFilter {
    /// <p>The name of the filter being used. Each API call supports a list of filters that are available for it (for example, <code>LocationType</code> for <code>ListLocations</code>).</p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::LocationFilterName>,
    /// <p>The values that you want to filter for. For example, you might want to display only Amazon S3 locations.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The operator that is used to compare filter values (for example, <code>Equals</code> or <code>Contains</code>).</p>
    #[doc(hidden)]
    pub operator: std::option::Option<crate::model::Operator>,
}
impl LocationFilter {
    /// <p>The name of the filter being used. Each API call supports a list of filters that are available for it (for example, <code>LocationType</code> for <code>ListLocations</code>).</p>
    pub fn name(&self) -> std::option::Option<&crate::model::LocationFilterName> {
        self.name.as_ref()
    }
    /// <p>The values that you want to filter for. For example, you might want to display only Amazon S3 locations.</p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
    /// <p>The operator that is used to compare filter values (for example, <code>Equals</code> or <code>Contains</code>).</p>
    pub fn operator(&self) -> std::option::Option<&crate::model::Operator> {
        self.operator.as_ref()
    }
}
/// See [`LocationFilter`](crate::model::LocationFilter).
pub mod location_filter {

    /// A builder for [`LocationFilter`](crate::model::LocationFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::LocationFilterName>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) operator: std::option::Option<crate::model::Operator>,
    }
    impl Builder {
        /// <p>The name of the filter being used. Each API call supports a list of filters that are available for it (for example, <code>LocationType</code> for <code>ListLocations</code>).</p>
        pub fn name(mut self, input: crate::model::LocationFilterName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the filter being used. Each API call supports a list of filters that are available for it (for example, <code>LocationType</code> for <code>ListLocations</code>).</p>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::LocationFilterName>,
        ) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The values that you want to filter for. For example, you might want to display only Amazon S3 locations.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>The values that you want to filter for. For example, you might want to display only Amazon S3 locations.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// <p>The operator that is used to compare filter values (for example, <code>Equals</code> or <code>Contains</code>).</p>
        pub fn operator(mut self, input: crate::model::Operator) -> Self {
            self.operator = Some(input);
            self
        }
        /// <p>The operator that is used to compare filter values (for example, <code>Equals</code> or <code>Contains</code>).</p>
        pub fn set_operator(mut self, input: std::option::Option<crate::model::Operator>) -> Self {
            self.operator = input;
            self
        }
        /// Consumes the builder and constructs a [`LocationFilter`](crate::model::LocationFilter).
        pub fn build(self) -> crate::model::LocationFilter {
            crate::model::LocationFilter {
                name: self.name,
                values: self.values,
                operator: self.operator,
            }
        }
    }
}
impl LocationFilter {
    /// Creates a new builder-style object to manufacture [`LocationFilter`](crate::model::LocationFilter).
    pub fn builder() -> crate::model::location_filter::Builder {
        crate::model::location_filter::Builder::default()
    }
}

/// When writing a match expression against `LocationFilterName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let locationfiltername = unimplemented!();
/// match locationfiltername {
///     LocationFilterName::CreationTime => { /* ... */ },
///     LocationFilterName::LocationType => { /* ... */ },
///     LocationFilterName::LocationUri => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `locationfiltername` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LocationFilterName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LocationFilterName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LocationFilterName::NewFeature` is defined.
/// Specifically, when `locationfiltername` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LocationFilterName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LocationFilterName {
    #[allow(missing_docs)] // documentation missing in model
    CreationTime,
    #[allow(missing_docs)] // documentation missing in model
    LocationType,
    #[allow(missing_docs)] // documentation missing in model
    LocationUri,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LocationFilterName {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => LocationFilterName::CreationTime,
            "LocationType" => LocationFilterName::LocationType,
            "LocationUri" => LocationFilterName::LocationUri,
            other => {
                LocationFilterName::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for LocationFilterName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LocationFilterName::from(s))
    }
}
impl LocationFilterName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LocationFilterName::CreationTime => "CreationTime",
            LocationFilterName::LocationType => "LocationType",
            LocationFilterName::LocationUri => "LocationUri",
            LocationFilterName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CreationTime", "LocationType", "LocationUri"]
    }
}
impl AsRef<str> for LocationFilterName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Represents a single entry in a list of agents. <code>AgentListEntry</code> returns an array that contains a list of agents when the <a href="https://docs.aws.amazon.com/datasync/latest/userguide/API_ListAgents.html">ListAgents</a> operation is called.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AgentListEntry {
    /// <p>The Amazon Resource Name (ARN) of the agent.</p>
    #[doc(hidden)]
    pub agent_arn: std::option::Option<std::string::String>,
    /// <p>The name of the agent.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The status of the agent.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::AgentStatus>,
}
impl AgentListEntry {
    /// <p>The Amazon Resource Name (ARN) of the agent.</p>
    pub fn agent_arn(&self) -> std::option::Option<&str> {
        self.agent_arn.as_deref()
    }
    /// <p>The name of the agent.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The status of the agent.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::AgentStatus> {
        self.status.as_ref()
    }
}
/// See [`AgentListEntry`](crate::model::AgentListEntry).
pub mod agent_list_entry {

    /// A builder for [`AgentListEntry`](crate::model::AgentListEntry).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) agent_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::AgentStatus>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the agent.</p>
        pub fn agent_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.agent_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the agent.</p>
        pub fn set_agent_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.agent_arn = input;
            self
        }
        /// <p>The name of the agent.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the agent.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The status of the agent.</p>
        pub fn status(mut self, input: crate::model::AgentStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the agent.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::AgentStatus>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AgentListEntry`](crate::model::AgentListEntry).
        pub fn build(self) -> crate::model::AgentListEntry {
            crate::model::AgentListEntry {
                agent_arn: self.agent_arn,
                name: self.name,
                status: self.status,
            }
        }
    }
}
impl AgentListEntry {
    /// Creates a new builder-style object to manufacture [`AgentListEntry`](crate::model::AgentListEntry).
    pub fn builder() -> crate::model::agent_list_entry::Builder {
        crate::model::agent_list_entry::Builder::default()
    }
}

/// When writing a match expression against `AgentStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let agentstatus = unimplemented!();
/// match agentstatus {
///     AgentStatus::Offline => { /* ... */ },
///     AgentStatus::Online => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `agentstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AgentStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AgentStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AgentStatus::NewFeature` is defined.
/// Specifically, when `agentstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AgentStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AgentStatus {
    #[allow(missing_docs)] // documentation missing in model
    Offline,
    #[allow(missing_docs)] // documentation missing in model
    Online,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AgentStatus {
    fn from(s: &str) -> Self {
        match s {
            "OFFLINE" => AgentStatus::Offline,
            "ONLINE" => AgentStatus::Online,
            other => AgentStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AgentStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AgentStatus::from(s))
    }
}
impl AgentStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AgentStatus::Offline => "OFFLINE",
            AgentStatus::Online => "ONLINE",
            AgentStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["OFFLINE", "ONLINE"]
    }
}
impl AsRef<str> for AgentStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the detailed result of a <code>TaskExecution</code> operation. This result includes the time in milliseconds spent in each phase, the status of the task execution, and the errors encountered.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TaskExecutionResultDetail {
    /// <p>The total time in milliseconds that DataSync spent in the PREPARING phase. </p>
    #[doc(hidden)]
    pub prepare_duration: std::option::Option<i64>,
    /// <p>The status of the PREPARING phase.</p>
    #[doc(hidden)]
    pub prepare_status: std::option::Option<crate::model::PhaseStatus>,
    /// <p>The total time in milliseconds that DataSync took to transfer the file from the source to the destination location.</p>
    #[doc(hidden)]
    pub total_duration: std::option::Option<i64>,
    /// <p>The total time in milliseconds that DataSync spent in the TRANSFERRING phase.</p>
    #[doc(hidden)]
    pub transfer_duration: std::option::Option<i64>,
    /// <p>The status of the TRANSFERRING phase.</p>
    #[doc(hidden)]
    pub transfer_status: std::option::Option<crate::model::PhaseStatus>,
    /// <p>The total time in milliseconds that DataSync spent in the VERIFYING phase.</p>
    #[doc(hidden)]
    pub verify_duration: std::option::Option<i64>,
    /// <p>The status of the VERIFYING phase.</p>
    #[doc(hidden)]
    pub verify_status: std::option::Option<crate::model::PhaseStatus>,
    /// <p>Errors that DataSync encountered during execution of the task. You can use this error code to help troubleshoot issues.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>Detailed description of an error that was encountered during the task execution. You can use this information to help troubleshoot issues. </p>
    #[doc(hidden)]
    pub error_detail: std::option::Option<std::string::String>,
}
impl TaskExecutionResultDetail {
    /// <p>The total time in milliseconds that DataSync spent in the PREPARING phase. </p>
    pub fn prepare_duration(&self) -> std::option::Option<i64> {
        self.prepare_duration
    }
    /// <p>The status of the PREPARING phase.</p>
    pub fn prepare_status(&self) -> std::option::Option<&crate::model::PhaseStatus> {
        self.prepare_status.as_ref()
    }
    /// <p>The total time in milliseconds that DataSync took to transfer the file from the source to the destination location.</p>
    pub fn total_duration(&self) -> std::option::Option<i64> {
        self.total_duration
    }
    /// <p>The total time in milliseconds that DataSync spent in the TRANSFERRING phase.</p>
    pub fn transfer_duration(&self) -> std::option::Option<i64> {
        self.transfer_duration
    }
    /// <p>The status of the TRANSFERRING phase.</p>
    pub fn transfer_status(&self) -> std::option::Option<&crate::model::PhaseStatus> {
        self.transfer_status.as_ref()
    }
    /// <p>The total time in milliseconds that DataSync spent in the VERIFYING phase.</p>
    pub fn verify_duration(&self) -> std::option::Option<i64> {
        self.verify_duration
    }
    /// <p>The status of the VERIFYING phase.</p>
    pub fn verify_status(&self) -> std::option::Option<&crate::model::PhaseStatus> {
        self.verify_status.as_ref()
    }
    /// <p>Errors that DataSync encountered during execution of the task. You can use this error code to help troubleshoot issues.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>Detailed description of an error that was encountered during the task execution. You can use this information to help troubleshoot issues. </p>
    pub fn error_detail(&self) -> std::option::Option<&str> {
        self.error_detail.as_deref()
    }
}
/// See [`TaskExecutionResultDetail`](crate::model::TaskExecutionResultDetail).
pub mod task_execution_result_detail {

    /// A builder for [`TaskExecutionResultDetail`](crate::model::TaskExecutionResultDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) prepare_duration: std::option::Option<i64>,
        pub(crate) prepare_status: std::option::Option<crate::model::PhaseStatus>,
        pub(crate) total_duration: std::option::Option<i64>,
        pub(crate) transfer_duration: std::option::Option<i64>,
        pub(crate) transfer_status: std::option::Option<crate::model::PhaseStatus>,
        pub(crate) verify_duration: std::option::Option<i64>,
        pub(crate) verify_status: std::option::Option<crate::model::PhaseStatus>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_detail: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The total time in milliseconds that DataSync spent in the PREPARING phase. </p>
        pub fn prepare_duration(mut self, input: i64) -> Self {
            self.prepare_duration = Some(input);
            self
        }
        /// <p>The total time in milliseconds that DataSync spent in the PREPARING phase. </p>
        pub fn set_prepare_duration(mut self, input: std::option::Option<i64>) -> Self {
            self.prepare_duration = input;
            self
        }
        /// <p>The status of the PREPARING phase.</p>
        pub fn prepare_status(mut self, input: crate::model::PhaseStatus) -> Self {
            self.prepare_status = Some(input);
            self
        }
        /// <p>The status of the PREPARING phase.</p>
        pub fn set_prepare_status(
            mut self,
            input: std::option::Option<crate::model::PhaseStatus>,
        ) -> Self {
            self.prepare_status = input;
            self
        }
        /// <p>The total time in milliseconds that DataSync took to transfer the file from the source to the destination location.</p>
        pub fn total_duration(mut self, input: i64) -> Self {
            self.total_duration = Some(input);
            self
        }
        /// <p>The total time in milliseconds that DataSync took to transfer the file from the source to the destination location.</p>
        pub fn set_total_duration(mut self, input: std::option::Option<i64>) -> Self {
            self.total_duration = input;
            self
        }
        /// <p>The total time in milliseconds that DataSync spent in the TRANSFERRING phase.</p>
        pub fn transfer_duration(mut self, input: i64) -> Self {
            self.transfer_duration = Some(input);
            self
        }
        /// <p>The total time in milliseconds that DataSync spent in the TRANSFERRING phase.</p>
        pub fn set_transfer_duration(mut self, input: std::option::Option<i64>) -> Self {
            self.transfer_duration = input;
            self
        }
        /// <p>The status of the TRANSFERRING phase.</p>
        pub fn transfer_status(mut self, input: crate::model::PhaseStatus) -> Self {
            self.transfer_status = Some(input);
            self
        }
        /// <p>The status of the TRANSFERRING phase.</p>
        pub fn set_transfer_status(
            mut self,
            input: std::option::Option<crate::model::PhaseStatus>,
        ) -> Self {
            self.transfer_status = input;
            self
        }
        /// <p>The total time in milliseconds that DataSync spent in the VERIFYING phase.</p>
        pub fn verify_duration(mut self, input: i64) -> Self {
            self.verify_duration = Some(input);
            self
        }
        /// <p>The total time in milliseconds that DataSync spent in the VERIFYING phase.</p>
        pub fn set_verify_duration(mut self, input: std::option::Option<i64>) -> Self {
            self.verify_duration = input;
            self
        }
        /// <p>The status of the VERIFYING phase.</p>
        pub fn verify_status(mut self, input: crate::model::PhaseStatus) -> Self {
            self.verify_status = Some(input);
            self
        }
        /// <p>The status of the VERIFYING phase.</p>
        pub fn set_verify_status(
            mut self,
            input: std::option::Option<crate::model::PhaseStatus>,
        ) -> Self {
            self.verify_status = input;
            self
        }
        /// <p>Errors that DataSync encountered during execution of the task. You can use this error code to help troubleshoot issues.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>Errors that DataSync encountered during execution of the task. You can use this error code to help troubleshoot issues.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>Detailed description of an error that was encountered during the task execution. You can use this information to help troubleshoot issues. </p>
        pub fn error_detail(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_detail = Some(input.into());
            self
        }
        /// <p>Detailed description of an error that was encountered during the task execution. You can use this information to help troubleshoot issues. </p>
        pub fn set_error_detail(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_detail = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskExecutionResultDetail`](crate::model::TaskExecutionResultDetail).
        pub fn build(self) -> crate::model::TaskExecutionResultDetail {
            crate::model::TaskExecutionResultDetail {
                prepare_duration: self.prepare_duration,
                prepare_status: self.prepare_status,
                total_duration: self.total_duration,
                transfer_duration: self.transfer_duration,
                transfer_status: self.transfer_status,
                verify_duration: self.verify_duration,
                verify_status: self.verify_status,
                error_code: self.error_code,
                error_detail: self.error_detail,
            }
        }
    }
}
impl TaskExecutionResultDetail {
    /// Creates a new builder-style object to manufacture [`TaskExecutionResultDetail`](crate::model::TaskExecutionResultDetail).
    pub fn builder() -> crate::model::task_execution_result_detail::Builder {
        crate::model::task_execution_result_detail::Builder::default()
    }
}

/// When writing a match expression against `PhaseStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let phasestatus = unimplemented!();
/// match phasestatus {
///     PhaseStatus::Error => { /* ... */ },
///     PhaseStatus::Pending => { /* ... */ },
///     PhaseStatus::Success => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `phasestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PhaseStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PhaseStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PhaseStatus::NewFeature` is defined.
/// Specifically, when `phasestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PhaseStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PhaseStatus {
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Success,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PhaseStatus {
    fn from(s: &str) -> Self {
        match s {
            "ERROR" => PhaseStatus::Error,
            "PENDING" => PhaseStatus::Pending,
            "SUCCESS" => PhaseStatus::Success,
            other => PhaseStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PhaseStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PhaseStatus::from(s))
    }
}
impl PhaseStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PhaseStatus::Error => "ERROR",
            PhaseStatus::Pending => "PENDING",
            PhaseStatus::Success => "SUCCESS",
            PhaseStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ERROR", "PENDING", "SUCCESS"]
    }
}
impl AsRef<str> for PhaseStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role used to access an Amazon S3 bucket.</p>
/// <p>For detailed information about using such a role, see Creating a Location for Amazon S3 in the <i>DataSync User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3Config {
    /// <p>The ARN of the IAM role for accessing the S3 bucket. </p>
    #[doc(hidden)]
    pub bucket_access_role_arn: std::option::Option<std::string::String>,
}
impl S3Config {
    /// <p>The ARN of the IAM role for accessing the S3 bucket. </p>
    pub fn bucket_access_role_arn(&self) -> std::option::Option<&str> {
        self.bucket_access_role_arn.as_deref()
    }
}
/// See [`S3Config`](crate::model::S3Config).
pub mod s3_config {

    /// A builder for [`S3Config`](crate::model::S3Config).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_access_role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the IAM role for accessing the S3 bucket. </p>
        pub fn bucket_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_access_role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the IAM role for accessing the S3 bucket. </p>
        pub fn set_bucket_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.bucket_access_role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`S3Config`](crate::model::S3Config).
        pub fn build(self) -> crate::model::S3Config {
            crate::model::S3Config {
                bucket_access_role_arn: self.bucket_access_role_arn,
            }
        }
    }
}
impl S3Config {
    /// Creates a new builder-style object to manufacture [`S3Config`](crate::model::S3Config).
    pub fn builder() -> crate::model::s3_config::Builder {
        crate::model::s3_config::Builder::default()
    }
}

/// When writing a match expression against `S3StorageClass`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let s3storageclass = unimplemented!();
/// match s3storageclass {
///     S3StorageClass::DeepArchive => { /* ... */ },
///     S3StorageClass::Glacier => { /* ... */ },
///     S3StorageClass::GlacierInstantRetrieval => { /* ... */ },
///     S3StorageClass::IntelligentTiering => { /* ... */ },
///     S3StorageClass::OnezoneIa => { /* ... */ },
///     S3StorageClass::Outposts => { /* ... */ },
///     S3StorageClass::Standard => { /* ... */ },
///     S3StorageClass::StandardIa => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `s3storageclass` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `S3StorageClass::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `S3StorageClass::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `S3StorageClass::NewFeature` is defined.
/// Specifically, when `s3storageclass` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `S3StorageClass::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum S3StorageClass {
    #[allow(missing_docs)] // documentation missing in model
    DeepArchive,
    #[allow(missing_docs)] // documentation missing in model
    Glacier,
    #[allow(missing_docs)] // documentation missing in model
    GlacierInstantRetrieval,
    #[allow(missing_docs)] // documentation missing in model
    IntelligentTiering,
    #[allow(missing_docs)] // documentation missing in model
    OnezoneIa,
    #[allow(missing_docs)] // documentation missing in model
    Outposts,
    #[allow(missing_docs)] // documentation missing in model
    Standard,
    #[allow(missing_docs)] // documentation missing in model
    StandardIa,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for S3StorageClass {
    fn from(s: &str) -> Self {
        match s {
            "DEEP_ARCHIVE" => S3StorageClass::DeepArchive,
            "GLACIER" => S3StorageClass::Glacier,
            "GLACIER_INSTANT_RETRIEVAL" => S3StorageClass::GlacierInstantRetrieval,
            "INTELLIGENT_TIERING" => S3StorageClass::IntelligentTiering,
            "ONEZONE_IA" => S3StorageClass::OnezoneIa,
            "OUTPOSTS" => S3StorageClass::Outposts,
            "STANDARD" => S3StorageClass::Standard,
            "STANDARD_IA" => S3StorageClass::StandardIa,
            other => S3StorageClass::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for S3StorageClass {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(S3StorageClass::from(s))
    }
}
impl S3StorageClass {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            S3StorageClass::DeepArchive => "DEEP_ARCHIVE",
            S3StorageClass::Glacier => "GLACIER",
            S3StorageClass::GlacierInstantRetrieval => "GLACIER_INSTANT_RETRIEVAL",
            S3StorageClass::IntelligentTiering => "INTELLIGENT_TIERING",
            S3StorageClass::OnezoneIa => "ONEZONE_IA",
            S3StorageClass::Outposts => "OUTPOSTS",
            S3StorageClass::Standard => "STANDARD",
            S3StorageClass::StandardIa => "STANDARD_IA",
            S3StorageClass::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DEEP_ARCHIVE",
            "GLACIER",
            "GLACIER_INSTANT_RETRIEVAL",
            "INTELLIGENT_TIERING",
            "ONEZONE_IA",
            "OUTPOSTS",
            "STANDARD",
            "STANDARD_IA",
        ]
    }
}
impl AsRef<str> for S3StorageClass {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies the data transfer protocol that DataSync uses to access your Amazon FSx file system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FsxProtocol {
    /// <p>Specifies the Network File System (NFS) protocol configuration that DataSync uses to access your FSx for OpenZFS file system or FSx for ONTAP file system's storage virtual machine (SVM).</p>
    #[doc(hidden)]
    pub nfs: std::option::Option<crate::model::FsxProtocolNfs>,
    /// <p>Specifies the Server Message Block (SMB) protocol configuration that DataSync uses to access your FSx for ONTAP file system's SVM.</p>
    #[doc(hidden)]
    pub smb: std::option::Option<crate::model::FsxProtocolSmb>,
}
impl FsxProtocol {
    /// <p>Specifies the Network File System (NFS) protocol configuration that DataSync uses to access your FSx for OpenZFS file system or FSx for ONTAP file system's storage virtual machine (SVM).</p>
    pub fn nfs(&self) -> std::option::Option<&crate::model::FsxProtocolNfs> {
        self.nfs.as_ref()
    }
    /// <p>Specifies the Server Message Block (SMB) protocol configuration that DataSync uses to access your FSx for ONTAP file system's SVM.</p>
    pub fn smb(&self) -> std::option::Option<&crate::model::FsxProtocolSmb> {
        self.smb.as_ref()
    }
}
/// See [`FsxProtocol`](crate::model::FsxProtocol).
pub mod fsx_protocol {

    /// A builder for [`FsxProtocol`](crate::model::FsxProtocol).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) nfs: std::option::Option<crate::model::FsxProtocolNfs>,
        pub(crate) smb: std::option::Option<crate::model::FsxProtocolSmb>,
    }
    impl Builder {
        /// <p>Specifies the Network File System (NFS) protocol configuration that DataSync uses to access your FSx for OpenZFS file system or FSx for ONTAP file system's storage virtual machine (SVM).</p>
        pub fn nfs(mut self, input: crate::model::FsxProtocolNfs) -> Self {
            self.nfs = Some(input);
            self
        }
        /// <p>Specifies the Network File System (NFS) protocol configuration that DataSync uses to access your FSx for OpenZFS file system or FSx for ONTAP file system's storage virtual machine (SVM).</p>
        pub fn set_nfs(mut self, input: std::option::Option<crate::model::FsxProtocolNfs>) -> Self {
            self.nfs = input;
            self
        }
        /// <p>Specifies the Server Message Block (SMB) protocol configuration that DataSync uses to access your FSx for ONTAP file system's SVM.</p>
        pub fn smb(mut self, input: crate::model::FsxProtocolSmb) -> Self {
            self.smb = Some(input);
            self
        }
        /// <p>Specifies the Server Message Block (SMB) protocol configuration that DataSync uses to access your FSx for ONTAP file system's SVM.</p>
        pub fn set_smb(mut self, input: std::option::Option<crate::model::FsxProtocolSmb>) -> Self {
            self.smb = input;
            self
        }
        /// Consumes the builder and constructs a [`FsxProtocol`](crate::model::FsxProtocol).
        pub fn build(self) -> crate::model::FsxProtocol {
            crate::model::FsxProtocol {
                nfs: self.nfs,
                smb: self.smb,
            }
        }
    }
}
impl FsxProtocol {
    /// Creates a new builder-style object to manufacture [`FsxProtocol`](crate::model::FsxProtocol).
    pub fn builder() -> crate::model::fsx_protocol::Builder {
        crate::model::fsx_protocol::Builder::default()
    }
}

/// <p>Specifies the Server Message Block (SMB) protocol configuration that DataSync uses to access your Amazon FSx for NetApp ONTAP file system. For more information, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-ontap-location.html#create-ontap-location-access">Accessing FSx for ONTAP file systems</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FsxProtocolSmb {
    /// <p>Specifies the fully qualified domain name (FQDN) of the Microsoft Active Directory that your storage virtual machine (SVM) belongs to.</p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p>Specifies how DataSync can access a location using the SMB protocol.</p>
    #[doc(hidden)]
    pub mount_options: std::option::Option<crate::model::SmbMountOptions>,
    /// <p>Specifies the password of a user who has permission to access your SVM.</p>
    #[doc(hidden)]
    pub password: std::option::Option<std::string::String>,
    /// <p>Specifies a user name that can mount the location and access the files, folders, and metadata that you need in the SVM.</p>
    /// <p>If you provide a user in your Active Directory, note the following:</p>
    /// <ul>
    /// <li> <p>If you're using Directory Service for Microsoft Active Directory, the user must be a member of the Amazon Web Services Delegated FSx Administrators group.</p> </li>
    /// <li> <p>If you're using a self-managed Active Directory, the user must be a member of either the Domain Admins group or a custom group that you specified for file system administration when you created your file system.</p> </li>
    /// </ul>
    /// <p>Make sure that the user has the permissions it needs to copy the data you want:</p>
    /// <ul>
    /// <li> <p> <code>SE_TCB_NAME</code>: Required to set object ownership and file metadata. With this privilege, you also can copy NTFS discretionary access lists (DACLs).</p> </li>
    /// <li> <p> <code>SE_SECURITY_NAME</code>: May be needed to copy NTFS system access control lists (SACLs). This operation specifically requires the Windows privilege, which is granted to members of the Domain Admins group. If you configure your task to copy SACLs, make sure that the user has the required privileges. For information about copying SACLs, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-task.html#configure-ownership-and-permissions">Ownership and permissions-related options</a>.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub user: std::option::Option<std::string::String>,
}
impl FsxProtocolSmb {
    /// <p>Specifies the fully qualified domain name (FQDN) of the Microsoft Active Directory that your storage virtual machine (SVM) belongs to.</p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p>Specifies how DataSync can access a location using the SMB protocol.</p>
    pub fn mount_options(&self) -> std::option::Option<&crate::model::SmbMountOptions> {
        self.mount_options.as_ref()
    }
    /// <p>Specifies the password of a user who has permission to access your SVM.</p>
    pub fn password(&self) -> std::option::Option<&str> {
        self.password.as_deref()
    }
    /// <p>Specifies a user name that can mount the location and access the files, folders, and metadata that you need in the SVM.</p>
    /// <p>If you provide a user in your Active Directory, note the following:</p>
    /// <ul>
    /// <li> <p>If you're using Directory Service for Microsoft Active Directory, the user must be a member of the Amazon Web Services Delegated FSx Administrators group.</p> </li>
    /// <li> <p>If you're using a self-managed Active Directory, the user must be a member of either the Domain Admins group or a custom group that you specified for file system administration when you created your file system.</p> </li>
    /// </ul>
    /// <p>Make sure that the user has the permissions it needs to copy the data you want:</p>
    /// <ul>
    /// <li> <p> <code>SE_TCB_NAME</code>: Required to set object ownership and file metadata. With this privilege, you also can copy NTFS discretionary access lists (DACLs).</p> </li>
    /// <li> <p> <code>SE_SECURITY_NAME</code>: May be needed to copy NTFS system access control lists (SACLs). This operation specifically requires the Windows privilege, which is granted to members of the Domain Admins group. If you configure your task to copy SACLs, make sure that the user has the required privileges. For information about copying SACLs, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-task.html#configure-ownership-and-permissions">Ownership and permissions-related options</a>.</p> </li>
    /// </ul>
    pub fn user(&self) -> std::option::Option<&str> {
        self.user.as_deref()
    }
}
impl std::fmt::Debug for FsxProtocolSmb {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FsxProtocolSmb");
        formatter.field("domain", &self.domain);
        formatter.field("mount_options", &self.mount_options);
        formatter.field("password", &"*** Sensitive Data Redacted ***");
        formatter.field("user", &self.user);
        formatter.finish()
    }
}
/// See [`FsxProtocolSmb`](crate::model::FsxProtocolSmb).
pub mod fsx_protocol_smb {

    /// A builder for [`FsxProtocolSmb`](crate::model::FsxProtocolSmb).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) mount_options: std::option::Option<crate::model::SmbMountOptions>,
        pub(crate) password: std::option::Option<std::string::String>,
        pub(crate) user: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the fully qualified domain name (FQDN) of the Microsoft Active Directory that your storage virtual machine (SVM) belongs to.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p>Specifies the fully qualified domain name (FQDN) of the Microsoft Active Directory that your storage virtual machine (SVM) belongs to.</p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p>Specifies how DataSync can access a location using the SMB protocol.</p>
        pub fn mount_options(mut self, input: crate::model::SmbMountOptions) -> Self {
            self.mount_options = Some(input);
            self
        }
        /// <p>Specifies how DataSync can access a location using the SMB protocol.</p>
        pub fn set_mount_options(
            mut self,
            input: std::option::Option<crate::model::SmbMountOptions>,
        ) -> Self {
            self.mount_options = input;
            self
        }
        /// <p>Specifies the password of a user who has permission to access your SVM.</p>
        pub fn password(mut self, input: impl Into<std::string::String>) -> Self {
            self.password = Some(input.into());
            self
        }
        /// <p>Specifies the password of a user who has permission to access your SVM.</p>
        pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.password = input;
            self
        }
        /// <p>Specifies a user name that can mount the location and access the files, folders, and metadata that you need in the SVM.</p>
        /// <p>If you provide a user in your Active Directory, note the following:</p>
        /// <ul>
        /// <li> <p>If you're using Directory Service for Microsoft Active Directory, the user must be a member of the Amazon Web Services Delegated FSx Administrators group.</p> </li>
        /// <li> <p>If you're using a self-managed Active Directory, the user must be a member of either the Domain Admins group or a custom group that you specified for file system administration when you created your file system.</p> </li>
        /// </ul>
        /// <p>Make sure that the user has the permissions it needs to copy the data you want:</p>
        /// <ul>
        /// <li> <p> <code>SE_TCB_NAME</code>: Required to set object ownership and file metadata. With this privilege, you also can copy NTFS discretionary access lists (DACLs).</p> </li>
        /// <li> <p> <code>SE_SECURITY_NAME</code>: May be needed to copy NTFS system access control lists (SACLs). This operation specifically requires the Windows privilege, which is granted to members of the Domain Admins group. If you configure your task to copy SACLs, make sure that the user has the required privileges. For information about copying SACLs, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-task.html#configure-ownership-and-permissions">Ownership and permissions-related options</a>.</p> </li>
        /// </ul>
        pub fn user(mut self, input: impl Into<std::string::String>) -> Self {
            self.user = Some(input.into());
            self
        }
        /// <p>Specifies a user name that can mount the location and access the files, folders, and metadata that you need in the SVM.</p>
        /// <p>If you provide a user in your Active Directory, note the following:</p>
        /// <ul>
        /// <li> <p>If you're using Directory Service for Microsoft Active Directory, the user must be a member of the Amazon Web Services Delegated FSx Administrators group.</p> </li>
        /// <li> <p>If you're using a self-managed Active Directory, the user must be a member of either the Domain Admins group or a custom group that you specified for file system administration when you created your file system.</p> </li>
        /// </ul>
        /// <p>Make sure that the user has the permissions it needs to copy the data you want:</p>
        /// <ul>
        /// <li> <p> <code>SE_TCB_NAME</code>: Required to set object ownership and file metadata. With this privilege, you also can copy NTFS discretionary access lists (DACLs).</p> </li>
        /// <li> <p> <code>SE_SECURITY_NAME</code>: May be needed to copy NTFS system access control lists (SACLs). This operation specifically requires the Windows privilege, which is granted to members of the Domain Admins group. If you configure your task to copy SACLs, make sure that the user has the required privileges. For information about copying SACLs, see <a href="https://docs.aws.amazon.com/datasync/latest/userguide/create-task.html#configure-ownership-and-permissions">Ownership and permissions-related options</a>.</p> </li>
        /// </ul>
        pub fn set_user(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user = input;
            self
        }
        /// Consumes the builder and constructs a [`FsxProtocolSmb`](crate::model::FsxProtocolSmb).
        pub fn build(self) -> crate::model::FsxProtocolSmb {
            crate::model::FsxProtocolSmb {
                domain: self.domain,
                mount_options: self.mount_options,
                password: self.password,
                user: self.user,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("domain", &self.domain);
            formatter.field("mount_options", &self.mount_options);
            formatter.field("password", &"*** Sensitive Data Redacted ***");
            formatter.field("user", &self.user);
            formatter.finish()
        }
    }
}
impl FsxProtocolSmb {
    /// Creates a new builder-style object to manufacture [`FsxProtocolSmb`](crate::model::FsxProtocolSmb).
    pub fn builder() -> crate::model::fsx_protocol_smb::Builder {
        crate::model::fsx_protocol_smb::Builder::default()
    }
}

/// <p>Specifies the Network File System (NFS) protocol configuration that DataSync uses to access your Amazon FSx for OpenZFS or Amazon FSx for NetApp ONTAP file system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FsxProtocolNfs {
    /// <p>Specifies how DataSync can access a location using the NFS protocol.</p>
    #[doc(hidden)]
    pub mount_options: std::option::Option<crate::model::NfsMountOptions>,
}
impl FsxProtocolNfs {
    /// <p>Specifies how DataSync can access a location using the NFS protocol.</p>
    pub fn mount_options(&self) -> std::option::Option<&crate::model::NfsMountOptions> {
        self.mount_options.as_ref()
    }
}
/// See [`FsxProtocolNfs`](crate::model::FsxProtocolNfs).
pub mod fsx_protocol_nfs {

    /// A builder for [`FsxProtocolNfs`](crate::model::FsxProtocolNfs).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mount_options: std::option::Option<crate::model::NfsMountOptions>,
    }
    impl Builder {
        /// <p>Specifies how DataSync can access a location using the NFS protocol.</p>
        pub fn mount_options(mut self, input: crate::model::NfsMountOptions) -> Self {
            self.mount_options = Some(input);
            self
        }
        /// <p>Specifies how DataSync can access a location using the NFS protocol.</p>
        pub fn set_mount_options(
            mut self,
            input: std::option::Option<crate::model::NfsMountOptions>,
        ) -> Self {
            self.mount_options = input;
            self
        }
        /// Consumes the builder and constructs a [`FsxProtocolNfs`](crate::model::FsxProtocolNfs).
        pub fn build(self) -> crate::model::FsxProtocolNfs {
            crate::model::FsxProtocolNfs {
                mount_options: self.mount_options,
            }
        }
    }
}
impl FsxProtocolNfs {
    /// Creates a new builder-style object to manufacture [`FsxProtocolNfs`](crate::model::FsxProtocolNfs).
    pub fn builder() -> crate::model::fsx_protocol_nfs::Builder {
        crate::model::fsx_protocol_nfs::Builder::default()
    }
}

/// When writing a match expression against `EfsInTransitEncryption`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let efsintransitencryption = unimplemented!();
/// match efsintransitencryption {
///     EfsInTransitEncryption::None => { /* ... */ },
///     EfsInTransitEncryption::Tls12 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `efsintransitencryption` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EfsInTransitEncryption::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EfsInTransitEncryption::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EfsInTransitEncryption::NewFeature` is defined.
/// Specifically, when `efsintransitencryption` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EfsInTransitEncryption::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EfsInTransitEncryption {
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    Tls12,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EfsInTransitEncryption {
    fn from(s: &str) -> Self {
        match s {
            "NONE" => EfsInTransitEncryption::None,
            "TLS1_2" => EfsInTransitEncryption::Tls12,
            other => {
                EfsInTransitEncryption::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for EfsInTransitEncryption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EfsInTransitEncryption::from(s))
    }
}
impl EfsInTransitEncryption {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EfsInTransitEncryption::None => "NONE",
            EfsInTransitEncryption::Tls12 => "TLS1_2",
            EfsInTransitEncryption::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["NONE", "TLS1_2"]
    }
}
impl AsRef<str> for EfsInTransitEncryption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The subnet and security groups that DataSync uses to access your Amazon EFS file system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Ec2Config {
    /// <p>Specifies the ARN of a subnet where DataSync creates the <a href="https://docs.aws.amazon.com/datasync/latest/userguide/datasync-network.html#required-network-interfaces">network interfaces</a> for managing traffic during your transfer.</p>
    /// <p>The subnet must be located:</p>
    /// <ul>
    /// <li> <p>In the same virtual private cloud (VPC) as the Amazon EFS file system.</p> </li>
    /// <li> <p>In the same Availability Zone as at least one mount target for the Amazon EFS file system.</p> </li>
    /// </ul> <note>
    /// <p>You don't need to specify a subnet that includes a file system mount target.</p>
    /// </note>
    #[doc(hidden)]
    pub subnet_arn: std::option::Option<std::string::String>,
    /// <p>Specifies the Amazon Resource Names (ARNs) of the security groups associated with an Amazon EFS file system's mount target.</p>
    #[doc(hidden)]
    pub security_group_arns: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl Ec2Config {
    /// <p>Specifies the ARN of a subnet where DataSync creates the <a href="https://docs.aws.amazon.com/datasync/latest/userguide/datasync-network.html#required-network-interfaces">network interfaces</a> for managing traffic during your transfer.</p>
    /// <p>The subnet must be located:</p>
    /// <ul>
    /// <li> <p>In the same virtual private cloud (VPC) as the Amazon EFS file system.</p> </li>
    /// <li> <p>In the same Availability Zone as at least one mount target for the Amazon EFS file system.</p> </li>
    /// </ul> <note>
    /// <p>You don't need to specify a subnet that includes a file system mount target.</p>
    /// </note>
    pub fn subnet_arn(&self) -> std::option::Option<&str> {
        self.subnet_arn.as_deref()
    }
    /// <p>Specifies the Amazon Resource Names (ARNs) of the security groups associated with an Amazon EFS file system's mount target.</p>
    pub fn security_group_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_arns.as_deref()
    }
}
/// See [`Ec2Config`](crate::model::Ec2Config).
pub mod ec2_config {

    /// A builder for [`Ec2Config`](crate::model::Ec2Config).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subnet_arn: std::option::Option<std::string::String>,
        pub(crate) security_group_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>Specifies the ARN of a subnet where DataSync creates the <a href="https://docs.aws.amazon.com/datasync/latest/userguide/datasync-network.html#required-network-interfaces">network interfaces</a> for managing traffic during your transfer.</p>
        /// <p>The subnet must be located:</p>
        /// <ul>
        /// <li> <p>In the same virtual private cloud (VPC) as the Amazon EFS file system.</p> </li>
        /// <li> <p>In the same Availability Zone as at least one mount target for the Amazon EFS file system.</p> </li>
        /// </ul> <note>
        /// <p>You don't need to specify a subnet that includes a file system mount target.</p>
        /// </note>
        pub fn subnet_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_arn = Some(input.into());
            self
        }
        /// <p>Specifies the ARN of a subnet where DataSync creates the <a href="https://docs.aws.amazon.com/datasync/latest/userguide/datasync-network.html#required-network-interfaces">network interfaces</a> for managing traffic during your transfer.</p>
        /// <p>The subnet must be located:</p>
        /// <ul>
        /// <li> <p>In the same virtual private cloud (VPC) as the Amazon EFS file system.</p> </li>
        /// <li> <p>In the same Availability Zone as at least one mount target for the Amazon EFS file system.</p> </li>
        /// </ul> <note>
        /// <p>You don't need to specify a subnet that includes a file system mount target.</p>
        /// </note>
        pub fn set_subnet_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_arn = input;
            self
        }
        /// Appends an item to `security_group_arns`.
        ///
        /// To override the contents of this collection use [`set_security_group_arns`](Self::set_security_group_arns).
        ///
        /// <p>Specifies the Amazon Resource Names (ARNs) of the security groups associated with an Amazon EFS file system's mount target.</p>
        pub fn security_group_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_arns.unwrap_or_default();
            v.push(input.into());
            self.security_group_arns = Some(v);
            self
        }
        /// <p>Specifies the Amazon Resource Names (ARNs) of the security groups associated with an Amazon EFS file system's mount target.</p>
        pub fn set_security_group_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_arns = input;
            self
        }
        /// Consumes the builder and constructs a [`Ec2Config`](crate::model::Ec2Config).
        pub fn build(self) -> crate::model::Ec2Config {
            crate::model::Ec2Config {
                subnet_arn: self.subnet_arn,
                security_group_arns: self.security_group_arns,
            }
        }
    }
}
impl Ec2Config {
    /// Creates a new builder-style object to manufacture [`Ec2Config`](crate::model::Ec2Config).
    pub fn builder() -> crate::model::ec2_config::Builder {
        crate::model::ec2_config::Builder::default()
    }
}

/// <p>The VPC endpoint, subnet, and security group that an agent uses to access IP addresses in a VPC (Virtual Private Cloud).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PrivateLinkConfig {
    /// <p>The ID of the VPC endpoint that is configured for an agent. An agent that is configured with a VPC endpoint will not be accessible over the public internet.</p>
    #[doc(hidden)]
    pub vpc_endpoint_id: std::option::Option<std::string::String>,
    /// <p>The private endpoint that is configured for an agent that has access to IP addresses in a <a href="https://docs.aws.amazon.com/vpc/latest/userguide/endpoint-service.html">PrivateLink</a>. An agent that is configured with this endpoint will not be accessible over the public internet.</p>
    #[doc(hidden)]
    pub private_link_endpoint: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Names (ARNs) of the subnets that are configured for an agent activated in a VPC or an agent that has access to a VPC endpoint.</p>
    #[doc(hidden)]
    pub subnet_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The Amazon Resource Names (ARNs) of the security groups that are configured for the EC2 resource that hosts an agent activated in a VPC or an agent that has access to a VPC endpoint.</p>
    #[doc(hidden)]
    pub security_group_arns: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl PrivateLinkConfig {
    /// <p>The ID of the VPC endpoint that is configured for an agent. An agent that is configured with a VPC endpoint will not be accessible over the public internet.</p>
    pub fn vpc_endpoint_id(&self) -> std::option::Option<&str> {
        self.vpc_endpoint_id.as_deref()
    }
    /// <p>The private endpoint that is configured for an agent that has access to IP addresses in a <a href="https://docs.aws.amazon.com/vpc/latest/userguide/endpoint-service.html">PrivateLink</a>. An agent that is configured with this endpoint will not be accessible over the public internet.</p>
    pub fn private_link_endpoint(&self) -> std::option::Option<&str> {
        self.private_link_endpoint.as_deref()
    }
    /// <p>The Amazon Resource Names (ARNs) of the subnets that are configured for an agent activated in a VPC or an agent that has access to a VPC endpoint.</p>
    pub fn subnet_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_arns.as_deref()
    }
    /// <p>The Amazon Resource Names (ARNs) of the security groups that are configured for the EC2 resource that hosts an agent activated in a VPC or an agent that has access to a VPC endpoint.</p>
    pub fn security_group_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_arns.as_deref()
    }
}
/// See [`PrivateLinkConfig`](crate::model::PrivateLinkConfig).
pub mod private_link_config {

    /// A builder for [`PrivateLinkConfig`](crate::model::PrivateLinkConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vpc_endpoint_id: std::option::Option<std::string::String>,
        pub(crate) private_link_endpoint: std::option::Option<std::string::String>,
        pub(crate) subnet_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_group_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ID of the VPC endpoint that is configured for an agent. An agent that is configured with a VPC endpoint will not be accessible over the public internet.</p>
        pub fn vpc_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_endpoint_id = Some(input.into());
            self
        }
        /// <p>The ID of the VPC endpoint that is configured for an agent. An agent that is configured with a VPC endpoint will not be accessible over the public internet.</p>
        pub fn set_vpc_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_endpoint_id = input;
            self
        }
        /// <p>The private endpoint that is configured for an agent that has access to IP addresses in a <a href="https://docs.aws.amazon.com/vpc/latest/userguide/endpoint-service.html">PrivateLink</a>. An agent that is configured with this endpoint will not be accessible over the public internet.</p>
        pub fn private_link_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_link_endpoint = Some(input.into());
            self
        }
        /// <p>The private endpoint that is configured for an agent that has access to IP addresses in a <a href="https://docs.aws.amazon.com/vpc/latest/userguide/endpoint-service.html">PrivateLink</a>. An agent that is configured with this endpoint will not be accessible over the public internet.</p>
        pub fn set_private_link_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_link_endpoint = input;
            self
        }
        /// Appends an item to `subnet_arns`.
        ///
        /// To override the contents of this collection use [`set_subnet_arns`](Self::set_subnet_arns).
        ///
        /// <p>The Amazon Resource Names (ARNs) of the subnets that are configured for an agent activated in a VPC or an agent that has access to a VPC endpoint.</p>
        pub fn subnet_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_arns.unwrap_or_default();
            v.push(input.into());
            self.subnet_arns = Some(v);
            self
        }
        /// <p>The Amazon Resource Names (ARNs) of the subnets that are configured for an agent activated in a VPC or an agent that has access to a VPC endpoint.</p>
        pub fn set_subnet_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_arns = input;
            self
        }
        /// Appends an item to `security_group_arns`.
        ///
        /// To override the contents of this collection use [`set_security_group_arns`](Self::set_security_group_arns).
        ///
        /// <p>The Amazon Resource Names (ARNs) of the security groups that are configured for the EC2 resource that hosts an agent activated in a VPC or an agent that has access to a VPC endpoint.</p>
        pub fn security_group_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_arns.unwrap_or_default();
            v.push(input.into());
            self.security_group_arns = Some(v);
            self
        }
        /// <p>The Amazon Resource Names (ARNs) of the security groups that are configured for the EC2 resource that hosts an agent activated in a VPC or an agent that has access to a VPC endpoint.</p>
        pub fn set_security_group_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_arns = input;
            self
        }
        /// Consumes the builder and constructs a [`PrivateLinkConfig`](crate::model::PrivateLinkConfig).
        pub fn build(self) -> crate::model::PrivateLinkConfig {
            crate::model::PrivateLinkConfig {
                vpc_endpoint_id: self.vpc_endpoint_id,
                private_link_endpoint: self.private_link_endpoint,
                subnet_arns: self.subnet_arns,
                security_group_arns: self.security_group_arns,
            }
        }
    }
}
impl PrivateLinkConfig {
    /// Creates a new builder-style object to manufacture [`PrivateLinkConfig`](crate::model::PrivateLinkConfig).
    pub fn builder() -> crate::model::private_link_config::Builder {
        crate::model::private_link_config::Builder::default()
    }
}

/// When writing a match expression against `EndpointType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let endpointtype = unimplemented!();
/// match endpointtype {
///     EndpointType::Fips => { /* ... */ },
///     EndpointType::PrivateLink => { /* ... */ },
///     EndpointType::Public => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `endpointtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EndpointType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EndpointType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EndpointType::NewFeature` is defined.
/// Specifically, when `endpointtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EndpointType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EndpointType {
    #[allow(missing_docs)] // documentation missing in model
    Fips,
    #[allow(missing_docs)] // documentation missing in model
    PrivateLink,
    #[allow(missing_docs)] // documentation missing in model
    Public,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EndpointType {
    fn from(s: &str) -> Self {
        match s {
            "FIPS" => EndpointType::Fips,
            "PRIVATE_LINK" => EndpointType::PrivateLink,
            "PUBLIC" => EndpointType::Public,
            other => EndpointType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EndpointType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EndpointType::from(s))
    }
}
impl EndpointType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EndpointType::Fips => "FIPS",
            EndpointType::PrivateLink => "PRIVATE_LINK",
            EndpointType::Public => "PUBLIC",
            EndpointType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FIPS", "PRIVATE_LINK", "PUBLIC"]
    }
}
impl AsRef<str> for EndpointType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
