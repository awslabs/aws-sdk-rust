// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::update_location_hdfs::_update_location_hdfs_output::UpdateLocationHdfsOutputBuilder;

pub use crate::operation::update_location_hdfs::_update_location_hdfs_input::UpdateLocationHdfsInputBuilder;

impl UpdateLocationHdfsInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::update_location_hdfs::UpdateLocationHdfsOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::update_location_hdfs::UpdateLocationHdfsError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.update_location_hdfs();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `UpdateLocationHdfs`.
///
/// <p>Updates some parameters of a previously created location for a Hadoop Distributed File System cluster.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct UpdateLocationHdfsFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::update_location_hdfs::builders::UpdateLocationHdfsInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::update_location_hdfs::UpdateLocationHdfsOutput,
        crate::operation::update_location_hdfs::UpdateLocationHdfsError,
    > for UpdateLocationHdfsFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::update_location_hdfs::UpdateLocationHdfsOutput,
            crate::operation::update_location_hdfs::UpdateLocationHdfsError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl UpdateLocationHdfsFluentBuilder {
    /// Creates a new `UpdateLocationHdfs`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the UpdateLocationHdfs as a reference.
    pub fn as_input(&self) -> &crate::operation::update_location_hdfs::builders::UpdateLocationHdfsInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::update_location_hdfs::UpdateLocationHdfsOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::update_location_hdfs::UpdateLocationHdfsError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::update_location_hdfs::UpdateLocationHdfs::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::update_location_hdfs::UpdateLocationHdfs::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::update_location_hdfs::UpdateLocationHdfsOutput,
        crate::operation::update_location_hdfs::UpdateLocationHdfsError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the source HDFS cluster location.</p>
    pub fn location_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.location_arn(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the source HDFS cluster location.</p>
    pub fn set_location_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_location_arn(input);
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the source HDFS cluster location.</p>
    pub fn get_location_arn(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_location_arn()
    }
    /// <p>A subdirectory in the HDFS cluster. This subdirectory is used to read data from or write data to the HDFS cluster.</p>
    pub fn subdirectory(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.subdirectory(input.into());
        self
    }
    /// <p>A subdirectory in the HDFS cluster. This subdirectory is used to read data from or write data to the HDFS cluster.</p>
    pub fn set_subdirectory(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_subdirectory(input);
        self
    }
    /// <p>A subdirectory in the HDFS cluster. This subdirectory is used to read data from or write data to the HDFS cluster.</p>
    pub fn get_subdirectory(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_subdirectory()
    }
    /// Appends an item to `NameNodes`.
    ///
    /// To override the contents of this collection use [`set_name_nodes`](Self::set_name_nodes).
    ///
    /// <p>The NameNode that manages the HDFS namespace. The NameNode performs operations such as opening, closing, and renaming files and directories. The NameNode contains the information to map blocks of data to the DataNodes. You can use only one NameNode.</p>
    pub fn name_nodes(mut self, input: crate::types::HdfsNameNode) -> Self {
        self.inner = self.inner.name_nodes(input);
        self
    }
    /// <p>The NameNode that manages the HDFS namespace. The NameNode performs operations such as opening, closing, and renaming files and directories. The NameNode contains the information to map blocks of data to the DataNodes. You can use only one NameNode.</p>
    pub fn set_name_nodes(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::HdfsNameNode>>) -> Self {
        self.inner = self.inner.set_name_nodes(input);
        self
    }
    /// <p>The NameNode that manages the HDFS namespace. The NameNode performs operations such as opening, closing, and renaming files and directories. The NameNode contains the information to map blocks of data to the DataNodes. You can use only one NameNode.</p>
    pub fn get_name_nodes(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::HdfsNameNode>> {
        self.inner.get_name_nodes()
    }
    /// <p>The size of the data blocks to write into the HDFS cluster. </p>
    pub fn block_size(mut self, input: i32) -> Self {
        self.inner = self.inner.block_size(input);
        self
    }
    /// <p>The size of the data blocks to write into the HDFS cluster. </p>
    pub fn set_block_size(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_block_size(input);
        self
    }
    /// <p>The size of the data blocks to write into the HDFS cluster. </p>
    pub fn get_block_size(&self) -> &::std::option::Option<i32> {
        self.inner.get_block_size()
    }
    /// <p>The number of DataNodes to replicate the data to when writing to the HDFS cluster. </p>
    pub fn replication_factor(mut self, input: i32) -> Self {
        self.inner = self.inner.replication_factor(input);
        self
    }
    /// <p>The number of DataNodes to replicate the data to when writing to the HDFS cluster. </p>
    pub fn set_replication_factor(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_replication_factor(input);
        self
    }
    /// <p>The number of DataNodes to replicate the data to when writing to the HDFS cluster. </p>
    pub fn get_replication_factor(&self) -> &::std::option::Option<i32> {
        self.inner.get_replication_factor()
    }
    /// <p>The URI of the HDFS cluster's Key Management Server (KMS). </p>
    pub fn kms_key_provider_uri(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.kms_key_provider_uri(input.into());
        self
    }
    /// <p>The URI of the HDFS cluster's Key Management Server (KMS). </p>
    pub fn set_kms_key_provider_uri(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_kms_key_provider_uri(input);
        self
    }
    /// <p>The URI of the HDFS cluster's Key Management Server (KMS). </p>
    pub fn get_kms_key_provider_uri(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_kms_key_provider_uri()
    }
    /// <p>The Quality of Protection (QOP) configuration specifies the Remote Procedure Call (RPC) and data transfer privacy settings configured on the Hadoop Distributed File System (HDFS) cluster. </p>
    pub fn qop_configuration(mut self, input: crate::types::QopConfiguration) -> Self {
        self.inner = self.inner.qop_configuration(input);
        self
    }
    /// <p>The Quality of Protection (QOP) configuration specifies the Remote Procedure Call (RPC) and data transfer privacy settings configured on the Hadoop Distributed File System (HDFS) cluster. </p>
    pub fn set_qop_configuration(mut self, input: ::std::option::Option<crate::types::QopConfiguration>) -> Self {
        self.inner = self.inner.set_qop_configuration(input);
        self
    }
    /// <p>The Quality of Protection (QOP) configuration specifies the Remote Procedure Call (RPC) and data transfer privacy settings configured on the Hadoop Distributed File System (HDFS) cluster. </p>
    pub fn get_qop_configuration(&self) -> &::std::option::Option<crate::types::QopConfiguration> {
        self.inner.get_qop_configuration()
    }
    /// <p>The type of authentication used to determine the identity of the user. </p>
    pub fn authentication_type(mut self, input: crate::types::HdfsAuthenticationType) -> Self {
        self.inner = self.inner.authentication_type(input);
        self
    }
    /// <p>The type of authentication used to determine the identity of the user. </p>
    pub fn set_authentication_type(mut self, input: ::std::option::Option<crate::types::HdfsAuthenticationType>) -> Self {
        self.inner = self.inner.set_authentication_type(input);
        self
    }
    /// <p>The type of authentication used to determine the identity of the user. </p>
    pub fn get_authentication_type(&self) -> &::std::option::Option<crate::types::HdfsAuthenticationType> {
        self.inner.get_authentication_type()
    }
    /// <p>The user name used to identify the client on the host operating system.</p>
    pub fn simple_user(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.simple_user(input.into());
        self
    }
    /// <p>The user name used to identify the client on the host operating system.</p>
    pub fn set_simple_user(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_simple_user(input);
        self
    }
    /// <p>The user name used to identify the client on the host operating system.</p>
    pub fn get_simple_user(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_simple_user()
    }
    /// <p>The Kerberos principal with access to the files and folders on the HDFS cluster. </p>
    pub fn kerberos_principal(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.kerberos_principal(input.into());
        self
    }
    /// <p>The Kerberos principal with access to the files and folders on the HDFS cluster. </p>
    pub fn set_kerberos_principal(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_kerberos_principal(input);
        self
    }
    /// <p>The Kerberos principal with access to the files and folders on the HDFS cluster. </p>
    pub fn get_kerberos_principal(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_kerberos_principal()
    }
    /// <p>The Kerberos key table (keytab) that contains mappings between the defined Kerberos principal and the encrypted keys. You can load the keytab from a file by providing the file's address. If you use the CLI, it performs base64 encoding for you. Otherwise, provide the base64-encoded text.</p>
    pub fn kerberos_keytab(mut self, input: ::aws_smithy_types::Blob) -> Self {
        self.inner = self.inner.kerberos_keytab(input);
        self
    }
    /// <p>The Kerberos key table (keytab) that contains mappings between the defined Kerberos principal and the encrypted keys. You can load the keytab from a file by providing the file's address. If you use the CLI, it performs base64 encoding for you. Otherwise, provide the base64-encoded text.</p>
    pub fn set_kerberos_keytab(mut self, input: ::std::option::Option<::aws_smithy_types::Blob>) -> Self {
        self.inner = self.inner.set_kerberos_keytab(input);
        self
    }
    /// <p>The Kerberos key table (keytab) that contains mappings between the defined Kerberos principal and the encrypted keys. You can load the keytab from a file by providing the file's address. If you use the CLI, it performs base64 encoding for you. Otherwise, provide the base64-encoded text.</p>
    pub fn get_kerberos_keytab(&self) -> &::std::option::Option<::aws_smithy_types::Blob> {
        self.inner.get_kerberos_keytab()
    }
    /// <p>The <code>krb5.conf</code> file that contains the Kerberos configuration information. You can load the <code>krb5.conf</code> file by providing the file's address. If you're using the CLI, it performs the base64 encoding for you. Otherwise, provide the base64-encoded text.</p>
    pub fn kerberos_krb5_conf(mut self, input: ::aws_smithy_types::Blob) -> Self {
        self.inner = self.inner.kerberos_krb5_conf(input);
        self
    }
    /// <p>The <code>krb5.conf</code> file that contains the Kerberos configuration information. You can load the <code>krb5.conf</code> file by providing the file's address. If you're using the CLI, it performs the base64 encoding for you. Otherwise, provide the base64-encoded text.</p>
    pub fn set_kerberos_krb5_conf(mut self, input: ::std::option::Option<::aws_smithy_types::Blob>) -> Self {
        self.inner = self.inner.set_kerberos_krb5_conf(input);
        self
    }
    /// <p>The <code>krb5.conf</code> file that contains the Kerberos configuration information. You can load the <code>krb5.conf</code> file by providing the file's address. If you're using the CLI, it performs the base64 encoding for you. Otherwise, provide the base64-encoded text.</p>
    pub fn get_kerberos_krb5_conf(&self) -> &::std::option::Option<::aws_smithy_types::Blob> {
        self.inner.get_kerberos_krb5_conf()
    }
    /// Appends an item to `AgentArns`.
    ///
    /// To override the contents of this collection use [`set_agent_arns`](Self::set_agent_arns).
    ///
    /// <p>The ARNs of the agents that are used to connect to the HDFS cluster. </p>
    pub fn agent_arns(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.agent_arns(input.into());
        self
    }
    /// <p>The ARNs of the agents that are used to connect to the HDFS cluster. </p>
    pub fn set_agent_arns(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.inner = self.inner.set_agent_arns(input);
        self
    }
    /// <p>The ARNs of the agents that are used to connect to the HDFS cluster. </p>
    pub fn get_agent_arns(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        self.inner.get_agent_arns()
    }
}
