// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::update_location_hdfs::_update_location_hdfs_output::UpdateLocationHdfsOutputBuilder;

pub use crate::operation::update_location_hdfs::_update_location_hdfs_input::UpdateLocationHdfsInputBuilder;

/// Fluent builder constructing a request to `UpdateLocationHdfs`.
///
/// <p>Updates some parameters of a previously created location for a Hadoop Distributed File System cluster.</p>
#[derive(std::clone::Clone, std::fmt::Debug)]
pub struct UpdateLocationHdfsFluentBuilder {
    handle: std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::update_location_hdfs::builders::UpdateLocationHdfsInputBuilder,
}
impl UpdateLocationHdfsFluentBuilder {
    /// Creates a new `UpdateLocationHdfs`.
    pub(crate) fn new(handle: std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: Default::default(),
        }
    }

    /// Consume this builder, creating a customizable operation that can be modified before being
    /// sent. The operation's inner [http::Request] can be modified as well.
    pub async fn customize(
        self,
    ) -> std::result::Result<
        crate::client::customize::CustomizableOperation<
            crate::operation::update_location_hdfs::UpdateLocationHdfs,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::result::SdkError<
            crate::operation::update_location_hdfs::UpdateLocationHdfsError,
        >,
    > {
        let handle = self.handle.clone();
        let operation = self
            .inner
            .build()
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?
            .make_operation(&handle.conf)
            .await
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
        Ok(crate::client::customize::CustomizableOperation { handle, operation })
    }

    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> std::result::Result<
        crate::operation::update_location_hdfs::UpdateLocationHdfsOutput,
        aws_smithy_http::result::SdkError<
            crate::operation::update_location_hdfs::UpdateLocationHdfsError,
        >,
    > {
        let op = self
            .inner
            .build()
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?
            .make_operation(&self.handle.conf)
            .await
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
        self.handle.client.call(op).await
    }
    /// <p>The Amazon Resource Name (ARN) of the source HDFS cluster location.</p>
    pub fn location_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.location_arn(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the source HDFS cluster location.</p>
    pub fn set_location_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_location_arn(input);
        self
    }
    /// <p>A subdirectory in the HDFS cluster. This subdirectory is used to read data from or write data to the HDFS cluster.</p>
    pub fn subdirectory(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.subdirectory(input.into());
        self
    }
    /// <p>A subdirectory in the HDFS cluster. This subdirectory is used to read data from or write data to the HDFS cluster.</p>
    pub fn set_subdirectory(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_subdirectory(input);
        self
    }
    /// Appends an item to `NameNodes`.
    ///
    /// To override the contents of this collection use [`set_name_nodes`](Self::set_name_nodes).
    ///
    /// <p>The NameNode that manages the HDFS namespace. The NameNode performs operations such as opening, closing, and renaming files and directories. The NameNode contains the information to map blocks of data to the DataNodes. You can use only one NameNode.</p>
    pub fn name_nodes(mut self, input: crate::types::HdfsNameNode) -> Self {
        self.inner = self.inner.name_nodes(input);
        self
    }
    /// <p>The NameNode that manages the HDFS namespace. The NameNode performs operations such as opening, closing, and renaming files and directories. The NameNode contains the information to map blocks of data to the DataNodes. You can use only one NameNode.</p>
    pub fn set_name_nodes(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::HdfsNameNode>>,
    ) -> Self {
        self.inner = self.inner.set_name_nodes(input);
        self
    }
    /// <p>The size of the data blocks to write into the HDFS cluster. </p>
    pub fn block_size(mut self, input: i32) -> Self {
        self.inner = self.inner.block_size(input);
        self
    }
    /// <p>The size of the data blocks to write into the HDFS cluster. </p>
    pub fn set_block_size(mut self, input: std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_block_size(input);
        self
    }
    /// <p>The number of DataNodes to replicate the data to when writing to the HDFS cluster. </p>
    pub fn replication_factor(mut self, input: i32) -> Self {
        self.inner = self.inner.replication_factor(input);
        self
    }
    /// <p>The number of DataNodes to replicate the data to when writing to the HDFS cluster. </p>
    pub fn set_replication_factor(mut self, input: std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_replication_factor(input);
        self
    }
    /// <p>The URI of the HDFS cluster's Key Management Server (KMS). </p>
    pub fn kms_key_provider_uri(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.kms_key_provider_uri(input.into());
        self
    }
    /// <p>The URI of the HDFS cluster's Key Management Server (KMS). </p>
    pub fn set_kms_key_provider_uri(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.inner = self.inner.set_kms_key_provider_uri(input);
        self
    }
    /// <p>The Quality of Protection (QOP) configuration specifies the Remote Procedure Call (RPC) and data transfer privacy settings configured on the Hadoop Distributed File System (HDFS) cluster. </p>
    pub fn qop_configuration(mut self, input: crate::types::QopConfiguration) -> Self {
        self.inner = self.inner.qop_configuration(input);
        self
    }
    /// <p>The Quality of Protection (QOP) configuration specifies the Remote Procedure Call (RPC) and data transfer privacy settings configured on the Hadoop Distributed File System (HDFS) cluster. </p>
    pub fn set_qop_configuration(
        mut self,
        input: std::option::Option<crate::types::QopConfiguration>,
    ) -> Self {
        self.inner = self.inner.set_qop_configuration(input);
        self
    }
    /// <p>The type of authentication used to determine the identity of the user. </p>
    pub fn authentication_type(mut self, input: crate::types::HdfsAuthenticationType) -> Self {
        self.inner = self.inner.authentication_type(input);
        self
    }
    /// <p>The type of authentication used to determine the identity of the user. </p>
    pub fn set_authentication_type(
        mut self,
        input: std::option::Option<crate::types::HdfsAuthenticationType>,
    ) -> Self {
        self.inner = self.inner.set_authentication_type(input);
        self
    }
    /// <p>The user name used to identify the client on the host operating system.</p>
    pub fn simple_user(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.simple_user(input.into());
        self
    }
    /// <p>The user name used to identify the client on the host operating system.</p>
    pub fn set_simple_user(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_simple_user(input);
        self
    }
    /// <p>The Kerberos principal with access to the files and folders on the HDFS cluster. </p>
    pub fn kerberos_principal(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.kerberos_principal(input.into());
        self
    }
    /// <p>The Kerberos principal with access to the files and folders on the HDFS cluster. </p>
    pub fn set_kerberos_principal(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.inner = self.inner.set_kerberos_principal(input);
        self
    }
    /// <p>The Kerberos key table (keytab) that contains mappings between the defined Kerberos principal and the encrypted keys. You can load the keytab from a file by providing the file's address. If you use the CLI, it performs base64 encoding for you. Otherwise, provide the base64-encoded text.</p>
    pub fn kerberos_keytab(mut self, input: aws_smithy_types::Blob) -> Self {
        self.inner = self.inner.kerberos_keytab(input);
        self
    }
    /// <p>The Kerberos key table (keytab) that contains mappings between the defined Kerberos principal and the encrypted keys. You can load the keytab from a file by providing the file's address. If you use the CLI, it performs base64 encoding for you. Otherwise, provide the base64-encoded text.</p>
    pub fn set_kerberos_keytab(
        mut self,
        input: std::option::Option<aws_smithy_types::Blob>,
    ) -> Self {
        self.inner = self.inner.set_kerberos_keytab(input);
        self
    }
    /// <p>The <code>krb5.conf</code> file that contains the Kerberos configuration information. You can load the <code>krb5.conf</code> file by providing the file's address. If you're using the CLI, it performs the base64 encoding for you. Otherwise, provide the base64-encoded text.</p>
    pub fn kerberos_krb5_conf(mut self, input: aws_smithy_types::Blob) -> Self {
        self.inner = self.inner.kerberos_krb5_conf(input);
        self
    }
    /// <p>The <code>krb5.conf</code> file that contains the Kerberos configuration information. You can load the <code>krb5.conf</code> file by providing the file's address. If you're using the CLI, it performs the base64 encoding for you. Otherwise, provide the base64-encoded text.</p>
    pub fn set_kerberos_krb5_conf(
        mut self,
        input: std::option::Option<aws_smithy_types::Blob>,
    ) -> Self {
        self.inner = self.inner.set_kerberos_krb5_conf(input);
        self
    }
    /// Appends an item to `AgentArns`.
    ///
    /// To override the contents of this collection use [`set_agent_arns`](Self::set_agent_arns).
    ///
    /// <p>The ARNs of the agents that are used to connect to the HDFS cluster. </p>
    pub fn agent_arns(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.agent_arns(input.into());
        self
    }
    /// <p>The ARNs of the agents that are used to connect to the HDFS cluster. </p>
    pub fn set_agent_arns(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.inner = self.inner.set_agent_arns(input);
        self
    }
}
