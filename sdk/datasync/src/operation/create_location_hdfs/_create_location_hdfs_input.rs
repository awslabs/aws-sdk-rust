// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateLocationHdfsInput {
    /// <p>A subdirectory in the HDFS cluster. This subdirectory is used to read data from or write data to the HDFS cluster. If the subdirectory isn't specified, it will default to <code>/</code>.</p>
    #[doc(hidden)]
    pub subdirectory: std::option::Option<std::string::String>,
    /// <p>The NameNode that manages the HDFS namespace. The NameNode performs operations such as opening, closing, and renaming files and directories. The NameNode contains the information to map blocks of data to the DataNodes. You can use only one NameNode.</p>
    #[doc(hidden)]
    pub name_nodes: std::option::Option<std::vec::Vec<crate::types::HdfsNameNode>>,
    /// <p>The size of data blocks to write into the HDFS cluster. The block size must be a multiple of 512 bytes. The default block size is 128 mebibytes (MiB).</p>
    #[doc(hidden)]
    pub block_size: std::option::Option<i32>,
    /// <p>The number of DataNodes to replicate the data to when writing to the HDFS cluster. By default, data is replicated to three DataNodes.</p>
    #[doc(hidden)]
    pub replication_factor: std::option::Option<i32>,
    /// <p>The URI of the HDFS cluster's Key Management Server (KMS). </p>
    #[doc(hidden)]
    pub kms_key_provider_uri: std::option::Option<std::string::String>,
    /// <p>The Quality of Protection (QOP) configuration specifies the Remote Procedure Call (RPC) and data transfer protection settings configured on the Hadoop Distributed File System (HDFS) cluster. If <code>QopConfiguration</code> isn't specified, <code>RpcProtection</code> and <code>DataTransferProtection</code> default to <code>PRIVACY</code>. If you set <code>RpcProtection</code> or <code>DataTransferProtection</code>, the other parameter assumes the same value. </p>
    #[doc(hidden)]
    pub qop_configuration: std::option::Option<crate::types::QopConfiguration>,
    /// <p>The type of authentication used to determine the identity of the user. </p>
    #[doc(hidden)]
    pub authentication_type: std::option::Option<crate::types::HdfsAuthenticationType>,
    /// <p>The user name used to identify the client on the host operating system. </p> <note>
    /// <p>If <code>SIMPLE</code> is specified for <code>AuthenticationType</code>, this parameter is required. </p>
    /// </note>
    #[doc(hidden)]
    pub simple_user: std::option::Option<std::string::String>,
    /// <p>The Kerberos principal with access to the files and folders on the HDFS cluster. </p> <note>
    /// <p>If <code>KERBEROS</code> is specified for <code>AuthenticationType</code>, this parameter is required.</p>
    /// </note>
    #[doc(hidden)]
    pub kerberos_principal: std::option::Option<std::string::String>,
    /// <p>The Kerberos key table (keytab) that contains mappings between the defined Kerberos principal and the encrypted keys. You can load the keytab from a file by providing the file's address. If you're using the CLI, it performs base64 encoding for you. Otherwise, provide the base64-encoded text. </p> <note>
    /// <p>If <code>KERBEROS</code> is specified for <code>AuthenticationType</code>, this parameter is required. </p>
    /// </note>
    #[doc(hidden)]
    pub kerberos_keytab: std::option::Option<aws_smithy_types::Blob>,
    /// <p>The <code>krb5.conf</code> file that contains the Kerberos configuration information. You can load the <code>krb5.conf</code> file by providing the file's address. If you're using the CLI, it performs the base64 encoding for you. Otherwise, provide the base64-encoded text. </p> <note>
    /// <p>If <code>KERBEROS</code> is specified for <code>AuthenticationType</code>, this parameter is required.</p>
    /// </note>
    #[doc(hidden)]
    pub kerberos_krb5_conf: std::option::Option<aws_smithy_types::Blob>,
    /// <p>The Amazon Resource Names (ARNs) of the agents that are used to connect to the HDFS cluster.</p>
    #[doc(hidden)]
    pub agent_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The key-value pair that represents the tag that you want to add to the location. The value can be an empty string. We recommend using tags to name your resources. </p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::types::TagListEntry>>,
}
impl CreateLocationHdfsInput {
    /// <p>A subdirectory in the HDFS cluster. This subdirectory is used to read data from or write data to the HDFS cluster. If the subdirectory isn't specified, it will default to <code>/</code>.</p>
    pub fn subdirectory(&self) -> std::option::Option<&str> {
        self.subdirectory.as_deref()
    }
    /// <p>The NameNode that manages the HDFS namespace. The NameNode performs operations such as opening, closing, and renaming files and directories. The NameNode contains the information to map blocks of data to the DataNodes. You can use only one NameNode.</p>
    pub fn name_nodes(&self) -> std::option::Option<&[crate::types::HdfsNameNode]> {
        self.name_nodes.as_deref()
    }
    /// <p>The size of data blocks to write into the HDFS cluster. The block size must be a multiple of 512 bytes. The default block size is 128 mebibytes (MiB).</p>
    pub fn block_size(&self) -> std::option::Option<i32> {
        self.block_size
    }
    /// <p>The number of DataNodes to replicate the data to when writing to the HDFS cluster. By default, data is replicated to three DataNodes.</p>
    pub fn replication_factor(&self) -> std::option::Option<i32> {
        self.replication_factor
    }
    /// <p>The URI of the HDFS cluster's Key Management Server (KMS). </p>
    pub fn kms_key_provider_uri(&self) -> std::option::Option<&str> {
        self.kms_key_provider_uri.as_deref()
    }
    /// <p>The Quality of Protection (QOP) configuration specifies the Remote Procedure Call (RPC) and data transfer protection settings configured on the Hadoop Distributed File System (HDFS) cluster. If <code>QopConfiguration</code> isn't specified, <code>RpcProtection</code> and <code>DataTransferProtection</code> default to <code>PRIVACY</code>. If you set <code>RpcProtection</code> or <code>DataTransferProtection</code>, the other parameter assumes the same value. </p>
    pub fn qop_configuration(&self) -> std::option::Option<&crate::types::QopConfiguration> {
        self.qop_configuration.as_ref()
    }
    /// <p>The type of authentication used to determine the identity of the user. </p>
    pub fn authentication_type(
        &self,
    ) -> std::option::Option<&crate::types::HdfsAuthenticationType> {
        self.authentication_type.as_ref()
    }
    /// <p>The user name used to identify the client on the host operating system. </p> <note>
    /// <p>If <code>SIMPLE</code> is specified for <code>AuthenticationType</code>, this parameter is required. </p>
    /// </note>
    pub fn simple_user(&self) -> std::option::Option<&str> {
        self.simple_user.as_deref()
    }
    /// <p>The Kerberos principal with access to the files and folders on the HDFS cluster. </p> <note>
    /// <p>If <code>KERBEROS</code> is specified for <code>AuthenticationType</code>, this parameter is required.</p>
    /// </note>
    pub fn kerberos_principal(&self) -> std::option::Option<&str> {
        self.kerberos_principal.as_deref()
    }
    /// <p>The Kerberos key table (keytab) that contains mappings between the defined Kerberos principal and the encrypted keys. You can load the keytab from a file by providing the file's address. If you're using the CLI, it performs base64 encoding for you. Otherwise, provide the base64-encoded text. </p> <note>
    /// <p>If <code>KERBEROS</code> is specified for <code>AuthenticationType</code>, this parameter is required. </p>
    /// </note>
    pub fn kerberos_keytab(&self) -> std::option::Option<&aws_smithy_types::Blob> {
        self.kerberos_keytab.as_ref()
    }
    /// <p>The <code>krb5.conf</code> file that contains the Kerberos configuration information. You can load the <code>krb5.conf</code> file by providing the file's address. If you're using the CLI, it performs the base64 encoding for you. Otherwise, provide the base64-encoded text. </p> <note>
    /// <p>If <code>KERBEROS</code> is specified for <code>AuthenticationType</code>, this parameter is required.</p>
    /// </note>
    pub fn kerberos_krb5_conf(&self) -> std::option::Option<&aws_smithy_types::Blob> {
        self.kerberos_krb5_conf.as_ref()
    }
    /// <p>The Amazon Resource Names (ARNs) of the agents that are used to connect to the HDFS cluster.</p>
    pub fn agent_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.agent_arns.as_deref()
    }
    /// <p>The key-value pair that represents the tag that you want to add to the location. The value can be an empty string. We recommend using tags to name your resources. </p>
    pub fn tags(&self) -> std::option::Option<&[crate::types::TagListEntry]> {
        self.tags.as_deref()
    }
}
impl CreateLocationHdfsInput {
    /// Creates a new builder-style object to manufacture [`CreateLocationHdfsInput`](crate::operation::create_location_hdfs::CreateLocationHdfsInput).
    pub fn builder(
    ) -> crate::operation::create_location_hdfs::builders::CreateLocationHdfsInputBuilder {
        crate::operation::create_location_hdfs::builders::CreateLocationHdfsInputBuilder::default()
    }
}

/// A builder for [`CreateLocationHdfsInput`](crate::operation::create_location_hdfs::CreateLocationHdfsInput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct CreateLocationHdfsInputBuilder {
    pub(crate) subdirectory: std::option::Option<std::string::String>,
    pub(crate) name_nodes: std::option::Option<std::vec::Vec<crate::types::HdfsNameNode>>,
    pub(crate) block_size: std::option::Option<i32>,
    pub(crate) replication_factor: std::option::Option<i32>,
    pub(crate) kms_key_provider_uri: std::option::Option<std::string::String>,
    pub(crate) qop_configuration: std::option::Option<crate::types::QopConfiguration>,
    pub(crate) authentication_type: std::option::Option<crate::types::HdfsAuthenticationType>,
    pub(crate) simple_user: std::option::Option<std::string::String>,
    pub(crate) kerberos_principal: std::option::Option<std::string::String>,
    pub(crate) kerberos_keytab: std::option::Option<aws_smithy_types::Blob>,
    pub(crate) kerberos_krb5_conf: std::option::Option<aws_smithy_types::Blob>,
    pub(crate) agent_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) tags: std::option::Option<std::vec::Vec<crate::types::TagListEntry>>,
}
impl CreateLocationHdfsInputBuilder {
    /// <p>A subdirectory in the HDFS cluster. This subdirectory is used to read data from or write data to the HDFS cluster. If the subdirectory isn't specified, it will default to <code>/</code>.</p>
    pub fn subdirectory(mut self, input: impl Into<std::string::String>) -> Self {
        self.subdirectory = Some(input.into());
        self
    }
    /// <p>A subdirectory in the HDFS cluster. This subdirectory is used to read data from or write data to the HDFS cluster. If the subdirectory isn't specified, it will default to <code>/</code>.</p>
    pub fn set_subdirectory(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.subdirectory = input;
        self
    }
    /// Appends an item to `name_nodes`.
    ///
    /// To override the contents of this collection use [`set_name_nodes`](Self::set_name_nodes).
    ///
    /// <p>The NameNode that manages the HDFS namespace. The NameNode performs operations such as opening, closing, and renaming files and directories. The NameNode contains the information to map blocks of data to the DataNodes. You can use only one NameNode.</p>
    pub fn name_nodes(mut self, input: crate::types::HdfsNameNode) -> Self {
        let mut v = self.name_nodes.unwrap_or_default();
        v.push(input);
        self.name_nodes = Some(v);
        self
    }
    /// <p>The NameNode that manages the HDFS namespace. The NameNode performs operations such as opening, closing, and renaming files and directories. The NameNode contains the information to map blocks of data to the DataNodes. You can use only one NameNode.</p>
    pub fn set_name_nodes(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::HdfsNameNode>>,
    ) -> Self {
        self.name_nodes = input;
        self
    }
    /// <p>The size of data blocks to write into the HDFS cluster. The block size must be a multiple of 512 bytes. The default block size is 128 mebibytes (MiB).</p>
    pub fn block_size(mut self, input: i32) -> Self {
        self.block_size = Some(input);
        self
    }
    /// <p>The size of data blocks to write into the HDFS cluster. The block size must be a multiple of 512 bytes. The default block size is 128 mebibytes (MiB).</p>
    pub fn set_block_size(mut self, input: std::option::Option<i32>) -> Self {
        self.block_size = input;
        self
    }
    /// <p>The number of DataNodes to replicate the data to when writing to the HDFS cluster. By default, data is replicated to three DataNodes.</p>
    pub fn replication_factor(mut self, input: i32) -> Self {
        self.replication_factor = Some(input);
        self
    }
    /// <p>The number of DataNodes to replicate the data to when writing to the HDFS cluster. By default, data is replicated to three DataNodes.</p>
    pub fn set_replication_factor(mut self, input: std::option::Option<i32>) -> Self {
        self.replication_factor = input;
        self
    }
    /// <p>The URI of the HDFS cluster's Key Management Server (KMS). </p>
    pub fn kms_key_provider_uri(mut self, input: impl Into<std::string::String>) -> Self {
        self.kms_key_provider_uri = Some(input.into());
        self
    }
    /// <p>The URI of the HDFS cluster's Key Management Server (KMS). </p>
    pub fn set_kms_key_provider_uri(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.kms_key_provider_uri = input;
        self
    }
    /// <p>The Quality of Protection (QOP) configuration specifies the Remote Procedure Call (RPC) and data transfer protection settings configured on the Hadoop Distributed File System (HDFS) cluster. If <code>QopConfiguration</code> isn't specified, <code>RpcProtection</code> and <code>DataTransferProtection</code> default to <code>PRIVACY</code>. If you set <code>RpcProtection</code> or <code>DataTransferProtection</code>, the other parameter assumes the same value. </p>
    pub fn qop_configuration(mut self, input: crate::types::QopConfiguration) -> Self {
        self.qop_configuration = Some(input);
        self
    }
    /// <p>The Quality of Protection (QOP) configuration specifies the Remote Procedure Call (RPC) and data transfer protection settings configured on the Hadoop Distributed File System (HDFS) cluster. If <code>QopConfiguration</code> isn't specified, <code>RpcProtection</code> and <code>DataTransferProtection</code> default to <code>PRIVACY</code>. If you set <code>RpcProtection</code> or <code>DataTransferProtection</code>, the other parameter assumes the same value. </p>
    pub fn set_qop_configuration(
        mut self,
        input: std::option::Option<crate::types::QopConfiguration>,
    ) -> Self {
        self.qop_configuration = input;
        self
    }
    /// <p>The type of authentication used to determine the identity of the user. </p>
    pub fn authentication_type(mut self, input: crate::types::HdfsAuthenticationType) -> Self {
        self.authentication_type = Some(input);
        self
    }
    /// <p>The type of authentication used to determine the identity of the user. </p>
    pub fn set_authentication_type(
        mut self,
        input: std::option::Option<crate::types::HdfsAuthenticationType>,
    ) -> Self {
        self.authentication_type = input;
        self
    }
    /// <p>The user name used to identify the client on the host operating system. </p> <note>
    /// <p>If <code>SIMPLE</code> is specified for <code>AuthenticationType</code>, this parameter is required. </p>
    /// </note>
    pub fn simple_user(mut self, input: impl Into<std::string::String>) -> Self {
        self.simple_user = Some(input.into());
        self
    }
    /// <p>The user name used to identify the client on the host operating system. </p> <note>
    /// <p>If <code>SIMPLE</code> is specified for <code>AuthenticationType</code>, this parameter is required. </p>
    /// </note>
    pub fn set_simple_user(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.simple_user = input;
        self
    }
    /// <p>The Kerberos principal with access to the files and folders on the HDFS cluster. </p> <note>
    /// <p>If <code>KERBEROS</code> is specified for <code>AuthenticationType</code>, this parameter is required.</p>
    /// </note>
    pub fn kerberos_principal(mut self, input: impl Into<std::string::String>) -> Self {
        self.kerberos_principal = Some(input.into());
        self
    }
    /// <p>The Kerberos principal with access to the files and folders on the HDFS cluster. </p> <note>
    /// <p>If <code>KERBEROS</code> is specified for <code>AuthenticationType</code>, this parameter is required.</p>
    /// </note>
    pub fn set_kerberos_principal(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.kerberos_principal = input;
        self
    }
    /// <p>The Kerberos key table (keytab) that contains mappings between the defined Kerberos principal and the encrypted keys. You can load the keytab from a file by providing the file's address. If you're using the CLI, it performs base64 encoding for you. Otherwise, provide the base64-encoded text. </p> <note>
    /// <p>If <code>KERBEROS</code> is specified for <code>AuthenticationType</code>, this parameter is required. </p>
    /// </note>
    pub fn kerberos_keytab(mut self, input: aws_smithy_types::Blob) -> Self {
        self.kerberos_keytab = Some(input);
        self
    }
    /// <p>The Kerberos key table (keytab) that contains mappings between the defined Kerberos principal and the encrypted keys. You can load the keytab from a file by providing the file's address. If you're using the CLI, it performs base64 encoding for you. Otherwise, provide the base64-encoded text. </p> <note>
    /// <p>If <code>KERBEROS</code> is specified for <code>AuthenticationType</code>, this parameter is required. </p>
    /// </note>
    pub fn set_kerberos_keytab(
        mut self,
        input: std::option::Option<aws_smithy_types::Blob>,
    ) -> Self {
        self.kerberos_keytab = input;
        self
    }
    /// <p>The <code>krb5.conf</code> file that contains the Kerberos configuration information. You can load the <code>krb5.conf</code> file by providing the file's address. If you're using the CLI, it performs the base64 encoding for you. Otherwise, provide the base64-encoded text. </p> <note>
    /// <p>If <code>KERBEROS</code> is specified for <code>AuthenticationType</code>, this parameter is required.</p>
    /// </note>
    pub fn kerberos_krb5_conf(mut self, input: aws_smithy_types::Blob) -> Self {
        self.kerberos_krb5_conf = Some(input);
        self
    }
    /// <p>The <code>krb5.conf</code> file that contains the Kerberos configuration information. You can load the <code>krb5.conf</code> file by providing the file's address. If you're using the CLI, it performs the base64 encoding for you. Otherwise, provide the base64-encoded text. </p> <note>
    /// <p>If <code>KERBEROS</code> is specified for <code>AuthenticationType</code>, this parameter is required.</p>
    /// </note>
    pub fn set_kerberos_krb5_conf(
        mut self,
        input: std::option::Option<aws_smithy_types::Blob>,
    ) -> Self {
        self.kerberos_krb5_conf = input;
        self
    }
    /// Appends an item to `agent_arns`.
    ///
    /// To override the contents of this collection use [`set_agent_arns`](Self::set_agent_arns).
    ///
    /// <p>The Amazon Resource Names (ARNs) of the agents that are used to connect to the HDFS cluster.</p>
    pub fn agent_arns(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.agent_arns.unwrap_or_default();
        v.push(input.into());
        self.agent_arns = Some(v);
        self
    }
    /// <p>The Amazon Resource Names (ARNs) of the agents that are used to connect to the HDFS cluster.</p>
    pub fn set_agent_arns(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.agent_arns = input;
        self
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>The key-value pair that represents the tag that you want to add to the location. The value can be an empty string. We recommend using tags to name your resources. </p>
    pub fn tags(mut self, input: crate::types::TagListEntry) -> Self {
        let mut v = self.tags.unwrap_or_default();
        v.push(input);
        self.tags = Some(v);
        self
    }
    /// <p>The key-value pair that represents the tag that you want to add to the location. The value can be an empty string. We recommend using tags to name your resources. </p>
    pub fn set_tags(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::TagListEntry>>,
    ) -> Self {
        self.tags = input;
        self
    }
    /// Consumes the builder and constructs a [`CreateLocationHdfsInput`](crate::operation::create_location_hdfs::CreateLocationHdfsInput).
    pub fn build(
        self,
    ) -> Result<
        crate::operation::create_location_hdfs::CreateLocationHdfsInput,
        aws_smithy_http::operation::error::BuildError,
    > {
        Ok(
            crate::operation::create_location_hdfs::CreateLocationHdfsInput {
                subdirectory: self.subdirectory,
                name_nodes: self.name_nodes,
                block_size: self.block_size,
                replication_factor: self.replication_factor,
                kms_key_provider_uri: self.kms_key_provider_uri,
                qop_configuration: self.qop_configuration,
                authentication_type: self.authentication_type,
                simple_user: self.simple_user,
                kerberos_principal: self.kerberos_principal,
                kerberos_keytab: self.kerberos_keytab,
                kerberos_krb5_conf: self.kerberos_krb5_conf,
                agent_arns: self.agent_arns,
                tags: self.tags,
            },
        )
    }
}
