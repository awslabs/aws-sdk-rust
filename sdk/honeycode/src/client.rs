// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn batch_create_table_rows(&self) -> fluent_builders::BatchCreateTableRows<C> {
        fluent_builders::BatchCreateTableRows::new(self.handle.clone())
    }
    pub fn batch_delete_table_rows(&self) -> fluent_builders::BatchDeleteTableRows<C> {
        fluent_builders::BatchDeleteTableRows::new(self.handle.clone())
    }
    pub fn batch_update_table_rows(&self) -> fluent_builders::BatchUpdateTableRows<C> {
        fluent_builders::BatchUpdateTableRows::new(self.handle.clone())
    }
    pub fn batch_upsert_table_rows(&self) -> fluent_builders::BatchUpsertTableRows<C> {
        fluent_builders::BatchUpsertTableRows::new(self.handle.clone())
    }
    pub fn describe_table_data_import_job(&self) -> fluent_builders::DescribeTableDataImportJob<C> {
        fluent_builders::DescribeTableDataImportJob::new(self.handle.clone())
    }
    pub fn get_screen_data(&self) -> fluent_builders::GetScreenData<C> {
        fluent_builders::GetScreenData::new(self.handle.clone())
    }
    pub fn invoke_screen_automation(&self) -> fluent_builders::InvokeScreenAutomation<C> {
        fluent_builders::InvokeScreenAutomation::new(self.handle.clone())
    }
    pub fn list_table_columns(&self) -> fluent_builders::ListTableColumns<C> {
        fluent_builders::ListTableColumns::new(self.handle.clone())
    }
    pub fn list_table_rows(&self) -> fluent_builders::ListTableRows<C> {
        fluent_builders::ListTableRows::new(self.handle.clone())
    }
    pub fn list_tables(&self) -> fluent_builders::ListTables<C> {
        fluent_builders::ListTables::new(self.handle.clone())
    }
    pub fn query_table_rows(&self) -> fluent_builders::QueryTableRows<C> {
        fluent_builders::QueryTableRows::new(self.handle.clone())
    }
    pub fn start_table_data_import_job(&self) -> fluent_builders::StartTableDataImportJob<C> {
        fluent_builders::StartTableDataImportJob::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct BatchCreateTableRows<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_create_table_rows_input::Builder,
    }
    impl<C> BatchCreateTableRows<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchCreateTableRowsOutput,
            smithy_http::result::SdkError<crate::error::BatchCreateTableRowsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the workbook where the new rows are being added.</p>
        /// <p>
        /// If a workbook with the specified ID could not be found, this API throws ResourceNotFoundException.
        /// </p>
        pub fn workbook_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workbook_id(input);
            self
        }
        pub fn set_workbook_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_workbook_id(input);
            self
        }
        /// <p>The ID of the table where the new rows are being added.</p>
        /// <p>
        /// If a table with the specified ID could not be found, this API throws ResourceNotFoundException.
        /// </p>
        pub fn table_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_id(input);
            self
        }
        pub fn set_table_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_id(input);
            self
        }
        /// <p>
        /// The list of rows to create at the end of the table. Each item in this list needs to have a batch item id
        /// to uniquely identify the element in the request and the cells to create for that row.
        /// You need to specify at least one item in this list.
        /// </p>
        /// <p>
        /// Note that if one of the column ids in any of the rows in the request does not exist in the table, then the
        /// request fails and no updates are made to the table.
        /// </p>
        pub fn rows_to_create(mut self, inp: impl Into<crate::model::CreateRowData>) -> Self {
            self.inner = self.inner.rows_to_create(inp);
            self
        }
        pub fn set_rows_to_create(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CreateRowData>>,
        ) -> Self {
            self.inner = self.inner.set_rows_to_create(input);
            self
        }
        /// <p>
        /// The request token for performing the batch create operation.
        /// Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error
        /// like a failed network connection, you can retry the call with the same request token. The service ensures
        /// that if the first call using that request token is successfully performed, the second call will not perform
        /// the operation again.
        /// </p>
        /// <p>
        /// Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests
        /// spanning hours or days.
        /// </p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchDeleteTableRows<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_delete_table_rows_input::Builder,
    }
    impl<C> BatchDeleteTableRows<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchDeleteTableRowsOutput,
            smithy_http::result::SdkError<crate::error::BatchDeleteTableRowsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the workbook where the rows are being deleted.</p>
        /// <p>
        /// If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
        /// </p>
        pub fn workbook_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workbook_id(input);
            self
        }
        pub fn set_workbook_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_workbook_id(input);
            self
        }
        /// <p>The ID of the table where the rows are being deleted.</p>
        /// <p>
        /// If a table with the specified id could not be found, this API throws ResourceNotFoundException.
        /// </p>
        pub fn table_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_id(input);
            self
        }
        pub fn set_table_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_id(input);
            self
        }
        /// <p>
        /// The list of row ids to delete from the table. You need to specify at least one row id in this list.
        /// </p>
        /// <p>
        /// Note that if one of the row ids provided in the request does not exist in the table, then the request fails
        /// and no rows are deleted from the table.
        /// </p>
        pub fn row_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.row_ids(inp);
            self
        }
        pub fn set_row_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_row_ids(input);
            self
        }
        /// <p>
        /// The request token for performing the delete action.
        /// Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error
        /// like a failed network connection, you can retry the call with the same request token. The service ensures
        /// that if the first call using that request token is successfully performed, the second call will not perform
        /// the action again.
        /// </p>
        /// <p>
        /// Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests
        /// spanning hours or days.
        /// </p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchUpdateTableRows<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_update_table_rows_input::Builder,
    }
    impl<C> BatchUpdateTableRows<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchUpdateTableRowsOutput,
            smithy_http::result::SdkError<crate::error::BatchUpdateTableRowsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the workbook where the rows are being updated.</p>
        /// <p>
        /// If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
        /// </p>
        pub fn workbook_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workbook_id(input);
            self
        }
        pub fn set_workbook_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_workbook_id(input);
            self
        }
        /// <p>The ID of the table where the rows are being updated.</p>
        /// <p>
        /// If a table with the specified id could not be found, this API throws ResourceNotFoundException.
        /// </p>
        pub fn table_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_id(input);
            self
        }
        pub fn set_table_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_id(input);
            self
        }
        /// <p>
        /// The list of rows to update in the table. Each item in this list needs to contain the row id to update
        /// along with the map of column id to cell values for each column in that row that needs to be updated.
        /// You need to specify at least one row in this list, and for each row, you need to specify at least one
        /// column to update.
        /// </p>
        /// <p>
        /// Note that if one of the row or column ids in the request does not exist in the table, then the request fails
        /// and no updates are made to the table.
        /// </p>
        pub fn rows_to_update(mut self, inp: impl Into<crate::model::UpdateRowData>) -> Self {
            self.inner = self.inner.rows_to_update(inp);
            self
        }
        pub fn set_rows_to_update(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UpdateRowData>>,
        ) -> Self {
            self.inner = self.inner.set_rows_to_update(input);
            self
        }
        /// <p>
        /// The request token for performing the update action.
        /// Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error
        /// like a failed network connection, you can retry the call with the same request token. The service ensures
        /// that if the first call using that request token is successfully performed, the second call will not perform
        /// the action again.
        /// </p>
        /// <p>
        /// Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests
        /// spanning hours or days.
        /// </p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchUpsertTableRows<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_upsert_table_rows_input::Builder,
    }
    impl<C> BatchUpsertTableRows<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchUpsertTableRowsOutput,
            smithy_http::result::SdkError<crate::error::BatchUpsertTableRowsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the workbook where the rows are being upserted.</p>
        /// <p>
        /// If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
        /// </p>
        pub fn workbook_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workbook_id(input);
            self
        }
        pub fn set_workbook_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_workbook_id(input);
            self
        }
        /// <p>The ID of the table where the rows are being upserted.</p>
        /// <p>
        /// If a table with the specified id could not be found, this API throws ResourceNotFoundException.
        /// </p>
        pub fn table_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_id(input);
            self
        }
        pub fn set_table_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_id(input);
            self
        }
        /// <p>
        /// The list of rows to upsert in the table. Each item in this list needs to have a batch item id to uniquely
        /// identify the element in the request, a filter expression to find the rows to update for that element
        /// and the cell values to set for each column in the upserted rows. You need to specify
        /// at least one item in this list.
        /// </p>
        /// <p>
        /// Note that if one of the filter formulas in the request fails to evaluate because of an error or one of the
        /// column ids in any of the rows does not exist in the table, then the request fails
        /// and no updates are made to the table.
        /// </p>
        pub fn rows_to_upsert(mut self, inp: impl Into<crate::model::UpsertRowData>) -> Self {
            self.inner = self.inner.rows_to_upsert(inp);
            self
        }
        pub fn set_rows_to_upsert(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UpsertRowData>>,
        ) -> Self {
            self.inner = self.inner.set_rows_to_upsert(input);
            self
        }
        /// <p>
        /// The request token for performing the update action.
        /// Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error
        /// like a failed network connection, you can retry the call with the same request token. The service ensures
        /// that if the first call using that request token is successfully performed, the second call will not perform
        /// the action again.
        /// </p>
        /// <p>
        /// Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests
        /// spanning hours or days.
        /// </p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTableDataImportJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_table_data_import_job_input::Builder,
    }
    impl<C> DescribeTableDataImportJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTableDataImportJobOutput,
            smithy_http::result::SdkError<crate::error::DescribeTableDataImportJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the workbook into which data was imported.</p>
        /// <p>
        /// If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
        /// </p>
        pub fn workbook_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workbook_id(input);
            self
        }
        pub fn set_workbook_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_workbook_id(input);
            self
        }
        /// <p>The ID of the table into which data was imported.</p>
        /// <p>
        /// If a table with the specified id could not be found, this API throws ResourceNotFoundException.
        /// </p>
        pub fn table_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_id(input);
            self
        }
        pub fn set_table_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_id(input);
            self
        }
        /// <p>The ID of the job that was returned by the StartTableDataImportJob request.</p>
        /// <p>
        /// If a job with the specified id could not be found, this API throws ResourceNotFoundException.
        /// </p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetScreenData<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_screen_data_input::Builder,
    }
    impl<C> GetScreenData<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetScreenDataOutput,
            smithy_http::result::SdkError<crate::error::GetScreenDataError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the workbook that contains the screen.</p>
        pub fn workbook_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workbook_id(input);
            self
        }
        pub fn set_workbook_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_workbook_id(input);
            self
        }
        /// <p>The ID of the app that contains the screem.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.app_id(input);
            self
        }
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_app_id(input);
            self
        }
        /// <p>The ID of the screen.</p>
        pub fn screen_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.screen_id(input);
            self
        }
        pub fn set_screen_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_screen_id(input);
            self
        }
        /// <p>
        /// Variables are optional and are needed only if the screen requires them to render correctly. Variables are
        /// specified as a map where the key is the name of the variable as defined on the screen. The value is an
        /// object which currently has only one property, rawValue, which holds the value of the variable to be passed
        /// to the screen.
        /// </p>
        pub fn variables(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::VariableValue>,
        ) -> Self {
            self.inner = self.inner.variables(k, v);
            self
        }
        pub fn set_variables(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::VariableValue>,
            >,
        ) -> Self {
            self.inner = self.inner.set_variables(input);
            self
        }
        /// <p>
        /// The number of results to be returned on a single page.
        /// Specify a number between 1 and 100. The maximum value is 100.
        /// </p>
        /// <p>
        /// This parameter is optional. If you don't specify this parameter, the default page size is 100.
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>
        /// This parameter is optional. If a nextToken is not specified, the API returns the first page of data.
        /// </p>
        /// <p>
        /// Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API
        /// will throw ValidationException.
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct InvokeScreenAutomation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::invoke_screen_automation_input::Builder,
    }
    impl<C> InvokeScreenAutomation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::InvokeScreenAutomationOutput,
            smithy_http::result::SdkError<crate::error::InvokeScreenAutomationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the workbook that contains the screen automation.</p>
        pub fn workbook_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workbook_id(input);
            self
        }
        pub fn set_workbook_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_workbook_id(input);
            self
        }
        /// <p>The ID of the app that contains the screen automation.</p>
        pub fn app_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.app_id(input);
            self
        }
        pub fn set_app_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_app_id(input);
            self
        }
        /// <p>The ID of the screen that contains the screen automation.</p>
        pub fn screen_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.screen_id(input);
            self
        }
        pub fn set_screen_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_screen_id(input);
            self
        }
        /// <p>The ID of the automation action to be performed.</p>
        pub fn screen_automation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.screen_automation_id(input);
            self
        }
        pub fn set_screen_automation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_screen_automation_id(input);
            self
        }
        /// <p>
        /// Variables are specified as a map where the key is the name of the variable as defined on the screen. The value is an
        /// object which currently has only one property, rawValue, which holds the value of the variable to be passed
        /// to the screen. Any variables defined in a screen are required to be passed in the call.
        /// </p>
        pub fn variables(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::VariableValue>,
        ) -> Self {
            self.inner = self.inner.variables(k, v);
            self
        }
        pub fn set_variables(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::VariableValue>,
            >,
        ) -> Self {
            self.inner = self.inner.set_variables(input);
            self
        }
        /// <p>
        /// The row ID for the automation if the automation is defined inside a block with source or list.
        /// </p>
        pub fn row_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.row_id(input);
            self
        }
        pub fn set_row_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_row_id(input);
            self
        }
        /// <p>
        /// The request token for performing the automation action.
        /// Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error
        /// like a failed network connection, you can retry the call with the same request token. The service ensures
        /// that if the first call using that request token is successfully performed, the second call will return the
        /// response of the previous call rather than performing the action again.
        /// </p>
        /// <p>
        /// Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests
        /// spanning hours or days.
        /// </p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTableColumns<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_table_columns_input::Builder,
    }
    impl<C> ListTableColumns<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTableColumnsOutput,
            smithy_http::result::SdkError<crate::error::ListTableColumnsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the workbook that contains the table whose columns are being retrieved.</p>
        /// <p>
        /// If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
        /// </p>
        pub fn workbook_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workbook_id(input);
            self
        }
        pub fn set_workbook_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_workbook_id(input);
            self
        }
        /// <p>The ID of the table whose columns are being retrieved.</p>
        /// <p>
        /// If a table with the specified id could not be found, this API throws ResourceNotFoundException.
        /// </p>
        pub fn table_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_id(input);
            self
        }
        pub fn set_table_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_id(input);
            self
        }
        /// <p>
        /// This parameter is optional. If a nextToken is not specified, the API returns the first page of data.
        /// </p>
        /// <p>
        /// Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API
        /// will throw ValidationException.
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTableRows<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_table_rows_input::Builder,
    }
    impl<C> ListTableRows<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTableRowsOutput,
            smithy_http::result::SdkError<crate::error::ListTableRowsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the workbook that contains the table whose rows are being retrieved.</p>
        /// <p>
        /// If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
        /// </p>
        pub fn workbook_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workbook_id(input);
            self
        }
        pub fn set_workbook_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_workbook_id(input);
            self
        }
        /// <p>The ID of the table whose rows are being retrieved.</p>
        /// <p>
        /// If a table with the specified id could not be found, this API throws ResourceNotFoundException.
        /// </p>
        pub fn table_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_id(input);
            self
        }
        pub fn set_table_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_id(input);
            self
        }
        /// <p>
        /// This parameter is optional. If one or more row ids are specified in this list, then only the specified
        /// row ids are returned in the result. If no row ids are specified here, then all the rows in the table are
        /// returned.
        /// </p>
        pub fn row_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.row_ids(inp);
            self
        }
        pub fn set_row_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_row_ids(input);
            self
        }
        /// <p>The maximum number of rows to return in each page of the results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>
        /// This parameter is optional. If a nextToken is not specified, the API returns the first page of data.
        /// </p>
        /// <p>
        /// Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API
        /// will throw ValidationException.
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTables<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tables_input::Builder,
    }
    impl<C> ListTables<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTablesOutput,
            smithy_http::result::SdkError<crate::error::ListTablesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the workbook whose tables are being retrieved.</p>
        /// <p>
        /// If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
        /// </p>
        pub fn workbook_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workbook_id(input);
            self
        }
        pub fn set_workbook_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_workbook_id(input);
            self
        }
        /// <p>The maximum number of tables to return in each page of the results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>
        /// This parameter is optional. If a nextToken is not specified, the API returns the first page of data.
        /// </p>
        /// <p>
        /// Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API
        /// will throw ValidationException.
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct QueryTableRows<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::query_table_rows_input::Builder,
    }
    impl<C> QueryTableRows<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::QueryTableRowsOutput,
            smithy_http::result::SdkError<crate::error::QueryTableRowsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the workbook whose table rows are being queried.</p>
        /// <p>
        /// If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
        /// </p>
        pub fn workbook_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workbook_id(input);
            self
        }
        pub fn set_workbook_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_workbook_id(input);
            self
        }
        /// <p>The ID of the table whose rows are being queried.</p>
        /// <p>
        /// If a table with the specified id could not be found, this API throws ResourceNotFoundException.
        /// </p>
        pub fn table_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_id(input);
            self
        }
        pub fn set_table_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_table_id(input);
            self
        }
        /// <p>An object that represents a filter formula along with the id of the context row under which the filter
        /// function needs to evaluate.</p>
        pub fn filter_formula(mut self, input: crate::model::Filter) -> Self {
            self.inner = self.inner.filter_formula(input);
            self
        }
        pub fn set_filter_formula(
            mut self,
            input: std::option::Option<crate::model::Filter>,
        ) -> Self {
            self.inner = self.inner.set_filter_formula(input);
            self
        }
        /// <p>The maximum number of rows to return in each page of the results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>
        /// This parameter is optional. If a nextToken is not specified, the API returns the first page of data.
        /// </p>
        /// <p>
        /// Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API
        /// will throw ValidationException.
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartTableDataImportJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_table_data_import_job_input::Builder,
    }
    impl<C> StartTableDataImportJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartTableDataImportJobOutput,
            smithy_http::result::SdkError<crate::error::StartTableDataImportJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the workbook where the rows are being imported.</p>
        /// <p>
        /// If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
        /// </p>
        pub fn workbook_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workbook_id(input);
            self
        }
        pub fn set_workbook_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_workbook_id(input);
            self
        }
        /// <p>
        /// The source of the data that is being imported. The size of source must be no larger than 100 MB.
        /// Source must have no more than 100,000 cells and no more than 1,000 rows.
        /// </p>
        pub fn data_source(mut self, input: crate::model::ImportDataSource) -> Self {
            self.inner = self.inner.data_source(input);
            self
        }
        pub fn set_data_source(
            mut self,
            input: std::option::Option<crate::model::ImportDataSource>,
        ) -> Self {
            self.inner = self.inner.set_data_source(input);
            self
        }
        /// <p>
        /// The format of the data that is being imported. Currently the only option supported is "DELIMITED_TEXT".
        /// </p>
        pub fn data_format(mut self, input: crate::model::ImportSourceDataFormat) -> Self {
            self.inner = self.inner.data_format(input);
            self
        }
        pub fn set_data_format(
            mut self,
            input: std::option::Option<crate::model::ImportSourceDataFormat>,
        ) -> Self {
            self.inner = self.inner.set_data_format(input);
            self
        }
        /// <p>The ID of the table where the rows are being imported.</p>
        /// <p>
        /// If a table with the specified id could not be found, this API throws ResourceNotFoundException.
        /// </p>
        pub fn destination_table_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_table_id(input);
            self
        }
        pub fn set_destination_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_table_id(input);
            self
        }
        /// <p>
        /// The options for customizing this import request.
        /// </p>
        pub fn import_options(mut self, input: crate::model::ImportOptions) -> Self {
            self.inner = self.inner.import_options(input);
            self
        }
        pub fn set_import_options(
            mut self,
            input: std::option::Option<crate::model::ImportOptions>,
        ) -> Self {
            self.inner = self.inner.set_import_options(input);
            self
        }
        /// <p>
        /// The request token for performing the update action.
        /// Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error
        /// like a failed network connection, you can retry the call with the same request token. The service ensures
        /// that if the first call using that request token is successfully performed, the second call will not perform
        /// the action again.
        /// </p>
        /// <p>
        /// Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests
        /// spanning hours or days.
        /// </p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
    }
}
