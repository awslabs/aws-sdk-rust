// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>
/// The BatchCreateTableRows API allows you to create one or more rows at the end of a table in a workbook.
/// The API allows you to specify the values to set in some or all of the columns in the new rows.
/// </p>
/// <p>
/// If a column is not explicitly set in a specific row, then the column level formula specified in the table
/// will be applied to the new row. If there is no column level formula but the last row of the table has a
/// formula, then that formula will be copied down to the new row. If there is no column level formula and
/// no formula in the last row of the table, then that column will be left blank for the new rows.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchCreateTableRows {
    _private: (),
}
impl BatchCreateTableRows {
    /// Creates a new builder-style object to manufacture [`BatchCreateTableRowsInput`](crate::input::BatchCreateTableRowsInput)
    pub fn builder() -> crate::input::batch_create_table_rows_input::Builder {
        crate::input::batch_create_table_rows_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchCreateTableRows {
    type Output = std::result::Result<
        crate::output::BatchCreateTableRowsOutput,
        crate::error::BatchCreateTableRowsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_create_table_rows_error(response)
        } else {
            crate::operation_deser::parse_batch_create_table_rows_response(response)
        }
    }
}

/// <p>
/// The BatchDeleteTableRows API allows you to delete one or more rows from a table in a workbook.
/// You need to specify the ids of the rows that you want to delete from the table.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchDeleteTableRows {
    _private: (),
}
impl BatchDeleteTableRows {
    /// Creates a new builder-style object to manufacture [`BatchDeleteTableRowsInput`](crate::input::BatchDeleteTableRowsInput)
    pub fn builder() -> crate::input::batch_delete_table_rows_input::Builder {
        crate::input::batch_delete_table_rows_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchDeleteTableRows {
    type Output = std::result::Result<
        crate::output::BatchDeleteTableRowsOutput,
        crate::error::BatchDeleteTableRowsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_delete_table_rows_error(response)
        } else {
            crate::operation_deser::parse_batch_delete_table_rows_response(response)
        }
    }
}

/// <p>
/// The BatchUpdateTableRows API allows you to update one or more rows in a table in a workbook.
/// </p>
/// <p>
/// You can specify the values to set in some or all of the columns in the table for the specified
/// rows.
/// If a column is not explicitly specified in a particular row, then that column will not be updated
/// for that row. To clear out the data in a specific cell, you need to set the value as an empty string
/// ("").
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchUpdateTableRows {
    _private: (),
}
impl BatchUpdateTableRows {
    /// Creates a new builder-style object to manufacture [`BatchUpdateTableRowsInput`](crate::input::BatchUpdateTableRowsInput)
    pub fn builder() -> crate::input::batch_update_table_rows_input::Builder {
        crate::input::batch_update_table_rows_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchUpdateTableRows {
    type Output = std::result::Result<
        crate::output::BatchUpdateTableRowsOutput,
        crate::error::BatchUpdateTableRowsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_update_table_rows_error(response)
        } else {
            crate::operation_deser::parse_batch_update_table_rows_response(response)
        }
    }
}

/// <p>
/// The BatchUpsertTableRows API allows you to upsert one or more rows in a table. The upsert
/// operation takes a filter expression as input and evaluates it to find matching rows on the destination
/// table. If matching rows are found, it will update the cells in the matching rows to new values specified
/// in the request. If no matching rows are found, a new row is added at the end of the table and the cells in
/// that row are set to the new values specified in the request.
/// </p>
/// <p>
/// You can specify the values to set in some or all of the columns in the table for the
/// matching or newly appended rows. If a column is not explicitly specified for a particular row, then that
/// column will not be updated for that row. To clear out the data in a specific cell, you need to set the value
/// as an empty string ("").
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchUpsertTableRows {
    _private: (),
}
impl BatchUpsertTableRows {
    /// Creates a new builder-style object to manufacture [`BatchUpsertTableRowsInput`](crate::input::BatchUpsertTableRowsInput)
    pub fn builder() -> crate::input::batch_upsert_table_rows_input::Builder {
        crate::input::batch_upsert_table_rows_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchUpsertTableRows {
    type Output = std::result::Result<
        crate::output::BatchUpsertTableRowsOutput,
        crate::error::BatchUpsertTableRowsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_upsert_table_rows_error(response)
        } else {
            crate::operation_deser::parse_batch_upsert_table_rows_response(response)
        }
    }
}

/// <p>
/// The DescribeTableDataImportJob API allows you to retrieve the status and details of a table data import job.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTableDataImportJob {
    _private: (),
}
impl DescribeTableDataImportJob {
    /// Creates a new builder-style object to manufacture [`DescribeTableDataImportJobInput`](crate::input::DescribeTableDataImportJobInput)
    pub fn builder() -> crate::input::describe_table_data_import_job_input::Builder {
        crate::input::describe_table_data_import_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTableDataImportJob {
    type Output = std::result::Result<
        crate::output::DescribeTableDataImportJobOutput,
        crate::error::DescribeTableDataImportJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_table_data_import_job_error(response)
        } else {
            crate::operation_deser::parse_describe_table_data_import_job_response(response)
        }
    }
}

/// <p>
/// The GetScreenData API allows retrieval of data from a screen in a Honeycode app.
/// The API allows setting local variables in the screen to filter, sort or otherwise affect what will be
/// displayed on the screen.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetScreenData {
    _private: (),
}
impl GetScreenData {
    /// Creates a new builder-style object to manufacture [`GetScreenDataInput`](crate::input::GetScreenDataInput)
    pub fn builder() -> crate::input::get_screen_data_input::Builder {
        crate::input::get_screen_data_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetScreenData {
    type Output =
        std::result::Result<crate::output::GetScreenDataOutput, crate::error::GetScreenDataError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_screen_data_error(response)
        } else {
            crate::operation_deser::parse_get_screen_data_response(response)
        }
    }
}

/// <p>
/// The InvokeScreenAutomation API allows invoking an action defined in a screen in a Honeycode app.
/// The API allows setting local variables, which can then be used in the automation being invoked.
/// This allows automating the Honeycode app interactions to write, update or delete data in the workbook.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct InvokeScreenAutomation {
    _private: (),
}
impl InvokeScreenAutomation {
    /// Creates a new builder-style object to manufacture [`InvokeScreenAutomationInput`](crate::input::InvokeScreenAutomationInput)
    pub fn builder() -> crate::input::invoke_screen_automation_input::Builder {
        crate::input::invoke_screen_automation_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for InvokeScreenAutomation {
    type Output = std::result::Result<
        crate::output::InvokeScreenAutomationOutput,
        crate::error::InvokeScreenAutomationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_invoke_screen_automation_error(response)
        } else {
            crate::operation_deser::parse_invoke_screen_automation_response(response)
        }
    }
}

/// <p>
/// The ListTableColumns API allows you to retrieve a list of all the columns in a table in a workbook.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTableColumns {
    _private: (),
}
impl ListTableColumns {
    /// Creates a new builder-style object to manufacture [`ListTableColumnsInput`](crate::input::ListTableColumnsInput)
    pub fn builder() -> crate::input::list_table_columns_input::Builder {
        crate::input::list_table_columns_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTableColumns {
    type Output = std::result::Result<
        crate::output::ListTableColumnsOutput,
        crate::error::ListTableColumnsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_table_columns_error(response)
        } else {
            crate::operation_deser::parse_list_table_columns_response(response)
        }
    }
}

/// <p>
/// The ListTableRows API allows you to retrieve a list of all the rows in a table in a workbook.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTableRows {
    _private: (),
}
impl ListTableRows {
    /// Creates a new builder-style object to manufacture [`ListTableRowsInput`](crate::input::ListTableRowsInput)
    pub fn builder() -> crate::input::list_table_rows_input::Builder {
        crate::input::list_table_rows_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTableRows {
    type Output =
        std::result::Result<crate::output::ListTableRowsOutput, crate::error::ListTableRowsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_table_rows_error(response)
        } else {
            crate::operation_deser::parse_list_table_rows_response(response)
        }
    }
}

/// <p>
/// The ListTables API allows you to retrieve a list of all the tables in a workbook.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTables {
    _private: (),
}
impl ListTables {
    /// Creates a new builder-style object to manufacture [`ListTablesInput`](crate::input::ListTablesInput)
    pub fn builder() -> crate::input::list_tables_input::Builder {
        crate::input::list_tables_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTables {
    type Output =
        std::result::Result<crate::output::ListTablesOutput, crate::error::ListTablesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tables_error(response)
        } else {
            crate::operation_deser::parse_list_tables_response(response)
        }
    }
}

/// <p>
/// The QueryTableRows API allows you to use a filter formula to query for specific rows in a table.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct QueryTableRows {
    _private: (),
}
impl QueryTableRows {
    /// Creates a new builder-style object to manufacture [`QueryTableRowsInput`](crate::input::QueryTableRowsInput)
    pub fn builder() -> crate::input::query_table_rows_input::Builder {
        crate::input::query_table_rows_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for QueryTableRows {
    type Output =
        std::result::Result<crate::output::QueryTableRowsOutput, crate::error::QueryTableRowsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_query_table_rows_error(response)
        } else {
            crate::operation_deser::parse_query_table_rows_response(response)
        }
    }
}

/// <p>
/// The StartTableDataImportJob API allows you to start an import job on a table. This API will only return
/// the id of the job that was started. To find out the status of the import request, you need to call the
/// DescribeTableDataImportJob API.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartTableDataImportJob {
    _private: (),
}
impl StartTableDataImportJob {
    /// Creates a new builder-style object to manufacture [`StartTableDataImportJobInput`](crate::input::StartTableDataImportJobInput)
    pub fn builder() -> crate::input::start_table_data_import_job_input::Builder {
        crate::input::start_table_data_import_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartTableDataImportJob {
    type Output = std::result::Result<
        crate::output::StartTableDataImportJobOutput,
        crate::error::StartTableDataImportJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_table_data_import_job_error(response)
        } else {
            crate::operation_deser::parse_start_table_data_import_job_response(response)
        }
    }
}
