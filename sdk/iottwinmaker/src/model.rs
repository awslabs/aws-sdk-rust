// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The pricing plan.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PricingPlan  {
    /// <p>The billable entity count.</p>
    #[doc(hidden)]
    pub billable_entity_count: std::option::Option<i64>,
    /// <p>The pricing plan's bundle information.</p>
    #[doc(hidden)]
    pub bundle_information: std::option::Option<crate::model::BundleInformation>,
    /// <p>The effective date and time of the pricing plan.</p>
    #[doc(hidden)]
    pub effective_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The pricing mode.</p>
    #[doc(hidden)]
    pub pricing_mode: std::option::Option<crate::model::PricingMode>,
    /// <p>The set date and time for updating a pricing plan.</p>
    #[doc(hidden)]
    pub update_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The update reason, for changing a pricing plan.</p>
    #[doc(hidden)]
    pub update_reason: std::option::Option<crate::model::UpdateReason>,
}
impl PricingPlan {
    /// <p>The billable entity count.</p>
    pub fn billable_entity_count(&self) -> std::option::Option<i64> {
        self.billable_entity_count
    }
    /// <p>The pricing plan's bundle information.</p>
    pub fn bundle_information(&self) -> std::option::Option<& crate::model::BundleInformation> {
        self.bundle_information.as_ref()
    }
    /// <p>The effective date and time of the pricing plan.</p>
    pub fn effective_date_time(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.effective_date_time.as_ref()
    }
    /// <p>The pricing mode.</p>
    pub fn pricing_mode(&self) -> std::option::Option<& crate::model::PricingMode> {
        self.pricing_mode.as_ref()
    }
    /// <p>The set date and time for updating a pricing plan.</p>
    pub fn update_date_time(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.update_date_time.as_ref()
    }
    /// <p>The update reason, for changing a pricing plan.</p>
    pub fn update_reason(&self) -> std::option::Option<& crate::model::UpdateReason> {
        self.update_reason.as_ref()
    }
}
/// See [`PricingPlan`](crate::model::PricingPlan).
pub mod pricing_plan {
    
    /// A builder for [`PricingPlan`](crate::model::PricingPlan).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) billable_entity_count: std::option::Option<i64>,
        pub(crate) bundle_information: std::option::Option<crate::model::BundleInformation>,
        pub(crate) effective_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) pricing_mode: std::option::Option<crate::model::PricingMode>,
        pub(crate) update_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_reason: std::option::Option<crate::model::UpdateReason>,
    }
    impl Builder {
        /// <p>The billable entity count.</p>
        pub fn billable_entity_count(mut self, input: i64) -> Self {
            self.billable_entity_count = Some(input);
            self
        }
        /// <p>The billable entity count.</p>
        pub fn set_billable_entity_count(mut self, input: std::option::Option<i64>) -> Self {
            self.billable_entity_count = input; self
        }
        /// <p>The pricing plan's bundle information.</p>
        pub fn bundle_information(mut self, input: crate::model::BundleInformation) -> Self {
            self.bundle_information = Some(input);
            self
        }
        /// <p>The pricing plan's bundle information.</p>
        pub fn set_bundle_information(mut self, input: std::option::Option<crate::model::BundleInformation>) -> Self {
            self.bundle_information = input; self
        }
        /// <p>The effective date and time of the pricing plan.</p>
        pub fn effective_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.effective_date_time = Some(input);
            self
        }
        /// <p>The effective date and time of the pricing plan.</p>
        pub fn set_effective_date_time(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.effective_date_time = input; self
        }
        /// <p>The pricing mode.</p>
        pub fn pricing_mode(mut self, input: crate::model::PricingMode) -> Self {
            self.pricing_mode = Some(input);
            self
        }
        /// <p>The pricing mode.</p>
        pub fn set_pricing_mode(mut self, input: std::option::Option<crate::model::PricingMode>) -> Self {
            self.pricing_mode = input; self
        }
        /// <p>The set date and time for updating a pricing plan.</p>
        pub fn update_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_date_time = Some(input);
            self
        }
        /// <p>The set date and time for updating a pricing plan.</p>
        pub fn set_update_date_time(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.update_date_time = input; self
        }
        /// <p>The update reason, for changing a pricing plan.</p>
        pub fn update_reason(mut self, input: crate::model::UpdateReason) -> Self {
            self.update_reason = Some(input);
            self
        }
        /// <p>The update reason, for changing a pricing plan.</p>
        pub fn set_update_reason(mut self, input: std::option::Option<crate::model::UpdateReason>) -> Self {
            self.update_reason = input; self
        }
        /// Consumes the builder and constructs a [`PricingPlan`](crate::model::PricingPlan).
        pub fn build(self) -> crate::model::PricingPlan {
            crate::model::PricingPlan {
                billable_entity_count: self.billable_entity_count
                ,
                bundle_information: self.bundle_information
                ,
                effective_date_time: self.effective_date_time
                ,
                pricing_mode: self.pricing_mode
                ,
                update_date_time: self.update_date_time
                ,
                update_reason: self.update_reason
                ,
            }
        }
    }
    
    
}
impl PricingPlan {
    /// Creates a new builder-style object to manufacture [`PricingPlan`](crate::model::PricingPlan).
    pub fn builder() -> crate::model::pricing_plan::Builder {
        crate::model::pricing_plan::Builder::default()
    }
}

/// When writing a match expression against `UpdateReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let updatereason = unimplemented!();
/// match updatereason {
///     UpdateReason::Default => { /* ... */ },
///     UpdateReason::EntityCountUpdate => { /* ... */ },
///     UpdateReason::Overwritten => { /* ... */ },
///     UpdateReason::PricingModeUpdate => { /* ... */ },
///     UpdateReason::PricingTierUpdate => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `updatereason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UpdateReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UpdateReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UpdateReason::NewFeature` is defined.
/// Specifically, when `updatereason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UpdateReason::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum UpdateReason {
    #[allow(missing_docs)] // documentation missing in model
    Default,
    #[allow(missing_docs)] // documentation missing in model
    EntityCountUpdate,
    #[allow(missing_docs)] // documentation missing in model
    Overwritten,
    #[allow(missing_docs)] // documentation missing in model
    PricingModeUpdate,
    #[allow(missing_docs)] // documentation missing in model
    PricingTierUpdate,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for UpdateReason {
    fn from(s: &str) -> Self {
        match s {
            "DEFAULT" => UpdateReason::Default,
            "ENTITY_COUNT_UPDATE" => UpdateReason::EntityCountUpdate,
            "OVERWRITTEN" => UpdateReason::Overwritten,
            "PRICING_MODE_UPDATE" => UpdateReason::PricingModeUpdate,
            "PRICING_TIER_UPDATE" => UpdateReason::PricingTierUpdate,
            other => UpdateReason::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for UpdateReason {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(UpdateReason::from(s))
                }
            }
impl UpdateReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UpdateReason::Default => "DEFAULT",
            UpdateReason::EntityCountUpdate => "ENTITY_COUNT_UPDATE",
            UpdateReason::Overwritten => "OVERWRITTEN",
            UpdateReason::PricingModeUpdate => "PRICING_MODE_UPDATE",
            UpdateReason::PricingTierUpdate => "PRICING_TIER_UPDATE",
            UpdateReason::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DEFAULT", "ENTITY_COUNT_UPDATE", "OVERWRITTEN", "PRICING_MODE_UPDATE", "PRICING_TIER_UPDATE"
        ]
    }
}
impl AsRef<str> for UpdateReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PricingMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let pricingmode = unimplemented!();
/// match pricingmode {
///     PricingMode::Basic => { /* ... */ },
///     PricingMode::Standard => { /* ... */ },
///     PricingMode::TieredBundle => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `pricingmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PricingMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PricingMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PricingMode::NewFeature` is defined.
/// Specifically, when `pricingmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PricingMode::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum PricingMode {
    #[allow(missing_docs)] // documentation missing in model
    Basic,
    #[allow(missing_docs)] // documentation missing in model
    Standard,
    #[allow(missing_docs)] // documentation missing in model
    TieredBundle,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for PricingMode {
    fn from(s: &str) -> Self {
        match s {
            "BASIC" => PricingMode::Basic,
            "STANDARD" => PricingMode::Standard,
            "TIERED_BUNDLE" => PricingMode::TieredBundle,
            other => PricingMode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for PricingMode {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(PricingMode::from(s))
                }
            }
impl PricingMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PricingMode::Basic => "BASIC",
            PricingMode::Standard => "STANDARD",
            PricingMode::TieredBundle => "TIERED_BUNDLE",
            PricingMode::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BASIC", "STANDARD", "TIERED_BUNDLE"
        ]
    }
}
impl AsRef<str> for PricingMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about pricing bundle.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BundleInformation  {
    /// <p>The bundle names.</p>
    #[doc(hidden)]
    pub bundle_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The pricing tier.</p>
    #[doc(hidden)]
    pub pricing_tier: std::option::Option<crate::model::PricingTier>,
}
impl BundleInformation {
    /// <p>The bundle names.</p>
    pub fn bundle_names(&self) -> std::option::Option<& [std::string::String]> {
        self.bundle_names.as_deref()
    }
    /// <p>The pricing tier.</p>
    pub fn pricing_tier(&self) -> std::option::Option<& crate::model::PricingTier> {
        self.pricing_tier.as_ref()
    }
}
/// See [`BundleInformation`](crate::model::BundleInformation).
pub mod bundle_information {
    
    /// A builder for [`BundleInformation`](crate::model::BundleInformation).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bundle_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) pricing_tier: std::option::Option<crate::model::PricingTier>,
    }
    impl Builder {
        /// Appends an item to `bundle_names`.
        ///
        /// To override the contents of this collection use [`set_bundle_names`](Self::set_bundle_names).
        ///
        /// <p>The bundle names.</p>
        pub fn bundle_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.bundle_names.unwrap_or_default();
                            v.push(input.into());
                            self.bundle_names = Some(v);
                            self
        }
        /// <p>The bundle names.</p>
        pub fn set_bundle_names(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.bundle_names = input; self
        }
        /// <p>The pricing tier.</p>
        pub fn pricing_tier(mut self, input: crate::model::PricingTier) -> Self {
            self.pricing_tier = Some(input);
            self
        }
        /// <p>The pricing tier.</p>
        pub fn set_pricing_tier(mut self, input: std::option::Option<crate::model::PricingTier>) -> Self {
            self.pricing_tier = input; self
        }
        /// Consumes the builder and constructs a [`BundleInformation`](crate::model::BundleInformation).
        pub fn build(self) -> crate::model::BundleInformation {
            crate::model::BundleInformation {
                bundle_names: self.bundle_names
                ,
                pricing_tier: self.pricing_tier
                ,
            }
        }
    }
    
    
}
impl BundleInformation {
    /// Creates a new builder-style object to manufacture [`BundleInformation`](crate::model::BundleInformation).
    pub fn builder() -> crate::model::bundle_information::Builder {
        crate::model::bundle_information::Builder::default()
    }
}

/// When writing a match expression against `PricingTier`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let pricingtier = unimplemented!();
/// match pricingtier {
///     PricingTier::Tier1 => { /* ... */ },
///     PricingTier::Tier2 => { /* ... */ },
///     PricingTier::Tier3 => { /* ... */ },
///     PricingTier::Tier4 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `pricingtier` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PricingTier::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PricingTier::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PricingTier::NewFeature` is defined.
/// Specifically, when `pricingtier` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PricingTier::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum PricingTier {
    #[allow(missing_docs)] // documentation missing in model
    Tier1,
    #[allow(missing_docs)] // documentation missing in model
    Tier2,
    #[allow(missing_docs)] // documentation missing in model
    Tier3,
    #[allow(missing_docs)] // documentation missing in model
    Tier4,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for PricingTier {
    fn from(s: &str) -> Self {
        match s {
            "TIER_1" => PricingTier::Tier1,
            "TIER_2" => PricingTier::Tier2,
            "TIER_3" => PricingTier::Tier3,
            "TIER_4" => PricingTier::Tier4,
            other => PricingTier::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for PricingTier {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(PricingTier::from(s))
                }
            }
impl PricingTier {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PricingTier::Tier1 => "TIER_1",
            PricingTier::Tier2 => "TIER_2",
            PricingTier::Tier3 => "TIER_3",
            PricingTier::Tier4 => "TIER_4",
            PricingTier::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "TIER_1", "TIER_2", "TIER_3", "TIER_4"
        ]
    }
}
impl AsRef<str> for PricingTier {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `State`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let state = unimplemented!();
/// match state {
///     State::Active => { /* ... */ },
///     State::Creating => { /* ... */ },
///     State::Deleting => { /* ... */ },
///     State::Error => { /* ... */ },
///     State::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `state` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `State::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `State::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `State::NewFeature` is defined.
/// Specifically, when `state` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `State::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum State {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for State {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => State::Active,
            "CREATING" => State::Creating,
            "DELETING" => State::Deleting,
            "ERROR" => State::Error,
            "UPDATING" => State::Updating,
            other => State::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for State {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(State::from(s))
                }
            }
impl State {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            State::Active => "ACTIVE",
            State::Creating => "CREATING",
            State::Deleting => "DELETING",
            State::Error => "ERROR",
            State::Updating => "UPDATING",
            State::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACTIVE", "CREATING", "DELETING", "ERROR", "UPDATING"
        ]
    }
}
impl AsRef<str> for State {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The parent entity update request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ParentEntityUpdateRequest  {
    /// <p>The type of the update.</p>
    #[doc(hidden)]
    pub update_type: std::option::Option<crate::model::ParentEntityUpdateType>,
    /// <p>The ID of the parent entity.</p>
    #[doc(hidden)]
    pub parent_entity_id: std::option::Option<std::string::String>,
}
impl ParentEntityUpdateRequest {
    /// <p>The type of the update.</p>
    pub fn update_type(&self) -> std::option::Option<& crate::model::ParentEntityUpdateType> {
        self.update_type.as_ref()
    }
    /// <p>The ID of the parent entity.</p>
    pub fn parent_entity_id(&self) -> std::option::Option<& str> {
        self.parent_entity_id.as_deref()
    }
}
/// See [`ParentEntityUpdateRequest`](crate::model::ParentEntityUpdateRequest).
pub mod parent_entity_update_request {
    
    /// A builder for [`ParentEntityUpdateRequest`](crate::model::ParentEntityUpdateRequest).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) update_type: std::option::Option<crate::model::ParentEntityUpdateType>,
        pub(crate) parent_entity_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of the update.</p>
        pub fn update_type(mut self, input: crate::model::ParentEntityUpdateType) -> Self {
            self.update_type = Some(input);
            self
        }
        /// <p>The type of the update.</p>
        pub fn set_update_type(mut self, input: std::option::Option<crate::model::ParentEntityUpdateType>) -> Self {
            self.update_type = input; self
        }
        /// <p>The ID of the parent entity.</p>
        pub fn parent_entity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.parent_entity_id = Some(input.into());
            self
        }
        /// <p>The ID of the parent entity.</p>
        pub fn set_parent_entity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.parent_entity_id = input; self
        }
        /// Consumes the builder and constructs a [`ParentEntityUpdateRequest`](crate::model::ParentEntityUpdateRequest).
        pub fn build(self) -> crate::model::ParentEntityUpdateRequest {
            crate::model::ParentEntityUpdateRequest {
                update_type: self.update_type
                ,
                parent_entity_id: self.parent_entity_id
                ,
            }
        }
    }
    
    
}
impl ParentEntityUpdateRequest {
    /// Creates a new builder-style object to manufacture [`ParentEntityUpdateRequest`](crate::model::ParentEntityUpdateRequest).
    pub fn builder() -> crate::model::parent_entity_update_request::Builder {
        crate::model::parent_entity_update_request::Builder::default()
    }
}

/// When writing a match expression against `ParentEntityUpdateType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let parententityupdatetype = unimplemented!();
/// match parententityupdatetype {
///     ParentEntityUpdateType::Delete => { /* ... */ },
///     ParentEntityUpdateType::Update => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `parententityupdatetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ParentEntityUpdateType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ParentEntityUpdateType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ParentEntityUpdateType::NewFeature` is defined.
/// Specifically, when `parententityupdatetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ParentEntityUpdateType::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum ParentEntityUpdateType {
    #[allow(missing_docs)] // documentation missing in model
    Delete,
    #[allow(missing_docs)] // documentation missing in model
    Update,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for ParentEntityUpdateType {
    fn from(s: &str) -> Self {
        match s {
            "DELETE" => ParentEntityUpdateType::Delete,
            "UPDATE" => ParentEntityUpdateType::Update,
            other => ParentEntityUpdateType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for ParentEntityUpdateType {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(ParentEntityUpdateType::from(s))
                }
            }
impl ParentEntityUpdateType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ParentEntityUpdateType::Delete => "DELETE",
            ParentEntityUpdateType::Update => "UPDATE",
            ParentEntityUpdateType::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DELETE", "UPDATE"
        ]
    }
}
impl AsRef<str> for ParentEntityUpdateType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The component update request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComponentUpdateRequest  {
    /// <p>The update type of the component update request.</p>
    #[doc(hidden)]
    pub update_type: std::option::Option<crate::model::ComponentUpdateType>,
    /// <p>The description of the component type.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The ID of the component type.</p>
    #[doc(hidden)]
    pub component_type_id: std::option::Option<std::string::String>,
    /// <p>An object that maps strings to the properties to set in the component type update. Each string in the mapping must be unique to this object.</p>
    #[doc(hidden)]
    pub property_updates: std::option::Option<std::collections::HashMap<std::string::String, crate::model::PropertyRequest>>,
    /// <p>The property group updates.</p>
    #[doc(hidden)]
    pub property_group_updates: std::option::Option<std::collections::HashMap<std::string::String, crate::model::ComponentPropertyGroupRequest>>,
}
impl ComponentUpdateRequest {
    /// <p>The update type of the component update request.</p>
    pub fn update_type(&self) -> std::option::Option<& crate::model::ComponentUpdateType> {
        self.update_type.as_ref()
    }
    /// <p>The description of the component type.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>The ID of the component type.</p>
    pub fn component_type_id(&self) -> std::option::Option<& str> {
        self.component_type_id.as_deref()
    }
    /// <p>An object that maps strings to the properties to set in the component type update. Each string in the mapping must be unique to this object.</p>
    pub fn property_updates(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, crate::model::PropertyRequest>> {
        self.property_updates.as_ref()
    }
    /// <p>The property group updates.</p>
    pub fn property_group_updates(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, crate::model::ComponentPropertyGroupRequest>> {
        self.property_group_updates.as_ref()
    }
}
/// See [`ComponentUpdateRequest`](crate::model::ComponentUpdateRequest).
pub mod component_update_request {
    
    /// A builder for [`ComponentUpdateRequest`](crate::model::ComponentUpdateRequest).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) update_type: std::option::Option<crate::model::ComponentUpdateType>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) component_type_id: std::option::Option<std::string::String>,
        pub(crate) property_updates: std::option::Option<std::collections::HashMap<std::string::String, crate::model::PropertyRequest>>,
        pub(crate) property_group_updates: std::option::Option<std::collections::HashMap<std::string::String, crate::model::ComponentPropertyGroupRequest>>,
    }
    impl Builder {
        /// <p>The update type of the component update request.</p>
        pub fn update_type(mut self, input: crate::model::ComponentUpdateType) -> Self {
            self.update_type = Some(input);
            self
        }
        /// <p>The update type of the component update request.</p>
        pub fn set_update_type(mut self, input: std::option::Option<crate::model::ComponentUpdateType>) -> Self {
            self.update_type = input; self
        }
        /// <p>The description of the component type.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the component type.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>The ID of the component type.</p>
        pub fn component_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_type_id = Some(input.into());
            self
        }
        /// <p>The ID of the component type.</p>
        pub fn set_component_type_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.component_type_id = input; self
        }
        /// Adds a key-value pair to `property_updates`.
        ///
        /// To override the contents of this collection use [`set_property_updates`](Self::set_property_updates).
        ///
        /// <p>An object that maps strings to the properties to set in the component type update. Each string in the mapping must be unique to this object.</p>
        pub fn property_updates(mut self, k: impl Into<std::string::String>, v: crate::model::PropertyRequest) -> Self {
            let mut hash_map = self.property_updates.unwrap_or_default();
                            hash_map.insert(k.into(), v);
                            self.property_updates = Some(hash_map);
                            self
        }
        /// <p>An object that maps strings to the properties to set in the component type update. Each string in the mapping must be unique to this object.</p>
        pub fn set_property_updates(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, crate::model::PropertyRequest>>) -> Self {
            self.property_updates = input; self
        }
        /// Adds a key-value pair to `property_group_updates`.
        ///
        /// To override the contents of this collection use [`set_property_group_updates`](Self::set_property_group_updates).
        ///
        /// <p>The property group updates.</p>
        pub fn property_group_updates(mut self, k: impl Into<std::string::String>, v: crate::model::ComponentPropertyGroupRequest) -> Self {
            let mut hash_map = self.property_group_updates.unwrap_or_default();
                            hash_map.insert(k.into(), v);
                            self.property_group_updates = Some(hash_map);
                            self
        }
        /// <p>The property group updates.</p>
        pub fn set_property_group_updates(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, crate::model::ComponentPropertyGroupRequest>>) -> Self {
            self.property_group_updates = input; self
        }
        /// Consumes the builder and constructs a [`ComponentUpdateRequest`](crate::model::ComponentUpdateRequest).
        pub fn build(self) -> crate::model::ComponentUpdateRequest {
            crate::model::ComponentUpdateRequest {
                update_type: self.update_type
                ,
                description: self.description
                ,
                component_type_id: self.component_type_id
                ,
                property_updates: self.property_updates
                ,
                property_group_updates: self.property_group_updates
                ,
            }
        }
    }
    
    
}
impl ComponentUpdateRequest {
    /// Creates a new builder-style object to manufacture [`ComponentUpdateRequest`](crate::model::ComponentUpdateRequest).
    pub fn builder() -> crate::model::component_update_request::Builder {
        crate::model::component_update_request::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComponentPropertyGroupRequest  {
    /// <p>The group type.</p>
    #[doc(hidden)]
    pub group_type: std::option::Option<crate::model::GroupType>,
    /// <p>The property names.</p>
    #[doc(hidden)]
    pub property_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The update type.</p>
    #[doc(hidden)]
    pub update_type: std::option::Option<crate::model::PropertyGroupUpdateType>,
}
impl ComponentPropertyGroupRequest {
    /// <p>The group type.</p>
    pub fn group_type(&self) -> std::option::Option<& crate::model::GroupType> {
        self.group_type.as_ref()
    }
    /// <p>The property names.</p>
    pub fn property_names(&self) -> std::option::Option<& [std::string::String]> {
        self.property_names.as_deref()
    }
    /// <p>The update type.</p>
    pub fn update_type(&self) -> std::option::Option<& crate::model::PropertyGroupUpdateType> {
        self.update_type.as_ref()
    }
}
/// See [`ComponentPropertyGroupRequest`](crate::model::ComponentPropertyGroupRequest).
pub mod component_property_group_request {
    
    /// A builder for [`ComponentPropertyGroupRequest`](crate::model::ComponentPropertyGroupRequest).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_type: std::option::Option<crate::model::GroupType>,
        pub(crate) property_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) update_type: std::option::Option<crate::model::PropertyGroupUpdateType>,
    }
    impl Builder {
        /// <p>The group type.</p>
        pub fn group_type(mut self, input: crate::model::GroupType) -> Self {
            self.group_type = Some(input);
            self
        }
        /// <p>The group type.</p>
        pub fn set_group_type(mut self, input: std::option::Option<crate::model::GroupType>) -> Self {
            self.group_type = input; self
        }
        /// Appends an item to `property_names`.
        ///
        /// To override the contents of this collection use [`set_property_names`](Self::set_property_names).
        ///
        /// <p>The property names.</p>
        pub fn property_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.property_names.unwrap_or_default();
                            v.push(input.into());
                            self.property_names = Some(v);
                            self
        }
        /// <p>The property names.</p>
        pub fn set_property_names(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.property_names = input; self
        }
        /// <p>The update type.</p>
        pub fn update_type(mut self, input: crate::model::PropertyGroupUpdateType) -> Self {
            self.update_type = Some(input);
            self
        }
        /// <p>The update type.</p>
        pub fn set_update_type(mut self, input: std::option::Option<crate::model::PropertyGroupUpdateType>) -> Self {
            self.update_type = input; self
        }
        /// Consumes the builder and constructs a [`ComponentPropertyGroupRequest`](crate::model::ComponentPropertyGroupRequest).
        pub fn build(self) -> crate::model::ComponentPropertyGroupRequest {
            crate::model::ComponentPropertyGroupRequest {
                group_type: self.group_type
                ,
                property_names: self.property_names
                ,
                update_type: self.update_type
                ,
            }
        }
    }
    
    
}
impl ComponentPropertyGroupRequest {
    /// Creates a new builder-style object to manufacture [`ComponentPropertyGroupRequest`](crate::model::ComponentPropertyGroupRequest).
    pub fn builder() -> crate::model::component_property_group_request::Builder {
        crate::model::component_property_group_request::Builder::default()
    }
}

/// When writing a match expression against `PropertyGroupUpdateType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let propertygroupupdatetype = unimplemented!();
/// match propertygroupupdatetype {
///     PropertyGroupUpdateType::Create => { /* ... */ },
///     PropertyGroupUpdateType::Delete => { /* ... */ },
///     PropertyGroupUpdateType::Update => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `propertygroupupdatetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PropertyGroupUpdateType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PropertyGroupUpdateType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PropertyGroupUpdateType::NewFeature` is defined.
/// Specifically, when `propertygroupupdatetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PropertyGroupUpdateType::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum PropertyGroupUpdateType {
    #[allow(missing_docs)] // documentation missing in model
    Create,
    #[allow(missing_docs)] // documentation missing in model
    Delete,
    #[allow(missing_docs)] // documentation missing in model
    Update,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for PropertyGroupUpdateType {
    fn from(s: &str) -> Self {
        match s {
            "CREATE" => PropertyGroupUpdateType::Create,
            "DELETE" => PropertyGroupUpdateType::Delete,
            "UPDATE" => PropertyGroupUpdateType::Update,
            other => PropertyGroupUpdateType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for PropertyGroupUpdateType {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(PropertyGroupUpdateType::from(s))
                }
            }
impl PropertyGroupUpdateType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PropertyGroupUpdateType::Create => "CREATE",
            PropertyGroupUpdateType::Delete => "DELETE",
            PropertyGroupUpdateType::Update => "UPDATE",
            PropertyGroupUpdateType::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CREATE", "DELETE", "UPDATE"
        ]
    }
}
impl AsRef<str> for PropertyGroupUpdateType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `GroupType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let grouptype = unimplemented!();
/// match grouptype {
///     GroupType::Tabular => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `grouptype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `GroupType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `GroupType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `GroupType::NewFeature` is defined.
/// Specifically, when `grouptype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `GroupType::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum GroupType {
    #[allow(missing_docs)] // documentation missing in model
    Tabular,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for GroupType {
    fn from(s: &str) -> Self {
        match s {
            "TABULAR" => GroupType::Tabular,
            other => GroupType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for GroupType {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(GroupType::from(s))
                }
            }
impl GroupType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            GroupType::Tabular => "TABULAR",
            GroupType::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "TABULAR"
        ]
    }
}
impl AsRef<str> for GroupType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that sets information about a property.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyRequest  {
    /// <p>An object that specifies information about a property.</p>
    #[doc(hidden)]
    pub definition: std::option::Option<crate::model::PropertyDefinitionRequest>,
    /// <p>The value of the property.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::DataValue>,
    /// <p>The update type of the update property request.</p>
    #[doc(hidden)]
    pub update_type: std::option::Option<crate::model::PropertyUpdateType>,
}
impl PropertyRequest {
    /// <p>An object that specifies information about a property.</p>
    pub fn definition(&self) -> std::option::Option<& crate::model::PropertyDefinitionRequest> {
        self.definition.as_ref()
    }
    /// <p>The value of the property.</p>
    pub fn value(&self) -> std::option::Option<& crate::model::DataValue> {
        self.value.as_ref()
    }
    /// <p>The update type of the update property request.</p>
    pub fn update_type(&self) -> std::option::Option<& crate::model::PropertyUpdateType> {
        self.update_type.as_ref()
    }
}
/// See [`PropertyRequest`](crate::model::PropertyRequest).
pub mod property_request {
    
    /// A builder for [`PropertyRequest`](crate::model::PropertyRequest).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) definition: std::option::Option<crate::model::PropertyDefinitionRequest>,
        pub(crate) value: std::option::Option<crate::model::DataValue>,
        pub(crate) update_type: std::option::Option<crate::model::PropertyUpdateType>,
    }
    impl Builder {
        /// <p>An object that specifies information about a property.</p>
        pub fn definition(mut self, input: crate::model::PropertyDefinitionRequest) -> Self {
            self.definition = Some(input);
            self
        }
        /// <p>An object that specifies information about a property.</p>
        pub fn set_definition(mut self, input: std::option::Option<crate::model::PropertyDefinitionRequest>) -> Self {
            self.definition = input; self
        }
        /// <p>The value of the property.</p>
        pub fn value(mut self, input: crate::model::DataValue) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the property.</p>
        pub fn set_value(mut self, input: std::option::Option<crate::model::DataValue>) -> Self {
            self.value = input; self
        }
        /// <p>The update type of the update property request.</p>
        pub fn update_type(mut self, input: crate::model::PropertyUpdateType) -> Self {
            self.update_type = Some(input);
            self
        }
        /// <p>The update type of the update property request.</p>
        pub fn set_update_type(mut self, input: std::option::Option<crate::model::PropertyUpdateType>) -> Self {
            self.update_type = input; self
        }
        /// Consumes the builder and constructs a [`PropertyRequest`](crate::model::PropertyRequest).
        pub fn build(self) -> crate::model::PropertyRequest {
            crate::model::PropertyRequest {
                definition: self.definition
                ,
                value: self.value
                ,
                update_type: self.update_type
                ,
            }
        }
    }
    
    
}
impl PropertyRequest {
    /// Creates a new builder-style object to manufacture [`PropertyRequest`](crate::model::PropertyRequest).
    pub fn builder() -> crate::model::property_request::Builder {
        crate::model::property_request::Builder::default()
    }
}

/// When writing a match expression against `PropertyUpdateType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let propertyupdatetype = unimplemented!();
/// match propertyupdatetype {
///     PropertyUpdateType::Create => { /* ... */ },
///     PropertyUpdateType::Delete => { /* ... */ },
///     PropertyUpdateType::Update => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `propertyupdatetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PropertyUpdateType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PropertyUpdateType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PropertyUpdateType::NewFeature` is defined.
/// Specifically, when `propertyupdatetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PropertyUpdateType::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum PropertyUpdateType {
    #[allow(missing_docs)] // documentation missing in model
    Create,
    #[allow(missing_docs)] // documentation missing in model
    Delete,
    #[allow(missing_docs)] // documentation missing in model
    Update,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for PropertyUpdateType {
    fn from(s: &str) -> Self {
        match s {
            "CREATE" => PropertyUpdateType::Create,
            "DELETE" => PropertyUpdateType::Delete,
            "UPDATE" => PropertyUpdateType::Update,
            other => PropertyUpdateType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for PropertyUpdateType {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(PropertyUpdateType::from(s))
                }
            }
impl PropertyUpdateType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PropertyUpdateType::Create => "CREATE",
            PropertyUpdateType::Delete => "DELETE",
            PropertyUpdateType::Update => "UPDATE",
            PropertyUpdateType::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CREATE", "DELETE", "UPDATE"
        ]
    }
}
impl AsRef<str> for PropertyUpdateType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that specifies a value for a property.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataValue  {
    /// <p>A Boolean value.</p>
    #[doc(hidden)]
    pub boolean_value: std::option::Option<bool>,
    /// <p>A double value.</p>
    #[doc(hidden)]
    pub double_value: std::option::Option<f64>,
    /// <p>An integer value.</p>
    #[doc(hidden)]
    pub integer_value: std::option::Option<i32>,
    /// <p>A long value.</p>
    #[doc(hidden)]
    pub long_value: std::option::Option<i64>,
    /// <p>A string value.</p>
    #[doc(hidden)]
    pub string_value: std::option::Option<std::string::String>,
    /// <p>A list of multiple values.</p>
    #[doc(hidden)]
    pub list_value: std::option::Option<std::vec::Vec<crate::model::DataValue>>,
    /// <p>An object that maps strings to multiple <code>DataValue</code> objects.</p>
    #[doc(hidden)]
    pub map_value: std::option::Option<std::collections::HashMap<std::string::String, crate::model::DataValue>>,
    /// <p>A value that relates a component to another component.</p>
    #[doc(hidden)]
    pub relationship_value: std::option::Option<crate::model::RelationshipValue>,
    /// <p>An expression that produces the value.</p>
    #[doc(hidden)]
    pub expression: std::option::Option<std::string::String>,
}
impl DataValue {
    /// <p>A Boolean value.</p>
    pub fn boolean_value(&self) -> std::option::Option<bool> {
        self.boolean_value
    }
    /// <p>A double value.</p>
    pub fn double_value(&self) -> std::option::Option<f64> {
        self.double_value
    }
    /// <p>An integer value.</p>
    pub fn integer_value(&self) -> std::option::Option<i32> {
        self.integer_value
    }
    /// <p>A long value.</p>
    pub fn long_value(&self) -> std::option::Option<i64> {
        self.long_value
    }
    /// <p>A string value.</p>
    pub fn string_value(&self) -> std::option::Option<& str> {
        self.string_value.as_deref()
    }
    /// <p>A list of multiple values.</p>
    pub fn list_value(&self) -> std::option::Option<& [crate::model::DataValue]> {
        self.list_value.as_deref()
    }
    /// <p>An object that maps strings to multiple <code>DataValue</code> objects.</p>
    pub fn map_value(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, crate::model::DataValue>> {
        self.map_value.as_ref()
    }
    /// <p>A value that relates a component to another component.</p>
    pub fn relationship_value(&self) -> std::option::Option<& crate::model::RelationshipValue> {
        self.relationship_value.as_ref()
    }
    /// <p>An expression that produces the value.</p>
    pub fn expression(&self) -> std::option::Option<& str> {
        self.expression.as_deref()
    }
}
/// See [`DataValue`](crate::model::DataValue).
pub mod data_value {
    
    /// A builder for [`DataValue`](crate::model::DataValue).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) boolean_value: std::option::Option<bool>,
        pub(crate) double_value: std::option::Option<f64>,
        pub(crate) integer_value: std::option::Option<i32>,
        pub(crate) long_value: std::option::Option<i64>,
        pub(crate) string_value: std::option::Option<std::string::String>,
        pub(crate) list_value: std::option::Option<std::vec::Vec<crate::model::DataValue>>,
        pub(crate) map_value: std::option::Option<std::collections::HashMap<std::string::String, crate::model::DataValue>>,
        pub(crate) relationship_value: std::option::Option<crate::model::RelationshipValue>,
        pub(crate) expression: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A Boolean value.</p>
        pub fn boolean_value(mut self, input: bool) -> Self {
            self.boolean_value = Some(input);
            self
        }
        /// <p>A Boolean value.</p>
        pub fn set_boolean_value(mut self, input: std::option::Option<bool>) -> Self {
            self.boolean_value = input; self
        }
        /// <p>A double value.</p>
        pub fn double_value(mut self, input: f64) -> Self {
            self.double_value = Some(input);
            self
        }
        /// <p>A double value.</p>
        pub fn set_double_value(mut self, input: std::option::Option<f64>) -> Self {
            self.double_value = input; self
        }
        /// <p>An integer value.</p>
        pub fn integer_value(mut self, input: i32) -> Self {
            self.integer_value = Some(input);
            self
        }
        /// <p>An integer value.</p>
        pub fn set_integer_value(mut self, input: std::option::Option<i32>) -> Self {
            self.integer_value = input; self
        }
        /// <p>A long value.</p>
        pub fn long_value(mut self, input: i64) -> Self {
            self.long_value = Some(input);
            self
        }
        /// <p>A long value.</p>
        pub fn set_long_value(mut self, input: std::option::Option<i64>) -> Self {
            self.long_value = input; self
        }
        /// <p>A string value.</p>
        pub fn string_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.string_value = Some(input.into());
            self
        }
        /// <p>A string value.</p>
        pub fn set_string_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.string_value = input; self
        }
        /// Appends an item to `list_value`.
        ///
        /// To override the contents of this collection use [`set_list_value`](Self::set_list_value).
        ///
        /// <p>A list of multiple values.</p>
        pub fn list_value(mut self, input: crate::model::DataValue) -> Self {
            let mut v = self.list_value.unwrap_or_default();
                            v.push(input);
                            self.list_value = Some(v);
                            self
        }
        /// <p>A list of multiple values.</p>
        pub fn set_list_value(mut self, input: std::option::Option<std::vec::Vec<crate::model::DataValue>>) -> Self {
            self.list_value = input; self
        }
        /// Adds a key-value pair to `map_value`.
        ///
        /// To override the contents of this collection use [`set_map_value`](Self::set_map_value).
        ///
        /// <p>An object that maps strings to multiple <code>DataValue</code> objects.</p>
        pub fn map_value(mut self, k: impl Into<std::string::String>, v: crate::model::DataValue) -> Self {
            let mut hash_map = self.map_value.unwrap_or_default();
                            hash_map.insert(k.into(), v);
                            self.map_value = Some(hash_map);
                            self
        }
        /// <p>An object that maps strings to multiple <code>DataValue</code> objects.</p>
        pub fn set_map_value(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, crate::model::DataValue>>) -> Self {
            self.map_value = input; self
        }
        /// <p>A value that relates a component to another component.</p>
        pub fn relationship_value(mut self, input: crate::model::RelationshipValue) -> Self {
            self.relationship_value = Some(input);
            self
        }
        /// <p>A value that relates a component to another component.</p>
        pub fn set_relationship_value(mut self, input: std::option::Option<crate::model::RelationshipValue>) -> Self {
            self.relationship_value = input; self
        }
        /// <p>An expression that produces the value.</p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.expression = Some(input.into());
            self
        }
        /// <p>An expression that produces the value.</p>
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expression = input; self
        }
        /// Consumes the builder and constructs a [`DataValue`](crate::model::DataValue).
        pub fn build(self) -> crate::model::DataValue {
            crate::model::DataValue {
                boolean_value: self.boolean_value
                ,
                double_value: self.double_value
                ,
                integer_value: self.integer_value
                ,
                long_value: self.long_value
                ,
                string_value: self.string_value
                ,
                list_value: self.list_value
                ,
                map_value: self.map_value
                ,
                relationship_value: self.relationship_value
                ,
                expression: self.expression
                ,
            }
        }
    }
    
    
}
impl DataValue {
    /// Creates a new builder-style object to manufacture [`DataValue`](crate::model::DataValue).
    pub fn builder() -> crate::model::data_value::Builder {
        crate::model::data_value::Builder::default()
    }
}

/// <p>A value that associates a component and an entity.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RelationshipValue  {
    /// <p>The ID of the target entity associated with this relationship value.</p>
    #[doc(hidden)]
    pub target_entity_id: std::option::Option<std::string::String>,
    /// <p>The name of the target component associated with the relationship value.</p>
    #[doc(hidden)]
    pub target_component_name: std::option::Option<std::string::String>,
}
impl RelationshipValue {
    /// <p>The ID of the target entity associated with this relationship value.</p>
    pub fn target_entity_id(&self) -> std::option::Option<& str> {
        self.target_entity_id.as_deref()
    }
    /// <p>The name of the target component associated with the relationship value.</p>
    pub fn target_component_name(&self) -> std::option::Option<& str> {
        self.target_component_name.as_deref()
    }
}
/// See [`RelationshipValue`](crate::model::RelationshipValue).
pub mod relationship_value {
    
    /// A builder for [`RelationshipValue`](crate::model::RelationshipValue).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_entity_id: std::option::Option<std::string::String>,
        pub(crate) target_component_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the target entity associated with this relationship value.</p>
        pub fn target_entity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_entity_id = Some(input.into());
            self
        }
        /// <p>The ID of the target entity associated with this relationship value.</p>
        pub fn set_target_entity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_entity_id = input; self
        }
        /// <p>The name of the target component associated with the relationship value.</p>
        pub fn target_component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_component_name = Some(input.into());
            self
        }
        /// <p>The name of the target component associated with the relationship value.</p>
        pub fn set_target_component_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_component_name = input; self
        }
        /// Consumes the builder and constructs a [`RelationshipValue`](crate::model::RelationshipValue).
        pub fn build(self) -> crate::model::RelationshipValue {
            crate::model::RelationshipValue {
                target_entity_id: self.target_entity_id
                ,
                target_component_name: self.target_component_name
                ,
            }
        }
    }
    
    
}
impl RelationshipValue {
    /// Creates a new builder-style object to manufacture [`RelationshipValue`](crate::model::RelationshipValue).
    pub fn builder() -> crate::model::relationship_value::Builder {
        crate::model::relationship_value::Builder::default()
    }
}

/// <p>An object that sets information about a property.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyDefinitionRequest  {
    /// <p>An object that contains information about the data type.</p>
    #[doc(hidden)]
    pub data_type: std::option::Option<crate::model::DataType>,
    /// <p>A Boolean value that specifies whether the property is required.</p>
    #[doc(hidden)]
    pub is_required_in_entity: std::option::Option<bool>,
    /// <p>A Boolean value that specifies whether the property ID comes from an external data store.</p>
    #[doc(hidden)]
    pub is_external_id: std::option::Option<bool>,
    /// <p>A Boolean value that specifies whether the property is stored externally.</p>
    #[doc(hidden)]
    pub is_stored_externally: std::option::Option<bool>,
    /// <p>A Boolean value that specifies whether the property consists of time series data.</p>
    #[doc(hidden)]
    pub is_time_series: std::option::Option<bool>,
    /// <p>An object that contains the default value.</p>
    #[doc(hidden)]
    pub default_value: std::option::Option<crate::model::DataValue>,
    /// <p>A mapping that specifies configuration information about the property. Use this field to specify information that you read from and write to an external source.</p>
    #[doc(hidden)]
    pub configuration: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A friendly name for the property.</p>
    #[doc(hidden)]
    pub display_name: std::option::Option<std::string::String>,
}
impl PropertyDefinitionRequest {
    /// <p>An object that contains information about the data type.</p>
    pub fn data_type(&self) -> std::option::Option<& crate::model::DataType> {
        self.data_type.as_ref()
    }
    /// <p>A Boolean value that specifies whether the property is required.</p>
    pub fn is_required_in_entity(&self) -> std::option::Option<bool> {
        self.is_required_in_entity
    }
    /// <p>A Boolean value that specifies whether the property ID comes from an external data store.</p>
    pub fn is_external_id(&self) -> std::option::Option<bool> {
        self.is_external_id
    }
    /// <p>A Boolean value that specifies whether the property is stored externally.</p>
    pub fn is_stored_externally(&self) -> std::option::Option<bool> {
        self.is_stored_externally
    }
    /// <p>A Boolean value that specifies whether the property consists of time series data.</p>
    pub fn is_time_series(&self) -> std::option::Option<bool> {
        self.is_time_series
    }
    /// <p>An object that contains the default value.</p>
    pub fn default_value(&self) -> std::option::Option<& crate::model::DataValue> {
        self.default_value.as_ref()
    }
    /// <p>A mapping that specifies configuration information about the property. Use this field to specify information that you read from and write to an external source.</p>
    pub fn configuration(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.configuration.as_ref()
    }
    /// <p>A friendly name for the property.</p>
    pub fn display_name(&self) -> std::option::Option<& str> {
        self.display_name.as_deref()
    }
}
/// See [`PropertyDefinitionRequest`](crate::model::PropertyDefinitionRequest).
pub mod property_definition_request {
    
    /// A builder for [`PropertyDefinitionRequest`](crate::model::PropertyDefinitionRequest).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_type: std::option::Option<crate::model::DataType>,
        pub(crate) is_required_in_entity: std::option::Option<bool>,
        pub(crate) is_external_id: std::option::Option<bool>,
        pub(crate) is_stored_externally: std::option::Option<bool>,
        pub(crate) is_time_series: std::option::Option<bool>,
        pub(crate) default_value: std::option::Option<crate::model::DataValue>,
        pub(crate) configuration: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) display_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An object that contains information about the data type.</p>
        pub fn data_type(mut self, input: crate::model::DataType) -> Self {
            self.data_type = Some(input);
            self
        }
        /// <p>An object that contains information about the data type.</p>
        pub fn set_data_type(mut self, input: std::option::Option<crate::model::DataType>) -> Self {
            self.data_type = input; self
        }
        /// <p>A Boolean value that specifies whether the property is required.</p>
        pub fn is_required_in_entity(mut self, input: bool) -> Self {
            self.is_required_in_entity = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property is required.</p>
        pub fn set_is_required_in_entity(mut self, input: std::option::Option<bool>) -> Self {
            self.is_required_in_entity = input; self
        }
        /// <p>A Boolean value that specifies whether the property ID comes from an external data store.</p>
        pub fn is_external_id(mut self, input: bool) -> Self {
            self.is_external_id = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property ID comes from an external data store.</p>
        pub fn set_is_external_id(mut self, input: std::option::Option<bool>) -> Self {
            self.is_external_id = input; self
        }
        /// <p>A Boolean value that specifies whether the property is stored externally.</p>
        pub fn is_stored_externally(mut self, input: bool) -> Self {
            self.is_stored_externally = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property is stored externally.</p>
        pub fn set_is_stored_externally(mut self, input: std::option::Option<bool>) -> Self {
            self.is_stored_externally = input; self
        }
        /// <p>A Boolean value that specifies whether the property consists of time series data.</p>
        pub fn is_time_series(mut self, input: bool) -> Self {
            self.is_time_series = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property consists of time series data.</p>
        pub fn set_is_time_series(mut self, input: std::option::Option<bool>) -> Self {
            self.is_time_series = input; self
        }
        /// <p>An object that contains the default value.</p>
        pub fn default_value(mut self, input: crate::model::DataValue) -> Self {
            self.default_value = Some(input);
            self
        }
        /// <p>An object that contains the default value.</p>
        pub fn set_default_value(mut self, input: std::option::Option<crate::model::DataValue>) -> Self {
            self.default_value = input; self
        }
        /// Adds a key-value pair to `configuration`.
        ///
        /// To override the contents of this collection use [`set_configuration`](Self::set_configuration).
        ///
        /// <p>A mapping that specifies configuration information about the property. Use this field to specify information that you read from and write to an external source.</p>
        pub fn configuration(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.configuration.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.configuration = Some(hash_map);
                            self
        }
        /// <p>A mapping that specifies configuration information about the property. Use this field to specify information that you read from and write to an external source.</p>
        pub fn set_configuration(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.configuration = input; self
        }
        /// <p>A friendly name for the property.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>A friendly name for the property.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input; self
        }
        /// Consumes the builder and constructs a [`PropertyDefinitionRequest`](crate::model::PropertyDefinitionRequest).
        pub fn build(self) -> crate::model::PropertyDefinitionRequest {
            crate::model::PropertyDefinitionRequest {
                data_type: self.data_type
                ,
                is_required_in_entity: self.is_required_in_entity
                ,
                is_external_id: self.is_external_id
                ,
                is_stored_externally: self.is_stored_externally
                ,
                is_time_series: self.is_time_series
                ,
                default_value: self.default_value
                ,
                configuration: self.configuration
                ,
                display_name: self.display_name
                ,
            }
        }
    }
    
    
}
impl PropertyDefinitionRequest {
    /// Creates a new builder-style object to manufacture [`PropertyDefinitionRequest`](crate::model::PropertyDefinitionRequest).
    pub fn builder() -> crate::model::property_definition_request::Builder {
        crate::model::property_definition_request::Builder::default()
    }
}

/// <p>An object that specifies the data type of a property.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataType  {
    /// <p>The underlying type of the data type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::Type>,
    /// <p>The nested type in the data type.</p>
    #[doc(hidden)]
    pub nested_type: std::option::Option<std::boxed::Box<crate::model::DataType>>,
    /// <p>The allowed values for this data type.</p>
    #[doc(hidden)]
    pub allowed_values: std::option::Option<std::vec::Vec<crate::model::DataValue>>,
    /// <p>The unit of measure used in this data type.</p>
    #[doc(hidden)]
    pub unit_of_measure: std::option::Option<std::string::String>,
    /// <p>A relationship that associates a component with another component.</p>
    #[doc(hidden)]
    pub relationship: std::option::Option<crate::model::Relationship>,
}
impl DataType {
    /// <p>The underlying type of the data type.</p>
    pub fn r#type(&self) -> std::option::Option<& crate::model::Type> {
        self.r#type.as_ref()
    }
    /// <p>The nested type in the data type.</p>
    pub fn nested_type(&self) -> std::option::Option<& crate::model::DataType> {
        self.nested_type.as_deref()
    }
    /// <p>The allowed values for this data type.</p>
    pub fn allowed_values(&self) -> std::option::Option<& [crate::model::DataValue]> {
        self.allowed_values.as_deref()
    }
    /// <p>The unit of measure used in this data type.</p>
    pub fn unit_of_measure(&self) -> std::option::Option<& str> {
        self.unit_of_measure.as_deref()
    }
    /// <p>A relationship that associates a component with another component.</p>
    pub fn relationship(&self) -> std::option::Option<& crate::model::Relationship> {
        self.relationship.as_ref()
    }
}
/// See [`DataType`](crate::model::DataType).
pub mod data_type {
    
    /// A builder for [`DataType`](crate::model::DataType).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::Type>,
        pub(crate) nested_type: std::option::Option<std::boxed::Box<crate::model::DataType>>,
        pub(crate) allowed_values: std::option::Option<std::vec::Vec<crate::model::DataValue>>,
        pub(crate) unit_of_measure: std::option::Option<std::string::String>,
        pub(crate) relationship: std::option::Option<crate::model::Relationship>,
    }
    impl Builder {
        /// <p>The underlying type of the data type.</p>
        pub fn r#type(mut self, input: crate::model::Type) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The underlying type of the data type.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::Type>) -> Self {
            self.r#type = input; self
        }
        /// <p>The nested type in the data type.</p>
        pub fn nested_type(mut self, input: impl Into<std::boxed::Box<crate::model::DataType>>) -> Self {
            self.nested_type = Some(input.into());
            self
        }
        /// <p>The nested type in the data type.</p>
        pub fn set_nested_type(mut self, input: std::option::Option<std::boxed::Box<crate::model::DataType>>) -> Self {
            self.nested_type = input; self
        }
        /// Appends an item to `allowed_values`.
        ///
        /// To override the contents of this collection use [`set_allowed_values`](Self::set_allowed_values).
        ///
        /// <p>The allowed values for this data type.</p>
        pub fn allowed_values(mut self, input: crate::model::DataValue) -> Self {
            let mut v = self.allowed_values.unwrap_or_default();
                            v.push(input);
                            self.allowed_values = Some(v);
                            self
        }
        /// <p>The allowed values for this data type.</p>
        pub fn set_allowed_values(mut self, input: std::option::Option<std::vec::Vec<crate::model::DataValue>>) -> Self {
            self.allowed_values = input; self
        }
        /// <p>The unit of measure used in this data type.</p>
        pub fn unit_of_measure(mut self, input: impl Into<std::string::String>) -> Self {
            self.unit_of_measure = Some(input.into());
            self
        }
        /// <p>The unit of measure used in this data type.</p>
        pub fn set_unit_of_measure(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.unit_of_measure = input; self
        }
        /// <p>A relationship that associates a component with another component.</p>
        pub fn relationship(mut self, input: crate::model::Relationship) -> Self {
            self.relationship = Some(input);
            self
        }
        /// <p>A relationship that associates a component with another component.</p>
        pub fn set_relationship(mut self, input: std::option::Option<crate::model::Relationship>) -> Self {
            self.relationship = input; self
        }
        /// Consumes the builder and constructs a [`DataType`](crate::model::DataType).
        pub fn build(self) -> crate::model::DataType {
            crate::model::DataType {
                r#type: self.r#type
                ,
                nested_type: self.nested_type
                ,
                allowed_values: self.allowed_values
                ,
                unit_of_measure: self.unit_of_measure
                ,
                relationship: self.relationship
                ,
            }
        }
    }
    
    
}
impl DataType {
    /// Creates a new builder-style object to manufacture [`DataType`](crate::model::DataType).
    pub fn builder() -> crate::model::data_type::Builder {
        crate::model::data_type::Builder::default()
    }
}

/// <p>An object that specifies a relationship with another component type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Relationship  {
    /// <p>The ID of the target component type associated with this relationship.</p>
    #[doc(hidden)]
    pub target_component_type_id: std::option::Option<std::string::String>,
    /// <p>The type of the relationship.</p>
    #[doc(hidden)]
    pub relationship_type: std::option::Option<std::string::String>,
}
impl Relationship {
    /// <p>The ID of the target component type associated with this relationship.</p>
    pub fn target_component_type_id(&self) -> std::option::Option<& str> {
        self.target_component_type_id.as_deref()
    }
    /// <p>The type of the relationship.</p>
    pub fn relationship_type(&self) -> std::option::Option<& str> {
        self.relationship_type.as_deref()
    }
}
/// See [`Relationship`](crate::model::Relationship).
pub mod relationship {
    
    /// A builder for [`Relationship`](crate::model::Relationship).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_component_type_id: std::option::Option<std::string::String>,
        pub(crate) relationship_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the target component type associated with this relationship.</p>
        pub fn target_component_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_component_type_id = Some(input.into());
            self
        }
        /// <p>The ID of the target component type associated with this relationship.</p>
        pub fn set_target_component_type_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_component_type_id = input; self
        }
        /// <p>The type of the relationship.</p>
        pub fn relationship_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.relationship_type = Some(input.into());
            self
        }
        /// <p>The type of the relationship.</p>
        pub fn set_relationship_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.relationship_type = input; self
        }
        /// Consumes the builder and constructs a [`Relationship`](crate::model::Relationship).
        pub fn build(self) -> crate::model::Relationship {
            crate::model::Relationship {
                target_component_type_id: self.target_component_type_id
                ,
                relationship_type: self.relationship_type
                ,
            }
        }
    }
    
    
}
impl Relationship {
    /// Creates a new builder-style object to manufacture [`Relationship`](crate::model::Relationship).
    pub fn builder() -> crate::model::relationship::Builder {
        crate::model::relationship::Builder::default()
    }
}

/// When writing a match expression against `Type`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let type = unimplemented!();
/// match type {
///     Type::Boolean => { /* ... */ },
///     Type::Double => { /* ... */ },
///     Type::Integer => { /* ... */ },
///     Type::List => { /* ... */ },
///     Type::Long => { /* ... */ },
///     Type::Map => { /* ... */ },
///     Type::Relationship => { /* ... */ },
///     Type::String => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `type` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Type::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Type::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Type::NewFeature` is defined.
/// Specifically, when `type` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Type::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum Type {
    #[allow(missing_docs)] // documentation missing in model
    Boolean,
    #[allow(missing_docs)] // documentation missing in model
    Double,
    #[allow(missing_docs)] // documentation missing in model
    Integer,
    #[allow(missing_docs)] // documentation missing in model
    List,
    #[allow(missing_docs)] // documentation missing in model
    Long,
    #[allow(missing_docs)] // documentation missing in model
    Map,
    #[allow(missing_docs)] // documentation missing in model
    Relationship,
    #[allow(missing_docs)] // documentation missing in model
    String,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for Type {
    fn from(s: &str) -> Self {
        match s {
            "BOOLEAN" => Type::Boolean,
            "DOUBLE" => Type::Double,
            "INTEGER" => Type::Integer,
            "LIST" => Type::List,
            "LONG" => Type::Long,
            "MAP" => Type::Map,
            "RELATIONSHIP" => Type::Relationship,
            "STRING" => Type::String,
            other => Type::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for Type {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(Type::from(s))
                }
            }
impl Type {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Type::Boolean => "BOOLEAN",
            Type::Double => "DOUBLE",
            Type::Integer => "INTEGER",
            Type::List => "LIST",
            Type::Long => "LONG",
            Type::Map => "MAP",
            Type::Relationship => "RELATIONSHIP",
            Type::String => "STRING",
            Type::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BOOLEAN", "DOUBLE", "INTEGER", "LIST", "LONG", "MAP", "RELATIONSHIP", "STRING"
        ]
    }
}
impl AsRef<str> for Type {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ComponentUpdateType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let componentupdatetype = unimplemented!();
/// match componentupdatetype {
///     ComponentUpdateType::Create => { /* ... */ },
///     ComponentUpdateType::Delete => { /* ... */ },
///     ComponentUpdateType::Update => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `componentupdatetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ComponentUpdateType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ComponentUpdateType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ComponentUpdateType::NewFeature` is defined.
/// Specifically, when `componentupdatetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ComponentUpdateType::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum ComponentUpdateType {
    #[allow(missing_docs)] // documentation missing in model
    Create,
    #[allow(missing_docs)] // documentation missing in model
    Delete,
    #[allow(missing_docs)] // documentation missing in model
    Update,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for ComponentUpdateType {
    fn from(s: &str) -> Self {
        match s {
            "CREATE" => ComponentUpdateType::Create,
            "DELETE" => ComponentUpdateType::Delete,
            "UPDATE" => ComponentUpdateType::Update,
            other => ComponentUpdateType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for ComponentUpdateType {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(ComponentUpdateType::from(s))
                }
            }
impl ComponentUpdateType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ComponentUpdateType::Create => "CREATE",
            ComponentUpdateType::Delete => "DELETE",
            ComponentUpdateType::Update => "UPDATE",
            ComponentUpdateType::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CREATE", "DELETE", "UPDATE"
        ]
    }
}
impl AsRef<str> for ComponentUpdateType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyGroupRequest  {
    /// <p>The group type.</p>
    #[doc(hidden)]
    pub group_type: std::option::Option<crate::model::GroupType>,
    /// <p>The names of properties.</p>
    #[doc(hidden)]
    pub property_names: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl PropertyGroupRequest {
    /// <p>The group type.</p>
    pub fn group_type(&self) -> std::option::Option<& crate::model::GroupType> {
        self.group_type.as_ref()
    }
    /// <p>The names of properties.</p>
    pub fn property_names(&self) -> std::option::Option<& [std::string::String]> {
        self.property_names.as_deref()
    }
}
/// See [`PropertyGroupRequest`](crate::model::PropertyGroupRequest).
pub mod property_group_request {
    
    /// A builder for [`PropertyGroupRequest`](crate::model::PropertyGroupRequest).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_type: std::option::Option<crate::model::GroupType>,
        pub(crate) property_names: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The group type.</p>
        pub fn group_type(mut self, input: crate::model::GroupType) -> Self {
            self.group_type = Some(input);
            self
        }
        /// <p>The group type.</p>
        pub fn set_group_type(mut self, input: std::option::Option<crate::model::GroupType>) -> Self {
            self.group_type = input; self
        }
        /// Appends an item to `property_names`.
        ///
        /// To override the contents of this collection use [`set_property_names`](Self::set_property_names).
        ///
        /// <p>The names of properties.</p>
        pub fn property_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.property_names.unwrap_or_default();
                            v.push(input.into());
                            self.property_names = Some(v);
                            self
        }
        /// <p>The names of properties.</p>
        pub fn set_property_names(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.property_names = input; self
        }
        /// Consumes the builder and constructs a [`PropertyGroupRequest`](crate::model::PropertyGroupRequest).
        pub fn build(self) -> crate::model::PropertyGroupRequest {
            crate::model::PropertyGroupRequest {
                group_type: self.group_type
                ,
                property_names: self.property_names
                ,
            }
        }
    }
    
    
}
impl PropertyGroupRequest {
    /// Creates a new builder-style object to manufacture [`PropertyGroupRequest`](crate::model::PropertyGroupRequest).
    pub fn builder() -> crate::model::property_group_request::Builder {
        crate::model::property_group_request::Builder::default()
    }
}

/// <p>The function request body.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FunctionRequest  {
    /// <p>The required properties of the function.</p>
    #[doc(hidden)]
    pub required_properties: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The scope of the function.</p>
    #[doc(hidden)]
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>The data connector.</p>
    #[doc(hidden)]
    pub implemented_by: std::option::Option<crate::model::DataConnector>,
}
impl FunctionRequest {
    /// <p>The required properties of the function.</p>
    pub fn required_properties(&self) -> std::option::Option<& [std::string::String]> {
        self.required_properties.as_deref()
    }
    /// <p>The scope of the function.</p>
    pub fn scope(&self) -> std::option::Option<& crate::model::Scope> {
        self.scope.as_ref()
    }
    /// <p>The data connector.</p>
    pub fn implemented_by(&self) -> std::option::Option<& crate::model::DataConnector> {
        self.implemented_by.as_ref()
    }
}
/// See [`FunctionRequest`](crate::model::FunctionRequest).
pub mod function_request {
    
    /// A builder for [`FunctionRequest`](crate::model::FunctionRequest).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) required_properties: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) implemented_by: std::option::Option<crate::model::DataConnector>,
    }
    impl Builder {
        /// Appends an item to `required_properties`.
        ///
        /// To override the contents of this collection use [`set_required_properties`](Self::set_required_properties).
        ///
        /// <p>The required properties of the function.</p>
        pub fn required_properties(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.required_properties.unwrap_or_default();
                            v.push(input.into());
                            self.required_properties = Some(v);
                            self
        }
        /// <p>The required properties of the function.</p>
        pub fn set_required_properties(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.required_properties = input; self
        }
        /// <p>The scope of the function.</p>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        /// <p>The scope of the function.</p>
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input; self
        }
        /// <p>The data connector.</p>
        pub fn implemented_by(mut self, input: crate::model::DataConnector) -> Self {
            self.implemented_by = Some(input);
            self
        }
        /// <p>The data connector.</p>
        pub fn set_implemented_by(mut self, input: std::option::Option<crate::model::DataConnector>) -> Self {
            self.implemented_by = input; self
        }
        /// Consumes the builder and constructs a [`FunctionRequest`](crate::model::FunctionRequest).
        pub fn build(self) -> crate::model::FunctionRequest {
            crate::model::FunctionRequest {
                required_properties: self.required_properties
                ,
                scope: self.scope
                ,
                implemented_by: self.implemented_by
                ,
            }
        }
    }
    
    
}
impl FunctionRequest {
    /// Creates a new builder-style object to manufacture [`FunctionRequest`](crate::model::FunctionRequest).
    pub fn builder() -> crate::model::function_request::Builder {
        crate::model::function_request::Builder::default()
    }
}

/// <p>The data connector.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataConnector  {
    /// <p>The Lambda function associated with this data connector.</p>
    #[doc(hidden)]
    pub lambda: std::option::Option<crate::model::LambdaFunction>,
    /// <p>A Boolean value that specifies whether the data connector is native to IoT TwinMaker.</p>
    #[doc(hidden)]
    pub is_native: std::option::Option<bool>,
}
impl DataConnector {
    /// <p>The Lambda function associated with this data connector.</p>
    pub fn lambda(&self) -> std::option::Option<& crate::model::LambdaFunction> {
        self.lambda.as_ref()
    }
    /// <p>A Boolean value that specifies whether the data connector is native to IoT TwinMaker.</p>
    pub fn is_native(&self) -> std::option::Option<bool> {
        self.is_native
    }
}
/// See [`DataConnector`](crate::model::DataConnector).
pub mod data_connector {
    
    /// A builder for [`DataConnector`](crate::model::DataConnector).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lambda: std::option::Option<crate::model::LambdaFunction>,
        pub(crate) is_native: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The Lambda function associated with this data connector.</p>
        pub fn lambda(mut self, input: crate::model::LambdaFunction) -> Self {
            self.lambda = Some(input);
            self
        }
        /// <p>The Lambda function associated with this data connector.</p>
        pub fn set_lambda(mut self, input: std::option::Option<crate::model::LambdaFunction>) -> Self {
            self.lambda = input; self
        }
        /// <p>A Boolean value that specifies whether the data connector is native to IoT TwinMaker.</p>
        pub fn is_native(mut self, input: bool) -> Self {
            self.is_native = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the data connector is native to IoT TwinMaker.</p>
        pub fn set_is_native(mut self, input: std::option::Option<bool>) -> Self {
            self.is_native = input; self
        }
        /// Consumes the builder and constructs a [`DataConnector`](crate::model::DataConnector).
        pub fn build(self) -> crate::model::DataConnector {
            crate::model::DataConnector {
                lambda: self.lambda
                ,
                is_native: self.is_native
                ,
            }
        }
    }
    
    
}
impl DataConnector {
    /// Creates a new builder-style object to manufacture [`DataConnector`](crate::model::DataConnector).
    pub fn builder() -> crate::model::data_connector::Builder {
        crate::model::data_connector::Builder::default()
    }
}

/// <p>The Lambda function.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LambdaFunction  {
    /// <p>The ARN of the Lambda function.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl LambdaFunction {
    /// <p>The ARN of the Lambda function.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
}
/// See [`LambdaFunction`](crate::model::LambdaFunction).
pub mod lambda_function {
    
    /// A builder for [`LambdaFunction`](crate::model::LambdaFunction).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the Lambda function.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the Lambda function.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// Consumes the builder and constructs a [`LambdaFunction`](crate::model::LambdaFunction).
        pub fn build(self) -> crate::model::LambdaFunction {
            crate::model::LambdaFunction {
                arn: self.arn
                ,
            }
        }
    }
    
    
}
impl LambdaFunction {
    /// Creates a new builder-style object to manufacture [`LambdaFunction`](crate::model::LambdaFunction).
    pub fn builder() -> crate::model::lambda_function::Builder {
        crate::model::lambda_function::Builder::default()
    }
}

/// When writing a match expression against `Scope`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let scope = unimplemented!();
/// match scope {
///     Scope::Entity => { /* ... */ },
///     Scope::Workspace => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `scope` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Scope::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Scope::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Scope::NewFeature` is defined.
/// Specifically, when `scope` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Scope::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum Scope {
    #[allow(missing_docs)] // documentation missing in model
    Entity,
    #[allow(missing_docs)] // documentation missing in model
    Workspace,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for Scope {
    fn from(s: &str) -> Self {
        match s {
            "ENTITY" => Scope::Entity,
            "WORKSPACE" => Scope::Workspace,
            other => Scope::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for Scope {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(Scope::from(s))
                }
            }
impl Scope {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Scope::Entity => "ENTITY",
            Scope::Workspace => "WORKSPACE",
            Scope::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ENTITY", "WORKSPACE"
        ]
    }
}
impl AsRef<str> for Scope {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that contains information about a workspace.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkspaceSummary  {
    /// <p>The ID of the workspace.</p>
    #[doc(hidden)]
    pub workspace_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the workspace.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The description of the workspace.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The date and time when the workspace was created.</p>
    #[doc(hidden)]
    pub creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time when the workspace was last updated.</p>
    #[doc(hidden)]
    pub update_date_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl WorkspaceSummary {
    /// <p>The ID of the workspace.</p>
    pub fn workspace_id(&self) -> std::option::Option<& str> {
        self.workspace_id.as_deref()
    }
    /// <p>The ARN of the workspace.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>The description of the workspace.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>The date and time when the workspace was created.</p>
    pub fn creation_date_time(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.creation_date_time.as_ref()
    }
    /// <p>The date and time when the workspace was last updated.</p>
    pub fn update_date_time(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.update_date_time.as_ref()
    }
}
/// See [`WorkspaceSummary`](crate::model::WorkspaceSummary).
pub mod workspace_summary {
    
    /// A builder for [`WorkspaceSummary`](crate::model::WorkspaceSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workspace_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_date_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The ID of the workspace.</p>
        pub fn workspace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workspace_id = Some(input.into());
            self
        }
        /// <p>The ID of the workspace.</p>
        pub fn set_workspace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workspace_id = input; self
        }
        /// <p>The ARN of the workspace.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the workspace.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// <p>The description of the workspace.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the workspace.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>The date and time when the workspace was created.</p>
        pub fn creation_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date_time = Some(input);
            self
        }
        /// <p>The date and time when the workspace was created.</p>
        pub fn set_creation_date_time(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.creation_date_time = input; self
        }
        /// <p>The date and time when the workspace was last updated.</p>
        pub fn update_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_date_time = Some(input);
            self
        }
        /// <p>The date and time when the workspace was last updated.</p>
        pub fn set_update_date_time(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.update_date_time = input; self
        }
        /// Consumes the builder and constructs a [`WorkspaceSummary`](crate::model::WorkspaceSummary).
        pub fn build(self) -> crate::model::WorkspaceSummary {
            crate::model::WorkspaceSummary {
                workspace_id: self.workspace_id
                ,
                arn: self.arn
                ,
                description: self.description
                ,
                creation_date_time: self.creation_date_time
                ,
                update_date_time: self.update_date_time
                ,
            }
        }
    }
    
    
}
impl WorkspaceSummary {
    /// Creates a new builder-style object to manufacture [`WorkspaceSummary`](crate::model::WorkspaceSummary).
    pub fn builder() -> crate::model::workspace_summary::Builder {
        crate::model::workspace_summary::Builder::default()
    }
}

/// <p>The sync resource summary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SyncResourceSummary  {
    /// <p>The resource type.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::SyncResourceType>,
    /// <p>The external Id.</p>
    #[doc(hidden)]
    pub external_id: std::option::Option<std::string::String>,
    /// <p>The resource Id.</p>
    #[doc(hidden)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The sync resource summary status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::SyncResourceStatus>,
    /// <p>The update date and time.</p>
    #[doc(hidden)]
    pub update_date_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl SyncResourceSummary {
    /// <p>The resource type.</p>
    pub fn resource_type(&self) -> std::option::Option<& crate::model::SyncResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>The external Id.</p>
    pub fn external_id(&self) -> std::option::Option<& str> {
        self.external_id.as_deref()
    }
    /// <p>The resource Id.</p>
    pub fn resource_id(&self) -> std::option::Option<& str> {
        self.resource_id.as_deref()
    }
    /// <p>The sync resource summary status.</p>
    pub fn status(&self) -> std::option::Option<& crate::model::SyncResourceStatus> {
        self.status.as_ref()
    }
    /// <p>The update date and time.</p>
    pub fn update_date_time(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.update_date_time.as_ref()
    }
}
/// See [`SyncResourceSummary`](crate::model::SyncResourceSummary).
pub mod sync_resource_summary {
    
    /// A builder for [`SyncResourceSummary`](crate::model::SyncResourceSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_type: std::option::Option<crate::model::SyncResourceType>,
        pub(crate) external_id: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::SyncResourceStatus>,
        pub(crate) update_date_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The resource type.</p>
        pub fn resource_type(mut self, input: crate::model::SyncResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>The resource type.</p>
        pub fn set_resource_type(mut self, input: std::option::Option<crate::model::SyncResourceType>) -> Self {
            self.resource_type = input; self
        }
        /// <p>The external Id.</p>
        pub fn external_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.external_id = Some(input.into());
            self
        }
        /// <p>The external Id.</p>
        pub fn set_external_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.external_id = input; self
        }
        /// <p>The resource Id.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The resource Id.</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input; self
        }
        /// <p>The sync resource summary status.</p>
        pub fn status(mut self, input: crate::model::SyncResourceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The sync resource summary status.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::SyncResourceStatus>) -> Self {
            self.status = input; self
        }
        /// <p>The update date and time.</p>
        pub fn update_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_date_time = Some(input);
            self
        }
        /// <p>The update date and time.</p>
        pub fn set_update_date_time(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.update_date_time = input; self
        }
        /// Consumes the builder and constructs a [`SyncResourceSummary`](crate::model::SyncResourceSummary).
        pub fn build(self) -> crate::model::SyncResourceSummary {
            crate::model::SyncResourceSummary {
                resource_type: self.resource_type
                ,
                external_id: self.external_id
                ,
                resource_id: self.resource_id
                ,
                status: self.status
                ,
                update_date_time: self.update_date_time
                ,
            }
        }
    }
    
    
}
impl SyncResourceSummary {
    /// Creates a new builder-style object to manufacture [`SyncResourceSummary`](crate::model::SyncResourceSummary).
    pub fn builder() -> crate::model::sync_resource_summary::Builder {
        crate::model::sync_resource_summary::Builder::default()
    }
}

/// <p>The sync resource status.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SyncResourceStatus  {
    /// <p>The sync resource status state.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::SyncResourceState>,
    /// <p>The status error.</p>
    #[doc(hidden)]
    pub error: std::option::Option<crate::model::ErrorDetails>,
}
impl SyncResourceStatus {
    /// <p>The sync resource status state.</p>
    pub fn state(&self) -> std::option::Option<& crate::model::SyncResourceState> {
        self.state.as_ref()
    }
    /// <p>The status error.</p>
    pub fn error(&self) -> std::option::Option<& crate::model::ErrorDetails> {
        self.error.as_ref()
    }
}
/// See [`SyncResourceStatus`](crate::model::SyncResourceStatus).
pub mod sync_resource_status {
    
    /// A builder for [`SyncResourceStatus`](crate::model::SyncResourceStatus).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::SyncResourceState>,
        pub(crate) error: std::option::Option<crate::model::ErrorDetails>,
    }
    impl Builder {
        /// <p>The sync resource status state.</p>
        pub fn state(mut self, input: crate::model::SyncResourceState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The sync resource status state.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::SyncResourceState>) -> Self {
            self.state = input; self
        }
        /// <p>The status error.</p>
        pub fn error(mut self, input: crate::model::ErrorDetails) -> Self {
            self.error = Some(input);
            self
        }
        /// <p>The status error.</p>
        pub fn set_error(mut self, input: std::option::Option<crate::model::ErrorDetails>) -> Self {
            self.error = input; self
        }
        /// Consumes the builder and constructs a [`SyncResourceStatus`](crate::model::SyncResourceStatus).
        pub fn build(self) -> crate::model::SyncResourceStatus {
            crate::model::SyncResourceStatus {
                state: self.state
                ,
                error: self.error
                ,
            }
        }
    }
    
    
}
impl SyncResourceStatus {
    /// Creates a new builder-style object to manufacture [`SyncResourceStatus`](crate::model::SyncResourceStatus).
    pub fn builder() -> crate::model::sync_resource_status::Builder {
        crate::model::sync_resource_status::Builder::default()
    }
}

/// <p>The error details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ErrorDetails  {
    /// <p>The error code.</p>
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::ErrorCode>,
    /// <p>The error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ErrorDetails {
    /// <p>The error code.</p>
    pub fn code(&self) -> std::option::Option<& crate::model::ErrorCode> {
        self.code.as_ref()
    }
    /// <p>The error message.</p>
    pub fn message(&self) -> std::option::Option<& str> {
        self.message.as_deref()
    }
}
/// See [`ErrorDetails`](crate::model::ErrorDetails).
pub mod error_details {
    
    /// A builder for [`ErrorDetails`](crate::model::ErrorDetails).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        /// <p>The error code.</p>
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input; self
        }
        /// <p>The error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ErrorDetails`](crate::model::ErrorDetails).
        pub fn build(self) -> crate::model::ErrorDetails {
            crate::model::ErrorDetails {
                code: self.code
                ,
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ErrorDetails {
    /// Creates a new builder-style object to manufacture [`ErrorDetails`](crate::model::ErrorDetails).
    pub fn builder() -> crate::model::error_details::Builder {
        crate::model::error_details::Builder::default()
    }
}

/// When writing a match expression against `ErrorCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let errorcode = unimplemented!();
/// match errorcode {
///     ErrorCode::InternalFailure => { /* ... */ },
///     ErrorCode::SyncCreatingError => { /* ... */ },
///     ErrorCode::SyncInitializingError => { /* ... */ },
///     ErrorCode::SyncProcessingError => { /* ... */ },
///     ErrorCode::ValidationError => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `errorcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ErrorCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ErrorCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ErrorCode::NewFeature` is defined.
/// Specifically, when `errorcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ErrorCode::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum ErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    InternalFailure,
    #[allow(missing_docs)] // documentation missing in model
    SyncCreatingError,
    #[allow(missing_docs)] // documentation missing in model
    SyncInitializingError,
    #[allow(missing_docs)] // documentation missing in model
    SyncProcessingError,
    #[allow(missing_docs)] // documentation missing in model
    ValidationError,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for ErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "INTERNAL_FAILURE" => ErrorCode::InternalFailure,
            "SYNC_CREATING_ERROR" => ErrorCode::SyncCreatingError,
            "SYNC_INITIALIZING_ERROR" => ErrorCode::SyncInitializingError,
            "SYNC_PROCESSING_ERROR" => ErrorCode::SyncProcessingError,
            "VALIDATION_ERROR" => ErrorCode::ValidationError,
            other => ErrorCode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for ErrorCode {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(ErrorCode::from(s))
                }
            }
impl ErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ErrorCode::InternalFailure => "INTERNAL_FAILURE",
            ErrorCode::SyncCreatingError => "SYNC_CREATING_ERROR",
            ErrorCode::SyncInitializingError => "SYNC_INITIALIZING_ERROR",
            ErrorCode::SyncProcessingError => "SYNC_PROCESSING_ERROR",
            ErrorCode::ValidationError => "VALIDATION_ERROR",
            ErrorCode::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "INTERNAL_FAILURE", "SYNC_CREATING_ERROR", "SYNC_INITIALIZING_ERROR", "SYNC_PROCESSING_ERROR", "VALIDATION_ERROR"
        ]
    }
}
impl AsRef<str> for ErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SyncResourceState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let syncresourcestate = unimplemented!();
/// match syncresourcestate {
///     SyncResourceState::Deleted => { /* ... */ },
///     SyncResourceState::Error => { /* ... */ },
///     SyncResourceState::Initializing => { /* ... */ },
///     SyncResourceState::InSync => { /* ... */ },
///     SyncResourceState::Processing => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `syncresourcestate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SyncResourceState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SyncResourceState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SyncResourceState::NewFeature` is defined.
/// Specifically, when `syncresourcestate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SyncResourceState::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum SyncResourceState {
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Initializing,
    #[allow(missing_docs)] // documentation missing in model
    InSync,
    #[allow(missing_docs)] // documentation missing in model
    Processing,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for SyncResourceState {
    fn from(s: &str) -> Self {
        match s {
            "DELETED" => SyncResourceState::Deleted,
            "ERROR" => SyncResourceState::Error,
            "INITIALIZING" => SyncResourceState::Initializing,
            "IN_SYNC" => SyncResourceState::InSync,
            "PROCESSING" => SyncResourceState::Processing,
            other => SyncResourceState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for SyncResourceState {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(SyncResourceState::from(s))
                }
            }
impl SyncResourceState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SyncResourceState::Deleted => "DELETED",
            SyncResourceState::Error => "ERROR",
            SyncResourceState::Initializing => "INITIALIZING",
            SyncResourceState::InSync => "IN_SYNC",
            SyncResourceState::Processing => "PROCESSING",
            SyncResourceState::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DELETED", "ERROR", "INITIALIZING", "IN_SYNC", "PROCESSING"
        ]
    }
}
impl AsRef<str> for SyncResourceState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SyncResourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let syncresourcetype = unimplemented!();
/// match syncresourcetype {
///     SyncResourceType::ComponentType => { /* ... */ },
///     SyncResourceType::Entity => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `syncresourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SyncResourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SyncResourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SyncResourceType::NewFeature` is defined.
/// Specifically, when `syncresourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SyncResourceType::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum SyncResourceType {
    #[allow(missing_docs)] // documentation missing in model
    ComponentType,
    #[allow(missing_docs)] // documentation missing in model
    Entity,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for SyncResourceType {
    fn from(s: &str) -> Self {
        match s {
            "COMPONENT_TYPE" => SyncResourceType::ComponentType,
            "ENTITY" => SyncResourceType::Entity,
            other => SyncResourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for SyncResourceType {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(SyncResourceType::from(s))
                }
            }
impl SyncResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SyncResourceType::ComponentType => "COMPONENT_TYPE",
            SyncResourceType::Entity => "ENTITY",
            SyncResourceType::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "COMPONENT_TYPE", "ENTITY"
        ]
    }
}
impl AsRef<str> for SyncResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The sync resource filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum SyncResourceFilter {
    /// <p>The external Id.</p>
    ExternalId(std::string::String),
    /// <p>The sync resource filter resource Id.</p>
    ResourceId(std::string::String),
    /// <p>The sync resource filter resoucre type</p>
    ResourceType(crate::model::SyncResourceType),
    /// <p>The sync resource filter's state.</p>
    State(crate::model::SyncResourceState),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl SyncResourceFilter {
    /// Tries to convert the enum instance into [`ExternalId`](crate::model::SyncResourceFilter::ExternalId), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_external_id(&self) -> std::result::Result<&std::string::String, &Self> {
        if let SyncResourceFilter::ExternalId(val) = &self { Ok(val) } else { Err(self) }
    }
    /// Returns true if this is a [`ExternalId`](crate::model::SyncResourceFilter::ExternalId).
    pub fn is_external_id(&self) -> bool {
        self.as_external_id().is_ok()
    }
    /// Tries to convert the enum instance into [`ResourceId`](crate::model::SyncResourceFilter::ResourceId), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_resource_id(&self) -> std::result::Result<&std::string::String, &Self> {
        if let SyncResourceFilter::ResourceId(val) = &self { Ok(val) } else { Err(self) }
    }
    /// Returns true if this is a [`ResourceId`](crate::model::SyncResourceFilter::ResourceId).
    pub fn is_resource_id(&self) -> bool {
        self.as_resource_id().is_ok()
    }
    /// Tries to convert the enum instance into [`ResourceType`](crate::model::SyncResourceFilter::ResourceType), extracting the inner [`SyncResourceType`](crate::model::SyncResourceType).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_resource_type(&self) -> std::result::Result<&crate::model::SyncResourceType, &Self> {
        if let SyncResourceFilter::ResourceType(val) = &self { Ok(val) } else { Err(self) }
    }
    /// Returns true if this is a [`ResourceType`](crate::model::SyncResourceFilter::ResourceType).
    pub fn is_resource_type(&self) -> bool {
        self.as_resource_type().is_ok()
    }
    /// Tries to convert the enum instance into [`State`](crate::model::SyncResourceFilter::State), extracting the inner [`SyncResourceState`](crate::model::SyncResourceState).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_state(&self) -> std::result::Result<&crate::model::SyncResourceState, &Self> {
        if let SyncResourceFilter::State(val) = &self { Ok(val) } else { Err(self) }
    }
    /// Returns true if this is a [`State`](crate::model::SyncResourceFilter::State).
    pub fn is_state(&self) -> bool {
        self.as_state().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>The SyncJob summary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SyncJobSummary  {
    /// <p>The SyncJob summary ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The ID of the workspace that contains the sync job.</p>
    #[doc(hidden)]
    pub workspace_id: std::option::Option<std::string::String>,
    /// <p>The sync source.</p>
    #[doc(hidden)]
    pub sync_source: std::option::Option<std::string::String>,
    /// <p>The SyncJob summaries status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::SyncJobStatus>,
    /// <p>The creation date and time.</p>
    #[doc(hidden)]
    pub creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The update date and time.</p>
    #[doc(hidden)]
    pub update_date_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl SyncJobSummary {
    /// <p>The SyncJob summary ARN.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>The ID of the workspace that contains the sync job.</p>
    pub fn workspace_id(&self) -> std::option::Option<& str> {
        self.workspace_id.as_deref()
    }
    /// <p>The sync source.</p>
    pub fn sync_source(&self) -> std::option::Option<& str> {
        self.sync_source.as_deref()
    }
    /// <p>The SyncJob summaries status.</p>
    pub fn status(&self) -> std::option::Option<& crate::model::SyncJobStatus> {
        self.status.as_ref()
    }
    /// <p>The creation date and time.</p>
    pub fn creation_date_time(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.creation_date_time.as_ref()
    }
    /// <p>The update date and time.</p>
    pub fn update_date_time(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.update_date_time.as_ref()
    }
}
/// See [`SyncJobSummary`](crate::model::SyncJobSummary).
pub mod sync_job_summary {
    
    /// A builder for [`SyncJobSummary`](crate::model::SyncJobSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) workspace_id: std::option::Option<std::string::String>,
        pub(crate) sync_source: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::SyncJobStatus>,
        pub(crate) creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_date_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The SyncJob summary ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The SyncJob summary ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// <p>The ID of the workspace that contains the sync job.</p>
        pub fn workspace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workspace_id = Some(input.into());
            self
        }
        /// <p>The ID of the workspace that contains the sync job.</p>
        pub fn set_workspace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workspace_id = input; self
        }
        /// <p>The sync source.</p>
        pub fn sync_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.sync_source = Some(input.into());
            self
        }
        /// <p>The sync source.</p>
        pub fn set_sync_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sync_source = input; self
        }
        /// <p>The SyncJob summaries status.</p>
        pub fn status(mut self, input: crate::model::SyncJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The SyncJob summaries status.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::SyncJobStatus>) -> Self {
            self.status = input; self
        }
        /// <p>The creation date and time.</p>
        pub fn creation_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date_time = Some(input);
            self
        }
        /// <p>The creation date and time.</p>
        pub fn set_creation_date_time(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.creation_date_time = input; self
        }
        /// <p>The update date and time.</p>
        pub fn update_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_date_time = Some(input);
            self
        }
        /// <p>The update date and time.</p>
        pub fn set_update_date_time(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.update_date_time = input; self
        }
        /// Consumes the builder and constructs a [`SyncJobSummary`](crate::model::SyncJobSummary).
        pub fn build(self) -> crate::model::SyncJobSummary {
            crate::model::SyncJobSummary {
                arn: self.arn
                ,
                workspace_id: self.workspace_id
                ,
                sync_source: self.sync_source
                ,
                status: self.status
                ,
                creation_date_time: self.creation_date_time
                ,
                update_date_time: self.update_date_time
                ,
            }
        }
    }
    
    
}
impl SyncJobSummary {
    /// Creates a new builder-style object to manufacture [`SyncJobSummary`](crate::model::SyncJobSummary).
    pub fn builder() -> crate::model::sync_job_summary::Builder {
        crate::model::sync_job_summary::Builder::default()
    }
}

/// <p>The SyncJob status.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SyncJobStatus  {
    /// <p>The SyncJob status state.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::SyncJobState>,
    /// <p>The SyncJob error.</p>
    #[doc(hidden)]
    pub error: std::option::Option<crate::model::ErrorDetails>,
}
impl SyncJobStatus {
    /// <p>The SyncJob status state.</p>
    pub fn state(&self) -> std::option::Option<& crate::model::SyncJobState> {
        self.state.as_ref()
    }
    /// <p>The SyncJob error.</p>
    pub fn error(&self) -> std::option::Option<& crate::model::ErrorDetails> {
        self.error.as_ref()
    }
}
/// See [`SyncJobStatus`](crate::model::SyncJobStatus).
pub mod sync_job_status {
    
    /// A builder for [`SyncJobStatus`](crate::model::SyncJobStatus).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::SyncJobState>,
        pub(crate) error: std::option::Option<crate::model::ErrorDetails>,
    }
    impl Builder {
        /// <p>The SyncJob status state.</p>
        pub fn state(mut self, input: crate::model::SyncJobState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The SyncJob status state.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::SyncJobState>) -> Self {
            self.state = input; self
        }
        /// <p>The SyncJob error.</p>
        pub fn error(mut self, input: crate::model::ErrorDetails) -> Self {
            self.error = Some(input);
            self
        }
        /// <p>The SyncJob error.</p>
        pub fn set_error(mut self, input: std::option::Option<crate::model::ErrorDetails>) -> Self {
            self.error = input; self
        }
        /// Consumes the builder and constructs a [`SyncJobStatus`](crate::model::SyncJobStatus).
        pub fn build(self) -> crate::model::SyncJobStatus {
            crate::model::SyncJobStatus {
                state: self.state
                ,
                error: self.error
                ,
            }
        }
    }
    
    
}
impl SyncJobStatus {
    /// Creates a new builder-style object to manufacture [`SyncJobStatus`](crate::model::SyncJobStatus).
    pub fn builder() -> crate::model::sync_job_status::Builder {
        crate::model::sync_job_status::Builder::default()
    }
}

/// When writing a match expression against `SyncJobState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let syncjobstate = unimplemented!();
/// match syncjobstate {
///     SyncJobState::Active => { /* ... */ },
///     SyncJobState::Creating => { /* ... */ },
///     SyncJobState::Deleting => { /* ... */ },
///     SyncJobState::Error => { /* ... */ },
///     SyncJobState::Initializing => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `syncjobstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SyncJobState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SyncJobState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SyncJobState::NewFeature` is defined.
/// Specifically, when `syncjobstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SyncJobState::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum SyncJobState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Initializing,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for SyncJobState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => SyncJobState::Active,
            "CREATING" => SyncJobState::Creating,
            "DELETING" => SyncJobState::Deleting,
            "ERROR" => SyncJobState::Error,
            "INITIALIZING" => SyncJobState::Initializing,
            other => SyncJobState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for SyncJobState {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(SyncJobState::from(s))
                }
            }
impl SyncJobState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SyncJobState::Active => "ACTIVE",
            SyncJobState::Creating => "CREATING",
            SyncJobState::Deleting => "DELETING",
            SyncJobState::Error => "ERROR",
            SyncJobState::Initializing => "INITIALIZING",
            SyncJobState::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACTIVE", "CREATING", "DELETING", "ERROR", "INITIALIZING"
        ]
    }
}
impl AsRef<str> for SyncJobState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that contains information about a scene.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SceneSummary  {
    /// <p>The ID of the scene.</p>
    #[doc(hidden)]
    pub scene_id: std::option::Option<std::string::String>,
    /// <p>The relative path that specifies the location of the content definition file.</p>
    #[doc(hidden)]
    pub content_location: std::option::Option<std::string::String>,
    /// <p>The ARN of the scene.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The date and time when the scene was created.</p>
    #[doc(hidden)]
    pub creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time when the scene was last updated.</p>
    #[doc(hidden)]
    pub update_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The scene description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl SceneSummary {
    /// <p>The ID of the scene.</p>
    pub fn scene_id(&self) -> std::option::Option<& str> {
        self.scene_id.as_deref()
    }
    /// <p>The relative path that specifies the location of the content definition file.</p>
    pub fn content_location(&self) -> std::option::Option<& str> {
        self.content_location.as_deref()
    }
    /// <p>The ARN of the scene.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>The date and time when the scene was created.</p>
    pub fn creation_date_time(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.creation_date_time.as_ref()
    }
    /// <p>The date and time when the scene was last updated.</p>
    pub fn update_date_time(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.update_date_time.as_ref()
    }
    /// <p>The scene description.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
}
/// See [`SceneSummary`](crate::model::SceneSummary).
pub mod scene_summary {
    
    /// A builder for [`SceneSummary`](crate::model::SceneSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scene_id: std::option::Option<std::string::String>,
        pub(crate) content_location: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the scene.</p>
        pub fn scene_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.scene_id = Some(input.into());
            self
        }
        /// <p>The ID of the scene.</p>
        pub fn set_scene_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.scene_id = input; self
        }
        /// <p>The relative path that specifies the location of the content definition file.</p>
        pub fn content_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_location = Some(input.into());
            self
        }
        /// <p>The relative path that specifies the location of the content definition file.</p>
        pub fn set_content_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_location = input; self
        }
        /// <p>The ARN of the scene.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the scene.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// <p>The date and time when the scene was created.</p>
        pub fn creation_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date_time = Some(input);
            self
        }
        /// <p>The date and time when the scene was created.</p>
        pub fn set_creation_date_time(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.creation_date_time = input; self
        }
        /// <p>The date and time when the scene was last updated.</p>
        pub fn update_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_date_time = Some(input);
            self
        }
        /// <p>The date and time when the scene was last updated.</p>
        pub fn set_update_date_time(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.update_date_time = input; self
        }
        /// <p>The scene description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The scene description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// Consumes the builder and constructs a [`SceneSummary`](crate::model::SceneSummary).
        pub fn build(self) -> crate::model::SceneSummary {
            crate::model::SceneSummary {
                scene_id: self.scene_id
                ,
                content_location: self.content_location
                ,
                arn: self.arn
                ,
                creation_date_time: self.creation_date_time
                ,
                update_date_time: self.update_date_time
                ,
                description: self.description
                ,
            }
        }
    }
    
    
}
impl SceneSummary {
    /// Creates a new builder-style object to manufacture [`SceneSummary`](crate::model::SceneSummary).
    pub fn builder() -> crate::model::scene_summary::Builder {
        crate::model::scene_summary::Builder::default()
    }
}

/// <p>An object that contains information about an entity.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EntitySummary  {
    /// <p>The ID of the entity.</p>
    #[doc(hidden)]
    pub entity_id: std::option::Option<std::string::String>,
    /// <p>The name of the entity.</p>
    #[doc(hidden)]
    pub entity_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the entity.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The ID of the parent entity.</p>
    #[doc(hidden)]
    pub parent_entity_id: std::option::Option<std::string::String>,
    /// <p>The current status of the entity.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::Status>,
    /// <p>The description of the entity.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>A Boolean value that specifies whether the entity has child entities or not.</p>
    #[doc(hidden)]
    pub has_child_entities: std::option::Option<bool>,
    /// <p>The date and time when the entity was created.</p>
    #[doc(hidden)]
    pub creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last date and time when the entity was updated.</p>
    #[doc(hidden)]
    pub update_date_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl EntitySummary {
    /// <p>The ID of the entity.</p>
    pub fn entity_id(&self) -> std::option::Option<& str> {
        self.entity_id.as_deref()
    }
    /// <p>The name of the entity.</p>
    pub fn entity_name(&self) -> std::option::Option<& str> {
        self.entity_name.as_deref()
    }
    /// <p>The ARN of the entity.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>The ID of the parent entity.</p>
    pub fn parent_entity_id(&self) -> std::option::Option<& str> {
        self.parent_entity_id.as_deref()
    }
    /// <p>The current status of the entity.</p>
    pub fn status(&self) -> std::option::Option<& crate::model::Status> {
        self.status.as_ref()
    }
    /// <p>The description of the entity.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>A Boolean value that specifies whether the entity has child entities or not.</p>
    pub fn has_child_entities(&self) -> std::option::Option<bool> {
        self.has_child_entities
    }
    /// <p>The date and time when the entity was created.</p>
    pub fn creation_date_time(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.creation_date_time.as_ref()
    }
    /// <p>The last date and time when the entity was updated.</p>
    pub fn update_date_time(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.update_date_time.as_ref()
    }
}
/// See [`EntitySummary`](crate::model::EntitySummary).
pub mod entity_summary {
    
    /// A builder for [`EntitySummary`](crate::model::EntitySummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entity_id: std::option::Option<std::string::String>,
        pub(crate) entity_name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) parent_entity_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::Status>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) has_child_entities: std::option::Option<bool>,
        pub(crate) creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_date_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The ID of the entity.</p>
        pub fn entity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entity_id = Some(input.into());
            self
        }
        /// <p>The ID of the entity.</p>
        pub fn set_entity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entity_id = input; self
        }
        /// <p>The name of the entity.</p>
        pub fn entity_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.entity_name = Some(input.into());
            self
        }
        /// <p>The name of the entity.</p>
        pub fn set_entity_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entity_name = input; self
        }
        /// <p>The ARN of the entity.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the entity.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// <p>The ID of the parent entity.</p>
        pub fn parent_entity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.parent_entity_id = Some(input.into());
            self
        }
        /// <p>The ID of the parent entity.</p>
        pub fn set_parent_entity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.parent_entity_id = input; self
        }
        /// <p>The current status of the entity.</p>
        pub fn status(mut self, input: crate::model::Status) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the entity.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::Status>) -> Self {
            self.status = input; self
        }
        /// <p>The description of the entity.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the entity.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>A Boolean value that specifies whether the entity has child entities or not.</p>
        pub fn has_child_entities(mut self, input: bool) -> Self {
            self.has_child_entities = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the entity has child entities or not.</p>
        pub fn set_has_child_entities(mut self, input: std::option::Option<bool>) -> Self {
            self.has_child_entities = input; self
        }
        /// <p>The date and time when the entity was created.</p>
        pub fn creation_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date_time = Some(input);
            self
        }
        /// <p>The date and time when the entity was created.</p>
        pub fn set_creation_date_time(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.creation_date_time = input; self
        }
        /// <p>The last date and time when the entity was updated.</p>
        pub fn update_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_date_time = Some(input);
            self
        }
        /// <p>The last date and time when the entity was updated.</p>
        pub fn set_update_date_time(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.update_date_time = input; self
        }
        /// Consumes the builder and constructs a [`EntitySummary`](crate::model::EntitySummary).
        pub fn build(self) -> crate::model::EntitySummary {
            crate::model::EntitySummary {
                entity_id: self.entity_id
                ,
                entity_name: self.entity_name
                ,
                arn: self.arn
                ,
                parent_entity_id: self.parent_entity_id
                ,
                status: self.status
                ,
                description: self.description
                ,
                has_child_entities: self.has_child_entities
                ,
                creation_date_time: self.creation_date_time
                ,
                update_date_time: self.update_date_time
                ,
            }
        }
    }
    
    
}
impl EntitySummary {
    /// Creates a new builder-style object to manufacture [`EntitySummary`](crate::model::EntitySummary).
    pub fn builder() -> crate::model::entity_summary::Builder {
        crate::model::entity_summary::Builder::default()
    }
}

/// <p>An object that represents the status of an entity, component, component type, or workspace.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Status  {
    /// <p>The current state of the entity, component, component type, or workspace.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::State>,
    /// <p>The error message.</p>
    #[doc(hidden)]
    pub error: std::option::Option<crate::model::ErrorDetails>,
}
impl Status {
    /// <p>The current state of the entity, component, component type, or workspace.</p>
    pub fn state(&self) -> std::option::Option<& crate::model::State> {
        self.state.as_ref()
    }
    /// <p>The error message.</p>
    pub fn error(&self) -> std::option::Option<& crate::model::ErrorDetails> {
        self.error.as_ref()
    }
}
/// See [`Status`](crate::model::Status).
pub mod status {
    
    /// A builder for [`Status`](crate::model::Status).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::State>,
        pub(crate) error: std::option::Option<crate::model::ErrorDetails>,
    }
    impl Builder {
        /// <p>The current state of the entity, component, component type, or workspace.</p>
        pub fn state(mut self, input: crate::model::State) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state of the entity, component, component type, or workspace.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::State>) -> Self {
            self.state = input; self
        }
        /// <p>The error message.</p>
        pub fn error(mut self, input: crate::model::ErrorDetails) -> Self {
            self.error = Some(input);
            self
        }
        /// <p>The error message.</p>
        pub fn set_error(mut self, input: std::option::Option<crate::model::ErrorDetails>) -> Self {
            self.error = input; self
        }
        /// Consumes the builder and constructs a [`Status`](crate::model::Status).
        pub fn build(self) -> crate::model::Status {
            crate::model::Status {
                state: self.state
                ,
                error: self.error
                ,
            }
        }
    }
    
    
}
impl Status {
    /// Creates a new builder-style object to manufacture [`Status`](crate::model::Status).
    pub fn builder() -> crate::model::status::Builder {
        crate::model::status::Builder::default()
    }
}

/// <p>An object that filters items in a list of entities.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum ListEntitiesFilter {
    /// <p>The ID of the component type in the entities in the list.</p>
    ComponentTypeId(std::string::String),
    /// <p>The external-Id property of a component. The external-Id property is the primary key of an external storage system.</p>
    ExternalId(std::string::String),
    /// <p>The parent of the entities in the list.</p>
    ParentEntityId(std::string::String),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl ListEntitiesFilter {
    /// Tries to convert the enum instance into [`ComponentTypeId`](crate::model::ListEntitiesFilter::ComponentTypeId), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_component_type_id(&self) -> std::result::Result<&std::string::String, &Self> {
        if let ListEntitiesFilter::ComponentTypeId(val) = &self { Ok(val) } else { Err(self) }
    }
    /// Returns true if this is a [`ComponentTypeId`](crate::model::ListEntitiesFilter::ComponentTypeId).
    pub fn is_component_type_id(&self) -> bool {
        self.as_component_type_id().is_ok()
    }
    /// Tries to convert the enum instance into [`ExternalId`](crate::model::ListEntitiesFilter::ExternalId), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_external_id(&self) -> std::result::Result<&std::string::String, &Self> {
        if let ListEntitiesFilter::ExternalId(val) = &self { Ok(val) } else { Err(self) }
    }
    /// Returns true if this is a [`ExternalId`](crate::model::ListEntitiesFilter::ExternalId).
    pub fn is_external_id(&self) -> bool {
        self.as_external_id().is_ok()
    }
    /// Tries to convert the enum instance into [`ParentEntityId`](crate::model::ListEntitiesFilter::ParentEntityId), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_parent_entity_id(&self) -> std::result::Result<&std::string::String, &Self> {
        if let ListEntitiesFilter::ParentEntityId(val) = &self { Ok(val) } else { Err(self) }
    }
    /// Returns true if this is a [`ParentEntityId`](crate::model::ListEntitiesFilter::ParentEntityId).
    pub fn is_parent_entity_id(&self) -> bool {
        self.as_parent_entity_id().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>An object that contains information about a component type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComponentTypeSummary  {
    /// <p>The ARN of the component type.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The ID of the component type.</p>
    #[doc(hidden)]
    pub component_type_id: std::option::Option<std::string::String>,
    /// <p>The date and time when the component type was created.</p>
    #[doc(hidden)]
    pub creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time when the component type was last updated.</p>
    #[doc(hidden)]
    pub update_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The description of the component type.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The current status of the component type.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::Status>,
    /// <p>The component type name.</p>
    #[doc(hidden)]
    pub component_type_name: std::option::Option<std::string::String>,
}
impl ComponentTypeSummary {
    /// <p>The ARN of the component type.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>The ID of the component type.</p>
    pub fn component_type_id(&self) -> std::option::Option<& str> {
        self.component_type_id.as_deref()
    }
    /// <p>The date and time when the component type was created.</p>
    pub fn creation_date_time(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.creation_date_time.as_ref()
    }
    /// <p>The date and time when the component type was last updated.</p>
    pub fn update_date_time(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.update_date_time.as_ref()
    }
    /// <p>The description of the component type.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>The current status of the component type.</p>
    pub fn status(&self) -> std::option::Option<& crate::model::Status> {
        self.status.as_ref()
    }
    /// <p>The component type name.</p>
    pub fn component_type_name(&self) -> std::option::Option<& str> {
        self.component_type_name.as_deref()
    }
}
/// See [`ComponentTypeSummary`](crate::model::ComponentTypeSummary).
pub mod component_type_summary {
    
    /// A builder for [`ComponentTypeSummary`](crate::model::ComponentTypeSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) component_type_id: std::option::Option<std::string::String>,
        pub(crate) creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::Status>,
        pub(crate) component_type_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the component type.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the component type.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// <p>The ID of the component type.</p>
        pub fn component_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_type_id = Some(input.into());
            self
        }
        /// <p>The ID of the component type.</p>
        pub fn set_component_type_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.component_type_id = input; self
        }
        /// <p>The date and time when the component type was created.</p>
        pub fn creation_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date_time = Some(input);
            self
        }
        /// <p>The date and time when the component type was created.</p>
        pub fn set_creation_date_time(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.creation_date_time = input; self
        }
        /// <p>The date and time when the component type was last updated.</p>
        pub fn update_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_date_time = Some(input);
            self
        }
        /// <p>The date and time when the component type was last updated.</p>
        pub fn set_update_date_time(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.update_date_time = input; self
        }
        /// <p>The description of the component type.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the component type.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>The current status of the component type.</p>
        pub fn status(mut self, input: crate::model::Status) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the component type.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::Status>) -> Self {
            self.status = input; self
        }
        /// <p>The component type name.</p>
        pub fn component_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_type_name = Some(input.into());
            self
        }
        /// <p>The component type name.</p>
        pub fn set_component_type_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.component_type_name = input; self
        }
        /// Consumes the builder and constructs a [`ComponentTypeSummary`](crate::model::ComponentTypeSummary).
        pub fn build(self) -> crate::model::ComponentTypeSummary {
            crate::model::ComponentTypeSummary {
                arn: self.arn
                ,
                component_type_id: self.component_type_id
                ,
                creation_date_time: self.creation_date_time
                ,
                update_date_time: self.update_date_time
                ,
                description: self.description
                ,
                status: self.status
                ,
                component_type_name: self.component_type_name
                ,
            }
        }
    }
    
    
}
impl ComponentTypeSummary {
    /// Creates a new builder-style object to manufacture [`ComponentTypeSummary`](crate::model::ComponentTypeSummary).
    pub fn builder() -> crate::model::component_type_summary::Builder {
        crate::model::component_type_summary::Builder::default()
    }
}

/// <p>An object that filters items in a list of component types.</p> <note> 
/// <p>Only one object is accepted as a valid input.</p> 
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum ListComponentTypesFilter {
    /// <p>The component type that the component types in the list extend.</p>
    ExtendsFrom(std::string::String),
    /// <p>A Boolean value that specifies whether the component types in the list are abstract.</p>
    IsAbstract(bool),
    /// <p>The namespace to which the component types in the list belong.</p>
    Namespace(std::string::String),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl ListComponentTypesFilter {
    /// Tries to convert the enum instance into [`ExtendsFrom`](crate::model::ListComponentTypesFilter::ExtendsFrom), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_extends_from(&self) -> std::result::Result<&std::string::String, &Self> {
        if let ListComponentTypesFilter::ExtendsFrom(val) = &self { Ok(val) } else { Err(self) }
    }
    /// Returns true if this is a [`ExtendsFrom`](crate::model::ListComponentTypesFilter::ExtendsFrom).
    pub fn is_extends_from(&self) -> bool {
        self.as_extends_from().is_ok()
    }
    /// Tries to convert the enum instance into [`IsAbstract`](crate::model::ListComponentTypesFilter::IsAbstract), extracting the inner [`bool`](bool).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_is_abstract(&self) -> std::result::Result<&bool, &Self> {
        if let ListComponentTypesFilter::IsAbstract(val) = &self { Ok(val) } else { Err(self) }
    }
    /// Returns true if this is a [`IsAbstract`](crate::model::ListComponentTypesFilter::IsAbstract).
    pub fn is_is_abstract(&self) -> bool {
        self.as_is_abstract().is_ok()
    }
    /// Tries to convert the enum instance into [`Namespace`](crate::model::ListComponentTypesFilter::Namespace), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_namespace(&self) -> std::result::Result<&std::string::String, &Self> {
        if let ListComponentTypesFilter::Namespace(val) = &self { Ok(val) } else { Err(self) }
    }
    /// Returns true if this is a [`Namespace`](crate::model::ListComponentTypesFilter::Namespace).
    pub fn is_namespace(&self) -> bool {
        self.as_namespace().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>The history of values for a time series property.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyValueHistory  {
    /// <p>An object that uniquely identifies an entity property.</p>
    #[doc(hidden)]
    pub entity_property_reference: std::option::Option<crate::model::EntityPropertyReference>,
    /// <p>A list of objects that contain information about the values in the history of a time series property.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<crate::model::PropertyValue>>,
}
impl PropertyValueHistory {
    /// <p>An object that uniquely identifies an entity property.</p>
    pub fn entity_property_reference(&self) -> std::option::Option<& crate::model::EntityPropertyReference> {
        self.entity_property_reference.as_ref()
    }
    /// <p>A list of objects that contain information about the values in the history of a time series property.</p>
    pub fn values(&self) -> std::option::Option<& [crate::model::PropertyValue]> {
        self.values.as_deref()
    }
}
/// See [`PropertyValueHistory`](crate::model::PropertyValueHistory).
pub mod property_value_history {
    
    /// A builder for [`PropertyValueHistory`](crate::model::PropertyValueHistory).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entity_property_reference: std::option::Option<crate::model::EntityPropertyReference>,
        pub(crate) values: std::option::Option<std::vec::Vec<crate::model::PropertyValue>>,
    }
    impl Builder {
        /// <p>An object that uniquely identifies an entity property.</p>
        pub fn entity_property_reference(mut self, input: crate::model::EntityPropertyReference) -> Self {
            self.entity_property_reference = Some(input);
            self
        }
        /// <p>An object that uniquely identifies an entity property.</p>
        pub fn set_entity_property_reference(mut self, input: std::option::Option<crate::model::EntityPropertyReference>) -> Self {
            self.entity_property_reference = input; self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>A list of objects that contain information about the values in the history of a time series property.</p>
        pub fn values(mut self, input: crate::model::PropertyValue) -> Self {
            let mut v = self.values.unwrap_or_default();
                            v.push(input);
                            self.values = Some(v);
                            self
        }
        /// <p>A list of objects that contain information about the values in the history of a time series property.</p>
        pub fn set_values(mut self, input: std::option::Option<std::vec::Vec<crate::model::PropertyValue>>) -> Self {
            self.values = input; self
        }
        /// Consumes the builder and constructs a [`PropertyValueHistory`](crate::model::PropertyValueHistory).
        pub fn build(self) -> crate::model::PropertyValueHistory {
            crate::model::PropertyValueHistory {
                entity_property_reference: self.entity_property_reference
                ,
                values: self.values
                ,
            }
        }
    }
    
    
}
impl PropertyValueHistory {
    /// Creates a new builder-style object to manufacture [`PropertyValueHistory`](crate::model::PropertyValueHistory).
    pub fn builder() -> crate::model::property_value_history::Builder {
        crate::model::property_value_history::Builder::default()
    }
}

/// <p>An object that contains information about a value for a time series property.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyValue  {
    /// <p>The timestamp of a value for a time series property.</p>
    #[deprecated(note = "This field is deprecated and will throw an error in the future. Use time instead.")]
    #[doc(hidden)]
    pub timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>An object that specifies a value for a time series property.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::DataValue>,
    /// <p>ISO8601 DateTime of a value for a time series property.</p> 
    /// <p>The time for when the property value was recorded in ISO 8601 format: <i>YYYY-MM-DDThh:mm:ss[.SSSSSSSSS][Z/HH:mm]</i>.</p> 
    /// <ul> 
    /// <li> <p> <i>[YYYY]</i>: year</p> </li> 
    /// <li> <p> <i>[MM]</i>: month</p> </li> 
    /// <li> <p> <i>[DD]</i>: day</p> </li> 
    /// <li> <p> <i>[hh]</i>: hour</p> </li> 
    /// <li> <p> <i>[mm]</i>: minute</p> </li> 
    /// <li> <p> <i>[ss]</i>: seconds</p> </li> 
    /// <li> <p> <i>[.SSSSSSSSS]</i>: additional precision, where precedence is maintained. For example: [.573123] is equal to 573123000 nanoseconds.</p> </li> 
    /// <li> <p> <i>Z</i>: default timezone UTC</p> </li> 
    /// <li> <p> <i> HH:mm</i>: time zone offset in Hours and Minutes.</p> </li> 
    /// </ul> 
    /// <p> <i>Required sub-fields</i>: YYYY-MM-DDThh:mm:ss and [Z/HH:mm]</p>
    #[doc(hidden)]
    pub time: std::option::Option<std::string::String>,
}
impl PropertyValue {
    /// <p>The timestamp of a value for a time series property.</p>
    #[deprecated(note = "This field is deprecated and will throw an error in the future. Use time instead.")]
    pub fn timestamp(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.timestamp.as_ref()
    }
    /// <p>An object that specifies a value for a time series property.</p>
    pub fn value(&self) -> std::option::Option<& crate::model::DataValue> {
        self.value.as_ref()
    }
    /// <p>ISO8601 DateTime of a value for a time series property.</p> 
    /// <p>The time for when the property value was recorded in ISO 8601 format: <i>YYYY-MM-DDThh:mm:ss[.SSSSSSSSS][Z/HH:mm]</i>.</p> 
    /// <ul> 
    /// <li> <p> <i>[YYYY]</i>: year</p> </li> 
    /// <li> <p> <i>[MM]</i>: month</p> </li> 
    /// <li> <p> <i>[DD]</i>: day</p> </li> 
    /// <li> <p> <i>[hh]</i>: hour</p> </li> 
    /// <li> <p> <i>[mm]</i>: minute</p> </li> 
    /// <li> <p> <i>[ss]</i>: seconds</p> </li> 
    /// <li> <p> <i>[.SSSSSSSSS]</i>: additional precision, where precedence is maintained. For example: [.573123] is equal to 573123000 nanoseconds.</p> </li> 
    /// <li> <p> <i>Z</i>: default timezone UTC</p> </li> 
    /// <li> <p> <i> HH:mm</i>: time zone offset in Hours and Minutes.</p> </li> 
    /// </ul> 
    /// <p> <i>Required sub-fields</i>: YYYY-MM-DDThh:mm:ss and [Z/HH:mm]</p>
    pub fn time(&self) -> std::option::Option<& str> {
        self.time.as_deref()
    }
}
/// See [`PropertyValue`](crate::model::PropertyValue).
pub mod property_value {
    
    /// A builder for [`PropertyValue`](crate::model::PropertyValue).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) value: std::option::Option<crate::model::DataValue>,
        pub(crate) time: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The timestamp of a value for a time series property.</p>
        #[deprecated(note = "This field is deprecated and will throw an error in the future. Use time instead.")]
        pub fn timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.timestamp = Some(input);
            self
        }
        /// <p>The timestamp of a value for a time series property.</p>
        #[deprecated(note = "This field is deprecated and will throw an error in the future. Use time instead.")]
        pub fn set_timestamp(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.timestamp = input; self
        }
        /// <p>An object that specifies a value for a time series property.</p>
        pub fn value(mut self, input: crate::model::DataValue) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>An object that specifies a value for a time series property.</p>
        pub fn set_value(mut self, input: std::option::Option<crate::model::DataValue>) -> Self {
            self.value = input; self
        }
        /// <p>ISO8601 DateTime of a value for a time series property.</p> 
        /// <p>The time for when the property value was recorded in ISO 8601 format: <i>YYYY-MM-DDThh:mm:ss[.SSSSSSSSS][Z/HH:mm]</i>.</p> 
        /// <ul> 
        /// <li> <p> <i>[YYYY]</i>: year</p> </li> 
        /// <li> <p> <i>[MM]</i>: month</p> </li> 
        /// <li> <p> <i>[DD]</i>: day</p> </li> 
        /// <li> <p> <i>[hh]</i>: hour</p> </li> 
        /// <li> <p> <i>[mm]</i>: minute</p> </li> 
        /// <li> <p> <i>[ss]</i>: seconds</p> </li> 
        /// <li> <p> <i>[.SSSSSSSSS]</i>: additional precision, where precedence is maintained. For example: [.573123] is equal to 573123000 nanoseconds.</p> </li> 
        /// <li> <p> <i>Z</i>: default timezone UTC</p> </li> 
        /// <li> <p> <i> HH:mm</i>: time zone offset in Hours and Minutes.</p> </li> 
        /// </ul> 
        /// <p> <i>Required sub-fields</i>: YYYY-MM-DDThh:mm:ss and [Z/HH:mm]</p>
        pub fn time(mut self, input: impl Into<std::string::String>) -> Self {
            self.time = Some(input.into());
            self
        }
        /// <p>ISO8601 DateTime of a value for a time series property.</p> 
        /// <p>The time for when the property value was recorded in ISO 8601 format: <i>YYYY-MM-DDThh:mm:ss[.SSSSSSSSS][Z/HH:mm]</i>.</p> 
        /// <ul> 
        /// <li> <p> <i>[YYYY]</i>: year</p> </li> 
        /// <li> <p> <i>[MM]</i>: month</p> </li> 
        /// <li> <p> <i>[DD]</i>: day</p> </li> 
        /// <li> <p> <i>[hh]</i>: hour</p> </li> 
        /// <li> <p> <i>[mm]</i>: minute</p> </li> 
        /// <li> <p> <i>[ss]</i>: seconds</p> </li> 
        /// <li> <p> <i>[.SSSSSSSSS]</i>: additional precision, where precedence is maintained. For example: [.573123] is equal to 573123000 nanoseconds.</p> </li> 
        /// <li> <p> <i>Z</i>: default timezone UTC</p> </li> 
        /// <li> <p> <i> HH:mm</i>: time zone offset in Hours and Minutes.</p> </li> 
        /// </ul> 
        /// <p> <i>Required sub-fields</i>: YYYY-MM-DDThh:mm:ss and [Z/HH:mm]</p>
        pub fn set_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.time = input; self
        }
        /// Consumes the builder and constructs a [`PropertyValue`](crate::model::PropertyValue).
        pub fn build(self) -> crate::model::PropertyValue {
            crate::model::PropertyValue {
                timestamp: self.timestamp
                ,
                value: self.value
                ,
                time: self.time
                ,
            }
        }
    }
    
    
}
impl PropertyValue {
    /// Creates a new builder-style object to manufacture [`PropertyValue`](crate::model::PropertyValue).
    pub fn builder() -> crate::model::property_value::Builder {
        crate::model::property_value::Builder::default()
    }
}

/// <p>An object that uniquely identifies an entity property.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EntityPropertyReference  {
    /// <p>The name of the component.</p>
    #[doc(hidden)]
    pub component_name: std::option::Option<std::string::String>,
    /// <p>A mapping of external IDs to property names. External IDs uniquely identify properties from external data stores.</p>
    #[doc(hidden)]
    pub external_id_property: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The ID of the entity.</p>
    #[doc(hidden)]
    pub entity_id: std::option::Option<std::string::String>,
    /// <p>The name of the property.</p>
    #[doc(hidden)]
    pub property_name: std::option::Option<std::string::String>,
}
impl EntityPropertyReference {
    /// <p>The name of the component.</p>
    pub fn component_name(&self) -> std::option::Option<& str> {
        self.component_name.as_deref()
    }
    /// <p>A mapping of external IDs to property names. External IDs uniquely identify properties from external data stores.</p>
    pub fn external_id_property(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.external_id_property.as_ref()
    }
    /// <p>The ID of the entity.</p>
    pub fn entity_id(&self) -> std::option::Option<& str> {
        self.entity_id.as_deref()
    }
    /// <p>The name of the property.</p>
    pub fn property_name(&self) -> std::option::Option<& str> {
        self.property_name.as_deref()
    }
}
/// See [`EntityPropertyReference`](crate::model::EntityPropertyReference).
pub mod entity_property_reference {
    
    /// A builder for [`EntityPropertyReference`](crate::model::EntityPropertyReference).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) component_name: std::option::Option<std::string::String>,
        pub(crate) external_id_property: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) entity_id: std::option::Option<std::string::String>,
        pub(crate) property_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the component.</p>
        pub fn component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_name = Some(input.into());
            self
        }
        /// <p>The name of the component.</p>
        pub fn set_component_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.component_name = input; self
        }
        /// Adds a key-value pair to `external_id_property`.
        ///
        /// To override the contents of this collection use [`set_external_id_property`](Self::set_external_id_property).
        ///
        /// <p>A mapping of external IDs to property names. External IDs uniquely identify properties from external data stores.</p>
        pub fn external_id_property(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.external_id_property.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.external_id_property = Some(hash_map);
                            self
        }
        /// <p>A mapping of external IDs to property names. External IDs uniquely identify properties from external data stores.</p>
        pub fn set_external_id_property(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.external_id_property = input; self
        }
        /// <p>The ID of the entity.</p>
        pub fn entity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entity_id = Some(input.into());
            self
        }
        /// <p>The ID of the entity.</p>
        pub fn set_entity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entity_id = input; self
        }
        /// <p>The name of the property.</p>
        pub fn property_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_name = Some(input.into());
            self
        }
        /// <p>The name of the property.</p>
        pub fn set_property_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property_name = input; self
        }
        /// Consumes the builder and constructs a [`EntityPropertyReference`](crate::model::EntityPropertyReference).
        pub fn build(self) -> crate::model::EntityPropertyReference {
            crate::model::EntityPropertyReference {
                component_name: self.component_name
                ,
                external_id_property: self.external_id_property
                ,
                entity_id: self.entity_id
                ,
                property_name: self.property_name
                ,
            }
        }
    }
    
    
}
impl EntityPropertyReference {
    /// Creates a new builder-style object to manufacture [`EntityPropertyReference`](crate::model::EntityPropertyReference).
    pub fn builder() -> crate::model::entity_property_reference::Builder {
        crate::model::entity_property_reference::Builder::default()
    }
}

/// When writing a match expression against `OrderByTime`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let orderbytime = unimplemented!();
/// match orderbytime {
///     OrderByTime::Ascending => { /* ... */ },
///     OrderByTime::Descending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `orderbytime` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OrderByTime::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OrderByTime::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OrderByTime::NewFeature` is defined.
/// Specifically, when `orderbytime` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OrderByTime::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum OrderByTime {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for OrderByTime {
    fn from(s: &str) -> Self {
        match s {
            "ASCENDING" => OrderByTime::Ascending,
            "DESCENDING" => OrderByTime::Descending,
            other => OrderByTime::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for OrderByTime {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(OrderByTime::from(s))
                }
            }
impl OrderByTime {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OrderByTime::Ascending => "ASCENDING",
            OrderByTime::Descending => "DESCENDING",
            OrderByTime::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ASCENDING", "DESCENDING"
        ]
    }
}
impl AsRef<str> for OrderByTime {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that specifies how to interpolate data in a list.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InterpolationParameters  {
    /// <p>The interpolation type.</p>
    #[doc(hidden)]
    pub interpolation_type: std::option::Option<crate::model::InterpolationType>,
    /// <p>The interpolation time interval in seconds.</p>
    #[doc(hidden)]
    pub interval_in_seconds: std::option::Option<i64>,
}
impl InterpolationParameters {
    /// <p>The interpolation type.</p>
    pub fn interpolation_type(&self) -> std::option::Option<& crate::model::InterpolationType> {
        self.interpolation_type.as_ref()
    }
    /// <p>The interpolation time interval in seconds.</p>
    pub fn interval_in_seconds(&self) -> std::option::Option<i64> {
        self.interval_in_seconds
    }
}
/// See [`InterpolationParameters`](crate::model::InterpolationParameters).
pub mod interpolation_parameters {
    
    /// A builder for [`InterpolationParameters`](crate::model::InterpolationParameters).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) interpolation_type: std::option::Option<crate::model::InterpolationType>,
        pub(crate) interval_in_seconds: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The interpolation type.</p>
        pub fn interpolation_type(mut self, input: crate::model::InterpolationType) -> Self {
            self.interpolation_type = Some(input);
            self
        }
        /// <p>The interpolation type.</p>
        pub fn set_interpolation_type(mut self, input: std::option::Option<crate::model::InterpolationType>) -> Self {
            self.interpolation_type = input; self
        }
        /// <p>The interpolation time interval in seconds.</p>
        pub fn interval_in_seconds(mut self, input: i64) -> Self {
            self.interval_in_seconds = Some(input);
            self
        }
        /// <p>The interpolation time interval in seconds.</p>
        pub fn set_interval_in_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.interval_in_seconds = input; self
        }
        /// Consumes the builder and constructs a [`InterpolationParameters`](crate::model::InterpolationParameters).
        pub fn build(self) -> crate::model::InterpolationParameters {
            crate::model::InterpolationParameters {
                interpolation_type: self.interpolation_type
                ,
                interval_in_seconds: self.interval_in_seconds
                ,
            }
        }
    }
    
    
}
impl InterpolationParameters {
    /// Creates a new builder-style object to manufacture [`InterpolationParameters`](crate::model::InterpolationParameters).
    pub fn builder() -> crate::model::interpolation_parameters::Builder {
        crate::model::interpolation_parameters::Builder::default()
    }
}

/// When writing a match expression against `InterpolationType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let interpolationtype = unimplemented!();
/// match interpolationtype {
///     InterpolationType::Linear => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `interpolationtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `InterpolationType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `InterpolationType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `InterpolationType::NewFeature` is defined.
/// Specifically, when `interpolationtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `InterpolationType::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum InterpolationType {
    #[allow(missing_docs)] // documentation missing in model
    Linear,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for InterpolationType {
    fn from(s: &str) -> Self {
        match s {
            "LINEAR" => InterpolationType::Linear,
            other => InterpolationType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for InterpolationType {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(InterpolationType::from(s))
                }
            }
impl InterpolationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InterpolationType::Linear => "LINEAR",
            InterpolationType::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "LINEAR"
        ]
    }
}
impl AsRef<str> for InterpolationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that filters items returned by a property request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyFilter  {
    /// <p>The property name associated with this property filter.</p>
    #[doc(hidden)]
    pub property_name: std::option::Option<std::string::String>,
    /// <p>The operator associated with this property filter.</p>
    #[doc(hidden)]
    pub operator: std::option::Option<std::string::String>,
    /// <p>The value associated with this property filter.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::DataValue>,
}
impl PropertyFilter {
    /// <p>The property name associated with this property filter.</p>
    pub fn property_name(&self) -> std::option::Option<& str> {
        self.property_name.as_deref()
    }
    /// <p>The operator associated with this property filter.</p>
    pub fn operator(&self) -> std::option::Option<& str> {
        self.operator.as_deref()
    }
    /// <p>The value associated with this property filter.</p>
    pub fn value(&self) -> std::option::Option<& crate::model::DataValue> {
        self.value.as_ref()
    }
}
/// See [`PropertyFilter`](crate::model::PropertyFilter).
pub mod property_filter {
    
    /// A builder for [`PropertyFilter`](crate::model::PropertyFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) property_name: std::option::Option<std::string::String>,
        pub(crate) operator: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<crate::model::DataValue>,
    }
    impl Builder {
        /// <p>The property name associated with this property filter.</p>
        pub fn property_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_name = Some(input.into());
            self
        }
        /// <p>The property name associated with this property filter.</p>
        pub fn set_property_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property_name = input; self
        }
        /// <p>The operator associated with this property filter.</p>
        pub fn operator(mut self, input: impl Into<std::string::String>) -> Self {
            self.operator = Some(input.into());
            self
        }
        /// <p>The operator associated with this property filter.</p>
        pub fn set_operator(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.operator = input; self
        }
        /// <p>The value associated with this property filter.</p>
        pub fn value(mut self, input: crate::model::DataValue) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value associated with this property filter.</p>
        pub fn set_value(mut self, input: std::option::Option<crate::model::DataValue>) -> Self {
            self.value = input; self
        }
        /// Consumes the builder and constructs a [`PropertyFilter`](crate::model::PropertyFilter).
        pub fn build(self) -> crate::model::PropertyFilter {
            crate::model::PropertyFilter {
                property_name: self.property_name
                ,
                operator: self.operator
                ,
                value: self.value
                ,
            }
        }
    }
    
    
}
impl PropertyFilter {
    /// Creates a new builder-style object to manufacture [`PropertyFilter`](crate::model::PropertyFilter).
    pub fn builder() -> crate::model::property_filter::Builder {
        crate::model::property_filter::Builder::default()
    }
}

/// <p>The latest value of the property.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyLatestValue  {
    /// <p>An object that specifies information about a property.&gt;</p>
    #[doc(hidden)]
    pub property_reference: std::option::Option<crate::model::EntityPropertyReference>,
    /// <p>The value of the property.</p>
    #[doc(hidden)]
    pub property_value: std::option::Option<crate::model::DataValue>,
}
impl PropertyLatestValue {
    /// <p>An object that specifies information about a property.&gt;</p>
    pub fn property_reference(&self) -> std::option::Option<& crate::model::EntityPropertyReference> {
        self.property_reference.as_ref()
    }
    /// <p>The value of the property.</p>
    pub fn property_value(&self) -> std::option::Option<& crate::model::DataValue> {
        self.property_value.as_ref()
    }
}
/// See [`PropertyLatestValue`](crate::model::PropertyLatestValue).
pub mod property_latest_value {
    
    /// A builder for [`PropertyLatestValue`](crate::model::PropertyLatestValue).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) property_reference: std::option::Option<crate::model::EntityPropertyReference>,
        pub(crate) property_value: std::option::Option<crate::model::DataValue>,
    }
    impl Builder {
        /// <p>An object that specifies information about a property.&gt;</p>
        pub fn property_reference(mut self, input: crate::model::EntityPropertyReference) -> Self {
            self.property_reference = Some(input);
            self
        }
        /// <p>An object that specifies information about a property.&gt;</p>
        pub fn set_property_reference(mut self, input: std::option::Option<crate::model::EntityPropertyReference>) -> Self {
            self.property_reference = input; self
        }
        /// <p>The value of the property.</p>
        pub fn property_value(mut self, input: crate::model::DataValue) -> Self {
            self.property_value = Some(input);
            self
        }
        /// <p>The value of the property.</p>
        pub fn set_property_value(mut self, input: std::option::Option<crate::model::DataValue>) -> Self {
            self.property_value = input; self
        }
        /// Consumes the builder and constructs a [`PropertyLatestValue`](crate::model::PropertyLatestValue).
        pub fn build(self) -> crate::model::PropertyLatestValue {
            crate::model::PropertyLatestValue {
                property_reference: self.property_reference
                ,
                property_value: self.property_value
                ,
            }
        }
    }
    
    
}
impl PropertyLatestValue {
    /// Creates a new builder-style object to manufacture [`PropertyLatestValue`](crate::model::PropertyLatestValue).
    pub fn builder() -> crate::model::property_latest_value::Builder {
        crate::model::property_latest_value::Builder::default()
    }
}

/// <p>The tabular conditions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TabularConditions  {
    /// <p>Filter criteria that orders the output. It can be sorted in ascending or descending order.</p>
    #[doc(hidden)]
    pub order_by: std::option::Option<std::vec::Vec<crate::model::OrderBy>>,
    /// <p>You can filter the request using various logical operators and a key-value format. For example:</p> 
    /// <p> <code>{"key": "serverType", "value": "webServer"}</code> </p>
    #[doc(hidden)]
    pub property_filters: std::option::Option<std::vec::Vec<crate::model::PropertyFilter>>,
}
impl TabularConditions {
    /// <p>Filter criteria that orders the output. It can be sorted in ascending or descending order.</p>
    pub fn order_by(&self) -> std::option::Option<& [crate::model::OrderBy]> {
        self.order_by.as_deref()
    }
    /// <p>You can filter the request using various logical operators and a key-value format. For example:</p> 
    /// <p> <code>{"key": "serverType", "value": "webServer"}</code> </p>
    pub fn property_filters(&self) -> std::option::Option<& [crate::model::PropertyFilter]> {
        self.property_filters.as_deref()
    }
}
/// See [`TabularConditions`](crate::model::TabularConditions).
pub mod tabular_conditions {
    
    /// A builder for [`TabularConditions`](crate::model::TabularConditions).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) order_by: std::option::Option<std::vec::Vec<crate::model::OrderBy>>,
        pub(crate) property_filters: std::option::Option<std::vec::Vec<crate::model::PropertyFilter>>,
    }
    impl Builder {
        /// Appends an item to `order_by`.
        ///
        /// To override the contents of this collection use [`set_order_by`](Self::set_order_by).
        ///
        /// <p>Filter criteria that orders the output. It can be sorted in ascending or descending order.</p>
        pub fn order_by(mut self, input: crate::model::OrderBy) -> Self {
            let mut v = self.order_by.unwrap_or_default();
                            v.push(input);
                            self.order_by = Some(v);
                            self
        }
        /// <p>Filter criteria that orders the output. It can be sorted in ascending or descending order.</p>
        pub fn set_order_by(mut self, input: std::option::Option<std::vec::Vec<crate::model::OrderBy>>) -> Self {
            self.order_by = input; self
        }
        /// Appends an item to `property_filters`.
        ///
        /// To override the contents of this collection use [`set_property_filters`](Self::set_property_filters).
        ///
        /// <p>You can filter the request using various logical operators and a key-value format. For example:</p> 
        /// <p> <code>{"key": "serverType", "value": "webServer"}</code> </p>
        pub fn property_filters(mut self, input: crate::model::PropertyFilter) -> Self {
            let mut v = self.property_filters.unwrap_or_default();
                            v.push(input);
                            self.property_filters = Some(v);
                            self
        }
        /// <p>You can filter the request using various logical operators and a key-value format. For example:</p> 
        /// <p> <code>{"key": "serverType", "value": "webServer"}</code> </p>
        pub fn set_property_filters(mut self, input: std::option::Option<std::vec::Vec<crate::model::PropertyFilter>>) -> Self {
            self.property_filters = input; self
        }
        /// Consumes the builder and constructs a [`TabularConditions`](crate::model::TabularConditions).
        pub fn build(self) -> crate::model::TabularConditions {
            crate::model::TabularConditions {
                order_by: self.order_by
                ,
                property_filters: self.property_filters
                ,
            }
        }
    }
    
    
}
impl TabularConditions {
    /// Creates a new builder-style object to manufacture [`TabularConditions`](crate::model::TabularConditions).
    pub fn builder() -> crate::model::tabular_conditions::Builder {
        crate::model::tabular_conditions::Builder::default()
    }
}

/// <p>Filter criteria that orders the return output. It can be sorted in ascending or descending order.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OrderBy  {
    /// <p>The set order that filters results.</p>
    #[doc(hidden)]
    pub order: std::option::Option<crate::model::Order>,
    /// <p>The property name.</p>
    #[doc(hidden)]
    pub property_name: std::option::Option<std::string::String>,
}
impl OrderBy {
    /// <p>The set order that filters results.</p>
    pub fn order(&self) -> std::option::Option<& crate::model::Order> {
        self.order.as_ref()
    }
    /// <p>The property name.</p>
    pub fn property_name(&self) -> std::option::Option<& str> {
        self.property_name.as_deref()
    }
}
/// See [`OrderBy`](crate::model::OrderBy).
pub mod order_by {
    
    /// A builder for [`OrderBy`](crate::model::OrderBy).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) order: std::option::Option<crate::model::Order>,
        pub(crate) property_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The set order that filters results.</p>
        pub fn order(mut self, input: crate::model::Order) -> Self {
            self.order = Some(input);
            self
        }
        /// <p>The set order that filters results.</p>
        pub fn set_order(mut self, input: std::option::Option<crate::model::Order>) -> Self {
            self.order = input; self
        }
        /// <p>The property name.</p>
        pub fn property_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_name = Some(input.into());
            self
        }
        /// <p>The property name.</p>
        pub fn set_property_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.property_name = input; self
        }
        /// Consumes the builder and constructs a [`OrderBy`](crate::model::OrderBy).
        pub fn build(self) -> crate::model::OrderBy {
            crate::model::OrderBy {
                order: self.order
                ,
                property_name: self.property_name
                ,
            }
        }
    }
    
    
}
impl OrderBy {
    /// Creates a new builder-style object to manufacture [`OrderBy`](crate::model::OrderBy).
    pub fn builder() -> crate::model::order_by::Builder {
        crate::model::order_by::Builder::default()
    }
}

/// When writing a match expression against `Order`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let order = unimplemented!();
/// match order {
///     Order::Ascending => { /* ... */ },
///     Order::Descending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `order` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Order::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Order::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Order::NewFeature` is defined.
/// Specifically, when `order` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Order::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum Order {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for Order {
    fn from(s: &str) -> Self {
        match s {
            "ASCENDING" => Order::Ascending,
            "DESCENDING" => Order::Descending,
            other => Order::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for Order {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(Order::from(s))
                }
            }
impl Order {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Order::Ascending => "ASCENDING",
            Order::Descending => "DESCENDING",
            Order::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ASCENDING", "DESCENDING"
        ]
    }
}
impl AsRef<str> for Order {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that returns information about a component type create or update request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComponentResponse  {
    /// <p>The name of the component.</p>
    #[doc(hidden)]
    pub component_name: std::option::Option<std::string::String>,
    /// <p>The description of the component type.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The ID of the component type.</p>
    #[doc(hidden)]
    pub component_type_id: std::option::Option<std::string::String>,
    /// <p>The status of the component type.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::Status>,
    /// <p>The name of the property definition set in the request.</p>
    #[doc(hidden)]
    pub defined_in: std::option::Option<std::string::String>,
    /// <p>An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.</p>
    #[doc(hidden)]
    pub properties: std::option::Option<std::collections::HashMap<std::string::String, crate::model::PropertyResponse>>,
    /// <p>The property groups.</p>
    #[doc(hidden)]
    pub property_groups: std::option::Option<std::collections::HashMap<std::string::String, crate::model::ComponentPropertyGroupResponse>>,
    /// <p>The syncSource of the sync job, if this entity was created by a sync job.</p>
    #[doc(hidden)]
    pub sync_source: std::option::Option<std::string::String>,
}
impl ComponentResponse {
    /// <p>The name of the component.</p>
    pub fn component_name(&self) -> std::option::Option<& str> {
        self.component_name.as_deref()
    }
    /// <p>The description of the component type.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>The ID of the component type.</p>
    pub fn component_type_id(&self) -> std::option::Option<& str> {
        self.component_type_id.as_deref()
    }
    /// <p>The status of the component type.</p>
    pub fn status(&self) -> std::option::Option<& crate::model::Status> {
        self.status.as_ref()
    }
    /// <p>The name of the property definition set in the request.</p>
    pub fn defined_in(&self) -> std::option::Option<& str> {
        self.defined_in.as_deref()
    }
    /// <p>An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.</p>
    pub fn properties(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, crate::model::PropertyResponse>> {
        self.properties.as_ref()
    }
    /// <p>The property groups.</p>
    pub fn property_groups(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, crate::model::ComponentPropertyGroupResponse>> {
        self.property_groups.as_ref()
    }
    /// <p>The syncSource of the sync job, if this entity was created by a sync job.</p>
    pub fn sync_source(&self) -> std::option::Option<& str> {
        self.sync_source.as_deref()
    }
}
/// See [`ComponentResponse`](crate::model::ComponentResponse).
pub mod component_response {
    
    /// A builder for [`ComponentResponse`](crate::model::ComponentResponse).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) component_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) component_type_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::Status>,
        pub(crate) defined_in: std::option::Option<std::string::String>,
        pub(crate) properties: std::option::Option<std::collections::HashMap<std::string::String, crate::model::PropertyResponse>>,
        pub(crate) property_groups: std::option::Option<std::collections::HashMap<std::string::String, crate::model::ComponentPropertyGroupResponse>>,
        pub(crate) sync_source: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the component.</p>
        pub fn component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_name = Some(input.into());
            self
        }
        /// <p>The name of the component.</p>
        pub fn set_component_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.component_name = input; self
        }
        /// <p>The description of the component type.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the component type.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>The ID of the component type.</p>
        pub fn component_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_type_id = Some(input.into());
            self
        }
        /// <p>The ID of the component type.</p>
        pub fn set_component_type_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.component_type_id = input; self
        }
        /// <p>The status of the component type.</p>
        pub fn status(mut self, input: crate::model::Status) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the component type.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::Status>) -> Self {
            self.status = input; self
        }
        /// <p>The name of the property definition set in the request.</p>
        pub fn defined_in(mut self, input: impl Into<std::string::String>) -> Self {
            self.defined_in = Some(input.into());
            self
        }
        /// <p>The name of the property definition set in the request.</p>
        pub fn set_defined_in(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.defined_in = input; self
        }
        /// Adds a key-value pair to `properties`.
        ///
        /// To override the contents of this collection use [`set_properties`](Self::set_properties).
        ///
        /// <p>An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.</p>
        pub fn properties(mut self, k: impl Into<std::string::String>, v: crate::model::PropertyResponse) -> Self {
            let mut hash_map = self.properties.unwrap_or_default();
                            hash_map.insert(k.into(), v);
                            self.properties = Some(hash_map);
                            self
        }
        /// <p>An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.</p>
        pub fn set_properties(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, crate::model::PropertyResponse>>) -> Self {
            self.properties = input; self
        }
        /// Adds a key-value pair to `property_groups`.
        ///
        /// To override the contents of this collection use [`set_property_groups`](Self::set_property_groups).
        ///
        /// <p>The property groups.</p>
        pub fn property_groups(mut self, k: impl Into<std::string::String>, v: crate::model::ComponentPropertyGroupResponse) -> Self {
            let mut hash_map = self.property_groups.unwrap_or_default();
                            hash_map.insert(k.into(), v);
                            self.property_groups = Some(hash_map);
                            self
        }
        /// <p>The property groups.</p>
        pub fn set_property_groups(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, crate::model::ComponentPropertyGroupResponse>>) -> Self {
            self.property_groups = input; self
        }
        /// <p>The syncSource of the sync job, if this entity was created by a sync job.</p>
        pub fn sync_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.sync_source = Some(input.into());
            self
        }
        /// <p>The syncSource of the sync job, if this entity was created by a sync job.</p>
        pub fn set_sync_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sync_source = input; self
        }
        /// Consumes the builder and constructs a [`ComponentResponse`](crate::model::ComponentResponse).
        pub fn build(self) -> crate::model::ComponentResponse {
            crate::model::ComponentResponse {
                component_name: self.component_name
                ,
                description: self.description
                ,
                component_type_id: self.component_type_id
                ,
                status: self.status
                ,
                defined_in: self.defined_in
                ,
                properties: self.properties
                ,
                property_groups: self.property_groups
                ,
                sync_source: self.sync_source
                ,
            }
        }
    }
    
    
}
impl ComponentResponse {
    /// Creates a new builder-style object to manufacture [`ComponentResponse`](crate::model::ComponentResponse).
    pub fn builder() -> crate::model::component_response::Builder {
        crate::model::component_response::Builder::default()
    }
}

/// <p>The component property group response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComponentPropertyGroupResponse  {
    /// <p>The group type.</p>
    #[doc(hidden)]
    pub group_type: std::option::Option<crate::model::GroupType>,
    /// <p>The names of properties</p>
    #[doc(hidden)]
    pub property_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A Boolean value that specifies whether the property group is inherited from a parent entity</p>
    #[doc(hidden)]
    pub is_inherited: std::option::Option<bool>,
}
impl ComponentPropertyGroupResponse {
    /// <p>The group type.</p>
    pub fn group_type(&self) -> std::option::Option<& crate::model::GroupType> {
        self.group_type.as_ref()
    }
    /// <p>The names of properties</p>
    pub fn property_names(&self) -> std::option::Option<& [std::string::String]> {
        self.property_names.as_deref()
    }
    /// <p>A Boolean value that specifies whether the property group is inherited from a parent entity</p>
    pub fn is_inherited(&self) -> std::option::Option<bool> {
        self.is_inherited
    }
}
/// See [`ComponentPropertyGroupResponse`](crate::model::ComponentPropertyGroupResponse).
pub mod component_property_group_response {
    
    /// A builder for [`ComponentPropertyGroupResponse`](crate::model::ComponentPropertyGroupResponse).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_type: std::option::Option<crate::model::GroupType>,
        pub(crate) property_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) is_inherited: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The group type.</p>
        pub fn group_type(mut self, input: crate::model::GroupType) -> Self {
            self.group_type = Some(input);
            self
        }
        /// <p>The group type.</p>
        pub fn set_group_type(mut self, input: std::option::Option<crate::model::GroupType>) -> Self {
            self.group_type = input; self
        }
        /// Appends an item to `property_names`.
        ///
        /// To override the contents of this collection use [`set_property_names`](Self::set_property_names).
        ///
        /// <p>The names of properties</p>
        pub fn property_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.property_names.unwrap_or_default();
                            v.push(input.into());
                            self.property_names = Some(v);
                            self
        }
        /// <p>The names of properties</p>
        pub fn set_property_names(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.property_names = input; self
        }
        /// <p>A Boolean value that specifies whether the property group is inherited from a parent entity</p>
        pub fn is_inherited(mut self, input: bool) -> Self {
            self.is_inherited = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property group is inherited from a parent entity</p>
        pub fn set_is_inherited(mut self, input: std::option::Option<bool>) -> Self {
            self.is_inherited = input; self
        }
        /// Consumes the builder and constructs a [`ComponentPropertyGroupResponse`](crate::model::ComponentPropertyGroupResponse).
        pub fn build(self) -> crate::model::ComponentPropertyGroupResponse {
            crate::model::ComponentPropertyGroupResponse {
                group_type: self.group_type
                ,
                property_names: self.property_names
                ,
                is_inherited: self.is_inherited
                ,
            }
        }
    }
    
    
}
impl ComponentPropertyGroupResponse {
    /// Creates a new builder-style object to manufacture [`ComponentPropertyGroupResponse`](crate::model::ComponentPropertyGroupResponse).
    pub fn builder() -> crate::model::component_property_group_response::Builder {
        crate::model::component_property_group_response::Builder::default()
    }
}

/// <p>An object that contains information about a property response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyResponse  {
    /// <p>An object that specifies information about a property.</p>
    #[doc(hidden)]
    pub definition: std::option::Option<crate::model::PropertyDefinitionResponse>,
    /// <p>The value of the property.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::DataValue>,
}
impl PropertyResponse {
    /// <p>An object that specifies information about a property.</p>
    pub fn definition(&self) -> std::option::Option<& crate::model::PropertyDefinitionResponse> {
        self.definition.as_ref()
    }
    /// <p>The value of the property.</p>
    pub fn value(&self) -> std::option::Option<& crate::model::DataValue> {
        self.value.as_ref()
    }
}
/// See [`PropertyResponse`](crate::model::PropertyResponse).
pub mod property_response {
    
    /// A builder for [`PropertyResponse`](crate::model::PropertyResponse).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) definition: std::option::Option<crate::model::PropertyDefinitionResponse>,
        pub(crate) value: std::option::Option<crate::model::DataValue>,
    }
    impl Builder {
        /// <p>An object that specifies information about a property.</p>
        pub fn definition(mut self, input: crate::model::PropertyDefinitionResponse) -> Self {
            self.definition = Some(input);
            self
        }
        /// <p>An object that specifies information about a property.</p>
        pub fn set_definition(mut self, input: std::option::Option<crate::model::PropertyDefinitionResponse>) -> Self {
            self.definition = input; self
        }
        /// <p>The value of the property.</p>
        pub fn value(mut self, input: crate::model::DataValue) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the property.</p>
        pub fn set_value(mut self, input: std::option::Option<crate::model::DataValue>) -> Self {
            self.value = input; self
        }
        /// Consumes the builder and constructs a [`PropertyResponse`](crate::model::PropertyResponse).
        pub fn build(self) -> crate::model::PropertyResponse {
            crate::model::PropertyResponse {
                definition: self.definition
                ,
                value: self.value
                ,
            }
        }
    }
    
    
}
impl PropertyResponse {
    /// Creates a new builder-style object to manufacture [`PropertyResponse`](crate::model::PropertyResponse).
    pub fn builder() -> crate::model::property_response::Builder {
        crate::model::property_response::Builder::default()
    }
}

/// <p>An object that contains response data from a property definition request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyDefinitionResponse  {
    /// <p>An object that contains information about the data type.</p>
    #[doc(hidden)]
    pub data_type: std::option::Option<crate::model::DataType>,
    /// <p>A Boolean value that specifies whether the property consists of time series data.</p>
    #[doc(hidden)]
    pub is_time_series: std::option::Option<bool>,
    /// <p>A Boolean value that specifies whether the property is required in an entity.</p>
    #[doc(hidden)]
    pub is_required_in_entity: std::option::Option<bool>,
    /// <p>A Boolean value that specifies whether the property ID comes from an external data store.</p>
    #[doc(hidden)]
    pub is_external_id: std::option::Option<bool>,
    /// <p>A Boolean value that specifies whether the property is stored externally.</p>
    #[doc(hidden)]
    pub is_stored_externally: std::option::Option<bool>,
    /// <p>A Boolean value that specifies whether the property definition is imported from an external data store.</p>
    #[doc(hidden)]
    pub is_imported: std::option::Option<bool>,
    /// <p>A Boolean value that specifies whether the property definition can be updated.</p>
    #[doc(hidden)]
    pub is_final: std::option::Option<bool>,
    /// <p>A Boolean value that specifies whether the property definition is inherited from a parent entity.</p>
    #[doc(hidden)]
    pub is_inherited: std::option::Option<bool>,
    /// <p>An object that contains the default value.</p>
    #[doc(hidden)]
    pub default_value: std::option::Option<crate::model::DataValue>,
    /// <p>A mapping that specifies configuration information about the property.</p>
    #[doc(hidden)]
    pub configuration: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A friendly name for the property.</p>
    #[doc(hidden)]
    pub display_name: std::option::Option<std::string::String>,
}
impl PropertyDefinitionResponse {
    /// <p>An object that contains information about the data type.</p>
    pub fn data_type(&self) -> std::option::Option<& crate::model::DataType> {
        self.data_type.as_ref()
    }
    /// <p>A Boolean value that specifies whether the property consists of time series data.</p>
    pub fn is_time_series(&self) -> std::option::Option<bool> {
        self.is_time_series
    }
    /// <p>A Boolean value that specifies whether the property is required in an entity.</p>
    pub fn is_required_in_entity(&self) -> std::option::Option<bool> {
        self.is_required_in_entity
    }
    /// <p>A Boolean value that specifies whether the property ID comes from an external data store.</p>
    pub fn is_external_id(&self) -> std::option::Option<bool> {
        self.is_external_id
    }
    /// <p>A Boolean value that specifies whether the property is stored externally.</p>
    pub fn is_stored_externally(&self) -> std::option::Option<bool> {
        self.is_stored_externally
    }
    /// <p>A Boolean value that specifies whether the property definition is imported from an external data store.</p>
    pub fn is_imported(&self) -> std::option::Option<bool> {
        self.is_imported
    }
    /// <p>A Boolean value that specifies whether the property definition can be updated.</p>
    pub fn is_final(&self) -> std::option::Option<bool> {
        self.is_final
    }
    /// <p>A Boolean value that specifies whether the property definition is inherited from a parent entity.</p>
    pub fn is_inherited(&self) -> std::option::Option<bool> {
        self.is_inherited
    }
    /// <p>An object that contains the default value.</p>
    pub fn default_value(&self) -> std::option::Option<& crate::model::DataValue> {
        self.default_value.as_ref()
    }
    /// <p>A mapping that specifies configuration information about the property.</p>
    pub fn configuration(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.configuration.as_ref()
    }
    /// <p>A friendly name for the property.</p>
    pub fn display_name(&self) -> std::option::Option<& str> {
        self.display_name.as_deref()
    }
}
/// See [`PropertyDefinitionResponse`](crate::model::PropertyDefinitionResponse).
pub mod property_definition_response {
    
    /// A builder for [`PropertyDefinitionResponse`](crate::model::PropertyDefinitionResponse).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_type: std::option::Option<crate::model::DataType>,
        pub(crate) is_time_series: std::option::Option<bool>,
        pub(crate) is_required_in_entity: std::option::Option<bool>,
        pub(crate) is_external_id: std::option::Option<bool>,
        pub(crate) is_stored_externally: std::option::Option<bool>,
        pub(crate) is_imported: std::option::Option<bool>,
        pub(crate) is_final: std::option::Option<bool>,
        pub(crate) is_inherited: std::option::Option<bool>,
        pub(crate) default_value: std::option::Option<crate::model::DataValue>,
        pub(crate) configuration: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) display_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An object that contains information about the data type.</p>
        pub fn data_type(mut self, input: crate::model::DataType) -> Self {
            self.data_type = Some(input);
            self
        }
        /// <p>An object that contains information about the data type.</p>
        pub fn set_data_type(mut self, input: std::option::Option<crate::model::DataType>) -> Self {
            self.data_type = input; self
        }
        /// <p>A Boolean value that specifies whether the property consists of time series data.</p>
        pub fn is_time_series(mut self, input: bool) -> Self {
            self.is_time_series = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property consists of time series data.</p>
        pub fn set_is_time_series(mut self, input: std::option::Option<bool>) -> Self {
            self.is_time_series = input; self
        }
        /// <p>A Boolean value that specifies whether the property is required in an entity.</p>
        pub fn is_required_in_entity(mut self, input: bool) -> Self {
            self.is_required_in_entity = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property is required in an entity.</p>
        pub fn set_is_required_in_entity(mut self, input: std::option::Option<bool>) -> Self {
            self.is_required_in_entity = input; self
        }
        /// <p>A Boolean value that specifies whether the property ID comes from an external data store.</p>
        pub fn is_external_id(mut self, input: bool) -> Self {
            self.is_external_id = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property ID comes from an external data store.</p>
        pub fn set_is_external_id(mut self, input: std::option::Option<bool>) -> Self {
            self.is_external_id = input; self
        }
        /// <p>A Boolean value that specifies whether the property is stored externally.</p>
        pub fn is_stored_externally(mut self, input: bool) -> Self {
            self.is_stored_externally = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property is stored externally.</p>
        pub fn set_is_stored_externally(mut self, input: std::option::Option<bool>) -> Self {
            self.is_stored_externally = input; self
        }
        /// <p>A Boolean value that specifies whether the property definition is imported from an external data store.</p>
        pub fn is_imported(mut self, input: bool) -> Self {
            self.is_imported = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property definition is imported from an external data store.</p>
        pub fn set_is_imported(mut self, input: std::option::Option<bool>) -> Self {
            self.is_imported = input; self
        }
        /// <p>A Boolean value that specifies whether the property definition can be updated.</p>
        pub fn is_final(mut self, input: bool) -> Self {
            self.is_final = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property definition can be updated.</p>
        pub fn set_is_final(mut self, input: std::option::Option<bool>) -> Self {
            self.is_final = input; self
        }
        /// <p>A Boolean value that specifies whether the property definition is inherited from a parent entity.</p>
        pub fn is_inherited(mut self, input: bool) -> Self {
            self.is_inherited = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property definition is inherited from a parent entity.</p>
        pub fn set_is_inherited(mut self, input: std::option::Option<bool>) -> Self {
            self.is_inherited = input; self
        }
        /// <p>An object that contains the default value.</p>
        pub fn default_value(mut self, input: crate::model::DataValue) -> Self {
            self.default_value = Some(input);
            self
        }
        /// <p>An object that contains the default value.</p>
        pub fn set_default_value(mut self, input: std::option::Option<crate::model::DataValue>) -> Self {
            self.default_value = input; self
        }
        /// Adds a key-value pair to `configuration`.
        ///
        /// To override the contents of this collection use [`set_configuration`](Self::set_configuration).
        ///
        /// <p>A mapping that specifies configuration information about the property.</p>
        pub fn configuration(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.configuration.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.configuration = Some(hash_map);
                            self
        }
        /// <p>A mapping that specifies configuration information about the property.</p>
        pub fn set_configuration(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.configuration = input; self
        }
        /// <p>A friendly name for the property.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>A friendly name for the property.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input; self
        }
        /// Consumes the builder and constructs a [`PropertyDefinitionResponse`](crate::model::PropertyDefinitionResponse).
        pub fn build(self) -> crate::model::PropertyDefinitionResponse {
            crate::model::PropertyDefinitionResponse {
                data_type: self.data_type
                ,
                is_time_series: self.is_time_series
                ,
                is_required_in_entity: self.is_required_in_entity
                ,
                is_external_id: self.is_external_id
                ,
                is_stored_externally: self.is_stored_externally
                ,
                is_imported: self.is_imported
                ,
                is_final: self.is_final
                ,
                is_inherited: self.is_inherited
                ,
                default_value: self.default_value
                ,
                configuration: self.configuration
                ,
                display_name: self.display_name
                ,
            }
        }
    }
    
    
}
impl PropertyDefinitionResponse {
    /// Creates a new builder-style object to manufacture [`PropertyDefinitionResponse`](crate::model::PropertyDefinitionResponse).
    pub fn builder() -> crate::model::property_definition_response::Builder {
        crate::model::property_definition_response::Builder::default()
    }
}

/// <p>The property group response</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyGroupResponse  {
    /// <p>The group types.</p>
    #[doc(hidden)]
    pub group_type: std::option::Option<crate::model::GroupType>,
    /// <p>The names of properties.</p>
    #[doc(hidden)]
    pub property_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A Boolean value that specifies whether the property group is inherited from a parent entity</p>
    #[doc(hidden)]
    pub is_inherited: std::option::Option<bool>,
}
impl PropertyGroupResponse {
    /// <p>The group types.</p>
    pub fn group_type(&self) -> std::option::Option<& crate::model::GroupType> {
        self.group_type.as_ref()
    }
    /// <p>The names of properties.</p>
    pub fn property_names(&self) -> std::option::Option<& [std::string::String]> {
        self.property_names.as_deref()
    }
    /// <p>A Boolean value that specifies whether the property group is inherited from a parent entity</p>
    pub fn is_inherited(&self) -> std::option::Option<bool> {
        self.is_inherited
    }
}
/// See [`PropertyGroupResponse`](crate::model::PropertyGroupResponse).
pub mod property_group_response {
    
    /// A builder for [`PropertyGroupResponse`](crate::model::PropertyGroupResponse).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_type: std::option::Option<crate::model::GroupType>,
        pub(crate) property_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) is_inherited: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The group types.</p>
        pub fn group_type(mut self, input: crate::model::GroupType) -> Self {
            self.group_type = Some(input);
            self
        }
        /// <p>The group types.</p>
        pub fn set_group_type(mut self, input: std::option::Option<crate::model::GroupType>) -> Self {
            self.group_type = input; self
        }
        /// Appends an item to `property_names`.
        ///
        /// To override the contents of this collection use [`set_property_names`](Self::set_property_names).
        ///
        /// <p>The names of properties.</p>
        pub fn property_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.property_names.unwrap_or_default();
                            v.push(input.into());
                            self.property_names = Some(v);
                            self
        }
        /// <p>The names of properties.</p>
        pub fn set_property_names(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.property_names = input; self
        }
        /// <p>A Boolean value that specifies whether the property group is inherited from a parent entity</p>
        pub fn is_inherited(mut self, input: bool) -> Self {
            self.is_inherited = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property group is inherited from a parent entity</p>
        pub fn set_is_inherited(mut self, input: std::option::Option<bool>) -> Self {
            self.is_inherited = input; self
        }
        /// Consumes the builder and constructs a [`PropertyGroupResponse`](crate::model::PropertyGroupResponse).
        pub fn build(self) -> crate::model::PropertyGroupResponse {
            crate::model::PropertyGroupResponse {
                group_type: self.group_type
                ,
                property_names: self.property_names
                ,
                is_inherited: self.is_inherited
                ,
            }
        }
    }
    
    
}
impl PropertyGroupResponse {
    /// Creates a new builder-style object to manufacture [`PropertyGroupResponse`](crate::model::PropertyGroupResponse).
    pub fn builder() -> crate::model::property_group_response::Builder {
        crate::model::property_group_response::Builder::default()
    }
}

/// <p>The function response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FunctionResponse  {
    /// <p>The required properties of the function.</p>
    #[doc(hidden)]
    pub required_properties: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The scope of the function.</p>
    #[doc(hidden)]
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>The data connector.</p>
    #[doc(hidden)]
    pub implemented_by: std::option::Option<crate::model::DataConnector>,
    /// <p>Indicates whether this function is inherited.</p>
    #[doc(hidden)]
    pub is_inherited: std::option::Option<bool>,
}
impl FunctionResponse {
    /// <p>The required properties of the function.</p>
    pub fn required_properties(&self) -> std::option::Option<& [std::string::String]> {
        self.required_properties.as_deref()
    }
    /// <p>The scope of the function.</p>
    pub fn scope(&self) -> std::option::Option<& crate::model::Scope> {
        self.scope.as_ref()
    }
    /// <p>The data connector.</p>
    pub fn implemented_by(&self) -> std::option::Option<& crate::model::DataConnector> {
        self.implemented_by.as_ref()
    }
    /// <p>Indicates whether this function is inherited.</p>
    pub fn is_inherited(&self) -> std::option::Option<bool> {
        self.is_inherited
    }
}
/// See [`FunctionResponse`](crate::model::FunctionResponse).
pub mod function_response {
    
    /// A builder for [`FunctionResponse`](crate::model::FunctionResponse).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) required_properties: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) implemented_by: std::option::Option<crate::model::DataConnector>,
        pub(crate) is_inherited: std::option::Option<bool>,
    }
    impl Builder {
        /// Appends an item to `required_properties`.
        ///
        /// To override the contents of this collection use [`set_required_properties`](Self::set_required_properties).
        ///
        /// <p>The required properties of the function.</p>
        pub fn required_properties(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.required_properties.unwrap_or_default();
                            v.push(input.into());
                            self.required_properties = Some(v);
                            self
        }
        /// <p>The required properties of the function.</p>
        pub fn set_required_properties(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.required_properties = input; self
        }
        /// <p>The scope of the function.</p>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        /// <p>The scope of the function.</p>
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input; self
        }
        /// <p>The data connector.</p>
        pub fn implemented_by(mut self, input: crate::model::DataConnector) -> Self {
            self.implemented_by = Some(input);
            self
        }
        /// <p>The data connector.</p>
        pub fn set_implemented_by(mut self, input: std::option::Option<crate::model::DataConnector>) -> Self {
            self.implemented_by = input; self
        }
        /// <p>Indicates whether this function is inherited.</p>
        pub fn is_inherited(mut self, input: bool) -> Self {
            self.is_inherited = Some(input);
            self
        }
        /// <p>Indicates whether this function is inherited.</p>
        pub fn set_is_inherited(mut self, input: std::option::Option<bool>) -> Self {
            self.is_inherited = input; self
        }
        /// Consumes the builder and constructs a [`FunctionResponse`](crate::model::FunctionResponse).
        pub fn build(self) -> crate::model::FunctionResponse {
            crate::model::FunctionResponse {
                required_properties: self.required_properties
                ,
                scope: self.scope
                ,
                implemented_by: self.implemented_by
                ,
                is_inherited: self.is_inherited
                ,
            }
        }
    }
    
    
}
impl FunctionResponse {
    /// Creates a new builder-style object to manufacture [`FunctionResponse`](crate::model::FunctionResponse).
    pub fn builder() -> crate::model::function_response::Builder {
        crate::model::function_response::Builder::default()
    }
}

/// <p>Represents a single row in the query results.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Row  {
    /// <p>The data in a row of query results.</p>
    #[doc(hidden)]
    pub row_data: std::option::Option<std::vec::Vec<aws_smithy_types::Document>>,
}
impl Row {
    /// <p>The data in a row of query results.</p>
    pub fn row_data(&self) -> std::option::Option<& [aws_smithy_types::Document]> {
        self.row_data.as_deref()
    }
}
/// See [`Row`](crate::model::Row).
pub mod row {
    
    /// A builder for [`Row`](crate::model::Row).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) row_data: std::option::Option<std::vec::Vec<aws_smithy_types::Document>>,
    }
    impl Builder {
        /// Appends an item to `row_data`.
        ///
        /// To override the contents of this collection use [`set_row_data`](Self::set_row_data).
        ///
        /// <p>The data in a row of query results.</p>
        pub fn row_data(mut self, input: aws_smithy_types::Document) -> Self {
            let mut v = self.row_data.unwrap_or_default();
                            v.push(input);
                            self.row_data = Some(v);
                            self
        }
        /// <p>The data in a row of query results.</p>
        pub fn set_row_data(mut self, input: std::option::Option<std::vec::Vec<aws_smithy_types::Document>>) -> Self {
            self.row_data = input; self
        }
        /// Consumes the builder and constructs a [`Row`](crate::model::Row).
        pub fn build(self) -> crate::model::Row {
            crate::model::Row {
                row_data: self.row_data
                ,
            }
        }
    }
    
    
}
impl Row {
    /// Creates a new builder-style object to manufacture [`Row`](crate::model::Row).
    pub fn builder() -> crate::model::row::Builder {
        crate::model::row::Builder::default()
    }
}

/// <p>A description of the column in the query results.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColumnDescription  {
    /// <p>The name of the column description.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of the column description.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ColumnType>,
}
impl ColumnDescription {
    /// <p>The name of the column description.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>The type of the column description.</p>
    pub fn r#type(&self) -> std::option::Option<& crate::model::ColumnType> {
        self.r#type.as_ref()
    }
}
/// See [`ColumnDescription`](crate::model::ColumnDescription).
pub mod column_description {
    
    /// A builder for [`ColumnDescription`](crate::model::ColumnDescription).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ColumnType>,
    }
    impl Builder {
        /// <p>The name of the column description.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the column description.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>The type of the column description.</p>
        pub fn r#type(mut self, input: crate::model::ColumnType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the column description.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::ColumnType>) -> Self {
            self.r#type = input; self
        }
        /// Consumes the builder and constructs a [`ColumnDescription`](crate::model::ColumnDescription).
        pub fn build(self) -> crate::model::ColumnDescription {
            crate::model::ColumnDescription {
                name: self.name
                ,
                r#type: self.r#type
                ,
            }
        }
    }
    
    
}
impl ColumnDescription {
    /// Creates a new builder-style object to manufacture [`ColumnDescription`](crate::model::ColumnDescription).
    pub fn builder() -> crate::model::column_description::Builder {
        crate::model::column_description::Builder::default()
    }
}

/// When writing a match expression against `ColumnType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let columntype = unimplemented!();
/// match columntype {
///     ColumnType::Edge => { /* ... */ },
///     ColumnType::Node => { /* ... */ },
///     ColumnType::Value => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `columntype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ColumnType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ColumnType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ColumnType::NewFeature` is defined.
/// Specifically, when `columntype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ColumnType::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum ColumnType {
    #[allow(missing_docs)] // documentation missing in model
    Edge,
    #[allow(missing_docs)] // documentation missing in model
    Node,
    #[allow(missing_docs)] // documentation missing in model
    Value,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for ColumnType {
    fn from(s: &str) -> Self {
        match s {
            "EDGE" => ColumnType::Edge,
            "NODE" => ColumnType::Node,
            "VALUE" => ColumnType::Value,
            other => ColumnType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for ColumnType {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(ColumnType::from(s))
                }
            }
impl ColumnType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ColumnType::Edge => "EDGE",
            ColumnType::Node => "NODE",
            ColumnType::Value => "VALUE",
            ColumnType::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "EDGE", "NODE", "VALUE"
        ]
    }
}
impl AsRef<str> for ColumnType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that sets information about a component type create or update request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComponentRequest  {
    /// <p>The description of the component request.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The ID of the component type.</p>
    #[doc(hidden)]
    pub component_type_id: std::option::Option<std::string::String>,
    /// <p>An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.</p>
    #[doc(hidden)]
    pub properties: std::option::Option<std::collections::HashMap<std::string::String, crate::model::PropertyRequest>>,
    /// <p>The property groups.</p>
    #[doc(hidden)]
    pub property_groups: std::option::Option<std::collections::HashMap<std::string::String, crate::model::ComponentPropertyGroupRequest>>,
}
impl ComponentRequest {
    /// <p>The description of the component request.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>The ID of the component type.</p>
    pub fn component_type_id(&self) -> std::option::Option<& str> {
        self.component_type_id.as_deref()
    }
    /// <p>An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.</p>
    pub fn properties(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, crate::model::PropertyRequest>> {
        self.properties.as_ref()
    }
    /// <p>The property groups.</p>
    pub fn property_groups(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, crate::model::ComponentPropertyGroupRequest>> {
        self.property_groups.as_ref()
    }
}
/// See [`ComponentRequest`](crate::model::ComponentRequest).
pub mod component_request {
    
    /// A builder for [`ComponentRequest`](crate::model::ComponentRequest).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) component_type_id: std::option::Option<std::string::String>,
        pub(crate) properties: std::option::Option<std::collections::HashMap<std::string::String, crate::model::PropertyRequest>>,
        pub(crate) property_groups: std::option::Option<std::collections::HashMap<std::string::String, crate::model::ComponentPropertyGroupRequest>>,
    }
    impl Builder {
        /// <p>The description of the component request.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the component request.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>The ID of the component type.</p>
        pub fn component_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_type_id = Some(input.into());
            self
        }
        /// <p>The ID of the component type.</p>
        pub fn set_component_type_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.component_type_id = input; self
        }
        /// Adds a key-value pair to `properties`.
        ///
        /// To override the contents of this collection use [`set_properties`](Self::set_properties).
        ///
        /// <p>An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.</p>
        pub fn properties(mut self, k: impl Into<std::string::String>, v: crate::model::PropertyRequest) -> Self {
            let mut hash_map = self.properties.unwrap_or_default();
                            hash_map.insert(k.into(), v);
                            self.properties = Some(hash_map);
                            self
        }
        /// <p>An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.</p>
        pub fn set_properties(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, crate::model::PropertyRequest>>) -> Self {
            self.properties = input; self
        }
        /// Adds a key-value pair to `property_groups`.
        ///
        /// To override the contents of this collection use [`set_property_groups`](Self::set_property_groups).
        ///
        /// <p>The property groups.</p>
        pub fn property_groups(mut self, k: impl Into<std::string::String>, v: crate::model::ComponentPropertyGroupRequest) -> Self {
            let mut hash_map = self.property_groups.unwrap_or_default();
                            hash_map.insert(k.into(), v);
                            self.property_groups = Some(hash_map);
                            self
        }
        /// <p>The property groups.</p>
        pub fn set_property_groups(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, crate::model::ComponentPropertyGroupRequest>>) -> Self {
            self.property_groups = input; self
        }
        /// Consumes the builder and constructs a [`ComponentRequest`](crate::model::ComponentRequest).
        pub fn build(self) -> crate::model::ComponentRequest {
            crate::model::ComponentRequest {
                description: self.description
                ,
                component_type_id: self.component_type_id
                ,
                properties: self.properties
                ,
                property_groups: self.property_groups
                ,
            }
        }
    }
    
    
}
impl ComponentRequest {
    /// Creates a new builder-style object to manufacture [`ComponentRequest`](crate::model::ComponentRequest).
    pub fn builder() -> crate::model::component_request::Builder {
        crate::model::component_request::Builder::default()
    }
}

/// <p>An object that contains information about errors returned by the <code>BatchPutProperty</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchPutPropertyErrorEntry  {
    /// <p>A list of objects that contain information about errors returned by the <code>BatchPutProperty</code> action.</p>
    #[doc(hidden)]
    pub errors: std::option::Option<std::vec::Vec<crate::model::BatchPutPropertyError>>,
}
impl BatchPutPropertyErrorEntry {
    /// <p>A list of objects that contain information about errors returned by the <code>BatchPutProperty</code> action.</p>
    pub fn errors(&self) -> std::option::Option<& [crate::model::BatchPutPropertyError]> {
        self.errors.as_deref()
    }
}
/// See [`BatchPutPropertyErrorEntry`](crate::model::BatchPutPropertyErrorEntry).
pub mod batch_put_property_error_entry {
    
    /// A builder for [`BatchPutPropertyErrorEntry`](crate::model::BatchPutPropertyErrorEntry).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) errors: std::option::Option<std::vec::Vec<crate::model::BatchPutPropertyError>>,
    }
    impl Builder {
        /// Appends an item to `errors`.
        ///
        /// To override the contents of this collection use [`set_errors`](Self::set_errors).
        ///
        /// <p>A list of objects that contain information about errors returned by the <code>BatchPutProperty</code> action.</p>
        pub fn errors(mut self, input: crate::model::BatchPutPropertyError) -> Self {
            let mut v = self.errors.unwrap_or_default();
                            v.push(input);
                            self.errors = Some(v);
                            self
        }
        /// <p>A list of objects that contain information about errors returned by the <code>BatchPutProperty</code> action.</p>
        pub fn set_errors(mut self, input: std::option::Option<std::vec::Vec<crate::model::BatchPutPropertyError>>) -> Self {
            self.errors = input; self
        }
        /// Consumes the builder and constructs a [`BatchPutPropertyErrorEntry`](crate::model::BatchPutPropertyErrorEntry).
        pub fn build(self) -> crate::model::BatchPutPropertyErrorEntry {
            crate::model::BatchPutPropertyErrorEntry {
                errors: self.errors
                ,
            }
        }
    }
    
    
}
impl BatchPutPropertyErrorEntry {
    /// Creates a new builder-style object to manufacture [`BatchPutPropertyErrorEntry`](crate::model::BatchPutPropertyErrorEntry).
    pub fn builder() -> crate::model::batch_put_property_error_entry::Builder {
        crate::model::batch_put_property_error_entry::Builder::default()
    }
}

/// <p>An error returned by the <code>BatchPutProperty</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchPutPropertyError  {
    /// <p>The error code.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The error message.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>An object that contains information about errors returned by the <code>BatchPutProperty</code> action.</p>
    #[doc(hidden)]
    pub entry: std::option::Option<crate::model::PropertyValueEntry>,
}
impl BatchPutPropertyError {
    /// <p>The error code.</p>
    pub fn error_code(&self) -> std::option::Option<& str> {
        self.error_code.as_deref()
    }
    /// <p>The error message.</p>
    pub fn error_message(&self) -> std::option::Option<& str> {
        self.error_message.as_deref()
    }
    /// <p>An object that contains information about errors returned by the <code>BatchPutProperty</code> action.</p>
    pub fn entry(&self) -> std::option::Option<& crate::model::PropertyValueEntry> {
        self.entry.as_ref()
    }
}
/// See [`BatchPutPropertyError`](crate::model::BatchPutPropertyError).
pub mod batch_put_property_error {
    
    /// A builder for [`BatchPutPropertyError`](crate::model::BatchPutPropertyError).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) entry: std::option::Option<crate::model::PropertyValueEntry>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The error code.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input; self
        }
        /// <p>The error message.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The error message.</p>
        pub fn set_error_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_message = input; self
        }
        /// <p>An object that contains information about errors returned by the <code>BatchPutProperty</code> action.</p>
        pub fn entry(mut self, input: crate::model::PropertyValueEntry) -> Self {
            self.entry = Some(input);
            self
        }
        /// <p>An object that contains information about errors returned by the <code>BatchPutProperty</code> action.</p>
        pub fn set_entry(mut self, input: std::option::Option<crate::model::PropertyValueEntry>) -> Self {
            self.entry = input; self
        }
        /// Consumes the builder and constructs a [`BatchPutPropertyError`](crate::model::BatchPutPropertyError).
        pub fn build(self) -> crate::model::BatchPutPropertyError {
            crate::model::BatchPutPropertyError {
                error_code: self.error_code
                ,
                error_message: self.error_message
                ,
                entry: self.entry
                ,
            }
        }
    }
    
    
}
impl BatchPutPropertyError {
    /// Creates a new builder-style object to manufacture [`BatchPutPropertyError`](crate::model::BatchPutPropertyError).
    pub fn builder() -> crate::model::batch_put_property_error::Builder {
        crate::model::batch_put_property_error::Builder::default()
    }
}

/// <p>An object that specifies information about time series property values. This object is used and consumed by the <a href="https://docs.aws.amazon.com/iot-twinmaker/latest/apireference/API_BatchPutPropertyValues.html">BatchPutPropertyValues</a> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyValueEntry  {
    /// <p>An object that contains information about the entity that has the property.</p>
    #[doc(hidden)]
    pub entity_property_reference: std::option::Option<crate::model::EntityPropertyReference>,
    /// <p>A list of objects that specify time series property values.</p>
    #[doc(hidden)]
    pub property_values: std::option::Option<std::vec::Vec<crate::model::PropertyValue>>,
}
impl PropertyValueEntry {
    /// <p>An object that contains information about the entity that has the property.</p>
    pub fn entity_property_reference(&self) -> std::option::Option<& crate::model::EntityPropertyReference> {
        self.entity_property_reference.as_ref()
    }
    /// <p>A list of objects that specify time series property values.</p>
    pub fn property_values(&self) -> std::option::Option<& [crate::model::PropertyValue]> {
        self.property_values.as_deref()
    }
}
/// See [`PropertyValueEntry`](crate::model::PropertyValueEntry).
pub mod property_value_entry {
    
    /// A builder for [`PropertyValueEntry`](crate::model::PropertyValueEntry).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entity_property_reference: std::option::Option<crate::model::EntityPropertyReference>,
        pub(crate) property_values: std::option::Option<std::vec::Vec<crate::model::PropertyValue>>,
    }
    impl Builder {
        /// <p>An object that contains information about the entity that has the property.</p>
        pub fn entity_property_reference(mut self, input: crate::model::EntityPropertyReference) -> Self {
            self.entity_property_reference = Some(input);
            self
        }
        /// <p>An object that contains information about the entity that has the property.</p>
        pub fn set_entity_property_reference(mut self, input: std::option::Option<crate::model::EntityPropertyReference>) -> Self {
            self.entity_property_reference = input; self
        }
        /// Appends an item to `property_values`.
        ///
        /// To override the contents of this collection use [`set_property_values`](Self::set_property_values).
        ///
        /// <p>A list of objects that specify time series property values.</p>
        pub fn property_values(mut self, input: crate::model::PropertyValue) -> Self {
            let mut v = self.property_values.unwrap_or_default();
                            v.push(input);
                            self.property_values = Some(v);
                            self
        }
        /// <p>A list of objects that specify time series property values.</p>
        pub fn set_property_values(mut self, input: std::option::Option<std::vec::Vec<crate::model::PropertyValue>>) -> Self {
            self.property_values = input; self
        }
        /// Consumes the builder and constructs a [`PropertyValueEntry`](crate::model::PropertyValueEntry).
        pub fn build(self) -> crate::model::PropertyValueEntry {
            crate::model::PropertyValueEntry {
                entity_property_reference: self.entity_property_reference
                ,
                property_values: self.property_values
                ,
            }
        }
    }
    
    
}
impl PropertyValueEntry {
    /// Creates a new builder-style object to manufacture [`PropertyValueEntry`](crate::model::PropertyValueEntry).
    pub fn builder() -> crate::model::property_value_entry::Builder {
        crate::model::property_value_entry::Builder::default()
    }
}

