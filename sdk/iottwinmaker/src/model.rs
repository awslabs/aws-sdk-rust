// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The pricing plan.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PricingPlan {
    /// <p>The billable entity count.</p>
    #[doc(hidden)]
    pub billable_entity_count: std::option::Option<i64>,
    /// <p>The pricing plan's bundle information.</p>
    #[doc(hidden)]
    pub bundle_information: std::option::Option<crate::model::BundleInformation>,
    /// <p>The effective date and time of the pricing plan.</p>
    #[doc(hidden)]
    pub effective_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The pricing mode.</p>
    #[doc(hidden)]
    pub pricing_mode: std::option::Option<crate::model::PricingMode>,
    /// <p>The set date and time for updating a pricing plan.</p>
    #[doc(hidden)]
    pub update_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The update reason, for changing a pricing plan.</p>
    #[doc(hidden)]
    pub update_reason: std::option::Option<crate::model::UpdateReason>,
}
impl PricingPlan {
    /// <p>The billable entity count.</p>
    pub fn billable_entity_count(&self) -> std::option::Option<i64> {
        self.billable_entity_count
    }
    /// <p>The pricing plan's bundle information.</p>
    pub fn bundle_information(&self) -> std::option::Option<&crate::model::BundleInformation> {
        self.bundle_information.as_ref()
    }
    /// <p>The effective date and time of the pricing plan.</p>
    pub fn effective_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.effective_date_time.as_ref()
    }
    /// <p>The pricing mode.</p>
    pub fn pricing_mode(&self) -> std::option::Option<&crate::model::PricingMode> {
        self.pricing_mode.as_ref()
    }
    /// <p>The set date and time for updating a pricing plan.</p>
    pub fn update_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_date_time.as_ref()
    }
    /// <p>The update reason, for changing a pricing plan.</p>
    pub fn update_reason(&self) -> std::option::Option<&crate::model::UpdateReason> {
        self.update_reason.as_ref()
    }
}
/// See [`PricingPlan`](crate::model::PricingPlan).
pub mod pricing_plan {

    /// A builder for [`PricingPlan`](crate::model::PricingPlan).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) billable_entity_count: std::option::Option<i64>,
        pub(crate) bundle_information: std::option::Option<crate::model::BundleInformation>,
        pub(crate) effective_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) pricing_mode: std::option::Option<crate::model::PricingMode>,
        pub(crate) update_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_reason: std::option::Option<crate::model::UpdateReason>,
    }
    impl Builder {
        /// <p>The billable entity count.</p>
        pub fn billable_entity_count(mut self, input: i64) -> Self {
            self.billable_entity_count = Some(input);
            self
        }
        /// <p>The billable entity count.</p>
        pub fn set_billable_entity_count(mut self, input: std::option::Option<i64>) -> Self {
            self.billable_entity_count = input;
            self
        }
        /// <p>The pricing plan's bundle information.</p>
        pub fn bundle_information(mut self, input: crate::model::BundleInformation) -> Self {
            self.bundle_information = Some(input);
            self
        }
        /// <p>The pricing plan's bundle information.</p>
        pub fn set_bundle_information(
            mut self,
            input: std::option::Option<crate::model::BundleInformation>,
        ) -> Self {
            self.bundle_information = input;
            self
        }
        /// <p>The effective date and time of the pricing plan.</p>
        pub fn effective_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.effective_date_time = Some(input);
            self
        }
        /// <p>The effective date and time of the pricing plan.</p>
        pub fn set_effective_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.effective_date_time = input;
            self
        }
        /// <p>The pricing mode.</p>
        pub fn pricing_mode(mut self, input: crate::model::PricingMode) -> Self {
            self.pricing_mode = Some(input);
            self
        }
        /// <p>The pricing mode.</p>
        pub fn set_pricing_mode(
            mut self,
            input: std::option::Option<crate::model::PricingMode>,
        ) -> Self {
            self.pricing_mode = input;
            self
        }
        /// <p>The set date and time for updating a pricing plan.</p>
        pub fn update_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_date_time = Some(input);
            self
        }
        /// <p>The set date and time for updating a pricing plan.</p>
        pub fn set_update_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_date_time = input;
            self
        }
        /// <p>The update reason, for changing a pricing plan.</p>
        pub fn update_reason(mut self, input: crate::model::UpdateReason) -> Self {
            self.update_reason = Some(input);
            self
        }
        /// <p>The update reason, for changing a pricing plan.</p>
        pub fn set_update_reason(
            mut self,
            input: std::option::Option<crate::model::UpdateReason>,
        ) -> Self {
            self.update_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`PricingPlan`](crate::model::PricingPlan).
        pub fn build(self) -> crate::model::PricingPlan {
            crate::model::PricingPlan {
                billable_entity_count: self.billable_entity_count,
                bundle_information: self.bundle_information,
                effective_date_time: self.effective_date_time,
                pricing_mode: self.pricing_mode,
                update_date_time: self.update_date_time,
                update_reason: self.update_reason,
            }
        }
    }
}
impl PricingPlan {
    /// Creates a new builder-style object to manufacture [`PricingPlan`](crate::model::PricingPlan).
    pub fn builder() -> crate::model::pricing_plan::Builder {
        crate::model::pricing_plan::Builder::default()
    }
}

/// When writing a match expression against `UpdateReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let updatereason = unimplemented!();
/// match updatereason {
///     UpdateReason::Default => { /* ... */ },
///     UpdateReason::EntityCountUpdate => { /* ... */ },
///     UpdateReason::Overwritten => { /* ... */ },
///     UpdateReason::PricingModeUpdate => { /* ... */ },
///     UpdateReason::PricingTierUpdate => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `updatereason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UpdateReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UpdateReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UpdateReason::NewFeature` is defined.
/// Specifically, when `updatereason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UpdateReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UpdateReason {
    #[allow(missing_docs)] // documentation missing in model
    Default,
    #[allow(missing_docs)] // documentation missing in model
    EntityCountUpdate,
    #[allow(missing_docs)] // documentation missing in model
    Overwritten,
    #[allow(missing_docs)] // documentation missing in model
    PricingModeUpdate,
    #[allow(missing_docs)] // documentation missing in model
    PricingTierUpdate,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for UpdateReason {
    fn from(s: &str) -> Self {
        match s {
            "DEFAULT" => UpdateReason::Default,
            "ENTITY_COUNT_UPDATE" => UpdateReason::EntityCountUpdate,
            "OVERWRITTEN" => UpdateReason::Overwritten,
            "PRICING_MODE_UPDATE" => UpdateReason::PricingModeUpdate,
            "PRICING_TIER_UPDATE" => UpdateReason::PricingTierUpdate,
            other => UpdateReason::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for UpdateReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UpdateReason::from(s))
    }
}
impl UpdateReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UpdateReason::Default => "DEFAULT",
            UpdateReason::EntityCountUpdate => "ENTITY_COUNT_UPDATE",
            UpdateReason::Overwritten => "OVERWRITTEN",
            UpdateReason::PricingModeUpdate => "PRICING_MODE_UPDATE",
            UpdateReason::PricingTierUpdate => "PRICING_TIER_UPDATE",
            UpdateReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DEFAULT",
            "ENTITY_COUNT_UPDATE",
            "OVERWRITTEN",
            "PRICING_MODE_UPDATE",
            "PRICING_TIER_UPDATE",
        ]
    }
}
impl AsRef<str> for UpdateReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PricingMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let pricingmode = unimplemented!();
/// match pricingmode {
///     PricingMode::Basic => { /* ... */ },
///     PricingMode::Standard => { /* ... */ },
///     PricingMode::TieredBundle => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `pricingmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PricingMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PricingMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PricingMode::NewFeature` is defined.
/// Specifically, when `pricingmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PricingMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PricingMode {
    #[allow(missing_docs)] // documentation missing in model
    Basic,
    #[allow(missing_docs)] // documentation missing in model
    Standard,
    #[allow(missing_docs)] // documentation missing in model
    TieredBundle,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PricingMode {
    fn from(s: &str) -> Self {
        match s {
            "BASIC" => PricingMode::Basic,
            "STANDARD" => PricingMode::Standard,
            "TIERED_BUNDLE" => PricingMode::TieredBundle,
            other => PricingMode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PricingMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PricingMode::from(s))
    }
}
impl PricingMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PricingMode::Basic => "BASIC",
            PricingMode::Standard => "STANDARD",
            PricingMode::TieredBundle => "TIERED_BUNDLE",
            PricingMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BASIC", "STANDARD", "TIERED_BUNDLE"]
    }
}
impl AsRef<str> for PricingMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about pricing bundle.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BundleInformation {
    /// <p>The bundle names.</p>
    #[doc(hidden)]
    pub bundle_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The pricing tier.</p>
    #[doc(hidden)]
    pub pricing_tier: std::option::Option<crate::model::PricingTier>,
}
impl BundleInformation {
    /// <p>The bundle names.</p>
    pub fn bundle_names(&self) -> std::option::Option<&[std::string::String]> {
        self.bundle_names.as_deref()
    }
    /// <p>The pricing tier.</p>
    pub fn pricing_tier(&self) -> std::option::Option<&crate::model::PricingTier> {
        self.pricing_tier.as_ref()
    }
}
/// See [`BundleInformation`](crate::model::BundleInformation).
pub mod bundle_information {

    /// A builder for [`BundleInformation`](crate::model::BundleInformation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bundle_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) pricing_tier: std::option::Option<crate::model::PricingTier>,
    }
    impl Builder {
        /// Appends an item to `bundle_names`.
        ///
        /// To override the contents of this collection use [`set_bundle_names`](Self::set_bundle_names).
        ///
        /// <p>The bundle names.</p>
        pub fn bundle_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.bundle_names.unwrap_or_default();
            v.push(input.into());
            self.bundle_names = Some(v);
            self
        }
        /// <p>The bundle names.</p>
        pub fn set_bundle_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.bundle_names = input;
            self
        }
        /// <p>The pricing tier.</p>
        pub fn pricing_tier(mut self, input: crate::model::PricingTier) -> Self {
            self.pricing_tier = Some(input);
            self
        }
        /// <p>The pricing tier.</p>
        pub fn set_pricing_tier(
            mut self,
            input: std::option::Option<crate::model::PricingTier>,
        ) -> Self {
            self.pricing_tier = input;
            self
        }
        /// Consumes the builder and constructs a [`BundleInformation`](crate::model::BundleInformation).
        pub fn build(self) -> crate::model::BundleInformation {
            crate::model::BundleInformation {
                bundle_names: self.bundle_names,
                pricing_tier: self.pricing_tier,
            }
        }
    }
}
impl BundleInformation {
    /// Creates a new builder-style object to manufacture [`BundleInformation`](crate::model::BundleInformation).
    pub fn builder() -> crate::model::bundle_information::Builder {
        crate::model::bundle_information::Builder::default()
    }
}

/// When writing a match expression against `PricingTier`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let pricingtier = unimplemented!();
/// match pricingtier {
///     PricingTier::Tier1 => { /* ... */ },
///     PricingTier::Tier2 => { /* ... */ },
///     PricingTier::Tier3 => { /* ... */ },
///     PricingTier::Tier4 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `pricingtier` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PricingTier::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PricingTier::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PricingTier::NewFeature` is defined.
/// Specifically, when `pricingtier` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PricingTier::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PricingTier {
    #[allow(missing_docs)] // documentation missing in model
    Tier1,
    #[allow(missing_docs)] // documentation missing in model
    Tier2,
    #[allow(missing_docs)] // documentation missing in model
    Tier3,
    #[allow(missing_docs)] // documentation missing in model
    Tier4,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PricingTier {
    fn from(s: &str) -> Self {
        match s {
            "TIER_1" => PricingTier::Tier1,
            "TIER_2" => PricingTier::Tier2,
            "TIER_3" => PricingTier::Tier3,
            "TIER_4" => PricingTier::Tier4,
            other => PricingTier::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PricingTier {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PricingTier::from(s))
    }
}
impl PricingTier {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PricingTier::Tier1 => "TIER_1",
            PricingTier::Tier2 => "TIER_2",
            PricingTier::Tier3 => "TIER_3",
            PricingTier::Tier4 => "TIER_4",
            PricingTier::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["TIER_1", "TIER_2", "TIER_3", "TIER_4"]
    }
}
impl AsRef<str> for PricingTier {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `State`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let state = unimplemented!();
/// match state {
///     State::Active => { /* ... */ },
///     State::Creating => { /* ... */ },
///     State::Deleting => { /* ... */ },
///     State::Error => { /* ... */ },
///     State::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `state` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `State::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `State::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `State::NewFeature` is defined.
/// Specifically, when `state` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `State::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum State {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for State {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => State::Active,
            "CREATING" => State::Creating,
            "DELETING" => State::Deleting,
            "ERROR" => State::Error,
            "UPDATING" => State::Updating,
            other => State::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for State {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(State::from(s))
    }
}
impl State {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            State::Active => "ACTIVE",
            State::Creating => "CREATING",
            State::Deleting => "DELETING",
            State::Error => "ERROR",
            State::Updating => "UPDATING",
            State::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "CREATING", "DELETING", "ERROR", "UPDATING"]
    }
}
impl AsRef<str> for State {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The parent entity update request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ParentEntityUpdateRequest {
    /// <p>The type of the update.</p>
    #[doc(hidden)]
    pub update_type: std::option::Option<crate::model::ParentEntityUpdateType>,
    /// <p>The ID of the parent entity.</p>
    #[doc(hidden)]
    pub parent_entity_id: std::option::Option<std::string::String>,
}
impl ParentEntityUpdateRequest {
    /// <p>The type of the update.</p>
    pub fn update_type(&self) -> std::option::Option<&crate::model::ParentEntityUpdateType> {
        self.update_type.as_ref()
    }
    /// <p>The ID of the parent entity.</p>
    pub fn parent_entity_id(&self) -> std::option::Option<&str> {
        self.parent_entity_id.as_deref()
    }
}
/// See [`ParentEntityUpdateRequest`](crate::model::ParentEntityUpdateRequest).
pub mod parent_entity_update_request {

    /// A builder for [`ParentEntityUpdateRequest`](crate::model::ParentEntityUpdateRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) update_type: std::option::Option<crate::model::ParentEntityUpdateType>,
        pub(crate) parent_entity_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of the update.</p>
        pub fn update_type(mut self, input: crate::model::ParentEntityUpdateType) -> Self {
            self.update_type = Some(input);
            self
        }
        /// <p>The type of the update.</p>
        pub fn set_update_type(
            mut self,
            input: std::option::Option<crate::model::ParentEntityUpdateType>,
        ) -> Self {
            self.update_type = input;
            self
        }
        /// <p>The ID of the parent entity.</p>
        pub fn parent_entity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.parent_entity_id = Some(input.into());
            self
        }
        /// <p>The ID of the parent entity.</p>
        pub fn set_parent_entity_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parent_entity_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ParentEntityUpdateRequest`](crate::model::ParentEntityUpdateRequest).
        pub fn build(self) -> crate::model::ParentEntityUpdateRequest {
            crate::model::ParentEntityUpdateRequest {
                update_type: self.update_type,
                parent_entity_id: self.parent_entity_id,
            }
        }
    }
}
impl ParentEntityUpdateRequest {
    /// Creates a new builder-style object to manufacture [`ParentEntityUpdateRequest`](crate::model::ParentEntityUpdateRequest).
    pub fn builder() -> crate::model::parent_entity_update_request::Builder {
        crate::model::parent_entity_update_request::Builder::default()
    }
}

/// When writing a match expression against `ParentEntityUpdateType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let parententityupdatetype = unimplemented!();
/// match parententityupdatetype {
///     ParentEntityUpdateType::Delete => { /* ... */ },
///     ParentEntityUpdateType::Update => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `parententityupdatetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ParentEntityUpdateType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ParentEntityUpdateType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ParentEntityUpdateType::NewFeature` is defined.
/// Specifically, when `parententityupdatetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ParentEntityUpdateType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ParentEntityUpdateType {
    #[allow(missing_docs)] // documentation missing in model
    Delete,
    #[allow(missing_docs)] // documentation missing in model
    Update,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ParentEntityUpdateType {
    fn from(s: &str) -> Self {
        match s {
            "DELETE" => ParentEntityUpdateType::Delete,
            "UPDATE" => ParentEntityUpdateType::Update,
            other => {
                ParentEntityUpdateType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ParentEntityUpdateType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ParentEntityUpdateType::from(s))
    }
}
impl ParentEntityUpdateType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ParentEntityUpdateType::Delete => "DELETE",
            ParentEntityUpdateType::Update => "UPDATE",
            ParentEntityUpdateType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DELETE", "UPDATE"]
    }
}
impl AsRef<str> for ParentEntityUpdateType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The component update request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComponentUpdateRequest {
    /// <p>The update type of the component update request.</p>
    #[doc(hidden)]
    pub update_type: std::option::Option<crate::model::ComponentUpdateType>,
    /// <p>The description of the component type.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The ID of the component type.</p>
    #[doc(hidden)]
    pub component_type_id: std::option::Option<std::string::String>,
    /// <p>An object that maps strings to the properties to set in the component type update. Each string in the mapping must be unique to this object.</p>
    #[doc(hidden)]
    pub property_updates: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::PropertyRequest>,
    >,
    /// <p>The property group updates.</p>
    #[doc(hidden)]
    pub property_group_updates: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::ComponentPropertyGroupRequest>,
    >,
}
impl ComponentUpdateRequest {
    /// <p>The update type of the component update request.</p>
    pub fn update_type(&self) -> std::option::Option<&crate::model::ComponentUpdateType> {
        self.update_type.as_ref()
    }
    /// <p>The description of the component type.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The ID of the component type.</p>
    pub fn component_type_id(&self) -> std::option::Option<&str> {
        self.component_type_id.as_deref()
    }
    /// <p>An object that maps strings to the properties to set in the component type update. Each string in the mapping must be unique to this object.</p>
    pub fn property_updates(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::PropertyRequest>,
    > {
        self.property_updates.as_ref()
    }
    /// <p>The property group updates.</p>
    pub fn property_group_updates(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<
            std::string::String,
            crate::model::ComponentPropertyGroupRequest,
        >,
    > {
        self.property_group_updates.as_ref()
    }
}
/// See [`ComponentUpdateRequest`](crate::model::ComponentUpdateRequest).
pub mod component_update_request {

    /// A builder for [`ComponentUpdateRequest`](crate::model::ComponentUpdateRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) update_type: std::option::Option<crate::model::ComponentUpdateType>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) component_type_id: std::option::Option<std::string::String>,
        pub(crate) property_updates: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::PropertyRequest>,
        >,
        pub(crate) property_group_updates: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                crate::model::ComponentPropertyGroupRequest,
            >,
        >,
    }
    impl Builder {
        /// <p>The update type of the component update request.</p>
        pub fn update_type(mut self, input: crate::model::ComponentUpdateType) -> Self {
            self.update_type = Some(input);
            self
        }
        /// <p>The update type of the component update request.</p>
        pub fn set_update_type(
            mut self,
            input: std::option::Option<crate::model::ComponentUpdateType>,
        ) -> Self {
            self.update_type = input;
            self
        }
        /// <p>The description of the component type.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the component type.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ID of the component type.</p>
        pub fn component_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_type_id = Some(input.into());
            self
        }
        /// <p>The ID of the component type.</p>
        pub fn set_component_type_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.component_type_id = input;
            self
        }
        /// Adds a key-value pair to `property_updates`.
        ///
        /// To override the contents of this collection use [`set_property_updates`](Self::set_property_updates).
        ///
        /// <p>An object that maps strings to the properties to set in the component type update. Each string in the mapping must be unique to this object.</p>
        pub fn property_updates(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::PropertyRequest,
        ) -> Self {
            let mut hash_map = self.property_updates.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.property_updates = Some(hash_map);
            self
        }
        /// <p>An object that maps strings to the properties to set in the component type update. Each string in the mapping must be unique to this object.</p>
        pub fn set_property_updates(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::PropertyRequest>,
            >,
        ) -> Self {
            self.property_updates = input;
            self
        }
        /// Adds a key-value pair to `property_group_updates`.
        ///
        /// To override the contents of this collection use [`set_property_group_updates`](Self::set_property_group_updates).
        ///
        /// <p>The property group updates.</p>
        pub fn property_group_updates(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::ComponentPropertyGroupRequest,
        ) -> Self {
            let mut hash_map = self.property_group_updates.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.property_group_updates = Some(hash_map);
            self
        }
        /// <p>The property group updates.</p>
        pub fn set_property_group_updates(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::ComponentPropertyGroupRequest,
                >,
            >,
        ) -> Self {
            self.property_group_updates = input;
            self
        }
        /// Consumes the builder and constructs a [`ComponentUpdateRequest`](crate::model::ComponentUpdateRequest).
        pub fn build(self) -> crate::model::ComponentUpdateRequest {
            crate::model::ComponentUpdateRequest {
                update_type: self.update_type,
                description: self.description,
                component_type_id: self.component_type_id,
                property_updates: self.property_updates,
                property_group_updates: self.property_group_updates,
            }
        }
    }
}
impl ComponentUpdateRequest {
    /// Creates a new builder-style object to manufacture [`ComponentUpdateRequest`](crate::model::ComponentUpdateRequest).
    pub fn builder() -> crate::model::component_update_request::Builder {
        crate::model::component_update_request::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComponentPropertyGroupRequest {
    /// <p>The group type.</p>
    #[doc(hidden)]
    pub group_type: std::option::Option<crate::model::GroupType>,
    /// <p>The property names.</p>
    #[doc(hidden)]
    pub property_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The update type.</p>
    #[doc(hidden)]
    pub update_type: std::option::Option<crate::model::PropertyGroupUpdateType>,
}
impl ComponentPropertyGroupRequest {
    /// <p>The group type.</p>
    pub fn group_type(&self) -> std::option::Option<&crate::model::GroupType> {
        self.group_type.as_ref()
    }
    /// <p>The property names.</p>
    pub fn property_names(&self) -> std::option::Option<&[std::string::String]> {
        self.property_names.as_deref()
    }
    /// <p>The update type.</p>
    pub fn update_type(&self) -> std::option::Option<&crate::model::PropertyGroupUpdateType> {
        self.update_type.as_ref()
    }
}
/// See [`ComponentPropertyGroupRequest`](crate::model::ComponentPropertyGroupRequest).
pub mod component_property_group_request {

    /// A builder for [`ComponentPropertyGroupRequest`](crate::model::ComponentPropertyGroupRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_type: std::option::Option<crate::model::GroupType>,
        pub(crate) property_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) update_type: std::option::Option<crate::model::PropertyGroupUpdateType>,
    }
    impl Builder {
        /// <p>The group type.</p>
        pub fn group_type(mut self, input: crate::model::GroupType) -> Self {
            self.group_type = Some(input);
            self
        }
        /// <p>The group type.</p>
        pub fn set_group_type(
            mut self,
            input: std::option::Option<crate::model::GroupType>,
        ) -> Self {
            self.group_type = input;
            self
        }
        /// Appends an item to `property_names`.
        ///
        /// To override the contents of this collection use [`set_property_names`](Self::set_property_names).
        ///
        /// <p>The property names.</p>
        pub fn property_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.property_names.unwrap_or_default();
            v.push(input.into());
            self.property_names = Some(v);
            self
        }
        /// <p>The property names.</p>
        pub fn set_property_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.property_names = input;
            self
        }
        /// <p>The update type.</p>
        pub fn update_type(mut self, input: crate::model::PropertyGroupUpdateType) -> Self {
            self.update_type = Some(input);
            self
        }
        /// <p>The update type.</p>
        pub fn set_update_type(
            mut self,
            input: std::option::Option<crate::model::PropertyGroupUpdateType>,
        ) -> Self {
            self.update_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ComponentPropertyGroupRequest`](crate::model::ComponentPropertyGroupRequest).
        pub fn build(self) -> crate::model::ComponentPropertyGroupRequest {
            crate::model::ComponentPropertyGroupRequest {
                group_type: self.group_type,
                property_names: self.property_names,
                update_type: self.update_type,
            }
        }
    }
}
impl ComponentPropertyGroupRequest {
    /// Creates a new builder-style object to manufacture [`ComponentPropertyGroupRequest`](crate::model::ComponentPropertyGroupRequest).
    pub fn builder() -> crate::model::component_property_group_request::Builder {
        crate::model::component_property_group_request::Builder::default()
    }
}

/// When writing a match expression against `PropertyGroupUpdateType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let propertygroupupdatetype = unimplemented!();
/// match propertygroupupdatetype {
///     PropertyGroupUpdateType::Create => { /* ... */ },
///     PropertyGroupUpdateType::Delete => { /* ... */ },
///     PropertyGroupUpdateType::Update => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `propertygroupupdatetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PropertyGroupUpdateType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PropertyGroupUpdateType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PropertyGroupUpdateType::NewFeature` is defined.
/// Specifically, when `propertygroupupdatetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PropertyGroupUpdateType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PropertyGroupUpdateType {
    #[allow(missing_docs)] // documentation missing in model
    Create,
    #[allow(missing_docs)] // documentation missing in model
    Delete,
    #[allow(missing_docs)] // documentation missing in model
    Update,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PropertyGroupUpdateType {
    fn from(s: &str) -> Self {
        match s {
            "CREATE" => PropertyGroupUpdateType::Create,
            "DELETE" => PropertyGroupUpdateType::Delete,
            "UPDATE" => PropertyGroupUpdateType::Update,
            other => PropertyGroupUpdateType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for PropertyGroupUpdateType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PropertyGroupUpdateType::from(s))
    }
}
impl PropertyGroupUpdateType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PropertyGroupUpdateType::Create => "CREATE",
            PropertyGroupUpdateType::Delete => "DELETE",
            PropertyGroupUpdateType::Update => "UPDATE",
            PropertyGroupUpdateType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CREATE", "DELETE", "UPDATE"]
    }
}
impl AsRef<str> for PropertyGroupUpdateType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `GroupType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let grouptype = unimplemented!();
/// match grouptype {
///     GroupType::Tabular => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `grouptype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `GroupType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `GroupType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `GroupType::NewFeature` is defined.
/// Specifically, when `grouptype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `GroupType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum GroupType {
    #[allow(missing_docs)] // documentation missing in model
    Tabular,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for GroupType {
    fn from(s: &str) -> Self {
        match s {
            "TABULAR" => GroupType::Tabular,
            other => GroupType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for GroupType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(GroupType::from(s))
    }
}
impl GroupType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            GroupType::Tabular => "TABULAR",
            GroupType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["TABULAR"]
    }
}
impl AsRef<str> for GroupType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that sets information about a property.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyRequest {
    /// <p>An object that specifies information about a property.</p>
    #[doc(hidden)]
    pub definition: std::option::Option<crate::model::PropertyDefinitionRequest>,
    /// <p>The value of the property.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::DataValue>,
    /// <p>The update type of the update property request.</p>
    #[doc(hidden)]
    pub update_type: std::option::Option<crate::model::PropertyUpdateType>,
}
impl PropertyRequest {
    /// <p>An object that specifies information about a property.</p>
    pub fn definition(&self) -> std::option::Option<&crate::model::PropertyDefinitionRequest> {
        self.definition.as_ref()
    }
    /// <p>The value of the property.</p>
    pub fn value(&self) -> std::option::Option<&crate::model::DataValue> {
        self.value.as_ref()
    }
    /// <p>The update type of the update property request.</p>
    pub fn update_type(&self) -> std::option::Option<&crate::model::PropertyUpdateType> {
        self.update_type.as_ref()
    }
}
/// See [`PropertyRequest`](crate::model::PropertyRequest).
pub mod property_request {

    /// A builder for [`PropertyRequest`](crate::model::PropertyRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) definition: std::option::Option<crate::model::PropertyDefinitionRequest>,
        pub(crate) value: std::option::Option<crate::model::DataValue>,
        pub(crate) update_type: std::option::Option<crate::model::PropertyUpdateType>,
    }
    impl Builder {
        /// <p>An object that specifies information about a property.</p>
        pub fn definition(mut self, input: crate::model::PropertyDefinitionRequest) -> Self {
            self.definition = Some(input);
            self
        }
        /// <p>An object that specifies information about a property.</p>
        pub fn set_definition(
            mut self,
            input: std::option::Option<crate::model::PropertyDefinitionRequest>,
        ) -> Self {
            self.definition = input;
            self
        }
        /// <p>The value of the property.</p>
        pub fn value(mut self, input: crate::model::DataValue) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the property.</p>
        pub fn set_value(mut self, input: std::option::Option<crate::model::DataValue>) -> Self {
            self.value = input;
            self
        }
        /// <p>The update type of the update property request.</p>
        pub fn update_type(mut self, input: crate::model::PropertyUpdateType) -> Self {
            self.update_type = Some(input);
            self
        }
        /// <p>The update type of the update property request.</p>
        pub fn set_update_type(
            mut self,
            input: std::option::Option<crate::model::PropertyUpdateType>,
        ) -> Self {
            self.update_type = input;
            self
        }
        /// Consumes the builder and constructs a [`PropertyRequest`](crate::model::PropertyRequest).
        pub fn build(self) -> crate::model::PropertyRequest {
            crate::model::PropertyRequest {
                definition: self.definition,
                value: self.value,
                update_type: self.update_type,
            }
        }
    }
}
impl PropertyRequest {
    /// Creates a new builder-style object to manufacture [`PropertyRequest`](crate::model::PropertyRequest).
    pub fn builder() -> crate::model::property_request::Builder {
        crate::model::property_request::Builder::default()
    }
}

/// When writing a match expression against `PropertyUpdateType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let propertyupdatetype = unimplemented!();
/// match propertyupdatetype {
///     PropertyUpdateType::Create => { /* ... */ },
///     PropertyUpdateType::Delete => { /* ... */ },
///     PropertyUpdateType::Update => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `propertyupdatetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PropertyUpdateType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PropertyUpdateType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PropertyUpdateType::NewFeature` is defined.
/// Specifically, when `propertyupdatetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PropertyUpdateType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PropertyUpdateType {
    #[allow(missing_docs)] // documentation missing in model
    Create,
    #[allow(missing_docs)] // documentation missing in model
    Delete,
    #[allow(missing_docs)] // documentation missing in model
    Update,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PropertyUpdateType {
    fn from(s: &str) -> Self {
        match s {
            "CREATE" => PropertyUpdateType::Create,
            "DELETE" => PropertyUpdateType::Delete,
            "UPDATE" => PropertyUpdateType::Update,
            other => {
                PropertyUpdateType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for PropertyUpdateType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PropertyUpdateType::from(s))
    }
}
impl PropertyUpdateType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PropertyUpdateType::Create => "CREATE",
            PropertyUpdateType::Delete => "DELETE",
            PropertyUpdateType::Update => "UPDATE",
            PropertyUpdateType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CREATE", "DELETE", "UPDATE"]
    }
}
impl AsRef<str> for PropertyUpdateType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that specifies a value for a property.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataValue {
    /// <p>A Boolean value.</p>
    #[doc(hidden)]
    pub boolean_value: std::option::Option<bool>,
    /// <p>A double value.</p>
    #[doc(hidden)]
    pub double_value: std::option::Option<f64>,
    /// <p>An integer value.</p>
    #[doc(hidden)]
    pub integer_value: std::option::Option<i32>,
    /// <p>A long value.</p>
    #[doc(hidden)]
    pub long_value: std::option::Option<i64>,
    /// <p>A string value.</p>
    #[doc(hidden)]
    pub string_value: std::option::Option<std::string::String>,
    /// <p>A list of multiple values.</p>
    #[doc(hidden)]
    pub list_value: std::option::Option<std::vec::Vec<crate::model::DataValue>>,
    /// <p>An object that maps strings to multiple <code>DataValue</code> objects.</p>
    #[doc(hidden)]
    pub map_value: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::DataValue>,
    >,
    /// <p>A value that relates a component to another component.</p>
    #[doc(hidden)]
    pub relationship_value: std::option::Option<crate::model::RelationshipValue>,
    /// <p>An expression that produces the value.</p>
    #[doc(hidden)]
    pub expression: std::option::Option<std::string::String>,
}
impl DataValue {
    /// <p>A Boolean value.</p>
    pub fn boolean_value(&self) -> std::option::Option<bool> {
        self.boolean_value
    }
    /// <p>A double value.</p>
    pub fn double_value(&self) -> std::option::Option<f64> {
        self.double_value
    }
    /// <p>An integer value.</p>
    pub fn integer_value(&self) -> std::option::Option<i32> {
        self.integer_value
    }
    /// <p>A long value.</p>
    pub fn long_value(&self) -> std::option::Option<i64> {
        self.long_value
    }
    /// <p>A string value.</p>
    pub fn string_value(&self) -> std::option::Option<&str> {
        self.string_value.as_deref()
    }
    /// <p>A list of multiple values.</p>
    pub fn list_value(&self) -> std::option::Option<&[crate::model::DataValue]> {
        self.list_value.as_deref()
    }
    /// <p>An object that maps strings to multiple <code>DataValue</code> objects.</p>
    pub fn map_value(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, crate::model::DataValue>>
    {
        self.map_value.as_ref()
    }
    /// <p>A value that relates a component to another component.</p>
    pub fn relationship_value(&self) -> std::option::Option<&crate::model::RelationshipValue> {
        self.relationship_value.as_ref()
    }
    /// <p>An expression that produces the value.</p>
    pub fn expression(&self) -> std::option::Option<&str> {
        self.expression.as_deref()
    }
}
/// See [`DataValue`](crate::model::DataValue).
pub mod data_value {

    /// A builder for [`DataValue`](crate::model::DataValue).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) boolean_value: std::option::Option<bool>,
        pub(crate) double_value: std::option::Option<f64>,
        pub(crate) integer_value: std::option::Option<i32>,
        pub(crate) long_value: std::option::Option<i64>,
        pub(crate) string_value: std::option::Option<std::string::String>,
        pub(crate) list_value: std::option::Option<std::vec::Vec<crate::model::DataValue>>,
        pub(crate) map_value: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::DataValue>,
        >,
        pub(crate) relationship_value: std::option::Option<crate::model::RelationshipValue>,
        pub(crate) expression: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A Boolean value.</p>
        pub fn boolean_value(mut self, input: bool) -> Self {
            self.boolean_value = Some(input);
            self
        }
        /// <p>A Boolean value.</p>
        pub fn set_boolean_value(mut self, input: std::option::Option<bool>) -> Self {
            self.boolean_value = input;
            self
        }
        /// <p>A double value.</p>
        pub fn double_value(mut self, input: f64) -> Self {
            self.double_value = Some(input);
            self
        }
        /// <p>A double value.</p>
        pub fn set_double_value(mut self, input: std::option::Option<f64>) -> Self {
            self.double_value = input;
            self
        }
        /// <p>An integer value.</p>
        pub fn integer_value(mut self, input: i32) -> Self {
            self.integer_value = Some(input);
            self
        }
        /// <p>An integer value.</p>
        pub fn set_integer_value(mut self, input: std::option::Option<i32>) -> Self {
            self.integer_value = input;
            self
        }
        /// <p>A long value.</p>
        pub fn long_value(mut self, input: i64) -> Self {
            self.long_value = Some(input);
            self
        }
        /// <p>A long value.</p>
        pub fn set_long_value(mut self, input: std::option::Option<i64>) -> Self {
            self.long_value = input;
            self
        }
        /// <p>A string value.</p>
        pub fn string_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.string_value = Some(input.into());
            self
        }
        /// <p>A string value.</p>
        pub fn set_string_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.string_value = input;
            self
        }
        /// Appends an item to `list_value`.
        ///
        /// To override the contents of this collection use [`set_list_value`](Self::set_list_value).
        ///
        /// <p>A list of multiple values.</p>
        pub fn list_value(mut self, input: crate::model::DataValue) -> Self {
            let mut v = self.list_value.unwrap_or_default();
            v.push(input);
            self.list_value = Some(v);
            self
        }
        /// <p>A list of multiple values.</p>
        pub fn set_list_value(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataValue>>,
        ) -> Self {
            self.list_value = input;
            self
        }
        /// Adds a key-value pair to `map_value`.
        ///
        /// To override the contents of this collection use [`set_map_value`](Self::set_map_value).
        ///
        /// <p>An object that maps strings to multiple <code>DataValue</code> objects.</p>
        pub fn map_value(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::DataValue,
        ) -> Self {
            let mut hash_map = self.map_value.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.map_value = Some(hash_map);
            self
        }
        /// <p>An object that maps strings to multiple <code>DataValue</code> objects.</p>
        pub fn set_map_value(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::DataValue>,
            >,
        ) -> Self {
            self.map_value = input;
            self
        }
        /// <p>A value that relates a component to another component.</p>
        pub fn relationship_value(mut self, input: crate::model::RelationshipValue) -> Self {
            self.relationship_value = Some(input);
            self
        }
        /// <p>A value that relates a component to another component.</p>
        pub fn set_relationship_value(
            mut self,
            input: std::option::Option<crate::model::RelationshipValue>,
        ) -> Self {
            self.relationship_value = input;
            self
        }
        /// <p>An expression that produces the value.</p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.expression = Some(input.into());
            self
        }
        /// <p>An expression that produces the value.</p>
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expression = input;
            self
        }
        /// Consumes the builder and constructs a [`DataValue`](crate::model::DataValue).
        pub fn build(self) -> crate::model::DataValue {
            crate::model::DataValue {
                boolean_value: self.boolean_value,
                double_value: self.double_value,
                integer_value: self.integer_value,
                long_value: self.long_value,
                string_value: self.string_value,
                list_value: self.list_value,
                map_value: self.map_value,
                relationship_value: self.relationship_value,
                expression: self.expression,
            }
        }
    }
}
impl DataValue {
    /// Creates a new builder-style object to manufacture [`DataValue`](crate::model::DataValue).
    pub fn builder() -> crate::model::data_value::Builder {
        crate::model::data_value::Builder::default()
    }
}

/// <p>A value that associates a component and an entity.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RelationshipValue {
    /// <p>The ID of the target entity associated with this relationship value.</p>
    #[doc(hidden)]
    pub target_entity_id: std::option::Option<std::string::String>,
    /// <p>The name of the target component associated with the relationship value.</p>
    #[doc(hidden)]
    pub target_component_name: std::option::Option<std::string::String>,
}
impl RelationshipValue {
    /// <p>The ID of the target entity associated with this relationship value.</p>
    pub fn target_entity_id(&self) -> std::option::Option<&str> {
        self.target_entity_id.as_deref()
    }
    /// <p>The name of the target component associated with the relationship value.</p>
    pub fn target_component_name(&self) -> std::option::Option<&str> {
        self.target_component_name.as_deref()
    }
}
/// See [`RelationshipValue`](crate::model::RelationshipValue).
pub mod relationship_value {

    /// A builder for [`RelationshipValue`](crate::model::RelationshipValue).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_entity_id: std::option::Option<std::string::String>,
        pub(crate) target_component_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the target entity associated with this relationship value.</p>
        pub fn target_entity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_entity_id = Some(input.into());
            self
        }
        /// <p>The ID of the target entity associated with this relationship value.</p>
        pub fn set_target_entity_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_entity_id = input;
            self
        }
        /// <p>The name of the target component associated with the relationship value.</p>
        pub fn target_component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_component_name = Some(input.into());
            self
        }
        /// <p>The name of the target component associated with the relationship value.</p>
        pub fn set_target_component_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_component_name = input;
            self
        }
        /// Consumes the builder and constructs a [`RelationshipValue`](crate::model::RelationshipValue).
        pub fn build(self) -> crate::model::RelationshipValue {
            crate::model::RelationshipValue {
                target_entity_id: self.target_entity_id,
                target_component_name: self.target_component_name,
            }
        }
    }
}
impl RelationshipValue {
    /// Creates a new builder-style object to manufacture [`RelationshipValue`](crate::model::RelationshipValue).
    pub fn builder() -> crate::model::relationship_value::Builder {
        crate::model::relationship_value::Builder::default()
    }
}

/// <p>An object that sets information about a property.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyDefinitionRequest {
    /// <p>An object that contains information about the data type.</p>
    #[doc(hidden)]
    pub data_type: std::option::Option<crate::model::DataType>,
    /// <p>A Boolean value that specifies whether the property is required.</p>
    #[doc(hidden)]
    pub is_required_in_entity: std::option::Option<bool>,
    /// <p>A Boolean value that specifies whether the property ID comes from an external data store.</p>
    #[doc(hidden)]
    pub is_external_id: std::option::Option<bool>,
    /// <p>A Boolean value that specifies whether the property is stored externally.</p>
    #[doc(hidden)]
    pub is_stored_externally: std::option::Option<bool>,
    /// <p>A Boolean value that specifies whether the property consists of time series data.</p>
    #[doc(hidden)]
    pub is_time_series: std::option::Option<bool>,
    /// <p>An object that contains the default value.</p>
    #[doc(hidden)]
    pub default_value: std::option::Option<crate::model::DataValue>,
    /// <p>A mapping that specifies configuration information about the property. Use this field to specify information that you read from and write to an external source.</p>
    #[doc(hidden)]
    pub configuration:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A friendly name for the property.</p>
    #[doc(hidden)]
    pub display_name: std::option::Option<std::string::String>,
}
impl PropertyDefinitionRequest {
    /// <p>An object that contains information about the data type.</p>
    pub fn data_type(&self) -> std::option::Option<&crate::model::DataType> {
        self.data_type.as_ref()
    }
    /// <p>A Boolean value that specifies whether the property is required.</p>
    pub fn is_required_in_entity(&self) -> std::option::Option<bool> {
        self.is_required_in_entity
    }
    /// <p>A Boolean value that specifies whether the property ID comes from an external data store.</p>
    pub fn is_external_id(&self) -> std::option::Option<bool> {
        self.is_external_id
    }
    /// <p>A Boolean value that specifies whether the property is stored externally.</p>
    pub fn is_stored_externally(&self) -> std::option::Option<bool> {
        self.is_stored_externally
    }
    /// <p>A Boolean value that specifies whether the property consists of time series data.</p>
    pub fn is_time_series(&self) -> std::option::Option<bool> {
        self.is_time_series
    }
    /// <p>An object that contains the default value.</p>
    pub fn default_value(&self) -> std::option::Option<&crate::model::DataValue> {
        self.default_value.as_ref()
    }
    /// <p>A mapping that specifies configuration information about the property. Use this field to specify information that you read from and write to an external source.</p>
    pub fn configuration(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.configuration.as_ref()
    }
    /// <p>A friendly name for the property.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
}
/// See [`PropertyDefinitionRequest`](crate::model::PropertyDefinitionRequest).
pub mod property_definition_request {

    /// A builder for [`PropertyDefinitionRequest`](crate::model::PropertyDefinitionRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_type: std::option::Option<crate::model::DataType>,
        pub(crate) is_required_in_entity: std::option::Option<bool>,
        pub(crate) is_external_id: std::option::Option<bool>,
        pub(crate) is_stored_externally: std::option::Option<bool>,
        pub(crate) is_time_series: std::option::Option<bool>,
        pub(crate) default_value: std::option::Option<crate::model::DataValue>,
        pub(crate) configuration: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) display_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An object that contains information about the data type.</p>
        pub fn data_type(mut self, input: crate::model::DataType) -> Self {
            self.data_type = Some(input);
            self
        }
        /// <p>An object that contains information about the data type.</p>
        pub fn set_data_type(mut self, input: std::option::Option<crate::model::DataType>) -> Self {
            self.data_type = input;
            self
        }
        /// <p>A Boolean value that specifies whether the property is required.</p>
        pub fn is_required_in_entity(mut self, input: bool) -> Self {
            self.is_required_in_entity = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property is required.</p>
        pub fn set_is_required_in_entity(mut self, input: std::option::Option<bool>) -> Self {
            self.is_required_in_entity = input;
            self
        }
        /// <p>A Boolean value that specifies whether the property ID comes from an external data store.</p>
        pub fn is_external_id(mut self, input: bool) -> Self {
            self.is_external_id = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property ID comes from an external data store.</p>
        pub fn set_is_external_id(mut self, input: std::option::Option<bool>) -> Self {
            self.is_external_id = input;
            self
        }
        /// <p>A Boolean value that specifies whether the property is stored externally.</p>
        pub fn is_stored_externally(mut self, input: bool) -> Self {
            self.is_stored_externally = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property is stored externally.</p>
        pub fn set_is_stored_externally(mut self, input: std::option::Option<bool>) -> Self {
            self.is_stored_externally = input;
            self
        }
        /// <p>A Boolean value that specifies whether the property consists of time series data.</p>
        pub fn is_time_series(mut self, input: bool) -> Self {
            self.is_time_series = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property consists of time series data.</p>
        pub fn set_is_time_series(mut self, input: std::option::Option<bool>) -> Self {
            self.is_time_series = input;
            self
        }
        /// <p>An object that contains the default value.</p>
        pub fn default_value(mut self, input: crate::model::DataValue) -> Self {
            self.default_value = Some(input);
            self
        }
        /// <p>An object that contains the default value.</p>
        pub fn set_default_value(
            mut self,
            input: std::option::Option<crate::model::DataValue>,
        ) -> Self {
            self.default_value = input;
            self
        }
        /// Adds a key-value pair to `configuration`.
        ///
        /// To override the contents of this collection use [`set_configuration`](Self::set_configuration).
        ///
        /// <p>A mapping that specifies configuration information about the property. Use this field to specify information that you read from and write to an external source.</p>
        pub fn configuration(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.configuration.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.configuration = Some(hash_map);
            self
        }
        /// <p>A mapping that specifies configuration information about the property. Use this field to specify information that you read from and write to an external source.</p>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// <p>A friendly name for the property.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>A friendly name for the property.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// Consumes the builder and constructs a [`PropertyDefinitionRequest`](crate::model::PropertyDefinitionRequest).
        pub fn build(self) -> crate::model::PropertyDefinitionRequest {
            crate::model::PropertyDefinitionRequest {
                data_type: self.data_type,
                is_required_in_entity: self.is_required_in_entity,
                is_external_id: self.is_external_id,
                is_stored_externally: self.is_stored_externally,
                is_time_series: self.is_time_series,
                default_value: self.default_value,
                configuration: self.configuration,
                display_name: self.display_name,
            }
        }
    }
}
impl PropertyDefinitionRequest {
    /// Creates a new builder-style object to manufacture [`PropertyDefinitionRequest`](crate::model::PropertyDefinitionRequest).
    pub fn builder() -> crate::model::property_definition_request::Builder {
        crate::model::property_definition_request::Builder::default()
    }
}

/// <p>An object that specifies the data type of a property.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataType {
    /// <p>The underlying type of the data type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::Type>,
    /// <p>The nested type in the data type.</p>
    #[doc(hidden)]
    pub nested_type: std::option::Option<std::boxed::Box<crate::model::DataType>>,
    /// <p>The allowed values for this data type.</p>
    #[doc(hidden)]
    pub allowed_values: std::option::Option<std::vec::Vec<crate::model::DataValue>>,
    /// <p>The unit of measure used in this data type.</p>
    #[doc(hidden)]
    pub unit_of_measure: std::option::Option<std::string::String>,
    /// <p>A relationship that associates a component with another component.</p>
    #[doc(hidden)]
    pub relationship: std::option::Option<crate::model::Relationship>,
}
impl DataType {
    /// <p>The underlying type of the data type.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::Type> {
        self.r#type.as_ref()
    }
    /// <p>The nested type in the data type.</p>
    pub fn nested_type(&self) -> std::option::Option<&crate::model::DataType> {
        self.nested_type.as_deref()
    }
    /// <p>The allowed values for this data type.</p>
    pub fn allowed_values(&self) -> std::option::Option<&[crate::model::DataValue]> {
        self.allowed_values.as_deref()
    }
    /// <p>The unit of measure used in this data type.</p>
    pub fn unit_of_measure(&self) -> std::option::Option<&str> {
        self.unit_of_measure.as_deref()
    }
    /// <p>A relationship that associates a component with another component.</p>
    pub fn relationship(&self) -> std::option::Option<&crate::model::Relationship> {
        self.relationship.as_ref()
    }
}
/// See [`DataType`](crate::model::DataType).
pub mod data_type {

    /// A builder for [`DataType`](crate::model::DataType).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::Type>,
        pub(crate) nested_type: std::option::Option<std::boxed::Box<crate::model::DataType>>,
        pub(crate) allowed_values: std::option::Option<std::vec::Vec<crate::model::DataValue>>,
        pub(crate) unit_of_measure: std::option::Option<std::string::String>,
        pub(crate) relationship: std::option::Option<crate::model::Relationship>,
    }
    impl Builder {
        /// <p>The underlying type of the data type.</p>
        pub fn r#type(mut self, input: crate::model::Type) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The underlying type of the data type.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::Type>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The nested type in the data type.</p>
        pub fn nested_type(
            mut self,
            input: impl Into<std::boxed::Box<crate::model::DataType>>,
        ) -> Self {
            self.nested_type = Some(input.into());
            self
        }
        /// <p>The nested type in the data type.</p>
        pub fn set_nested_type(
            mut self,
            input: std::option::Option<std::boxed::Box<crate::model::DataType>>,
        ) -> Self {
            self.nested_type = input;
            self
        }
        /// Appends an item to `allowed_values`.
        ///
        /// To override the contents of this collection use [`set_allowed_values`](Self::set_allowed_values).
        ///
        /// <p>The allowed values for this data type.</p>
        pub fn allowed_values(mut self, input: crate::model::DataValue) -> Self {
            let mut v = self.allowed_values.unwrap_or_default();
            v.push(input);
            self.allowed_values = Some(v);
            self
        }
        /// <p>The allowed values for this data type.</p>
        pub fn set_allowed_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataValue>>,
        ) -> Self {
            self.allowed_values = input;
            self
        }
        /// <p>The unit of measure used in this data type.</p>
        pub fn unit_of_measure(mut self, input: impl Into<std::string::String>) -> Self {
            self.unit_of_measure = Some(input.into());
            self
        }
        /// <p>The unit of measure used in this data type.</p>
        pub fn set_unit_of_measure(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.unit_of_measure = input;
            self
        }
        /// <p>A relationship that associates a component with another component.</p>
        pub fn relationship(mut self, input: crate::model::Relationship) -> Self {
            self.relationship = Some(input);
            self
        }
        /// <p>A relationship that associates a component with another component.</p>
        pub fn set_relationship(
            mut self,
            input: std::option::Option<crate::model::Relationship>,
        ) -> Self {
            self.relationship = input;
            self
        }
        /// Consumes the builder and constructs a [`DataType`](crate::model::DataType).
        pub fn build(self) -> crate::model::DataType {
            crate::model::DataType {
                r#type: self.r#type,
                nested_type: self.nested_type,
                allowed_values: self.allowed_values,
                unit_of_measure: self.unit_of_measure,
                relationship: self.relationship,
            }
        }
    }
}
impl DataType {
    /// Creates a new builder-style object to manufacture [`DataType`](crate::model::DataType).
    pub fn builder() -> crate::model::data_type::Builder {
        crate::model::data_type::Builder::default()
    }
}

/// <p>An object that specifies a relationship with another component type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Relationship {
    /// <p>The ID of the target component type associated with this relationship.</p>
    #[doc(hidden)]
    pub target_component_type_id: std::option::Option<std::string::String>,
    /// <p>The type of the relationship.</p>
    #[doc(hidden)]
    pub relationship_type: std::option::Option<std::string::String>,
}
impl Relationship {
    /// <p>The ID of the target component type associated with this relationship.</p>
    pub fn target_component_type_id(&self) -> std::option::Option<&str> {
        self.target_component_type_id.as_deref()
    }
    /// <p>The type of the relationship.</p>
    pub fn relationship_type(&self) -> std::option::Option<&str> {
        self.relationship_type.as_deref()
    }
}
/// See [`Relationship`](crate::model::Relationship).
pub mod relationship {

    /// A builder for [`Relationship`](crate::model::Relationship).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_component_type_id: std::option::Option<std::string::String>,
        pub(crate) relationship_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the target component type associated with this relationship.</p>
        pub fn target_component_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_component_type_id = Some(input.into());
            self
        }
        /// <p>The ID of the target component type associated with this relationship.</p>
        pub fn set_target_component_type_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_component_type_id = input;
            self
        }
        /// <p>The type of the relationship.</p>
        pub fn relationship_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.relationship_type = Some(input.into());
            self
        }
        /// <p>The type of the relationship.</p>
        pub fn set_relationship_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relationship_type = input;
            self
        }
        /// Consumes the builder and constructs a [`Relationship`](crate::model::Relationship).
        pub fn build(self) -> crate::model::Relationship {
            crate::model::Relationship {
                target_component_type_id: self.target_component_type_id,
                relationship_type: self.relationship_type,
            }
        }
    }
}
impl Relationship {
    /// Creates a new builder-style object to manufacture [`Relationship`](crate::model::Relationship).
    pub fn builder() -> crate::model::relationship::Builder {
        crate::model::relationship::Builder::default()
    }
}

/// When writing a match expression against `Type`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let type = unimplemented!();
/// match type {
///     Type::Boolean => { /* ... */ },
///     Type::Double => { /* ... */ },
///     Type::Integer => { /* ... */ },
///     Type::List => { /* ... */ },
///     Type::Long => { /* ... */ },
///     Type::Map => { /* ... */ },
///     Type::Relationship => { /* ... */ },
///     Type::String => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `type` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Type::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Type::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Type::NewFeature` is defined.
/// Specifically, when `type` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Type::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Type {
    #[allow(missing_docs)] // documentation missing in model
    Boolean,
    #[allow(missing_docs)] // documentation missing in model
    Double,
    #[allow(missing_docs)] // documentation missing in model
    Integer,
    #[allow(missing_docs)] // documentation missing in model
    List,
    #[allow(missing_docs)] // documentation missing in model
    Long,
    #[allow(missing_docs)] // documentation missing in model
    Map,
    #[allow(missing_docs)] // documentation missing in model
    Relationship,
    #[allow(missing_docs)] // documentation missing in model
    String,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Type {
    fn from(s: &str) -> Self {
        match s {
            "BOOLEAN" => Type::Boolean,
            "DOUBLE" => Type::Double,
            "INTEGER" => Type::Integer,
            "LIST" => Type::List,
            "LONG" => Type::Long,
            "MAP" => Type::Map,
            "RELATIONSHIP" => Type::Relationship,
            "STRING" => Type::String,
            other => Type::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Type {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Type::from(s))
    }
}
impl Type {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Type::Boolean => "BOOLEAN",
            Type::Double => "DOUBLE",
            Type::Integer => "INTEGER",
            Type::List => "LIST",
            Type::Long => "LONG",
            Type::Map => "MAP",
            Type::Relationship => "RELATIONSHIP",
            Type::String => "STRING",
            Type::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BOOLEAN",
            "DOUBLE",
            "INTEGER",
            "LIST",
            "LONG",
            "MAP",
            "RELATIONSHIP",
            "STRING",
        ]
    }
}
impl AsRef<str> for Type {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ComponentUpdateType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let componentupdatetype = unimplemented!();
/// match componentupdatetype {
///     ComponentUpdateType::Create => { /* ... */ },
///     ComponentUpdateType::Delete => { /* ... */ },
///     ComponentUpdateType::Update => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `componentupdatetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ComponentUpdateType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ComponentUpdateType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ComponentUpdateType::NewFeature` is defined.
/// Specifically, when `componentupdatetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ComponentUpdateType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ComponentUpdateType {
    #[allow(missing_docs)] // documentation missing in model
    Create,
    #[allow(missing_docs)] // documentation missing in model
    Delete,
    #[allow(missing_docs)] // documentation missing in model
    Update,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ComponentUpdateType {
    fn from(s: &str) -> Self {
        match s {
            "CREATE" => ComponentUpdateType::Create,
            "DELETE" => ComponentUpdateType::Delete,
            "UPDATE" => ComponentUpdateType::Update,
            other => {
                ComponentUpdateType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ComponentUpdateType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ComponentUpdateType::from(s))
    }
}
impl ComponentUpdateType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ComponentUpdateType::Create => "CREATE",
            ComponentUpdateType::Delete => "DELETE",
            ComponentUpdateType::Update => "UPDATE",
            ComponentUpdateType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CREATE", "DELETE", "UPDATE"]
    }
}
impl AsRef<str> for ComponentUpdateType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyGroupRequest {
    /// <p>The group type.</p>
    #[doc(hidden)]
    pub group_type: std::option::Option<crate::model::GroupType>,
    /// <p>The names of properties.</p>
    #[doc(hidden)]
    pub property_names: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl PropertyGroupRequest {
    /// <p>The group type.</p>
    pub fn group_type(&self) -> std::option::Option<&crate::model::GroupType> {
        self.group_type.as_ref()
    }
    /// <p>The names of properties.</p>
    pub fn property_names(&self) -> std::option::Option<&[std::string::String]> {
        self.property_names.as_deref()
    }
}
/// See [`PropertyGroupRequest`](crate::model::PropertyGroupRequest).
pub mod property_group_request {

    /// A builder for [`PropertyGroupRequest`](crate::model::PropertyGroupRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_type: std::option::Option<crate::model::GroupType>,
        pub(crate) property_names: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The group type.</p>
        pub fn group_type(mut self, input: crate::model::GroupType) -> Self {
            self.group_type = Some(input);
            self
        }
        /// <p>The group type.</p>
        pub fn set_group_type(
            mut self,
            input: std::option::Option<crate::model::GroupType>,
        ) -> Self {
            self.group_type = input;
            self
        }
        /// Appends an item to `property_names`.
        ///
        /// To override the contents of this collection use [`set_property_names`](Self::set_property_names).
        ///
        /// <p>The names of properties.</p>
        pub fn property_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.property_names.unwrap_or_default();
            v.push(input.into());
            self.property_names = Some(v);
            self
        }
        /// <p>The names of properties.</p>
        pub fn set_property_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.property_names = input;
            self
        }
        /// Consumes the builder and constructs a [`PropertyGroupRequest`](crate::model::PropertyGroupRequest).
        pub fn build(self) -> crate::model::PropertyGroupRequest {
            crate::model::PropertyGroupRequest {
                group_type: self.group_type,
                property_names: self.property_names,
            }
        }
    }
}
impl PropertyGroupRequest {
    /// Creates a new builder-style object to manufacture [`PropertyGroupRequest`](crate::model::PropertyGroupRequest).
    pub fn builder() -> crate::model::property_group_request::Builder {
        crate::model::property_group_request::Builder::default()
    }
}

/// <p>The function request body.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FunctionRequest {
    /// <p>The required properties of the function.</p>
    #[doc(hidden)]
    pub required_properties: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The scope of the function.</p>
    #[doc(hidden)]
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>The data connector.</p>
    #[doc(hidden)]
    pub implemented_by: std::option::Option<crate::model::DataConnector>,
}
impl FunctionRequest {
    /// <p>The required properties of the function.</p>
    pub fn required_properties(&self) -> std::option::Option<&[std::string::String]> {
        self.required_properties.as_deref()
    }
    /// <p>The scope of the function.</p>
    pub fn scope(&self) -> std::option::Option<&crate::model::Scope> {
        self.scope.as_ref()
    }
    /// <p>The data connector.</p>
    pub fn implemented_by(&self) -> std::option::Option<&crate::model::DataConnector> {
        self.implemented_by.as_ref()
    }
}
/// See [`FunctionRequest`](crate::model::FunctionRequest).
pub mod function_request {

    /// A builder for [`FunctionRequest`](crate::model::FunctionRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) required_properties: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) implemented_by: std::option::Option<crate::model::DataConnector>,
    }
    impl Builder {
        /// Appends an item to `required_properties`.
        ///
        /// To override the contents of this collection use [`set_required_properties`](Self::set_required_properties).
        ///
        /// <p>The required properties of the function.</p>
        pub fn required_properties(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.required_properties.unwrap_or_default();
            v.push(input.into());
            self.required_properties = Some(v);
            self
        }
        /// <p>The required properties of the function.</p>
        pub fn set_required_properties(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.required_properties = input;
            self
        }
        /// <p>The scope of the function.</p>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        /// <p>The scope of the function.</p>
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>The data connector.</p>
        pub fn implemented_by(mut self, input: crate::model::DataConnector) -> Self {
            self.implemented_by = Some(input);
            self
        }
        /// <p>The data connector.</p>
        pub fn set_implemented_by(
            mut self,
            input: std::option::Option<crate::model::DataConnector>,
        ) -> Self {
            self.implemented_by = input;
            self
        }
        /// Consumes the builder and constructs a [`FunctionRequest`](crate::model::FunctionRequest).
        pub fn build(self) -> crate::model::FunctionRequest {
            crate::model::FunctionRequest {
                required_properties: self.required_properties,
                scope: self.scope,
                implemented_by: self.implemented_by,
            }
        }
    }
}
impl FunctionRequest {
    /// Creates a new builder-style object to manufacture [`FunctionRequest`](crate::model::FunctionRequest).
    pub fn builder() -> crate::model::function_request::Builder {
        crate::model::function_request::Builder::default()
    }
}

/// <p>The data connector.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataConnector {
    /// <p>The Lambda function associated with this data connector.</p>
    #[doc(hidden)]
    pub lambda: std::option::Option<crate::model::LambdaFunction>,
    /// <p>A Boolean value that specifies whether the data connector is native to IoT TwinMaker.</p>
    #[doc(hidden)]
    pub is_native: std::option::Option<bool>,
}
impl DataConnector {
    /// <p>The Lambda function associated with this data connector.</p>
    pub fn lambda(&self) -> std::option::Option<&crate::model::LambdaFunction> {
        self.lambda.as_ref()
    }
    /// <p>A Boolean value that specifies whether the data connector is native to IoT TwinMaker.</p>
    pub fn is_native(&self) -> std::option::Option<bool> {
        self.is_native
    }
}
/// See [`DataConnector`](crate::model::DataConnector).
pub mod data_connector {

    /// A builder for [`DataConnector`](crate::model::DataConnector).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lambda: std::option::Option<crate::model::LambdaFunction>,
        pub(crate) is_native: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The Lambda function associated with this data connector.</p>
        pub fn lambda(mut self, input: crate::model::LambdaFunction) -> Self {
            self.lambda = Some(input);
            self
        }
        /// <p>The Lambda function associated with this data connector.</p>
        pub fn set_lambda(
            mut self,
            input: std::option::Option<crate::model::LambdaFunction>,
        ) -> Self {
            self.lambda = input;
            self
        }
        /// <p>A Boolean value that specifies whether the data connector is native to IoT TwinMaker.</p>
        pub fn is_native(mut self, input: bool) -> Self {
            self.is_native = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the data connector is native to IoT TwinMaker.</p>
        pub fn set_is_native(mut self, input: std::option::Option<bool>) -> Self {
            self.is_native = input;
            self
        }
        /// Consumes the builder and constructs a [`DataConnector`](crate::model::DataConnector).
        pub fn build(self) -> crate::model::DataConnector {
            crate::model::DataConnector {
                lambda: self.lambda,
                is_native: self.is_native,
            }
        }
    }
}
impl DataConnector {
    /// Creates a new builder-style object to manufacture [`DataConnector`](crate::model::DataConnector).
    pub fn builder() -> crate::model::data_connector::Builder {
        crate::model::data_connector::Builder::default()
    }
}

/// <p>The Lambda function.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LambdaFunction {
    /// <p>The ARN of the Lambda function.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl LambdaFunction {
    /// <p>The ARN of the Lambda function.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
/// See [`LambdaFunction`](crate::model::LambdaFunction).
pub mod lambda_function {

    /// A builder for [`LambdaFunction`](crate::model::LambdaFunction).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the Lambda function.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the Lambda function.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`LambdaFunction`](crate::model::LambdaFunction).
        pub fn build(self) -> crate::model::LambdaFunction {
            crate::model::LambdaFunction { arn: self.arn }
        }
    }
}
impl LambdaFunction {
    /// Creates a new builder-style object to manufacture [`LambdaFunction`](crate::model::LambdaFunction).
    pub fn builder() -> crate::model::lambda_function::Builder {
        crate::model::lambda_function::Builder::default()
    }
}

/// When writing a match expression against `Scope`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let scope = unimplemented!();
/// match scope {
///     Scope::Entity => { /* ... */ },
///     Scope::Workspace => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `scope` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Scope::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Scope::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Scope::NewFeature` is defined.
/// Specifically, when `scope` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Scope::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Scope {
    #[allow(missing_docs)] // documentation missing in model
    Entity,
    #[allow(missing_docs)] // documentation missing in model
    Workspace,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Scope {
    fn from(s: &str) -> Self {
        match s {
            "ENTITY" => Scope::Entity,
            "WORKSPACE" => Scope::Workspace,
            other => Scope::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Scope {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Scope::from(s))
    }
}
impl Scope {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Scope::Entity => "ENTITY",
            Scope::Workspace => "WORKSPACE",
            Scope::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ENTITY", "WORKSPACE"]
    }
}
impl AsRef<str> for Scope {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that contains information about a workspace.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkspaceSummary {
    /// <p>The ID of the workspace.</p>
    #[doc(hidden)]
    pub workspace_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the workspace.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The description of the workspace.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The date and time when the workspace was created.</p>
    #[doc(hidden)]
    pub creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time when the workspace was last updated.</p>
    #[doc(hidden)]
    pub update_date_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl WorkspaceSummary {
    /// <p>The ID of the workspace.</p>
    pub fn workspace_id(&self) -> std::option::Option<&str> {
        self.workspace_id.as_deref()
    }
    /// <p>The ARN of the workspace.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The description of the workspace.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The date and time when the workspace was created.</p>
    pub fn creation_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date_time.as_ref()
    }
    /// <p>The date and time when the workspace was last updated.</p>
    pub fn update_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_date_time.as_ref()
    }
}
/// See [`WorkspaceSummary`](crate::model::WorkspaceSummary).
pub mod workspace_summary {

    /// A builder for [`WorkspaceSummary`](crate::model::WorkspaceSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workspace_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_date_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The ID of the workspace.</p>
        pub fn workspace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workspace_id = Some(input.into());
            self
        }
        /// <p>The ID of the workspace.</p>
        pub fn set_workspace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workspace_id = input;
            self
        }
        /// <p>The ARN of the workspace.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the workspace.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The description of the workspace.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the workspace.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The date and time when the workspace was created.</p>
        pub fn creation_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date_time = Some(input);
            self
        }
        /// <p>The date and time when the workspace was created.</p>
        pub fn set_creation_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date_time = input;
            self
        }
        /// <p>The date and time when the workspace was last updated.</p>
        pub fn update_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_date_time = Some(input);
            self
        }
        /// <p>The date and time when the workspace was last updated.</p>
        pub fn set_update_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_date_time = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkspaceSummary`](crate::model::WorkspaceSummary).
        pub fn build(self) -> crate::model::WorkspaceSummary {
            crate::model::WorkspaceSummary {
                workspace_id: self.workspace_id,
                arn: self.arn,
                description: self.description,
                creation_date_time: self.creation_date_time,
                update_date_time: self.update_date_time,
            }
        }
    }
}
impl WorkspaceSummary {
    /// Creates a new builder-style object to manufacture [`WorkspaceSummary`](crate::model::WorkspaceSummary).
    pub fn builder() -> crate::model::workspace_summary::Builder {
        crate::model::workspace_summary::Builder::default()
    }
}

/// <p>The sync resource summary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SyncResourceSummary {
    /// <p>The resource type.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::SyncResourceType>,
    /// <p>The external Id.</p>
    #[doc(hidden)]
    pub external_id: std::option::Option<std::string::String>,
    /// <p>The resource Id.</p>
    #[doc(hidden)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The sync resource summary status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::SyncResourceStatus>,
    /// <p>The update date and time.</p>
    #[doc(hidden)]
    pub update_date_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl SyncResourceSummary {
    /// <p>The resource type.</p>
    pub fn resource_type(&self) -> std::option::Option<&crate::model::SyncResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>The external Id.</p>
    pub fn external_id(&self) -> std::option::Option<&str> {
        self.external_id.as_deref()
    }
    /// <p>The resource Id.</p>
    pub fn resource_id(&self) -> std::option::Option<&str> {
        self.resource_id.as_deref()
    }
    /// <p>The sync resource summary status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::SyncResourceStatus> {
        self.status.as_ref()
    }
    /// <p>The update date and time.</p>
    pub fn update_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_date_time.as_ref()
    }
}
/// See [`SyncResourceSummary`](crate::model::SyncResourceSummary).
pub mod sync_resource_summary {

    /// A builder for [`SyncResourceSummary`](crate::model::SyncResourceSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_type: std::option::Option<crate::model::SyncResourceType>,
        pub(crate) external_id: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::SyncResourceStatus>,
        pub(crate) update_date_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The resource type.</p>
        pub fn resource_type(mut self, input: crate::model::SyncResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>The resource type.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::SyncResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The external Id.</p>
        pub fn external_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.external_id = Some(input.into());
            self
        }
        /// <p>The external Id.</p>
        pub fn set_external_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.external_id = input;
            self
        }
        /// <p>The resource Id.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The resource Id.</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The sync resource summary status.</p>
        pub fn status(mut self, input: crate::model::SyncResourceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The sync resource summary status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::SyncResourceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The update date and time.</p>
        pub fn update_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_date_time = Some(input);
            self
        }
        /// <p>The update date and time.</p>
        pub fn set_update_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_date_time = input;
            self
        }
        /// Consumes the builder and constructs a [`SyncResourceSummary`](crate::model::SyncResourceSummary).
        pub fn build(self) -> crate::model::SyncResourceSummary {
            crate::model::SyncResourceSummary {
                resource_type: self.resource_type,
                external_id: self.external_id,
                resource_id: self.resource_id,
                status: self.status,
                update_date_time: self.update_date_time,
            }
        }
    }
}
impl SyncResourceSummary {
    /// Creates a new builder-style object to manufacture [`SyncResourceSummary`](crate::model::SyncResourceSummary).
    pub fn builder() -> crate::model::sync_resource_summary::Builder {
        crate::model::sync_resource_summary::Builder::default()
    }
}

/// <p>The sync resource status.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SyncResourceStatus {
    /// <p>The sync resource status state.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::SyncResourceState>,
    /// <p>The status error.</p>
    #[doc(hidden)]
    pub error: std::option::Option<crate::model::ErrorDetails>,
}
impl SyncResourceStatus {
    /// <p>The sync resource status state.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::SyncResourceState> {
        self.state.as_ref()
    }
    /// <p>The status error.</p>
    pub fn error(&self) -> std::option::Option<&crate::model::ErrorDetails> {
        self.error.as_ref()
    }
}
/// See [`SyncResourceStatus`](crate::model::SyncResourceStatus).
pub mod sync_resource_status {

    /// A builder for [`SyncResourceStatus`](crate::model::SyncResourceStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::SyncResourceState>,
        pub(crate) error: std::option::Option<crate::model::ErrorDetails>,
    }
    impl Builder {
        /// <p>The sync resource status state.</p>
        pub fn state(mut self, input: crate::model::SyncResourceState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The sync resource status state.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::SyncResourceState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The status error.</p>
        pub fn error(mut self, input: crate::model::ErrorDetails) -> Self {
            self.error = Some(input);
            self
        }
        /// <p>The status error.</p>
        pub fn set_error(mut self, input: std::option::Option<crate::model::ErrorDetails>) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`SyncResourceStatus`](crate::model::SyncResourceStatus).
        pub fn build(self) -> crate::model::SyncResourceStatus {
            crate::model::SyncResourceStatus {
                state: self.state,
                error: self.error,
            }
        }
    }
}
impl SyncResourceStatus {
    /// Creates a new builder-style object to manufacture [`SyncResourceStatus`](crate::model::SyncResourceStatus).
    pub fn builder() -> crate::model::sync_resource_status::Builder {
        crate::model::sync_resource_status::Builder::default()
    }
}

/// <p>The error details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ErrorDetails {
    /// <p>The error code.</p>
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::ErrorCode>,
    /// <p>The error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ErrorDetails {
    /// <p>The error code.</p>
    pub fn code(&self) -> std::option::Option<&crate::model::ErrorCode> {
        self.code.as_ref()
    }
    /// <p>The error message.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`ErrorDetails`](crate::model::ErrorDetails).
pub mod error_details {

    /// A builder for [`ErrorDetails`](crate::model::ErrorDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        /// <p>The error code.</p>
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        /// <p>The error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ErrorDetails`](crate::model::ErrorDetails).
        pub fn build(self) -> crate::model::ErrorDetails {
            crate::model::ErrorDetails {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ErrorDetails {
    /// Creates a new builder-style object to manufacture [`ErrorDetails`](crate::model::ErrorDetails).
    pub fn builder() -> crate::model::error_details::Builder {
        crate::model::error_details::Builder::default()
    }
}

/// When writing a match expression against `ErrorCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let errorcode = unimplemented!();
/// match errorcode {
///     ErrorCode::InternalFailure => { /* ... */ },
///     ErrorCode::SyncCreatingError => { /* ... */ },
///     ErrorCode::SyncInitializingError => { /* ... */ },
///     ErrorCode::SyncProcessingError => { /* ... */ },
///     ErrorCode::ValidationError => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `errorcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ErrorCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ErrorCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ErrorCode::NewFeature` is defined.
/// Specifically, when `errorcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ErrorCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    InternalFailure,
    #[allow(missing_docs)] // documentation missing in model
    SyncCreatingError,
    #[allow(missing_docs)] // documentation missing in model
    SyncInitializingError,
    #[allow(missing_docs)] // documentation missing in model
    SyncProcessingError,
    #[allow(missing_docs)] // documentation missing in model
    ValidationError,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "INTERNAL_FAILURE" => ErrorCode::InternalFailure,
            "SYNC_CREATING_ERROR" => ErrorCode::SyncCreatingError,
            "SYNC_INITIALIZING_ERROR" => ErrorCode::SyncInitializingError,
            "SYNC_PROCESSING_ERROR" => ErrorCode::SyncProcessingError,
            "VALIDATION_ERROR" => ErrorCode::ValidationError,
            other => ErrorCode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ErrorCode::from(s))
    }
}
impl ErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ErrorCode::InternalFailure => "INTERNAL_FAILURE",
            ErrorCode::SyncCreatingError => "SYNC_CREATING_ERROR",
            ErrorCode::SyncInitializingError => "SYNC_INITIALIZING_ERROR",
            ErrorCode::SyncProcessingError => "SYNC_PROCESSING_ERROR",
            ErrorCode::ValidationError => "VALIDATION_ERROR",
            ErrorCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "INTERNAL_FAILURE",
            "SYNC_CREATING_ERROR",
            "SYNC_INITIALIZING_ERROR",
            "SYNC_PROCESSING_ERROR",
            "VALIDATION_ERROR",
        ]
    }
}
impl AsRef<str> for ErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SyncResourceState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let syncresourcestate = unimplemented!();
/// match syncresourcestate {
///     SyncResourceState::Deleted => { /* ... */ },
///     SyncResourceState::Error => { /* ... */ },
///     SyncResourceState::Initializing => { /* ... */ },
///     SyncResourceState::InSync => { /* ... */ },
///     SyncResourceState::Processing => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `syncresourcestate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SyncResourceState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SyncResourceState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SyncResourceState::NewFeature` is defined.
/// Specifically, when `syncresourcestate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SyncResourceState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SyncResourceState {
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Initializing,
    #[allow(missing_docs)] // documentation missing in model
    InSync,
    #[allow(missing_docs)] // documentation missing in model
    Processing,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SyncResourceState {
    fn from(s: &str) -> Self {
        match s {
            "DELETED" => SyncResourceState::Deleted,
            "ERROR" => SyncResourceState::Error,
            "INITIALIZING" => SyncResourceState::Initializing,
            "IN_SYNC" => SyncResourceState::InSync,
            "PROCESSING" => SyncResourceState::Processing,
            other => {
                SyncResourceState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for SyncResourceState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SyncResourceState::from(s))
    }
}
impl SyncResourceState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SyncResourceState::Deleted => "DELETED",
            SyncResourceState::Error => "ERROR",
            SyncResourceState::Initializing => "INITIALIZING",
            SyncResourceState::InSync => "IN_SYNC",
            SyncResourceState::Processing => "PROCESSING",
            SyncResourceState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DELETED", "ERROR", "INITIALIZING", "IN_SYNC", "PROCESSING"]
    }
}
impl AsRef<str> for SyncResourceState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SyncResourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let syncresourcetype = unimplemented!();
/// match syncresourcetype {
///     SyncResourceType::ComponentType => { /* ... */ },
///     SyncResourceType::Entity => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `syncresourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SyncResourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SyncResourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SyncResourceType::NewFeature` is defined.
/// Specifically, when `syncresourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SyncResourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SyncResourceType {
    #[allow(missing_docs)] // documentation missing in model
    ComponentType,
    #[allow(missing_docs)] // documentation missing in model
    Entity,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SyncResourceType {
    fn from(s: &str) -> Self {
        match s {
            "COMPONENT_TYPE" => SyncResourceType::ComponentType,
            "ENTITY" => SyncResourceType::Entity,
            other => SyncResourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SyncResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SyncResourceType::from(s))
    }
}
impl SyncResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SyncResourceType::ComponentType => "COMPONENT_TYPE",
            SyncResourceType::Entity => "ENTITY",
            SyncResourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COMPONENT_TYPE", "ENTITY"]
    }
}
impl AsRef<str> for SyncResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The sync resource filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum SyncResourceFilter {
    /// <p>The external Id.</p>
    ExternalId(std::string::String),
    /// <p>The sync resource filter resource Id.</p>
    ResourceId(std::string::String),
    /// <p>The sync resource filter resoucre type</p>
    ResourceType(crate::model::SyncResourceType),
    /// <p>The sync resource filter's state.</p>
    State(crate::model::SyncResourceState),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl SyncResourceFilter {
    /// Tries to convert the enum instance into [`ExternalId`](crate::model::SyncResourceFilter::ExternalId), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_external_id(&self) -> std::result::Result<&std::string::String, &Self> {
        if let SyncResourceFilter::ExternalId(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ExternalId`](crate::model::SyncResourceFilter::ExternalId).
    pub fn is_external_id(&self) -> bool {
        self.as_external_id().is_ok()
    }
    /// Tries to convert the enum instance into [`ResourceId`](crate::model::SyncResourceFilter::ResourceId), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_resource_id(&self) -> std::result::Result<&std::string::String, &Self> {
        if let SyncResourceFilter::ResourceId(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ResourceId`](crate::model::SyncResourceFilter::ResourceId).
    pub fn is_resource_id(&self) -> bool {
        self.as_resource_id().is_ok()
    }
    /// Tries to convert the enum instance into [`ResourceType`](crate::model::SyncResourceFilter::ResourceType), extracting the inner [`SyncResourceType`](crate::model::SyncResourceType).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_resource_type(&self) -> std::result::Result<&crate::model::SyncResourceType, &Self> {
        if let SyncResourceFilter::ResourceType(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ResourceType`](crate::model::SyncResourceFilter::ResourceType).
    pub fn is_resource_type(&self) -> bool {
        self.as_resource_type().is_ok()
    }
    /// Tries to convert the enum instance into [`State`](crate::model::SyncResourceFilter::State), extracting the inner [`SyncResourceState`](crate::model::SyncResourceState).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_state(&self) -> std::result::Result<&crate::model::SyncResourceState, &Self> {
        if let SyncResourceFilter::State(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`State`](crate::model::SyncResourceFilter::State).
    pub fn is_state(&self) -> bool {
        self.as_state().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>The SyncJob summary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SyncJobSummary {
    /// <p>The SyncJob summary ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The ID of the workspace that contains the sync job.</p>
    #[doc(hidden)]
    pub workspace_id: std::option::Option<std::string::String>,
    /// <p>The sync source.</p>
    #[doc(hidden)]
    pub sync_source: std::option::Option<std::string::String>,
    /// <p>The SyncJob summaries status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::SyncJobStatus>,
    /// <p>The creation date and time.</p>
    #[doc(hidden)]
    pub creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The update date and time.</p>
    #[doc(hidden)]
    pub update_date_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl SyncJobSummary {
    /// <p>The SyncJob summary ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The ID of the workspace that contains the sync job.</p>
    pub fn workspace_id(&self) -> std::option::Option<&str> {
        self.workspace_id.as_deref()
    }
    /// <p>The sync source.</p>
    pub fn sync_source(&self) -> std::option::Option<&str> {
        self.sync_source.as_deref()
    }
    /// <p>The SyncJob summaries status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::SyncJobStatus> {
        self.status.as_ref()
    }
    /// <p>The creation date and time.</p>
    pub fn creation_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date_time.as_ref()
    }
    /// <p>The update date and time.</p>
    pub fn update_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_date_time.as_ref()
    }
}
/// See [`SyncJobSummary`](crate::model::SyncJobSummary).
pub mod sync_job_summary {

    /// A builder for [`SyncJobSummary`](crate::model::SyncJobSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) workspace_id: std::option::Option<std::string::String>,
        pub(crate) sync_source: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::SyncJobStatus>,
        pub(crate) creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_date_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The SyncJob summary ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The SyncJob summary ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The ID of the workspace that contains the sync job.</p>
        pub fn workspace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workspace_id = Some(input.into());
            self
        }
        /// <p>The ID of the workspace that contains the sync job.</p>
        pub fn set_workspace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workspace_id = input;
            self
        }
        /// <p>The sync source.</p>
        pub fn sync_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.sync_source = Some(input.into());
            self
        }
        /// <p>The sync source.</p>
        pub fn set_sync_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sync_source = input;
            self
        }
        /// <p>The SyncJob summaries status.</p>
        pub fn status(mut self, input: crate::model::SyncJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The SyncJob summaries status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::SyncJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The creation date and time.</p>
        pub fn creation_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date_time = Some(input);
            self
        }
        /// <p>The creation date and time.</p>
        pub fn set_creation_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date_time = input;
            self
        }
        /// <p>The update date and time.</p>
        pub fn update_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_date_time = Some(input);
            self
        }
        /// <p>The update date and time.</p>
        pub fn set_update_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_date_time = input;
            self
        }
        /// Consumes the builder and constructs a [`SyncJobSummary`](crate::model::SyncJobSummary).
        pub fn build(self) -> crate::model::SyncJobSummary {
            crate::model::SyncJobSummary {
                arn: self.arn,
                workspace_id: self.workspace_id,
                sync_source: self.sync_source,
                status: self.status,
                creation_date_time: self.creation_date_time,
                update_date_time: self.update_date_time,
            }
        }
    }
}
impl SyncJobSummary {
    /// Creates a new builder-style object to manufacture [`SyncJobSummary`](crate::model::SyncJobSummary).
    pub fn builder() -> crate::model::sync_job_summary::Builder {
        crate::model::sync_job_summary::Builder::default()
    }
}

/// <p>The SyncJob status.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SyncJobStatus {
    /// <p>The SyncJob status state.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::SyncJobState>,
    /// <p>The SyncJob error.</p>
    #[doc(hidden)]
    pub error: std::option::Option<crate::model::ErrorDetails>,
}
impl SyncJobStatus {
    /// <p>The SyncJob status state.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::SyncJobState> {
        self.state.as_ref()
    }
    /// <p>The SyncJob error.</p>
    pub fn error(&self) -> std::option::Option<&crate::model::ErrorDetails> {
        self.error.as_ref()
    }
}
/// See [`SyncJobStatus`](crate::model::SyncJobStatus).
pub mod sync_job_status {

    /// A builder for [`SyncJobStatus`](crate::model::SyncJobStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::SyncJobState>,
        pub(crate) error: std::option::Option<crate::model::ErrorDetails>,
    }
    impl Builder {
        /// <p>The SyncJob status state.</p>
        pub fn state(mut self, input: crate::model::SyncJobState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The SyncJob status state.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::SyncJobState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The SyncJob error.</p>
        pub fn error(mut self, input: crate::model::ErrorDetails) -> Self {
            self.error = Some(input);
            self
        }
        /// <p>The SyncJob error.</p>
        pub fn set_error(mut self, input: std::option::Option<crate::model::ErrorDetails>) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`SyncJobStatus`](crate::model::SyncJobStatus).
        pub fn build(self) -> crate::model::SyncJobStatus {
            crate::model::SyncJobStatus {
                state: self.state,
                error: self.error,
            }
        }
    }
}
impl SyncJobStatus {
    /// Creates a new builder-style object to manufacture [`SyncJobStatus`](crate::model::SyncJobStatus).
    pub fn builder() -> crate::model::sync_job_status::Builder {
        crate::model::sync_job_status::Builder::default()
    }
}

/// When writing a match expression against `SyncJobState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let syncjobstate = unimplemented!();
/// match syncjobstate {
///     SyncJobState::Active => { /* ... */ },
///     SyncJobState::Creating => { /* ... */ },
///     SyncJobState::Deleting => { /* ... */ },
///     SyncJobState::Error => { /* ... */ },
///     SyncJobState::Initializing => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `syncjobstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SyncJobState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SyncJobState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SyncJobState::NewFeature` is defined.
/// Specifically, when `syncjobstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SyncJobState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SyncJobState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Initializing,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SyncJobState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => SyncJobState::Active,
            "CREATING" => SyncJobState::Creating,
            "DELETING" => SyncJobState::Deleting,
            "ERROR" => SyncJobState::Error,
            "INITIALIZING" => SyncJobState::Initializing,
            other => SyncJobState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SyncJobState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SyncJobState::from(s))
    }
}
impl SyncJobState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SyncJobState::Active => "ACTIVE",
            SyncJobState::Creating => "CREATING",
            SyncJobState::Deleting => "DELETING",
            SyncJobState::Error => "ERROR",
            SyncJobState::Initializing => "INITIALIZING",
            SyncJobState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "CREATING", "DELETING", "ERROR", "INITIALIZING"]
    }
}
impl AsRef<str> for SyncJobState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that contains information about a scene.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SceneSummary {
    /// <p>The ID of the scene.</p>
    #[doc(hidden)]
    pub scene_id: std::option::Option<std::string::String>,
    /// <p>The relative path that specifies the location of the content definition file.</p>
    #[doc(hidden)]
    pub content_location: std::option::Option<std::string::String>,
    /// <p>The ARN of the scene.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The date and time when the scene was created.</p>
    #[doc(hidden)]
    pub creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time when the scene was last updated.</p>
    #[doc(hidden)]
    pub update_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The scene description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl SceneSummary {
    /// <p>The ID of the scene.</p>
    pub fn scene_id(&self) -> std::option::Option<&str> {
        self.scene_id.as_deref()
    }
    /// <p>The relative path that specifies the location of the content definition file.</p>
    pub fn content_location(&self) -> std::option::Option<&str> {
        self.content_location.as_deref()
    }
    /// <p>The ARN of the scene.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The date and time when the scene was created.</p>
    pub fn creation_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date_time.as_ref()
    }
    /// <p>The date and time when the scene was last updated.</p>
    pub fn update_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_date_time.as_ref()
    }
    /// <p>The scene description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
/// See [`SceneSummary`](crate::model::SceneSummary).
pub mod scene_summary {

    /// A builder for [`SceneSummary`](crate::model::SceneSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scene_id: std::option::Option<std::string::String>,
        pub(crate) content_location: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the scene.</p>
        pub fn scene_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.scene_id = Some(input.into());
            self
        }
        /// <p>The ID of the scene.</p>
        pub fn set_scene_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.scene_id = input;
            self
        }
        /// <p>The relative path that specifies the location of the content definition file.</p>
        pub fn content_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_location = Some(input.into());
            self
        }
        /// <p>The relative path that specifies the location of the content definition file.</p>
        pub fn set_content_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_location = input;
            self
        }
        /// <p>The ARN of the scene.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the scene.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The date and time when the scene was created.</p>
        pub fn creation_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date_time = Some(input);
            self
        }
        /// <p>The date and time when the scene was created.</p>
        pub fn set_creation_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date_time = input;
            self
        }
        /// <p>The date and time when the scene was last updated.</p>
        pub fn update_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_date_time = Some(input);
            self
        }
        /// <p>The date and time when the scene was last updated.</p>
        pub fn set_update_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_date_time = input;
            self
        }
        /// <p>The scene description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The scene description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`SceneSummary`](crate::model::SceneSummary).
        pub fn build(self) -> crate::model::SceneSummary {
            crate::model::SceneSummary {
                scene_id: self.scene_id,
                content_location: self.content_location,
                arn: self.arn,
                creation_date_time: self.creation_date_time,
                update_date_time: self.update_date_time,
                description: self.description,
            }
        }
    }
}
impl SceneSummary {
    /// Creates a new builder-style object to manufacture [`SceneSummary`](crate::model::SceneSummary).
    pub fn builder() -> crate::model::scene_summary::Builder {
        crate::model::scene_summary::Builder::default()
    }
}

/// <p>An object that contains information about an entity.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EntitySummary {
    /// <p>The ID of the entity.</p>
    #[doc(hidden)]
    pub entity_id: std::option::Option<std::string::String>,
    /// <p>The name of the entity.</p>
    #[doc(hidden)]
    pub entity_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the entity.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The ID of the parent entity.</p>
    #[doc(hidden)]
    pub parent_entity_id: std::option::Option<std::string::String>,
    /// <p>The current status of the entity.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::Status>,
    /// <p>The description of the entity.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>A Boolean value that specifies whether the entity has child entities or not.</p>
    #[doc(hidden)]
    pub has_child_entities: std::option::Option<bool>,
    /// <p>The date and time when the entity was created.</p>
    #[doc(hidden)]
    pub creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last date and time when the entity was updated.</p>
    #[doc(hidden)]
    pub update_date_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl EntitySummary {
    /// <p>The ID of the entity.</p>
    pub fn entity_id(&self) -> std::option::Option<&str> {
        self.entity_id.as_deref()
    }
    /// <p>The name of the entity.</p>
    pub fn entity_name(&self) -> std::option::Option<&str> {
        self.entity_name.as_deref()
    }
    /// <p>The ARN of the entity.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The ID of the parent entity.</p>
    pub fn parent_entity_id(&self) -> std::option::Option<&str> {
        self.parent_entity_id.as_deref()
    }
    /// <p>The current status of the entity.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::Status> {
        self.status.as_ref()
    }
    /// <p>The description of the entity.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>A Boolean value that specifies whether the entity has child entities or not.</p>
    pub fn has_child_entities(&self) -> std::option::Option<bool> {
        self.has_child_entities
    }
    /// <p>The date and time when the entity was created.</p>
    pub fn creation_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date_time.as_ref()
    }
    /// <p>The last date and time when the entity was updated.</p>
    pub fn update_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_date_time.as_ref()
    }
}
/// See [`EntitySummary`](crate::model::EntitySummary).
pub mod entity_summary {

    /// A builder for [`EntitySummary`](crate::model::EntitySummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entity_id: std::option::Option<std::string::String>,
        pub(crate) entity_name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) parent_entity_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::Status>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) has_child_entities: std::option::Option<bool>,
        pub(crate) creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_date_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The ID of the entity.</p>
        pub fn entity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entity_id = Some(input.into());
            self
        }
        /// <p>The ID of the entity.</p>
        pub fn set_entity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entity_id = input;
            self
        }
        /// <p>The name of the entity.</p>
        pub fn entity_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.entity_name = Some(input.into());
            self
        }
        /// <p>The name of the entity.</p>
        pub fn set_entity_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entity_name = input;
            self
        }
        /// <p>The ARN of the entity.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the entity.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The ID of the parent entity.</p>
        pub fn parent_entity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.parent_entity_id = Some(input.into());
            self
        }
        /// <p>The ID of the parent entity.</p>
        pub fn set_parent_entity_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parent_entity_id = input;
            self
        }
        /// <p>The current status of the entity.</p>
        pub fn status(mut self, input: crate::model::Status) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the entity.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::Status>) -> Self {
            self.status = input;
            self
        }
        /// <p>The description of the entity.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the entity.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>A Boolean value that specifies whether the entity has child entities or not.</p>
        pub fn has_child_entities(mut self, input: bool) -> Self {
            self.has_child_entities = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the entity has child entities or not.</p>
        pub fn set_has_child_entities(mut self, input: std::option::Option<bool>) -> Self {
            self.has_child_entities = input;
            self
        }
        /// <p>The date and time when the entity was created.</p>
        pub fn creation_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date_time = Some(input);
            self
        }
        /// <p>The date and time when the entity was created.</p>
        pub fn set_creation_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date_time = input;
            self
        }
        /// <p>The last date and time when the entity was updated.</p>
        pub fn update_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_date_time = Some(input);
            self
        }
        /// <p>The last date and time when the entity was updated.</p>
        pub fn set_update_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_date_time = input;
            self
        }
        /// Consumes the builder and constructs a [`EntitySummary`](crate::model::EntitySummary).
        pub fn build(self) -> crate::model::EntitySummary {
            crate::model::EntitySummary {
                entity_id: self.entity_id,
                entity_name: self.entity_name,
                arn: self.arn,
                parent_entity_id: self.parent_entity_id,
                status: self.status,
                description: self.description,
                has_child_entities: self.has_child_entities,
                creation_date_time: self.creation_date_time,
                update_date_time: self.update_date_time,
            }
        }
    }
}
impl EntitySummary {
    /// Creates a new builder-style object to manufacture [`EntitySummary`](crate::model::EntitySummary).
    pub fn builder() -> crate::model::entity_summary::Builder {
        crate::model::entity_summary::Builder::default()
    }
}

/// <p>An object that represents the status of an entity, component, component type, or workspace.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Status {
    /// <p>The current state of the entity, component, component type, or workspace.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::State>,
    /// <p>The error message.</p>
    #[doc(hidden)]
    pub error: std::option::Option<crate::model::ErrorDetails>,
}
impl Status {
    /// <p>The current state of the entity, component, component type, or workspace.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::State> {
        self.state.as_ref()
    }
    /// <p>The error message.</p>
    pub fn error(&self) -> std::option::Option<&crate::model::ErrorDetails> {
        self.error.as_ref()
    }
}
/// See [`Status`](crate::model::Status).
pub mod status {

    /// A builder for [`Status`](crate::model::Status).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::State>,
        pub(crate) error: std::option::Option<crate::model::ErrorDetails>,
    }
    impl Builder {
        /// <p>The current state of the entity, component, component type, or workspace.</p>
        pub fn state(mut self, input: crate::model::State) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state of the entity, component, component type, or workspace.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::State>) -> Self {
            self.state = input;
            self
        }
        /// <p>The error message.</p>
        pub fn error(mut self, input: crate::model::ErrorDetails) -> Self {
            self.error = Some(input);
            self
        }
        /// <p>The error message.</p>
        pub fn set_error(mut self, input: std::option::Option<crate::model::ErrorDetails>) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`Status`](crate::model::Status).
        pub fn build(self) -> crate::model::Status {
            crate::model::Status {
                state: self.state,
                error: self.error,
            }
        }
    }
}
impl Status {
    /// Creates a new builder-style object to manufacture [`Status`](crate::model::Status).
    pub fn builder() -> crate::model::status::Builder {
        crate::model::status::Builder::default()
    }
}

/// <p>An object that filters items in a list of entities.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum ListEntitiesFilter {
    /// <p>The ID of the component type in the entities in the list.</p>
    ComponentTypeId(std::string::String),
    /// <p>The external-Id property of a component. The external-Id property is the primary key of an external storage system.</p>
    ExternalId(std::string::String),
    /// <p>The parent of the entities in the list.</p>
    ParentEntityId(std::string::String),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl ListEntitiesFilter {
    /// Tries to convert the enum instance into [`ComponentTypeId`](crate::model::ListEntitiesFilter::ComponentTypeId), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_component_type_id(&self) -> std::result::Result<&std::string::String, &Self> {
        if let ListEntitiesFilter::ComponentTypeId(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ComponentTypeId`](crate::model::ListEntitiesFilter::ComponentTypeId).
    pub fn is_component_type_id(&self) -> bool {
        self.as_component_type_id().is_ok()
    }
    /// Tries to convert the enum instance into [`ExternalId`](crate::model::ListEntitiesFilter::ExternalId), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_external_id(&self) -> std::result::Result<&std::string::String, &Self> {
        if let ListEntitiesFilter::ExternalId(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ExternalId`](crate::model::ListEntitiesFilter::ExternalId).
    pub fn is_external_id(&self) -> bool {
        self.as_external_id().is_ok()
    }
    /// Tries to convert the enum instance into [`ParentEntityId`](crate::model::ListEntitiesFilter::ParentEntityId), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_parent_entity_id(&self) -> std::result::Result<&std::string::String, &Self> {
        if let ListEntitiesFilter::ParentEntityId(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ParentEntityId`](crate::model::ListEntitiesFilter::ParentEntityId).
    pub fn is_parent_entity_id(&self) -> bool {
        self.as_parent_entity_id().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>An object that contains information about a component type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComponentTypeSummary {
    /// <p>The ARN of the component type.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The ID of the component type.</p>
    #[doc(hidden)]
    pub component_type_id: std::option::Option<std::string::String>,
    /// <p>The date and time when the component type was created.</p>
    #[doc(hidden)]
    pub creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time when the component type was last updated.</p>
    #[doc(hidden)]
    pub update_date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The description of the component type.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The current status of the component type.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::Status>,
    /// <p>The component type name.</p>
    #[doc(hidden)]
    pub component_type_name: std::option::Option<std::string::String>,
}
impl ComponentTypeSummary {
    /// <p>The ARN of the component type.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The ID of the component type.</p>
    pub fn component_type_id(&self) -> std::option::Option<&str> {
        self.component_type_id.as_deref()
    }
    /// <p>The date and time when the component type was created.</p>
    pub fn creation_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date_time.as_ref()
    }
    /// <p>The date and time when the component type was last updated.</p>
    pub fn update_date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.update_date_time.as_ref()
    }
    /// <p>The description of the component type.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The current status of the component type.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::Status> {
        self.status.as_ref()
    }
    /// <p>The component type name.</p>
    pub fn component_type_name(&self) -> std::option::Option<&str> {
        self.component_type_name.as_deref()
    }
}
/// See [`ComponentTypeSummary`](crate::model::ComponentTypeSummary).
pub mod component_type_summary {

    /// A builder for [`ComponentTypeSummary`](crate::model::ComponentTypeSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) component_type_id: std::option::Option<std::string::String>,
        pub(crate) creation_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) update_date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::Status>,
        pub(crate) component_type_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the component type.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the component type.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The ID of the component type.</p>
        pub fn component_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_type_id = Some(input.into());
            self
        }
        /// <p>The ID of the component type.</p>
        pub fn set_component_type_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.component_type_id = input;
            self
        }
        /// <p>The date and time when the component type was created.</p>
        pub fn creation_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date_time = Some(input);
            self
        }
        /// <p>The date and time when the component type was created.</p>
        pub fn set_creation_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date_time = input;
            self
        }
        /// <p>The date and time when the component type was last updated.</p>
        pub fn update_date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.update_date_time = Some(input);
            self
        }
        /// <p>The date and time when the component type was last updated.</p>
        pub fn set_update_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.update_date_time = input;
            self
        }
        /// <p>The description of the component type.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the component type.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The current status of the component type.</p>
        pub fn status(mut self, input: crate::model::Status) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the component type.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::Status>) -> Self {
            self.status = input;
            self
        }
        /// <p>The component type name.</p>
        pub fn component_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_type_name = Some(input.into());
            self
        }
        /// <p>The component type name.</p>
        pub fn set_component_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.component_type_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ComponentTypeSummary`](crate::model::ComponentTypeSummary).
        pub fn build(self) -> crate::model::ComponentTypeSummary {
            crate::model::ComponentTypeSummary {
                arn: self.arn,
                component_type_id: self.component_type_id,
                creation_date_time: self.creation_date_time,
                update_date_time: self.update_date_time,
                description: self.description,
                status: self.status,
                component_type_name: self.component_type_name,
            }
        }
    }
}
impl ComponentTypeSummary {
    /// Creates a new builder-style object to manufacture [`ComponentTypeSummary`](crate::model::ComponentTypeSummary).
    pub fn builder() -> crate::model::component_type_summary::Builder {
        crate::model::component_type_summary::Builder::default()
    }
}

/// <p>An object that filters items in a list of component types.</p> <note>
/// <p>Only one object is accepted as a valid input.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum ListComponentTypesFilter {
    /// <p>The component type that the component types in the list extend.</p>
    ExtendsFrom(std::string::String),
    /// <p>A Boolean value that specifies whether the component types in the list are abstract.</p>
    IsAbstract(bool),
    /// <p>The namespace to which the component types in the list belong.</p>
    Namespace(std::string::String),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl ListComponentTypesFilter {
    /// Tries to convert the enum instance into [`ExtendsFrom`](crate::model::ListComponentTypesFilter::ExtendsFrom), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_extends_from(&self) -> std::result::Result<&std::string::String, &Self> {
        if let ListComponentTypesFilter::ExtendsFrom(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ExtendsFrom`](crate::model::ListComponentTypesFilter::ExtendsFrom).
    pub fn is_extends_from(&self) -> bool {
        self.as_extends_from().is_ok()
    }
    /// Tries to convert the enum instance into [`IsAbstract`](crate::model::ListComponentTypesFilter::IsAbstract), extracting the inner [`bool`](bool).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_is_abstract(&self) -> std::result::Result<&bool, &Self> {
        if let ListComponentTypesFilter::IsAbstract(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`IsAbstract`](crate::model::ListComponentTypesFilter::IsAbstract).
    pub fn is_is_abstract(&self) -> bool {
        self.as_is_abstract().is_ok()
    }
    /// Tries to convert the enum instance into [`Namespace`](crate::model::ListComponentTypesFilter::Namespace), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_namespace(&self) -> std::result::Result<&std::string::String, &Self> {
        if let ListComponentTypesFilter::Namespace(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Namespace`](crate::model::ListComponentTypesFilter::Namespace).
    pub fn is_namespace(&self) -> bool {
        self.as_namespace().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>The history of values for a time series property.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyValueHistory {
    /// <p>An object that uniquely identifies an entity property.</p>
    #[doc(hidden)]
    pub entity_property_reference: std::option::Option<crate::model::EntityPropertyReference>,
    /// <p>A list of objects that contain information about the values in the history of a time series property.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<crate::model::PropertyValue>>,
}
impl PropertyValueHistory {
    /// <p>An object that uniquely identifies an entity property.</p>
    pub fn entity_property_reference(
        &self,
    ) -> std::option::Option<&crate::model::EntityPropertyReference> {
        self.entity_property_reference.as_ref()
    }
    /// <p>A list of objects that contain information about the values in the history of a time series property.</p>
    pub fn values(&self) -> std::option::Option<&[crate::model::PropertyValue]> {
        self.values.as_deref()
    }
}
/// See [`PropertyValueHistory`](crate::model::PropertyValueHistory).
pub mod property_value_history {

    /// A builder for [`PropertyValueHistory`](crate::model::PropertyValueHistory).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entity_property_reference:
            std::option::Option<crate::model::EntityPropertyReference>,
        pub(crate) values: std::option::Option<std::vec::Vec<crate::model::PropertyValue>>,
    }
    impl Builder {
        /// <p>An object that uniquely identifies an entity property.</p>
        pub fn entity_property_reference(
            mut self,
            input: crate::model::EntityPropertyReference,
        ) -> Self {
            self.entity_property_reference = Some(input);
            self
        }
        /// <p>An object that uniquely identifies an entity property.</p>
        pub fn set_entity_property_reference(
            mut self,
            input: std::option::Option<crate::model::EntityPropertyReference>,
        ) -> Self {
            self.entity_property_reference = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>A list of objects that contain information about the values in the history of a time series property.</p>
        pub fn values(mut self, input: crate::model::PropertyValue) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input);
            self.values = Some(v);
            self
        }
        /// <p>A list of objects that contain information about the values in the history of a time series property.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PropertyValue>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`PropertyValueHistory`](crate::model::PropertyValueHistory).
        pub fn build(self) -> crate::model::PropertyValueHistory {
            crate::model::PropertyValueHistory {
                entity_property_reference: self.entity_property_reference,
                values: self.values,
            }
        }
    }
}
impl PropertyValueHistory {
    /// Creates a new builder-style object to manufacture [`PropertyValueHistory`](crate::model::PropertyValueHistory).
    pub fn builder() -> crate::model::property_value_history::Builder {
        crate::model::property_value_history::Builder::default()
    }
}

/// <p>An object that contains information about a value for a time series property.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyValue {
    /// <p>The timestamp of a value for a time series property.</p>
    #[deprecated(
        note = "This field is deprecated and will throw an error in the future. Use time instead."
    )]
    #[doc(hidden)]
    pub timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>An object that specifies a value for a time series property.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::DataValue>,
    /// <p>ISO8601 DateTime of a value for a time series property.</p>
    /// <p>The time for when the property value was recorded in ISO 8601 format: <i>YYYY-MM-DDThh:mm:ss[.SSSSSSSSS][Z/±HH:mm]</i>.</p>
    /// <ul>
    /// <li> <p> <i>[YYYY]</i>: year</p> </li>
    /// <li> <p> <i>[MM]</i>: month</p> </li>
    /// <li> <p> <i>[DD]</i>: day</p> </li>
    /// <li> <p> <i>[hh]</i>: hour</p> </li>
    /// <li> <p> <i>[mm]</i>: minute</p> </li>
    /// <li> <p> <i>[ss]</i>: seconds</p> </li>
    /// <li> <p> <i>[.SSSSSSSSS]</i>: additional precision, where precedence is maintained. For example: [.573123] is equal to 573123000 nanoseconds.</p> </li>
    /// <li> <p> <i>Z</i>: default timezone UTC</p> </li>
    /// <li> <p> <i>± HH:mm</i>: time zone offset in Hours and Minutes.</p> </li>
    /// </ul>
    /// <p> <i>Required sub-fields</i>: YYYY-MM-DDThh:mm:ss and [Z/±HH:mm]</p>
    #[doc(hidden)]
    pub time: std::option::Option<std::string::String>,
}
impl PropertyValue {
    /// <p>The timestamp of a value for a time series property.</p>
    #[deprecated(
        note = "This field is deprecated and will throw an error in the future. Use time instead."
    )]
    pub fn timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.timestamp.as_ref()
    }
    /// <p>An object that specifies a value for a time series property.</p>
    pub fn value(&self) -> std::option::Option<&crate::model::DataValue> {
        self.value.as_ref()
    }
    /// <p>ISO8601 DateTime of a value for a time series property.</p>
    /// <p>The time for when the property value was recorded in ISO 8601 format: <i>YYYY-MM-DDThh:mm:ss[.SSSSSSSSS][Z/±HH:mm]</i>.</p>
    /// <ul>
    /// <li> <p> <i>[YYYY]</i>: year</p> </li>
    /// <li> <p> <i>[MM]</i>: month</p> </li>
    /// <li> <p> <i>[DD]</i>: day</p> </li>
    /// <li> <p> <i>[hh]</i>: hour</p> </li>
    /// <li> <p> <i>[mm]</i>: minute</p> </li>
    /// <li> <p> <i>[ss]</i>: seconds</p> </li>
    /// <li> <p> <i>[.SSSSSSSSS]</i>: additional precision, where precedence is maintained. For example: [.573123] is equal to 573123000 nanoseconds.</p> </li>
    /// <li> <p> <i>Z</i>: default timezone UTC</p> </li>
    /// <li> <p> <i>± HH:mm</i>: time zone offset in Hours and Minutes.</p> </li>
    /// </ul>
    /// <p> <i>Required sub-fields</i>: YYYY-MM-DDThh:mm:ss and [Z/±HH:mm]</p>
    pub fn time(&self) -> std::option::Option<&str> {
        self.time.as_deref()
    }
}
/// See [`PropertyValue`](crate::model::PropertyValue).
pub mod property_value {

    /// A builder for [`PropertyValue`](crate::model::PropertyValue).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) value: std::option::Option<crate::model::DataValue>,
        pub(crate) time: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The timestamp of a value for a time series property.</p>
        #[deprecated(
            note = "This field is deprecated and will throw an error in the future. Use time instead."
        )]
        pub fn timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.timestamp = Some(input);
            self
        }
        /// <p>The timestamp of a value for a time series property.</p>
        #[deprecated(
            note = "This field is deprecated and will throw an error in the future. Use time instead."
        )]
        pub fn set_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.timestamp = input;
            self
        }
        /// <p>An object that specifies a value for a time series property.</p>
        pub fn value(mut self, input: crate::model::DataValue) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>An object that specifies a value for a time series property.</p>
        pub fn set_value(mut self, input: std::option::Option<crate::model::DataValue>) -> Self {
            self.value = input;
            self
        }
        /// <p>ISO8601 DateTime of a value for a time series property.</p>
        /// <p>The time for when the property value was recorded in ISO 8601 format: <i>YYYY-MM-DDThh:mm:ss[.SSSSSSSSS][Z/±HH:mm]</i>.</p>
        /// <ul>
        /// <li> <p> <i>[YYYY]</i>: year</p> </li>
        /// <li> <p> <i>[MM]</i>: month</p> </li>
        /// <li> <p> <i>[DD]</i>: day</p> </li>
        /// <li> <p> <i>[hh]</i>: hour</p> </li>
        /// <li> <p> <i>[mm]</i>: minute</p> </li>
        /// <li> <p> <i>[ss]</i>: seconds</p> </li>
        /// <li> <p> <i>[.SSSSSSSSS]</i>: additional precision, where precedence is maintained. For example: [.573123] is equal to 573123000 nanoseconds.</p> </li>
        /// <li> <p> <i>Z</i>: default timezone UTC</p> </li>
        /// <li> <p> <i>± HH:mm</i>: time zone offset in Hours and Minutes.</p> </li>
        /// </ul>
        /// <p> <i>Required sub-fields</i>: YYYY-MM-DDThh:mm:ss and [Z/±HH:mm]</p>
        pub fn time(mut self, input: impl Into<std::string::String>) -> Self {
            self.time = Some(input.into());
            self
        }
        /// <p>ISO8601 DateTime of a value for a time series property.</p>
        /// <p>The time for when the property value was recorded in ISO 8601 format: <i>YYYY-MM-DDThh:mm:ss[.SSSSSSSSS][Z/±HH:mm]</i>.</p>
        /// <ul>
        /// <li> <p> <i>[YYYY]</i>: year</p> </li>
        /// <li> <p> <i>[MM]</i>: month</p> </li>
        /// <li> <p> <i>[DD]</i>: day</p> </li>
        /// <li> <p> <i>[hh]</i>: hour</p> </li>
        /// <li> <p> <i>[mm]</i>: minute</p> </li>
        /// <li> <p> <i>[ss]</i>: seconds</p> </li>
        /// <li> <p> <i>[.SSSSSSSSS]</i>: additional precision, where precedence is maintained. For example: [.573123] is equal to 573123000 nanoseconds.</p> </li>
        /// <li> <p> <i>Z</i>: default timezone UTC</p> </li>
        /// <li> <p> <i>± HH:mm</i>: time zone offset in Hours and Minutes.</p> </li>
        /// </ul>
        /// <p> <i>Required sub-fields</i>: YYYY-MM-DDThh:mm:ss and [Z/±HH:mm]</p>
        pub fn set_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.time = input;
            self
        }
        /// Consumes the builder and constructs a [`PropertyValue`](crate::model::PropertyValue).
        pub fn build(self) -> crate::model::PropertyValue {
            crate::model::PropertyValue {
                timestamp: self.timestamp,
                value: self.value,
                time: self.time,
            }
        }
    }
}
impl PropertyValue {
    /// Creates a new builder-style object to manufacture [`PropertyValue`](crate::model::PropertyValue).
    pub fn builder() -> crate::model::property_value::Builder {
        crate::model::property_value::Builder::default()
    }
}

/// <p>An object that uniquely identifies an entity property.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EntityPropertyReference {
    /// <p>The name of the component.</p>
    #[doc(hidden)]
    pub component_name: std::option::Option<std::string::String>,
    /// <p>A mapping of external IDs to property names. External IDs uniquely identify properties from external data stores.</p>
    #[doc(hidden)]
    pub external_id_property:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The ID of the entity.</p>
    #[doc(hidden)]
    pub entity_id: std::option::Option<std::string::String>,
    /// <p>The name of the property.</p>
    #[doc(hidden)]
    pub property_name: std::option::Option<std::string::String>,
}
impl EntityPropertyReference {
    /// <p>The name of the component.</p>
    pub fn component_name(&self) -> std::option::Option<&str> {
        self.component_name.as_deref()
    }
    /// <p>A mapping of external IDs to property names. External IDs uniquely identify properties from external data stores.</p>
    pub fn external_id_property(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.external_id_property.as_ref()
    }
    /// <p>The ID of the entity.</p>
    pub fn entity_id(&self) -> std::option::Option<&str> {
        self.entity_id.as_deref()
    }
    /// <p>The name of the property.</p>
    pub fn property_name(&self) -> std::option::Option<&str> {
        self.property_name.as_deref()
    }
}
/// See [`EntityPropertyReference`](crate::model::EntityPropertyReference).
pub mod entity_property_reference {

    /// A builder for [`EntityPropertyReference`](crate::model::EntityPropertyReference).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) component_name: std::option::Option<std::string::String>,
        pub(crate) external_id_property: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) entity_id: std::option::Option<std::string::String>,
        pub(crate) property_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the component.</p>
        pub fn component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_name = Some(input.into());
            self
        }
        /// <p>The name of the component.</p>
        pub fn set_component_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.component_name = input;
            self
        }
        /// Adds a key-value pair to `external_id_property`.
        ///
        /// To override the contents of this collection use [`set_external_id_property`](Self::set_external_id_property).
        ///
        /// <p>A mapping of external IDs to property names. External IDs uniquely identify properties from external data stores.</p>
        pub fn external_id_property(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.external_id_property.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.external_id_property = Some(hash_map);
            self
        }
        /// <p>A mapping of external IDs to property names. External IDs uniquely identify properties from external data stores.</p>
        pub fn set_external_id_property(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.external_id_property = input;
            self
        }
        /// <p>The ID of the entity.</p>
        pub fn entity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entity_id = Some(input.into());
            self
        }
        /// <p>The ID of the entity.</p>
        pub fn set_entity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entity_id = input;
            self
        }
        /// <p>The name of the property.</p>
        pub fn property_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_name = Some(input.into());
            self
        }
        /// <p>The name of the property.</p>
        pub fn set_property_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.property_name = input;
            self
        }
        /// Consumes the builder and constructs a [`EntityPropertyReference`](crate::model::EntityPropertyReference).
        pub fn build(self) -> crate::model::EntityPropertyReference {
            crate::model::EntityPropertyReference {
                component_name: self.component_name,
                external_id_property: self.external_id_property,
                entity_id: self.entity_id,
                property_name: self.property_name,
            }
        }
    }
}
impl EntityPropertyReference {
    /// Creates a new builder-style object to manufacture [`EntityPropertyReference`](crate::model::EntityPropertyReference).
    pub fn builder() -> crate::model::entity_property_reference::Builder {
        crate::model::entity_property_reference::Builder::default()
    }
}

/// When writing a match expression against `OrderByTime`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let orderbytime = unimplemented!();
/// match orderbytime {
///     OrderByTime::Ascending => { /* ... */ },
///     OrderByTime::Descending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `orderbytime` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OrderByTime::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OrderByTime::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OrderByTime::NewFeature` is defined.
/// Specifically, when `orderbytime` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OrderByTime::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OrderByTime {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OrderByTime {
    fn from(s: &str) -> Self {
        match s {
            "ASCENDING" => OrderByTime::Ascending,
            "DESCENDING" => OrderByTime::Descending,
            other => OrderByTime::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for OrderByTime {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OrderByTime::from(s))
    }
}
impl OrderByTime {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OrderByTime::Ascending => "ASCENDING",
            OrderByTime::Descending => "DESCENDING",
            OrderByTime::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ASCENDING", "DESCENDING"]
    }
}
impl AsRef<str> for OrderByTime {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that specifies how to interpolate data in a list.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InterpolationParameters {
    /// <p>The interpolation type.</p>
    #[doc(hidden)]
    pub interpolation_type: std::option::Option<crate::model::InterpolationType>,
    /// <p>The interpolation time interval in seconds.</p>
    #[doc(hidden)]
    pub interval_in_seconds: std::option::Option<i64>,
}
impl InterpolationParameters {
    /// <p>The interpolation type.</p>
    pub fn interpolation_type(&self) -> std::option::Option<&crate::model::InterpolationType> {
        self.interpolation_type.as_ref()
    }
    /// <p>The interpolation time interval in seconds.</p>
    pub fn interval_in_seconds(&self) -> std::option::Option<i64> {
        self.interval_in_seconds
    }
}
/// See [`InterpolationParameters`](crate::model::InterpolationParameters).
pub mod interpolation_parameters {

    /// A builder for [`InterpolationParameters`](crate::model::InterpolationParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) interpolation_type: std::option::Option<crate::model::InterpolationType>,
        pub(crate) interval_in_seconds: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The interpolation type.</p>
        pub fn interpolation_type(mut self, input: crate::model::InterpolationType) -> Self {
            self.interpolation_type = Some(input);
            self
        }
        /// <p>The interpolation type.</p>
        pub fn set_interpolation_type(
            mut self,
            input: std::option::Option<crate::model::InterpolationType>,
        ) -> Self {
            self.interpolation_type = input;
            self
        }
        /// <p>The interpolation time interval in seconds.</p>
        pub fn interval_in_seconds(mut self, input: i64) -> Self {
            self.interval_in_seconds = Some(input);
            self
        }
        /// <p>The interpolation time interval in seconds.</p>
        pub fn set_interval_in_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.interval_in_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`InterpolationParameters`](crate::model::InterpolationParameters).
        pub fn build(self) -> crate::model::InterpolationParameters {
            crate::model::InterpolationParameters {
                interpolation_type: self.interpolation_type,
                interval_in_seconds: self.interval_in_seconds,
            }
        }
    }
}
impl InterpolationParameters {
    /// Creates a new builder-style object to manufacture [`InterpolationParameters`](crate::model::InterpolationParameters).
    pub fn builder() -> crate::model::interpolation_parameters::Builder {
        crate::model::interpolation_parameters::Builder::default()
    }
}

/// When writing a match expression against `InterpolationType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let interpolationtype = unimplemented!();
/// match interpolationtype {
///     InterpolationType::Linear => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `interpolationtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `InterpolationType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `InterpolationType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `InterpolationType::NewFeature` is defined.
/// Specifically, when `interpolationtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `InterpolationType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InterpolationType {
    #[allow(missing_docs)] // documentation missing in model
    Linear,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for InterpolationType {
    fn from(s: &str) -> Self {
        match s {
            "LINEAR" => InterpolationType::Linear,
            other => {
                InterpolationType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for InterpolationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InterpolationType::from(s))
    }
}
impl InterpolationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InterpolationType::Linear => "LINEAR",
            InterpolationType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LINEAR"]
    }
}
impl AsRef<str> for InterpolationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that filters items returned by a property request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyFilter {
    /// <p>The property name associated with this property filter.</p>
    #[doc(hidden)]
    pub property_name: std::option::Option<std::string::String>,
    /// <p>The operator associated with this property filter.</p>
    #[doc(hidden)]
    pub operator: std::option::Option<std::string::String>,
    /// <p>The value associated with this property filter.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::DataValue>,
}
impl PropertyFilter {
    /// <p>The property name associated with this property filter.</p>
    pub fn property_name(&self) -> std::option::Option<&str> {
        self.property_name.as_deref()
    }
    /// <p>The operator associated with this property filter.</p>
    pub fn operator(&self) -> std::option::Option<&str> {
        self.operator.as_deref()
    }
    /// <p>The value associated with this property filter.</p>
    pub fn value(&self) -> std::option::Option<&crate::model::DataValue> {
        self.value.as_ref()
    }
}
/// See [`PropertyFilter`](crate::model::PropertyFilter).
pub mod property_filter {

    /// A builder for [`PropertyFilter`](crate::model::PropertyFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) property_name: std::option::Option<std::string::String>,
        pub(crate) operator: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<crate::model::DataValue>,
    }
    impl Builder {
        /// <p>The property name associated with this property filter.</p>
        pub fn property_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_name = Some(input.into());
            self
        }
        /// <p>The property name associated with this property filter.</p>
        pub fn set_property_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.property_name = input;
            self
        }
        /// <p>The operator associated with this property filter.</p>
        pub fn operator(mut self, input: impl Into<std::string::String>) -> Self {
            self.operator = Some(input.into());
            self
        }
        /// <p>The operator associated with this property filter.</p>
        pub fn set_operator(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.operator = input;
            self
        }
        /// <p>The value associated with this property filter.</p>
        pub fn value(mut self, input: crate::model::DataValue) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value associated with this property filter.</p>
        pub fn set_value(mut self, input: std::option::Option<crate::model::DataValue>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`PropertyFilter`](crate::model::PropertyFilter).
        pub fn build(self) -> crate::model::PropertyFilter {
            crate::model::PropertyFilter {
                property_name: self.property_name,
                operator: self.operator,
                value: self.value,
            }
        }
    }
}
impl PropertyFilter {
    /// Creates a new builder-style object to manufacture [`PropertyFilter`](crate::model::PropertyFilter).
    pub fn builder() -> crate::model::property_filter::Builder {
        crate::model::property_filter::Builder::default()
    }
}

/// <p>The latest value of the property.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyLatestValue {
    /// <p>An object that specifies information about a property.&gt;</p>
    #[doc(hidden)]
    pub property_reference: std::option::Option<crate::model::EntityPropertyReference>,
    /// <p>The value of the property.</p>
    #[doc(hidden)]
    pub property_value: std::option::Option<crate::model::DataValue>,
}
impl PropertyLatestValue {
    /// <p>An object that specifies information about a property.&gt;</p>
    pub fn property_reference(
        &self,
    ) -> std::option::Option<&crate::model::EntityPropertyReference> {
        self.property_reference.as_ref()
    }
    /// <p>The value of the property.</p>
    pub fn property_value(&self) -> std::option::Option<&crate::model::DataValue> {
        self.property_value.as_ref()
    }
}
/// See [`PropertyLatestValue`](crate::model::PropertyLatestValue).
pub mod property_latest_value {

    /// A builder for [`PropertyLatestValue`](crate::model::PropertyLatestValue).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) property_reference: std::option::Option<crate::model::EntityPropertyReference>,
        pub(crate) property_value: std::option::Option<crate::model::DataValue>,
    }
    impl Builder {
        /// <p>An object that specifies information about a property.&gt;</p>
        pub fn property_reference(mut self, input: crate::model::EntityPropertyReference) -> Self {
            self.property_reference = Some(input);
            self
        }
        /// <p>An object that specifies information about a property.&gt;</p>
        pub fn set_property_reference(
            mut self,
            input: std::option::Option<crate::model::EntityPropertyReference>,
        ) -> Self {
            self.property_reference = input;
            self
        }
        /// <p>The value of the property.</p>
        pub fn property_value(mut self, input: crate::model::DataValue) -> Self {
            self.property_value = Some(input);
            self
        }
        /// <p>The value of the property.</p>
        pub fn set_property_value(
            mut self,
            input: std::option::Option<crate::model::DataValue>,
        ) -> Self {
            self.property_value = input;
            self
        }
        /// Consumes the builder and constructs a [`PropertyLatestValue`](crate::model::PropertyLatestValue).
        pub fn build(self) -> crate::model::PropertyLatestValue {
            crate::model::PropertyLatestValue {
                property_reference: self.property_reference,
                property_value: self.property_value,
            }
        }
    }
}
impl PropertyLatestValue {
    /// Creates a new builder-style object to manufacture [`PropertyLatestValue`](crate::model::PropertyLatestValue).
    pub fn builder() -> crate::model::property_latest_value::Builder {
        crate::model::property_latest_value::Builder::default()
    }
}

/// <p>The tabular conditions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TabularConditions {
    /// <p>Filter criteria that orders the output. It can be sorted in ascending or descending order.</p>
    #[doc(hidden)]
    pub order_by: std::option::Option<std::vec::Vec<crate::model::OrderBy>>,
    /// <p>You can filter the request using various logical operators and a key-value format. For example:</p>
    /// <p> <code>{"key": "serverType", "value": "webServer"}</code> </p>
    #[doc(hidden)]
    pub property_filters: std::option::Option<std::vec::Vec<crate::model::PropertyFilter>>,
}
impl TabularConditions {
    /// <p>Filter criteria that orders the output. It can be sorted in ascending or descending order.</p>
    pub fn order_by(&self) -> std::option::Option<&[crate::model::OrderBy]> {
        self.order_by.as_deref()
    }
    /// <p>You can filter the request using various logical operators and a key-value format. For example:</p>
    /// <p> <code>{"key": "serverType", "value": "webServer"}</code> </p>
    pub fn property_filters(&self) -> std::option::Option<&[crate::model::PropertyFilter]> {
        self.property_filters.as_deref()
    }
}
/// See [`TabularConditions`](crate::model::TabularConditions).
pub mod tabular_conditions {

    /// A builder for [`TabularConditions`](crate::model::TabularConditions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) order_by: std::option::Option<std::vec::Vec<crate::model::OrderBy>>,
        pub(crate) property_filters:
            std::option::Option<std::vec::Vec<crate::model::PropertyFilter>>,
    }
    impl Builder {
        /// Appends an item to `order_by`.
        ///
        /// To override the contents of this collection use [`set_order_by`](Self::set_order_by).
        ///
        /// <p>Filter criteria that orders the output. It can be sorted in ascending or descending order.</p>
        pub fn order_by(mut self, input: crate::model::OrderBy) -> Self {
            let mut v = self.order_by.unwrap_or_default();
            v.push(input);
            self.order_by = Some(v);
            self
        }
        /// <p>Filter criteria that orders the output. It can be sorted in ascending or descending order.</p>
        pub fn set_order_by(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::OrderBy>>,
        ) -> Self {
            self.order_by = input;
            self
        }
        /// Appends an item to `property_filters`.
        ///
        /// To override the contents of this collection use [`set_property_filters`](Self::set_property_filters).
        ///
        /// <p>You can filter the request using various logical operators and a key-value format. For example:</p>
        /// <p> <code>{"key": "serverType", "value": "webServer"}</code> </p>
        pub fn property_filters(mut self, input: crate::model::PropertyFilter) -> Self {
            let mut v = self.property_filters.unwrap_or_default();
            v.push(input);
            self.property_filters = Some(v);
            self
        }
        /// <p>You can filter the request using various logical operators and a key-value format. For example:</p>
        /// <p> <code>{"key": "serverType", "value": "webServer"}</code> </p>
        pub fn set_property_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PropertyFilter>>,
        ) -> Self {
            self.property_filters = input;
            self
        }
        /// Consumes the builder and constructs a [`TabularConditions`](crate::model::TabularConditions).
        pub fn build(self) -> crate::model::TabularConditions {
            crate::model::TabularConditions {
                order_by: self.order_by,
                property_filters: self.property_filters,
            }
        }
    }
}
impl TabularConditions {
    /// Creates a new builder-style object to manufacture [`TabularConditions`](crate::model::TabularConditions).
    pub fn builder() -> crate::model::tabular_conditions::Builder {
        crate::model::tabular_conditions::Builder::default()
    }
}

/// <p>Filter criteria that orders the return output. It can be sorted in ascending or descending order.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OrderBy {
    /// <p>The set order that filters results.</p>
    #[doc(hidden)]
    pub order: std::option::Option<crate::model::Order>,
    /// <p>The property name.</p>
    #[doc(hidden)]
    pub property_name: std::option::Option<std::string::String>,
}
impl OrderBy {
    /// <p>The set order that filters results.</p>
    pub fn order(&self) -> std::option::Option<&crate::model::Order> {
        self.order.as_ref()
    }
    /// <p>The property name.</p>
    pub fn property_name(&self) -> std::option::Option<&str> {
        self.property_name.as_deref()
    }
}
/// See [`OrderBy`](crate::model::OrderBy).
pub mod order_by {

    /// A builder for [`OrderBy`](crate::model::OrderBy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) order: std::option::Option<crate::model::Order>,
        pub(crate) property_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The set order that filters results.</p>
        pub fn order(mut self, input: crate::model::Order) -> Self {
            self.order = Some(input);
            self
        }
        /// <p>The set order that filters results.</p>
        pub fn set_order(mut self, input: std::option::Option<crate::model::Order>) -> Self {
            self.order = input;
            self
        }
        /// <p>The property name.</p>
        pub fn property_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_name = Some(input.into());
            self
        }
        /// <p>The property name.</p>
        pub fn set_property_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.property_name = input;
            self
        }
        /// Consumes the builder and constructs a [`OrderBy`](crate::model::OrderBy).
        pub fn build(self) -> crate::model::OrderBy {
            crate::model::OrderBy {
                order: self.order,
                property_name: self.property_name,
            }
        }
    }
}
impl OrderBy {
    /// Creates a new builder-style object to manufacture [`OrderBy`](crate::model::OrderBy).
    pub fn builder() -> crate::model::order_by::Builder {
        crate::model::order_by::Builder::default()
    }
}

/// When writing a match expression against `Order`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let order = unimplemented!();
/// match order {
///     Order::Ascending => { /* ... */ },
///     Order::Descending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `order` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Order::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Order::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Order::NewFeature` is defined.
/// Specifically, when `order` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Order::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Order {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Order {
    fn from(s: &str) -> Self {
        match s {
            "ASCENDING" => Order::Ascending,
            "DESCENDING" => Order::Descending,
            other => Order::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Order {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Order::from(s))
    }
}
impl Order {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Order::Ascending => "ASCENDING",
            Order::Descending => "DESCENDING",
            Order::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ASCENDING", "DESCENDING"]
    }
}
impl AsRef<str> for Order {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that returns information about a component type create or update request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComponentResponse {
    /// <p>The name of the component.</p>
    #[doc(hidden)]
    pub component_name: std::option::Option<std::string::String>,
    /// <p>The description of the component type.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The ID of the component type.</p>
    #[doc(hidden)]
    pub component_type_id: std::option::Option<std::string::String>,
    /// <p>The status of the component type.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::Status>,
    /// <p>The name of the property definition set in the request.</p>
    #[doc(hidden)]
    pub defined_in: std::option::Option<std::string::String>,
    /// <p>An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.</p>
    #[doc(hidden)]
    pub properties: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::PropertyResponse>,
    >,
    /// <p>The property groups.</p>
    #[doc(hidden)]
    pub property_groups: std::option::Option<
        std::collections::HashMap<
            std::string::String,
            crate::model::ComponentPropertyGroupResponse,
        >,
    >,
    /// <p>The syncSource of the sync job, if this entity was created by a sync job.</p>
    #[doc(hidden)]
    pub sync_source: std::option::Option<std::string::String>,
}
impl ComponentResponse {
    /// <p>The name of the component.</p>
    pub fn component_name(&self) -> std::option::Option<&str> {
        self.component_name.as_deref()
    }
    /// <p>The description of the component type.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The ID of the component type.</p>
    pub fn component_type_id(&self) -> std::option::Option<&str> {
        self.component_type_id.as_deref()
    }
    /// <p>The status of the component type.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::Status> {
        self.status.as_ref()
    }
    /// <p>The name of the property definition set in the request.</p>
    pub fn defined_in(&self) -> std::option::Option<&str> {
        self.defined_in.as_deref()
    }
    /// <p>An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.</p>
    pub fn properties(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::PropertyResponse>,
    > {
        self.properties.as_ref()
    }
    /// <p>The property groups.</p>
    pub fn property_groups(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<
            std::string::String,
            crate::model::ComponentPropertyGroupResponse,
        >,
    > {
        self.property_groups.as_ref()
    }
    /// <p>The syncSource of the sync job, if this entity was created by a sync job.</p>
    pub fn sync_source(&self) -> std::option::Option<&str> {
        self.sync_source.as_deref()
    }
}
/// See [`ComponentResponse`](crate::model::ComponentResponse).
pub mod component_response {

    /// A builder for [`ComponentResponse`](crate::model::ComponentResponse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) component_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) component_type_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::Status>,
        pub(crate) defined_in: std::option::Option<std::string::String>,
        pub(crate) properties: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::PropertyResponse>,
        >,
        pub(crate) property_groups: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                crate::model::ComponentPropertyGroupResponse,
            >,
        >,
        pub(crate) sync_source: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the component.</p>
        pub fn component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_name = Some(input.into());
            self
        }
        /// <p>The name of the component.</p>
        pub fn set_component_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.component_name = input;
            self
        }
        /// <p>The description of the component type.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the component type.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ID of the component type.</p>
        pub fn component_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_type_id = Some(input.into());
            self
        }
        /// <p>The ID of the component type.</p>
        pub fn set_component_type_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.component_type_id = input;
            self
        }
        /// <p>The status of the component type.</p>
        pub fn status(mut self, input: crate::model::Status) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the component type.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::Status>) -> Self {
            self.status = input;
            self
        }
        /// <p>The name of the property definition set in the request.</p>
        pub fn defined_in(mut self, input: impl Into<std::string::String>) -> Self {
            self.defined_in = Some(input.into());
            self
        }
        /// <p>The name of the property definition set in the request.</p>
        pub fn set_defined_in(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.defined_in = input;
            self
        }
        /// Adds a key-value pair to `properties`.
        ///
        /// To override the contents of this collection use [`set_properties`](Self::set_properties).
        ///
        /// <p>An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.</p>
        pub fn properties(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::PropertyResponse,
        ) -> Self {
            let mut hash_map = self.properties.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.properties = Some(hash_map);
            self
        }
        /// <p>An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.</p>
        pub fn set_properties(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::PropertyResponse>,
            >,
        ) -> Self {
            self.properties = input;
            self
        }
        /// Adds a key-value pair to `property_groups`.
        ///
        /// To override the contents of this collection use [`set_property_groups`](Self::set_property_groups).
        ///
        /// <p>The property groups.</p>
        pub fn property_groups(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::ComponentPropertyGroupResponse,
        ) -> Self {
            let mut hash_map = self.property_groups.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.property_groups = Some(hash_map);
            self
        }
        /// <p>The property groups.</p>
        pub fn set_property_groups(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::ComponentPropertyGroupResponse,
                >,
            >,
        ) -> Self {
            self.property_groups = input;
            self
        }
        /// <p>The syncSource of the sync job, if this entity was created by a sync job.</p>
        pub fn sync_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.sync_source = Some(input.into());
            self
        }
        /// <p>The syncSource of the sync job, if this entity was created by a sync job.</p>
        pub fn set_sync_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sync_source = input;
            self
        }
        /// Consumes the builder and constructs a [`ComponentResponse`](crate::model::ComponentResponse).
        pub fn build(self) -> crate::model::ComponentResponse {
            crate::model::ComponentResponse {
                component_name: self.component_name,
                description: self.description,
                component_type_id: self.component_type_id,
                status: self.status,
                defined_in: self.defined_in,
                properties: self.properties,
                property_groups: self.property_groups,
                sync_source: self.sync_source,
            }
        }
    }
}
impl ComponentResponse {
    /// Creates a new builder-style object to manufacture [`ComponentResponse`](crate::model::ComponentResponse).
    pub fn builder() -> crate::model::component_response::Builder {
        crate::model::component_response::Builder::default()
    }
}

/// <p>The component property group response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComponentPropertyGroupResponse {
    /// <p>The group type.</p>
    #[doc(hidden)]
    pub group_type: std::option::Option<crate::model::GroupType>,
    /// <p>The names of properties</p>
    #[doc(hidden)]
    pub property_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A Boolean value that specifies whether the property group is inherited from a parent entity</p>
    #[doc(hidden)]
    pub is_inherited: std::option::Option<bool>,
}
impl ComponentPropertyGroupResponse {
    /// <p>The group type.</p>
    pub fn group_type(&self) -> std::option::Option<&crate::model::GroupType> {
        self.group_type.as_ref()
    }
    /// <p>The names of properties</p>
    pub fn property_names(&self) -> std::option::Option<&[std::string::String]> {
        self.property_names.as_deref()
    }
    /// <p>A Boolean value that specifies whether the property group is inherited from a parent entity</p>
    pub fn is_inherited(&self) -> std::option::Option<bool> {
        self.is_inherited
    }
}
/// See [`ComponentPropertyGroupResponse`](crate::model::ComponentPropertyGroupResponse).
pub mod component_property_group_response {

    /// A builder for [`ComponentPropertyGroupResponse`](crate::model::ComponentPropertyGroupResponse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_type: std::option::Option<crate::model::GroupType>,
        pub(crate) property_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) is_inherited: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The group type.</p>
        pub fn group_type(mut self, input: crate::model::GroupType) -> Self {
            self.group_type = Some(input);
            self
        }
        /// <p>The group type.</p>
        pub fn set_group_type(
            mut self,
            input: std::option::Option<crate::model::GroupType>,
        ) -> Self {
            self.group_type = input;
            self
        }
        /// Appends an item to `property_names`.
        ///
        /// To override the contents of this collection use [`set_property_names`](Self::set_property_names).
        ///
        /// <p>The names of properties</p>
        pub fn property_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.property_names.unwrap_or_default();
            v.push(input.into());
            self.property_names = Some(v);
            self
        }
        /// <p>The names of properties</p>
        pub fn set_property_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.property_names = input;
            self
        }
        /// <p>A Boolean value that specifies whether the property group is inherited from a parent entity</p>
        pub fn is_inherited(mut self, input: bool) -> Self {
            self.is_inherited = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property group is inherited from a parent entity</p>
        pub fn set_is_inherited(mut self, input: std::option::Option<bool>) -> Self {
            self.is_inherited = input;
            self
        }
        /// Consumes the builder and constructs a [`ComponentPropertyGroupResponse`](crate::model::ComponentPropertyGroupResponse).
        pub fn build(self) -> crate::model::ComponentPropertyGroupResponse {
            crate::model::ComponentPropertyGroupResponse {
                group_type: self.group_type,
                property_names: self.property_names,
                is_inherited: self.is_inherited,
            }
        }
    }
}
impl ComponentPropertyGroupResponse {
    /// Creates a new builder-style object to manufacture [`ComponentPropertyGroupResponse`](crate::model::ComponentPropertyGroupResponse).
    pub fn builder() -> crate::model::component_property_group_response::Builder {
        crate::model::component_property_group_response::Builder::default()
    }
}

/// <p>An object that contains information about a property response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyResponse {
    /// <p>An object that specifies information about a property.</p>
    #[doc(hidden)]
    pub definition: std::option::Option<crate::model::PropertyDefinitionResponse>,
    /// <p>The value of the property.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::DataValue>,
}
impl PropertyResponse {
    /// <p>An object that specifies information about a property.</p>
    pub fn definition(&self) -> std::option::Option<&crate::model::PropertyDefinitionResponse> {
        self.definition.as_ref()
    }
    /// <p>The value of the property.</p>
    pub fn value(&self) -> std::option::Option<&crate::model::DataValue> {
        self.value.as_ref()
    }
}
/// See [`PropertyResponse`](crate::model::PropertyResponse).
pub mod property_response {

    /// A builder for [`PropertyResponse`](crate::model::PropertyResponse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) definition: std::option::Option<crate::model::PropertyDefinitionResponse>,
        pub(crate) value: std::option::Option<crate::model::DataValue>,
    }
    impl Builder {
        /// <p>An object that specifies information about a property.</p>
        pub fn definition(mut self, input: crate::model::PropertyDefinitionResponse) -> Self {
            self.definition = Some(input);
            self
        }
        /// <p>An object that specifies information about a property.</p>
        pub fn set_definition(
            mut self,
            input: std::option::Option<crate::model::PropertyDefinitionResponse>,
        ) -> Self {
            self.definition = input;
            self
        }
        /// <p>The value of the property.</p>
        pub fn value(mut self, input: crate::model::DataValue) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the property.</p>
        pub fn set_value(mut self, input: std::option::Option<crate::model::DataValue>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`PropertyResponse`](crate::model::PropertyResponse).
        pub fn build(self) -> crate::model::PropertyResponse {
            crate::model::PropertyResponse {
                definition: self.definition,
                value: self.value,
            }
        }
    }
}
impl PropertyResponse {
    /// Creates a new builder-style object to manufacture [`PropertyResponse`](crate::model::PropertyResponse).
    pub fn builder() -> crate::model::property_response::Builder {
        crate::model::property_response::Builder::default()
    }
}

/// <p>An object that contains response data from a property definition request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyDefinitionResponse {
    /// <p>An object that contains information about the data type.</p>
    #[doc(hidden)]
    pub data_type: std::option::Option<crate::model::DataType>,
    /// <p>A Boolean value that specifies whether the property consists of time series data.</p>
    #[doc(hidden)]
    pub is_time_series: std::option::Option<bool>,
    /// <p>A Boolean value that specifies whether the property is required in an entity.</p>
    #[doc(hidden)]
    pub is_required_in_entity: std::option::Option<bool>,
    /// <p>A Boolean value that specifies whether the property ID comes from an external data store.</p>
    #[doc(hidden)]
    pub is_external_id: std::option::Option<bool>,
    /// <p>A Boolean value that specifies whether the property is stored externally.</p>
    #[doc(hidden)]
    pub is_stored_externally: std::option::Option<bool>,
    /// <p>A Boolean value that specifies whether the property definition is imported from an external data store.</p>
    #[doc(hidden)]
    pub is_imported: std::option::Option<bool>,
    /// <p>A Boolean value that specifies whether the property definition can be updated.</p>
    #[doc(hidden)]
    pub is_final: std::option::Option<bool>,
    /// <p>A Boolean value that specifies whether the property definition is inherited from a parent entity.</p>
    #[doc(hidden)]
    pub is_inherited: std::option::Option<bool>,
    /// <p>An object that contains the default value.</p>
    #[doc(hidden)]
    pub default_value: std::option::Option<crate::model::DataValue>,
    /// <p>A mapping that specifies configuration information about the property.</p>
    #[doc(hidden)]
    pub configuration:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A friendly name for the property.</p>
    #[doc(hidden)]
    pub display_name: std::option::Option<std::string::String>,
}
impl PropertyDefinitionResponse {
    /// <p>An object that contains information about the data type.</p>
    pub fn data_type(&self) -> std::option::Option<&crate::model::DataType> {
        self.data_type.as_ref()
    }
    /// <p>A Boolean value that specifies whether the property consists of time series data.</p>
    pub fn is_time_series(&self) -> std::option::Option<bool> {
        self.is_time_series
    }
    /// <p>A Boolean value that specifies whether the property is required in an entity.</p>
    pub fn is_required_in_entity(&self) -> std::option::Option<bool> {
        self.is_required_in_entity
    }
    /// <p>A Boolean value that specifies whether the property ID comes from an external data store.</p>
    pub fn is_external_id(&self) -> std::option::Option<bool> {
        self.is_external_id
    }
    /// <p>A Boolean value that specifies whether the property is stored externally.</p>
    pub fn is_stored_externally(&self) -> std::option::Option<bool> {
        self.is_stored_externally
    }
    /// <p>A Boolean value that specifies whether the property definition is imported from an external data store.</p>
    pub fn is_imported(&self) -> std::option::Option<bool> {
        self.is_imported
    }
    /// <p>A Boolean value that specifies whether the property definition can be updated.</p>
    pub fn is_final(&self) -> std::option::Option<bool> {
        self.is_final
    }
    /// <p>A Boolean value that specifies whether the property definition is inherited from a parent entity.</p>
    pub fn is_inherited(&self) -> std::option::Option<bool> {
        self.is_inherited
    }
    /// <p>An object that contains the default value.</p>
    pub fn default_value(&self) -> std::option::Option<&crate::model::DataValue> {
        self.default_value.as_ref()
    }
    /// <p>A mapping that specifies configuration information about the property.</p>
    pub fn configuration(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.configuration.as_ref()
    }
    /// <p>A friendly name for the property.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
}
/// See [`PropertyDefinitionResponse`](crate::model::PropertyDefinitionResponse).
pub mod property_definition_response {

    /// A builder for [`PropertyDefinitionResponse`](crate::model::PropertyDefinitionResponse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_type: std::option::Option<crate::model::DataType>,
        pub(crate) is_time_series: std::option::Option<bool>,
        pub(crate) is_required_in_entity: std::option::Option<bool>,
        pub(crate) is_external_id: std::option::Option<bool>,
        pub(crate) is_stored_externally: std::option::Option<bool>,
        pub(crate) is_imported: std::option::Option<bool>,
        pub(crate) is_final: std::option::Option<bool>,
        pub(crate) is_inherited: std::option::Option<bool>,
        pub(crate) default_value: std::option::Option<crate::model::DataValue>,
        pub(crate) configuration: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) display_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An object that contains information about the data type.</p>
        pub fn data_type(mut self, input: crate::model::DataType) -> Self {
            self.data_type = Some(input);
            self
        }
        /// <p>An object that contains information about the data type.</p>
        pub fn set_data_type(mut self, input: std::option::Option<crate::model::DataType>) -> Self {
            self.data_type = input;
            self
        }
        /// <p>A Boolean value that specifies whether the property consists of time series data.</p>
        pub fn is_time_series(mut self, input: bool) -> Self {
            self.is_time_series = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property consists of time series data.</p>
        pub fn set_is_time_series(mut self, input: std::option::Option<bool>) -> Self {
            self.is_time_series = input;
            self
        }
        /// <p>A Boolean value that specifies whether the property is required in an entity.</p>
        pub fn is_required_in_entity(mut self, input: bool) -> Self {
            self.is_required_in_entity = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property is required in an entity.</p>
        pub fn set_is_required_in_entity(mut self, input: std::option::Option<bool>) -> Self {
            self.is_required_in_entity = input;
            self
        }
        /// <p>A Boolean value that specifies whether the property ID comes from an external data store.</p>
        pub fn is_external_id(mut self, input: bool) -> Self {
            self.is_external_id = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property ID comes from an external data store.</p>
        pub fn set_is_external_id(mut self, input: std::option::Option<bool>) -> Self {
            self.is_external_id = input;
            self
        }
        /// <p>A Boolean value that specifies whether the property is stored externally.</p>
        pub fn is_stored_externally(mut self, input: bool) -> Self {
            self.is_stored_externally = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property is stored externally.</p>
        pub fn set_is_stored_externally(mut self, input: std::option::Option<bool>) -> Self {
            self.is_stored_externally = input;
            self
        }
        /// <p>A Boolean value that specifies whether the property definition is imported from an external data store.</p>
        pub fn is_imported(mut self, input: bool) -> Self {
            self.is_imported = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property definition is imported from an external data store.</p>
        pub fn set_is_imported(mut self, input: std::option::Option<bool>) -> Self {
            self.is_imported = input;
            self
        }
        /// <p>A Boolean value that specifies whether the property definition can be updated.</p>
        pub fn is_final(mut self, input: bool) -> Self {
            self.is_final = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property definition can be updated.</p>
        pub fn set_is_final(mut self, input: std::option::Option<bool>) -> Self {
            self.is_final = input;
            self
        }
        /// <p>A Boolean value that specifies whether the property definition is inherited from a parent entity.</p>
        pub fn is_inherited(mut self, input: bool) -> Self {
            self.is_inherited = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property definition is inherited from a parent entity.</p>
        pub fn set_is_inherited(mut self, input: std::option::Option<bool>) -> Self {
            self.is_inherited = input;
            self
        }
        /// <p>An object that contains the default value.</p>
        pub fn default_value(mut self, input: crate::model::DataValue) -> Self {
            self.default_value = Some(input);
            self
        }
        /// <p>An object that contains the default value.</p>
        pub fn set_default_value(
            mut self,
            input: std::option::Option<crate::model::DataValue>,
        ) -> Self {
            self.default_value = input;
            self
        }
        /// Adds a key-value pair to `configuration`.
        ///
        /// To override the contents of this collection use [`set_configuration`](Self::set_configuration).
        ///
        /// <p>A mapping that specifies configuration information about the property.</p>
        pub fn configuration(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.configuration.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.configuration = Some(hash_map);
            self
        }
        /// <p>A mapping that specifies configuration information about the property.</p>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// <p>A friendly name for the property.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>A friendly name for the property.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// Consumes the builder and constructs a [`PropertyDefinitionResponse`](crate::model::PropertyDefinitionResponse).
        pub fn build(self) -> crate::model::PropertyDefinitionResponse {
            crate::model::PropertyDefinitionResponse {
                data_type: self.data_type,
                is_time_series: self.is_time_series,
                is_required_in_entity: self.is_required_in_entity,
                is_external_id: self.is_external_id,
                is_stored_externally: self.is_stored_externally,
                is_imported: self.is_imported,
                is_final: self.is_final,
                is_inherited: self.is_inherited,
                default_value: self.default_value,
                configuration: self.configuration,
                display_name: self.display_name,
            }
        }
    }
}
impl PropertyDefinitionResponse {
    /// Creates a new builder-style object to manufacture [`PropertyDefinitionResponse`](crate::model::PropertyDefinitionResponse).
    pub fn builder() -> crate::model::property_definition_response::Builder {
        crate::model::property_definition_response::Builder::default()
    }
}

/// <p>The property group response</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyGroupResponse {
    /// <p>The group types.</p>
    #[doc(hidden)]
    pub group_type: std::option::Option<crate::model::GroupType>,
    /// <p>The names of properties.</p>
    #[doc(hidden)]
    pub property_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A Boolean value that specifies whether the property group is inherited from a parent entity</p>
    #[doc(hidden)]
    pub is_inherited: std::option::Option<bool>,
}
impl PropertyGroupResponse {
    /// <p>The group types.</p>
    pub fn group_type(&self) -> std::option::Option<&crate::model::GroupType> {
        self.group_type.as_ref()
    }
    /// <p>The names of properties.</p>
    pub fn property_names(&self) -> std::option::Option<&[std::string::String]> {
        self.property_names.as_deref()
    }
    /// <p>A Boolean value that specifies whether the property group is inherited from a parent entity</p>
    pub fn is_inherited(&self) -> std::option::Option<bool> {
        self.is_inherited
    }
}
/// See [`PropertyGroupResponse`](crate::model::PropertyGroupResponse).
pub mod property_group_response {

    /// A builder for [`PropertyGroupResponse`](crate::model::PropertyGroupResponse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_type: std::option::Option<crate::model::GroupType>,
        pub(crate) property_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) is_inherited: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The group types.</p>
        pub fn group_type(mut self, input: crate::model::GroupType) -> Self {
            self.group_type = Some(input);
            self
        }
        /// <p>The group types.</p>
        pub fn set_group_type(
            mut self,
            input: std::option::Option<crate::model::GroupType>,
        ) -> Self {
            self.group_type = input;
            self
        }
        /// Appends an item to `property_names`.
        ///
        /// To override the contents of this collection use [`set_property_names`](Self::set_property_names).
        ///
        /// <p>The names of properties.</p>
        pub fn property_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.property_names.unwrap_or_default();
            v.push(input.into());
            self.property_names = Some(v);
            self
        }
        /// <p>The names of properties.</p>
        pub fn set_property_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.property_names = input;
            self
        }
        /// <p>A Boolean value that specifies whether the property group is inherited from a parent entity</p>
        pub fn is_inherited(mut self, input: bool) -> Self {
            self.is_inherited = Some(input);
            self
        }
        /// <p>A Boolean value that specifies whether the property group is inherited from a parent entity</p>
        pub fn set_is_inherited(mut self, input: std::option::Option<bool>) -> Self {
            self.is_inherited = input;
            self
        }
        /// Consumes the builder and constructs a [`PropertyGroupResponse`](crate::model::PropertyGroupResponse).
        pub fn build(self) -> crate::model::PropertyGroupResponse {
            crate::model::PropertyGroupResponse {
                group_type: self.group_type,
                property_names: self.property_names,
                is_inherited: self.is_inherited,
            }
        }
    }
}
impl PropertyGroupResponse {
    /// Creates a new builder-style object to manufacture [`PropertyGroupResponse`](crate::model::PropertyGroupResponse).
    pub fn builder() -> crate::model::property_group_response::Builder {
        crate::model::property_group_response::Builder::default()
    }
}

/// <p>The function response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FunctionResponse {
    /// <p>The required properties of the function.</p>
    #[doc(hidden)]
    pub required_properties: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The scope of the function.</p>
    #[doc(hidden)]
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>The data connector.</p>
    #[doc(hidden)]
    pub implemented_by: std::option::Option<crate::model::DataConnector>,
    /// <p>Indicates whether this function is inherited.</p>
    #[doc(hidden)]
    pub is_inherited: std::option::Option<bool>,
}
impl FunctionResponse {
    /// <p>The required properties of the function.</p>
    pub fn required_properties(&self) -> std::option::Option<&[std::string::String]> {
        self.required_properties.as_deref()
    }
    /// <p>The scope of the function.</p>
    pub fn scope(&self) -> std::option::Option<&crate::model::Scope> {
        self.scope.as_ref()
    }
    /// <p>The data connector.</p>
    pub fn implemented_by(&self) -> std::option::Option<&crate::model::DataConnector> {
        self.implemented_by.as_ref()
    }
    /// <p>Indicates whether this function is inherited.</p>
    pub fn is_inherited(&self) -> std::option::Option<bool> {
        self.is_inherited
    }
}
/// See [`FunctionResponse`](crate::model::FunctionResponse).
pub mod function_response {

    /// A builder for [`FunctionResponse`](crate::model::FunctionResponse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) required_properties: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) implemented_by: std::option::Option<crate::model::DataConnector>,
        pub(crate) is_inherited: std::option::Option<bool>,
    }
    impl Builder {
        /// Appends an item to `required_properties`.
        ///
        /// To override the contents of this collection use [`set_required_properties`](Self::set_required_properties).
        ///
        /// <p>The required properties of the function.</p>
        pub fn required_properties(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.required_properties.unwrap_or_default();
            v.push(input.into());
            self.required_properties = Some(v);
            self
        }
        /// <p>The required properties of the function.</p>
        pub fn set_required_properties(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.required_properties = input;
            self
        }
        /// <p>The scope of the function.</p>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        /// <p>The scope of the function.</p>
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>The data connector.</p>
        pub fn implemented_by(mut self, input: crate::model::DataConnector) -> Self {
            self.implemented_by = Some(input);
            self
        }
        /// <p>The data connector.</p>
        pub fn set_implemented_by(
            mut self,
            input: std::option::Option<crate::model::DataConnector>,
        ) -> Self {
            self.implemented_by = input;
            self
        }
        /// <p>Indicates whether this function is inherited.</p>
        pub fn is_inherited(mut self, input: bool) -> Self {
            self.is_inherited = Some(input);
            self
        }
        /// <p>Indicates whether this function is inherited.</p>
        pub fn set_is_inherited(mut self, input: std::option::Option<bool>) -> Self {
            self.is_inherited = input;
            self
        }
        /// Consumes the builder and constructs a [`FunctionResponse`](crate::model::FunctionResponse).
        pub fn build(self) -> crate::model::FunctionResponse {
            crate::model::FunctionResponse {
                required_properties: self.required_properties,
                scope: self.scope,
                implemented_by: self.implemented_by,
                is_inherited: self.is_inherited,
            }
        }
    }
}
impl FunctionResponse {
    /// Creates a new builder-style object to manufacture [`FunctionResponse`](crate::model::FunctionResponse).
    pub fn builder() -> crate::model::function_response::Builder {
        crate::model::function_response::Builder::default()
    }
}

/// <p>Represents a single row in the query results.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Row {
    /// <p>The data in a row of query results.</p>
    #[doc(hidden)]
    pub row_data: std::option::Option<std::vec::Vec<aws_smithy_types::Document>>,
}
impl Row {
    /// <p>The data in a row of query results.</p>
    pub fn row_data(&self) -> std::option::Option<&[aws_smithy_types::Document]> {
        self.row_data.as_deref()
    }
}
/// See [`Row`](crate::model::Row).
pub mod row {

    /// A builder for [`Row`](crate::model::Row).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) row_data: std::option::Option<std::vec::Vec<aws_smithy_types::Document>>,
    }
    impl Builder {
        /// Appends an item to `row_data`.
        ///
        /// To override the contents of this collection use [`set_row_data`](Self::set_row_data).
        ///
        /// <p>The data in a row of query results.</p>
        pub fn row_data(mut self, input: aws_smithy_types::Document) -> Self {
            let mut v = self.row_data.unwrap_or_default();
            v.push(input);
            self.row_data = Some(v);
            self
        }
        /// <p>The data in a row of query results.</p>
        pub fn set_row_data(
            mut self,
            input: std::option::Option<std::vec::Vec<aws_smithy_types::Document>>,
        ) -> Self {
            self.row_data = input;
            self
        }
        /// Consumes the builder and constructs a [`Row`](crate::model::Row).
        pub fn build(self) -> crate::model::Row {
            crate::model::Row {
                row_data: self.row_data,
            }
        }
    }
}
impl Row {
    /// Creates a new builder-style object to manufacture [`Row`](crate::model::Row).
    pub fn builder() -> crate::model::row::Builder {
        crate::model::row::Builder::default()
    }
}

/// <p>A description of the column in the query results.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColumnDescription {
    /// <p>The name of the column description.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of the column description.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ColumnType>,
}
impl ColumnDescription {
    /// <p>The name of the column description.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of the column description.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ColumnType> {
        self.r#type.as_ref()
    }
}
/// See [`ColumnDescription`](crate::model::ColumnDescription).
pub mod column_description {

    /// A builder for [`ColumnDescription`](crate::model::ColumnDescription).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ColumnType>,
    }
    impl Builder {
        /// <p>The name of the column description.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the column description.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of the column description.</p>
        pub fn r#type(mut self, input: crate::model::ColumnType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the column description.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::ColumnType>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`ColumnDescription`](crate::model::ColumnDescription).
        pub fn build(self) -> crate::model::ColumnDescription {
            crate::model::ColumnDescription {
                name: self.name,
                r#type: self.r#type,
            }
        }
    }
}
impl ColumnDescription {
    /// Creates a new builder-style object to manufacture [`ColumnDescription`](crate::model::ColumnDescription).
    pub fn builder() -> crate::model::column_description::Builder {
        crate::model::column_description::Builder::default()
    }
}

/// When writing a match expression against `ColumnType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let columntype = unimplemented!();
/// match columntype {
///     ColumnType::Edge => { /* ... */ },
///     ColumnType::Node => { /* ... */ },
///     ColumnType::Value => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `columntype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ColumnType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ColumnType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ColumnType::NewFeature` is defined.
/// Specifically, when `columntype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ColumnType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ColumnType {
    #[allow(missing_docs)] // documentation missing in model
    Edge,
    #[allow(missing_docs)] // documentation missing in model
    Node,
    #[allow(missing_docs)] // documentation missing in model
    Value,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ColumnType {
    fn from(s: &str) -> Self {
        match s {
            "EDGE" => ColumnType::Edge,
            "NODE" => ColumnType::Node,
            "VALUE" => ColumnType::Value,
            other => ColumnType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ColumnType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ColumnType::from(s))
    }
}
impl ColumnType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ColumnType::Edge => "EDGE",
            ColumnType::Node => "NODE",
            ColumnType::Value => "VALUE",
            ColumnType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EDGE", "NODE", "VALUE"]
    }
}
impl AsRef<str> for ColumnType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that sets information about a component type create or update request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComponentRequest {
    /// <p>The description of the component request.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The ID of the component type.</p>
    #[doc(hidden)]
    pub component_type_id: std::option::Option<std::string::String>,
    /// <p>An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.</p>
    #[doc(hidden)]
    pub properties: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::PropertyRequest>,
    >,
    /// <p>The property groups.</p>
    #[doc(hidden)]
    pub property_groups: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::ComponentPropertyGroupRequest>,
    >,
}
impl ComponentRequest {
    /// <p>The description of the component request.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The ID of the component type.</p>
    pub fn component_type_id(&self) -> std::option::Option<&str> {
        self.component_type_id.as_deref()
    }
    /// <p>An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.</p>
    pub fn properties(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::PropertyRequest>,
    > {
        self.properties.as_ref()
    }
    /// <p>The property groups.</p>
    pub fn property_groups(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<
            std::string::String,
            crate::model::ComponentPropertyGroupRequest,
        >,
    > {
        self.property_groups.as_ref()
    }
}
/// See [`ComponentRequest`](crate::model::ComponentRequest).
pub mod component_request {

    /// A builder for [`ComponentRequest`](crate::model::ComponentRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) component_type_id: std::option::Option<std::string::String>,
        pub(crate) properties: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::PropertyRequest>,
        >,
        pub(crate) property_groups: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                crate::model::ComponentPropertyGroupRequest,
            >,
        >,
    }
    impl Builder {
        /// <p>The description of the component request.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the component request.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ID of the component type.</p>
        pub fn component_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_type_id = Some(input.into());
            self
        }
        /// <p>The ID of the component type.</p>
        pub fn set_component_type_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.component_type_id = input;
            self
        }
        /// Adds a key-value pair to `properties`.
        ///
        /// To override the contents of this collection use [`set_properties`](Self::set_properties).
        ///
        /// <p>An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.</p>
        pub fn properties(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::PropertyRequest,
        ) -> Self {
            let mut hash_map = self.properties.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.properties = Some(hash_map);
            self
        }
        /// <p>An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.</p>
        pub fn set_properties(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::PropertyRequest>,
            >,
        ) -> Self {
            self.properties = input;
            self
        }
        /// Adds a key-value pair to `property_groups`.
        ///
        /// To override the contents of this collection use [`set_property_groups`](Self::set_property_groups).
        ///
        /// <p>The property groups.</p>
        pub fn property_groups(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::ComponentPropertyGroupRequest,
        ) -> Self {
            let mut hash_map = self.property_groups.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.property_groups = Some(hash_map);
            self
        }
        /// <p>The property groups.</p>
        pub fn set_property_groups(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::ComponentPropertyGroupRequest,
                >,
            >,
        ) -> Self {
            self.property_groups = input;
            self
        }
        /// Consumes the builder and constructs a [`ComponentRequest`](crate::model::ComponentRequest).
        pub fn build(self) -> crate::model::ComponentRequest {
            crate::model::ComponentRequest {
                description: self.description,
                component_type_id: self.component_type_id,
                properties: self.properties,
                property_groups: self.property_groups,
            }
        }
    }
}
impl ComponentRequest {
    /// Creates a new builder-style object to manufacture [`ComponentRequest`](crate::model::ComponentRequest).
    pub fn builder() -> crate::model::component_request::Builder {
        crate::model::component_request::Builder::default()
    }
}

/// <p>An object that contains information about errors returned by the <code>BatchPutProperty</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchPutPropertyErrorEntry {
    /// <p>A list of objects that contain information about errors returned by the <code>BatchPutProperty</code> action.</p>
    #[doc(hidden)]
    pub errors: std::option::Option<std::vec::Vec<crate::model::BatchPutPropertyError>>,
}
impl BatchPutPropertyErrorEntry {
    /// <p>A list of objects that contain information about errors returned by the <code>BatchPutProperty</code> action.</p>
    pub fn errors(&self) -> std::option::Option<&[crate::model::BatchPutPropertyError]> {
        self.errors.as_deref()
    }
}
/// See [`BatchPutPropertyErrorEntry`](crate::model::BatchPutPropertyErrorEntry).
pub mod batch_put_property_error_entry {

    /// A builder for [`BatchPutPropertyErrorEntry`](crate::model::BatchPutPropertyErrorEntry).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) errors: std::option::Option<std::vec::Vec<crate::model::BatchPutPropertyError>>,
    }
    impl Builder {
        /// Appends an item to `errors`.
        ///
        /// To override the contents of this collection use [`set_errors`](Self::set_errors).
        ///
        /// <p>A list of objects that contain information about errors returned by the <code>BatchPutProperty</code> action.</p>
        pub fn errors(mut self, input: crate::model::BatchPutPropertyError) -> Self {
            let mut v = self.errors.unwrap_or_default();
            v.push(input);
            self.errors = Some(v);
            self
        }
        /// <p>A list of objects that contain information about errors returned by the <code>BatchPutProperty</code> action.</p>
        pub fn set_errors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BatchPutPropertyError>>,
        ) -> Self {
            self.errors = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchPutPropertyErrorEntry`](crate::model::BatchPutPropertyErrorEntry).
        pub fn build(self) -> crate::model::BatchPutPropertyErrorEntry {
            crate::model::BatchPutPropertyErrorEntry {
                errors: self.errors,
            }
        }
    }
}
impl BatchPutPropertyErrorEntry {
    /// Creates a new builder-style object to manufacture [`BatchPutPropertyErrorEntry`](crate::model::BatchPutPropertyErrorEntry).
    pub fn builder() -> crate::model::batch_put_property_error_entry::Builder {
        crate::model::batch_put_property_error_entry::Builder::default()
    }
}

/// <p>An error returned by the <code>BatchPutProperty</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchPutPropertyError {
    /// <p>The error code.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The error message.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>An object that contains information about errors returned by the <code>BatchPutProperty</code> action.</p>
    #[doc(hidden)]
    pub entry: std::option::Option<crate::model::PropertyValueEntry>,
}
impl BatchPutPropertyError {
    /// <p>The error code.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>The error message.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>An object that contains information about errors returned by the <code>BatchPutProperty</code> action.</p>
    pub fn entry(&self) -> std::option::Option<&crate::model::PropertyValueEntry> {
        self.entry.as_ref()
    }
}
/// See [`BatchPutPropertyError`](crate::model::BatchPutPropertyError).
pub mod batch_put_property_error {

    /// A builder for [`BatchPutPropertyError`](crate::model::BatchPutPropertyError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) entry: std::option::Option<crate::model::PropertyValueEntry>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The error code.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The error message.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The error message.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>An object that contains information about errors returned by the <code>BatchPutProperty</code> action.</p>
        pub fn entry(mut self, input: crate::model::PropertyValueEntry) -> Self {
            self.entry = Some(input);
            self
        }
        /// <p>An object that contains information about errors returned by the <code>BatchPutProperty</code> action.</p>
        pub fn set_entry(
            mut self,
            input: std::option::Option<crate::model::PropertyValueEntry>,
        ) -> Self {
            self.entry = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchPutPropertyError`](crate::model::BatchPutPropertyError).
        pub fn build(self) -> crate::model::BatchPutPropertyError {
            crate::model::BatchPutPropertyError {
                error_code: self.error_code,
                error_message: self.error_message,
                entry: self.entry,
            }
        }
    }
}
impl BatchPutPropertyError {
    /// Creates a new builder-style object to manufacture [`BatchPutPropertyError`](crate::model::BatchPutPropertyError).
    pub fn builder() -> crate::model::batch_put_property_error::Builder {
        crate::model::batch_put_property_error::Builder::default()
    }
}

/// <p>An object that specifies information about time series property values. This object is used and consumed by the <a href="https://docs.aws.amazon.com/iot-twinmaker/latest/apireference/API_BatchPutPropertyValues.html">BatchPutPropertyValues</a> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyValueEntry {
    /// <p>An object that contains information about the entity that has the property.</p>
    #[doc(hidden)]
    pub entity_property_reference: std::option::Option<crate::model::EntityPropertyReference>,
    /// <p>A list of objects that specify time series property values.</p>
    #[doc(hidden)]
    pub property_values: std::option::Option<std::vec::Vec<crate::model::PropertyValue>>,
}
impl PropertyValueEntry {
    /// <p>An object that contains information about the entity that has the property.</p>
    pub fn entity_property_reference(
        &self,
    ) -> std::option::Option<&crate::model::EntityPropertyReference> {
        self.entity_property_reference.as_ref()
    }
    /// <p>A list of objects that specify time series property values.</p>
    pub fn property_values(&self) -> std::option::Option<&[crate::model::PropertyValue]> {
        self.property_values.as_deref()
    }
}
/// See [`PropertyValueEntry`](crate::model::PropertyValueEntry).
pub mod property_value_entry {

    /// A builder for [`PropertyValueEntry`](crate::model::PropertyValueEntry).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entity_property_reference:
            std::option::Option<crate::model::EntityPropertyReference>,
        pub(crate) property_values: std::option::Option<std::vec::Vec<crate::model::PropertyValue>>,
    }
    impl Builder {
        /// <p>An object that contains information about the entity that has the property.</p>
        pub fn entity_property_reference(
            mut self,
            input: crate::model::EntityPropertyReference,
        ) -> Self {
            self.entity_property_reference = Some(input);
            self
        }
        /// <p>An object that contains information about the entity that has the property.</p>
        pub fn set_entity_property_reference(
            mut self,
            input: std::option::Option<crate::model::EntityPropertyReference>,
        ) -> Self {
            self.entity_property_reference = input;
            self
        }
        /// Appends an item to `property_values`.
        ///
        /// To override the contents of this collection use [`set_property_values`](Self::set_property_values).
        ///
        /// <p>A list of objects that specify time series property values.</p>
        pub fn property_values(mut self, input: crate::model::PropertyValue) -> Self {
            let mut v = self.property_values.unwrap_or_default();
            v.push(input);
            self.property_values = Some(v);
            self
        }
        /// <p>A list of objects that specify time series property values.</p>
        pub fn set_property_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PropertyValue>>,
        ) -> Self {
            self.property_values = input;
            self
        }
        /// Consumes the builder and constructs a [`PropertyValueEntry`](crate::model::PropertyValueEntry).
        pub fn build(self) -> crate::model::PropertyValueEntry {
            crate::model::PropertyValueEntry {
                entity_property_reference: self.entity_property_reference,
                property_values: self.property_values,
            }
        }
    }
}
impl PropertyValueEntry {
    /// Creates a new builder-style object to manufacture [`PropertyValueEntry`](crate::model::PropertyValueEntry).
    pub fn builder() -> crate::model::property_value_entry::Builder {
        crate::model::property_value_entry::Builder::default()
    }
}
