// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type UntagResourceErrorKind = UntagResourceError;
/// Error type for the `UntagResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceError {
    /// <p>You do not have sufficient permission to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Invalid input was provided.</p>
    IllegalArgumentException(crate::error::IllegalArgumentException),
    /// <p>The specified resource does not exist.</p>
    NoSuchResourceException(crate::error::NoSuchResourceException),
    /// <p>Something went wrong.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>Due to throttling, the request was denied. Slow down the rate of request calls, or request an increase for this quota.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UntagResourceError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::IllegalArgumentException(_inner) =>
            _inner.fmt(f)
            ,
            Self::NoSuchResourceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ServiceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TooManyRequestsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UntagResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ServiceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UntagResourceError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    /// Creates the `UntagResourceError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `UntagResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::IllegalArgumentException(e) => e.meta(),
            Self::NoSuchResourceException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::TooManyRequestsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UntagResourceError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::IllegalArgumentException`.
    pub fn is_illegal_argument_exception(&self) -> bool {
        matches!(self, Self::IllegalArgumentException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::NoSuchResourceException`.
    pub fn is_no_such_resource_exception(&self) -> bool {
        matches!(self, Self::NoSuchResourceException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(self, Self::TooManyRequestsException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            Some(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            Some(_inner)
            ,
            Self::ServiceException(_inner) =>
            Some(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>Due to throttling, the request was denied. Slow down the rate of request calls, or request an increase for this quota.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyRequestsException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyRequestsException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for TooManyRequestsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyRequestsException")?;
        if let Some(inner_1) = &self.message {
             {
                write!(f, ": {}", inner_1)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyRequestsException {}
impl aws_http::request_id::RequestId for crate::error::TooManyRequestsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyRequestsException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}
impl TooManyRequestsException {
    /// Creates a new builder-style object to manufacture [`TooManyRequestsException`](crate::error::TooManyRequestsException).
    pub fn builder() -> crate::error::too_many_requests_exception::Builder {
        crate::error::too_many_requests_exception::Builder::default()
    }
}

/// See [`TooManyRequestsException`](crate::error::TooManyRequestsException).
pub mod too_many_requests_exception {
    
    /// A builder for [`TooManyRequestsException`](crate::error::TooManyRequestsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                                pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                    self.meta = Some(meta);
                                                    self
                                                }
        
                                                /// Sets error metadata
                                                pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                    self.meta = meta;
                                                    self
                                                }
        /// Consumes the builder and constructs a [`TooManyRequestsException`](crate::error::TooManyRequestsException).
        pub fn build(self) -> crate::error::TooManyRequestsException {
            crate::error::TooManyRequestsException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}

/// <p>Something went wrong.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ServiceException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ServiceException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceException")?;
        if let Some(inner_2) = &self.message {
             {
                write!(f, ": {}", inner_2)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ServiceException {}
impl aws_http::request_id::RequestId for crate::error::ServiceException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ServiceException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}
impl ServiceException {
    /// Creates a new builder-style object to manufacture [`ServiceException`](crate::error::ServiceException).
    pub fn builder() -> crate::error::service_exception::Builder {
        crate::error::service_exception::Builder::default()
    }
}

/// See [`ServiceException`](crate::error::ServiceException).
pub mod service_exception {
    
    /// A builder for [`ServiceException`](crate::error::ServiceException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                                pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                    self.meta = Some(meta);
                                                    self
                                                }
        
                                                /// Sets error metadata
                                                pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                    self.meta = meta;
                                                    self
                                                }
        /// Consumes the builder and constructs a [`ServiceException`](crate::error::ServiceException).
        pub fn build(self) -> crate::error::ServiceException {
            crate::error::ServiceException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}

/// <p>The specified resource does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NoSuchResourceException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NoSuchResourceException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for NoSuchResourceException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoSuchResourceException")?;
        if let Some(inner_3) = &self.message {
             {
                write!(f, ": {}", inner_3)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NoSuchResourceException {}
impl aws_http::request_id::RequestId for crate::error::NoSuchResourceException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NoSuchResourceException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}
impl NoSuchResourceException {
    /// Creates a new builder-style object to manufacture [`NoSuchResourceException`](crate::error::NoSuchResourceException).
    pub fn builder() -> crate::error::no_such_resource_exception::Builder {
        crate::error::no_such_resource_exception::Builder::default()
    }
}

/// See [`NoSuchResourceException`](crate::error::NoSuchResourceException).
pub mod no_such_resource_exception {
    
    /// A builder for [`NoSuchResourceException`](crate::error::NoSuchResourceException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                                pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                    self.meta = Some(meta);
                                                    self
                                                }
        
                                                /// Sets error metadata
                                                pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                    self.meta = meta;
                                                    self
                                                }
        /// Consumes the builder and constructs a [`NoSuchResourceException`](crate::error::NoSuchResourceException).
        pub fn build(self) -> crate::error::NoSuchResourceException {
            crate::error::NoSuchResourceException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}

/// <p>Invalid input was provided.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IllegalArgumentException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl IllegalArgumentException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for IllegalArgumentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IllegalArgumentException")?;
        if let Some(inner_4) = &self.message {
             {
                write!(f, ": {}", inner_4)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for IllegalArgumentException {}
impl aws_http::request_id::RequestId for crate::error::IllegalArgumentException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for IllegalArgumentException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}
impl IllegalArgumentException {
    /// Creates a new builder-style object to manufacture [`IllegalArgumentException`](crate::error::IllegalArgumentException).
    pub fn builder() -> crate::error::illegal_argument_exception::Builder {
        crate::error::illegal_argument_exception::Builder::default()
    }
}

/// See [`IllegalArgumentException`](crate::error::IllegalArgumentException).
pub mod illegal_argument_exception {
    
    /// A builder for [`IllegalArgumentException`](crate::error::IllegalArgumentException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                                pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                    self.meta = Some(meta);
                                                    self
                                                }
        
                                                /// Sets error metadata
                                                pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                    self.meta = meta;
                                                    self
                                                }
        /// Consumes the builder and constructs a [`IllegalArgumentException`](crate::error::IllegalArgumentException).
        pub fn build(self) -> crate::error::IllegalArgumentException {
            crate::error::IllegalArgumentException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}

/// <p>You do not have sufficient permission to perform this action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccessDeniedException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl AccessDeniedException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_5) = &self.message {
             {
                write!(f, ": {}", inner_5)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
impl aws_http::request_id::RequestId for crate::error::AccessDeniedException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AccessDeniedException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException).
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}

/// See [`AccessDeniedException`](crate::error::AccessDeniedException).
pub mod access_denied_exception {
    
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                                pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                    self.meta = Some(meta);
                                                    self
                                                }
        
                                                /// Sets error metadata
                                                pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                    self.meta = meta;
                                                    self
                                                }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException).
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type TagResourceErrorKind = TagResourceError;
/// Error type for the `TagResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceError {
    /// <p>You do not have sufficient permission to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Invalid input was provided.</p>
    IllegalArgumentException(crate::error::IllegalArgumentException),
    /// <p>The specified resource does not exist.</p>
    NoSuchResourceException(crate::error::NoSuchResourceException),
    /// <p>Something went wrong.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The specified tag is a reserved word and cannot be used.</p>
    TagPolicyViolationException(crate::error::TagPolicyViolationException),
    /// <p>Due to throttling, the request was denied. Slow down the rate of request calls, or request an increase for this quota.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// <p>You've exceeded the number of tags allowed for a resource. For more information, see <a href="https://docs.aws.amazon.com/servicequotas/latest/userguide/sq-tagging.html#sq-tagging-restrictions">Tag restrictions</a> in the <i>Service Quotas User Guide</i>.</p>
    TooManyTagsException(crate::error::TooManyTagsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for TagResourceError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::IllegalArgumentException(_inner) =>
            _inner.fmt(f)
            ,
            Self::NoSuchResourceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ServiceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TagPolicyViolationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TooManyRequestsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TooManyTagsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TagResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ServiceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TagPolicyViolationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TooManyTagsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::TagResourceError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    /// Creates the `TagResourceError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `TagResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::IllegalArgumentException(e) => e.meta(),
            Self::NoSuchResourceException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::TagPolicyViolationException(e) => e.meta(),
            Self::TooManyRequestsException(e) => e.meta(),
            Self::TooManyTagsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `TagResourceError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::IllegalArgumentException`.
    pub fn is_illegal_argument_exception(&self) -> bool {
        matches!(self, Self::IllegalArgumentException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::NoSuchResourceException`.
    pub fn is_no_such_resource_exception(&self) -> bool {
        matches!(self, Self::NoSuchResourceException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::TagPolicyViolationException`.
    pub fn is_tag_policy_violation_exception(&self) -> bool {
        matches!(self, Self::TagPolicyViolationException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(self, Self::TooManyRequestsException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::TooManyTagsException`.
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(self, Self::TooManyTagsException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            Some(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            Some(_inner)
            ,
            Self::ServiceException(_inner) =>
            Some(_inner)
            ,
            Self::TagPolicyViolationException(_inner) =>
            Some(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            Some(_inner)
            ,
            Self::TooManyTagsException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>You've exceeded the number of tags allowed for a resource. For more information, see <a href="https://docs.aws.amazon.com/servicequotas/latest/userguide/sq-tagging.html#sq-tagging-restrictions">Tag restrictions</a> in the <i>Service Quotas User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyTagsException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyTagsException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for TooManyTagsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyTagsException")?;
        if let Some(inner_6) = &self.message {
             {
                write!(f, ": {}", inner_6)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyTagsException {}
impl aws_http::request_id::RequestId for crate::error::TooManyTagsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyTagsException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}
impl TooManyTagsException {
    /// Creates a new builder-style object to manufacture [`TooManyTagsException`](crate::error::TooManyTagsException).
    pub fn builder() -> crate::error::too_many_tags_exception::Builder {
        crate::error::too_many_tags_exception::Builder::default()
    }
}

/// See [`TooManyTagsException`](crate::error::TooManyTagsException).
pub mod too_many_tags_exception {
    
    /// A builder for [`TooManyTagsException`](crate::error::TooManyTagsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                                pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                    self.meta = Some(meta);
                                                    self
                                                }
        
                                                /// Sets error metadata
                                                pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                    self.meta = meta;
                                                    self
                                                }
        /// Consumes the builder and constructs a [`TooManyTagsException`](crate::error::TooManyTagsException).
        pub fn build(self) -> crate::error::TooManyTagsException {
            crate::error::TooManyTagsException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}

/// <p>The specified tag is a reserved word and cannot be used.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagPolicyViolationException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TagPolicyViolationException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for TagPolicyViolationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagPolicyViolationException")?;
        if let Some(inner_7) = &self.message {
             {
                write!(f, ": {}", inner_7)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TagPolicyViolationException {}
impl aws_http::request_id::RequestId for crate::error::TagPolicyViolationException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TagPolicyViolationException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}
impl TagPolicyViolationException {
    /// Creates a new builder-style object to manufacture [`TagPolicyViolationException`](crate::error::TagPolicyViolationException).
    pub fn builder() -> crate::error::tag_policy_violation_exception::Builder {
        crate::error::tag_policy_violation_exception::Builder::default()
    }
}

/// See [`TagPolicyViolationException`](crate::error::TagPolicyViolationException).
pub mod tag_policy_violation_exception {
    
    /// A builder for [`TagPolicyViolationException`](crate::error::TagPolicyViolationException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                                pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                    self.meta = Some(meta);
                                                    self
                                                }
        
                                                /// Sets error metadata
                                                pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                    self.meta = meta;
                                                    self
                                                }
        /// Consumes the builder and constructs a [`TagPolicyViolationException`](crate::error::TagPolicyViolationException).
        pub fn build(self) -> crate::error::TagPolicyViolationException {
            crate::error::TagPolicyViolationException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type RequestServiceQuotaIncreaseErrorKind = RequestServiceQuotaIncreaseError;
/// Error type for the `RequestServiceQuotaIncreaseError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RequestServiceQuotaIncreaseError {
    /// <p>You do not have sufficient permission to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>You can't perform this action because a dependency does not have access.</p>
    DependencyAccessDeniedException(crate::error::DependencyAccessDeniedException),
    /// <p>Invalid input was provided.</p>
    IllegalArgumentException(crate::error::IllegalArgumentException),
    /// <p>The resource is in an invalid state.</p>
    InvalidResourceStateException(crate::error::InvalidResourceStateException),
    /// <p>The specified resource does not exist.</p>
    NoSuchResourceException(crate::error::NoSuchResourceException),
    /// <p>You have exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use Service Quotas to request a service quota increase.</p>
    QuotaExceededException(crate::error::QuotaExceededException),
    /// <p>The specified resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>Something went wrong.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>Due to throttling, the request was denied. Slow down the rate of request calls, or request an increase for this quota.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RequestServiceQuotaIncreaseError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for RequestServiceQuotaIncreaseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::DependencyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::IllegalArgumentException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InvalidResourceStateException(_inner) =>
            _inner.fmt(f)
            ,
            Self::NoSuchResourceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::QuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceAlreadyExistsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ServiceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TooManyRequestsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RequestServiceQuotaIncreaseError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::DependencyAccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InvalidResourceStateException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::QuotaExceededException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceAlreadyExistsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ServiceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RequestServiceQuotaIncreaseError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for RequestServiceQuotaIncreaseError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RequestServiceQuotaIncreaseError {
    /// Creates the `RequestServiceQuotaIncreaseError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `RequestServiceQuotaIncreaseError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::DependencyAccessDeniedException(e) => e.meta(),
            Self::IllegalArgumentException(e) => e.meta(),
            Self::InvalidResourceStateException(e) => e.meta(),
            Self::NoSuchResourceException(e) => e.meta(),
            Self::QuotaExceededException(e) => e.meta(),
            Self::ResourceAlreadyExistsException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::TooManyRequestsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RequestServiceQuotaIncreaseError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `RequestServiceQuotaIncreaseError::DependencyAccessDeniedException`.
    pub fn is_dependency_access_denied_exception(&self) -> bool {
        matches!(self, Self::DependencyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `RequestServiceQuotaIncreaseError::IllegalArgumentException`.
    pub fn is_illegal_argument_exception(&self) -> bool {
        matches!(self, Self::IllegalArgumentException(_))
    }
    /// Returns `true` if the error kind is `RequestServiceQuotaIncreaseError::InvalidResourceStateException`.
    pub fn is_invalid_resource_state_exception(&self) -> bool {
        matches!(self, Self::InvalidResourceStateException(_))
    }
    /// Returns `true` if the error kind is `RequestServiceQuotaIncreaseError::NoSuchResourceException`.
    pub fn is_no_such_resource_exception(&self) -> bool {
        matches!(self, Self::NoSuchResourceException(_))
    }
    /// Returns `true` if the error kind is `RequestServiceQuotaIncreaseError::QuotaExceededException`.
    pub fn is_quota_exceeded_exception(&self) -> bool {
        matches!(self, Self::QuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `RequestServiceQuotaIncreaseError::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(self, Self::ResourceAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `RequestServiceQuotaIncreaseError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `RequestServiceQuotaIncreaseError::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(self, Self::TooManyRequestsException(_))
    }
}
impl std::error::Error for RequestServiceQuotaIncreaseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::DependencyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            Some(_inner)
            ,
            Self::InvalidResourceStateException(_inner) =>
            Some(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            Some(_inner)
            ,
            Self::QuotaExceededException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceAlreadyExistsException(_inner) =>
            Some(_inner)
            ,
            Self::ServiceException(_inner) =>
            Some(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>The specified resource already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceAlreadyExistsException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ResourceAlreadyExistsException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ResourceAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceAlreadyExistsException")?;
        if let Some(inner_8) = &self.message {
             {
                write!(f, ": {}", inner_8)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ResourceAlreadyExistsException {}
impl aws_http::request_id::RequestId for crate::error::ResourceAlreadyExistsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ResourceAlreadyExistsException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}
impl ResourceAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException).
    pub fn builder() -> crate::error::resource_already_exists_exception::Builder {
        crate::error::resource_already_exists_exception::Builder::default()
    }
}

/// See [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException).
pub mod resource_already_exists_exception {
    
    /// A builder for [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                                pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                    self.meta = Some(meta);
                                                    self
                                                }
        
                                                /// Sets error metadata
                                                pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                    self.meta = meta;
                                                    self
                                                }
        /// Consumes the builder and constructs a [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException).
        pub fn build(self) -> crate::error::ResourceAlreadyExistsException {
            crate::error::ResourceAlreadyExistsException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}

/// <p>You have exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use Service Quotas to request a service quota increase.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QuotaExceededException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl QuotaExceededException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for QuotaExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "QuotaExceededException")?;
        if let Some(inner_9) = &self.message {
             {
                write!(f, ": {}", inner_9)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for QuotaExceededException {}
impl aws_http::request_id::RequestId for crate::error::QuotaExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for QuotaExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}
impl QuotaExceededException {
    /// Creates a new builder-style object to manufacture [`QuotaExceededException`](crate::error::QuotaExceededException).
    pub fn builder() -> crate::error::quota_exceeded_exception::Builder {
        crate::error::quota_exceeded_exception::Builder::default()
    }
}

/// See [`QuotaExceededException`](crate::error::QuotaExceededException).
pub mod quota_exceeded_exception {
    
    /// A builder for [`QuotaExceededException`](crate::error::QuotaExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                                pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                    self.meta = Some(meta);
                                                    self
                                                }
        
                                                /// Sets error metadata
                                                pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                    self.meta = meta;
                                                    self
                                                }
        /// Consumes the builder and constructs a [`QuotaExceededException`](crate::error::QuotaExceededException).
        pub fn build(self) -> crate::error::QuotaExceededException {
            crate::error::QuotaExceededException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}

/// <p>The resource is in an invalid state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidResourceStateException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidResourceStateException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for InvalidResourceStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidResourceStateException")?;
        if let Some(inner_10) = &self.message {
             {
                write!(f, ": {}", inner_10)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidResourceStateException {}
impl aws_http::request_id::RequestId for crate::error::InvalidResourceStateException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidResourceStateException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}
impl InvalidResourceStateException {
    /// Creates a new builder-style object to manufacture [`InvalidResourceStateException`](crate::error::InvalidResourceStateException).
    pub fn builder() -> crate::error::invalid_resource_state_exception::Builder {
        crate::error::invalid_resource_state_exception::Builder::default()
    }
}

/// See [`InvalidResourceStateException`](crate::error::InvalidResourceStateException).
pub mod invalid_resource_state_exception {
    
    /// A builder for [`InvalidResourceStateException`](crate::error::InvalidResourceStateException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                                pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                    self.meta = Some(meta);
                                                    self
                                                }
        
                                                /// Sets error metadata
                                                pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                    self.meta = meta;
                                                    self
                                                }
        /// Consumes the builder and constructs a [`InvalidResourceStateException`](crate::error::InvalidResourceStateException).
        pub fn build(self) -> crate::error::InvalidResourceStateException {
            crate::error::InvalidResourceStateException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}

/// <p>You can't perform this action because a dependency does not have access.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DependencyAccessDeniedException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DependencyAccessDeniedException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for DependencyAccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DependencyAccessDeniedException")?;
        if let Some(inner_11) = &self.message {
             {
                write!(f, ": {}", inner_11)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DependencyAccessDeniedException {}
impl aws_http::request_id::RequestId for crate::error::DependencyAccessDeniedException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DependencyAccessDeniedException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}
impl DependencyAccessDeniedException {
    /// Creates a new builder-style object to manufacture [`DependencyAccessDeniedException`](crate::error::DependencyAccessDeniedException).
    pub fn builder() -> crate::error::dependency_access_denied_exception::Builder {
        crate::error::dependency_access_denied_exception::Builder::default()
    }
}

/// See [`DependencyAccessDeniedException`](crate::error::DependencyAccessDeniedException).
pub mod dependency_access_denied_exception {
    
    /// A builder for [`DependencyAccessDeniedException`](crate::error::DependencyAccessDeniedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                                pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                    self.meta = Some(meta);
                                                    self
                                                }
        
                                                /// Sets error metadata
                                                pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                    self.meta = meta;
                                                    self
                                                }
        /// Consumes the builder and constructs a [`DependencyAccessDeniedException`](crate::error::DependencyAccessDeniedException).
        pub fn build(self) -> crate::error::DependencyAccessDeniedException {
            crate::error::DependencyAccessDeniedException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type PutServiceQuotaIncreaseRequestIntoTemplateErrorKind = PutServiceQuotaIncreaseRequestIntoTemplateError;
/// Error type for the `PutServiceQuotaIncreaseRequestIntoTemplateError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutServiceQuotaIncreaseRequestIntoTemplateError {
    /// <p>You do not have sufficient permission to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The action you attempted is not allowed unless Service Access with Service Quotas is enabled in your organization.</p>
    AwsServiceAccessNotEnabledException(crate::error::AwsServiceAccessNotEnabledException),
    /// <p>You can't perform this action because a dependency does not have access.</p>
    DependencyAccessDeniedException(crate::error::DependencyAccessDeniedException),
    /// <p>Invalid input was provided.</p>
    IllegalArgumentException(crate::error::IllegalArgumentException),
    /// <p>The account making this call is not a member of an organization.</p>
    NoAvailableOrganizationException(crate::error::NoAvailableOrganizationException),
    /// <p>The specified resource does not exist.</p>
    NoSuchResourceException(crate::error::NoSuchResourceException),
    /// <p>You have exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use Service Quotas to request a service quota increase.</p>
    QuotaExceededException(crate::error::QuotaExceededException),
    /// <p>Something went wrong.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The Service Quotas template is not available in this AWS Region.</p>
    TemplatesNotAvailableInRegionException(crate::error::TemplatesNotAvailableInRegionException),
    /// <p>Due to throttling, the request was denied. Slow down the rate of request calls, or request an increase for this quota.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for PutServiceQuotaIncreaseRequestIntoTemplateError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for PutServiceQuotaIncreaseRequestIntoTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::AwsServiceAccessNotEnabledException(_inner) =>
            _inner.fmt(f)
            ,
            Self::DependencyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::IllegalArgumentException(_inner) =>
            _inner.fmt(f)
            ,
            Self::NoAvailableOrganizationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::NoSuchResourceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::QuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ServiceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TemplatesNotAvailableInRegionException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TooManyRequestsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PutServiceQuotaIncreaseRequestIntoTemplateError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::AwsServiceAccessNotEnabledException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::DependencyAccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::NoAvailableOrganizationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::QuotaExceededException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ServiceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TemplatesNotAvailableInRegionException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::PutServiceQuotaIncreaseRequestIntoTemplateError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for PutServiceQuotaIncreaseRequestIntoTemplateError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutServiceQuotaIncreaseRequestIntoTemplateError {
    /// Creates the `PutServiceQuotaIncreaseRequestIntoTemplateError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `PutServiceQuotaIncreaseRequestIntoTemplateError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::AwsServiceAccessNotEnabledException(e) => e.meta(),
            Self::DependencyAccessDeniedException(e) => e.meta(),
            Self::IllegalArgumentException(e) => e.meta(),
            Self::NoAvailableOrganizationException(e) => e.meta(),
            Self::NoSuchResourceException(e) => e.meta(),
            Self::QuotaExceededException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::TemplatesNotAvailableInRegionException(e) => e.meta(),
            Self::TooManyRequestsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `PutServiceQuotaIncreaseRequestIntoTemplateError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `PutServiceQuotaIncreaseRequestIntoTemplateError::AwsServiceAccessNotEnabledException`.
    pub fn is_aws_service_access_not_enabled_exception(&self) -> bool {
        matches!(self, Self::AwsServiceAccessNotEnabledException(_))
    }
    /// Returns `true` if the error kind is `PutServiceQuotaIncreaseRequestIntoTemplateError::DependencyAccessDeniedException`.
    pub fn is_dependency_access_denied_exception(&self) -> bool {
        matches!(self, Self::DependencyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `PutServiceQuotaIncreaseRequestIntoTemplateError::IllegalArgumentException`.
    pub fn is_illegal_argument_exception(&self) -> bool {
        matches!(self, Self::IllegalArgumentException(_))
    }
    /// Returns `true` if the error kind is `PutServiceQuotaIncreaseRequestIntoTemplateError::NoAvailableOrganizationException`.
    pub fn is_no_available_organization_exception(&self) -> bool {
        matches!(self, Self::NoAvailableOrganizationException(_))
    }
    /// Returns `true` if the error kind is `PutServiceQuotaIncreaseRequestIntoTemplateError::NoSuchResourceException`.
    pub fn is_no_such_resource_exception(&self) -> bool {
        matches!(self, Self::NoSuchResourceException(_))
    }
    /// Returns `true` if the error kind is `PutServiceQuotaIncreaseRequestIntoTemplateError::QuotaExceededException`.
    pub fn is_quota_exceeded_exception(&self) -> bool {
        matches!(self, Self::QuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `PutServiceQuotaIncreaseRequestIntoTemplateError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `PutServiceQuotaIncreaseRequestIntoTemplateError::TemplatesNotAvailableInRegionException`.
    pub fn is_templates_not_available_in_region_exception(&self) -> bool {
        matches!(self, Self::TemplatesNotAvailableInRegionException(_))
    }
    /// Returns `true` if the error kind is `PutServiceQuotaIncreaseRequestIntoTemplateError::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(self, Self::TooManyRequestsException(_))
    }
}
impl std::error::Error for PutServiceQuotaIncreaseRequestIntoTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::AwsServiceAccessNotEnabledException(_inner) =>
            Some(_inner)
            ,
            Self::DependencyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            Some(_inner)
            ,
            Self::NoAvailableOrganizationException(_inner) =>
            Some(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            Some(_inner)
            ,
            Self::QuotaExceededException(_inner) =>
            Some(_inner)
            ,
            Self::ServiceException(_inner) =>
            Some(_inner)
            ,
            Self::TemplatesNotAvailableInRegionException(_inner) =>
            Some(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>The Service Quotas template is not available in this AWS Region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TemplatesNotAvailableInRegionException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TemplatesNotAvailableInRegionException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for TemplatesNotAvailableInRegionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TemplatesNotAvailableInRegionException")?;
        if let Some(inner_12) = &self.message {
             {
                write!(f, ": {}", inner_12)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TemplatesNotAvailableInRegionException {}
impl aws_http::request_id::RequestId for crate::error::TemplatesNotAvailableInRegionException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TemplatesNotAvailableInRegionException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}
impl TemplatesNotAvailableInRegionException {
    /// Creates a new builder-style object to manufacture [`TemplatesNotAvailableInRegionException`](crate::error::TemplatesNotAvailableInRegionException).
    pub fn builder() -> crate::error::templates_not_available_in_region_exception::Builder {
        crate::error::templates_not_available_in_region_exception::Builder::default()
    }
}

/// See [`TemplatesNotAvailableInRegionException`](crate::error::TemplatesNotAvailableInRegionException).
pub mod templates_not_available_in_region_exception {
    
    /// A builder for [`TemplatesNotAvailableInRegionException`](crate::error::TemplatesNotAvailableInRegionException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                                pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                    self.meta = Some(meta);
                                                    self
                                                }
        
                                                /// Sets error metadata
                                                pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                    self.meta = meta;
                                                    self
                                                }
        /// Consumes the builder and constructs a [`TemplatesNotAvailableInRegionException`](crate::error::TemplatesNotAvailableInRegionException).
        pub fn build(self) -> crate::error::TemplatesNotAvailableInRegionException {
            crate::error::TemplatesNotAvailableInRegionException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}

/// <p>The account making this call is not a member of an organization.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NoAvailableOrganizationException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NoAvailableOrganizationException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for NoAvailableOrganizationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoAvailableOrganizationException")?;
        if let Some(inner_13) = &self.message {
             {
                write!(f, ": {}", inner_13)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NoAvailableOrganizationException {}
impl aws_http::request_id::RequestId for crate::error::NoAvailableOrganizationException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NoAvailableOrganizationException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}
impl NoAvailableOrganizationException {
    /// Creates a new builder-style object to manufacture [`NoAvailableOrganizationException`](crate::error::NoAvailableOrganizationException).
    pub fn builder() -> crate::error::no_available_organization_exception::Builder {
        crate::error::no_available_organization_exception::Builder::default()
    }
}

/// See [`NoAvailableOrganizationException`](crate::error::NoAvailableOrganizationException).
pub mod no_available_organization_exception {
    
    /// A builder for [`NoAvailableOrganizationException`](crate::error::NoAvailableOrganizationException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                                pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                    self.meta = Some(meta);
                                                    self
                                                }
        
                                                /// Sets error metadata
                                                pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                    self.meta = meta;
                                                    self
                                                }
        /// Consumes the builder and constructs a [`NoAvailableOrganizationException`](crate::error::NoAvailableOrganizationException).
        pub fn build(self) -> crate::error::NoAvailableOrganizationException {
            crate::error::NoAvailableOrganizationException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}

/// <p>The action you attempted is not allowed unless Service Access with Service Quotas is enabled in your organization.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AwsServiceAccessNotEnabledException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl AwsServiceAccessNotEnabledException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for AwsServiceAccessNotEnabledException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AwsServiceAccessNotEnabledException [AWSServiceAccessNotEnabledException]")?;
        if let Some(inner_14) = &self.message {
             {
                write!(f, ": {}", inner_14)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AwsServiceAccessNotEnabledException {}
impl aws_http::request_id::RequestId for crate::error::AwsServiceAccessNotEnabledException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AwsServiceAccessNotEnabledException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}
impl AwsServiceAccessNotEnabledException {
    /// Creates a new builder-style object to manufacture [`AwsServiceAccessNotEnabledException`](crate::error::AwsServiceAccessNotEnabledException).
    pub fn builder() -> crate::error::aws_service_access_not_enabled_exception::Builder {
        crate::error::aws_service_access_not_enabled_exception::Builder::default()
    }
}

/// See [`AwsServiceAccessNotEnabledException`](crate::error::AwsServiceAccessNotEnabledException).
pub mod aws_service_access_not_enabled_exception {
    
    /// A builder for [`AwsServiceAccessNotEnabledException`](crate::error::AwsServiceAccessNotEnabledException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                                pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                    self.meta = Some(meta);
                                                    self
                                                }
        
                                                /// Sets error metadata
                                                pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                    self.meta = meta;
                                                    self
                                                }
        /// Consumes the builder and constructs a [`AwsServiceAccessNotEnabledException`](crate::error::AwsServiceAccessNotEnabledException).
        pub fn build(self) -> crate::error::AwsServiceAccessNotEnabledException {
            crate::error::AwsServiceAccessNotEnabledException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type ListTagsForResourceErrorKind = ListTagsForResourceError;
/// Error type for the `ListTagsForResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceError {
    /// <p>You do not have sufficient permission to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Invalid input was provided.</p>
    IllegalArgumentException(crate::error::IllegalArgumentException),
    /// <p>The specified resource does not exist.</p>
    NoSuchResourceException(crate::error::NoSuchResourceException),
    /// <p>Something went wrong.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>Due to throttling, the request was denied. Slow down the rate of request calls, or request an increase for this quota.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListTagsForResourceError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::IllegalArgumentException(_inner) =>
            _inner.fmt(f)
            ,
            Self::NoSuchResourceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ServiceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TooManyRequestsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListTagsForResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ServiceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListTagsForResourceError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    /// Creates the `ListTagsForResourceError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `ListTagsForResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::IllegalArgumentException(e) => e.meta(),
            Self::NoSuchResourceException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::TooManyRequestsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::IllegalArgumentException`.
    pub fn is_illegal_argument_exception(&self) -> bool {
        matches!(self, Self::IllegalArgumentException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::NoSuchResourceException`.
    pub fn is_no_such_resource_exception(&self) -> bool {
        matches!(self, Self::NoSuchResourceException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(self, Self::TooManyRequestsException(_))
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            Some(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            Some(_inner)
            ,
            Self::ServiceException(_inner) =>
            Some(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type ListServicesErrorKind = ListServicesError;
/// Error type for the `ListServicesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListServicesError {
    /// <p>You do not have sufficient permission to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Invalid input was provided.</p>
    IllegalArgumentException(crate::error::IllegalArgumentException),
    /// <p>Invalid input was provided.</p>
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    /// <p>Something went wrong.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>Due to throttling, the request was denied. Slow down the rate of request calls, or request an increase for this quota.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListServicesError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for ListServicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::IllegalArgumentException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InvalidPaginationTokenException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ServiceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TooManyRequestsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListServicesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InvalidPaginationTokenException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ServiceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListServicesError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for ListServicesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListServicesError {
    /// Creates the `ListServicesError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `ListServicesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::IllegalArgumentException(e) => e.meta(),
            Self::InvalidPaginationTokenException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::TooManyRequestsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListServicesError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListServicesError::IllegalArgumentException`.
    pub fn is_illegal_argument_exception(&self) -> bool {
        matches!(self, Self::IllegalArgumentException(_))
    }
    /// Returns `true` if the error kind is `ListServicesError::InvalidPaginationTokenException`.
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(self, Self::InvalidPaginationTokenException(_))
    }
    /// Returns `true` if the error kind is `ListServicesError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `ListServicesError::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(self, Self::TooManyRequestsException(_))
    }
}
impl std::error::Error for ListServicesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            Some(_inner)
            ,
            Self::InvalidPaginationTokenException(_inner) =>
            Some(_inner)
            ,
            Self::ServiceException(_inner) =>
            Some(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>Invalid input was provided.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidPaginationTokenException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidPaginationTokenException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for InvalidPaginationTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPaginationTokenException")?;
        if let Some(inner_15) = &self.message {
             {
                write!(f, ": {}", inner_15)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPaginationTokenException {}
impl aws_http::request_id::RequestId for crate::error::InvalidPaginationTokenException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidPaginationTokenException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}
impl InvalidPaginationTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidPaginationTokenException`](crate::error::InvalidPaginationTokenException).
    pub fn builder() -> crate::error::invalid_pagination_token_exception::Builder {
        crate::error::invalid_pagination_token_exception::Builder::default()
    }
}

/// See [`InvalidPaginationTokenException`](crate::error::InvalidPaginationTokenException).
pub mod invalid_pagination_token_exception {
    
    /// A builder for [`InvalidPaginationTokenException`](crate::error::InvalidPaginationTokenException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                                pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                    self.meta = Some(meta);
                                                    self
                                                }
        
                                                /// Sets error metadata
                                                pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                    self.meta = meta;
                                                    self
                                                }
        /// Consumes the builder and constructs a [`InvalidPaginationTokenException`](crate::error::InvalidPaginationTokenException).
        pub fn build(self) -> crate::error::InvalidPaginationTokenException {
            crate::error::InvalidPaginationTokenException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type ListServiceQuotasErrorKind = ListServiceQuotasError;
/// Error type for the `ListServiceQuotasError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListServiceQuotasError {
    /// <p>You do not have sufficient permission to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Invalid input was provided.</p>
    IllegalArgumentException(crate::error::IllegalArgumentException),
    /// <p>Invalid input was provided.</p>
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    /// <p>The specified resource does not exist.</p>
    NoSuchResourceException(crate::error::NoSuchResourceException),
    /// <p>Something went wrong.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>Due to throttling, the request was denied. Slow down the rate of request calls, or request an increase for this quota.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListServiceQuotasError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for ListServiceQuotasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::IllegalArgumentException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InvalidPaginationTokenException(_inner) =>
            _inner.fmt(f)
            ,
            Self::NoSuchResourceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ServiceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TooManyRequestsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListServiceQuotasError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InvalidPaginationTokenException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ServiceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListServiceQuotasError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for ListServiceQuotasError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListServiceQuotasError {
    /// Creates the `ListServiceQuotasError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `ListServiceQuotasError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::IllegalArgumentException(e) => e.meta(),
            Self::InvalidPaginationTokenException(e) => e.meta(),
            Self::NoSuchResourceException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::TooManyRequestsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListServiceQuotasError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListServiceQuotasError::IllegalArgumentException`.
    pub fn is_illegal_argument_exception(&self) -> bool {
        matches!(self, Self::IllegalArgumentException(_))
    }
    /// Returns `true` if the error kind is `ListServiceQuotasError::InvalidPaginationTokenException`.
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(self, Self::InvalidPaginationTokenException(_))
    }
    /// Returns `true` if the error kind is `ListServiceQuotasError::NoSuchResourceException`.
    pub fn is_no_such_resource_exception(&self) -> bool {
        matches!(self, Self::NoSuchResourceException(_))
    }
    /// Returns `true` if the error kind is `ListServiceQuotasError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `ListServiceQuotasError::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(self, Self::TooManyRequestsException(_))
    }
}
impl std::error::Error for ListServiceQuotasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            Some(_inner)
            ,
            Self::InvalidPaginationTokenException(_inner) =>
            Some(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            Some(_inner)
            ,
            Self::ServiceException(_inner) =>
            Some(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type ListServiceQuotaIncreaseRequestsInTemplateErrorKind = ListServiceQuotaIncreaseRequestsInTemplateError;
/// Error type for the `ListServiceQuotaIncreaseRequestsInTemplateError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListServiceQuotaIncreaseRequestsInTemplateError {
    /// <p>You do not have sufficient permission to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The action you attempted is not allowed unless Service Access with Service Quotas is enabled in your organization.</p>
    AwsServiceAccessNotEnabledException(crate::error::AwsServiceAccessNotEnabledException),
    /// <p>You can't perform this action because a dependency does not have access.</p>
    DependencyAccessDeniedException(crate::error::DependencyAccessDeniedException),
    /// <p>Invalid input was provided.</p>
    IllegalArgumentException(crate::error::IllegalArgumentException),
    /// <p>The account making this call is not a member of an organization.</p>
    NoAvailableOrganizationException(crate::error::NoAvailableOrganizationException),
    /// <p>Something went wrong.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The Service Quotas template is not available in this AWS Region.</p>
    TemplatesNotAvailableInRegionException(crate::error::TemplatesNotAvailableInRegionException),
    /// <p>Due to throttling, the request was denied. Slow down the rate of request calls, or request an increase for this quota.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListServiceQuotaIncreaseRequestsInTemplateError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for ListServiceQuotaIncreaseRequestsInTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::AwsServiceAccessNotEnabledException(_inner) =>
            _inner.fmt(f)
            ,
            Self::DependencyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::IllegalArgumentException(_inner) =>
            _inner.fmt(f)
            ,
            Self::NoAvailableOrganizationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ServiceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TemplatesNotAvailableInRegionException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TooManyRequestsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListServiceQuotaIncreaseRequestsInTemplateError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::AwsServiceAccessNotEnabledException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::DependencyAccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::NoAvailableOrganizationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ServiceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TemplatesNotAvailableInRegionException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListServiceQuotaIncreaseRequestsInTemplateError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for ListServiceQuotaIncreaseRequestsInTemplateError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListServiceQuotaIncreaseRequestsInTemplateError {
    /// Creates the `ListServiceQuotaIncreaseRequestsInTemplateError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `ListServiceQuotaIncreaseRequestsInTemplateError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::AwsServiceAccessNotEnabledException(e) => e.meta(),
            Self::DependencyAccessDeniedException(e) => e.meta(),
            Self::IllegalArgumentException(e) => e.meta(),
            Self::NoAvailableOrganizationException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::TemplatesNotAvailableInRegionException(e) => e.meta(),
            Self::TooManyRequestsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListServiceQuotaIncreaseRequestsInTemplateError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListServiceQuotaIncreaseRequestsInTemplateError::AwsServiceAccessNotEnabledException`.
    pub fn is_aws_service_access_not_enabled_exception(&self) -> bool {
        matches!(self, Self::AwsServiceAccessNotEnabledException(_))
    }
    /// Returns `true` if the error kind is `ListServiceQuotaIncreaseRequestsInTemplateError::DependencyAccessDeniedException`.
    pub fn is_dependency_access_denied_exception(&self) -> bool {
        matches!(self, Self::DependencyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListServiceQuotaIncreaseRequestsInTemplateError::IllegalArgumentException`.
    pub fn is_illegal_argument_exception(&self) -> bool {
        matches!(self, Self::IllegalArgumentException(_))
    }
    /// Returns `true` if the error kind is `ListServiceQuotaIncreaseRequestsInTemplateError::NoAvailableOrganizationException`.
    pub fn is_no_available_organization_exception(&self) -> bool {
        matches!(self, Self::NoAvailableOrganizationException(_))
    }
    /// Returns `true` if the error kind is `ListServiceQuotaIncreaseRequestsInTemplateError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `ListServiceQuotaIncreaseRequestsInTemplateError::TemplatesNotAvailableInRegionException`.
    pub fn is_templates_not_available_in_region_exception(&self) -> bool {
        matches!(self, Self::TemplatesNotAvailableInRegionException(_))
    }
    /// Returns `true` if the error kind is `ListServiceQuotaIncreaseRequestsInTemplateError::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(self, Self::TooManyRequestsException(_))
    }
}
impl std::error::Error for ListServiceQuotaIncreaseRequestsInTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::AwsServiceAccessNotEnabledException(_inner) =>
            Some(_inner)
            ,
            Self::DependencyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            Some(_inner)
            ,
            Self::NoAvailableOrganizationException(_inner) =>
            Some(_inner)
            ,
            Self::ServiceException(_inner) =>
            Some(_inner)
            ,
            Self::TemplatesNotAvailableInRegionException(_inner) =>
            Some(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type ListRequestedServiceQuotaChangeHistoryByQuotaErrorKind = ListRequestedServiceQuotaChangeHistoryByQuotaError;
/// Error type for the `ListRequestedServiceQuotaChangeHistoryByQuotaError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRequestedServiceQuotaChangeHistoryByQuotaError {
    /// <p>You do not have sufficient permission to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Invalid input was provided.</p>
    IllegalArgumentException(crate::error::IllegalArgumentException),
    /// <p>Invalid input was provided.</p>
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    /// <p>The specified resource does not exist.</p>
    NoSuchResourceException(crate::error::NoSuchResourceException),
    /// <p>Something went wrong.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>Due to throttling, the request was denied. Slow down the rate of request calls, or request an increase for this quota.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListRequestedServiceQuotaChangeHistoryByQuotaError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for ListRequestedServiceQuotaChangeHistoryByQuotaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::IllegalArgumentException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InvalidPaginationTokenException(_inner) =>
            _inner.fmt(f)
            ,
            Self::NoSuchResourceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ServiceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TooManyRequestsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListRequestedServiceQuotaChangeHistoryByQuotaError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InvalidPaginationTokenException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ServiceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListRequestedServiceQuotaChangeHistoryByQuotaError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for ListRequestedServiceQuotaChangeHistoryByQuotaError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRequestedServiceQuotaChangeHistoryByQuotaError {
    /// Creates the `ListRequestedServiceQuotaChangeHistoryByQuotaError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `ListRequestedServiceQuotaChangeHistoryByQuotaError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::IllegalArgumentException(e) => e.meta(),
            Self::InvalidPaginationTokenException(e) => e.meta(),
            Self::NoSuchResourceException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::TooManyRequestsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListRequestedServiceQuotaChangeHistoryByQuotaError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListRequestedServiceQuotaChangeHistoryByQuotaError::IllegalArgumentException`.
    pub fn is_illegal_argument_exception(&self) -> bool {
        matches!(self, Self::IllegalArgumentException(_))
    }
    /// Returns `true` if the error kind is `ListRequestedServiceQuotaChangeHistoryByQuotaError::InvalidPaginationTokenException`.
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(self, Self::InvalidPaginationTokenException(_))
    }
    /// Returns `true` if the error kind is `ListRequestedServiceQuotaChangeHistoryByQuotaError::NoSuchResourceException`.
    pub fn is_no_such_resource_exception(&self) -> bool {
        matches!(self, Self::NoSuchResourceException(_))
    }
    /// Returns `true` if the error kind is `ListRequestedServiceQuotaChangeHistoryByQuotaError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `ListRequestedServiceQuotaChangeHistoryByQuotaError::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(self, Self::TooManyRequestsException(_))
    }
}
impl std::error::Error for ListRequestedServiceQuotaChangeHistoryByQuotaError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            Some(_inner)
            ,
            Self::InvalidPaginationTokenException(_inner) =>
            Some(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            Some(_inner)
            ,
            Self::ServiceException(_inner) =>
            Some(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type ListRequestedServiceQuotaChangeHistoryErrorKind = ListRequestedServiceQuotaChangeHistoryError;
/// Error type for the `ListRequestedServiceQuotaChangeHistoryError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRequestedServiceQuotaChangeHistoryError {
    /// <p>You do not have sufficient permission to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Invalid input was provided.</p>
    IllegalArgumentException(crate::error::IllegalArgumentException),
    /// <p>Invalid input was provided.</p>
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    /// <p>The specified resource does not exist.</p>
    NoSuchResourceException(crate::error::NoSuchResourceException),
    /// <p>Something went wrong.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>Due to throttling, the request was denied. Slow down the rate of request calls, or request an increase for this quota.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListRequestedServiceQuotaChangeHistoryError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for ListRequestedServiceQuotaChangeHistoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::IllegalArgumentException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InvalidPaginationTokenException(_inner) =>
            _inner.fmt(f)
            ,
            Self::NoSuchResourceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ServiceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TooManyRequestsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListRequestedServiceQuotaChangeHistoryError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InvalidPaginationTokenException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ServiceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListRequestedServiceQuotaChangeHistoryError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for ListRequestedServiceQuotaChangeHistoryError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRequestedServiceQuotaChangeHistoryError {
    /// Creates the `ListRequestedServiceQuotaChangeHistoryError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `ListRequestedServiceQuotaChangeHistoryError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::IllegalArgumentException(e) => e.meta(),
            Self::InvalidPaginationTokenException(e) => e.meta(),
            Self::NoSuchResourceException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::TooManyRequestsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListRequestedServiceQuotaChangeHistoryError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListRequestedServiceQuotaChangeHistoryError::IllegalArgumentException`.
    pub fn is_illegal_argument_exception(&self) -> bool {
        matches!(self, Self::IllegalArgumentException(_))
    }
    /// Returns `true` if the error kind is `ListRequestedServiceQuotaChangeHistoryError::InvalidPaginationTokenException`.
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(self, Self::InvalidPaginationTokenException(_))
    }
    /// Returns `true` if the error kind is `ListRequestedServiceQuotaChangeHistoryError::NoSuchResourceException`.
    pub fn is_no_such_resource_exception(&self) -> bool {
        matches!(self, Self::NoSuchResourceException(_))
    }
    /// Returns `true` if the error kind is `ListRequestedServiceQuotaChangeHistoryError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `ListRequestedServiceQuotaChangeHistoryError::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(self, Self::TooManyRequestsException(_))
    }
}
impl std::error::Error for ListRequestedServiceQuotaChangeHistoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            Some(_inner)
            ,
            Self::InvalidPaginationTokenException(_inner) =>
            Some(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            Some(_inner)
            ,
            Self::ServiceException(_inner) =>
            Some(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type ListAWSDefaultServiceQuotasErrorKind = ListAWSDefaultServiceQuotasError;
/// Error type for the `ListAWSDefaultServiceQuotasError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAWSDefaultServiceQuotasError {
    /// <p>You do not have sufficient permission to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Invalid input was provided.</p>
    IllegalArgumentException(crate::error::IllegalArgumentException),
    /// <p>Invalid input was provided.</p>
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    /// <p>The specified resource does not exist.</p>
    NoSuchResourceException(crate::error::NoSuchResourceException),
    /// <p>Something went wrong.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>Due to throttling, the request was denied. Slow down the rate of request calls, or request an increase for this quota.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListAWSDefaultServiceQuotasError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for ListAWSDefaultServiceQuotasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::IllegalArgumentException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InvalidPaginationTokenException(_inner) =>
            _inner.fmt(f)
            ,
            Self::NoSuchResourceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ServiceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TooManyRequestsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListAWSDefaultServiceQuotasError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InvalidPaginationTokenException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ServiceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListAWSDefaultServiceQuotasError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for ListAWSDefaultServiceQuotasError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAWSDefaultServiceQuotasError {
    /// Creates the `ListAWSDefaultServiceQuotasError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `ListAWSDefaultServiceQuotasError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::IllegalArgumentException(e) => e.meta(),
            Self::InvalidPaginationTokenException(e) => e.meta(),
            Self::NoSuchResourceException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::TooManyRequestsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListAWSDefaultServiceQuotasError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListAWSDefaultServiceQuotasError::IllegalArgumentException`.
    pub fn is_illegal_argument_exception(&self) -> bool {
        matches!(self, Self::IllegalArgumentException(_))
    }
    /// Returns `true` if the error kind is `ListAWSDefaultServiceQuotasError::InvalidPaginationTokenException`.
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(self, Self::InvalidPaginationTokenException(_))
    }
    /// Returns `true` if the error kind is `ListAWSDefaultServiceQuotasError::NoSuchResourceException`.
    pub fn is_no_such_resource_exception(&self) -> bool {
        matches!(self, Self::NoSuchResourceException(_))
    }
    /// Returns `true` if the error kind is `ListAWSDefaultServiceQuotasError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `ListAWSDefaultServiceQuotasError::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(self, Self::TooManyRequestsException(_))
    }
}
impl std::error::Error for ListAWSDefaultServiceQuotasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            Some(_inner)
            ,
            Self::InvalidPaginationTokenException(_inner) =>
            Some(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            Some(_inner)
            ,
            Self::ServiceException(_inner) =>
            Some(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type GetServiceQuotaIncreaseRequestFromTemplateErrorKind = GetServiceQuotaIncreaseRequestFromTemplateError;
/// Error type for the `GetServiceQuotaIncreaseRequestFromTemplateError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetServiceQuotaIncreaseRequestFromTemplateError {
    /// <p>You do not have sufficient permission to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The action you attempted is not allowed unless Service Access with Service Quotas is enabled in your organization.</p>
    AwsServiceAccessNotEnabledException(crate::error::AwsServiceAccessNotEnabledException),
    /// <p>You can't perform this action because a dependency does not have access.</p>
    DependencyAccessDeniedException(crate::error::DependencyAccessDeniedException),
    /// <p>Invalid input was provided.</p>
    IllegalArgumentException(crate::error::IllegalArgumentException),
    /// <p>The account making this call is not a member of an organization.</p>
    NoAvailableOrganizationException(crate::error::NoAvailableOrganizationException),
    /// <p>The specified resource does not exist.</p>
    NoSuchResourceException(crate::error::NoSuchResourceException),
    /// <p>Something went wrong.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The Service Quotas template is not available in this AWS Region.</p>
    TemplatesNotAvailableInRegionException(crate::error::TemplatesNotAvailableInRegionException),
    /// <p>Due to throttling, the request was denied. Slow down the rate of request calls, or request an increase for this quota.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetServiceQuotaIncreaseRequestFromTemplateError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for GetServiceQuotaIncreaseRequestFromTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::AwsServiceAccessNotEnabledException(_inner) =>
            _inner.fmt(f)
            ,
            Self::DependencyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::IllegalArgumentException(_inner) =>
            _inner.fmt(f)
            ,
            Self::NoAvailableOrganizationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::NoSuchResourceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ServiceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TemplatesNotAvailableInRegionException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TooManyRequestsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetServiceQuotaIncreaseRequestFromTemplateError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::AwsServiceAccessNotEnabledException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::DependencyAccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::NoAvailableOrganizationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ServiceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TemplatesNotAvailableInRegionException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetServiceQuotaIncreaseRequestFromTemplateError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for GetServiceQuotaIncreaseRequestFromTemplateError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetServiceQuotaIncreaseRequestFromTemplateError {
    /// Creates the `GetServiceQuotaIncreaseRequestFromTemplateError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `GetServiceQuotaIncreaseRequestFromTemplateError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::AwsServiceAccessNotEnabledException(e) => e.meta(),
            Self::DependencyAccessDeniedException(e) => e.meta(),
            Self::IllegalArgumentException(e) => e.meta(),
            Self::NoAvailableOrganizationException(e) => e.meta(),
            Self::NoSuchResourceException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::TemplatesNotAvailableInRegionException(e) => e.meta(),
            Self::TooManyRequestsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetServiceQuotaIncreaseRequestFromTemplateError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetServiceQuotaIncreaseRequestFromTemplateError::AwsServiceAccessNotEnabledException`.
    pub fn is_aws_service_access_not_enabled_exception(&self) -> bool {
        matches!(self, Self::AwsServiceAccessNotEnabledException(_))
    }
    /// Returns `true` if the error kind is `GetServiceQuotaIncreaseRequestFromTemplateError::DependencyAccessDeniedException`.
    pub fn is_dependency_access_denied_exception(&self) -> bool {
        matches!(self, Self::DependencyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetServiceQuotaIncreaseRequestFromTemplateError::IllegalArgumentException`.
    pub fn is_illegal_argument_exception(&self) -> bool {
        matches!(self, Self::IllegalArgumentException(_))
    }
    /// Returns `true` if the error kind is `GetServiceQuotaIncreaseRequestFromTemplateError::NoAvailableOrganizationException`.
    pub fn is_no_available_organization_exception(&self) -> bool {
        matches!(self, Self::NoAvailableOrganizationException(_))
    }
    /// Returns `true` if the error kind is `GetServiceQuotaIncreaseRequestFromTemplateError::NoSuchResourceException`.
    pub fn is_no_such_resource_exception(&self) -> bool {
        matches!(self, Self::NoSuchResourceException(_))
    }
    /// Returns `true` if the error kind is `GetServiceQuotaIncreaseRequestFromTemplateError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `GetServiceQuotaIncreaseRequestFromTemplateError::TemplatesNotAvailableInRegionException`.
    pub fn is_templates_not_available_in_region_exception(&self) -> bool {
        matches!(self, Self::TemplatesNotAvailableInRegionException(_))
    }
    /// Returns `true` if the error kind is `GetServiceQuotaIncreaseRequestFromTemplateError::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(self, Self::TooManyRequestsException(_))
    }
}
impl std::error::Error for GetServiceQuotaIncreaseRequestFromTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::AwsServiceAccessNotEnabledException(_inner) =>
            Some(_inner)
            ,
            Self::DependencyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            Some(_inner)
            ,
            Self::NoAvailableOrganizationException(_inner) =>
            Some(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            Some(_inner)
            ,
            Self::ServiceException(_inner) =>
            Some(_inner)
            ,
            Self::TemplatesNotAvailableInRegionException(_inner) =>
            Some(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type GetServiceQuotaErrorKind = GetServiceQuotaError;
/// Error type for the `GetServiceQuotaError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetServiceQuotaError {
    /// <p>You do not have sufficient permission to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Invalid input was provided.</p>
    IllegalArgumentException(crate::error::IllegalArgumentException),
    /// <p>The specified resource does not exist.</p>
    NoSuchResourceException(crate::error::NoSuchResourceException),
    /// <p>Something went wrong.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>Due to throttling, the request was denied. Slow down the rate of request calls, or request an increase for this quota.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetServiceQuotaError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for GetServiceQuotaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::IllegalArgumentException(_inner) =>
            _inner.fmt(f)
            ,
            Self::NoSuchResourceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ServiceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TooManyRequestsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetServiceQuotaError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ServiceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetServiceQuotaError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for GetServiceQuotaError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetServiceQuotaError {
    /// Creates the `GetServiceQuotaError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `GetServiceQuotaError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::IllegalArgumentException(e) => e.meta(),
            Self::NoSuchResourceException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::TooManyRequestsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetServiceQuotaError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetServiceQuotaError::IllegalArgumentException`.
    pub fn is_illegal_argument_exception(&self) -> bool {
        matches!(self, Self::IllegalArgumentException(_))
    }
    /// Returns `true` if the error kind is `GetServiceQuotaError::NoSuchResourceException`.
    pub fn is_no_such_resource_exception(&self) -> bool {
        matches!(self, Self::NoSuchResourceException(_))
    }
    /// Returns `true` if the error kind is `GetServiceQuotaError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `GetServiceQuotaError::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(self, Self::TooManyRequestsException(_))
    }
}
impl std::error::Error for GetServiceQuotaError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            Some(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            Some(_inner)
            ,
            Self::ServiceException(_inner) =>
            Some(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type GetRequestedServiceQuotaChangeErrorKind = GetRequestedServiceQuotaChangeError;
/// Error type for the `GetRequestedServiceQuotaChangeError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRequestedServiceQuotaChangeError {
    /// <p>You do not have sufficient permission to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Invalid input was provided.</p>
    IllegalArgumentException(crate::error::IllegalArgumentException),
    /// <p>The specified resource does not exist.</p>
    NoSuchResourceException(crate::error::NoSuchResourceException),
    /// <p>Something went wrong.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>Due to throttling, the request was denied. Slow down the rate of request calls, or request an increase for this quota.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetRequestedServiceQuotaChangeError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for GetRequestedServiceQuotaChangeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::IllegalArgumentException(_inner) =>
            _inner.fmt(f)
            ,
            Self::NoSuchResourceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ServiceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TooManyRequestsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetRequestedServiceQuotaChangeError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ServiceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetRequestedServiceQuotaChangeError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for GetRequestedServiceQuotaChangeError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRequestedServiceQuotaChangeError {
    /// Creates the `GetRequestedServiceQuotaChangeError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `GetRequestedServiceQuotaChangeError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::IllegalArgumentException(e) => e.meta(),
            Self::NoSuchResourceException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::TooManyRequestsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetRequestedServiceQuotaChangeError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetRequestedServiceQuotaChangeError::IllegalArgumentException`.
    pub fn is_illegal_argument_exception(&self) -> bool {
        matches!(self, Self::IllegalArgumentException(_))
    }
    /// Returns `true` if the error kind is `GetRequestedServiceQuotaChangeError::NoSuchResourceException`.
    pub fn is_no_such_resource_exception(&self) -> bool {
        matches!(self, Self::NoSuchResourceException(_))
    }
    /// Returns `true` if the error kind is `GetRequestedServiceQuotaChangeError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `GetRequestedServiceQuotaChangeError::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(self, Self::TooManyRequestsException(_))
    }
}
impl std::error::Error for GetRequestedServiceQuotaChangeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            Some(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            Some(_inner)
            ,
            Self::ServiceException(_inner) =>
            Some(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type GetAWSDefaultServiceQuotaErrorKind = GetAWSDefaultServiceQuotaError;
/// Error type for the `GetAWSDefaultServiceQuotaError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAWSDefaultServiceQuotaError {
    /// <p>You do not have sufficient permission to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>Invalid input was provided.</p>
    IllegalArgumentException(crate::error::IllegalArgumentException),
    /// <p>The specified resource does not exist.</p>
    NoSuchResourceException(crate::error::NoSuchResourceException),
    /// <p>Something went wrong.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>Due to throttling, the request was denied. Slow down the rate of request calls, or request an increase for this quota.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetAWSDefaultServiceQuotaError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for GetAWSDefaultServiceQuotaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::IllegalArgumentException(_inner) =>
            _inner.fmt(f)
            ,
            Self::NoSuchResourceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ServiceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TooManyRequestsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetAWSDefaultServiceQuotaError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ServiceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetAWSDefaultServiceQuotaError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for GetAWSDefaultServiceQuotaError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAWSDefaultServiceQuotaError {
    /// Creates the `GetAWSDefaultServiceQuotaError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `GetAWSDefaultServiceQuotaError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::IllegalArgumentException(e) => e.meta(),
            Self::NoSuchResourceException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::TooManyRequestsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetAWSDefaultServiceQuotaError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetAWSDefaultServiceQuotaError::IllegalArgumentException`.
    pub fn is_illegal_argument_exception(&self) -> bool {
        matches!(self, Self::IllegalArgumentException(_))
    }
    /// Returns `true` if the error kind is `GetAWSDefaultServiceQuotaError::NoSuchResourceException`.
    pub fn is_no_such_resource_exception(&self) -> bool {
        matches!(self, Self::NoSuchResourceException(_))
    }
    /// Returns `true` if the error kind is `GetAWSDefaultServiceQuotaError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `GetAWSDefaultServiceQuotaError::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(self, Self::TooManyRequestsException(_))
    }
}
impl std::error::Error for GetAWSDefaultServiceQuotaError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            Some(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            Some(_inner)
            ,
            Self::ServiceException(_inner) =>
            Some(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type GetAssociationForServiceQuotaTemplateErrorKind = GetAssociationForServiceQuotaTemplateError;
/// Error type for the `GetAssociationForServiceQuotaTemplateError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAssociationForServiceQuotaTemplateError {
    /// <p>You do not have sufficient permission to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The action you attempted is not allowed unless Service Access with Service Quotas is enabled in your organization.</p>
    AwsServiceAccessNotEnabledException(crate::error::AwsServiceAccessNotEnabledException),
    /// <p>You can't perform this action because a dependency does not have access.</p>
    DependencyAccessDeniedException(crate::error::DependencyAccessDeniedException),
    /// <p>The account making this call is not a member of an organization.</p>
    NoAvailableOrganizationException(crate::error::NoAvailableOrganizationException),
    /// <p>Something went wrong.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The quota request template is not associated with your organization.</p>
    ServiceQuotaTemplateNotInUseException(crate::error::ServiceQuotaTemplateNotInUseException),
    /// <p>The Service Quotas template is not available in this AWS Region.</p>
    TemplatesNotAvailableInRegionException(crate::error::TemplatesNotAvailableInRegionException),
    /// <p>Due to throttling, the request was denied. Slow down the rate of request calls, or request an increase for this quota.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetAssociationForServiceQuotaTemplateError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for GetAssociationForServiceQuotaTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::AwsServiceAccessNotEnabledException(_inner) =>
            _inner.fmt(f)
            ,
            Self::DependencyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::NoAvailableOrganizationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ServiceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ServiceQuotaTemplateNotInUseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TemplatesNotAvailableInRegionException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TooManyRequestsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetAssociationForServiceQuotaTemplateError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::AwsServiceAccessNotEnabledException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::DependencyAccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::NoAvailableOrganizationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ServiceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ServiceQuotaTemplateNotInUseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TemplatesNotAvailableInRegionException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetAssociationForServiceQuotaTemplateError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for GetAssociationForServiceQuotaTemplateError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAssociationForServiceQuotaTemplateError {
    /// Creates the `GetAssociationForServiceQuotaTemplateError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `GetAssociationForServiceQuotaTemplateError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::AwsServiceAccessNotEnabledException(e) => e.meta(),
            Self::DependencyAccessDeniedException(e) => e.meta(),
            Self::NoAvailableOrganizationException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::ServiceQuotaTemplateNotInUseException(e) => e.meta(),
            Self::TemplatesNotAvailableInRegionException(e) => e.meta(),
            Self::TooManyRequestsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetAssociationForServiceQuotaTemplateError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetAssociationForServiceQuotaTemplateError::AwsServiceAccessNotEnabledException`.
    pub fn is_aws_service_access_not_enabled_exception(&self) -> bool {
        matches!(self, Self::AwsServiceAccessNotEnabledException(_))
    }
    /// Returns `true` if the error kind is `GetAssociationForServiceQuotaTemplateError::DependencyAccessDeniedException`.
    pub fn is_dependency_access_denied_exception(&self) -> bool {
        matches!(self, Self::DependencyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetAssociationForServiceQuotaTemplateError::NoAvailableOrganizationException`.
    pub fn is_no_available_organization_exception(&self) -> bool {
        matches!(self, Self::NoAvailableOrganizationException(_))
    }
    /// Returns `true` if the error kind is `GetAssociationForServiceQuotaTemplateError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `GetAssociationForServiceQuotaTemplateError::ServiceQuotaTemplateNotInUseException`.
    pub fn is_service_quota_template_not_in_use_exception(&self) -> bool {
        matches!(self, Self::ServiceQuotaTemplateNotInUseException(_))
    }
    /// Returns `true` if the error kind is `GetAssociationForServiceQuotaTemplateError::TemplatesNotAvailableInRegionException`.
    pub fn is_templates_not_available_in_region_exception(&self) -> bool {
        matches!(self, Self::TemplatesNotAvailableInRegionException(_))
    }
    /// Returns `true` if the error kind is `GetAssociationForServiceQuotaTemplateError::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(self, Self::TooManyRequestsException(_))
    }
}
impl std::error::Error for GetAssociationForServiceQuotaTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::AwsServiceAccessNotEnabledException(_inner) =>
            Some(_inner)
            ,
            Self::DependencyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::NoAvailableOrganizationException(_inner) =>
            Some(_inner)
            ,
            Self::ServiceException(_inner) =>
            Some(_inner)
            ,
            Self::ServiceQuotaTemplateNotInUseException(_inner) =>
            Some(_inner)
            ,
            Self::TemplatesNotAvailableInRegionException(_inner) =>
            Some(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>The quota request template is not associated with your organization.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceQuotaTemplateNotInUseException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ServiceQuotaTemplateNotInUseException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ServiceQuotaTemplateNotInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceQuotaTemplateNotInUseException")?;
        if let Some(inner_16) = &self.message {
             {
                write!(f, ": {}", inner_16)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ServiceQuotaTemplateNotInUseException {}
impl aws_http::request_id::RequestId for crate::error::ServiceQuotaTemplateNotInUseException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ServiceQuotaTemplateNotInUseException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}
impl ServiceQuotaTemplateNotInUseException {
    /// Creates a new builder-style object to manufacture [`ServiceQuotaTemplateNotInUseException`](crate::error::ServiceQuotaTemplateNotInUseException).
    pub fn builder() -> crate::error::service_quota_template_not_in_use_exception::Builder {
        crate::error::service_quota_template_not_in_use_exception::Builder::default()
    }
}

/// See [`ServiceQuotaTemplateNotInUseException`](crate::error::ServiceQuotaTemplateNotInUseException).
pub mod service_quota_template_not_in_use_exception {
    
    /// A builder for [`ServiceQuotaTemplateNotInUseException`](crate::error::ServiceQuotaTemplateNotInUseException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                                pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                    self.meta = Some(meta);
                                                    self
                                                }
        
                                                /// Sets error metadata
                                                pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                    self.meta = meta;
                                                    self
                                                }
        /// Consumes the builder and constructs a [`ServiceQuotaTemplateNotInUseException`](crate::error::ServiceQuotaTemplateNotInUseException).
        pub fn build(self) -> crate::error::ServiceQuotaTemplateNotInUseException {
            crate::error::ServiceQuotaTemplateNotInUseException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DisassociateServiceQuotaTemplateErrorKind = DisassociateServiceQuotaTemplateError;
/// Error type for the `DisassociateServiceQuotaTemplateError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateServiceQuotaTemplateError {
    /// <p>You do not have sufficient permission to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The action you attempted is not allowed unless Service Access with Service Quotas is enabled in your organization.</p>
    AwsServiceAccessNotEnabledException(crate::error::AwsServiceAccessNotEnabledException),
    /// <p>You can't perform this action because a dependency does not have access.</p>
    DependencyAccessDeniedException(crate::error::DependencyAccessDeniedException),
    /// <p>The account making this call is not a member of an organization.</p>
    NoAvailableOrganizationException(crate::error::NoAvailableOrganizationException),
    /// <p>Something went wrong.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The quota request template is not associated with your organization.</p>
    ServiceQuotaTemplateNotInUseException(crate::error::ServiceQuotaTemplateNotInUseException),
    /// <p>The Service Quotas template is not available in this AWS Region.</p>
    TemplatesNotAvailableInRegionException(crate::error::TemplatesNotAvailableInRegionException),
    /// <p>Due to throttling, the request was denied. Slow down the rate of request calls, or request an increase for this quota.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DisassociateServiceQuotaTemplateError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DisassociateServiceQuotaTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::AwsServiceAccessNotEnabledException(_inner) =>
            _inner.fmt(f)
            ,
            Self::DependencyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::NoAvailableOrganizationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ServiceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ServiceQuotaTemplateNotInUseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TemplatesNotAvailableInRegionException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TooManyRequestsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DisassociateServiceQuotaTemplateError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::AwsServiceAccessNotEnabledException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::DependencyAccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::NoAvailableOrganizationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ServiceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ServiceQuotaTemplateNotInUseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TemplatesNotAvailableInRegionException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DisassociateServiceQuotaTemplateError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DisassociateServiceQuotaTemplateError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateServiceQuotaTemplateError {
    /// Creates the `DisassociateServiceQuotaTemplateError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DisassociateServiceQuotaTemplateError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::AwsServiceAccessNotEnabledException(e) => e.meta(),
            Self::DependencyAccessDeniedException(e) => e.meta(),
            Self::NoAvailableOrganizationException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::ServiceQuotaTemplateNotInUseException(e) => e.meta(),
            Self::TemplatesNotAvailableInRegionException(e) => e.meta(),
            Self::TooManyRequestsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DisassociateServiceQuotaTemplateError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DisassociateServiceQuotaTemplateError::AwsServiceAccessNotEnabledException`.
    pub fn is_aws_service_access_not_enabled_exception(&self) -> bool {
        matches!(self, Self::AwsServiceAccessNotEnabledException(_))
    }
    /// Returns `true` if the error kind is `DisassociateServiceQuotaTemplateError::DependencyAccessDeniedException`.
    pub fn is_dependency_access_denied_exception(&self) -> bool {
        matches!(self, Self::DependencyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DisassociateServiceQuotaTemplateError::NoAvailableOrganizationException`.
    pub fn is_no_available_organization_exception(&self) -> bool {
        matches!(self, Self::NoAvailableOrganizationException(_))
    }
    /// Returns `true` if the error kind is `DisassociateServiceQuotaTemplateError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `DisassociateServiceQuotaTemplateError::ServiceQuotaTemplateNotInUseException`.
    pub fn is_service_quota_template_not_in_use_exception(&self) -> bool {
        matches!(self, Self::ServiceQuotaTemplateNotInUseException(_))
    }
    /// Returns `true` if the error kind is `DisassociateServiceQuotaTemplateError::TemplatesNotAvailableInRegionException`.
    pub fn is_templates_not_available_in_region_exception(&self) -> bool {
        matches!(self, Self::TemplatesNotAvailableInRegionException(_))
    }
    /// Returns `true` if the error kind is `DisassociateServiceQuotaTemplateError::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(self, Self::TooManyRequestsException(_))
    }
}
impl std::error::Error for DisassociateServiceQuotaTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::AwsServiceAccessNotEnabledException(_inner) =>
            Some(_inner)
            ,
            Self::DependencyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::NoAvailableOrganizationException(_inner) =>
            Some(_inner)
            ,
            Self::ServiceException(_inner) =>
            Some(_inner)
            ,
            Self::ServiceQuotaTemplateNotInUseException(_inner) =>
            Some(_inner)
            ,
            Self::TemplatesNotAvailableInRegionException(_inner) =>
            Some(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DeleteServiceQuotaIncreaseRequestFromTemplateErrorKind = DeleteServiceQuotaIncreaseRequestFromTemplateError;
/// Error type for the `DeleteServiceQuotaIncreaseRequestFromTemplateError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteServiceQuotaIncreaseRequestFromTemplateError {
    /// <p>You do not have sufficient permission to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The action you attempted is not allowed unless Service Access with Service Quotas is enabled in your organization.</p>
    AwsServiceAccessNotEnabledException(crate::error::AwsServiceAccessNotEnabledException),
    /// <p>You can't perform this action because a dependency does not have access.</p>
    DependencyAccessDeniedException(crate::error::DependencyAccessDeniedException),
    /// <p>Invalid input was provided.</p>
    IllegalArgumentException(crate::error::IllegalArgumentException),
    /// <p>The account making this call is not a member of an organization.</p>
    NoAvailableOrganizationException(crate::error::NoAvailableOrganizationException),
    /// <p>The specified resource does not exist.</p>
    NoSuchResourceException(crate::error::NoSuchResourceException),
    /// <p>Something went wrong.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The Service Quotas template is not available in this AWS Region.</p>
    TemplatesNotAvailableInRegionException(crate::error::TemplatesNotAvailableInRegionException),
    /// <p>Due to throttling, the request was denied. Slow down the rate of request calls, or request an increase for this quota.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteServiceQuotaIncreaseRequestFromTemplateError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DeleteServiceQuotaIncreaseRequestFromTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::AwsServiceAccessNotEnabledException(_inner) =>
            _inner.fmt(f)
            ,
            Self::DependencyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::IllegalArgumentException(_inner) =>
            _inner.fmt(f)
            ,
            Self::NoAvailableOrganizationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::NoSuchResourceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ServiceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TemplatesNotAvailableInRegionException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TooManyRequestsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteServiceQuotaIncreaseRequestFromTemplateError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::AwsServiceAccessNotEnabledException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::DependencyAccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::NoAvailableOrganizationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ServiceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TemplatesNotAvailableInRegionException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteServiceQuotaIncreaseRequestFromTemplateError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DeleteServiceQuotaIncreaseRequestFromTemplateError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteServiceQuotaIncreaseRequestFromTemplateError {
    /// Creates the `DeleteServiceQuotaIncreaseRequestFromTemplateError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DeleteServiceQuotaIncreaseRequestFromTemplateError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::AwsServiceAccessNotEnabledException(e) => e.meta(),
            Self::DependencyAccessDeniedException(e) => e.meta(),
            Self::IllegalArgumentException(e) => e.meta(),
            Self::NoAvailableOrganizationException(e) => e.meta(),
            Self::NoSuchResourceException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::TemplatesNotAvailableInRegionException(e) => e.meta(),
            Self::TooManyRequestsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteServiceQuotaIncreaseRequestFromTemplateError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DeleteServiceQuotaIncreaseRequestFromTemplateError::AwsServiceAccessNotEnabledException`.
    pub fn is_aws_service_access_not_enabled_exception(&self) -> bool {
        matches!(self, Self::AwsServiceAccessNotEnabledException(_))
    }
    /// Returns `true` if the error kind is `DeleteServiceQuotaIncreaseRequestFromTemplateError::DependencyAccessDeniedException`.
    pub fn is_dependency_access_denied_exception(&self) -> bool {
        matches!(self, Self::DependencyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DeleteServiceQuotaIncreaseRequestFromTemplateError::IllegalArgumentException`.
    pub fn is_illegal_argument_exception(&self) -> bool {
        matches!(self, Self::IllegalArgumentException(_))
    }
    /// Returns `true` if the error kind is `DeleteServiceQuotaIncreaseRequestFromTemplateError::NoAvailableOrganizationException`.
    pub fn is_no_available_organization_exception(&self) -> bool {
        matches!(self, Self::NoAvailableOrganizationException(_))
    }
    /// Returns `true` if the error kind is `DeleteServiceQuotaIncreaseRequestFromTemplateError::NoSuchResourceException`.
    pub fn is_no_such_resource_exception(&self) -> bool {
        matches!(self, Self::NoSuchResourceException(_))
    }
    /// Returns `true` if the error kind is `DeleteServiceQuotaIncreaseRequestFromTemplateError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `DeleteServiceQuotaIncreaseRequestFromTemplateError::TemplatesNotAvailableInRegionException`.
    pub fn is_templates_not_available_in_region_exception(&self) -> bool {
        matches!(self, Self::TemplatesNotAvailableInRegionException(_))
    }
    /// Returns `true` if the error kind is `DeleteServiceQuotaIncreaseRequestFromTemplateError::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(self, Self::TooManyRequestsException(_))
    }
}
impl std::error::Error for DeleteServiceQuotaIncreaseRequestFromTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::AwsServiceAccessNotEnabledException(_inner) =>
            Some(_inner)
            ,
            Self::DependencyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::IllegalArgumentException(_inner) =>
            Some(_inner)
            ,
            Self::NoAvailableOrganizationException(_inner) =>
            Some(_inner)
            ,
            Self::NoSuchResourceException(_inner) =>
            Some(_inner)
            ,
            Self::ServiceException(_inner) =>
            Some(_inner)
            ,
            Self::TemplatesNotAvailableInRegionException(_inner) =>
            Some(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type AssociateServiceQuotaTemplateErrorKind = AssociateServiceQuotaTemplateError;
/// Error type for the `AssociateServiceQuotaTemplateError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateServiceQuotaTemplateError {
    /// <p>You do not have sufficient permission to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The action you attempted is not allowed unless Service Access with Service Quotas is enabled in your organization.</p>
    AwsServiceAccessNotEnabledException(crate::error::AwsServiceAccessNotEnabledException),
    /// <p>You can't perform this action because a dependency does not have access.</p>
    DependencyAccessDeniedException(crate::error::DependencyAccessDeniedException),
    /// <p>The account making this call is not a member of an organization.</p>
    NoAvailableOrganizationException(crate::error::NoAvailableOrganizationException),
    /// <p>The organization that your account belongs to is not in All Features mode.</p>
    OrganizationNotInAllFeaturesModeException(crate::error::OrganizationNotInAllFeaturesModeException),
    /// <p>Something went wrong.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The Service Quotas template is not available in this AWS Region.</p>
    TemplatesNotAvailableInRegionException(crate::error::TemplatesNotAvailableInRegionException),
    /// <p>Due to throttling, the request was denied. Slow down the rate of request calls, or request an increase for this quota.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AssociateServiceQuotaTemplateError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for AssociateServiceQuotaTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::AwsServiceAccessNotEnabledException(_inner) =>
            _inner.fmt(f)
            ,
            Self::DependencyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::NoAvailableOrganizationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::OrganizationNotInAllFeaturesModeException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ServiceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TemplatesNotAvailableInRegionException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TooManyRequestsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AssociateServiceQuotaTemplateError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::AwsServiceAccessNotEnabledException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::DependencyAccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::NoAvailableOrganizationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::OrganizationNotInAllFeaturesModeException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ServiceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TemplatesNotAvailableInRegionException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::AssociateServiceQuotaTemplateError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for AssociateServiceQuotaTemplateError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateServiceQuotaTemplateError {
    /// Creates the `AssociateServiceQuotaTemplateError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `AssociateServiceQuotaTemplateError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::AwsServiceAccessNotEnabledException(e) => e.meta(),
            Self::DependencyAccessDeniedException(e) => e.meta(),
            Self::NoAvailableOrganizationException(e) => e.meta(),
            Self::OrganizationNotInAllFeaturesModeException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::TemplatesNotAvailableInRegionException(e) => e.meta(),
            Self::TooManyRequestsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AssociateServiceQuotaTemplateError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `AssociateServiceQuotaTemplateError::AwsServiceAccessNotEnabledException`.
    pub fn is_aws_service_access_not_enabled_exception(&self) -> bool {
        matches!(self, Self::AwsServiceAccessNotEnabledException(_))
    }
    /// Returns `true` if the error kind is `AssociateServiceQuotaTemplateError::DependencyAccessDeniedException`.
    pub fn is_dependency_access_denied_exception(&self) -> bool {
        matches!(self, Self::DependencyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `AssociateServiceQuotaTemplateError::NoAvailableOrganizationException`.
    pub fn is_no_available_organization_exception(&self) -> bool {
        matches!(self, Self::NoAvailableOrganizationException(_))
    }
    /// Returns `true` if the error kind is `AssociateServiceQuotaTemplateError::OrganizationNotInAllFeaturesModeException`.
    pub fn is_organization_not_in_all_features_mode_exception(&self) -> bool {
        matches!(self, Self::OrganizationNotInAllFeaturesModeException(_))
    }
    /// Returns `true` if the error kind is `AssociateServiceQuotaTemplateError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `AssociateServiceQuotaTemplateError::TemplatesNotAvailableInRegionException`.
    pub fn is_templates_not_available_in_region_exception(&self) -> bool {
        matches!(self, Self::TemplatesNotAvailableInRegionException(_))
    }
    /// Returns `true` if the error kind is `AssociateServiceQuotaTemplateError::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(self, Self::TooManyRequestsException(_))
    }
}
impl std::error::Error for AssociateServiceQuotaTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::AwsServiceAccessNotEnabledException(_inner) =>
            Some(_inner)
            ,
            Self::DependencyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::NoAvailableOrganizationException(_inner) =>
            Some(_inner)
            ,
            Self::OrganizationNotInAllFeaturesModeException(_inner) =>
            Some(_inner)
            ,
            Self::ServiceException(_inner) =>
            Some(_inner)
            ,
            Self::TemplatesNotAvailableInRegionException(_inner) =>
            Some(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>The organization that your account belongs to is not in All Features mode.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OrganizationNotInAllFeaturesModeException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl OrganizationNotInAllFeaturesModeException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for OrganizationNotInAllFeaturesModeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OrganizationNotInAllFeaturesModeException")?;
        if let Some(inner_17) = &self.message {
             {
                write!(f, ": {}", inner_17)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for OrganizationNotInAllFeaturesModeException {}
impl aws_http::request_id::RequestId for crate::error::OrganizationNotInAllFeaturesModeException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for OrganizationNotInAllFeaturesModeException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}
impl OrganizationNotInAllFeaturesModeException {
    /// Creates a new builder-style object to manufacture [`OrganizationNotInAllFeaturesModeException`](crate::error::OrganizationNotInAllFeaturesModeException).
    pub fn builder() -> crate::error::organization_not_in_all_features_mode_exception::Builder {
        crate::error::organization_not_in_all_features_mode_exception::Builder::default()
    }
}

/// See [`OrganizationNotInAllFeaturesModeException`](crate::error::OrganizationNotInAllFeaturesModeException).
pub mod organization_not_in_all_features_mode_exception {
    
    /// A builder for [`OrganizationNotInAllFeaturesModeException`](crate::error::OrganizationNotInAllFeaturesModeException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                                pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                    self.meta = Some(meta);
                                                    self
                                                }
        
                                                /// Sets error metadata
                                                pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                    self.meta = meta;
                                                    self
                                                }
        /// Consumes the builder and constructs a [`OrganizationNotInAllFeaturesModeException`](crate::error::OrganizationNotInAllFeaturesModeException).
        pub fn build(self) -> crate::error::OrganizationNotInAllFeaturesModeException {
            crate::error::OrganizationNotInAllFeaturesModeException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}

