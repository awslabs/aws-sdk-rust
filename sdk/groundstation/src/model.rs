// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Item in a list of satellites.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SatelliteListItem {
    /// <p>UUID of a satellite.</p>
    #[doc(hidden)]
    pub satellite_id: std::option::Option<std::string::String>,
    /// <p>ARN of a satellite.</p>
    #[doc(hidden)]
    pub satellite_arn: std::option::Option<std::string::String>,
    /// <p>NORAD satellite ID number.</p>
    #[doc(hidden)]
    pub norad_satellite_id: i32,
    /// <p>A list of ground stations to which the satellite is on-boarded.</p>
    #[doc(hidden)]
    pub ground_stations: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The current ephemeris being used to compute the trajectory of the satellite.</p>
    #[doc(hidden)]
    pub current_ephemeris: std::option::Option<crate::model::EphemerisMetaData>,
}
impl SatelliteListItem {
    /// <p>UUID of a satellite.</p>
    pub fn satellite_id(&self) -> std::option::Option<&str> {
        self.satellite_id.as_deref()
    }
    /// <p>ARN of a satellite.</p>
    pub fn satellite_arn(&self) -> std::option::Option<&str> {
        self.satellite_arn.as_deref()
    }
    /// <p>NORAD satellite ID number.</p>
    pub fn norad_satellite_id(&self) -> i32 {
        self.norad_satellite_id
    }
    /// <p>A list of ground stations to which the satellite is on-boarded.</p>
    pub fn ground_stations(&self) -> std::option::Option<&[std::string::String]> {
        self.ground_stations.as_deref()
    }
    /// <p>The current ephemeris being used to compute the trajectory of the satellite.</p>
    pub fn current_ephemeris(&self) -> std::option::Option<&crate::model::EphemerisMetaData> {
        self.current_ephemeris.as_ref()
    }
}
/// See [`SatelliteListItem`](crate::model::SatelliteListItem).
pub mod satellite_list_item {

    /// A builder for [`SatelliteListItem`](crate::model::SatelliteListItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) satellite_id: std::option::Option<std::string::String>,
        pub(crate) satellite_arn: std::option::Option<std::string::String>,
        pub(crate) norad_satellite_id: std::option::Option<i32>,
        pub(crate) ground_stations: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) current_ephemeris: std::option::Option<crate::model::EphemerisMetaData>,
    }
    impl Builder {
        /// <p>UUID of a satellite.</p>
        pub fn satellite_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.satellite_id = Some(input.into());
            self
        }
        /// <p>UUID of a satellite.</p>
        pub fn set_satellite_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.satellite_id = input;
            self
        }
        /// <p>ARN of a satellite.</p>
        pub fn satellite_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.satellite_arn = Some(input.into());
            self
        }
        /// <p>ARN of a satellite.</p>
        pub fn set_satellite_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.satellite_arn = input;
            self
        }
        /// <p>NORAD satellite ID number.</p>
        pub fn norad_satellite_id(mut self, input: i32) -> Self {
            self.norad_satellite_id = Some(input);
            self
        }
        /// <p>NORAD satellite ID number.</p>
        pub fn set_norad_satellite_id(mut self, input: std::option::Option<i32>) -> Self {
            self.norad_satellite_id = input;
            self
        }
        /// Appends an item to `ground_stations`.
        ///
        /// To override the contents of this collection use [`set_ground_stations`](Self::set_ground_stations).
        ///
        /// <p>A list of ground stations to which the satellite is on-boarded.</p>
        pub fn ground_stations(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ground_stations.unwrap_or_default();
            v.push(input.into());
            self.ground_stations = Some(v);
            self
        }
        /// <p>A list of ground stations to which the satellite is on-boarded.</p>
        pub fn set_ground_stations(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ground_stations = input;
            self
        }
        /// <p>The current ephemeris being used to compute the trajectory of the satellite.</p>
        pub fn current_ephemeris(mut self, input: crate::model::EphemerisMetaData) -> Self {
            self.current_ephemeris = Some(input);
            self
        }
        /// <p>The current ephemeris being used to compute the trajectory of the satellite.</p>
        pub fn set_current_ephemeris(
            mut self,
            input: std::option::Option<crate::model::EphemerisMetaData>,
        ) -> Self {
            self.current_ephemeris = input;
            self
        }
        /// Consumes the builder and constructs a [`SatelliteListItem`](crate::model::SatelliteListItem).
        pub fn build(self) -> crate::model::SatelliteListItem {
            crate::model::SatelliteListItem {
                satellite_id: self.satellite_id,
                satellite_arn: self.satellite_arn,
                norad_satellite_id: self.norad_satellite_id.unwrap_or_default(),
                ground_stations: self.ground_stations,
                current_ephemeris: self.current_ephemeris,
            }
        }
    }
}
impl SatelliteListItem {
    /// Creates a new builder-style object to manufacture [`SatelliteListItem`](crate::model::SatelliteListItem).
    pub fn builder() -> crate::model::satellite_list_item::Builder {
        crate::model::satellite_list_item::Builder::default()
    }
}

/// <p>Metadata describing a particular ephemeris.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EphemerisMetaData {
    /// <p>The <code>EphemerisSource</code> that generated a given ephemeris.</p>
    #[doc(hidden)]
    pub source: std::option::Option<crate::model::EphemerisSource>,
    /// <p>UUID of a customer-provided ephemeris.</p>
    /// <p>This field is not populated for default ephemerides from Space Track.</p>
    #[doc(hidden)]
    pub ephemeris_id: std::option::Option<std::string::String>,
    /// <p>The epoch of a default, ephemeris from Space Track in UTC.</p>
    /// <p>This field is not populated for customer-provided ephemerides.</p>
    #[doc(hidden)]
    pub epoch: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.</p>
    /// <p>A name is only returned for customer-provider ephemerides that have a name associated.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl EphemerisMetaData {
    /// <p>The <code>EphemerisSource</code> that generated a given ephemeris.</p>
    pub fn source(&self) -> std::option::Option<&crate::model::EphemerisSource> {
        self.source.as_ref()
    }
    /// <p>UUID of a customer-provided ephemeris.</p>
    /// <p>This field is not populated for default ephemerides from Space Track.</p>
    pub fn ephemeris_id(&self) -> std::option::Option<&str> {
        self.ephemeris_id.as_deref()
    }
    /// <p>The epoch of a default, ephemeris from Space Track in UTC.</p>
    /// <p>This field is not populated for customer-provided ephemerides.</p>
    pub fn epoch(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.epoch.as_ref()
    }
    /// <p>A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.</p>
    /// <p>A name is only returned for customer-provider ephemerides that have a name associated.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
/// See [`EphemerisMetaData`](crate::model::EphemerisMetaData).
pub mod ephemeris_meta_data {

    /// A builder for [`EphemerisMetaData`](crate::model::EphemerisMetaData).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source: std::option::Option<crate::model::EphemerisSource>,
        pub(crate) ephemeris_id: std::option::Option<std::string::String>,
        pub(crate) epoch: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The <code>EphemerisSource</code> that generated a given ephemeris.</p>
        pub fn source(mut self, input: crate::model::EphemerisSource) -> Self {
            self.source = Some(input);
            self
        }
        /// <p>The <code>EphemerisSource</code> that generated a given ephemeris.</p>
        pub fn set_source(
            mut self,
            input: std::option::Option<crate::model::EphemerisSource>,
        ) -> Self {
            self.source = input;
            self
        }
        /// <p>UUID of a customer-provided ephemeris.</p>
        /// <p>This field is not populated for default ephemerides from Space Track.</p>
        pub fn ephemeris_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ephemeris_id = Some(input.into());
            self
        }
        /// <p>UUID of a customer-provided ephemeris.</p>
        /// <p>This field is not populated for default ephemerides from Space Track.</p>
        pub fn set_ephemeris_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ephemeris_id = input;
            self
        }
        /// <p>The epoch of a default, ephemeris from Space Track in UTC.</p>
        /// <p>This field is not populated for customer-provided ephemerides.</p>
        pub fn epoch(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.epoch = Some(input);
            self
        }
        /// <p>The epoch of a default, ephemeris from Space Track in UTC.</p>
        /// <p>This field is not populated for customer-provided ephemerides.</p>
        pub fn set_epoch(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.epoch = input;
            self
        }
        /// <p>A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.</p>
        /// <p>A name is only returned for customer-provider ephemerides that have a name associated.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.</p>
        /// <p>A name is only returned for customer-provider ephemerides that have a name associated.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`EphemerisMetaData`](crate::model::EphemerisMetaData).
        pub fn build(self) -> crate::model::EphemerisMetaData {
            crate::model::EphemerisMetaData {
                source: self.source,
                ephemeris_id: self.ephemeris_id,
                epoch: self.epoch,
                name: self.name,
            }
        }
    }
}
impl EphemerisMetaData {
    /// Creates a new builder-style object to manufacture [`EphemerisMetaData`](crate::model::EphemerisMetaData).
    pub fn builder() -> crate::model::ephemeris_meta_data::Builder {
        crate::model::ephemeris_meta_data::Builder::default()
    }
}

/// When writing a match expression against `EphemerisSource`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let ephemerissource = unimplemented!();
/// match ephemerissource {
///     EphemerisSource::CustomerProvided => { /* ... */ },
///     EphemerisSource::SpaceTrack => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `ephemerissource` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EphemerisSource::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EphemerisSource::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EphemerisSource::NewFeature` is defined.
/// Specifically, when `ephemerissource` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EphemerisSource::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EphemerisSource {
    #[allow(missing_docs)] // documentation missing in model
    CustomerProvided,
    #[allow(missing_docs)] // documentation missing in model
    SpaceTrack,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EphemerisSource {
    fn from(s: &str) -> Self {
        match s {
            "CUSTOMER_PROVIDED" => EphemerisSource::CustomerProvided,
            "SPACE_TRACK" => EphemerisSource::SpaceTrack,
            other => EphemerisSource::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EphemerisSource {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EphemerisSource::from(s))
    }
}
impl EphemerisSource {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EphemerisSource::CustomerProvided => "CUSTOMER_PROVIDED",
            EphemerisSource::SpaceTrack => "SPACE_TRACK",
            EphemerisSource::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CUSTOMER_PROVIDED", "SPACE_TRACK"]
    }
}
impl AsRef<str> for EphemerisSource {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Item in a list of mission profiles.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MissionProfileListItem {
    /// <p>UUID of a mission profile.</p>
    #[doc(hidden)]
    pub mission_profile_id: std::option::Option<std::string::String>,
    /// <p>ARN of a mission profile.</p>
    #[doc(hidden)]
    pub mission_profile_arn: std::option::Option<std::string::String>,
    /// <p>Region of a mission profile.</p>
    #[doc(hidden)]
    pub region: std::option::Option<std::string::String>,
    /// <p>Name of a mission profile.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl MissionProfileListItem {
    /// <p>UUID of a mission profile.</p>
    pub fn mission_profile_id(&self) -> std::option::Option<&str> {
        self.mission_profile_id.as_deref()
    }
    /// <p>ARN of a mission profile.</p>
    pub fn mission_profile_arn(&self) -> std::option::Option<&str> {
        self.mission_profile_arn.as_deref()
    }
    /// <p>Region of a mission profile.</p>
    pub fn region(&self) -> std::option::Option<&str> {
        self.region.as_deref()
    }
    /// <p>Name of a mission profile.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
/// See [`MissionProfileListItem`](crate::model::MissionProfileListItem).
pub mod mission_profile_list_item {

    /// A builder for [`MissionProfileListItem`](crate::model::MissionProfileListItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mission_profile_id: std::option::Option<std::string::String>,
        pub(crate) mission_profile_arn: std::option::Option<std::string::String>,
        pub(crate) region: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>UUID of a mission profile.</p>
        pub fn mission_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.mission_profile_id = Some(input.into());
            self
        }
        /// <p>UUID of a mission profile.</p>
        pub fn set_mission_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.mission_profile_id = input;
            self
        }
        /// <p>ARN of a mission profile.</p>
        pub fn mission_profile_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.mission_profile_arn = Some(input.into());
            self
        }
        /// <p>ARN of a mission profile.</p>
        pub fn set_mission_profile_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.mission_profile_arn = input;
            self
        }
        /// <p>Region of a mission profile.</p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        /// <p>Region of a mission profile.</p>
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// <p>Name of a mission profile.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Name of a mission profile.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`MissionProfileListItem`](crate::model::MissionProfileListItem).
        pub fn build(self) -> crate::model::MissionProfileListItem {
            crate::model::MissionProfileListItem {
                mission_profile_id: self.mission_profile_id,
                mission_profile_arn: self.mission_profile_arn,
                region: self.region,
                name: self.name,
            }
        }
    }
}
impl MissionProfileListItem {
    /// Creates a new builder-style object to manufacture [`MissionProfileListItem`](crate::model::MissionProfileListItem).
    pub fn builder() -> crate::model::mission_profile_list_item::Builder {
        crate::model::mission_profile_list_item::Builder::default()
    }
}

/// <p>Information about the ground station data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GroundStationData {
    /// <p>UUID of a ground station.</p>
    #[doc(hidden)]
    pub ground_station_id: std::option::Option<std::string::String>,
    /// <p>Name of a ground station.</p>
    #[doc(hidden)]
    pub ground_station_name: std::option::Option<std::string::String>,
    /// <p>Ground station Region.</p>
    #[doc(hidden)]
    pub region: std::option::Option<std::string::String>,
}
impl GroundStationData {
    /// <p>UUID of a ground station.</p>
    pub fn ground_station_id(&self) -> std::option::Option<&str> {
        self.ground_station_id.as_deref()
    }
    /// <p>Name of a ground station.</p>
    pub fn ground_station_name(&self) -> std::option::Option<&str> {
        self.ground_station_name.as_deref()
    }
    /// <p>Ground station Region.</p>
    pub fn region(&self) -> std::option::Option<&str> {
        self.region.as_deref()
    }
}
/// See [`GroundStationData`](crate::model::GroundStationData).
pub mod ground_station_data {

    /// A builder for [`GroundStationData`](crate::model::GroundStationData).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ground_station_id: std::option::Option<std::string::String>,
        pub(crate) ground_station_name: std::option::Option<std::string::String>,
        pub(crate) region: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>UUID of a ground station.</p>
        pub fn ground_station_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ground_station_id = Some(input.into());
            self
        }
        /// <p>UUID of a ground station.</p>
        pub fn set_ground_station_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ground_station_id = input;
            self
        }
        /// <p>Name of a ground station.</p>
        pub fn ground_station_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.ground_station_name = Some(input.into());
            self
        }
        /// <p>Name of a ground station.</p>
        pub fn set_ground_station_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ground_station_name = input;
            self
        }
        /// <p>Ground station Region.</p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        /// <p>Ground station Region.</p>
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// Consumes the builder and constructs a [`GroundStationData`](crate::model::GroundStationData).
        pub fn build(self) -> crate::model::GroundStationData {
            crate::model::GroundStationData {
                ground_station_id: self.ground_station_id,
                ground_station_name: self.ground_station_name,
                region: self.region,
            }
        }
    }
}
impl GroundStationData {
    /// Creates a new builder-style object to manufacture [`GroundStationData`](crate::model::GroundStationData).
    pub fn builder() -> crate::model::ground_station_data::Builder {
        crate::model::ground_station_data::Builder::default()
    }
}

/// <p>Ephemeris item.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EphemerisItem {
    /// <p>The AWS Ground Station ephemeris ID.</p>
    #[doc(hidden)]
    pub ephemeris_id: std::option::Option<std::string::String>,
    /// <p>The status of the ephemeris.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::EphemerisStatus>,
    /// <p>Customer-provided priority score to establish the order in which overlapping ephemerides should be used.</p>
    /// <p>The default for customer-provided ephemeris priority is 1, and higher numbers take precedence.</p>
    /// <p>Priority must be 1 or greater</p>
    #[doc(hidden)]
    pub priority: std::option::Option<i32>,
    /// <p>Whether or not the ephemeris is enabled.</p>
    #[doc(hidden)]
    pub enabled: std::option::Option<bool>,
    /// <p>The time the ephemeris was uploaded in UTC.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Source S3 object used for the ephemeris.</p>
    #[doc(hidden)]
    pub source_s3_object: std::option::Option<crate::model::S3Object>,
}
impl EphemerisItem {
    /// <p>The AWS Ground Station ephemeris ID.</p>
    pub fn ephemeris_id(&self) -> std::option::Option<&str> {
        self.ephemeris_id.as_deref()
    }
    /// <p>The status of the ephemeris.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::EphemerisStatus> {
        self.status.as_ref()
    }
    /// <p>Customer-provided priority score to establish the order in which overlapping ephemerides should be used.</p>
    /// <p>The default for customer-provided ephemeris priority is 1, and higher numbers take precedence.</p>
    /// <p>Priority must be 1 or greater</p>
    pub fn priority(&self) -> std::option::Option<i32> {
        self.priority
    }
    /// <p>Whether or not the ephemeris is enabled.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
    /// <p>The time the ephemeris was uploaded in UTC.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Source S3 object used for the ephemeris.</p>
    pub fn source_s3_object(&self) -> std::option::Option<&crate::model::S3Object> {
        self.source_s3_object.as_ref()
    }
}
/// See [`EphemerisItem`](crate::model::EphemerisItem).
pub mod ephemeris_item {

    /// A builder for [`EphemerisItem`](crate::model::EphemerisItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ephemeris_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::EphemerisStatus>,
        pub(crate) priority: std::option::Option<i32>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) source_s3_object: std::option::Option<crate::model::S3Object>,
    }
    impl Builder {
        /// <p>The AWS Ground Station ephemeris ID.</p>
        pub fn ephemeris_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ephemeris_id = Some(input.into());
            self
        }
        /// <p>The AWS Ground Station ephemeris ID.</p>
        pub fn set_ephemeris_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ephemeris_id = input;
            self
        }
        /// <p>The status of the ephemeris.</p>
        pub fn status(mut self, input: crate::model::EphemerisStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the ephemeris.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::EphemerisStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Customer-provided priority score to establish the order in which overlapping ephemerides should be used.</p>
        /// <p>The default for customer-provided ephemeris priority is 1, and higher numbers take precedence.</p>
        /// <p>Priority must be 1 or greater</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        /// <p>Customer-provided priority score to establish the order in which overlapping ephemerides should be used.</p>
        /// <p>The default for customer-provided ephemeris priority is 1, and higher numbers take precedence.</p>
        /// <p>Priority must be 1 or greater</p>
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        /// <p>Whether or not the ephemeris is enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Whether or not the ephemeris is enabled.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The time the ephemeris was uploaded in UTC.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time the ephemeris was uploaded in UTC.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Source S3 object used for the ephemeris.</p>
        pub fn source_s3_object(mut self, input: crate::model::S3Object) -> Self {
            self.source_s3_object = Some(input);
            self
        }
        /// <p>Source S3 object used for the ephemeris.</p>
        pub fn set_source_s3_object(
            mut self,
            input: std::option::Option<crate::model::S3Object>,
        ) -> Self {
            self.source_s3_object = input;
            self
        }
        /// Consumes the builder and constructs a [`EphemerisItem`](crate::model::EphemerisItem).
        pub fn build(self) -> crate::model::EphemerisItem {
            crate::model::EphemerisItem {
                ephemeris_id: self.ephemeris_id,
                status: self.status,
                priority: self.priority,
                enabled: self.enabled,
                creation_time: self.creation_time,
                name: self.name,
                source_s3_object: self.source_s3_object,
            }
        }
    }
}
impl EphemerisItem {
    /// Creates a new builder-style object to manufacture [`EphemerisItem`](crate::model::EphemerisItem).
    pub fn builder() -> crate::model::ephemeris_item::Builder {
        crate::model::ephemeris_item::Builder::default()
    }
}

/// <p>Object stored in S3 containing ephemeris data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3Object {
    /// <p>An Amazon S3 Bucket name.</p>
    #[doc(hidden)]
    pub bucket: std::option::Option<std::string::String>,
    /// <p>An Amazon S3 key for the ephemeris.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>For versioned S3 objects, the version to use for the ephemeris.</p>
    #[doc(hidden)]
    pub version: std::option::Option<std::string::String>,
}
impl S3Object {
    /// <p>An Amazon S3 Bucket name.</p>
    pub fn bucket(&self) -> std::option::Option<&str> {
        self.bucket.as_deref()
    }
    /// <p>An Amazon S3 key for the ephemeris.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>For versioned S3 objects, the version to use for the ephemeris.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
}
/// See [`S3Object`](crate::model::S3Object).
pub mod s3_object {

    /// A builder for [`S3Object`](crate::model::S3Object).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An Amazon S3 Bucket name.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        /// <p>An Amazon S3 Bucket name.</p>
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>An Amazon S3 key for the ephemeris.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>An Amazon S3 key for the ephemeris.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>For versioned S3 objects, the version to use for the ephemeris.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>For versioned S3 objects, the version to use for the ephemeris.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`S3Object`](crate::model::S3Object).
        pub fn build(self) -> crate::model::S3Object {
            crate::model::S3Object {
                bucket: self.bucket,
                key: self.key,
                version: self.version,
            }
        }
    }
}
impl S3Object {
    /// Creates a new builder-style object to manufacture [`S3Object`](crate::model::S3Object).
    pub fn builder() -> crate::model::s3_object::Builder {
        crate::model::s3_object::Builder::default()
    }
}

/// When writing a match expression against `EphemerisStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let ephemerisstatus = unimplemented!();
/// match ephemerisstatus {
///     EphemerisStatus::Disabled => { /* ... */ },
///     EphemerisStatus::Enabled => { /* ... */ },
///     EphemerisStatus::Error => { /* ... */ },
///     EphemerisStatus::Expired => { /* ... */ },
///     EphemerisStatus::Invalid => { /* ... */ },
///     EphemerisStatus::Validating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `ephemerisstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EphemerisStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EphemerisStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EphemerisStatus::NewFeature` is defined.
/// Specifically, when `ephemerisstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EphemerisStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EphemerisStatus {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Expired,
    #[allow(missing_docs)] // documentation missing in model
    Invalid,
    #[allow(missing_docs)] // documentation missing in model
    Validating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EphemerisStatus {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => EphemerisStatus::Disabled,
            "ENABLED" => EphemerisStatus::Enabled,
            "ERROR" => EphemerisStatus::Error,
            "EXPIRED" => EphemerisStatus::Expired,
            "INVALID" => EphemerisStatus::Invalid,
            "VALIDATING" => EphemerisStatus::Validating,
            other => EphemerisStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EphemerisStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EphemerisStatus::from(s))
    }
}
impl EphemerisStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EphemerisStatus::Disabled => "DISABLED",
            EphemerisStatus::Enabled => "ENABLED",
            EphemerisStatus::Error => "ERROR",
            EphemerisStatus::Expired => "EXPIRED",
            EphemerisStatus::Invalid => "INVALID",
            EphemerisStatus::Validating => "VALIDATING",
            EphemerisStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DISABLED",
            "ENABLED",
            "ERROR",
            "EXPIRED",
            "INVALID",
            "VALIDATING",
        ]
    }
}
impl AsRef<str> for EphemerisStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Ephemeris data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum EphemerisData {
    /// <p>Ephemeris data in Orbit Ephemeris Message (OEM) format.</p>
    Oem(crate::model::OemEphemeris),
    /// <p>Two-line element set (TLE) ephemeris.</p>
    Tle(crate::model::TleEphemeris),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl EphemerisData {
    /// Tries to convert the enum instance into [`Oem`](crate::model::EphemerisData::Oem), extracting the inner [`OemEphemeris`](crate::model::OemEphemeris).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_oem(&self) -> std::result::Result<&crate::model::OemEphemeris, &Self> {
        if let EphemerisData::Oem(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Oem`](crate::model::EphemerisData::Oem).
    pub fn is_oem(&self) -> bool {
        self.as_oem().is_ok()
    }
    /// Tries to convert the enum instance into [`Tle`](crate::model::EphemerisData::Tle), extracting the inner [`TleEphemeris`](crate::model::TleEphemeris).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_tle(&self) -> std::result::Result<&crate::model::TleEphemeris, &Self> {
        if let EphemerisData::Tle(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Tle`](crate::model::EphemerisData::Tle).
    pub fn is_tle(&self) -> bool {
        self.as_tle().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Ephemeris data in Orbit Ephemeris Message (OEM) format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OemEphemeris {
    /// <p>Identifies the S3 object to be used as the ephemeris.</p>
    #[doc(hidden)]
    pub s3_object: std::option::Option<crate::model::S3Object>,
    /// <p>The data for an OEM ephemeris, supplied directly in the request rather than through an S3 object.</p>
    #[doc(hidden)]
    pub oem_data: std::option::Option<std::string::String>,
}
impl OemEphemeris {
    /// <p>Identifies the S3 object to be used as the ephemeris.</p>
    pub fn s3_object(&self) -> std::option::Option<&crate::model::S3Object> {
        self.s3_object.as_ref()
    }
    /// <p>The data for an OEM ephemeris, supplied directly in the request rather than through an S3 object.</p>
    pub fn oem_data(&self) -> std::option::Option<&str> {
        self.oem_data.as_deref()
    }
}
/// See [`OemEphemeris`](crate::model::OemEphemeris).
pub mod oem_ephemeris {

    /// A builder for [`OemEphemeris`](crate::model::OemEphemeris).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_object: std::option::Option<crate::model::S3Object>,
        pub(crate) oem_data: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Identifies the S3 object to be used as the ephemeris.</p>
        pub fn s3_object(mut self, input: crate::model::S3Object) -> Self {
            self.s3_object = Some(input);
            self
        }
        /// <p>Identifies the S3 object to be used as the ephemeris.</p>
        pub fn set_s3_object(mut self, input: std::option::Option<crate::model::S3Object>) -> Self {
            self.s3_object = input;
            self
        }
        /// <p>The data for an OEM ephemeris, supplied directly in the request rather than through an S3 object.</p>
        pub fn oem_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.oem_data = Some(input.into());
            self
        }
        /// <p>The data for an OEM ephemeris, supplied directly in the request rather than through an S3 object.</p>
        pub fn set_oem_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.oem_data = input;
            self
        }
        /// Consumes the builder and constructs a [`OemEphemeris`](crate::model::OemEphemeris).
        pub fn build(self) -> crate::model::OemEphemeris {
            crate::model::OemEphemeris {
                s3_object: self.s3_object,
                oem_data: self.oem_data,
            }
        }
    }
}
impl OemEphemeris {
    /// Creates a new builder-style object to manufacture [`OemEphemeris`](crate::model::OemEphemeris).
    pub fn builder() -> crate::model::oem_ephemeris::Builder {
        crate::model::oem_ephemeris::Builder::default()
    }
}

/// <p>Two-line element set (TLE) ephemeris.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TleEphemeris {
    /// <p>Identifies the S3 object to be used as the ephemeris.</p>
    #[doc(hidden)]
    pub s3_object: std::option::Option<crate::model::S3Object>,
    /// <p>The data for a TLE ephemeris, supplied directly in the request rather than through an S3 object.</p>
    #[doc(hidden)]
    pub tle_data: std::option::Option<std::vec::Vec<crate::model::TleData>>,
}
impl TleEphemeris {
    /// <p>Identifies the S3 object to be used as the ephemeris.</p>
    pub fn s3_object(&self) -> std::option::Option<&crate::model::S3Object> {
        self.s3_object.as_ref()
    }
    /// <p>The data for a TLE ephemeris, supplied directly in the request rather than through an S3 object.</p>
    pub fn tle_data(&self) -> std::option::Option<&[crate::model::TleData]> {
        self.tle_data.as_deref()
    }
}
/// See [`TleEphemeris`](crate::model::TleEphemeris).
pub mod tle_ephemeris {

    /// A builder for [`TleEphemeris`](crate::model::TleEphemeris).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_object: std::option::Option<crate::model::S3Object>,
        pub(crate) tle_data: std::option::Option<std::vec::Vec<crate::model::TleData>>,
    }
    impl Builder {
        /// <p>Identifies the S3 object to be used as the ephemeris.</p>
        pub fn s3_object(mut self, input: crate::model::S3Object) -> Self {
            self.s3_object = Some(input);
            self
        }
        /// <p>Identifies the S3 object to be used as the ephemeris.</p>
        pub fn set_s3_object(mut self, input: std::option::Option<crate::model::S3Object>) -> Self {
            self.s3_object = input;
            self
        }
        /// Appends an item to `tle_data`.
        ///
        /// To override the contents of this collection use [`set_tle_data`](Self::set_tle_data).
        ///
        /// <p>The data for a TLE ephemeris, supplied directly in the request rather than through an S3 object.</p>
        pub fn tle_data(mut self, input: crate::model::TleData) -> Self {
            let mut v = self.tle_data.unwrap_or_default();
            v.push(input);
            self.tle_data = Some(v);
            self
        }
        /// <p>The data for a TLE ephemeris, supplied directly in the request rather than through an S3 object.</p>
        pub fn set_tle_data(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TleData>>,
        ) -> Self {
            self.tle_data = input;
            self
        }
        /// Consumes the builder and constructs a [`TleEphemeris`](crate::model::TleEphemeris).
        pub fn build(self) -> crate::model::TleEphemeris {
            crate::model::TleEphemeris {
                s3_object: self.s3_object,
                tle_data: self.tle_data,
            }
        }
    }
}
impl TleEphemeris {
    /// Creates a new builder-style object to manufacture [`TleEphemeris`](crate::model::TleEphemeris).
    pub fn builder() -> crate::model::tle_ephemeris::Builder {
        crate::model::tle_ephemeris::Builder::default()
    }
}

/// <p>Two-line element set (TLE) data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TleData {
    /// <p>First line of two-line element set (TLE) data.</p>
    #[doc(hidden)]
    pub tle_line1: std::option::Option<std::string::String>,
    /// <p>Second line of two-line element set (TLE) data.</p>
    #[doc(hidden)]
    pub tle_line2: std::option::Option<std::string::String>,
    /// <p>The valid time range for the TLE. Gaps or overlap are not permitted.</p>
    #[doc(hidden)]
    pub valid_time_range: std::option::Option<crate::model::TimeRange>,
}
impl TleData {
    /// <p>First line of two-line element set (TLE) data.</p>
    pub fn tle_line1(&self) -> std::option::Option<&str> {
        self.tle_line1.as_deref()
    }
    /// <p>Second line of two-line element set (TLE) data.</p>
    pub fn tle_line2(&self) -> std::option::Option<&str> {
        self.tle_line2.as_deref()
    }
    /// <p>The valid time range for the TLE. Gaps or overlap are not permitted.</p>
    pub fn valid_time_range(&self) -> std::option::Option<&crate::model::TimeRange> {
        self.valid_time_range.as_ref()
    }
}
/// See [`TleData`](crate::model::TleData).
pub mod tle_data {

    /// A builder for [`TleData`](crate::model::TleData).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tle_line1: std::option::Option<std::string::String>,
        pub(crate) tle_line2: std::option::Option<std::string::String>,
        pub(crate) valid_time_range: std::option::Option<crate::model::TimeRange>,
    }
    impl Builder {
        /// <p>First line of two-line element set (TLE) data.</p>
        pub fn tle_line1(mut self, input: impl Into<std::string::String>) -> Self {
            self.tle_line1 = Some(input.into());
            self
        }
        /// <p>First line of two-line element set (TLE) data.</p>
        pub fn set_tle_line1(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tle_line1 = input;
            self
        }
        /// <p>Second line of two-line element set (TLE) data.</p>
        pub fn tle_line2(mut self, input: impl Into<std::string::String>) -> Self {
            self.tle_line2 = Some(input.into());
            self
        }
        /// <p>Second line of two-line element set (TLE) data.</p>
        pub fn set_tle_line2(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tle_line2 = input;
            self
        }
        /// <p>The valid time range for the TLE. Gaps or overlap are not permitted.</p>
        pub fn valid_time_range(mut self, input: crate::model::TimeRange) -> Self {
            self.valid_time_range = Some(input);
            self
        }
        /// <p>The valid time range for the TLE. Gaps or overlap are not permitted.</p>
        pub fn set_valid_time_range(
            mut self,
            input: std::option::Option<crate::model::TimeRange>,
        ) -> Self {
            self.valid_time_range = input;
            self
        }
        /// Consumes the builder and constructs a [`TleData`](crate::model::TleData).
        pub fn build(self) -> crate::model::TleData {
            crate::model::TleData {
                tle_line1: self.tle_line1,
                tle_line2: self.tle_line2,
                valid_time_range: self.valid_time_range,
            }
        }
    }
}
impl TleData {
    /// Creates a new builder-style object to manufacture [`TleData`](crate::model::TleData).
    pub fn builder() -> crate::model::tle_data::Builder {
        crate::model::tle_data::Builder::default()
    }
}

/// <p>A time range with a start and end time.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TimeRange {
    /// <p>Time in UTC at which the time range starts.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Time in UTC at which the time range ends.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl TimeRange {
    /// <p>Time in UTC at which the time range starts.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>Time in UTC at which the time range ends.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
}
/// See [`TimeRange`](crate::model::TimeRange).
pub mod time_range {

    /// A builder for [`TimeRange`](crate::model::TimeRange).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Time in UTC at which the time range starts.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>Time in UTC at which the time range starts.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>Time in UTC at which the time range ends.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>Time in UTC at which the time range ends.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// Consumes the builder and constructs a [`TimeRange`](crate::model::TimeRange).
        pub fn build(self) -> crate::model::TimeRange {
            crate::model::TimeRange {
                start_time: self.start_time,
                end_time: self.end_time,
            }
        }
    }
}
impl TimeRange {
    /// Creates a new builder-style object to manufacture [`TimeRange`](crate::model::TimeRange).
    pub fn builder() -> crate::model::time_range::Builder {
        crate::model::time_range::Builder::default()
    }
}

/// When writing a match expression against `EphemerisInvalidReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let ephemerisinvalidreason = unimplemented!();
/// match ephemerisinvalidreason {
///     EphemerisInvalidReason::KmsKeyInvalid => { /* ... */ },
///     EphemerisInvalidReason::MetadataInvalid => { /* ... */ },
///     EphemerisInvalidReason::TimeRangeInvalid => { /* ... */ },
///     EphemerisInvalidReason::TrajectoryInvalid => { /* ... */ },
///     EphemerisInvalidReason::ValidationError => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `ephemerisinvalidreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EphemerisInvalidReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EphemerisInvalidReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EphemerisInvalidReason::NewFeature` is defined.
/// Specifically, when `ephemerisinvalidreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EphemerisInvalidReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EphemerisInvalidReason {
    /// Provided KMS key is invalid
    KmsKeyInvalid,
    /// Provided spacecraft identifiers such as spacecraft NORAD Id are invalid
    MetadataInvalid,
    /// Start, end, or expiration time(s) are invalid for the provided ephemeris
    TimeRangeInvalid,
    /// Provided ephemeris defines invalid spacecraft trajectory
    TrajectoryInvalid,
    /// Internal Service Error occurred while processing ephemeris
    ValidationError,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EphemerisInvalidReason {
    fn from(s: &str) -> Self {
        match s {
            "KMS_KEY_INVALID" => EphemerisInvalidReason::KmsKeyInvalid,
            "METADATA_INVALID" => EphemerisInvalidReason::MetadataInvalid,
            "TIME_RANGE_INVALID" => EphemerisInvalidReason::TimeRangeInvalid,
            "TRAJECTORY_INVALID" => EphemerisInvalidReason::TrajectoryInvalid,
            "VALIDATION_ERROR" => EphemerisInvalidReason::ValidationError,
            other => {
                EphemerisInvalidReason::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for EphemerisInvalidReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EphemerisInvalidReason::from(s))
    }
}
impl EphemerisInvalidReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EphemerisInvalidReason::KmsKeyInvalid => "KMS_KEY_INVALID",
            EphemerisInvalidReason::MetadataInvalid => "METADATA_INVALID",
            EphemerisInvalidReason::TimeRangeInvalid => "TIME_RANGE_INVALID",
            EphemerisInvalidReason::TrajectoryInvalid => "TRAJECTORY_INVALID",
            EphemerisInvalidReason::ValidationError => "VALIDATION_ERROR",
            EphemerisInvalidReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "KMS_KEY_INVALID",
            "METADATA_INVALID",
            "TIME_RANGE_INVALID",
            "TRAJECTORY_INVALID",
            "VALIDATION_ERROR",
        ]
    }
}
impl AsRef<str> for EphemerisInvalidReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum EphemerisTypeDescription {
    /// <p>Description of ephemeris.</p>
    Oem(crate::model::EphemerisDescription),
    /// <p>Description of ephemeris.</p>
    Tle(crate::model::EphemerisDescription),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl EphemerisTypeDescription {
    /// Tries to convert the enum instance into [`Oem`](crate::model::EphemerisTypeDescription::Oem), extracting the inner [`EphemerisDescription`](crate::model::EphemerisDescription).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_oem(&self) -> std::result::Result<&crate::model::EphemerisDescription, &Self> {
        if let EphemerisTypeDescription::Oem(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Oem`](crate::model::EphemerisTypeDescription::Oem).
    pub fn is_oem(&self) -> bool {
        self.as_oem().is_ok()
    }
    /// Tries to convert the enum instance into [`Tle`](crate::model::EphemerisTypeDescription::Tle), extracting the inner [`EphemerisDescription`](crate::model::EphemerisDescription).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_tle(&self) -> std::result::Result<&crate::model::EphemerisDescription, &Self> {
        if let EphemerisTypeDescription::Tle(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Tle`](crate::model::EphemerisTypeDescription::Tle).
    pub fn is_tle(&self) -> bool {
        self.as_tle().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Description of ephemeris.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EphemerisDescription {
    /// <p>Source S3 object used for the ephemeris.</p>
    #[doc(hidden)]
    pub source_s3_object: std::option::Option<crate::model::S3Object>,
    /// <p>Supplied ephemeris data.</p>
    #[doc(hidden)]
    pub ephemeris_data: std::option::Option<std::string::String>,
}
impl EphemerisDescription {
    /// <p>Source S3 object used for the ephemeris.</p>
    pub fn source_s3_object(&self) -> std::option::Option<&crate::model::S3Object> {
        self.source_s3_object.as_ref()
    }
    /// <p>Supplied ephemeris data.</p>
    pub fn ephemeris_data(&self) -> std::option::Option<&str> {
        self.ephemeris_data.as_deref()
    }
}
/// See [`EphemerisDescription`](crate::model::EphemerisDescription).
pub mod ephemeris_description {

    /// A builder for [`EphemerisDescription`](crate::model::EphemerisDescription).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_s3_object: std::option::Option<crate::model::S3Object>,
        pub(crate) ephemeris_data: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Source S3 object used for the ephemeris.</p>
        pub fn source_s3_object(mut self, input: crate::model::S3Object) -> Self {
            self.source_s3_object = Some(input);
            self
        }
        /// <p>Source S3 object used for the ephemeris.</p>
        pub fn set_source_s3_object(
            mut self,
            input: std::option::Option<crate::model::S3Object>,
        ) -> Self {
            self.source_s3_object = input;
            self
        }
        /// <p>Supplied ephemeris data.</p>
        pub fn ephemeris_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.ephemeris_data = Some(input.into());
            self
        }
        /// <p>Supplied ephemeris data.</p>
        pub fn set_ephemeris_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ephemeris_data = input;
            self
        }
        /// Consumes the builder and constructs a [`EphemerisDescription`](crate::model::EphemerisDescription).
        pub fn build(self) -> crate::model::EphemerisDescription {
            crate::model::EphemerisDescription {
                source_s3_object: self.source_s3_object,
                ephemeris_data: self.ephemeris_data,
            }
        }
    }
}
impl EphemerisDescription {
    /// Creates a new builder-style object to manufacture [`EphemerisDescription`](crate::model::EphemerisDescription).
    pub fn builder() -> crate::model::ephemeris_description::Builder {
        crate::model::ephemeris_description::Builder::default()
    }
}

/// <p>Item in a list of <code>DataflowEndpoint</code> groups.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataflowEndpointListItem {
    /// <p>UUID of a dataflow endpoint group.</p>
    #[doc(hidden)]
    pub dataflow_endpoint_group_id: std::option::Option<std::string::String>,
    /// <p>ARN of a dataflow endpoint group.</p>
    #[doc(hidden)]
    pub dataflow_endpoint_group_arn: std::option::Option<std::string::String>,
}
impl DataflowEndpointListItem {
    /// <p>UUID of a dataflow endpoint group.</p>
    pub fn dataflow_endpoint_group_id(&self) -> std::option::Option<&str> {
        self.dataflow_endpoint_group_id.as_deref()
    }
    /// <p>ARN of a dataflow endpoint group.</p>
    pub fn dataflow_endpoint_group_arn(&self) -> std::option::Option<&str> {
        self.dataflow_endpoint_group_arn.as_deref()
    }
}
/// See [`DataflowEndpointListItem`](crate::model::DataflowEndpointListItem).
pub mod dataflow_endpoint_list_item {

    /// A builder for [`DataflowEndpointListItem`](crate::model::DataflowEndpointListItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dataflow_endpoint_group_id: std::option::Option<std::string::String>,
        pub(crate) dataflow_endpoint_group_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>UUID of a dataflow endpoint group.</p>
        pub fn dataflow_endpoint_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.dataflow_endpoint_group_id = Some(input.into());
            self
        }
        /// <p>UUID of a dataflow endpoint group.</p>
        pub fn set_dataflow_endpoint_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dataflow_endpoint_group_id = input;
            self
        }
        /// <p>ARN of a dataflow endpoint group.</p>
        pub fn dataflow_endpoint_group_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.dataflow_endpoint_group_arn = Some(input.into());
            self
        }
        /// <p>ARN of a dataflow endpoint group.</p>
        pub fn set_dataflow_endpoint_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dataflow_endpoint_group_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DataflowEndpointListItem`](crate::model::DataflowEndpointListItem).
        pub fn build(self) -> crate::model::DataflowEndpointListItem {
            crate::model::DataflowEndpointListItem {
                dataflow_endpoint_group_id: self.dataflow_endpoint_group_id,
                dataflow_endpoint_group_arn: self.dataflow_endpoint_group_arn,
            }
        }
    }
}
impl DataflowEndpointListItem {
    /// Creates a new builder-style object to manufacture [`DataflowEndpointListItem`](crate::model::DataflowEndpointListItem).
    pub fn builder() -> crate::model::dataflow_endpoint_list_item::Builder {
        crate::model::dataflow_endpoint_list_item::Builder::default()
    }
}

/// <p>Information about the endpoint details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EndpointDetails {
    /// <p>Endpoint security details including a list of subnets, a list of security groups and a role to connect streams to instances.</p>
    #[doc(hidden)]
    pub security_details: std::option::Option<crate::model::SecurityDetails>,
    /// <p>A dataflow endpoint.</p>
    #[doc(hidden)]
    pub endpoint: std::option::Option<crate::model::DataflowEndpoint>,
}
impl EndpointDetails {
    /// <p>Endpoint security details including a list of subnets, a list of security groups and a role to connect streams to instances.</p>
    pub fn security_details(&self) -> std::option::Option<&crate::model::SecurityDetails> {
        self.security_details.as_ref()
    }
    /// <p>A dataflow endpoint.</p>
    pub fn endpoint(&self) -> std::option::Option<&crate::model::DataflowEndpoint> {
        self.endpoint.as_ref()
    }
}
/// See [`EndpointDetails`](crate::model::EndpointDetails).
pub mod endpoint_details {

    /// A builder for [`EndpointDetails`](crate::model::EndpointDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_details: std::option::Option<crate::model::SecurityDetails>,
        pub(crate) endpoint: std::option::Option<crate::model::DataflowEndpoint>,
    }
    impl Builder {
        /// <p>Endpoint security details including a list of subnets, a list of security groups and a role to connect streams to instances.</p>
        pub fn security_details(mut self, input: crate::model::SecurityDetails) -> Self {
            self.security_details = Some(input);
            self
        }
        /// <p>Endpoint security details including a list of subnets, a list of security groups and a role to connect streams to instances.</p>
        pub fn set_security_details(
            mut self,
            input: std::option::Option<crate::model::SecurityDetails>,
        ) -> Self {
            self.security_details = input;
            self
        }
        /// <p>A dataflow endpoint.</p>
        pub fn endpoint(mut self, input: crate::model::DataflowEndpoint) -> Self {
            self.endpoint = Some(input);
            self
        }
        /// <p>A dataflow endpoint.</p>
        pub fn set_endpoint(
            mut self,
            input: std::option::Option<crate::model::DataflowEndpoint>,
        ) -> Self {
            self.endpoint = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointDetails`](crate::model::EndpointDetails).
        pub fn build(self) -> crate::model::EndpointDetails {
            crate::model::EndpointDetails {
                security_details: self.security_details,
                endpoint: self.endpoint,
            }
        }
    }
}
impl EndpointDetails {
    /// Creates a new builder-style object to manufacture [`EndpointDetails`](crate::model::EndpointDetails).
    pub fn builder() -> crate::model::endpoint_details::Builder {
        crate::model::endpoint_details::Builder::default()
    }
}

/// <p>Information about a dataflow endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataflowEndpoint {
    /// <p>Name of a dataflow endpoint.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Socket address of a dataflow endpoint.</p>
    #[doc(hidden)]
    pub address: std::option::Option<crate::model::SocketAddress>,
    /// <p>Status of a dataflow endpoint.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::EndpointStatus>,
    /// <p>Maximum transmission unit (MTU) size in bytes of a dataflow endpoint.</p>
    #[doc(hidden)]
    pub mtu: std::option::Option<i32>,
}
impl DataflowEndpoint {
    /// <p>Name of a dataflow endpoint.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Socket address of a dataflow endpoint.</p>
    pub fn address(&self) -> std::option::Option<&crate::model::SocketAddress> {
        self.address.as_ref()
    }
    /// <p>Status of a dataflow endpoint.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::EndpointStatus> {
        self.status.as_ref()
    }
    /// <p>Maximum transmission unit (MTU) size in bytes of a dataflow endpoint.</p>
    pub fn mtu(&self) -> std::option::Option<i32> {
        self.mtu
    }
}
/// See [`DataflowEndpoint`](crate::model::DataflowEndpoint).
pub mod dataflow_endpoint {

    /// A builder for [`DataflowEndpoint`](crate::model::DataflowEndpoint).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) address: std::option::Option<crate::model::SocketAddress>,
        pub(crate) status: std::option::Option<crate::model::EndpointStatus>,
        pub(crate) mtu: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Name of a dataflow endpoint.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Name of a dataflow endpoint.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Socket address of a dataflow endpoint.</p>
        pub fn address(mut self, input: crate::model::SocketAddress) -> Self {
            self.address = Some(input);
            self
        }
        /// <p>Socket address of a dataflow endpoint.</p>
        pub fn set_address(
            mut self,
            input: std::option::Option<crate::model::SocketAddress>,
        ) -> Self {
            self.address = input;
            self
        }
        /// <p>Status of a dataflow endpoint.</p>
        pub fn status(mut self, input: crate::model::EndpointStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Status of a dataflow endpoint.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::EndpointStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Maximum transmission unit (MTU) size in bytes of a dataflow endpoint.</p>
        pub fn mtu(mut self, input: i32) -> Self {
            self.mtu = Some(input);
            self
        }
        /// <p>Maximum transmission unit (MTU) size in bytes of a dataflow endpoint.</p>
        pub fn set_mtu(mut self, input: std::option::Option<i32>) -> Self {
            self.mtu = input;
            self
        }
        /// Consumes the builder and constructs a [`DataflowEndpoint`](crate::model::DataflowEndpoint).
        pub fn build(self) -> crate::model::DataflowEndpoint {
            crate::model::DataflowEndpoint {
                name: self.name,
                address: self.address,
                status: self.status,
                mtu: self.mtu,
            }
        }
    }
}
impl DataflowEndpoint {
    /// Creates a new builder-style object to manufacture [`DataflowEndpoint`](crate::model::DataflowEndpoint).
    pub fn builder() -> crate::model::dataflow_endpoint::Builder {
        crate::model::dataflow_endpoint::Builder::default()
    }
}

/// When writing a match expression against `EndpointStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let endpointstatus = unimplemented!();
/// match endpointstatus {
///     EndpointStatus::Created => { /* ... */ },
///     EndpointStatus::Creating => { /* ... */ },
///     EndpointStatus::Deleted => { /* ... */ },
///     EndpointStatus::Deleting => { /* ... */ },
///     EndpointStatus::Failed => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `endpointstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EndpointStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EndpointStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EndpointStatus::NewFeature` is defined.
/// Specifically, when `endpointstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EndpointStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EndpointStatus {
    #[allow(missing_docs)] // documentation missing in model
    Created,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EndpointStatus {
    fn from(s: &str) -> Self {
        match s {
            "created" => EndpointStatus::Created,
            "creating" => EndpointStatus::Creating,
            "deleted" => EndpointStatus::Deleted,
            "deleting" => EndpointStatus::Deleting,
            "failed" => EndpointStatus::Failed,
            other => EndpointStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EndpointStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EndpointStatus::from(s))
    }
}
impl EndpointStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EndpointStatus::Created => "created",
            EndpointStatus::Creating => "creating",
            EndpointStatus::Deleted => "deleted",
            EndpointStatus::Deleting => "deleting",
            EndpointStatus::Failed => "failed",
            EndpointStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["created", "creating", "deleted", "deleting", "failed"]
    }
}
impl AsRef<str> for EndpointStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the socket address.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SocketAddress {
    /// <p>Name of a socket address.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Port of a socket address.</p>
    #[doc(hidden)]
    pub port: std::option::Option<i32>,
}
impl SocketAddress {
    /// <p>Name of a socket address.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Port of a socket address.</p>
    pub fn port(&self) -> std::option::Option<i32> {
        self.port
    }
}
/// See [`SocketAddress`](crate::model::SocketAddress).
pub mod socket_address {

    /// A builder for [`SocketAddress`](crate::model::SocketAddress).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Name of a socket address.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Name of a socket address.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Port of a socket address.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>Port of a socket address.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// Consumes the builder and constructs a [`SocketAddress`](crate::model::SocketAddress).
        pub fn build(self) -> crate::model::SocketAddress {
            crate::model::SocketAddress {
                name: self.name,
                port: self.port,
            }
        }
    }
}
impl SocketAddress {
    /// Creates a new builder-style object to manufacture [`SocketAddress`](crate::model::SocketAddress).
    pub fn builder() -> crate::model::socket_address::Builder {
        crate::model::socket_address::Builder::default()
    }
}

/// <p>Information about endpoints.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SecurityDetails {
    /// <p>A list of subnets where AWS Ground Station places elastic network interfaces to send streams to your instances.</p>
    #[doc(hidden)]
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The security groups to attach to the elastic network interfaces.</p>
    #[doc(hidden)]
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>ARN to a role needed for connecting streams to your instances. </p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
}
impl SecurityDetails {
    /// <p>A list of subnets where AWS Ground Station places elastic network interfaces to send streams to your instances.</p>
    pub fn subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_ids.as_deref()
    }
    /// <p>The security groups to attach to the elastic network interfaces.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
    /// <p>ARN to a role needed for connecting streams to your instances. </p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
}
/// See [`SecurityDetails`](crate::model::SecurityDetails).
pub mod security_details {

    /// A builder for [`SecurityDetails`](crate::model::SecurityDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `subnet_ids`.
        ///
        /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
        ///
        /// <p>A list of subnets where AWS Ground Station places elastic network interfaces to send streams to your instances.</p>
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        /// <p>A list of subnets where AWS Ground Station places elastic network interfaces to send streams to your instances.</p>
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        /// Appends an item to `security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
        ///
        /// <p>The security groups to attach to the elastic network interfaces.</p>
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        /// <p>The security groups to attach to the elastic network interfaces.</p>
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// <p>ARN to a role needed for connecting streams to your instances. </p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>ARN to a role needed for connecting streams to your instances. </p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`SecurityDetails`](crate::model::SecurityDetails).
        pub fn build(self) -> crate::model::SecurityDetails {
            crate::model::SecurityDetails {
                subnet_ids: self.subnet_ids,
                security_group_ids: self.security_group_ids,
                role_arn: self.role_arn,
            }
        }
    }
}
impl SecurityDetails {
    /// Creates a new builder-style object to manufacture [`SecurityDetails`](crate::model::SecurityDetails).
    pub fn builder() -> crate::model::security_details::Builder {
        crate::model::security_details::Builder::default()
    }
}

/// <p>Data describing a contact.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ContactData {
    /// <p>UUID of a contact.</p>
    #[doc(hidden)]
    pub contact_id: std::option::Option<std::string::String>,
    /// <p>ARN of a mission profile.</p>
    #[doc(hidden)]
    pub mission_profile_arn: std::option::Option<std::string::String>,
    /// <p>ARN of a satellite.</p>
    #[doc(hidden)]
    pub satellite_arn: std::option::Option<std::string::String>,
    /// <p>Start time of a contact in UTC.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>End time of a contact in UTC.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.</p>
    #[doc(hidden)]
    pub pre_pass_start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.</p>
    #[doc(hidden)]
    pub post_pass_end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Name of a ground station.</p>
    #[doc(hidden)]
    pub ground_station: std::option::Option<std::string::String>,
    /// <p>Status of a contact.</p>
    #[doc(hidden)]
    pub contact_status: std::option::Option<crate::model::ContactStatus>,
    /// <p>Error message of a contact.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>Maximum elevation angle of a contact.</p>
    #[doc(hidden)]
    pub maximum_elevation: std::option::Option<crate::model::Elevation>,
    /// <p>Region of a contact.</p>
    #[doc(hidden)]
    pub region: std::option::Option<std::string::String>,
    /// <p>Tags assigned to a contact.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl ContactData {
    /// <p>UUID of a contact.</p>
    pub fn contact_id(&self) -> std::option::Option<&str> {
        self.contact_id.as_deref()
    }
    /// <p>ARN of a mission profile.</p>
    pub fn mission_profile_arn(&self) -> std::option::Option<&str> {
        self.mission_profile_arn.as_deref()
    }
    /// <p>ARN of a satellite.</p>
    pub fn satellite_arn(&self) -> std::option::Option<&str> {
        self.satellite_arn.as_deref()
    }
    /// <p>Start time of a contact in UTC.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>End time of a contact in UTC.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.</p>
    pub fn pre_pass_start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.pre_pass_start_time.as_ref()
    }
    /// <p>Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.</p>
    pub fn post_pass_end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.post_pass_end_time.as_ref()
    }
    /// <p>Name of a ground station.</p>
    pub fn ground_station(&self) -> std::option::Option<&str> {
        self.ground_station.as_deref()
    }
    /// <p>Status of a contact.</p>
    pub fn contact_status(&self) -> std::option::Option<&crate::model::ContactStatus> {
        self.contact_status.as_ref()
    }
    /// <p>Error message of a contact.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>Maximum elevation angle of a contact.</p>
    pub fn maximum_elevation(&self) -> std::option::Option<&crate::model::Elevation> {
        self.maximum_elevation.as_ref()
    }
    /// <p>Region of a contact.</p>
    pub fn region(&self) -> std::option::Option<&str> {
        self.region.as_deref()
    }
    /// <p>Tags assigned to a contact.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
/// See [`ContactData`](crate::model::ContactData).
pub mod contact_data {

    /// A builder for [`ContactData`](crate::model::ContactData).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) contact_id: std::option::Option<std::string::String>,
        pub(crate) mission_profile_arn: std::option::Option<std::string::String>,
        pub(crate) satellite_arn: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) pre_pass_start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) post_pass_end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) ground_station: std::option::Option<std::string::String>,
        pub(crate) contact_status: std::option::Option<crate::model::ContactStatus>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) maximum_elevation: std::option::Option<crate::model::Elevation>,
        pub(crate) region: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>UUID of a contact.</p>
        pub fn contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_id = Some(input.into());
            self
        }
        /// <p>UUID of a contact.</p>
        pub fn set_contact_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.contact_id = input;
            self
        }
        /// <p>ARN of a mission profile.</p>
        pub fn mission_profile_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.mission_profile_arn = Some(input.into());
            self
        }
        /// <p>ARN of a mission profile.</p>
        pub fn set_mission_profile_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.mission_profile_arn = input;
            self
        }
        /// <p>ARN of a satellite.</p>
        pub fn satellite_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.satellite_arn = Some(input.into());
            self
        }
        /// <p>ARN of a satellite.</p>
        pub fn set_satellite_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.satellite_arn = input;
            self
        }
        /// <p>Start time of a contact in UTC.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>Start time of a contact in UTC.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>End time of a contact in UTC.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>End time of a contact in UTC.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.</p>
        pub fn pre_pass_start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.pre_pass_start_time = Some(input);
            self
        }
        /// <p>Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.</p>
        pub fn set_pre_pass_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.pre_pass_start_time = input;
            self
        }
        /// <p>Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.</p>
        pub fn post_pass_end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.post_pass_end_time = Some(input);
            self
        }
        /// <p>Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.</p>
        pub fn set_post_pass_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.post_pass_end_time = input;
            self
        }
        /// <p>Name of a ground station.</p>
        pub fn ground_station(mut self, input: impl Into<std::string::String>) -> Self {
            self.ground_station = Some(input.into());
            self
        }
        /// <p>Name of a ground station.</p>
        pub fn set_ground_station(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ground_station = input;
            self
        }
        /// <p>Status of a contact.</p>
        pub fn contact_status(mut self, input: crate::model::ContactStatus) -> Self {
            self.contact_status = Some(input);
            self
        }
        /// <p>Status of a contact.</p>
        pub fn set_contact_status(
            mut self,
            input: std::option::Option<crate::model::ContactStatus>,
        ) -> Self {
            self.contact_status = input;
            self
        }
        /// <p>Error message of a contact.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>Error message of a contact.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>Maximum elevation angle of a contact.</p>
        pub fn maximum_elevation(mut self, input: crate::model::Elevation) -> Self {
            self.maximum_elevation = Some(input);
            self
        }
        /// <p>Maximum elevation angle of a contact.</p>
        pub fn set_maximum_elevation(
            mut self,
            input: std::option::Option<crate::model::Elevation>,
        ) -> Self {
            self.maximum_elevation = input;
            self
        }
        /// <p>Region of a contact.</p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        /// <p>Region of a contact.</p>
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Tags assigned to a contact.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>Tags assigned to a contact.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ContactData`](crate::model::ContactData).
        pub fn build(self) -> crate::model::ContactData {
            crate::model::ContactData {
                contact_id: self.contact_id,
                mission_profile_arn: self.mission_profile_arn,
                satellite_arn: self.satellite_arn,
                start_time: self.start_time,
                end_time: self.end_time,
                pre_pass_start_time: self.pre_pass_start_time,
                post_pass_end_time: self.post_pass_end_time,
                ground_station: self.ground_station,
                contact_status: self.contact_status,
                error_message: self.error_message,
                maximum_elevation: self.maximum_elevation,
                region: self.region,
                tags: self.tags,
            }
        }
    }
}
impl ContactData {
    /// Creates a new builder-style object to manufacture [`ContactData`](crate::model::ContactData).
    pub fn builder() -> crate::model::contact_data::Builder {
        crate::model::contact_data::Builder::default()
    }
}

/// <p>Elevation angle of the satellite in the sky during a contact.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Elevation {
    /// <p>Elevation angle value.</p>
    #[doc(hidden)]
    pub value: std::option::Option<f64>,
    /// <p>Elevation angle units.</p>
    #[doc(hidden)]
    pub unit: std::option::Option<crate::model::AngleUnits>,
}
impl Elevation {
    /// <p>Elevation angle value.</p>
    pub fn value(&self) -> std::option::Option<f64> {
        self.value
    }
    /// <p>Elevation angle units.</p>
    pub fn unit(&self) -> std::option::Option<&crate::model::AngleUnits> {
        self.unit.as_ref()
    }
}
/// See [`Elevation`](crate::model::Elevation).
pub mod elevation {

    /// A builder for [`Elevation`](crate::model::Elevation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<f64>,
        pub(crate) unit: std::option::Option<crate::model::AngleUnits>,
    }
    impl Builder {
        /// <p>Elevation angle value.</p>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>Elevation angle value.</p>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input;
            self
        }
        /// <p>Elevation angle units.</p>
        pub fn unit(mut self, input: crate::model::AngleUnits) -> Self {
            self.unit = Some(input);
            self
        }
        /// <p>Elevation angle units.</p>
        pub fn set_unit(mut self, input: std::option::Option<crate::model::AngleUnits>) -> Self {
            self.unit = input;
            self
        }
        /// Consumes the builder and constructs a [`Elevation`](crate::model::Elevation).
        pub fn build(self) -> crate::model::Elevation {
            crate::model::Elevation {
                value: self.value,
                unit: self.unit,
            }
        }
    }
}
impl Elevation {
    /// Creates a new builder-style object to manufacture [`Elevation`](crate::model::Elevation).
    pub fn builder() -> crate::model::elevation::Builder {
        crate::model::elevation::Builder::default()
    }
}

/// When writing a match expression against `AngleUnits`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let angleunits = unimplemented!();
/// match angleunits {
///     AngleUnits::DegreeAngle => { /* ... */ },
///     AngleUnits::Radian => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `angleunits` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AngleUnits::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AngleUnits::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AngleUnits::NewFeature` is defined.
/// Specifically, when `angleunits` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AngleUnits::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AngleUnits {
    #[allow(missing_docs)] // documentation missing in model
    DegreeAngle,
    #[allow(missing_docs)] // documentation missing in model
    Radian,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AngleUnits {
    fn from(s: &str) -> Self {
        match s {
            "DEGREE_ANGLE" => AngleUnits::DegreeAngle,
            "RADIAN" => AngleUnits::Radian,
            other => AngleUnits::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AngleUnits {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AngleUnits::from(s))
    }
}
impl AngleUnits {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AngleUnits::DegreeAngle => "DEGREE_ANGLE",
            AngleUnits::Radian => "RADIAN",
            AngleUnits::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DEGREE_ANGLE", "RADIAN"]
    }
}
impl AsRef<str> for AngleUnits {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ContactStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let contactstatus = unimplemented!();
/// match contactstatus {
///     ContactStatus::Available => { /* ... */ },
///     ContactStatus::AwsCancelled => { /* ... */ },
///     ContactStatus::AwsFailed => { /* ... */ },
///     ContactStatus::Cancelled => { /* ... */ },
///     ContactStatus::Cancelling => { /* ... */ },
///     ContactStatus::Completed => { /* ... */ },
///     ContactStatus::Failed => { /* ... */ },
///     ContactStatus::FailedToSchedule => { /* ... */ },
///     ContactStatus::Pass => { /* ... */ },
///     ContactStatus::Postpass => { /* ... */ },
///     ContactStatus::Prepass => { /* ... */ },
///     ContactStatus::Scheduled => { /* ... */ },
///     ContactStatus::Scheduling => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `contactstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ContactStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ContactStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ContactStatus::NewFeature` is defined.
/// Specifically, when `contactstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ContactStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContactStatus {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    AwsCancelled,
    #[allow(missing_docs)] // documentation missing in model
    AwsFailed,
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Cancelling,
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    FailedToSchedule,
    #[allow(missing_docs)] // documentation missing in model
    Pass,
    #[allow(missing_docs)] // documentation missing in model
    Postpass,
    #[allow(missing_docs)] // documentation missing in model
    Prepass,
    #[allow(missing_docs)] // documentation missing in model
    Scheduled,
    #[allow(missing_docs)] // documentation missing in model
    Scheduling,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ContactStatus {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => ContactStatus::Available,
            "AWS_CANCELLED" => ContactStatus::AwsCancelled,
            "AWS_FAILED" => ContactStatus::AwsFailed,
            "CANCELLED" => ContactStatus::Cancelled,
            "CANCELLING" => ContactStatus::Cancelling,
            "COMPLETED" => ContactStatus::Completed,
            "FAILED" => ContactStatus::Failed,
            "FAILED_TO_SCHEDULE" => ContactStatus::FailedToSchedule,
            "PASS" => ContactStatus::Pass,
            "POSTPASS" => ContactStatus::Postpass,
            "PREPASS" => ContactStatus::Prepass,
            "SCHEDULED" => ContactStatus::Scheduled,
            "SCHEDULING" => ContactStatus::Scheduling,
            other => ContactStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ContactStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ContactStatus::from(s))
    }
}
impl ContactStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ContactStatus::Available => "AVAILABLE",
            ContactStatus::AwsCancelled => "AWS_CANCELLED",
            ContactStatus::AwsFailed => "AWS_FAILED",
            ContactStatus::Cancelled => "CANCELLED",
            ContactStatus::Cancelling => "CANCELLING",
            ContactStatus::Completed => "COMPLETED",
            ContactStatus::Failed => "FAILED",
            ContactStatus::FailedToSchedule => "FAILED_TO_SCHEDULE",
            ContactStatus::Pass => "PASS",
            ContactStatus::Postpass => "POSTPASS",
            ContactStatus::Prepass => "PREPASS",
            ContactStatus::Scheduled => "SCHEDULED",
            ContactStatus::Scheduling => "SCHEDULING",
            ContactStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE",
            "AWS_CANCELLED",
            "AWS_FAILED",
            "CANCELLED",
            "CANCELLING",
            "COMPLETED",
            "FAILED",
            "FAILED_TO_SCHEDULE",
            "PASS",
            "POSTPASS",
            "PREPASS",
            "SCHEDULED",
            "SCHEDULING",
        ]
    }
}
impl AsRef<str> for ContactStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a dataflow edge used in a contact.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataflowDetail {
    /// <p>Dataflow details for the source side.</p>
    #[doc(hidden)]
    pub source: std::option::Option<crate::model::Source>,
    /// <p>Dataflow details for the destination side.</p>
    #[doc(hidden)]
    pub destination: std::option::Option<crate::model::Destination>,
    /// <p>Error message for a dataflow.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl DataflowDetail {
    /// <p>Dataflow details for the source side.</p>
    pub fn source(&self) -> std::option::Option<&crate::model::Source> {
        self.source.as_ref()
    }
    /// <p>Dataflow details for the destination side.</p>
    pub fn destination(&self) -> std::option::Option<&crate::model::Destination> {
        self.destination.as_ref()
    }
    /// <p>Error message for a dataflow.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
/// See [`DataflowDetail`](crate::model::DataflowDetail).
pub mod dataflow_detail {

    /// A builder for [`DataflowDetail`](crate::model::DataflowDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source: std::option::Option<crate::model::Source>,
        pub(crate) destination: std::option::Option<crate::model::Destination>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Dataflow details for the source side.</p>
        pub fn source(mut self, input: crate::model::Source) -> Self {
            self.source = Some(input);
            self
        }
        /// <p>Dataflow details for the source side.</p>
        pub fn set_source(mut self, input: std::option::Option<crate::model::Source>) -> Self {
            self.source = input;
            self
        }
        /// <p>Dataflow details for the destination side.</p>
        pub fn destination(mut self, input: crate::model::Destination) -> Self {
            self.destination = Some(input);
            self
        }
        /// <p>Dataflow details for the destination side.</p>
        pub fn set_destination(
            mut self,
            input: std::option::Option<crate::model::Destination>,
        ) -> Self {
            self.destination = input;
            self
        }
        /// <p>Error message for a dataflow.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>Error message for a dataflow.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`DataflowDetail`](crate::model::DataflowDetail).
        pub fn build(self) -> crate::model::DataflowDetail {
            crate::model::DataflowDetail {
                source: self.source,
                destination: self.destination,
                error_message: self.error_message,
            }
        }
    }
}
impl DataflowDetail {
    /// Creates a new builder-style object to manufacture [`DataflowDetail`](crate::model::DataflowDetail).
    pub fn builder() -> crate::model::dataflow_detail::Builder {
        crate::model::dataflow_detail::Builder::default()
    }
}

/// <p>Dataflow details for the destination side.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Destination {
    /// <p>Type of a <code>Config</code>.</p>
    #[doc(hidden)]
    pub config_type: std::option::Option<crate::model::ConfigCapabilityType>,
    /// <p>UUID of a <code>Config</code>.</p>
    #[doc(hidden)]
    pub config_id: std::option::Option<std::string::String>,
    /// <p>Additional details for a <code>Config</code>, if type is dataflow endpoint or antenna demod decode.</p>
    #[doc(hidden)]
    pub config_details: std::option::Option<crate::model::ConfigDetails>,
    /// <p>Region of a dataflow destination.</p>
    #[doc(hidden)]
    pub dataflow_destination_region: std::option::Option<std::string::String>,
}
impl Destination {
    /// <p>Type of a <code>Config</code>.</p>
    pub fn config_type(&self) -> std::option::Option<&crate::model::ConfigCapabilityType> {
        self.config_type.as_ref()
    }
    /// <p>UUID of a <code>Config</code>.</p>
    pub fn config_id(&self) -> std::option::Option<&str> {
        self.config_id.as_deref()
    }
    /// <p>Additional details for a <code>Config</code>, if type is dataflow endpoint or antenna demod decode.</p>
    pub fn config_details(&self) -> std::option::Option<&crate::model::ConfigDetails> {
        self.config_details.as_ref()
    }
    /// <p>Region of a dataflow destination.</p>
    pub fn dataflow_destination_region(&self) -> std::option::Option<&str> {
        self.dataflow_destination_region.as_deref()
    }
}
/// See [`Destination`](crate::model::Destination).
pub mod destination {

    /// A builder for [`Destination`](crate::model::Destination).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) config_type: std::option::Option<crate::model::ConfigCapabilityType>,
        pub(crate) config_id: std::option::Option<std::string::String>,
        pub(crate) config_details: std::option::Option<crate::model::ConfigDetails>,
        pub(crate) dataflow_destination_region: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Type of a <code>Config</code>.</p>
        pub fn config_type(mut self, input: crate::model::ConfigCapabilityType) -> Self {
            self.config_type = Some(input);
            self
        }
        /// <p>Type of a <code>Config</code>.</p>
        pub fn set_config_type(
            mut self,
            input: std::option::Option<crate::model::ConfigCapabilityType>,
        ) -> Self {
            self.config_type = input;
            self
        }
        /// <p>UUID of a <code>Config</code>.</p>
        pub fn config_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.config_id = Some(input.into());
            self
        }
        /// <p>UUID of a <code>Config</code>.</p>
        pub fn set_config_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.config_id = input;
            self
        }
        /// <p>Additional details for a <code>Config</code>, if type is dataflow endpoint or antenna demod decode.</p>
        pub fn config_details(mut self, input: crate::model::ConfigDetails) -> Self {
            self.config_details = Some(input);
            self
        }
        /// <p>Additional details for a <code>Config</code>, if type is dataflow endpoint or antenna demod decode.</p>
        pub fn set_config_details(
            mut self,
            input: std::option::Option<crate::model::ConfigDetails>,
        ) -> Self {
            self.config_details = input;
            self
        }
        /// <p>Region of a dataflow destination.</p>
        pub fn dataflow_destination_region(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.dataflow_destination_region = Some(input.into());
            self
        }
        /// <p>Region of a dataflow destination.</p>
        pub fn set_dataflow_destination_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dataflow_destination_region = input;
            self
        }
        /// Consumes the builder and constructs a [`Destination`](crate::model::Destination).
        pub fn build(self) -> crate::model::Destination {
            crate::model::Destination {
                config_type: self.config_type,
                config_id: self.config_id,
                config_details: self.config_details,
                dataflow_destination_region: self.dataflow_destination_region,
            }
        }
    }
}
impl Destination {
    /// Creates a new builder-style object to manufacture [`Destination`](crate::model::Destination).
    pub fn builder() -> crate::model::destination::Builder {
        crate::model::destination::Builder::default()
    }
}

/// <p>Details for certain <code>Config</code> object types in a contact.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum ConfigDetails {
    /// <p>Details for antenna demod decode <code>Config</code> in a contact.</p>
    AntennaDemodDecodeDetails(crate::model::AntennaDemodDecodeDetails),
    /// <p>Information about the endpoint details.</p>
    EndpointDetails(crate::model::EndpointDetails),
    /// <p>Details for an S3 recording <code>Config</code> in a contact.</p>
    S3RecordingDetails(crate::model::S3RecordingDetails),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl ConfigDetails {
    /// Tries to convert the enum instance into [`AntennaDemodDecodeDetails`](crate::model::ConfigDetails::AntennaDemodDecodeDetails), extracting the inner [`AntennaDemodDecodeDetails`](crate::model::AntennaDemodDecodeDetails).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_antenna_demod_decode_details(
        &self,
    ) -> std::result::Result<&crate::model::AntennaDemodDecodeDetails, &Self> {
        if let ConfigDetails::AntennaDemodDecodeDetails(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`AntennaDemodDecodeDetails`](crate::model::ConfigDetails::AntennaDemodDecodeDetails).
    pub fn is_antenna_demod_decode_details(&self) -> bool {
        self.as_antenna_demod_decode_details().is_ok()
    }
    /// Tries to convert the enum instance into [`EndpointDetails`](crate::model::ConfigDetails::EndpointDetails), extracting the inner [`EndpointDetails`](crate::model::EndpointDetails).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_endpoint_details(
        &self,
    ) -> std::result::Result<&crate::model::EndpointDetails, &Self> {
        if let ConfigDetails::EndpointDetails(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`EndpointDetails`](crate::model::ConfigDetails::EndpointDetails).
    pub fn is_endpoint_details(&self) -> bool {
        self.as_endpoint_details().is_ok()
    }
    /// Tries to convert the enum instance into [`S3RecordingDetails`](crate::model::ConfigDetails::S3RecordingDetails), extracting the inner [`S3RecordingDetails`](crate::model::S3RecordingDetails).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_s3_recording_details(
        &self,
    ) -> std::result::Result<&crate::model::S3RecordingDetails, &Self> {
        if let ConfigDetails::S3RecordingDetails(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`S3RecordingDetails`](crate::model::ConfigDetails::S3RecordingDetails).
    pub fn is_s3_recording_details(&self) -> bool {
        self.as_s3_recording_details().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Details about an S3 recording <code>Config</code> used in a contact.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3RecordingDetails {
    /// <p>ARN of the bucket used.</p>
    #[doc(hidden)]
    pub bucket_arn: std::option::Option<std::string::String>,
    /// <p>Key template used for the S3 Recording Configuration</p>
    #[doc(hidden)]
    pub key_template: std::option::Option<std::string::String>,
}
impl S3RecordingDetails {
    /// <p>ARN of the bucket used.</p>
    pub fn bucket_arn(&self) -> std::option::Option<&str> {
        self.bucket_arn.as_deref()
    }
    /// <p>Key template used for the S3 Recording Configuration</p>
    pub fn key_template(&self) -> std::option::Option<&str> {
        self.key_template.as_deref()
    }
}
/// See [`S3RecordingDetails`](crate::model::S3RecordingDetails).
pub mod s3_recording_details {

    /// A builder for [`S3RecordingDetails`](crate::model::S3RecordingDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_arn: std::option::Option<std::string::String>,
        pub(crate) key_template: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>ARN of the bucket used.</p>
        pub fn bucket_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_arn = Some(input.into());
            self
        }
        /// <p>ARN of the bucket used.</p>
        pub fn set_bucket_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_arn = input;
            self
        }
        /// <p>Key template used for the S3 Recording Configuration</p>
        pub fn key_template(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_template = Some(input.into());
            self
        }
        /// <p>Key template used for the S3 Recording Configuration</p>
        pub fn set_key_template(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_template = input;
            self
        }
        /// Consumes the builder and constructs a [`S3RecordingDetails`](crate::model::S3RecordingDetails).
        pub fn build(self) -> crate::model::S3RecordingDetails {
            crate::model::S3RecordingDetails {
                bucket_arn: self.bucket_arn,
                key_template: self.key_template,
            }
        }
    }
}
impl S3RecordingDetails {
    /// Creates a new builder-style object to manufacture [`S3RecordingDetails`](crate::model::S3RecordingDetails).
    pub fn builder() -> crate::model::s3_recording_details::Builder {
        crate::model::s3_recording_details::Builder::default()
    }
}

/// <p>Details about an antenna demod decode <code>Config</code> used in a contact.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AntennaDemodDecodeDetails {
    /// <p>Name of an antenna demod decode output node used in a contact.</p>
    #[doc(hidden)]
    pub output_node: std::option::Option<std::string::String>,
}
impl AntennaDemodDecodeDetails {
    /// <p>Name of an antenna demod decode output node used in a contact.</p>
    pub fn output_node(&self) -> std::option::Option<&str> {
        self.output_node.as_deref()
    }
}
/// See [`AntennaDemodDecodeDetails`](crate::model::AntennaDemodDecodeDetails).
pub mod antenna_demod_decode_details {

    /// A builder for [`AntennaDemodDecodeDetails`](crate::model::AntennaDemodDecodeDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) output_node: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Name of an antenna demod decode output node used in a contact.</p>
        pub fn output_node(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_node = Some(input.into());
            self
        }
        /// <p>Name of an antenna demod decode output node used in a contact.</p>
        pub fn set_output_node(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.output_node = input;
            self
        }
        /// Consumes the builder and constructs a [`AntennaDemodDecodeDetails`](crate::model::AntennaDemodDecodeDetails).
        pub fn build(self) -> crate::model::AntennaDemodDecodeDetails {
            crate::model::AntennaDemodDecodeDetails {
                output_node: self.output_node,
            }
        }
    }
}
impl AntennaDemodDecodeDetails {
    /// Creates a new builder-style object to manufacture [`AntennaDemodDecodeDetails`](crate::model::AntennaDemodDecodeDetails).
    pub fn builder() -> crate::model::antenna_demod_decode_details::Builder {
        crate::model::antenna_demod_decode_details::Builder::default()
    }
}

/// When writing a match expression against `ConfigCapabilityType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let configcapabilitytype = unimplemented!();
/// match configcapabilitytype {
///     ConfigCapabilityType::AntennaDownlink => { /* ... */ },
///     ConfigCapabilityType::AntennaDownlinkDemodDecode => { /* ... */ },
///     ConfigCapabilityType::AntennaUplink => { /* ... */ },
///     ConfigCapabilityType::DataflowEndpoint => { /* ... */ },
///     ConfigCapabilityType::S3Recording => { /* ... */ },
///     ConfigCapabilityType::Tracking => { /* ... */ },
///     ConfigCapabilityType::UplinkEcho => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `configcapabilitytype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConfigCapabilityType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConfigCapabilityType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConfigCapabilityType::NewFeature` is defined.
/// Specifically, when `configcapabilitytype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConfigCapabilityType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConfigCapabilityType {
    #[allow(missing_docs)] // documentation missing in model
    AntennaDownlink,
    #[allow(missing_docs)] // documentation missing in model
    AntennaDownlinkDemodDecode,
    #[allow(missing_docs)] // documentation missing in model
    AntennaUplink,
    #[allow(missing_docs)] // documentation missing in model
    DataflowEndpoint,
    #[allow(missing_docs)] // documentation missing in model
    S3Recording,
    #[allow(missing_docs)] // documentation missing in model
    Tracking,
    #[allow(missing_docs)] // documentation missing in model
    UplinkEcho,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConfigCapabilityType {
    fn from(s: &str) -> Self {
        match s {
            "antenna-downlink" => ConfigCapabilityType::AntennaDownlink,
            "antenna-downlink-demod-decode" => ConfigCapabilityType::AntennaDownlinkDemodDecode,
            "antenna-uplink" => ConfigCapabilityType::AntennaUplink,
            "dataflow-endpoint" => ConfigCapabilityType::DataflowEndpoint,
            "s3-recording" => ConfigCapabilityType::S3Recording,
            "tracking" => ConfigCapabilityType::Tracking,
            "uplink-echo" => ConfigCapabilityType::UplinkEcho,
            other => {
                ConfigCapabilityType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ConfigCapabilityType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConfigCapabilityType::from(s))
    }
}
impl ConfigCapabilityType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConfigCapabilityType::AntennaDownlink => "antenna-downlink",
            ConfigCapabilityType::AntennaDownlinkDemodDecode => "antenna-downlink-demod-decode",
            ConfigCapabilityType::AntennaUplink => "antenna-uplink",
            ConfigCapabilityType::DataflowEndpoint => "dataflow-endpoint",
            ConfigCapabilityType::S3Recording => "s3-recording",
            ConfigCapabilityType::Tracking => "tracking",
            ConfigCapabilityType::UplinkEcho => "uplink-echo",
            ConfigCapabilityType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "antenna-downlink",
            "antenna-downlink-demod-decode",
            "antenna-uplink",
            "dataflow-endpoint",
            "s3-recording",
            "tracking",
            "uplink-echo",
        ]
    }
}
impl AsRef<str> for ConfigCapabilityType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Dataflow details for the source side.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Source {
    /// <p>Type of a <code>Config</code>.</p>
    #[doc(hidden)]
    pub config_type: std::option::Option<crate::model::ConfigCapabilityType>,
    /// <p>UUID of a <code>Config</code>.</p>
    #[doc(hidden)]
    pub config_id: std::option::Option<std::string::String>,
    /// <p>Additional details for a <code>Config</code>, if type is <code>dataflow-endpoint</code> or <code>antenna-downlink-demod-decode</code> </p>
    #[doc(hidden)]
    pub config_details: std::option::Option<crate::model::ConfigDetails>,
    /// <p>Region of a dataflow source.</p>
    #[doc(hidden)]
    pub dataflow_source_region: std::option::Option<std::string::String>,
}
impl Source {
    /// <p>Type of a <code>Config</code>.</p>
    pub fn config_type(&self) -> std::option::Option<&crate::model::ConfigCapabilityType> {
        self.config_type.as_ref()
    }
    /// <p>UUID of a <code>Config</code>.</p>
    pub fn config_id(&self) -> std::option::Option<&str> {
        self.config_id.as_deref()
    }
    /// <p>Additional details for a <code>Config</code>, if type is <code>dataflow-endpoint</code> or <code>antenna-downlink-demod-decode</code> </p>
    pub fn config_details(&self) -> std::option::Option<&crate::model::ConfigDetails> {
        self.config_details.as_ref()
    }
    /// <p>Region of a dataflow source.</p>
    pub fn dataflow_source_region(&self) -> std::option::Option<&str> {
        self.dataflow_source_region.as_deref()
    }
}
/// See [`Source`](crate::model::Source).
pub mod source {

    /// A builder for [`Source`](crate::model::Source).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) config_type: std::option::Option<crate::model::ConfigCapabilityType>,
        pub(crate) config_id: std::option::Option<std::string::String>,
        pub(crate) config_details: std::option::Option<crate::model::ConfigDetails>,
        pub(crate) dataflow_source_region: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Type of a <code>Config</code>.</p>
        pub fn config_type(mut self, input: crate::model::ConfigCapabilityType) -> Self {
            self.config_type = Some(input);
            self
        }
        /// <p>Type of a <code>Config</code>.</p>
        pub fn set_config_type(
            mut self,
            input: std::option::Option<crate::model::ConfigCapabilityType>,
        ) -> Self {
            self.config_type = input;
            self
        }
        /// <p>UUID of a <code>Config</code>.</p>
        pub fn config_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.config_id = Some(input.into());
            self
        }
        /// <p>UUID of a <code>Config</code>.</p>
        pub fn set_config_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.config_id = input;
            self
        }
        /// <p>Additional details for a <code>Config</code>, if type is <code>dataflow-endpoint</code> or <code>antenna-downlink-demod-decode</code> </p>
        pub fn config_details(mut self, input: crate::model::ConfigDetails) -> Self {
            self.config_details = Some(input);
            self
        }
        /// <p>Additional details for a <code>Config</code>, if type is <code>dataflow-endpoint</code> or <code>antenna-downlink-demod-decode</code> </p>
        pub fn set_config_details(
            mut self,
            input: std::option::Option<crate::model::ConfigDetails>,
        ) -> Self {
            self.config_details = input;
            self
        }
        /// <p>Region of a dataflow source.</p>
        pub fn dataflow_source_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.dataflow_source_region = Some(input.into());
            self
        }
        /// <p>Region of a dataflow source.</p>
        pub fn set_dataflow_source_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dataflow_source_region = input;
            self
        }
        /// Consumes the builder and constructs a [`Source`](crate::model::Source).
        pub fn build(self) -> crate::model::Source {
            crate::model::Source {
                config_type: self.config_type,
                config_id: self.config_id,
                config_details: self.config_details,
                dataflow_source_region: self.dataflow_source_region,
            }
        }
    }
}
impl Source {
    /// Creates a new builder-style object to manufacture [`Source`](crate::model::Source).
    pub fn builder() -> crate::model::source::Builder {
        crate::model::source::Builder::default()
    }
}

/// <p>An item in a list of <code>Config</code> objects.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfigListItem {
    /// <p>UUID of a <code>Config</code>.</p>
    #[doc(hidden)]
    pub config_id: std::option::Option<std::string::String>,
    /// <p>Type of a <code>Config</code>.</p>
    #[doc(hidden)]
    pub config_type: std::option::Option<crate::model::ConfigCapabilityType>,
    /// <p>ARN of a <code>Config</code>.</p>
    #[doc(hidden)]
    pub config_arn: std::option::Option<std::string::String>,
    /// <p>Name of a <code>Config</code>.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl ConfigListItem {
    /// <p>UUID of a <code>Config</code>.</p>
    pub fn config_id(&self) -> std::option::Option<&str> {
        self.config_id.as_deref()
    }
    /// <p>Type of a <code>Config</code>.</p>
    pub fn config_type(&self) -> std::option::Option<&crate::model::ConfigCapabilityType> {
        self.config_type.as_ref()
    }
    /// <p>ARN of a <code>Config</code>.</p>
    pub fn config_arn(&self) -> std::option::Option<&str> {
        self.config_arn.as_deref()
    }
    /// <p>Name of a <code>Config</code>.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
/// See [`ConfigListItem`](crate::model::ConfigListItem).
pub mod config_list_item {

    /// A builder for [`ConfigListItem`](crate::model::ConfigListItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) config_id: std::option::Option<std::string::String>,
        pub(crate) config_type: std::option::Option<crate::model::ConfigCapabilityType>,
        pub(crate) config_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>UUID of a <code>Config</code>.</p>
        pub fn config_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.config_id = Some(input.into());
            self
        }
        /// <p>UUID of a <code>Config</code>.</p>
        pub fn set_config_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.config_id = input;
            self
        }
        /// <p>Type of a <code>Config</code>.</p>
        pub fn config_type(mut self, input: crate::model::ConfigCapabilityType) -> Self {
            self.config_type = Some(input);
            self
        }
        /// <p>Type of a <code>Config</code>.</p>
        pub fn set_config_type(
            mut self,
            input: std::option::Option<crate::model::ConfigCapabilityType>,
        ) -> Self {
            self.config_type = input;
            self
        }
        /// <p>ARN of a <code>Config</code>.</p>
        pub fn config_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.config_arn = Some(input.into());
            self
        }
        /// <p>ARN of a <code>Config</code>.</p>
        pub fn set_config_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.config_arn = input;
            self
        }
        /// <p>Name of a <code>Config</code>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Name of a <code>Config</code>.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigListItem`](crate::model::ConfigListItem).
        pub fn build(self) -> crate::model::ConfigListItem {
            crate::model::ConfigListItem {
                config_id: self.config_id,
                config_type: self.config_type,
                config_arn: self.config_arn,
                name: self.name,
            }
        }
    }
}
impl ConfigListItem {
    /// Creates a new builder-style object to manufacture [`ConfigListItem`](crate::model::ConfigListItem).
    pub fn builder() -> crate::model::config_list_item::Builder {
        crate::model::config_list_item::Builder::default()
    }
}

/// <p>Object containing the parameters of a <code>Config</code>.</p>
/// <p>See the subtype definitions for what each type of <code>Config</code> contains.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum ConfigTypeData {
    /// <p>Information about how AWS Ground Station should configure an antenna for downlink during a contact.</p>
    AntennaDownlinkConfig(crate::model::AntennaDownlinkConfig),
    /// <p>Information about how AWS Ground Station should conﬁgure an antenna for downlink demod decode during a contact.</p>
    AntennaDownlinkDemodDecodeConfig(crate::model::AntennaDownlinkDemodDecodeConfig),
    /// <p>Information about how AWS Ground Station should conﬁgure an antenna for uplink during a contact.</p>
    AntennaUplinkConfig(crate::model::AntennaUplinkConfig),
    /// <p>Information about the dataflow endpoint <code>Config</code>.</p>
    DataflowEndpointConfig(crate::model::DataflowEndpointConfig),
    /// <p>Information about an S3 recording <code>Config</code>.</p>
    S3RecordingConfig(crate::model::S3RecordingConfig),
    /// <p>Object that determines whether tracking should be used during a contact executed with this <code>Config</code> in the mission profile. </p>
    TrackingConfig(crate::model::TrackingConfig),
    /// <p>Information about an uplink echo <code>Config</code>.</p>
    /// <p>Parameters from the <code>AntennaUplinkConfig</code>, corresponding to the specified <code>AntennaUplinkConfigArn</code>, are used when this <code>UplinkEchoConfig</code> is used in a contact.</p>
    UplinkEchoConfig(crate::model::UplinkEchoConfig),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl ConfigTypeData {
    /// Tries to convert the enum instance into [`AntennaDownlinkConfig`](crate::model::ConfigTypeData::AntennaDownlinkConfig), extracting the inner [`AntennaDownlinkConfig`](crate::model::AntennaDownlinkConfig).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_antenna_downlink_config(
        &self,
    ) -> std::result::Result<&crate::model::AntennaDownlinkConfig, &Self> {
        if let ConfigTypeData::AntennaDownlinkConfig(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`AntennaDownlinkConfig`](crate::model::ConfigTypeData::AntennaDownlinkConfig).
    pub fn is_antenna_downlink_config(&self) -> bool {
        self.as_antenna_downlink_config().is_ok()
    }
    /// Tries to convert the enum instance into [`AntennaDownlinkDemodDecodeConfig`](crate::model::ConfigTypeData::AntennaDownlinkDemodDecodeConfig), extracting the inner [`AntennaDownlinkDemodDecodeConfig`](crate::model::AntennaDownlinkDemodDecodeConfig).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_antenna_downlink_demod_decode_config(
        &self,
    ) -> std::result::Result<&crate::model::AntennaDownlinkDemodDecodeConfig, &Self> {
        if let ConfigTypeData::AntennaDownlinkDemodDecodeConfig(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`AntennaDownlinkDemodDecodeConfig`](crate::model::ConfigTypeData::AntennaDownlinkDemodDecodeConfig).
    pub fn is_antenna_downlink_demod_decode_config(&self) -> bool {
        self.as_antenna_downlink_demod_decode_config().is_ok()
    }
    /// Tries to convert the enum instance into [`AntennaUplinkConfig`](crate::model::ConfigTypeData::AntennaUplinkConfig), extracting the inner [`AntennaUplinkConfig`](crate::model::AntennaUplinkConfig).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_antenna_uplink_config(
        &self,
    ) -> std::result::Result<&crate::model::AntennaUplinkConfig, &Self> {
        if let ConfigTypeData::AntennaUplinkConfig(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`AntennaUplinkConfig`](crate::model::ConfigTypeData::AntennaUplinkConfig).
    pub fn is_antenna_uplink_config(&self) -> bool {
        self.as_antenna_uplink_config().is_ok()
    }
    /// Tries to convert the enum instance into [`DataflowEndpointConfig`](crate::model::ConfigTypeData::DataflowEndpointConfig), extracting the inner [`DataflowEndpointConfig`](crate::model::DataflowEndpointConfig).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_dataflow_endpoint_config(
        &self,
    ) -> std::result::Result<&crate::model::DataflowEndpointConfig, &Self> {
        if let ConfigTypeData::DataflowEndpointConfig(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`DataflowEndpointConfig`](crate::model::ConfigTypeData::DataflowEndpointConfig).
    pub fn is_dataflow_endpoint_config(&self) -> bool {
        self.as_dataflow_endpoint_config().is_ok()
    }
    /// Tries to convert the enum instance into [`S3RecordingConfig`](crate::model::ConfigTypeData::S3RecordingConfig), extracting the inner [`S3RecordingConfig`](crate::model::S3RecordingConfig).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_s3_recording_config(
        &self,
    ) -> std::result::Result<&crate::model::S3RecordingConfig, &Self> {
        if let ConfigTypeData::S3RecordingConfig(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`S3RecordingConfig`](crate::model::ConfigTypeData::S3RecordingConfig).
    pub fn is_s3_recording_config(&self) -> bool {
        self.as_s3_recording_config().is_ok()
    }
    /// Tries to convert the enum instance into [`TrackingConfig`](crate::model::ConfigTypeData::TrackingConfig), extracting the inner [`TrackingConfig`](crate::model::TrackingConfig).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_tracking_config(&self) -> std::result::Result<&crate::model::TrackingConfig, &Self> {
        if let ConfigTypeData::TrackingConfig(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`TrackingConfig`](crate::model::ConfigTypeData::TrackingConfig).
    pub fn is_tracking_config(&self) -> bool {
        self.as_tracking_config().is_ok()
    }
    /// Tries to convert the enum instance into [`UplinkEchoConfig`](crate::model::ConfigTypeData::UplinkEchoConfig), extracting the inner [`UplinkEchoConfig`](crate::model::UplinkEchoConfig).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_uplink_echo_config(
        &self,
    ) -> std::result::Result<&crate::model::UplinkEchoConfig, &Self> {
        if let ConfigTypeData::UplinkEchoConfig(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`UplinkEchoConfig`](crate::model::ConfigTypeData::UplinkEchoConfig).
    pub fn is_uplink_echo_config(&self) -> bool {
        self.as_uplink_echo_config().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Information about an S3 recording <code>Config</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3RecordingConfig {
    /// <p>ARN of the bucket to record to.</p>
    #[doc(hidden)]
    pub bucket_arn: std::option::Option<std::string::String>,
    /// <p>ARN of the role Ground Station assumes to write data to the bucket.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>S3 Key prefix to prefice data files.</p>
    #[doc(hidden)]
    pub prefix: std::option::Option<std::string::String>,
}
impl S3RecordingConfig {
    /// <p>ARN of the bucket to record to.</p>
    pub fn bucket_arn(&self) -> std::option::Option<&str> {
        self.bucket_arn.as_deref()
    }
    /// <p>ARN of the role Ground Station assumes to write data to the bucket.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>S3 Key prefix to prefice data files.</p>
    pub fn prefix(&self) -> std::option::Option<&str> {
        self.prefix.as_deref()
    }
}
/// See [`S3RecordingConfig`](crate::model::S3RecordingConfig).
pub mod s3_recording_config {

    /// A builder for [`S3RecordingConfig`](crate::model::S3RecordingConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_arn: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>ARN of the bucket to record to.</p>
        pub fn bucket_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_arn = Some(input.into());
            self
        }
        /// <p>ARN of the bucket to record to.</p>
        pub fn set_bucket_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_arn = input;
            self
        }
        /// <p>ARN of the role Ground Station assumes to write data to the bucket.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>ARN of the role Ground Station assumes to write data to the bucket.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>S3 Key prefix to prefice data files.</p>
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        /// <p>S3 Key prefix to prefice data files.</p>
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`S3RecordingConfig`](crate::model::S3RecordingConfig).
        pub fn build(self) -> crate::model::S3RecordingConfig {
            crate::model::S3RecordingConfig {
                bucket_arn: self.bucket_arn,
                role_arn: self.role_arn,
                prefix: self.prefix,
            }
        }
    }
}
impl S3RecordingConfig {
    /// Creates a new builder-style object to manufacture [`S3RecordingConfig`](crate::model::S3RecordingConfig).
    pub fn builder() -> crate::model::s3_recording_config::Builder {
        crate::model::s3_recording_config::Builder::default()
    }
}

/// <p>Information about an uplink echo <code>Config</code>.</p>
/// <p>Parameters from the <code>AntennaUplinkConfig</code>, corresponding to the specified <code>AntennaUplinkConfigArn</code>, are used when this <code>UplinkEchoConfig</code> is used in a contact.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UplinkEchoConfig {
    /// <p>Whether or not an uplink <code>Config</code> is enabled.</p>
    #[doc(hidden)]
    pub enabled: std::option::Option<bool>,
    /// <p>ARN of an uplink <code>Config</code>.</p>
    #[doc(hidden)]
    pub antenna_uplink_config_arn: std::option::Option<std::string::String>,
}
impl UplinkEchoConfig {
    /// <p>Whether or not an uplink <code>Config</code> is enabled.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
    /// <p>ARN of an uplink <code>Config</code>.</p>
    pub fn antenna_uplink_config_arn(&self) -> std::option::Option<&str> {
        self.antenna_uplink_config_arn.as_deref()
    }
}
/// See [`UplinkEchoConfig`](crate::model::UplinkEchoConfig).
pub mod uplink_echo_config {

    /// A builder for [`UplinkEchoConfig`](crate::model::UplinkEchoConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) antenna_uplink_config_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Whether or not an uplink <code>Config</code> is enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Whether or not an uplink <code>Config</code> is enabled.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>ARN of an uplink <code>Config</code>.</p>
        pub fn antenna_uplink_config_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.antenna_uplink_config_arn = Some(input.into());
            self
        }
        /// <p>ARN of an uplink <code>Config</code>.</p>
        pub fn set_antenna_uplink_config_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.antenna_uplink_config_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`UplinkEchoConfig`](crate::model::UplinkEchoConfig).
        pub fn build(self) -> crate::model::UplinkEchoConfig {
            crate::model::UplinkEchoConfig {
                enabled: self.enabled,
                antenna_uplink_config_arn: self.antenna_uplink_config_arn,
            }
        }
    }
}
impl UplinkEchoConfig {
    /// Creates a new builder-style object to manufacture [`UplinkEchoConfig`](crate::model::UplinkEchoConfig).
    pub fn builder() -> crate::model::uplink_echo_config::Builder {
        crate::model::uplink_echo_config::Builder::default()
    }
}

/// <p>Information about the uplink <code>Config</code> of an antenna.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AntennaUplinkConfig {
    /// <p>Whether or not uplink transmit is disabled.</p>
    #[doc(hidden)]
    pub transmit_disabled: std::option::Option<bool>,
    /// <p>Information about the uplink spectral <code>Config</code>.</p>
    #[doc(hidden)]
    pub spectrum_config: std::option::Option<crate::model::UplinkSpectrumConfig>,
    /// <p>EIRP of the target.</p>
    #[doc(hidden)]
    pub target_eirp: std::option::Option<crate::model::Eirp>,
}
impl AntennaUplinkConfig {
    /// <p>Whether or not uplink transmit is disabled.</p>
    pub fn transmit_disabled(&self) -> std::option::Option<bool> {
        self.transmit_disabled
    }
    /// <p>Information about the uplink spectral <code>Config</code>.</p>
    pub fn spectrum_config(&self) -> std::option::Option<&crate::model::UplinkSpectrumConfig> {
        self.spectrum_config.as_ref()
    }
    /// <p>EIRP of the target.</p>
    pub fn target_eirp(&self) -> std::option::Option<&crate::model::Eirp> {
        self.target_eirp.as_ref()
    }
}
/// See [`AntennaUplinkConfig`](crate::model::AntennaUplinkConfig).
pub mod antenna_uplink_config {

    /// A builder for [`AntennaUplinkConfig`](crate::model::AntennaUplinkConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transmit_disabled: std::option::Option<bool>,
        pub(crate) spectrum_config: std::option::Option<crate::model::UplinkSpectrumConfig>,
        pub(crate) target_eirp: std::option::Option<crate::model::Eirp>,
    }
    impl Builder {
        /// <p>Whether or not uplink transmit is disabled.</p>
        pub fn transmit_disabled(mut self, input: bool) -> Self {
            self.transmit_disabled = Some(input);
            self
        }
        /// <p>Whether or not uplink transmit is disabled.</p>
        pub fn set_transmit_disabled(mut self, input: std::option::Option<bool>) -> Self {
            self.transmit_disabled = input;
            self
        }
        /// <p>Information about the uplink spectral <code>Config</code>.</p>
        pub fn spectrum_config(mut self, input: crate::model::UplinkSpectrumConfig) -> Self {
            self.spectrum_config = Some(input);
            self
        }
        /// <p>Information about the uplink spectral <code>Config</code>.</p>
        pub fn set_spectrum_config(
            mut self,
            input: std::option::Option<crate::model::UplinkSpectrumConfig>,
        ) -> Self {
            self.spectrum_config = input;
            self
        }
        /// <p>EIRP of the target.</p>
        pub fn target_eirp(mut self, input: crate::model::Eirp) -> Self {
            self.target_eirp = Some(input);
            self
        }
        /// <p>EIRP of the target.</p>
        pub fn set_target_eirp(mut self, input: std::option::Option<crate::model::Eirp>) -> Self {
            self.target_eirp = input;
            self
        }
        /// Consumes the builder and constructs a [`AntennaUplinkConfig`](crate::model::AntennaUplinkConfig).
        pub fn build(self) -> crate::model::AntennaUplinkConfig {
            crate::model::AntennaUplinkConfig {
                transmit_disabled: self.transmit_disabled,
                spectrum_config: self.spectrum_config,
                target_eirp: self.target_eirp,
            }
        }
    }
}
impl AntennaUplinkConfig {
    /// Creates a new builder-style object to manufacture [`AntennaUplinkConfig`](crate::model::AntennaUplinkConfig).
    pub fn builder() -> crate::model::antenna_uplink_config::Builder {
        crate::model::antenna_uplink_config::Builder::default()
    }
}

/// <p>Object that represents EIRP.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Eirp {
    /// <p>Value of an EIRP. Valid values are between 20.0 to 50.0 dBW.</p>
    #[doc(hidden)]
    pub value: std::option::Option<f64>,
    /// <p>Units of an EIRP.</p>
    #[doc(hidden)]
    pub units: std::option::Option<crate::model::EirpUnits>,
}
impl Eirp {
    /// <p>Value of an EIRP. Valid values are between 20.0 to 50.0 dBW.</p>
    pub fn value(&self) -> std::option::Option<f64> {
        self.value
    }
    /// <p>Units of an EIRP.</p>
    pub fn units(&self) -> std::option::Option<&crate::model::EirpUnits> {
        self.units.as_ref()
    }
}
/// See [`Eirp`](crate::model::Eirp).
pub mod eirp {

    /// A builder for [`Eirp`](crate::model::Eirp).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<f64>,
        pub(crate) units: std::option::Option<crate::model::EirpUnits>,
    }
    impl Builder {
        /// <p>Value of an EIRP. Valid values are between 20.0 to 50.0 dBW.</p>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>Value of an EIRP. Valid values are between 20.0 to 50.0 dBW.</p>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input;
            self
        }
        /// <p>Units of an EIRP.</p>
        pub fn units(mut self, input: crate::model::EirpUnits) -> Self {
            self.units = Some(input);
            self
        }
        /// <p>Units of an EIRP.</p>
        pub fn set_units(mut self, input: std::option::Option<crate::model::EirpUnits>) -> Self {
            self.units = input;
            self
        }
        /// Consumes the builder and constructs a [`Eirp`](crate::model::Eirp).
        pub fn build(self) -> crate::model::Eirp {
            crate::model::Eirp {
                value: self.value,
                units: self.units,
            }
        }
    }
}
impl Eirp {
    /// Creates a new builder-style object to manufacture [`Eirp`](crate::model::Eirp).
    pub fn builder() -> crate::model::eirp::Builder {
        crate::model::eirp::Builder::default()
    }
}

/// When writing a match expression against `EirpUnits`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let eirpunits = unimplemented!();
/// match eirpunits {
///     EirpUnits::Dbw => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `eirpunits` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EirpUnits::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EirpUnits::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EirpUnits::NewFeature` is defined.
/// Specifically, when `eirpunits` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EirpUnits::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EirpUnits {
    #[allow(missing_docs)] // documentation missing in model
    Dbw,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EirpUnits {
    fn from(s: &str) -> Self {
        match s {
            "dBW" => EirpUnits::Dbw,
            other => EirpUnits::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EirpUnits {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EirpUnits::from(s))
    }
}
impl EirpUnits {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EirpUnits::Dbw => "dBW",
            EirpUnits::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["dBW"]
    }
}
impl AsRef<str> for EirpUnits {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the uplink spectral <code>Config</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UplinkSpectrumConfig {
    /// <p>Center frequency of an uplink spectral <code>Config</code>. Valid values are between 2025 to 2120 MHz.</p>
    #[doc(hidden)]
    pub center_frequency: std::option::Option<crate::model::Frequency>,
    /// <p>Polarization of an uplink spectral <code>Config</code>. Capturing both <code>"RIGHT_HAND"</code> and <code>"LEFT_HAND"</code> polarization requires two separate configs.</p>
    #[doc(hidden)]
    pub polarization: std::option::Option<crate::model::Polarization>,
}
impl UplinkSpectrumConfig {
    /// <p>Center frequency of an uplink spectral <code>Config</code>. Valid values are between 2025 to 2120 MHz.</p>
    pub fn center_frequency(&self) -> std::option::Option<&crate::model::Frequency> {
        self.center_frequency.as_ref()
    }
    /// <p>Polarization of an uplink spectral <code>Config</code>. Capturing both <code>"RIGHT_HAND"</code> and <code>"LEFT_HAND"</code> polarization requires two separate configs.</p>
    pub fn polarization(&self) -> std::option::Option<&crate::model::Polarization> {
        self.polarization.as_ref()
    }
}
/// See [`UplinkSpectrumConfig`](crate::model::UplinkSpectrumConfig).
pub mod uplink_spectrum_config {

    /// A builder for [`UplinkSpectrumConfig`](crate::model::UplinkSpectrumConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) center_frequency: std::option::Option<crate::model::Frequency>,
        pub(crate) polarization: std::option::Option<crate::model::Polarization>,
    }
    impl Builder {
        /// <p>Center frequency of an uplink spectral <code>Config</code>. Valid values are between 2025 to 2120 MHz.</p>
        pub fn center_frequency(mut self, input: crate::model::Frequency) -> Self {
            self.center_frequency = Some(input);
            self
        }
        /// <p>Center frequency of an uplink spectral <code>Config</code>. Valid values are between 2025 to 2120 MHz.</p>
        pub fn set_center_frequency(
            mut self,
            input: std::option::Option<crate::model::Frequency>,
        ) -> Self {
            self.center_frequency = input;
            self
        }
        /// <p>Polarization of an uplink spectral <code>Config</code>. Capturing both <code>"RIGHT_HAND"</code> and <code>"LEFT_HAND"</code> polarization requires two separate configs.</p>
        pub fn polarization(mut self, input: crate::model::Polarization) -> Self {
            self.polarization = Some(input);
            self
        }
        /// <p>Polarization of an uplink spectral <code>Config</code>. Capturing both <code>"RIGHT_HAND"</code> and <code>"LEFT_HAND"</code> polarization requires two separate configs.</p>
        pub fn set_polarization(
            mut self,
            input: std::option::Option<crate::model::Polarization>,
        ) -> Self {
            self.polarization = input;
            self
        }
        /// Consumes the builder and constructs a [`UplinkSpectrumConfig`](crate::model::UplinkSpectrumConfig).
        pub fn build(self) -> crate::model::UplinkSpectrumConfig {
            crate::model::UplinkSpectrumConfig {
                center_frequency: self.center_frequency,
                polarization: self.polarization,
            }
        }
    }
}
impl UplinkSpectrumConfig {
    /// Creates a new builder-style object to manufacture [`UplinkSpectrumConfig`](crate::model::UplinkSpectrumConfig).
    pub fn builder() -> crate::model::uplink_spectrum_config::Builder {
        crate::model::uplink_spectrum_config::Builder::default()
    }
}

/// When writing a match expression against `Polarization`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let polarization = unimplemented!();
/// match polarization {
///     Polarization::LeftHand => { /* ... */ },
///     Polarization::None => { /* ... */ },
///     Polarization::RightHand => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `polarization` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Polarization::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Polarization::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Polarization::NewFeature` is defined.
/// Specifically, when `polarization` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Polarization::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Polarization {
    #[allow(missing_docs)] // documentation missing in model
    LeftHand,
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    RightHand,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Polarization {
    fn from(s: &str) -> Self {
        match s {
            "LEFT_HAND" => Polarization::LeftHand,
            "NONE" => Polarization::None,
            "RIGHT_HAND" => Polarization::RightHand,
            other => Polarization::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Polarization {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Polarization::from(s))
    }
}
impl Polarization {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Polarization::LeftHand => "LEFT_HAND",
            Polarization::None => "NONE",
            Polarization::RightHand => "RIGHT_HAND",
            Polarization::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LEFT_HAND", "NONE", "RIGHT_HAND"]
    }
}
impl AsRef<str> for Polarization {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Object that describes the frequency.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Frequency {
    /// <p>Frequency value. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.</p>
    #[doc(hidden)]
    pub value: std::option::Option<f64>,
    /// <p>Frequency units.</p>
    #[doc(hidden)]
    pub units: std::option::Option<crate::model::FrequencyUnits>,
}
impl Frequency {
    /// <p>Frequency value. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.</p>
    pub fn value(&self) -> std::option::Option<f64> {
        self.value
    }
    /// <p>Frequency units.</p>
    pub fn units(&self) -> std::option::Option<&crate::model::FrequencyUnits> {
        self.units.as_ref()
    }
}
/// See [`Frequency`](crate::model::Frequency).
pub mod frequency {

    /// A builder for [`Frequency`](crate::model::Frequency).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<f64>,
        pub(crate) units: std::option::Option<crate::model::FrequencyUnits>,
    }
    impl Builder {
        /// <p>Frequency value. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.</p>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>Frequency value. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.</p>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input;
            self
        }
        /// <p>Frequency units.</p>
        pub fn units(mut self, input: crate::model::FrequencyUnits) -> Self {
            self.units = Some(input);
            self
        }
        /// <p>Frequency units.</p>
        pub fn set_units(
            mut self,
            input: std::option::Option<crate::model::FrequencyUnits>,
        ) -> Self {
            self.units = input;
            self
        }
        /// Consumes the builder and constructs a [`Frequency`](crate::model::Frequency).
        pub fn build(self) -> crate::model::Frequency {
            crate::model::Frequency {
                value: self.value,
                units: self.units,
            }
        }
    }
}
impl Frequency {
    /// Creates a new builder-style object to manufacture [`Frequency`](crate::model::Frequency).
    pub fn builder() -> crate::model::frequency::Builder {
        crate::model::frequency::Builder::default()
    }
}

/// When writing a match expression against `FrequencyUnits`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let frequencyunits = unimplemented!();
/// match frequencyunits {
///     FrequencyUnits::Ghz => { /* ... */ },
///     FrequencyUnits::Mhz => { /* ... */ },
///     FrequencyUnits::Khz => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `frequencyunits` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FrequencyUnits::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FrequencyUnits::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FrequencyUnits::NewFeature` is defined.
/// Specifically, when `frequencyunits` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FrequencyUnits::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FrequencyUnits {
    #[allow(missing_docs)] // documentation missing in model
    Ghz,
    #[allow(missing_docs)] // documentation missing in model
    Mhz,
    #[allow(missing_docs)] // documentation missing in model
    Khz,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FrequencyUnits {
    fn from(s: &str) -> Self {
        match s {
            "GHz" => FrequencyUnits::Ghz,
            "MHz" => FrequencyUnits::Mhz,
            "kHz" => FrequencyUnits::Khz,
            other => FrequencyUnits::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FrequencyUnits {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FrequencyUnits::from(s))
    }
}
impl FrequencyUnits {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FrequencyUnits::Ghz => "GHz",
            FrequencyUnits::Mhz => "MHz",
            FrequencyUnits::Khz => "kHz",
            FrequencyUnits::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["GHz", "MHz", "kHz"]
    }
}
impl AsRef<str> for FrequencyUnits {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about how AWS Ground Station should conﬁgure an antenna for downlink demod decode during a contact.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AntennaDownlinkDemodDecodeConfig {
    /// <p>Information about the spectral <code>Config</code>.</p>
    #[doc(hidden)]
    pub spectrum_config: std::option::Option<crate::model::SpectrumConfig>,
    /// <p>Information about the demodulation <code>Config</code>.</p>
    #[doc(hidden)]
    pub demodulation_config: std::option::Option<crate::model::DemodulationConfig>,
    /// <p>Information about the decode <code>Config</code>.</p>
    #[doc(hidden)]
    pub decode_config: std::option::Option<crate::model::DecodeConfig>,
}
impl AntennaDownlinkDemodDecodeConfig {
    /// <p>Information about the spectral <code>Config</code>.</p>
    pub fn spectrum_config(&self) -> std::option::Option<&crate::model::SpectrumConfig> {
        self.spectrum_config.as_ref()
    }
    /// <p>Information about the demodulation <code>Config</code>.</p>
    pub fn demodulation_config(&self) -> std::option::Option<&crate::model::DemodulationConfig> {
        self.demodulation_config.as_ref()
    }
    /// <p>Information about the decode <code>Config</code>.</p>
    pub fn decode_config(&self) -> std::option::Option<&crate::model::DecodeConfig> {
        self.decode_config.as_ref()
    }
}
/// See [`AntennaDownlinkDemodDecodeConfig`](crate::model::AntennaDownlinkDemodDecodeConfig).
pub mod antenna_downlink_demod_decode_config {

    /// A builder for [`AntennaDownlinkDemodDecodeConfig`](crate::model::AntennaDownlinkDemodDecodeConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) spectrum_config: std::option::Option<crate::model::SpectrumConfig>,
        pub(crate) demodulation_config: std::option::Option<crate::model::DemodulationConfig>,
        pub(crate) decode_config: std::option::Option<crate::model::DecodeConfig>,
    }
    impl Builder {
        /// <p>Information about the spectral <code>Config</code>.</p>
        pub fn spectrum_config(mut self, input: crate::model::SpectrumConfig) -> Self {
            self.spectrum_config = Some(input);
            self
        }
        /// <p>Information about the spectral <code>Config</code>.</p>
        pub fn set_spectrum_config(
            mut self,
            input: std::option::Option<crate::model::SpectrumConfig>,
        ) -> Self {
            self.spectrum_config = input;
            self
        }
        /// <p>Information about the demodulation <code>Config</code>.</p>
        pub fn demodulation_config(mut self, input: crate::model::DemodulationConfig) -> Self {
            self.demodulation_config = Some(input);
            self
        }
        /// <p>Information about the demodulation <code>Config</code>.</p>
        pub fn set_demodulation_config(
            mut self,
            input: std::option::Option<crate::model::DemodulationConfig>,
        ) -> Self {
            self.demodulation_config = input;
            self
        }
        /// <p>Information about the decode <code>Config</code>.</p>
        pub fn decode_config(mut self, input: crate::model::DecodeConfig) -> Self {
            self.decode_config = Some(input);
            self
        }
        /// <p>Information about the decode <code>Config</code>.</p>
        pub fn set_decode_config(
            mut self,
            input: std::option::Option<crate::model::DecodeConfig>,
        ) -> Self {
            self.decode_config = input;
            self
        }
        /// Consumes the builder and constructs a [`AntennaDownlinkDemodDecodeConfig`](crate::model::AntennaDownlinkDemodDecodeConfig).
        pub fn build(self) -> crate::model::AntennaDownlinkDemodDecodeConfig {
            crate::model::AntennaDownlinkDemodDecodeConfig {
                spectrum_config: self.spectrum_config,
                demodulation_config: self.demodulation_config,
                decode_config: self.decode_config,
            }
        }
    }
}
impl AntennaDownlinkDemodDecodeConfig {
    /// Creates a new builder-style object to manufacture [`AntennaDownlinkDemodDecodeConfig`](crate::model::AntennaDownlinkDemodDecodeConfig).
    pub fn builder() -> crate::model::antenna_downlink_demod_decode_config::Builder {
        crate::model::antenna_downlink_demod_decode_config::Builder::default()
    }
}

/// <p>Information about the decode <code>Config</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DecodeConfig {
    /// <p>Unvalidated JSON of a decode <code>Config</code>.</p>
    #[doc(hidden)]
    pub unvalidated_json: std::option::Option<std::string::String>,
}
impl DecodeConfig {
    /// <p>Unvalidated JSON of a decode <code>Config</code>.</p>
    pub fn unvalidated_json(&self) -> std::option::Option<&str> {
        self.unvalidated_json.as_deref()
    }
}
/// See [`DecodeConfig`](crate::model::DecodeConfig).
pub mod decode_config {

    /// A builder for [`DecodeConfig`](crate::model::DecodeConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) unvalidated_json: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Unvalidated JSON of a decode <code>Config</code>.</p>
        pub fn unvalidated_json(mut self, input: impl Into<std::string::String>) -> Self {
            self.unvalidated_json = Some(input.into());
            self
        }
        /// <p>Unvalidated JSON of a decode <code>Config</code>.</p>
        pub fn set_unvalidated_json(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.unvalidated_json = input;
            self
        }
        /// Consumes the builder and constructs a [`DecodeConfig`](crate::model::DecodeConfig).
        pub fn build(self) -> crate::model::DecodeConfig {
            crate::model::DecodeConfig {
                unvalidated_json: self.unvalidated_json,
            }
        }
    }
}
impl DecodeConfig {
    /// Creates a new builder-style object to manufacture [`DecodeConfig`](crate::model::DecodeConfig).
    pub fn builder() -> crate::model::decode_config::Builder {
        crate::model::decode_config::Builder::default()
    }
}

/// <p>Information about the demodulation <code>Config</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DemodulationConfig {
    /// <p>Unvalidated JSON of a demodulation <code>Config</code>.</p>
    #[doc(hidden)]
    pub unvalidated_json: std::option::Option<std::string::String>,
}
impl DemodulationConfig {
    /// <p>Unvalidated JSON of a demodulation <code>Config</code>.</p>
    pub fn unvalidated_json(&self) -> std::option::Option<&str> {
        self.unvalidated_json.as_deref()
    }
}
/// See [`DemodulationConfig`](crate::model::DemodulationConfig).
pub mod demodulation_config {

    /// A builder for [`DemodulationConfig`](crate::model::DemodulationConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) unvalidated_json: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Unvalidated JSON of a demodulation <code>Config</code>.</p>
        pub fn unvalidated_json(mut self, input: impl Into<std::string::String>) -> Self {
            self.unvalidated_json = Some(input.into());
            self
        }
        /// <p>Unvalidated JSON of a demodulation <code>Config</code>.</p>
        pub fn set_unvalidated_json(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.unvalidated_json = input;
            self
        }
        /// Consumes the builder and constructs a [`DemodulationConfig`](crate::model::DemodulationConfig).
        pub fn build(self) -> crate::model::DemodulationConfig {
            crate::model::DemodulationConfig {
                unvalidated_json: self.unvalidated_json,
            }
        }
    }
}
impl DemodulationConfig {
    /// Creates a new builder-style object to manufacture [`DemodulationConfig`](crate::model::DemodulationConfig).
    pub fn builder() -> crate::model::demodulation_config::Builder {
        crate::model::demodulation_config::Builder::default()
    }
}

/// <p>Object that describes a spectral <code>Config</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SpectrumConfig {
    /// <p>Center frequency of a spectral <code>Config</code>. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.</p>
    #[doc(hidden)]
    pub center_frequency: std::option::Option<crate::model::Frequency>,
    /// <p>Bandwidth of a spectral <code>Config</code>. AWS Ground Station currently has the following bandwidth limitations:</p>
    /// <ul>
    /// <li> <p>For <code>AntennaDownlinkDemodDecodeconfig</code>, valid values are between 125 kHz to 650 MHz.</p> </li>
    /// <li> <p>For <code>AntennaDownlinkconfig</code> valid values are between 10 kHz to 54 MHz.</p> </li>
    /// <li> <p>For <code>AntennaUplinkConfig</code>, valid values are between 10 kHz to 54 MHz.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub bandwidth: std::option::Option<crate::model::FrequencyBandwidth>,
    /// <p>Polarization of a spectral <code>Config</code>. Capturing both <code>"RIGHT_HAND"</code> and <code>"LEFT_HAND"</code> polarization requires two separate configs.</p>
    #[doc(hidden)]
    pub polarization: std::option::Option<crate::model::Polarization>,
}
impl SpectrumConfig {
    /// <p>Center frequency of a spectral <code>Config</code>. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.</p>
    pub fn center_frequency(&self) -> std::option::Option<&crate::model::Frequency> {
        self.center_frequency.as_ref()
    }
    /// <p>Bandwidth of a spectral <code>Config</code>. AWS Ground Station currently has the following bandwidth limitations:</p>
    /// <ul>
    /// <li> <p>For <code>AntennaDownlinkDemodDecodeconfig</code>, valid values are between 125 kHz to 650 MHz.</p> </li>
    /// <li> <p>For <code>AntennaDownlinkconfig</code> valid values are between 10 kHz to 54 MHz.</p> </li>
    /// <li> <p>For <code>AntennaUplinkConfig</code>, valid values are between 10 kHz to 54 MHz.</p> </li>
    /// </ul>
    pub fn bandwidth(&self) -> std::option::Option<&crate::model::FrequencyBandwidth> {
        self.bandwidth.as_ref()
    }
    /// <p>Polarization of a spectral <code>Config</code>. Capturing both <code>"RIGHT_HAND"</code> and <code>"LEFT_HAND"</code> polarization requires two separate configs.</p>
    pub fn polarization(&self) -> std::option::Option<&crate::model::Polarization> {
        self.polarization.as_ref()
    }
}
/// See [`SpectrumConfig`](crate::model::SpectrumConfig).
pub mod spectrum_config {

    /// A builder for [`SpectrumConfig`](crate::model::SpectrumConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) center_frequency: std::option::Option<crate::model::Frequency>,
        pub(crate) bandwidth: std::option::Option<crate::model::FrequencyBandwidth>,
        pub(crate) polarization: std::option::Option<crate::model::Polarization>,
    }
    impl Builder {
        /// <p>Center frequency of a spectral <code>Config</code>. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.</p>
        pub fn center_frequency(mut self, input: crate::model::Frequency) -> Self {
            self.center_frequency = Some(input);
            self
        }
        /// <p>Center frequency of a spectral <code>Config</code>. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.</p>
        pub fn set_center_frequency(
            mut self,
            input: std::option::Option<crate::model::Frequency>,
        ) -> Self {
            self.center_frequency = input;
            self
        }
        /// <p>Bandwidth of a spectral <code>Config</code>. AWS Ground Station currently has the following bandwidth limitations:</p>
        /// <ul>
        /// <li> <p>For <code>AntennaDownlinkDemodDecodeconfig</code>, valid values are between 125 kHz to 650 MHz.</p> </li>
        /// <li> <p>For <code>AntennaDownlinkconfig</code> valid values are between 10 kHz to 54 MHz.</p> </li>
        /// <li> <p>For <code>AntennaUplinkConfig</code>, valid values are between 10 kHz to 54 MHz.</p> </li>
        /// </ul>
        pub fn bandwidth(mut self, input: crate::model::FrequencyBandwidth) -> Self {
            self.bandwidth = Some(input);
            self
        }
        /// <p>Bandwidth of a spectral <code>Config</code>. AWS Ground Station currently has the following bandwidth limitations:</p>
        /// <ul>
        /// <li> <p>For <code>AntennaDownlinkDemodDecodeconfig</code>, valid values are between 125 kHz to 650 MHz.</p> </li>
        /// <li> <p>For <code>AntennaDownlinkconfig</code> valid values are between 10 kHz to 54 MHz.</p> </li>
        /// <li> <p>For <code>AntennaUplinkConfig</code>, valid values are between 10 kHz to 54 MHz.</p> </li>
        /// </ul>
        pub fn set_bandwidth(
            mut self,
            input: std::option::Option<crate::model::FrequencyBandwidth>,
        ) -> Self {
            self.bandwidth = input;
            self
        }
        /// <p>Polarization of a spectral <code>Config</code>. Capturing both <code>"RIGHT_HAND"</code> and <code>"LEFT_HAND"</code> polarization requires two separate configs.</p>
        pub fn polarization(mut self, input: crate::model::Polarization) -> Self {
            self.polarization = Some(input);
            self
        }
        /// <p>Polarization of a spectral <code>Config</code>. Capturing both <code>"RIGHT_HAND"</code> and <code>"LEFT_HAND"</code> polarization requires two separate configs.</p>
        pub fn set_polarization(
            mut self,
            input: std::option::Option<crate::model::Polarization>,
        ) -> Self {
            self.polarization = input;
            self
        }
        /// Consumes the builder and constructs a [`SpectrumConfig`](crate::model::SpectrumConfig).
        pub fn build(self) -> crate::model::SpectrumConfig {
            crate::model::SpectrumConfig {
                center_frequency: self.center_frequency,
                bandwidth: self.bandwidth,
                polarization: self.polarization,
            }
        }
    }
}
impl SpectrumConfig {
    /// Creates a new builder-style object to manufacture [`SpectrumConfig`](crate::model::SpectrumConfig).
    pub fn builder() -> crate::model::spectrum_config::Builder {
        crate::model::spectrum_config::Builder::default()
    }
}

/// <p>Object that describes the frequency bandwidth. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FrequencyBandwidth {
    /// <p>Frequency bandwidth value. AWS Ground Station currently has the following bandwidth limitations:</p>
    /// <ul>
    /// <li> <p>For <code>AntennaDownlinkDemodDecodeconfig</code>, valid values are between 125 kHz to 650 MHz.</p> </li>
    /// <li> <p>For <code>AntennaDownlinkconfig</code>, valid values are between 10 kHz to 54 MHz.</p> </li>
    /// <li> <p>For <code>AntennaUplinkConfig</code>, valid values are between 10 kHz to 54 MHz.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub value: std::option::Option<f64>,
    /// <p>Frequency bandwidth units.</p>
    #[doc(hidden)]
    pub units: std::option::Option<crate::model::BandwidthUnits>,
}
impl FrequencyBandwidth {
    /// <p>Frequency bandwidth value. AWS Ground Station currently has the following bandwidth limitations:</p>
    /// <ul>
    /// <li> <p>For <code>AntennaDownlinkDemodDecodeconfig</code>, valid values are between 125 kHz to 650 MHz.</p> </li>
    /// <li> <p>For <code>AntennaDownlinkconfig</code>, valid values are between 10 kHz to 54 MHz.</p> </li>
    /// <li> <p>For <code>AntennaUplinkConfig</code>, valid values are between 10 kHz to 54 MHz.</p> </li>
    /// </ul>
    pub fn value(&self) -> std::option::Option<f64> {
        self.value
    }
    /// <p>Frequency bandwidth units.</p>
    pub fn units(&self) -> std::option::Option<&crate::model::BandwidthUnits> {
        self.units.as_ref()
    }
}
/// See [`FrequencyBandwidth`](crate::model::FrequencyBandwidth).
pub mod frequency_bandwidth {

    /// A builder for [`FrequencyBandwidth`](crate::model::FrequencyBandwidth).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<f64>,
        pub(crate) units: std::option::Option<crate::model::BandwidthUnits>,
    }
    impl Builder {
        /// <p>Frequency bandwidth value. AWS Ground Station currently has the following bandwidth limitations:</p>
        /// <ul>
        /// <li> <p>For <code>AntennaDownlinkDemodDecodeconfig</code>, valid values are between 125 kHz to 650 MHz.</p> </li>
        /// <li> <p>For <code>AntennaDownlinkconfig</code>, valid values are between 10 kHz to 54 MHz.</p> </li>
        /// <li> <p>For <code>AntennaUplinkConfig</code>, valid values are between 10 kHz to 54 MHz.</p> </li>
        /// </ul>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>Frequency bandwidth value. AWS Ground Station currently has the following bandwidth limitations:</p>
        /// <ul>
        /// <li> <p>For <code>AntennaDownlinkDemodDecodeconfig</code>, valid values are between 125 kHz to 650 MHz.</p> </li>
        /// <li> <p>For <code>AntennaDownlinkconfig</code>, valid values are between 10 kHz to 54 MHz.</p> </li>
        /// <li> <p>For <code>AntennaUplinkConfig</code>, valid values are between 10 kHz to 54 MHz.</p> </li>
        /// </ul>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input;
            self
        }
        /// <p>Frequency bandwidth units.</p>
        pub fn units(mut self, input: crate::model::BandwidthUnits) -> Self {
            self.units = Some(input);
            self
        }
        /// <p>Frequency bandwidth units.</p>
        pub fn set_units(
            mut self,
            input: std::option::Option<crate::model::BandwidthUnits>,
        ) -> Self {
            self.units = input;
            self
        }
        /// Consumes the builder and constructs a [`FrequencyBandwidth`](crate::model::FrequencyBandwidth).
        pub fn build(self) -> crate::model::FrequencyBandwidth {
            crate::model::FrequencyBandwidth {
                value: self.value,
                units: self.units,
            }
        }
    }
}
impl FrequencyBandwidth {
    /// Creates a new builder-style object to manufacture [`FrequencyBandwidth`](crate::model::FrequencyBandwidth).
    pub fn builder() -> crate::model::frequency_bandwidth::Builder {
        crate::model::frequency_bandwidth::Builder::default()
    }
}

/// When writing a match expression against `BandwidthUnits`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let bandwidthunits = unimplemented!();
/// match bandwidthunits {
///     BandwidthUnits::Ghz => { /* ... */ },
///     BandwidthUnits::Mhz => { /* ... */ },
///     BandwidthUnits::Khz => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `bandwidthunits` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `BandwidthUnits::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `BandwidthUnits::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `BandwidthUnits::NewFeature` is defined.
/// Specifically, when `bandwidthunits` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `BandwidthUnits::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BandwidthUnits {
    #[allow(missing_docs)] // documentation missing in model
    Ghz,
    #[allow(missing_docs)] // documentation missing in model
    Mhz,
    #[allow(missing_docs)] // documentation missing in model
    Khz,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for BandwidthUnits {
    fn from(s: &str) -> Self {
        match s {
            "GHz" => BandwidthUnits::Ghz,
            "MHz" => BandwidthUnits::Mhz,
            "kHz" => BandwidthUnits::Khz,
            other => BandwidthUnits::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for BandwidthUnits {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BandwidthUnits::from(s))
    }
}
impl BandwidthUnits {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BandwidthUnits::Ghz => "GHz",
            BandwidthUnits::Mhz => "MHz",
            BandwidthUnits::Khz => "kHz",
            BandwidthUnits::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["GHz", "MHz", "kHz"]
    }
}
impl AsRef<str> for BandwidthUnits {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the dataflow endpoint <code>Config</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataflowEndpointConfig {
    /// <p>Name of a dataflow endpoint.</p>
    #[doc(hidden)]
    pub dataflow_endpoint_name: std::option::Option<std::string::String>,
    /// <p>Region of a dataflow endpoint.</p>
    #[doc(hidden)]
    pub dataflow_endpoint_region: std::option::Option<std::string::String>,
}
impl DataflowEndpointConfig {
    /// <p>Name of a dataflow endpoint.</p>
    pub fn dataflow_endpoint_name(&self) -> std::option::Option<&str> {
        self.dataflow_endpoint_name.as_deref()
    }
    /// <p>Region of a dataflow endpoint.</p>
    pub fn dataflow_endpoint_region(&self) -> std::option::Option<&str> {
        self.dataflow_endpoint_region.as_deref()
    }
}
/// See [`DataflowEndpointConfig`](crate::model::DataflowEndpointConfig).
pub mod dataflow_endpoint_config {

    /// A builder for [`DataflowEndpointConfig`](crate::model::DataflowEndpointConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dataflow_endpoint_name: std::option::Option<std::string::String>,
        pub(crate) dataflow_endpoint_region: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Name of a dataflow endpoint.</p>
        pub fn dataflow_endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.dataflow_endpoint_name = Some(input.into());
            self
        }
        /// <p>Name of a dataflow endpoint.</p>
        pub fn set_dataflow_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dataflow_endpoint_name = input;
            self
        }
        /// <p>Region of a dataflow endpoint.</p>
        pub fn dataflow_endpoint_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.dataflow_endpoint_region = Some(input.into());
            self
        }
        /// <p>Region of a dataflow endpoint.</p>
        pub fn set_dataflow_endpoint_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dataflow_endpoint_region = input;
            self
        }
        /// Consumes the builder and constructs a [`DataflowEndpointConfig`](crate::model::DataflowEndpointConfig).
        pub fn build(self) -> crate::model::DataflowEndpointConfig {
            crate::model::DataflowEndpointConfig {
                dataflow_endpoint_name: self.dataflow_endpoint_name,
                dataflow_endpoint_region: self.dataflow_endpoint_region,
            }
        }
    }
}
impl DataflowEndpointConfig {
    /// Creates a new builder-style object to manufacture [`DataflowEndpointConfig`](crate::model::DataflowEndpointConfig).
    pub fn builder() -> crate::model::dataflow_endpoint_config::Builder {
        crate::model::dataflow_endpoint_config::Builder::default()
    }
}

/// <p>Object that determines whether tracking should be used during a contact executed with this <code>Config</code> in the mission profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TrackingConfig {
    /// <p>Current setting for autotrack.</p>
    #[doc(hidden)]
    pub autotrack: std::option::Option<crate::model::Criticality>,
}
impl TrackingConfig {
    /// <p>Current setting for autotrack.</p>
    pub fn autotrack(&self) -> std::option::Option<&crate::model::Criticality> {
        self.autotrack.as_ref()
    }
}
/// See [`TrackingConfig`](crate::model::TrackingConfig).
pub mod tracking_config {

    /// A builder for [`TrackingConfig`](crate::model::TrackingConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) autotrack: std::option::Option<crate::model::Criticality>,
    }
    impl Builder {
        /// <p>Current setting for autotrack.</p>
        pub fn autotrack(mut self, input: crate::model::Criticality) -> Self {
            self.autotrack = Some(input);
            self
        }
        /// <p>Current setting for autotrack.</p>
        pub fn set_autotrack(
            mut self,
            input: std::option::Option<crate::model::Criticality>,
        ) -> Self {
            self.autotrack = input;
            self
        }
        /// Consumes the builder and constructs a [`TrackingConfig`](crate::model::TrackingConfig).
        pub fn build(self) -> crate::model::TrackingConfig {
            crate::model::TrackingConfig {
                autotrack: self.autotrack,
            }
        }
    }
}
impl TrackingConfig {
    /// Creates a new builder-style object to manufacture [`TrackingConfig`](crate::model::TrackingConfig).
    pub fn builder() -> crate::model::tracking_config::Builder {
        crate::model::tracking_config::Builder::default()
    }
}

/// When writing a match expression against `Criticality`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let criticality = unimplemented!();
/// match criticality {
///     Criticality::Preferred => { /* ... */ },
///     Criticality::Removed => { /* ... */ },
///     Criticality::Required => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `criticality` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Criticality::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Criticality::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Criticality::NewFeature` is defined.
/// Specifically, when `criticality` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Criticality::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Criticality {
    #[allow(missing_docs)] // documentation missing in model
    Preferred,
    #[allow(missing_docs)] // documentation missing in model
    Removed,
    #[allow(missing_docs)] // documentation missing in model
    Required,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Criticality {
    fn from(s: &str) -> Self {
        match s {
            "PREFERRED" => Criticality::Preferred,
            "REMOVED" => Criticality::Removed,
            "REQUIRED" => Criticality::Required,
            other => Criticality::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Criticality {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Criticality::from(s))
    }
}
impl Criticality {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Criticality::Preferred => "PREFERRED",
            Criticality::Removed => "REMOVED",
            Criticality::Required => "REQUIRED",
            Criticality::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PREFERRED", "REMOVED", "REQUIRED"]
    }
}
impl AsRef<str> for Criticality {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about how AWS Ground Station should configure an antenna for downlink during a contact.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AntennaDownlinkConfig {
    /// <p>Object that describes a spectral <code>Config</code>.</p>
    #[doc(hidden)]
    pub spectrum_config: std::option::Option<crate::model::SpectrumConfig>,
}
impl AntennaDownlinkConfig {
    /// <p>Object that describes a spectral <code>Config</code>.</p>
    pub fn spectrum_config(&self) -> std::option::Option<&crate::model::SpectrumConfig> {
        self.spectrum_config.as_ref()
    }
}
/// See [`AntennaDownlinkConfig`](crate::model::AntennaDownlinkConfig).
pub mod antenna_downlink_config {

    /// A builder for [`AntennaDownlinkConfig`](crate::model::AntennaDownlinkConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) spectrum_config: std::option::Option<crate::model::SpectrumConfig>,
    }
    impl Builder {
        /// <p>Object that describes a spectral <code>Config</code>.</p>
        pub fn spectrum_config(mut self, input: crate::model::SpectrumConfig) -> Self {
            self.spectrum_config = Some(input);
            self
        }
        /// <p>Object that describes a spectral <code>Config</code>.</p>
        pub fn set_spectrum_config(
            mut self,
            input: std::option::Option<crate::model::SpectrumConfig>,
        ) -> Self {
            self.spectrum_config = input;
            self
        }
        /// Consumes the builder and constructs a [`AntennaDownlinkConfig`](crate::model::AntennaDownlinkConfig).
        pub fn build(self) -> crate::model::AntennaDownlinkConfig {
            crate::model::AntennaDownlinkConfig {
                spectrum_config: self.spectrum_config,
            }
        }
    }
}
impl AntennaDownlinkConfig {
    /// Creates a new builder-style object to manufacture [`AntennaDownlinkConfig`](crate::model::AntennaDownlinkConfig).
    pub fn builder() -> crate::model::antenna_downlink_config::Builder {
        crate::model::antenna_downlink_config::Builder::default()
    }
}
