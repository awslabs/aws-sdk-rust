// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn batch_delete_document(&self) -> fluent_builders::BatchDeleteDocument<C> {
        fluent_builders::BatchDeleteDocument::new(self.handle.clone())
    }
    pub fn batch_get_document_status(&self) -> fluent_builders::BatchGetDocumentStatus<C> {
        fluent_builders::BatchGetDocumentStatus::new(self.handle.clone())
    }
    pub fn batch_put_document(&self) -> fluent_builders::BatchPutDocument<C> {
        fluent_builders::BatchPutDocument::new(self.handle.clone())
    }
    pub fn clear_query_suggestions(&self) -> fluent_builders::ClearQuerySuggestions<C> {
        fluent_builders::ClearQuerySuggestions::new(self.handle.clone())
    }
    pub fn create_data_source(&self) -> fluent_builders::CreateDataSource<C> {
        fluent_builders::CreateDataSource::new(self.handle.clone())
    }
    pub fn create_faq(&self) -> fluent_builders::CreateFaq<C> {
        fluent_builders::CreateFaq::new(self.handle.clone())
    }
    pub fn create_index(&self) -> fluent_builders::CreateIndex<C> {
        fluent_builders::CreateIndex::new(self.handle.clone())
    }
    pub fn create_query_suggestions_block_list(
        &self,
    ) -> fluent_builders::CreateQuerySuggestionsBlockList<C> {
        fluent_builders::CreateQuerySuggestionsBlockList::new(self.handle.clone())
    }
    pub fn create_thesaurus(&self) -> fluent_builders::CreateThesaurus<C> {
        fluent_builders::CreateThesaurus::new(self.handle.clone())
    }
    pub fn delete_data_source(&self) -> fluent_builders::DeleteDataSource<C> {
        fluent_builders::DeleteDataSource::new(self.handle.clone())
    }
    pub fn delete_faq(&self) -> fluent_builders::DeleteFaq<C> {
        fluent_builders::DeleteFaq::new(self.handle.clone())
    }
    pub fn delete_index(&self) -> fluent_builders::DeleteIndex<C> {
        fluent_builders::DeleteIndex::new(self.handle.clone())
    }
    pub fn delete_query_suggestions_block_list(
        &self,
    ) -> fluent_builders::DeleteQuerySuggestionsBlockList<C> {
        fluent_builders::DeleteQuerySuggestionsBlockList::new(self.handle.clone())
    }
    pub fn delete_thesaurus(&self) -> fluent_builders::DeleteThesaurus<C> {
        fluent_builders::DeleteThesaurus::new(self.handle.clone())
    }
    pub fn describe_data_source(&self) -> fluent_builders::DescribeDataSource<C> {
        fluent_builders::DescribeDataSource::new(self.handle.clone())
    }
    pub fn describe_faq(&self) -> fluent_builders::DescribeFaq<C> {
        fluent_builders::DescribeFaq::new(self.handle.clone())
    }
    pub fn describe_index(&self) -> fluent_builders::DescribeIndex<C> {
        fluent_builders::DescribeIndex::new(self.handle.clone())
    }
    pub fn describe_query_suggestions_block_list(
        &self,
    ) -> fluent_builders::DescribeQuerySuggestionsBlockList<C> {
        fluent_builders::DescribeQuerySuggestionsBlockList::new(self.handle.clone())
    }
    pub fn describe_query_suggestions_config(
        &self,
    ) -> fluent_builders::DescribeQuerySuggestionsConfig<C> {
        fluent_builders::DescribeQuerySuggestionsConfig::new(self.handle.clone())
    }
    pub fn describe_thesaurus(&self) -> fluent_builders::DescribeThesaurus<C> {
        fluent_builders::DescribeThesaurus::new(self.handle.clone())
    }
    pub fn get_query_suggestions(&self) -> fluent_builders::GetQuerySuggestions<C> {
        fluent_builders::GetQuerySuggestions::new(self.handle.clone())
    }
    pub fn list_data_sources(&self) -> fluent_builders::ListDataSources<C> {
        fluent_builders::ListDataSources::new(self.handle.clone())
    }
    pub fn list_data_source_sync_jobs(&self) -> fluent_builders::ListDataSourceSyncJobs<C> {
        fluent_builders::ListDataSourceSyncJobs::new(self.handle.clone())
    }
    pub fn list_faqs(&self) -> fluent_builders::ListFaqs<C> {
        fluent_builders::ListFaqs::new(self.handle.clone())
    }
    pub fn list_indices(&self) -> fluent_builders::ListIndices<C> {
        fluent_builders::ListIndices::new(self.handle.clone())
    }
    pub fn list_query_suggestions_block_lists(
        &self,
    ) -> fluent_builders::ListQuerySuggestionsBlockLists<C> {
        fluent_builders::ListQuerySuggestionsBlockLists::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn list_thesauri(&self) -> fluent_builders::ListThesauri<C> {
        fluent_builders::ListThesauri::new(self.handle.clone())
    }
    pub fn query(&self) -> fluent_builders::Query<C> {
        fluent_builders::Query::new(self.handle.clone())
    }
    pub fn start_data_source_sync_job(&self) -> fluent_builders::StartDataSourceSyncJob<C> {
        fluent_builders::StartDataSourceSyncJob::new(self.handle.clone())
    }
    pub fn stop_data_source_sync_job(&self) -> fluent_builders::StopDataSourceSyncJob<C> {
        fluent_builders::StopDataSourceSyncJob::new(self.handle.clone())
    }
    pub fn submit_feedback(&self) -> fluent_builders::SubmitFeedback<C> {
        fluent_builders::SubmitFeedback::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_data_source(&self) -> fluent_builders::UpdateDataSource<C> {
        fluent_builders::UpdateDataSource::new(self.handle.clone())
    }
    pub fn update_index(&self) -> fluent_builders::UpdateIndex<C> {
        fluent_builders::UpdateIndex::new(self.handle.clone())
    }
    pub fn update_query_suggestions_block_list(
        &self,
    ) -> fluent_builders::UpdateQuerySuggestionsBlockList<C> {
        fluent_builders::UpdateQuerySuggestionsBlockList::new(self.handle.clone())
    }
    pub fn update_query_suggestions_config(
        &self,
    ) -> fluent_builders::UpdateQuerySuggestionsConfig<C> {
        fluent_builders::UpdateQuerySuggestionsConfig::new(self.handle.clone())
    }
    pub fn update_thesaurus(&self) -> fluent_builders::UpdateThesaurus<C> {
        fluent_builders::UpdateThesaurus::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct BatchDeleteDocument<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_delete_document_input::Builder,
    }
    impl<C> BatchDeleteDocument<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchDeleteDocumentOutput,
            smithy_http::result::SdkError<crate::error::BatchDeleteDocumentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the index that contains the documents to
        /// delete.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
        /// <p>One or more identifiers for documents to delete from the index.</p>
        pub fn document_id_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.document_id_list(inp);
            self
        }
        pub fn set_document_id_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_document_id_list(input);
            self
        }
        /// <p>Maps a particular data source sync job to a particular data
        /// source.</p>
        pub fn data_source_sync_job_metric_target(
            mut self,
            input: crate::model::DataSourceSyncJobMetricTarget,
        ) -> Self {
            self.inner = self.inner.data_source_sync_job_metric_target(input);
            self
        }
        pub fn set_data_source_sync_job_metric_target(
            mut self,
            input: std::option::Option<crate::model::DataSourceSyncJobMetricTarget>,
        ) -> Self {
            self.inner = self.inner.set_data_source_sync_job_metric_target(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchGetDocumentStatus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_get_document_status_input::Builder,
    }
    impl<C> BatchGetDocumentStatus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchGetDocumentStatusOutput,
            smithy_http::result::SdkError<crate::error::BatchGetDocumentStatusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the index to add documents to. The index ID is
        /// returned by the <a href="https://docs.aws.amazon.com/kendra/latest/dg/API_CreateIndex.html"> CreateIndex
        /// </a> operation.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
        /// <p>A list of <code>DocumentInfo</code> objects that identify the
        /// documents for which to get the status. You identify the documents by
        /// their document ID and optional attributes.</p>
        pub fn document_info_list(mut self, inp: impl Into<crate::model::DocumentInfo>) -> Self {
            self.inner = self.inner.document_info_list(inp);
            self
        }
        pub fn set_document_info_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DocumentInfo>>,
        ) -> Self {
            self.inner = self.inner.set_document_info_list(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchPutDocument<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_put_document_input::Builder,
    }
    impl<C> BatchPutDocument<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchPutDocumentOutput,
            smithy_http::result::SdkError<crate::error::BatchPutDocumentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the index to add the documents to. You need to
        /// create the index first using the <code>CreateIndex</code>
        /// operation.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a role that is allowed to run the
        /// <code>BatchPutDocument</code> operation. For more information, see
        /// <a href="https://docs.aws.amazon.com/kendra/latest/dg/iam-roles.html">IAM
        /// Roles for Amazon Kendra</a>.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>One or more documents to add to the index.</p>
        /// <p>Documents can include custom attributes. For example,
        /// 'DataSourceId' and 'DataSourceSyncJobId' are custom
        /// attributes that provide information on the synchronization
        /// of documents running on a data source. Note,
        /// 'DataSourceSyncJobId' could be an optional custom attribute
        /// as Amazon Kendra will use the ID of a running sync job.</p>
        /// <p>Documents have the following file size limits.</p>
        /// <ul>
        /// <li>
        /// <p>5 MB total size for inline documents</p>
        /// </li>
        /// <li>
        /// <p>50 MB total size for files from an S3 bucket</p>
        /// </li>
        /// <li>
        /// <p>5 MB extracted text for any file</p>
        /// </li>
        /// </ul>
        /// <p>For more information about file size and transaction per second
        /// quotas, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/quotas.html">Quotas</a>.</p>
        pub fn documents(mut self, inp: impl Into<crate::model::Document>) -> Self {
            self.inner = self.inner.documents(inp);
            self
        }
        pub fn set_documents(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Document>>,
        ) -> Self {
            self.inner = self.inner.set_documents(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ClearQuerySuggestions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::clear_query_suggestions_input::Builder,
    }
    impl<C> ClearQuerySuggestions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ClearQuerySuggestionsOutput,
            smithy_http::result::SdkError<crate::error::ClearQuerySuggestionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the index you want to clear query suggestions from.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDataSource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_data_source_input::Builder,
    }
    impl<C> CreateDataSource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDataSourceOutput,
            smithy_http::result::SdkError<crate::error::CreateDataSourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique name for the data source. A data source name can't be changed
        /// without deleting and recreating the data source.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The identifier of the index that should be associated with this data
        /// source.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
        /// <p>The type of repository that contains the data source.</p>
        pub fn r#type(mut self, input: crate::model::DataSourceType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::DataSourceType>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>The connector configuration information that is required to access the
        /// repository.</p>
        /// <p>You can't specify the <code>Configuration</code> parameter when the
        /// <code>Type</code> parameter is set to <code>CUSTOM</code>. If you do,
        /// you receive a <code>ValidationException</code> exception.</p>
        /// <p>The <code>Configuration</code> parameter is required for all other
        /// data sources.</p>
        pub fn configuration(mut self, input: crate::model::DataSourceConfiguration) -> Self {
            self.inner = self.inner.configuration(input);
            self
        }
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::DataSourceConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_configuration(input);
            self
        }
        /// <p>A description for the data source.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Sets the frequency that Amazon Kendra will check the documents in your
        /// repository and update the index. If you don't set a schedule Amazon Kendra
        /// will not periodically update the index. You can call the
        /// <code>StartDataSourceSyncJob</code> operation to update the
        /// index.</p>
        /// <p>You can't specify the <code>Schedule</code> parameter when the
        /// <code>Type</code> parameter is set to <code>CUSTOM</code>. If you do,
        /// you receive a <code>ValidationException</code> exception.</p>
        pub fn schedule(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.schedule(input);
            self
        }
        pub fn set_schedule(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_schedule(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a role with permission to access the
        /// data source. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/iam-roles.html">IAM Roles for
        /// Amazon Kendra</a>.</p>
        /// <p>You can't specify the <code>RoleArn</code> parameter when the
        /// <code>Type</code> parameter is set to <code>CUSTOM</code>. If you do,
        /// you receive a <code>ValidationException</code> exception.</p>
        /// <p>The <code>RoleArn</code> parameter is required for all other data
        /// sources.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>A list of key-value pairs that identify the data source. You can use
        /// the tags to identify and organize your resources and to control access to
        /// resources.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>A token that you provide to identify the request to create a data
        /// source. Multiple calls to the <code>CreateDataSource</code> operation with
        /// the same client token will create only one data source.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateFaq<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_faq_input::Builder,
    }
    impl<C> CreateFaq<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateFaqOutput,
            smithy_http::result::SdkError<crate::error::CreateFaqError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the index that contains the FAQ.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
        /// <p>The name that should be associated with the FAQ.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A description of the FAQ.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The S3 location of the FAQ input data.</p>
        pub fn s3_path(mut self, input: crate::model::S3Path) -> Self {
            self.inner = self.inner.s3_path(input);
            self
        }
        pub fn set_s3_path(mut self, input: std::option::Option<crate::model::S3Path>) -> Self {
            self.inner = self.inner.set_s3_path(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a role with permission to access the S3 bucket that
        /// contains the FAQs. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/iam-roles.html">IAM Roles for Amazon Kendra</a>.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>A list of key-value pairs that identify the FAQ. You can use the tags to identify and
        /// organize your resources and to control access to resources.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The format of the input file. You can choose between a basic CSV format, a CSV format
        /// that includes customs attributes in a header, and a JSON format that includes custom
        /// attributes.</p>
        /// <p>The format must match the format of the file stored in the S3 bucket identified in the
        /// <code>S3Path</code> parameter.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/in-creating-faq.html">Adding questions and
        /// answers</a>.</p>
        pub fn file_format(mut self, input: crate::model::FaqFileFormat) -> Self {
            self.inner = self.inner.file_format(input);
            self
        }
        pub fn set_file_format(
            mut self,
            input: std::option::Option<crate::model::FaqFileFormat>,
        ) -> Self {
            self.inner = self.inner.set_file_format(input);
            self
        }
        /// <p>A token that you provide to identify the request to create a FAQ. Multiple calls to
        /// the <code>CreateFaqRequest</code> operation with the same client token will create only
        /// one FAQ. </p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateIndex<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_index_input::Builder,
    }
    impl<C> CreateIndex<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateIndexOutput,
            smithy_http::result::SdkError<crate::error::CreateIndexError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name for the new index.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The Amazon Kendra edition to use for the index. Choose
        /// <code>DEVELOPER_EDITION</code> for indexes intended for development,
        /// testing, or proof of concept. Use <code>ENTERPRISE_EDITION</code> for your
        /// production databases. Once you set the edition for an index, it can't be
        /// changed. </p>
        /// <p>The <code>Edition</code> parameter is optional. If you don't supply a
        /// value, the default is <code>ENTERPRISE_EDITION</code>.</p>
        /// <p>For more information on quota limits for enterprise and developer editions,
        /// see <a href="https://docs.aws.amazon.com/kendra/latest/dg/quotas.html">Quotas</a>.</p>
        pub fn edition(mut self, input: crate::model::IndexEdition) -> Self {
            self.inner = self.inner.edition(input);
            self
        }
        pub fn set_edition(
            mut self,
            input: std::option::Option<crate::model::IndexEdition>,
        ) -> Self {
            self.inner = self.inner.set_edition(input);
            self
        }
        /// <p>An AWS Identity and Access Management (IAM) role that gives
        /// Amazon Kendra permissions to access your Amazon CloudWatch logs and
        /// metrics. This is also the role used when you use the
        /// <code>BatchPutDocument</code> operation to index documents from an
        /// Amazon S3 bucket.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>The identifier of the AWS KMS customer managed key (CMK) to use to
        /// encrypt data indexed by Amazon Kendra. Amazon Kendra doesn't support
        /// asymmetric CMKs.</p>
        pub fn server_side_encryption_configuration(
            mut self,
            input: crate::model::ServerSideEncryptionConfiguration,
        ) -> Self {
            self.inner = self.inner.server_side_encryption_configuration(input);
            self
        }
        pub fn set_server_side_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::ServerSideEncryptionConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_server_side_encryption_configuration(input);
            self
        }
        /// <p>A description for the index.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>A token that you provide to identify the request to create an index.
        /// Multiple calls to the <code>CreateIndex</code> operation with the same
        /// client token will create only one index.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>A list of key-value pairs that identify the index. You can use the
        /// tags to identify and organize your resources and to control access to
        /// resources.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The user token configuration.</p>
        pub fn user_token_configurations(
            mut self,
            inp: impl Into<crate::model::UserTokenConfiguration>,
        ) -> Self {
            self.inner = self.inner.user_token_configurations(inp);
            self
        }
        pub fn set_user_token_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UserTokenConfiguration>>,
        ) -> Self {
            self.inner = self.inner.set_user_token_configurations(input);
            self
        }
        /// <p>The user context policy.</p>
        /// <dl>
        /// <dt>ATTRIBUTE_FILTER</dt>
        /// <dd>
        /// <p>All indexed content is searchable and displayable
        /// for all users. If there is an access control list, it
        /// is ignored. You can filter on user and group attributes.
        /// </p>
        /// </dd>
        /// <dt>USER_TOKEN</dt>
        /// <dd>
        /// <p>Enables SSO and token-based user access control.
        /// All documents with no access control and all documents
        /// accessible to the user will be searchable and
        /// displayable.
        /// </p>
        /// </dd>
        /// </dl>
        pub fn user_context_policy(mut self, input: crate::model::UserContextPolicy) -> Self {
            self.inner = self.inner.user_context_policy(input);
            self
        }
        pub fn set_user_context_policy(
            mut self,
            input: std::option::Option<crate::model::UserContextPolicy>,
        ) -> Self {
            self.inner = self.inner.set_user_context_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateQuerySuggestionsBlockList<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_query_suggestions_block_list_input::Builder,
    }
    impl<C> CreateQuerySuggestionsBlockList<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateQuerySuggestionsBlockListOutput,
            smithy_http::result::SdkError<crate::error::CreateQuerySuggestionsBlockListError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the index you want to create a query suggestions block list for.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
        /// <p>A user friendly name for the block list.</p>
        /// <p>For example, the block list named 'offensive-words' includes all
        /// offensive words that could appear in user queries and need to be
        /// blocked from suggestions.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A user-friendly description for the block list.</p>
        /// <p>For example, the description "List of all offensive words that can
        /// appear in user queries and need to be blocked from suggestions."</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The S3 path to your block list text file in your S3 bucket.</p>
        /// <p>Each block word or phrase should be on a separate line in a text file.</p>
        /// <p>For information on the current quota limits for block lists, see
        /// <a href="https://docs.aws.amazon.com/kendra/latest/dg/quotas.html">Quotas
        /// for Amazon Kendra</a>.</p>
        pub fn source_s3_path(mut self, input: crate::model::S3Path) -> Self {
            self.inner = self.inner.source_s3_path(input);
            self
        }
        pub fn set_source_s3_path(
            mut self,
            input: std::option::Option<crate::model::S3Path>,
        ) -> Self {
            self.inner = self.inner.set_source_s3_path(input);
            self
        }
        /// <p>A token that you provide to identify the request to create a
        /// query suggestions block list.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The IAM (Identity and Access Management) role used by Amazon Kendra to
        /// access the block list text file in your S3 bucket.</p>
        /// <p>You need permissions to the role ARN (Amazon Resource Name).
        /// The role needs S3 read permissions to your file in S3 and needs
        /// to give STS (Security Token Service) assume role permissions
        /// to Amazon Kendra.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>A tag that you can assign to a block list that categorizes
        /// the block list.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateThesaurus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_thesaurus_input::Builder,
    }
    impl<C> CreateThesaurus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateThesaurusOutput,
            smithy_http::result::SdkError<crate::error::CreateThesaurusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier of the index for the new thesaurus.
        /// </p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
        /// <p>The name for the new thesaurus.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The description for the new thesaurus.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>An AWS Identity and Access Management (IAM) role that gives Amazon Kendra permissions
        /// to access thesaurus file specified in <code>SourceS3Path</code>.
        /// </p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>A list of key-value pairs that identify the thesaurus. You can use
        /// the tags to identify and organize your resources and to control
        /// access to resources.
        /// </p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The thesaurus file Amazon S3 source path.
        /// </p>
        pub fn source_s3_path(mut self, input: crate::model::S3Path) -> Self {
            self.inner = self.inner.source_s3_path(input);
            self
        }
        pub fn set_source_s3_path(
            mut self,
            input: std::option::Option<crate::model::S3Path>,
        ) -> Self {
            self.inner = self.inner.set_source_s3_path(input);
            self
        }
        /// <p>A token that you provide to identify the request to create a
        /// thesaurus. Multiple calls to the <code>CreateThesaurus</code> operation
        /// with the same client token will create only one index.
        /// </p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDataSource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_data_source_input::Builder,
    }
    impl<C> DeleteDataSource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDataSourceOutput,
            smithy_http::result::SdkError<crate::error::DeleteDataSourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier of the data source to delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The unique identifier of the index associated with the data
        /// source.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFaq<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_faq_input::Builder,
    }
    impl<C> DeleteFaq<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFaqOutput,
            smithy_http::result::SdkError<crate::error::DeleteFaqError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the FAQ to remove.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The index to remove the FAQ from.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteIndex<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_index_input::Builder,
    }
    impl<C> DeleteIndex<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteIndexOutput,
            smithy_http::result::SdkError<crate::error::DeleteIndexError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the index to delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteQuerySuggestionsBlockList<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_query_suggestions_block_list_input::Builder,
    }
    impl<C> DeleteQuerySuggestionsBlockList<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteQuerySuggestionsBlockListOutput,
            smithy_http::result::SdkError<crate::error::DeleteQuerySuggestionsBlockListError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the you want to delete a block list from.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
        /// <p>The unique identifier of the block list that needs to be deleted.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteThesaurus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_thesaurus_input::Builder,
    }
    impl<C> DeleteThesaurus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteThesaurusOutput,
            smithy_http::result::SdkError<crate::error::DeleteThesaurusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the thesaurus to delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The identifier of the index associated with the thesaurus to delete.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeDataSource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_data_source_input::Builder,
    }
    impl<C> DescribeDataSource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeDataSourceOutput,
            smithy_http::result::SdkError<crate::error::DescribeDataSourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier of the data source to describe.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The identifier of the index that contains the data source.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFaq<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_faq_input::Builder,
    }
    impl<C> DescribeFaq<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFaqOutput,
            smithy_http::result::SdkError<crate::error::DescribeFaqError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier of the FAQ.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The identifier of the index that contains the FAQ.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeIndex<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_index_input::Builder,
    }
    impl<C> DescribeIndex<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeIndexOutput,
            smithy_http::result::SdkError<crate::error::DescribeIndexError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the index to describe.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeQuerySuggestionsBlockList<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_query_suggestions_block_list_input::Builder,
    }
    impl<C> DescribeQuerySuggestionsBlockList<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeQuerySuggestionsBlockListOutput,
            smithy_http::result::SdkError<crate::error::DescribeQuerySuggestionsBlockListError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the index for the block list.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
        /// <p>The unique identifier of the block list.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeQuerySuggestionsConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_query_suggestions_config_input::Builder,
    }
    impl<C> DescribeQuerySuggestionsConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeQuerySuggestionsConfigOutput,
            smithy_http::result::SdkError<crate::error::DescribeQuerySuggestionsConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the index you want to describe query suggestions
        /// settings for.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeThesaurus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_thesaurus_input::Builder,
    }
    impl<C> DescribeThesaurus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeThesaurusOutput,
            smithy_http::result::SdkError<crate::error::DescribeThesaurusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the thesaurus to describe.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The identifier of the index associated with the thesaurus to describe.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetQuerySuggestions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_query_suggestions_input::Builder,
    }
    impl<C> GetQuerySuggestions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetQuerySuggestionsOutput,
            smithy_http::result::SdkError<crate::error::GetQuerySuggestionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the index you want to get query suggestions from.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
        /// <p>The text of a user's query to generate query suggestions.</p>
        /// <p>A query is suggested if the query prefix matches
        /// what a user starts to type as their query.</p>
        /// <p>Amazon Kendra does not show any suggestions if a user
        /// types fewer than two characters or more than 60 characters.
        /// A query must also have at least one search result and contain
        /// at least one word of more than four characters.</p>
        pub fn query_text(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_text(input);
            self
        }
        pub fn set_query_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_query_text(input);
            self
        }
        /// <p>The maximum number of query suggestions you want to show
        /// to your users.</p>
        pub fn max_suggestions_count(mut self, input: i32) -> Self {
            self.inner = self.inner.max_suggestions_count(input);
            self
        }
        pub fn set_max_suggestions_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_suggestions_count(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDataSources<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_data_sources_input::Builder,
    }
    impl<C> ListDataSources<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDataSourcesOutput,
            smithy_http::result::SdkError<crate::error::ListDataSourcesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the index that contains the data source.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
        /// <p>If the previous response was incomplete (because there is more data to
        /// retrieve), Amazon Kendra returns a pagination token in the response. You
        /// can use this pagination token to retrieve the next set of data sources
        /// (<code>DataSourceSummaryItems</code>). </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of data sources to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDataSourceSyncJobs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_data_source_sync_jobs_input::Builder,
    }
    impl<C> ListDataSourceSyncJobs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDataSourceSyncJobsOutput,
            smithy_http::result::SdkError<crate::error::ListDataSourceSyncJobsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the data source.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The identifier of the index that contains the data source.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
        /// <p>If the result of the previous request to
        /// <code>GetDataSourceSyncJobHistory</code> was truncated, include the
        /// <code>NextToken</code> to fetch the next set of jobs.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of synchronization jobs to return in the response.
        /// If there are fewer results in the list, this response contains only the
        /// actual results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>When specified, the synchronization jobs returned in the list are
        /// limited to jobs between the specified dates. </p>
        pub fn start_time_filter(mut self, input: crate::model::TimeRange) -> Self {
            self.inner = self.inner.start_time_filter(input);
            self
        }
        pub fn set_start_time_filter(
            mut self,
            input: std::option::Option<crate::model::TimeRange>,
        ) -> Self {
            self.inner = self.inner.set_start_time_filter(input);
            self
        }
        /// <p>When specified, only returns synchronization jobs with the
        /// <code>Status</code> field equal to the specified status.</p>
        pub fn status_filter(mut self, input: crate::model::DataSourceSyncJobStatus) -> Self {
            self.inner = self.inner.status_filter(input);
            self
        }
        pub fn set_status_filter(
            mut self,
            input: std::option::Option<crate::model::DataSourceSyncJobStatus>,
        ) -> Self {
            self.inner = self.inner.set_status_filter(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFaqs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_faqs_input::Builder,
    }
    impl<C> ListFaqs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFaqsOutput,
            smithy_http::result::SdkError<crate::error::ListFaqsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The index that contains the FAQ lists.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
        /// <p>If the result of the previous request to <code>ListFaqs</code> was truncated, include
        /// the <code>NextToken</code> to fetch the next set of FAQs.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of FAQs to return in the response. If there are fewer results in
        /// the list, this response contains only the actual results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListIndices<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_indices_input::Builder,
    }
    impl<C> ListIndices<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListIndicesOutput,
            smithy_http::result::SdkError<crate::error::ListIndicesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>If the previous response was incomplete (because there is more data to
        /// retrieve), Amazon Kendra returns a pagination token in the response. You
        /// can use this pagination token to retrieve the next set of indexes
        /// (<code>DataSourceSummaryItems</code>). </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of data sources to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListQuerySuggestionsBlockLists<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_query_suggestions_block_lists_input::Builder,
    }
    impl<C> ListQuerySuggestionsBlockLists<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListQuerySuggestionsBlockListsOutput,
            smithy_http::result::SdkError<crate::error::ListQuerySuggestionsBlockListsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the index for a list of all block lists that exist for
        /// that index.</p>
        /// <p>For information on the current quota limits for block lists, see
        /// <a href="https://docs.aws.amazon.com/kendra/latest/dg/quotas.html">Quotas
        /// for Amazon Kendra</a>.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
        /// <p>If the previous response was incomplete (because there is more data to retrieve),
        /// Amazon Kendra returns a pagination token in the response. You can use this pagination
        /// token to retrieve the next set of block lists (<code>BlockListSummaryItems</code>).</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of block lists to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the index, FAQ, or data source to
        /// get a list of tags for.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListThesauri<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_thesauri_input::Builder,
    }
    impl<C> ListThesauri<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListThesauriOutput,
            smithy_http::result::SdkError<crate::error::ListThesauriError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the index associated with the thesaurus to list.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
        /// <p>If the previous response was incomplete (because there is more data to retrieve),
        /// Amazon Kendra returns a pagination token in the response. You can use this pagination token to
        /// retrieve the next set of thesauri (<code>ThesaurusSummaryItems</code>).
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of thesauri to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct Query<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::query_input::Builder,
    }
    impl<C> Query<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::QueryOutput,
            smithy_http::result::SdkError<crate::error::QueryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier of the index to search. The identifier is
        /// returned in the response from the <code>CreateIndex</code>
        /// operation.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
        /// <p>The text to search for.</p>
        pub fn query_text(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_text(input);
            self
        }
        pub fn set_query_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_query_text(input);
            self
        }
        /// <p>Enables filtered searches based on document attributes. You can only
        /// provide one attribute filter; however, the <code>AndAllFilters</code>,
        /// <code>NotFilter</code>, and <code>OrAllFilters</code> parameters
        /// contain a list of other filters.</p>
        /// <p>The <code>AttributeFilter</code> parameter enables you to create a
        /// set of filtering rules that a document must satisfy to be included in
        /// the query results.</p>
        pub fn attribute_filter(mut self, input: crate::model::AttributeFilter) -> Self {
            self.inner = self.inner.attribute_filter(input);
            self
        }
        pub fn set_attribute_filter(
            mut self,
            input: std::option::Option<crate::model::AttributeFilter>,
        ) -> Self {
            self.inner = self.inner.set_attribute_filter(input);
            self
        }
        /// <p>An array of documents attributes. Amazon Kendra returns a count for
        /// each attribute key specified. You can use this information to help
        /// narrow the search for your user.</p>
        pub fn facets(mut self, inp: impl Into<crate::model::Facet>) -> Self {
            self.inner = self.inner.facets(inp);
            self
        }
        pub fn set_facets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Facet>>,
        ) -> Self {
            self.inner = self.inner.set_facets(input);
            self
        }
        /// <p>An array of document attributes to include in the response. No other
        /// document attributes are included in the response. By default all
        /// document attributes are included in the response. </p>
        pub fn requested_document_attributes(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.requested_document_attributes(inp);
            self
        }
        pub fn set_requested_document_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_requested_document_attributes(input);
            self
        }
        /// <p>Sets the type of query. Only results for the specified query type
        /// are returned.</p>
        pub fn query_result_type_filter(mut self, input: crate::model::QueryResultType) -> Self {
            self.inner = self.inner.query_result_type_filter(input);
            self
        }
        pub fn set_query_result_type_filter(
            mut self,
            input: std::option::Option<crate::model::QueryResultType>,
        ) -> Self {
            self.inner = self.inner.set_query_result_type_filter(input);
            self
        }
        /// <p>Overrides relevance tuning configurations of fields or attributes set at the index level.</p>
        /// <p>If you use this API to override the relevance tuning configured at the index
        /// level, but there is no relevance tuning configured at the index level, then Amazon Kendra does not apply any relevance tuning.</p>
        /// <p>If there is relevance tuning configured at the index level, but you do not use this API
        /// to override any relevance tuning in the index, then Amazon Kendra uses the relevance tuning that is configured at the index level.</p>
        /// <p>If there is relevance tuning configured for fields at the index level,
        /// but you use this API to override only some of these fields, then for the fields you did not override,
        /// the importance is set to 1.</p>
        pub fn document_relevance_override_configurations(
            mut self,
            inp: impl Into<crate::model::DocumentRelevanceConfiguration>,
        ) -> Self {
            self.inner = self.inner.document_relevance_override_configurations(inp);
            self
        }
        pub fn set_document_relevance_override_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DocumentRelevanceConfiguration>>,
        ) -> Self {
            self.inner = self
                .inner
                .set_document_relevance_override_configurations(input);
            self
        }
        /// <p>Query results are returned in pages the size of the
        /// <code>PageSize</code> parameter. By default, Amazon Kendra returns
        /// the first page of results. Use this parameter to get result pages after
        /// the first one.</p>
        pub fn page_number(mut self, input: i32) -> Self {
            self.inner = self.inner.page_number(input);
            self
        }
        pub fn set_page_number(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_number(input);
            self
        }
        /// <p>Sets the number of results that are returned in each page of
        /// results. The default page size is 10. The maximum number of results
        /// returned is 100. If you ask for more than 100 results, only 100 are
        /// returned.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.page_size(input);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
        /// <p>Provides information that determines how the results of the query
        /// are sorted. You can set the field that Amazon Kendra should sort the results
        /// on, and specify whether the results should be sorted in ascending or
        /// descending order. In the case of ties in sorting the results, the
        /// results are sorted by relevance.</p>
        /// <p>If you don't provide sorting configuration, the results are sorted
        /// by the relevance that Amazon Kendra determines for the result.</p>
        pub fn sorting_configuration(mut self, input: crate::model::SortingConfiguration) -> Self {
            self.inner = self.inner.sorting_configuration(input);
            self
        }
        pub fn set_sorting_configuration(
            mut self,
            input: std::option::Option<crate::model::SortingConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_sorting_configuration(input);
            self
        }
        /// <p>The user context token.</p>
        pub fn user_context(mut self, input: crate::model::UserContext) -> Self {
            self.inner = self.inner.user_context(input);
            self
        }
        pub fn set_user_context(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.inner = self.inner.set_user_context(input);
            self
        }
        /// <p>Provides an identifier for a specific user. The
        /// <code>VisitorId</code> should be a unique identifier, such as a
        /// GUID. Don't use personally identifiable information, such as the user's
        /// email address, as the <code>VisitorId</code>.</p>
        pub fn visitor_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.visitor_id(input);
            self
        }
        pub fn set_visitor_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_visitor_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartDataSourceSyncJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_data_source_sync_job_input::Builder,
    }
    impl<C> StartDataSourceSyncJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartDataSourceSyncJobOutput,
            smithy_http::result::SdkError<crate::error::StartDataSourceSyncJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the data source to synchronize.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The identifier of the index that contains the data source.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopDataSourceSyncJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_data_source_sync_job_input::Builder,
    }
    impl<C> StopDataSourceSyncJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopDataSourceSyncJobOutput,
            smithy_http::result::SdkError<crate::error::StopDataSourceSyncJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the data source for which to stop the
        /// synchronization jobs.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The identifier of the index that contains the data source.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SubmitFeedback<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::submit_feedback_input::Builder,
    }
    impl<C> SubmitFeedback<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SubmitFeedbackOutput,
            smithy_http::result::SdkError<crate::error::SubmitFeedbackError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the index that was queried.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
        /// <p>The identifier of the specific query for which you are submitting
        /// feedback. The query ID is returned in the response to the
        /// <code>Query</code> operation.</p>
        pub fn query_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_id(input);
            self
        }
        pub fn set_query_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_query_id(input);
            self
        }
        /// <p>Tells Amazon Kendra that a particular search result link was chosen
        /// by the user. </p>
        pub fn click_feedback_items(mut self, inp: impl Into<crate::model::ClickFeedback>) -> Self {
            self.inner = self.inner.click_feedback_items(inp);
            self
        }
        pub fn set_click_feedback_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ClickFeedback>>,
        ) -> Self {
            self.inner = self.inner.set_click_feedback_items(input);
            self
        }
        /// <p>Provides Amazon Kendra with relevant or not relevant feedback for
        /// whether a particular item was relevant to the search.</p>
        pub fn relevance_feedback_items(
            mut self,
            inp: impl Into<crate::model::RelevanceFeedback>,
        ) -> Self {
            self.inner = self.inner.relevance_feedback_items(inp);
            self
        }
        pub fn set_relevance_feedback_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RelevanceFeedback>>,
        ) -> Self {
            self.inner = self.inner.set_relevance_feedback_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the index, FAQ, or data source to
        /// tag.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>A list of tag keys to add to the index, FAQ, or data source. If a tag
        /// already exists, the existing value is replaced with the new value.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the index, FAQ, or data source to
        /// remove the tag from.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>A list of tag keys to remove from the index, FAQ, or data source. If a
        /// tag key does not exist on the resource, it is ignored.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDataSource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_data_source_input::Builder,
    }
    impl<C> UpdateDataSource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDataSourceOutput,
            smithy_http::result::SdkError<crate::error::UpdateDataSourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier of the data source to update.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The name of the data source to update. The name of the data source
        /// can't be updated. To rename a data source you must delete the data source
        /// and re-create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The identifier of the index that contains the data source to
        /// update.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
        /// <p>Configuration information for a Amazon Kendra data source.</p>
        pub fn configuration(mut self, input: crate::model::DataSourceConfiguration) -> Self {
            self.inner = self.inner.configuration(input);
            self
        }
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::DataSourceConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_configuration(input);
            self
        }
        /// <p>The new description for the data source.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The new update schedule for the data source.</p>
        pub fn schedule(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.schedule(input);
            self
        }
        pub fn set_schedule(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_schedule(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the new role to use when the data
        /// source is accessing resources on your behalf.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateIndex<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_index_input::Builder,
    }
    impl<C> UpdateIndex<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateIndexOutput,
            smithy_http::result::SdkError<crate::error::UpdateIndexError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the index to update.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The name of the index to update.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A new IAM role that gives Amazon Kendra permission to access your
        /// Amazon CloudWatch logs.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>A new description for the index.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The document metadata to update. </p>
        pub fn document_metadata_configuration_updates(
            mut self,
            inp: impl Into<crate::model::DocumentMetadataConfiguration>,
        ) -> Self {
            self.inner = self.inner.document_metadata_configuration_updates(inp);
            self
        }
        pub fn set_document_metadata_configuration_updates(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DocumentMetadataConfiguration>>,
        ) -> Self {
            self.inner = self
                .inner
                .set_document_metadata_configuration_updates(input);
            self
        }
        /// <p>Sets the number of additional storage and query capacity units that
        /// should be used by the index. You can change the capacity of the index up
        /// to 5 times per day.</p>
        /// <p>If you are using extra storage units, you can't reduce the storage
        /// capacity below that required to meet the storage needs for your
        /// index.</p>
        pub fn capacity_units(mut self, input: crate::model::CapacityUnitsConfiguration) -> Self {
            self.inner = self.inner.capacity_units(input);
            self
        }
        pub fn set_capacity_units(
            mut self,
            input: std::option::Option<crate::model::CapacityUnitsConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_capacity_units(input);
            self
        }
        /// <p>The user token configuration.</p>
        pub fn user_token_configurations(
            mut self,
            inp: impl Into<crate::model::UserTokenConfiguration>,
        ) -> Self {
            self.inner = self.inner.user_token_configurations(inp);
            self
        }
        pub fn set_user_token_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UserTokenConfiguration>>,
        ) -> Self {
            self.inner = self.inner.set_user_token_configurations(input);
            self
        }
        /// <p>The user user token context policy.</p>
        pub fn user_context_policy(mut self, input: crate::model::UserContextPolicy) -> Self {
            self.inner = self.inner.user_context_policy(input);
            self
        }
        pub fn set_user_context_policy(
            mut self,
            input: std::option::Option<crate::model::UserContextPolicy>,
        ) -> Self {
            self.inner = self.inner.set_user_context_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateQuerySuggestionsBlockList<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_query_suggestions_block_list_input::Builder,
    }
    impl<C> UpdateQuerySuggestionsBlockList<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateQuerySuggestionsBlockListOutput,
            smithy_http::result::SdkError<crate::error::UpdateQuerySuggestionsBlockListError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the index for a block list.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
        /// <p>The unique identifier of a block list.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The name of a block list.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The description for a block list.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The S3 path where your block list text file sits in S3.</p>
        /// <p>If you update your block list and provide the same path to the
        /// block list text file in S3, then Amazon Kendra reloads the file to refresh
        /// the block list. Amazon Kendra does not automatically refresh your block list.
        /// You need to call the <code>UpdateQuerySuggestionsBlockList</code> API
        /// to refresh you block list.</p>
        /// <p>If you update your block list, then Amazon Kendra asynchronously refreshes
        /// all query suggestions with the latest content in the S3 file. This
        /// means changes might not take effect immediately.</p>
        pub fn source_s3_path(mut self, input: crate::model::S3Path) -> Self {
            self.inner = self.inner.source_s3_path(input);
            self
        }
        pub fn set_source_s3_path(
            mut self,
            input: std::option::Option<crate::model::S3Path>,
        ) -> Self {
            self.inner = self.inner.set_source_s3_path(input);
            self
        }
        /// <p>The IAM (Identity and Access Management) role used to access the
        /// block list text file in S3.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateQuerySuggestionsConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_query_suggestions_config_input::Builder,
    }
    impl<C> UpdateQuerySuggestionsConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateQuerySuggestionsConfigOutput,
            smithy_http::result::SdkError<crate::error::UpdateQuerySuggestionsConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the index you want to update query suggestions settings for.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
        /// <p>Set the mode to <code>ENABLED</code> or <code>LEARN_ONLY</code>.</p>
        /// <p>By default, Amazon Kendra enables query suggestions.
        /// <code>LEARN_ONLY</code> mode allows you to turn off query suggestions.
        /// You can to update this at any time.</p>
        /// <p>In <code>LEARN_ONLY</code> mode, Amazon Kendra continues to learn from new
        /// queries to keep suggestions up to date for when you are ready to
        /// switch to ENABLED mode again.</p>
        pub fn mode(mut self, input: crate::model::Mode) -> Self {
            self.inner = self.inner.mode(input);
            self
        }
        pub fn set_mode(mut self, input: std::option::Option<crate::model::Mode>) -> Self {
            self.inner = self.inner.set_mode(input);
            self
        }
        /// <p>How recent your queries are in your query log time window.</p>
        /// <p>The time window is the number of days from current day to past days.</p>
        /// <p>By default, Amazon Kendra sets this to 180.</p>
        pub fn query_log_look_back_window_in_days(mut self, input: i32) -> Self {
            self.inner = self.inner.query_log_look_back_window_in_days(input);
            self
        }
        pub fn set_query_log_look_back_window_in_days(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.inner = self.inner.set_query_log_look_back_window_in_days(input);
            self
        }
        /// <p>
        /// <code>TRUE</code> to include queries without user information (i.e. all queries,
        /// irrespective of the user), otherwise <code>FALSE</code> to only include queries
        /// with user information.</p>
        /// <p>If you pass user information to Amazon Kendra along with the queries, you can set this
        /// flag to <code>FALSE</code> and instruct Amazon Kendra to only consider queries with user
        /// information.</p>
        /// <p>If you set to <code>FALSE</code>, Amazon Kendra only considers queries searched at least
        /// <code>MinimumQueryCount</code> times across <code>MinimumNumberOfQueryingUsers</code>
        /// unique users for suggestions.</p>
        /// <p>If you set to <code>TRUE</code>, Amazon Kendra ignores all user information and learns
        /// from all queries.</p>
        pub fn include_queries_without_user_information(mut self, input: bool) -> Self {
            self.inner = self.inner.include_queries_without_user_information(input);
            self
        }
        pub fn set_include_queries_without_user_information(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self
                .inner
                .set_include_queries_without_user_information(input);
            self
        }
        /// <p>The minimum number of unique users who must search a query in order for the query
        /// to be eligible to suggest to your users.</p>
        /// <p>Increasing this number might decrease the number of suggestions. However, this
        /// ensures a query is searched by many users and is truly popular to suggest to users.</p>
        /// <p>How you tune this setting depends on your specific needs.</p>
        pub fn minimum_number_of_querying_users(mut self, input: i32) -> Self {
            self.inner = self.inner.minimum_number_of_querying_users(input);
            self
        }
        pub fn set_minimum_number_of_querying_users(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.inner = self.inner.set_minimum_number_of_querying_users(input);
            self
        }
        /// <p>The the minimum number of times a query must be searched in order to be
        /// eligible to suggest to your users.</p>
        /// <p>Decreasing this number increases the number of suggestions. However, this
        /// affects the quality of suggestions as it sets a low bar for a query to be
        /// considered popular to suggest to users.</p>
        /// <p>How you tune this setting depends on your specific needs.</p>
        pub fn minimum_query_count(mut self, input: i32) -> Self {
            self.inner = self.inner.minimum_query_count(input);
            self
        }
        pub fn set_minimum_query_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_minimum_query_count(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateThesaurus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_thesaurus_input::Builder,
    }
    impl<C> UpdateThesaurus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateThesaurusOutput,
            smithy_http::result::SdkError<crate::error::UpdateThesaurusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the thesaurus to update.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The updated name of the thesaurus.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The identifier of the index associated with the thesaurus to update.</p>
        pub fn index_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_id(input);
            self
        }
        pub fn set_index_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_id(input);
            self
        }
        /// <p>The updated description of the thesaurus.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The updated role ARN of the thesaurus.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>Information required to find a specific file in an Amazon S3
        /// bucket.</p>
        pub fn source_s3_path(mut self, input: crate::model::S3Path) -> Self {
            self.inner = self.inner.source_s3_path(input);
            self
        }
        pub fn set_source_s3_path(
            mut self,
            input: std::option::Option<crate::model::S3Path>,
        ) -> Self {
            self.inner = self.inner.set_source_s3_path(input);
            self
        }
    }
}
