// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Provides the configuration information to connect to Quip as your data source.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct QuipConfiguration {
    /// <p>The Quip site domain. For example, <i>https://quip-company.quipdomain.com/browse</i>. The domain in this example is "quipdomain".</p>
    pub domain: ::std::string::String,
    /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs that are required to connect to your Quip. The secret must contain a JSON structure with the following keys:</p>
    /// <ul>
    /// <li> <p>accessToken—The token created in Quip. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-slack.html">Using a Quip data source</a>.</p> </li>
    /// </ul>
    pub secret_arn: ::std::string::String,
    /// <p> <code>TRUE</code> to index file comments.</p>
    pub crawl_file_comments: bool,
    /// <p> <code>TRUE</code> to index the contents of chat rooms.</p>
    pub crawl_chat_rooms: bool,
    /// <p> <code>TRUE</code> to index attachments.</p>
    pub crawl_attachments: bool,
    /// <p>The identifiers of the Quip folders you want to index. You can find the folder ID in your browser URL when you access your folder in Quip. For example, <i>https://quip-company.quipdomain.com/zlLuOVNSarTL/folder-name</i>. The folder ID in this example is "zlLuOVNSarTL".</p>
    pub folder_ids: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip threads to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
    pub thread_field_mappings: ::std::option::Option<::std::vec::Vec<crate::types::DataSourceToIndexFieldMapping>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip messages to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
    pub message_field_mappings: ::std::option::Option<::std::vec::Vec<crate::types::DataSourceToIndexFieldMapping>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
    pub attachment_field_mappings: ::std::option::Option<::std::vec::Vec<crate::types::DataSourceToIndexFieldMapping>>,
    /// <p>A list of regular expression patterns to include certain files in your Quip file system. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence, and the file isn't included in the index.</p>
    pub inclusion_patterns: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>A list of regular expression patterns to exclude certain files in your Quip file system. Files that match the patterns are excluded from the index. Files that don’t match the patterns are included in the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence, and the file isn't included in the index.</p>
    pub exclusion_patterns: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>Configuration information for an Amazon Virtual Private Cloud (VPC) to connect to your Quip. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
    pub vpc_configuration: ::std::option::Option<crate::types::DataSourceVpcConfiguration>,
}
impl QuipConfiguration {
    /// <p>The Quip site domain. For example, <i>https://quip-company.quipdomain.com/browse</i>. The domain in this example is "quipdomain".</p>
    pub fn domain(&self) -> &str {
        use std::ops::Deref;
        self.domain.deref()
    }
    /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs that are required to connect to your Quip. The secret must contain a JSON structure with the following keys:</p>
    /// <ul>
    /// <li> <p>accessToken—The token created in Quip. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-slack.html">Using a Quip data source</a>.</p> </li>
    /// </ul>
    pub fn secret_arn(&self) -> &str {
        use std::ops::Deref;
        self.secret_arn.deref()
    }
    /// <p> <code>TRUE</code> to index file comments.</p>
    pub fn crawl_file_comments(&self) -> bool {
        self.crawl_file_comments
    }
    /// <p> <code>TRUE</code> to index the contents of chat rooms.</p>
    pub fn crawl_chat_rooms(&self) -> bool {
        self.crawl_chat_rooms
    }
    /// <p> <code>TRUE</code> to index attachments.</p>
    pub fn crawl_attachments(&self) -> bool {
        self.crawl_attachments
    }
    /// <p>The identifiers of the Quip folders you want to index. You can find the folder ID in your browser URL when you access your folder in Quip. For example, <i>https://quip-company.quipdomain.com/zlLuOVNSarTL/folder-name</i>. The folder ID in this example is "zlLuOVNSarTL".</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.folder_ids.is_none()`.
    pub fn folder_ids(&self) -> &[::std::string::String] {
        self.folder_ids.as_deref().unwrap_or_default()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip threads to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.thread_field_mappings.is_none()`.
    pub fn thread_field_mappings(&self) -> &[crate::types::DataSourceToIndexFieldMapping] {
        self.thread_field_mappings.as_deref().unwrap_or_default()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip messages to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.message_field_mappings.is_none()`.
    pub fn message_field_mappings(&self) -> &[crate::types::DataSourceToIndexFieldMapping] {
        self.message_field_mappings.as_deref().unwrap_or_default()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.attachment_field_mappings.is_none()`.
    pub fn attachment_field_mappings(&self) -> &[crate::types::DataSourceToIndexFieldMapping] {
        self.attachment_field_mappings.as_deref().unwrap_or_default()
    }
    /// <p>A list of regular expression patterns to include certain files in your Quip file system. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence, and the file isn't included in the index.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.inclusion_patterns.is_none()`.
    pub fn inclusion_patterns(&self) -> &[::std::string::String] {
        self.inclusion_patterns.as_deref().unwrap_or_default()
    }
    /// <p>A list of regular expression patterns to exclude certain files in your Quip file system. Files that match the patterns are excluded from the index. Files that don’t match the patterns are included in the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence, and the file isn't included in the index.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.exclusion_patterns.is_none()`.
    pub fn exclusion_patterns(&self) -> &[::std::string::String] {
        self.exclusion_patterns.as_deref().unwrap_or_default()
    }
    /// <p>Configuration information for an Amazon Virtual Private Cloud (VPC) to connect to your Quip. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
    pub fn vpc_configuration(&self) -> ::std::option::Option<&crate::types::DataSourceVpcConfiguration> {
        self.vpc_configuration.as_ref()
    }
}
impl QuipConfiguration {
    /// Creates a new builder-style object to manufacture [`QuipConfiguration`](crate::types::QuipConfiguration).
    pub fn builder() -> crate::types::builders::QuipConfigurationBuilder {
        crate::types::builders::QuipConfigurationBuilder::default()
    }
}

/// A builder for [`QuipConfiguration`](crate::types::QuipConfiguration).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct QuipConfigurationBuilder {
    pub(crate) domain: ::std::option::Option<::std::string::String>,
    pub(crate) secret_arn: ::std::option::Option<::std::string::String>,
    pub(crate) crawl_file_comments: ::std::option::Option<bool>,
    pub(crate) crawl_chat_rooms: ::std::option::Option<bool>,
    pub(crate) crawl_attachments: ::std::option::Option<bool>,
    pub(crate) folder_ids: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) thread_field_mappings: ::std::option::Option<::std::vec::Vec<crate::types::DataSourceToIndexFieldMapping>>,
    pub(crate) message_field_mappings: ::std::option::Option<::std::vec::Vec<crate::types::DataSourceToIndexFieldMapping>>,
    pub(crate) attachment_field_mappings: ::std::option::Option<::std::vec::Vec<crate::types::DataSourceToIndexFieldMapping>>,
    pub(crate) inclusion_patterns: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) exclusion_patterns: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) vpc_configuration: ::std::option::Option<crate::types::DataSourceVpcConfiguration>,
}
impl QuipConfigurationBuilder {
    /// <p>The Quip site domain. For example, <i>https://quip-company.quipdomain.com/browse</i>. The domain in this example is "quipdomain".</p>
    /// This field is required.
    pub fn domain(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.domain = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Quip site domain. For example, <i>https://quip-company.quipdomain.com/browse</i>. The domain in this example is "quipdomain".</p>
    pub fn set_domain(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.domain = input;
        self
    }
    /// <p>The Quip site domain. For example, <i>https://quip-company.quipdomain.com/browse</i>. The domain in this example is "quipdomain".</p>
    pub fn get_domain(&self) -> &::std::option::Option<::std::string::String> {
        &self.domain
    }
    /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs that are required to connect to your Quip. The secret must contain a JSON structure with the following keys:</p>
    /// <ul>
    /// <li> <p>accessToken—The token created in Quip. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-slack.html">Using a Quip data source</a>.</p> </li>
    /// </ul>
    /// This field is required.
    pub fn secret_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.secret_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs that are required to connect to your Quip. The secret must contain a JSON structure with the following keys:</p>
    /// <ul>
    /// <li> <p>accessToken—The token created in Quip. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-slack.html">Using a Quip data source</a>.</p> </li>
    /// </ul>
    pub fn set_secret_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.secret_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs that are required to connect to your Quip. The secret must contain a JSON structure with the following keys:</p>
    /// <ul>
    /// <li> <p>accessToken—The token created in Quip. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-slack.html">Using a Quip data source</a>.</p> </li>
    /// </ul>
    pub fn get_secret_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.secret_arn
    }
    /// <p> <code>TRUE</code> to index file comments.</p>
    pub fn crawl_file_comments(mut self, input: bool) -> Self {
        self.crawl_file_comments = ::std::option::Option::Some(input);
        self
    }
    /// <p> <code>TRUE</code> to index file comments.</p>
    pub fn set_crawl_file_comments(mut self, input: ::std::option::Option<bool>) -> Self {
        self.crawl_file_comments = input;
        self
    }
    /// <p> <code>TRUE</code> to index file comments.</p>
    pub fn get_crawl_file_comments(&self) -> &::std::option::Option<bool> {
        &self.crawl_file_comments
    }
    /// <p> <code>TRUE</code> to index the contents of chat rooms.</p>
    pub fn crawl_chat_rooms(mut self, input: bool) -> Self {
        self.crawl_chat_rooms = ::std::option::Option::Some(input);
        self
    }
    /// <p> <code>TRUE</code> to index the contents of chat rooms.</p>
    pub fn set_crawl_chat_rooms(mut self, input: ::std::option::Option<bool>) -> Self {
        self.crawl_chat_rooms = input;
        self
    }
    /// <p> <code>TRUE</code> to index the contents of chat rooms.</p>
    pub fn get_crawl_chat_rooms(&self) -> &::std::option::Option<bool> {
        &self.crawl_chat_rooms
    }
    /// <p> <code>TRUE</code> to index attachments.</p>
    pub fn crawl_attachments(mut self, input: bool) -> Self {
        self.crawl_attachments = ::std::option::Option::Some(input);
        self
    }
    /// <p> <code>TRUE</code> to index attachments.</p>
    pub fn set_crawl_attachments(mut self, input: ::std::option::Option<bool>) -> Self {
        self.crawl_attachments = input;
        self
    }
    /// <p> <code>TRUE</code> to index attachments.</p>
    pub fn get_crawl_attachments(&self) -> &::std::option::Option<bool> {
        &self.crawl_attachments
    }
    /// Appends an item to `folder_ids`.
    ///
    /// To override the contents of this collection use [`set_folder_ids`](Self::set_folder_ids).
    ///
    /// <p>The identifiers of the Quip folders you want to index. You can find the folder ID in your browser URL when you access your folder in Quip. For example, <i>https://quip-company.quipdomain.com/zlLuOVNSarTL/folder-name</i>. The folder ID in this example is "zlLuOVNSarTL".</p>
    pub fn folder_ids(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.folder_ids.unwrap_or_default();
        v.push(input.into());
        self.folder_ids = ::std::option::Option::Some(v);
        self
    }
    /// <p>The identifiers of the Quip folders you want to index. You can find the folder ID in your browser URL when you access your folder in Quip. For example, <i>https://quip-company.quipdomain.com/zlLuOVNSarTL/folder-name</i>. The folder ID in this example is "zlLuOVNSarTL".</p>
    pub fn set_folder_ids(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.folder_ids = input;
        self
    }
    /// <p>The identifiers of the Quip folders you want to index. You can find the folder ID in your browser URL when you access your folder in Quip. For example, <i>https://quip-company.quipdomain.com/zlLuOVNSarTL/folder-name</i>. The folder ID in this example is "zlLuOVNSarTL".</p>
    pub fn get_folder_ids(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.folder_ids
    }
    /// Appends an item to `thread_field_mappings`.
    ///
    /// To override the contents of this collection use [`set_thread_field_mappings`](Self::set_thread_field_mappings).
    ///
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip threads to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
    pub fn thread_field_mappings(mut self, input: crate::types::DataSourceToIndexFieldMapping) -> Self {
        let mut v = self.thread_field_mappings.unwrap_or_default();
        v.push(input);
        self.thread_field_mappings = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip threads to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
    pub fn set_thread_field_mappings(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::DataSourceToIndexFieldMapping>>) -> Self {
        self.thread_field_mappings = input;
        self
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip threads to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
    pub fn get_thread_field_mappings(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::DataSourceToIndexFieldMapping>> {
        &self.thread_field_mappings
    }
    /// Appends an item to `message_field_mappings`.
    ///
    /// To override the contents of this collection use [`set_message_field_mappings`](Self::set_message_field_mappings).
    ///
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip messages to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
    pub fn message_field_mappings(mut self, input: crate::types::DataSourceToIndexFieldMapping) -> Self {
        let mut v = self.message_field_mappings.unwrap_or_default();
        v.push(input);
        self.message_field_mappings = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip messages to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
    pub fn set_message_field_mappings(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::DataSourceToIndexFieldMapping>>) -> Self {
        self.message_field_mappings = input;
        self
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip messages to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
    pub fn get_message_field_mappings(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::DataSourceToIndexFieldMapping>> {
        &self.message_field_mappings
    }
    /// Appends an item to `attachment_field_mappings`.
    ///
    /// To override the contents of this collection use [`set_attachment_field_mappings`](Self::set_attachment_field_mappings).
    ///
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
    pub fn attachment_field_mappings(mut self, input: crate::types::DataSourceToIndexFieldMapping) -> Self {
        let mut v = self.attachment_field_mappings.unwrap_or_default();
        v.push(input);
        self.attachment_field_mappings = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
    pub fn set_attachment_field_mappings(
        mut self,
        input: ::std::option::Option<::std::vec::Vec<crate::types::DataSourceToIndexFieldMapping>>,
    ) -> Self {
        self.attachment_field_mappings = input;
        self
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
    pub fn get_attachment_field_mappings(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::DataSourceToIndexFieldMapping>> {
        &self.attachment_field_mappings
    }
    /// Appends an item to `inclusion_patterns`.
    ///
    /// To override the contents of this collection use [`set_inclusion_patterns`](Self::set_inclusion_patterns).
    ///
    /// <p>A list of regular expression patterns to include certain files in your Quip file system. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence, and the file isn't included in the index.</p>
    pub fn inclusion_patterns(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.inclusion_patterns.unwrap_or_default();
        v.push(input.into());
        self.inclusion_patterns = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of regular expression patterns to include certain files in your Quip file system. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence, and the file isn't included in the index.</p>
    pub fn set_inclusion_patterns(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.inclusion_patterns = input;
        self
    }
    /// <p>A list of regular expression patterns to include certain files in your Quip file system. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence, and the file isn't included in the index.</p>
    pub fn get_inclusion_patterns(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.inclusion_patterns
    }
    /// Appends an item to `exclusion_patterns`.
    ///
    /// To override the contents of this collection use [`set_exclusion_patterns`](Self::set_exclusion_patterns).
    ///
    /// <p>A list of regular expression patterns to exclude certain files in your Quip file system. Files that match the patterns are excluded from the index. Files that don’t match the patterns are included in the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence, and the file isn't included in the index.</p>
    pub fn exclusion_patterns(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.exclusion_patterns.unwrap_or_default();
        v.push(input.into());
        self.exclusion_patterns = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of regular expression patterns to exclude certain files in your Quip file system. Files that match the patterns are excluded from the index. Files that don’t match the patterns are included in the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence, and the file isn't included in the index.</p>
    pub fn set_exclusion_patterns(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.exclusion_patterns = input;
        self
    }
    /// <p>A list of regular expression patterns to exclude certain files in your Quip file system. Files that match the patterns are excluded from the index. Files that don’t match the patterns are included in the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence, and the file isn't included in the index.</p>
    pub fn get_exclusion_patterns(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.exclusion_patterns
    }
    /// <p>Configuration information for an Amazon Virtual Private Cloud (VPC) to connect to your Quip. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
    pub fn vpc_configuration(mut self, input: crate::types::DataSourceVpcConfiguration) -> Self {
        self.vpc_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Configuration information for an Amazon Virtual Private Cloud (VPC) to connect to your Quip. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
    pub fn set_vpc_configuration(mut self, input: ::std::option::Option<crate::types::DataSourceVpcConfiguration>) -> Self {
        self.vpc_configuration = input;
        self
    }
    /// <p>Configuration information for an Amazon Virtual Private Cloud (VPC) to connect to your Quip. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
    pub fn get_vpc_configuration(&self) -> &::std::option::Option<crate::types::DataSourceVpcConfiguration> {
        &self.vpc_configuration
    }
    /// Consumes the builder and constructs a [`QuipConfiguration`](crate::types::QuipConfiguration).
    /// This method will fail if any of the following fields are not set:
    /// - [`domain`](crate::types::builders::QuipConfigurationBuilder::domain)
    /// - [`secret_arn`](crate::types::builders::QuipConfigurationBuilder::secret_arn)
    pub fn build(self) -> ::std::result::Result<crate::types::QuipConfiguration, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::QuipConfiguration {
            domain: self.domain.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "domain",
                    "domain was not specified but it is required when building QuipConfiguration",
                )
            })?,
            secret_arn: self.secret_arn.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "secret_arn",
                    "secret_arn was not specified but it is required when building QuipConfiguration",
                )
            })?,
            crawl_file_comments: self.crawl_file_comments.unwrap_or_default(),
            crawl_chat_rooms: self.crawl_chat_rooms.unwrap_or_default(),
            crawl_attachments: self.crawl_attachments.unwrap_or_default(),
            folder_ids: self.folder_ids,
            thread_field_mappings: self.thread_field_mappings,
            message_field_mappings: self.message_field_mappings,
            attachment_field_mappings: self.attachment_field_mappings,
            inclusion_patterns: self.inclusion_patterns,
            exclusion_patterns: self.exclusion_patterns,
            vpc_configuration: self.vpc_configuration,
        })
    }
}
