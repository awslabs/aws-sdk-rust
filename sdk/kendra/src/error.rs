// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchDeleteDocumentError {
    pub kind: BatchDeleteDocumentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchDeleteDocumentErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchDeleteDocumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchDeleteDocumentErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            BatchDeleteDocumentErrorKind::ConflictException(_inner) => _inner.fmt(f),
            BatchDeleteDocumentErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            BatchDeleteDocumentErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            BatchDeleteDocumentErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            BatchDeleteDocumentErrorKind::ValidationException(_inner) => _inner.fmt(f),
            BatchDeleteDocumentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchDeleteDocumentError {
    fn code(&self) -> Option<&str> {
        BatchDeleteDocumentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchDeleteDocumentError {
    pub fn new(kind: BatchDeleteDocumentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchDeleteDocumentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchDeleteDocumentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteDocumentErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteDocumentErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteDocumentErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteDocumentErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteDocumentErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteDocumentErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for BatchDeleteDocumentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchDeleteDocumentErrorKind::AccessDeniedException(_inner) => Some(_inner),
            BatchDeleteDocumentErrorKind::ConflictException(_inner) => Some(_inner),
            BatchDeleteDocumentErrorKind::InternalServerException(_inner) => Some(_inner),
            BatchDeleteDocumentErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            BatchDeleteDocumentErrorKind::ThrottlingException(_inner) => Some(_inner),
            BatchDeleteDocumentErrorKind::ValidationException(_inner) => Some(_inner),
            BatchDeleteDocumentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchGetDocumentStatusError {
    pub kind: BatchGetDocumentStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetDocumentStatusErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchGetDocumentStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchGetDocumentStatusErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            BatchGetDocumentStatusErrorKind::ConflictException(_inner) => _inner.fmt(f),
            BatchGetDocumentStatusErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            BatchGetDocumentStatusErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            BatchGetDocumentStatusErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            BatchGetDocumentStatusErrorKind::ValidationException(_inner) => _inner.fmt(f),
            BatchGetDocumentStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchGetDocumentStatusError {
    fn code(&self) -> Option<&str> {
        BatchGetDocumentStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetDocumentStatusError {
    pub fn new(kind: BatchGetDocumentStatusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchGetDocumentStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchGetDocumentStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetDocumentStatusErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetDocumentStatusErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetDocumentStatusErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetDocumentStatusErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetDocumentStatusErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetDocumentStatusErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for BatchGetDocumentStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchGetDocumentStatusErrorKind::AccessDeniedException(_inner) => Some(_inner),
            BatchGetDocumentStatusErrorKind::ConflictException(_inner) => Some(_inner),
            BatchGetDocumentStatusErrorKind::InternalServerException(_inner) => Some(_inner),
            BatchGetDocumentStatusErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            BatchGetDocumentStatusErrorKind::ThrottlingException(_inner) => Some(_inner),
            BatchGetDocumentStatusErrorKind::ValidationException(_inner) => Some(_inner),
            BatchGetDocumentStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchPutDocumentError {
    pub kind: BatchPutDocumentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchPutDocumentErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchPutDocumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchPutDocumentErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            BatchPutDocumentErrorKind::ConflictException(_inner) => _inner.fmt(f),
            BatchPutDocumentErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            BatchPutDocumentErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            BatchPutDocumentErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            BatchPutDocumentErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            BatchPutDocumentErrorKind::ValidationException(_inner) => _inner.fmt(f),
            BatchPutDocumentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchPutDocumentError {
    fn code(&self) -> Option<&str> {
        BatchPutDocumentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchPutDocumentError {
    pub fn new(kind: BatchPutDocumentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchPutDocumentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchPutDocumentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchPutDocumentErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, BatchPutDocumentErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchPutDocumentErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchPutDocumentErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchPutDocumentErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchPutDocumentErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchPutDocumentErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for BatchPutDocumentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchPutDocumentErrorKind::AccessDeniedException(_inner) => Some(_inner),
            BatchPutDocumentErrorKind::ConflictException(_inner) => Some(_inner),
            BatchPutDocumentErrorKind::InternalServerException(_inner) => Some(_inner),
            BatchPutDocumentErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            BatchPutDocumentErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            BatchPutDocumentErrorKind::ThrottlingException(_inner) => Some(_inner),
            BatchPutDocumentErrorKind::ValidationException(_inner) => Some(_inner),
            BatchPutDocumentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ClearQuerySuggestionsError {
    pub kind: ClearQuerySuggestionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ClearQuerySuggestionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ClearQuerySuggestionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ClearQuerySuggestionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ClearQuerySuggestionsErrorKind::ConflictException(_inner) => _inner.fmt(f),
            ClearQuerySuggestionsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ClearQuerySuggestionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ClearQuerySuggestionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ClearQuerySuggestionsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ClearQuerySuggestionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ClearQuerySuggestionsError {
    fn code(&self) -> Option<&str> {
        ClearQuerySuggestionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ClearQuerySuggestionsError {
    pub fn new(kind: ClearQuerySuggestionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ClearQuerySuggestionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ClearQuerySuggestionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ClearQuerySuggestionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            ClearQuerySuggestionsErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ClearQuerySuggestionsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ClearQuerySuggestionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ClearQuerySuggestionsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ClearQuerySuggestionsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ClearQuerySuggestionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ClearQuerySuggestionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ClearQuerySuggestionsErrorKind::ConflictException(_inner) => Some(_inner),
            ClearQuerySuggestionsErrorKind::InternalServerException(_inner) => Some(_inner),
            ClearQuerySuggestionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ClearQuerySuggestionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ClearQuerySuggestionsErrorKind::ValidationException(_inner) => Some(_inner),
            ClearQuerySuggestionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDataSourceError {
    pub kind: CreateDataSourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDataSourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceAlreadyExistException(crate::error::ResourceAlreadyExistException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDataSourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDataSourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateDataSourceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateDataSourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateDataSourceErrorKind::ResourceAlreadyExistException(_inner) => _inner.fmt(f),
            CreateDataSourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateDataSourceErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            CreateDataSourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateDataSourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateDataSourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDataSourceError {
    fn code(&self) -> Option<&str> {
        CreateDataSourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDataSourceError {
    pub fn new(kind: CreateDataSourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDataSourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDataSourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataSourceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateDataSourceErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataSourceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_already_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataSourceErrorKind::ResourceAlreadyExistException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataSourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataSourceErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataSourceErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataSourceErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateDataSourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDataSourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateDataSourceErrorKind::ConflictException(_inner) => Some(_inner),
            CreateDataSourceErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateDataSourceErrorKind::ResourceAlreadyExistException(_inner) => Some(_inner),
            CreateDataSourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateDataSourceErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            CreateDataSourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateDataSourceErrorKind::ValidationException(_inner) => Some(_inner),
            CreateDataSourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateFaqError {
    pub kind: CreateFaqErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateFaqErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateFaqError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateFaqErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateFaqErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateFaqErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateFaqErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateFaqErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            CreateFaqErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateFaqErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateFaqErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateFaqError {
    fn code(&self) -> Option<&str> {
        CreateFaqError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateFaqError {
    pub fn new(kind: CreateFaqErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateFaqErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateFaqErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateFaqErrorKind::AccessDeniedException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateFaqErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, CreateFaqErrorKind::InternalServerException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateFaqErrorKind::ResourceNotFoundException(_))
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFaqErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateFaqErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateFaqErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateFaqError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateFaqErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateFaqErrorKind::ConflictException(_inner) => Some(_inner),
            CreateFaqErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateFaqErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateFaqErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            CreateFaqErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateFaqErrorKind::ValidationException(_inner) => Some(_inner),
            CreateFaqErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateIndexError {
    pub kind: CreateIndexErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateIndexErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceAlreadyExistException(crate::error::ResourceAlreadyExistException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateIndexError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateIndexErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateIndexErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateIndexErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateIndexErrorKind::ResourceAlreadyExistException(_inner) => _inner.fmt(f),
            CreateIndexErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            CreateIndexErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateIndexErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateIndexErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateIndexError {
    fn code(&self) -> Option<&str> {
        CreateIndexError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateIndexError {
    pub fn new(kind: CreateIndexErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateIndexErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateIndexErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateIndexErrorKind::AccessDeniedException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateIndexErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, CreateIndexErrorKind::InternalServerException(_))
    }
    pub fn is_resource_already_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIndexErrorKind::ResourceAlreadyExistException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIndexErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateIndexErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateIndexErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateIndexError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateIndexErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateIndexErrorKind::ConflictException(_inner) => Some(_inner),
            CreateIndexErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateIndexErrorKind::ResourceAlreadyExistException(_inner) => Some(_inner),
            CreateIndexErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            CreateIndexErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateIndexErrorKind::ValidationException(_inner) => Some(_inner),
            CreateIndexErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateQuerySuggestionsBlockListError {
    pub kind: CreateQuerySuggestionsBlockListErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateQuerySuggestionsBlockListErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateQuerySuggestionsBlockListError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateQuerySuggestionsBlockListErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            CreateQuerySuggestionsBlockListErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateQuerySuggestionsBlockListErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            CreateQuerySuggestionsBlockListErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CreateQuerySuggestionsBlockListErrorKind::ServiceQuotaExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateQuerySuggestionsBlockListErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateQuerySuggestionsBlockListErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateQuerySuggestionsBlockListErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateQuerySuggestionsBlockListError {
    fn code(&self) -> Option<&str> {
        CreateQuerySuggestionsBlockListError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateQuerySuggestionsBlockListError {
    pub fn new(kind: CreateQuerySuggestionsBlockListErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateQuerySuggestionsBlockListErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateQuerySuggestionsBlockListErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateQuerySuggestionsBlockListErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateQuerySuggestionsBlockListErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateQuerySuggestionsBlockListErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateQuerySuggestionsBlockListErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateQuerySuggestionsBlockListErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateQuerySuggestionsBlockListErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateQuerySuggestionsBlockListErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateQuerySuggestionsBlockListError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateQuerySuggestionsBlockListErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateQuerySuggestionsBlockListErrorKind::ConflictException(_inner) => Some(_inner),
            CreateQuerySuggestionsBlockListErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            CreateQuerySuggestionsBlockListErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            CreateQuerySuggestionsBlockListErrorKind::ServiceQuotaExceededException(_inner) => {
                Some(_inner)
            }
            CreateQuerySuggestionsBlockListErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateQuerySuggestionsBlockListErrorKind::ValidationException(_inner) => Some(_inner),
            CreateQuerySuggestionsBlockListErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateThesaurusError {
    pub kind: CreateThesaurusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateThesaurusErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateThesaurusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateThesaurusErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateThesaurusErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateThesaurusErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateThesaurusErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateThesaurusErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            CreateThesaurusErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateThesaurusErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateThesaurusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateThesaurusError {
    fn code(&self) -> Option<&str> {
        CreateThesaurusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateThesaurusError {
    pub fn new(kind: CreateThesaurusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateThesaurusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateThesaurusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThesaurusErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateThesaurusErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThesaurusErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThesaurusErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThesaurusErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateThesaurusErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateThesaurusErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateThesaurusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateThesaurusErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateThesaurusErrorKind::ConflictException(_inner) => Some(_inner),
            CreateThesaurusErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateThesaurusErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateThesaurusErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            CreateThesaurusErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateThesaurusErrorKind::ValidationException(_inner) => Some(_inner),
            CreateThesaurusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDataSourceError {
    pub kind: DeleteDataSourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDataSourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDataSourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDataSourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteDataSourceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteDataSourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteDataSourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteDataSourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteDataSourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteDataSourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDataSourceError {
    fn code(&self) -> Option<&str> {
        DeleteDataSourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDataSourceError {
    pub fn new(kind: DeleteDataSourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDataSourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDataSourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDataSourceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteDataSourceErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDataSourceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDataSourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDataSourceErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDataSourceErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteDataSourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDataSourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteDataSourceErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteDataSourceErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteDataSourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteDataSourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteDataSourceErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteDataSourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFaqError {
    pub kind: DeleteFaqErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFaqErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFaqError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFaqErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteFaqErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteFaqErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteFaqErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteFaqErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteFaqErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteFaqErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteFaqError {
    fn code(&self) -> Option<&str> {
        DeleteFaqError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFaqError {
    pub fn new(kind: DeleteFaqErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFaqErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFaqErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteFaqErrorKind::AccessDeniedException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteFaqErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DeleteFaqErrorKind::InternalServerException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteFaqErrorKind::ResourceNotFoundException(_))
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteFaqErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteFaqErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteFaqError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFaqErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteFaqErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteFaqErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteFaqErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteFaqErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteFaqErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteFaqErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteIndexError {
    pub kind: DeleteIndexErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteIndexErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteIndexError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteIndexErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteIndexErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteIndexErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteIndexErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteIndexErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteIndexErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteIndexErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteIndexError {
    fn code(&self) -> Option<&str> {
        DeleteIndexError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteIndexError {
    pub fn new(kind: DeleteIndexErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteIndexErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteIndexErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteIndexErrorKind::AccessDeniedException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteIndexErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DeleteIndexErrorKind::InternalServerException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIndexErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteIndexErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteIndexErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteIndexError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteIndexErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteIndexErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteIndexErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteIndexErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteIndexErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteIndexErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteIndexErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteQuerySuggestionsBlockListError {
    pub kind: DeleteQuerySuggestionsBlockListErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteQuerySuggestionsBlockListErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteQuerySuggestionsBlockListError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteQuerySuggestionsBlockListErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DeleteQuerySuggestionsBlockListErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteQuerySuggestionsBlockListErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            DeleteQuerySuggestionsBlockListErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteQuerySuggestionsBlockListErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteQuerySuggestionsBlockListErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteQuerySuggestionsBlockListErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteQuerySuggestionsBlockListError {
    fn code(&self) -> Option<&str> {
        DeleteQuerySuggestionsBlockListError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteQuerySuggestionsBlockListError {
    pub fn new(kind: DeleteQuerySuggestionsBlockListErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteQuerySuggestionsBlockListErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteQuerySuggestionsBlockListErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteQuerySuggestionsBlockListErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteQuerySuggestionsBlockListErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteQuerySuggestionsBlockListErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteQuerySuggestionsBlockListErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteQuerySuggestionsBlockListErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteQuerySuggestionsBlockListErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteQuerySuggestionsBlockListError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteQuerySuggestionsBlockListErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteQuerySuggestionsBlockListErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteQuerySuggestionsBlockListErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            DeleteQuerySuggestionsBlockListErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteQuerySuggestionsBlockListErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteQuerySuggestionsBlockListErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteQuerySuggestionsBlockListErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteThesaurusError {
    pub kind: DeleteThesaurusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteThesaurusErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteThesaurusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteThesaurusErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteThesaurusErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteThesaurusErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteThesaurusErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteThesaurusErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteThesaurusErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteThesaurusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteThesaurusError {
    fn code(&self) -> Option<&str> {
        DeleteThesaurusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteThesaurusError {
    pub fn new(kind: DeleteThesaurusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteThesaurusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteThesaurusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThesaurusErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteThesaurusErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThesaurusErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThesaurusErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteThesaurusErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteThesaurusErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteThesaurusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteThesaurusErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteThesaurusErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteThesaurusErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteThesaurusErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteThesaurusErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteThesaurusErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteThesaurusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDataSourceError {
    pub kind: DescribeDataSourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDataSourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDataSourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDataSourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeDataSourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeDataSourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeDataSourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeDataSourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DescribeDataSourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDataSourceError {
    fn code(&self) -> Option<&str> {
        DescribeDataSourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDataSourceError {
    pub fn new(kind: DescribeDataSourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDataSourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDataSourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataSourceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataSourceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataSourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataSourceErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataSourceErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DescribeDataSourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDataSourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeDataSourceErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeDataSourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeDataSourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeDataSourceErrorKind::ValidationException(_inner) => Some(_inner),
            DescribeDataSourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeFaqError {
    pub kind: DescribeFaqErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeFaqErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeFaqError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeFaqErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeFaqErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeFaqErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeFaqErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeFaqErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DescribeFaqErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeFaqError {
    fn code(&self) -> Option<&str> {
        DescribeFaqError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeFaqError {
    pub fn new(kind: DescribeFaqErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeFaqErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeFaqErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DescribeFaqErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, DescribeFaqErrorKind::InternalServerException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFaqErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeFaqErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DescribeFaqErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DescribeFaqError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeFaqErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeFaqErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeFaqErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeFaqErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeFaqErrorKind::ValidationException(_inner) => Some(_inner),
            DescribeFaqErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeIndexError {
    pub kind: DescribeIndexErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeIndexErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeIndexError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeIndexErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeIndexErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeIndexErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeIndexErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeIndexErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DescribeIndexErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeIndexError {
    fn code(&self) -> Option<&str> {
        DescribeIndexError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeIndexError {
    pub fn new(kind: DescribeIndexErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeIndexErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeIndexErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DescribeIndexErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIndexErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIndexErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeIndexErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DescribeIndexErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DescribeIndexError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeIndexErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeIndexErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeIndexErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeIndexErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeIndexErrorKind::ValidationException(_inner) => Some(_inner),
            DescribeIndexErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeQuerySuggestionsBlockListError {
    pub kind: DescribeQuerySuggestionsBlockListErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeQuerySuggestionsBlockListErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeQuerySuggestionsBlockListError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeQuerySuggestionsBlockListErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DescribeQuerySuggestionsBlockListErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            DescribeQuerySuggestionsBlockListErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeQuerySuggestionsBlockListErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            DescribeQuerySuggestionsBlockListErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            DescribeQuerySuggestionsBlockListErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeQuerySuggestionsBlockListError {
    fn code(&self) -> Option<&str> {
        DescribeQuerySuggestionsBlockListError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeQuerySuggestionsBlockListError {
    pub fn new(
        kind: DescribeQuerySuggestionsBlockListErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeQuerySuggestionsBlockListErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeQuerySuggestionsBlockListErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQuerySuggestionsBlockListErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQuerySuggestionsBlockListErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQuerySuggestionsBlockListErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQuerySuggestionsBlockListErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQuerySuggestionsBlockListErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DescribeQuerySuggestionsBlockListError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeQuerySuggestionsBlockListErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            DescribeQuerySuggestionsBlockListErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            DescribeQuerySuggestionsBlockListErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeQuerySuggestionsBlockListErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeQuerySuggestionsBlockListErrorKind::ValidationException(_inner) => Some(_inner),
            DescribeQuerySuggestionsBlockListErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeQuerySuggestionsConfigError {
    pub kind: DescribeQuerySuggestionsConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeQuerySuggestionsConfigErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeQuerySuggestionsConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeQuerySuggestionsConfigErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeQuerySuggestionsConfigErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            DescribeQuerySuggestionsConfigErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeQuerySuggestionsConfigErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeQuerySuggestionsConfigErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DescribeQuerySuggestionsConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeQuerySuggestionsConfigError {
    fn code(&self) -> Option<&str> {
        DescribeQuerySuggestionsConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeQuerySuggestionsConfigError {
    pub fn new(kind: DescribeQuerySuggestionsConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeQuerySuggestionsConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeQuerySuggestionsConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQuerySuggestionsConfigErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQuerySuggestionsConfigErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQuerySuggestionsConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQuerySuggestionsConfigErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQuerySuggestionsConfigErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DescribeQuerySuggestionsConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeQuerySuggestionsConfigErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeQuerySuggestionsConfigErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            DescribeQuerySuggestionsConfigErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeQuerySuggestionsConfigErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeQuerySuggestionsConfigErrorKind::ValidationException(_inner) => Some(_inner),
            DescribeQuerySuggestionsConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeThesaurusError {
    pub kind: DescribeThesaurusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeThesaurusErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeThesaurusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeThesaurusErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeThesaurusErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DescribeThesaurusErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeThesaurusErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeThesaurusErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DescribeThesaurusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeThesaurusError {
    fn code(&self) -> Option<&str> {
        DescribeThesaurusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeThesaurusError {
    pub fn new(kind: DescribeThesaurusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeThesaurusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeThesaurusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThesaurusErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThesaurusErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThesaurusErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThesaurusErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThesaurusErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DescribeThesaurusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeThesaurusErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeThesaurusErrorKind::InternalServerException(_inner) => Some(_inner),
            DescribeThesaurusErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeThesaurusErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeThesaurusErrorKind::ValidationException(_inner) => Some(_inner),
            DescribeThesaurusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetQuerySuggestionsError {
    pub kind: GetQuerySuggestionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetQuerySuggestionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetQuerySuggestionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetQuerySuggestionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetQuerySuggestionsErrorKind::ConflictException(_inner) => _inner.fmt(f),
            GetQuerySuggestionsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetQuerySuggestionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetQuerySuggestionsErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            GetQuerySuggestionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetQuerySuggestionsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetQuerySuggestionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetQuerySuggestionsError {
    fn code(&self) -> Option<&str> {
        GetQuerySuggestionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetQuerySuggestionsError {
    pub fn new(kind: GetQuerySuggestionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetQuerySuggestionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetQuerySuggestionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetQuerySuggestionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetQuerySuggestionsErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetQuerySuggestionsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetQuerySuggestionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetQuerySuggestionsErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetQuerySuggestionsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetQuerySuggestionsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetQuerySuggestionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetQuerySuggestionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetQuerySuggestionsErrorKind::ConflictException(_inner) => Some(_inner),
            GetQuerySuggestionsErrorKind::InternalServerException(_inner) => Some(_inner),
            GetQuerySuggestionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetQuerySuggestionsErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            GetQuerySuggestionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetQuerySuggestionsErrorKind::ValidationException(_inner) => Some(_inner),
            GetQuerySuggestionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDataSourcesError {
    pub kind: ListDataSourcesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDataSourcesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDataSourcesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDataSourcesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListDataSourcesErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListDataSourcesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListDataSourcesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListDataSourcesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListDataSourcesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDataSourcesError {
    fn code(&self) -> Option<&str> {
        ListDataSourcesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDataSourcesError {
    pub fn new(kind: ListDataSourcesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDataSourcesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDataSourcesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDataSourcesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDataSourcesErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDataSourcesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListDataSourcesErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListDataSourcesErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListDataSourcesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDataSourcesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListDataSourcesErrorKind::InternalServerException(_inner) => Some(_inner),
            ListDataSourcesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListDataSourcesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListDataSourcesErrorKind::ValidationException(_inner) => Some(_inner),
            ListDataSourcesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDataSourceSyncJobsError {
    pub kind: ListDataSourceSyncJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDataSourceSyncJobsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDataSourceSyncJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDataSourceSyncJobsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListDataSourceSyncJobsErrorKind::ConflictException(_inner) => _inner.fmt(f),
            ListDataSourceSyncJobsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListDataSourceSyncJobsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListDataSourceSyncJobsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListDataSourceSyncJobsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListDataSourceSyncJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDataSourceSyncJobsError {
    fn code(&self) -> Option<&str> {
        ListDataSourceSyncJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDataSourceSyncJobsError {
    pub fn new(kind: ListDataSourceSyncJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDataSourceSyncJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDataSourceSyncJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDataSourceSyncJobsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDataSourceSyncJobsErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDataSourceSyncJobsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDataSourceSyncJobsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDataSourceSyncJobsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDataSourceSyncJobsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListDataSourceSyncJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDataSourceSyncJobsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListDataSourceSyncJobsErrorKind::ConflictException(_inner) => Some(_inner),
            ListDataSourceSyncJobsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListDataSourceSyncJobsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListDataSourceSyncJobsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListDataSourceSyncJobsErrorKind::ValidationException(_inner) => Some(_inner),
            ListDataSourceSyncJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFaqsError {
    pub kind: ListFaqsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFaqsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFaqsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFaqsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListFaqsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListFaqsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListFaqsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListFaqsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListFaqsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListFaqsError {
    fn code(&self) -> Option<&str> {
        ListFaqsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFaqsError {
    pub fn new(kind: ListFaqsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFaqsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFaqsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListFaqsErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListFaqsErrorKind::InternalServerException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListFaqsErrorKind::ResourceNotFoundException(_))
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListFaqsErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListFaqsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListFaqsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFaqsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListFaqsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListFaqsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListFaqsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListFaqsErrorKind::ValidationException(_inner) => Some(_inner),
            ListFaqsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListIndicesError {
    pub kind: ListIndicesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListIndicesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListIndicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListIndicesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListIndicesErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListIndicesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListIndicesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListIndicesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListIndicesError {
    fn code(&self) -> Option<&str> {
        ListIndicesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListIndicesError {
    pub fn new(kind: ListIndicesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListIndicesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListIndicesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListIndicesErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListIndicesErrorKind::InternalServerException(_))
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListIndicesErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListIndicesErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListIndicesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListIndicesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListIndicesErrorKind::InternalServerException(_inner) => Some(_inner),
            ListIndicesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListIndicesErrorKind::ValidationException(_inner) => Some(_inner),
            ListIndicesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListQuerySuggestionsBlockListsError {
    pub kind: ListQuerySuggestionsBlockListsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListQuerySuggestionsBlockListsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListQuerySuggestionsBlockListsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListQuerySuggestionsBlockListsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListQuerySuggestionsBlockListsErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            ListQuerySuggestionsBlockListsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListQuerySuggestionsBlockListsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListQuerySuggestionsBlockListsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListQuerySuggestionsBlockListsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListQuerySuggestionsBlockListsError {
    fn code(&self) -> Option<&str> {
        ListQuerySuggestionsBlockListsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListQuerySuggestionsBlockListsError {
    pub fn new(kind: ListQuerySuggestionsBlockListsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListQuerySuggestionsBlockListsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListQuerySuggestionsBlockListsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListQuerySuggestionsBlockListsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListQuerySuggestionsBlockListsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListQuerySuggestionsBlockListsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListQuerySuggestionsBlockListsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListQuerySuggestionsBlockListsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListQuerySuggestionsBlockListsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListQuerySuggestionsBlockListsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListQuerySuggestionsBlockListsErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            ListQuerySuggestionsBlockListsErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ListQuerySuggestionsBlockListsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListQuerySuggestionsBlockListsErrorKind::ValidationException(_inner) => Some(_inner),
            ListQuerySuggestionsBlockListsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InternalServerException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ValidationException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListThesauriError {
    pub kind: ListThesauriErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListThesauriErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListThesauriError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListThesauriErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListThesauriErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListThesauriErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListThesauriErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListThesauriErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListThesauriErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListThesauriError {
    fn code(&self) -> Option<&str> {
        ListThesauriError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListThesauriError {
    pub fn new(kind: ListThesauriErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListThesauriErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListThesauriErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListThesauriErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThesauriErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThesauriErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListThesauriErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListThesauriErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListThesauriError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListThesauriErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListThesauriErrorKind::InternalServerException(_inner) => Some(_inner),
            ListThesauriErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListThesauriErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListThesauriErrorKind::ValidationException(_inner) => Some(_inner),
            ListThesauriErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct QueryError {
    pub kind: QueryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum QueryErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for QueryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            QueryErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            QueryErrorKind::ConflictException(_inner) => _inner.fmt(f),
            QueryErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            QueryErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            QueryErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            QueryErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            QueryErrorKind::ValidationException(_inner) => _inner.fmt(f),
            QueryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for QueryError {
    fn code(&self) -> Option<&str> {
        QueryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl QueryError {
    pub fn new(kind: QueryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: QueryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: QueryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, QueryErrorKind::AccessDeniedException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, QueryErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, QueryErrorKind::InternalServerException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, QueryErrorKind::ResourceNotFoundException(_))
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, QueryErrorKind::ServiceQuotaExceededException(_))
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, QueryErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, QueryErrorKind::ValidationException(_))
    }
}
impl std::error::Error for QueryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            QueryErrorKind::AccessDeniedException(_inner) => Some(_inner),
            QueryErrorKind::ConflictException(_inner) => Some(_inner),
            QueryErrorKind::InternalServerException(_inner) => Some(_inner),
            QueryErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            QueryErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            QueryErrorKind::ThrottlingException(_inner) => Some(_inner),
            QueryErrorKind::ValidationException(_inner) => Some(_inner),
            QueryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartDataSourceSyncJobError {
    pub kind: StartDataSourceSyncJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartDataSourceSyncJobErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceInUseException(crate::error::ResourceInUseException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartDataSourceSyncJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartDataSourceSyncJobErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartDataSourceSyncJobErrorKind::ConflictException(_inner) => _inner.fmt(f),
            StartDataSourceSyncJobErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            StartDataSourceSyncJobErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            StartDataSourceSyncJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StartDataSourceSyncJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartDataSourceSyncJobErrorKind::ValidationException(_inner) => _inner.fmt(f),
            StartDataSourceSyncJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartDataSourceSyncJobError {
    fn code(&self) -> Option<&str> {
        StartDataSourceSyncJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartDataSourceSyncJobError {
    pub fn new(kind: StartDataSourceSyncJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartDataSourceSyncJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartDataSourceSyncJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartDataSourceSyncJobErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartDataSourceSyncJobErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartDataSourceSyncJobErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartDataSourceSyncJobErrorKind::ResourceInUseException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartDataSourceSyncJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartDataSourceSyncJobErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartDataSourceSyncJobErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for StartDataSourceSyncJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartDataSourceSyncJobErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartDataSourceSyncJobErrorKind::ConflictException(_inner) => Some(_inner),
            StartDataSourceSyncJobErrorKind::InternalServerException(_inner) => Some(_inner),
            StartDataSourceSyncJobErrorKind::ResourceInUseException(_inner) => Some(_inner),
            StartDataSourceSyncJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StartDataSourceSyncJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartDataSourceSyncJobErrorKind::ValidationException(_inner) => Some(_inner),
            StartDataSourceSyncJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopDataSourceSyncJobError {
    pub kind: StopDataSourceSyncJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopDataSourceSyncJobErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopDataSourceSyncJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopDataSourceSyncJobErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StopDataSourceSyncJobErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            StopDataSourceSyncJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StopDataSourceSyncJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StopDataSourceSyncJobErrorKind::ValidationException(_inner) => _inner.fmt(f),
            StopDataSourceSyncJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopDataSourceSyncJobError {
    fn code(&self) -> Option<&str> {
        StopDataSourceSyncJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopDataSourceSyncJobError {
    pub fn new(kind: StopDataSourceSyncJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopDataSourceSyncJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopDataSourceSyncJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopDataSourceSyncJobErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopDataSourceSyncJobErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopDataSourceSyncJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopDataSourceSyncJobErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopDataSourceSyncJobErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for StopDataSourceSyncJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopDataSourceSyncJobErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StopDataSourceSyncJobErrorKind::InternalServerException(_inner) => Some(_inner),
            StopDataSourceSyncJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StopDataSourceSyncJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            StopDataSourceSyncJobErrorKind::ValidationException(_inner) => Some(_inner),
            StopDataSourceSyncJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SubmitFeedbackError {
    pub kind: SubmitFeedbackErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SubmitFeedbackErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SubmitFeedbackError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SubmitFeedbackErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            SubmitFeedbackErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            SubmitFeedbackErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            SubmitFeedbackErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            SubmitFeedbackErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            SubmitFeedbackErrorKind::ValidationException(_inner) => _inner.fmt(f),
            SubmitFeedbackErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SubmitFeedbackError {
    fn code(&self) -> Option<&str> {
        SubmitFeedbackError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SubmitFeedbackError {
    pub fn new(kind: SubmitFeedbackErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SubmitFeedbackErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SubmitFeedbackErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            SubmitFeedbackErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            SubmitFeedbackErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SubmitFeedbackErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            SubmitFeedbackErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, SubmitFeedbackErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, SubmitFeedbackErrorKind::ValidationException(_))
    }
}
impl std::error::Error for SubmitFeedbackError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SubmitFeedbackErrorKind::AccessDeniedException(_inner) => Some(_inner),
            SubmitFeedbackErrorKind::InternalServerException(_inner) => Some(_inner),
            SubmitFeedbackErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            SubmitFeedbackErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            SubmitFeedbackErrorKind::ThrottlingException(_inner) => Some(_inner),
            SubmitFeedbackErrorKind::ValidationException(_inner) => Some(_inner),
            SubmitFeedbackErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InternalServerException(_))
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ValidationException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            TagResourceErrorKind::InternalServerException(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            TagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            TagResourceErrorKind::ValidationException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UntagResourceErrorKind::InternalServerException(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            UntagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            UntagResourceErrorKind::ValidationException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDataSourceError {
    pub kind: UpdateDataSourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDataSourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDataSourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDataSourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateDataSourceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateDataSourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateDataSourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateDataSourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateDataSourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateDataSourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDataSourceError {
    fn code(&self) -> Option<&str> {
        UpdateDataSourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDataSourceError {
    pub fn new(kind: UpdateDataSourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDataSourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDataSourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSourceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateDataSourceErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSourceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSourceErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSourceErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateDataSourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDataSourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateDataSourceErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateDataSourceErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateDataSourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateDataSourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateDataSourceErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateDataSourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateIndexError {
    pub kind: UpdateIndexErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateIndexErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateIndexError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateIndexErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateIndexErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateIndexErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateIndexErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateIndexErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            UpdateIndexErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateIndexErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateIndexErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateIndexError {
    fn code(&self) -> Option<&str> {
        UpdateIndexError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateIndexError {
    pub fn new(kind: UpdateIndexErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateIndexErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateIndexErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UpdateIndexErrorKind::AccessDeniedException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateIndexErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, UpdateIndexErrorKind::InternalServerException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIndexErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIndexErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateIndexErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateIndexErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateIndexError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateIndexErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateIndexErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateIndexErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateIndexErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateIndexErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            UpdateIndexErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateIndexErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateIndexErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateQuerySuggestionsBlockListError {
    pub kind: UpdateQuerySuggestionsBlockListErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateQuerySuggestionsBlockListErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateQuerySuggestionsBlockListError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateQuerySuggestionsBlockListErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateQuerySuggestionsBlockListErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateQuerySuggestionsBlockListErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            UpdateQuerySuggestionsBlockListErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateQuerySuggestionsBlockListErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateQuerySuggestionsBlockListErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateQuerySuggestionsBlockListErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateQuerySuggestionsBlockListError {
    fn code(&self) -> Option<&str> {
        UpdateQuerySuggestionsBlockListError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateQuerySuggestionsBlockListError {
    pub fn new(kind: UpdateQuerySuggestionsBlockListErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateQuerySuggestionsBlockListErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateQuerySuggestionsBlockListErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQuerySuggestionsBlockListErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQuerySuggestionsBlockListErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQuerySuggestionsBlockListErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQuerySuggestionsBlockListErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQuerySuggestionsBlockListErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQuerySuggestionsBlockListErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateQuerySuggestionsBlockListError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateQuerySuggestionsBlockListErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateQuerySuggestionsBlockListErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateQuerySuggestionsBlockListErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            UpdateQuerySuggestionsBlockListErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateQuerySuggestionsBlockListErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateQuerySuggestionsBlockListErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateQuerySuggestionsBlockListErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateQuerySuggestionsConfigError {
    pub kind: UpdateQuerySuggestionsConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateQuerySuggestionsConfigErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateQuerySuggestionsConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateQuerySuggestionsConfigErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateQuerySuggestionsConfigErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateQuerySuggestionsConfigErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateQuerySuggestionsConfigErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateQuerySuggestionsConfigErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateQuerySuggestionsConfigErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateQuerySuggestionsConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateQuerySuggestionsConfigError {
    fn code(&self) -> Option<&str> {
        UpdateQuerySuggestionsConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateQuerySuggestionsConfigError {
    pub fn new(kind: UpdateQuerySuggestionsConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateQuerySuggestionsConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateQuerySuggestionsConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQuerySuggestionsConfigErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQuerySuggestionsConfigErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQuerySuggestionsConfigErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQuerySuggestionsConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQuerySuggestionsConfigErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQuerySuggestionsConfigErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateQuerySuggestionsConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateQuerySuggestionsConfigErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateQuerySuggestionsConfigErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateQuerySuggestionsConfigErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateQuerySuggestionsConfigErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateQuerySuggestionsConfigErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateQuerySuggestionsConfigErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateQuerySuggestionsConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateThesaurusError {
    pub kind: UpdateThesaurusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateThesaurusErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateThesaurusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateThesaurusErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateThesaurusErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateThesaurusErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateThesaurusErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateThesaurusErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateThesaurusErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateThesaurusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateThesaurusError {
    fn code(&self) -> Option<&str> {
        UpdateThesaurusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateThesaurusError {
    pub fn new(kind: UpdateThesaurusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateThesaurusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateThesaurusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThesaurusErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateThesaurusErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThesaurusErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThesaurusErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateThesaurusErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateThesaurusErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateThesaurusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateThesaurusErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateThesaurusErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateThesaurusErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateThesaurusErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateThesaurusErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateThesaurusErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateThesaurusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ValidationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ValidationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ValidationException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ValidationException {}
/// See [`ValidationException`](crate::error::ValidationException)
pub mod validation_exception {
    /// A builder for [`ValidationException`](crate::error::ValidationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationException`](crate::error::ValidationException)
        pub fn build(self) -> crate::error::ValidationException {
            crate::error::ValidationException {
                message: self.message,
            }
        }
    }
}
impl ValidationException {
    /// Creates a new builder-style object to manufacture [`ValidationException`](crate::error::ValidationException)
    pub fn builder() -> crate::error::validation_exception::Builder {
        crate::error::validation_exception::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ThrottlingException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ThrottlingException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ThrottlingException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottlingException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ThrottlingException {}
/// See [`ThrottlingException`](crate::error::ThrottlingException)
pub mod throttling_exception {
    /// A builder for [`ThrottlingException`](crate::error::ThrottlingException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ThrottlingException`](crate::error::ThrottlingException)
        pub fn build(self) -> crate::error::ThrottlingException {
            crate::error::ThrottlingException {
                message: self.message,
            }
        }
    }
}
impl ThrottlingException {
    /// Creates a new builder-style object to manufacture [`ThrottlingException`](crate::error::ThrottlingException)
    pub fn builder() -> crate::error::throttling_exception::Builder {
        crate::error::throttling_exception::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServerException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServerException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServerException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerException {}
/// See [`InternalServerException`](crate::error::InternalServerException)
pub mod internal_server_exception {
    /// A builder for [`InternalServerException`](crate::error::InternalServerException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerException`](crate::error::InternalServerException)
        pub fn build(self) -> crate::error::InternalServerException {
            crate::error::InternalServerException {
                message: self.message,
            }
        }
    }
}
impl InternalServerException {
    /// Creates a new builder-style object to manufacture [`InternalServerException`](crate::error::InternalServerException)
    pub fn builder() -> crate::error::internal_server_exception::Builder {
        crate::error::internal_server_exception::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccessDeniedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccessDeniedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AccessDeniedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException)
pub mod access_denied_exception {
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException)
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message,
            }
        }
    }
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException)
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceQuotaExceededException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceQuotaExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceQuotaExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceQuotaExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceQuotaExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceQuotaExceededException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceQuotaExceededException {}
/// See [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
pub mod service_quota_exceeded_exception {
    /// A builder for [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
        pub fn build(self) -> crate::error::ServiceQuotaExceededException {
            crate::error::ServiceQuotaExceededException {
                message: self.message,
            }
        }
    }
}
impl ServiceQuotaExceededException {
    /// Creates a new builder-style object to manufacture [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
    pub fn builder() -> crate::error::service_quota_exceeded_exception::Builder {
        crate::error::service_quota_exceeded_exception::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceUnavailableException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceUnavailableException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceUnavailableException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceUnavailableException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceUnavailableException {}
/// See [`ResourceUnavailableException`](crate::error::ResourceUnavailableException)
pub mod resource_unavailable_exception {
    /// A builder for [`ResourceUnavailableException`](crate::error::ResourceUnavailableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceUnavailableException`](crate::error::ResourceUnavailableException)
        pub fn build(self) -> crate::error::ResourceUnavailableException {
            crate::error::ResourceUnavailableException {
                message: self.message,
            }
        }
    }
}
impl ResourceUnavailableException {
    /// Creates a new builder-style object to manufacture [`ResourceUnavailableException`](crate::error::ResourceUnavailableException)
    pub fn builder() -> crate::error::resource_unavailable_exception::Builder {
        crate::error::resource_unavailable_exception::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceInUseException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceInUseException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceInUseException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceInUseException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceInUseException {}
/// See [`ResourceInUseException`](crate::error::ResourceInUseException)
pub mod resource_in_use_exception {
    /// A builder for [`ResourceInUseException`](crate::error::ResourceInUseException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceInUseException`](crate::error::ResourceInUseException)
        pub fn build(self) -> crate::error::ResourceInUseException {
            crate::error::ResourceInUseException {
                message: self.message,
            }
        }
    }
}
impl ResourceInUseException {
    /// Creates a new builder-style object to manufacture [`ResourceInUseException`](crate::error::ResourceInUseException)
    pub fn builder() -> crate::error::resource_in_use_exception::Builder {
        crate::error::resource_in_use_exception::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceAlreadyExistException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceAlreadyExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceAlreadyExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceAlreadyExistException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceAlreadyExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceAlreadyExistException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceAlreadyExistException {}
/// See [`ResourceAlreadyExistException`](crate::error::ResourceAlreadyExistException)
pub mod resource_already_exist_exception {
    /// A builder for [`ResourceAlreadyExistException`](crate::error::ResourceAlreadyExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceAlreadyExistException`](crate::error::ResourceAlreadyExistException)
        pub fn build(self) -> crate::error::ResourceAlreadyExistException {
            crate::error::ResourceAlreadyExistException {
                message: self.message,
            }
        }
    }
}
impl ResourceAlreadyExistException {
    /// Creates a new builder-style object to manufacture [`ResourceAlreadyExistException`](crate::error::ResourceAlreadyExistException)
    pub fn builder() -> crate::error::resource_already_exist_exception::Builder {
        crate::error::resource_already_exist_exception::Builder::default()
    }
}
