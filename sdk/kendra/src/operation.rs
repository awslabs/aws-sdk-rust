// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Removes one or more documents from an index. The documents must have
/// been added with the <code>BatchPutDocument</code> operation.</p>
/// <p>The documents are deleted asynchronously. You can see the progress of
/// the deletion by using AWS CloudWatch. Any error messages related to the
/// processing of the batch are sent to you CloudWatch log.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchDeleteDocument {
    _private: (),
}
impl BatchDeleteDocument {
    /// Creates a new builder-style object to manufacture [`BatchDeleteDocumentInput`](crate::input::BatchDeleteDocumentInput)
    pub fn builder() -> crate::input::batch_delete_document_input::Builder {
        crate::input::batch_delete_document_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchDeleteDocument {
    type Output = std::result::Result<
        crate::output::BatchDeleteDocumentOutput,
        crate::error::BatchDeleteDocumentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_delete_document_error(response)
        } else {
            crate::operation_deser::parse_batch_delete_document_response(response)
        }
    }
}

/// <p>Returns the indexing status for one or more documents submitted
/// with the <a href="https://docs.aws.amazon.com/kendra/latest/dg/API_BatchPutDocument.html">
/// BatchPutDocument</a> operation.</p>
/// <p>When you use the <code>BatchPutDocument</code> operation,
/// documents are indexed asynchronously. You can use the
/// <code>BatchGetDocumentStatus</code> operation to get the current
/// status of a list of documents so that you can determine if they have
/// been successfully indexed.</p>
/// <p>You can also use the <code>BatchGetDocumentStatus</code> operation
/// to check the status of the <a href="https://docs.aws.amazon.com/kendra/latest/dg/API_BatchDeleteDocument.html">
/// BatchDeleteDocument</a> operation. When a document is
/// deleted from the index, Amazon Kendra returns <code>NOT_FOUND</code> as the
/// status.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchGetDocumentStatus {
    _private: (),
}
impl BatchGetDocumentStatus {
    /// Creates a new builder-style object to manufacture [`BatchGetDocumentStatusInput`](crate::input::BatchGetDocumentStatusInput)
    pub fn builder() -> crate::input::batch_get_document_status_input::Builder {
        crate::input::batch_get_document_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchGetDocumentStatus {
    type Output = std::result::Result<
        crate::output::BatchGetDocumentStatusOutput,
        crate::error::BatchGetDocumentStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_get_document_status_error(response)
        } else {
            crate::operation_deser::parse_batch_get_document_status_response(response)
        }
    }
}

/// <p>Adds one or more documents to an index.</p>
/// <p>The <code>BatchPutDocument</code> operation enables you to ingest
/// inline documents or a set of documents stored in an Amazon S3 bucket. Use
/// this operation to ingest your text and unstructured text into an index,
/// add custom attributes to the documents, and to attach an access control
/// list to the documents added to the index.</p>
/// <p>The documents are indexed asynchronously. You can see the progress of
/// the batch using AWS CloudWatch. Any error messages related to processing
/// the batch are sent to your AWS CloudWatch log.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchPutDocument {
    _private: (),
}
impl BatchPutDocument {
    /// Creates a new builder-style object to manufacture [`BatchPutDocumentInput`](crate::input::BatchPutDocumentInput)
    pub fn builder() -> crate::input::batch_put_document_input::Builder {
        crate::input::batch_put_document_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchPutDocument {
    type Output = std::result::Result<
        crate::output::BatchPutDocumentOutput,
        crate::error::BatchPutDocumentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_put_document_error(response)
        } else {
            crate::operation_deser::parse_batch_put_document_response(response)
        }
    }
}

/// <p>Clears existing query suggestions from an index.</p>
/// <p>This deletes existing suggestions only, not the queries
/// in the query log. After you clear suggestions, Amazon Kendra learns
/// new suggestions based on new queries added to the query log
/// from the time you cleared suggestions. If you do not see any
/// new suggestions, then please allow Amazon Kendra to collect
/// enough queries to learn new suggestions.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ClearQuerySuggestions {
    _private: (),
}
impl ClearQuerySuggestions {
    /// Creates a new builder-style object to manufacture [`ClearQuerySuggestionsInput`](crate::input::ClearQuerySuggestionsInput)
    pub fn builder() -> crate::input::clear_query_suggestions_input::Builder {
        crate::input::clear_query_suggestions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ClearQuerySuggestions {
    type Output = std::result::Result<
        crate::output::ClearQuerySuggestionsOutput,
        crate::error::ClearQuerySuggestionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_clear_query_suggestions_error(response)
        } else {
            crate::operation_deser::parse_clear_query_suggestions_response(response)
        }
    }
}

/// <p>Creates a data source that you use to with an Amazon Kendra index. </p>
/// <p>You specify a name, data source connector type and description for
/// your data source. You also specify configuration information such as
/// document metadata (author, source URI, and so on) and user context
/// information.</p>
/// <p>
/// <code>CreateDataSource</code> is a synchronous operation. The
/// operation returns 200 if the data source was successfully created.
/// Otherwise, an exception is raised.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDataSource {
    _private: (),
}
impl CreateDataSource {
    /// Creates a new builder-style object to manufacture [`CreateDataSourceInput`](crate::input::CreateDataSourceInput)
    pub fn builder() -> crate::input::create_data_source_input::Builder {
        crate::input::create_data_source_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDataSource {
    type Output = std::result::Result<
        crate::output::CreateDataSourceOutput,
        crate::error::CreateDataSourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_data_source_error(response)
        } else {
            crate::operation_deser::parse_create_data_source_response(response)
        }
    }
}

/// <p>Creates an new set of frequently asked question (FAQ) questions and answers.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateFaq {
    _private: (),
}
impl CreateFaq {
    /// Creates a new builder-style object to manufacture [`CreateFaqInput`](crate::input::CreateFaqInput)
    pub fn builder() -> crate::input::create_faq_input::Builder {
        crate::input::create_faq_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateFaq {
    type Output = std::result::Result<crate::output::CreateFaqOutput, crate::error::CreateFaqError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_faq_error(response)
        } else {
            crate::operation_deser::parse_create_faq_response(response)
        }
    }
}

/// <p>Creates a new Amazon Kendra index. Index creation is an asynchronous
/// operation. To determine if index creation has completed, check the
/// <code>Status</code> field returned from a call to
/// <code>DescribeIndex</code>. The <code>Status</code> field is set to
/// <code>ACTIVE</code> when the index is ready to use.</p>
/// <p>Once the index is active you can index your documents using the
/// <code>BatchPutDocument</code> operation or using one of the supported
/// data sources. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateIndex {
    _private: (),
}
impl CreateIndex {
    /// Creates a new builder-style object to manufacture [`CreateIndexInput`](crate::input::CreateIndexInput)
    pub fn builder() -> crate::input::create_index_input::Builder {
        crate::input::create_index_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateIndex {
    type Output =
        std::result::Result<crate::output::CreateIndexOutput, crate::error::CreateIndexError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_index_error(response)
        } else {
            crate::operation_deser::parse_create_index_response(response)
        }
    }
}

/// <p>Creates a block list to exlcude certain queries from suggestions.</p>
/// <p>Any query that contains words or phrases specified in the block
/// list is blocked or filtered out from being shown as a suggestion.</p>
/// <p>You need to provide the file location of your block list text file
/// in your S3 bucket. In your text file, enter each block word or phrase
/// on a separate line.</p>
/// <p>For information on the current quota limits for block lists, see
/// <a href="https://docs.aws.amazon.com/kendra/latest/dg/quotas.html">Quotas
/// for Amazon Kendra</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateQuerySuggestionsBlockList {
    _private: (),
}
impl CreateQuerySuggestionsBlockList {
    /// Creates a new builder-style object to manufacture [`CreateQuerySuggestionsBlockListInput`](crate::input::CreateQuerySuggestionsBlockListInput)
    pub fn builder() -> crate::input::create_query_suggestions_block_list_input::Builder {
        crate::input::create_query_suggestions_block_list_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateQuerySuggestionsBlockList {
    type Output = std::result::Result<
        crate::output::CreateQuerySuggestionsBlockListOutput,
        crate::error::CreateQuerySuggestionsBlockListError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_query_suggestions_block_list_error(response)
        } else {
            crate::operation_deser::parse_create_query_suggestions_block_list_response(response)
        }
    }
}

/// <p>Creates a thesaurus for an index. The thesaurus
/// contains a list of synonyms in Solr format.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateThesaurus {
    _private: (),
}
impl CreateThesaurus {
    /// Creates a new builder-style object to manufacture [`CreateThesaurusInput`](crate::input::CreateThesaurusInput)
    pub fn builder() -> crate::input::create_thesaurus_input::Builder {
        crate::input::create_thesaurus_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateThesaurus {
    type Output = std::result::Result<
        crate::output::CreateThesaurusOutput,
        crate::error::CreateThesaurusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_thesaurus_error(response)
        } else {
            crate::operation_deser::parse_create_thesaurus_response(response)
        }
    }
}

/// <p>Deletes an Amazon Kendra data source. An exception is not thrown if the
/// data source is already being deleted. While the data source is being
/// deleted, the <code>Status</code> field returned by a call to the
/// <code>DescribeDataSource</code> operation is set to
/// <code>DELETING</code>. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/delete-data-source.html">Deleting Data Sources</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDataSource {
    _private: (),
}
impl DeleteDataSource {
    /// Creates a new builder-style object to manufacture [`DeleteDataSourceInput`](crate::input::DeleteDataSourceInput)
    pub fn builder() -> crate::input::delete_data_source_input::Builder {
        crate::input::delete_data_source_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDataSource {
    type Output = std::result::Result<
        crate::output::DeleteDataSourceOutput,
        crate::error::DeleteDataSourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_data_source_error(response)
        } else {
            crate::operation_deser::parse_delete_data_source_response(response)
        }
    }
}

/// <p>Removes an FAQ from an index.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteFaq {
    _private: (),
}
impl DeleteFaq {
    /// Creates a new builder-style object to manufacture [`DeleteFaqInput`](crate::input::DeleteFaqInput)
    pub fn builder() -> crate::input::delete_faq_input::Builder {
        crate::input::delete_faq_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteFaq {
    type Output = std::result::Result<crate::output::DeleteFaqOutput, crate::error::DeleteFaqError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_faq_error(response)
        } else {
            crate::operation_deser::parse_delete_faq_response(response)
        }
    }
}

/// <p>Deletes an existing Amazon Kendra index. An exception is not thrown if
/// the index is already being deleted. While the index is being deleted, the
/// <code>Status</code> field returned by a call to the
/// <code>DescribeIndex</code> operation is set to
/// <code>DELETING</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteIndex {
    _private: (),
}
impl DeleteIndex {
    /// Creates a new builder-style object to manufacture [`DeleteIndexInput`](crate::input::DeleteIndexInput)
    pub fn builder() -> crate::input::delete_index_input::Builder {
        crate::input::delete_index_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteIndex {
    type Output =
        std::result::Result<crate::output::DeleteIndexOutput, crate::error::DeleteIndexError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_index_error(response)
        } else {
            crate::operation_deser::parse_delete_index_response(response)
        }
    }
}

/// <p>Deletes a block list used for query suggestions for an index.</p>
/// <p>A deleted block list might not take effect right away. Amazon Kendra
/// needs to refresh the entire suggestions list to add back the
/// queries that were previously blocked.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteQuerySuggestionsBlockList {
    _private: (),
}
impl DeleteQuerySuggestionsBlockList {
    /// Creates a new builder-style object to manufacture [`DeleteQuerySuggestionsBlockListInput`](crate::input::DeleteQuerySuggestionsBlockListInput)
    pub fn builder() -> crate::input::delete_query_suggestions_block_list_input::Builder {
        crate::input::delete_query_suggestions_block_list_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteQuerySuggestionsBlockList {
    type Output = std::result::Result<
        crate::output::DeleteQuerySuggestionsBlockListOutput,
        crate::error::DeleteQuerySuggestionsBlockListError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_query_suggestions_block_list_error(response)
        } else {
            crate::operation_deser::parse_delete_query_suggestions_block_list_response(response)
        }
    }
}

/// <p>Deletes an existing Amazon Kendra thesaurus.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteThesaurus {
    _private: (),
}
impl DeleteThesaurus {
    /// Creates a new builder-style object to manufacture [`DeleteThesaurusInput`](crate::input::DeleteThesaurusInput)
    pub fn builder() -> crate::input::delete_thesaurus_input::Builder {
        crate::input::delete_thesaurus_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteThesaurus {
    type Output = std::result::Result<
        crate::output::DeleteThesaurusOutput,
        crate::error::DeleteThesaurusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_thesaurus_error(response)
        } else {
            crate::operation_deser::parse_delete_thesaurus_response(response)
        }
    }
}

/// <p>Gets information about a Amazon Kendra data source.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDataSource {
    _private: (),
}
impl DescribeDataSource {
    /// Creates a new builder-style object to manufacture [`DescribeDataSourceInput`](crate::input::DescribeDataSourceInput)
    pub fn builder() -> crate::input::describe_data_source_input::Builder {
        crate::input::describe_data_source_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDataSource {
    type Output = std::result::Result<
        crate::output::DescribeDataSourceOutput,
        crate::error::DescribeDataSourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_data_source_error(response)
        } else {
            crate::operation_deser::parse_describe_data_source_response(response)
        }
    }
}

/// <p>Gets information about an FAQ list.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeFaq {
    _private: (),
}
impl DescribeFaq {
    /// Creates a new builder-style object to manufacture [`DescribeFaqInput`](crate::input::DescribeFaqInput)
    pub fn builder() -> crate::input::describe_faq_input::Builder {
        crate::input::describe_faq_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeFaq {
    type Output =
        std::result::Result<crate::output::DescribeFaqOutput, crate::error::DescribeFaqError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_faq_error(response)
        } else {
            crate::operation_deser::parse_describe_faq_response(response)
        }
    }
}

/// <p>Describes an existing Amazon Kendra index</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeIndex {
    _private: (),
}
impl DescribeIndex {
    /// Creates a new builder-style object to manufacture [`DescribeIndexInput`](crate::input::DescribeIndexInput)
    pub fn builder() -> crate::input::describe_index_input::Builder {
        crate::input::describe_index_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeIndex {
    type Output =
        std::result::Result<crate::output::DescribeIndexOutput, crate::error::DescribeIndexError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_index_error(response)
        } else {
            crate::operation_deser::parse_describe_index_response(response)
        }
    }
}

/// <p>Describes a block list used for query suggestions for an index.</p>
/// <p>This is used to check the current settings that are applied to a
/// block list.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeQuerySuggestionsBlockList {
    _private: (),
}
impl DescribeQuerySuggestionsBlockList {
    /// Creates a new builder-style object to manufacture [`DescribeQuerySuggestionsBlockListInput`](crate::input::DescribeQuerySuggestionsBlockListInput)
    pub fn builder() -> crate::input::describe_query_suggestions_block_list_input::Builder {
        crate::input::describe_query_suggestions_block_list_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeQuerySuggestionsBlockList {
    type Output = std::result::Result<
        crate::output::DescribeQuerySuggestionsBlockListOutput,
        crate::error::DescribeQuerySuggestionsBlockListError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_query_suggestions_block_list_error(response)
        } else {
            crate::operation_deser::parse_describe_query_suggestions_block_list_response(response)
        }
    }
}

/// <p>Describes the settings of query suggestions for an index.</p>
/// <p>This is used to check the current settings applied
/// to query suggestions.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeQuerySuggestionsConfig {
    _private: (),
}
impl DescribeQuerySuggestionsConfig {
    /// Creates a new builder-style object to manufacture [`DescribeQuerySuggestionsConfigInput`](crate::input::DescribeQuerySuggestionsConfigInput)
    pub fn builder() -> crate::input::describe_query_suggestions_config_input::Builder {
        crate::input::describe_query_suggestions_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeQuerySuggestionsConfig {
    type Output = std::result::Result<
        crate::output::DescribeQuerySuggestionsConfigOutput,
        crate::error::DescribeQuerySuggestionsConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_query_suggestions_config_error(response)
        } else {
            crate::operation_deser::parse_describe_query_suggestions_config_response(response)
        }
    }
}

/// <p>Describes an existing Amazon Kendra thesaurus.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeThesaurus {
    _private: (),
}
impl DescribeThesaurus {
    /// Creates a new builder-style object to manufacture [`DescribeThesaurusInput`](crate::input::DescribeThesaurusInput)
    pub fn builder() -> crate::input::describe_thesaurus_input::Builder {
        crate::input::describe_thesaurus_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeThesaurus {
    type Output = std::result::Result<
        crate::output::DescribeThesaurusOutput,
        crate::error::DescribeThesaurusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_thesaurus_error(response)
        } else {
            crate::operation_deser::parse_describe_thesaurus_response(response)
        }
    }
}

/// <p>Fetches the queries that are suggested to your users.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetQuerySuggestions {
    _private: (),
}
impl GetQuerySuggestions {
    /// Creates a new builder-style object to manufacture [`GetQuerySuggestionsInput`](crate::input::GetQuerySuggestionsInput)
    pub fn builder() -> crate::input::get_query_suggestions_input::Builder {
        crate::input::get_query_suggestions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetQuerySuggestions {
    type Output = std::result::Result<
        crate::output::GetQuerySuggestionsOutput,
        crate::error::GetQuerySuggestionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_query_suggestions_error(response)
        } else {
            crate::operation_deser::parse_get_query_suggestions_response(response)
        }
    }
}

/// <p>Lists the data sources that you have created.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDataSources {
    _private: (),
}
impl ListDataSources {
    /// Creates a new builder-style object to manufacture [`ListDataSourcesInput`](crate::input::ListDataSourcesInput)
    pub fn builder() -> crate::input::list_data_sources_input::Builder {
        crate::input::list_data_sources_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDataSources {
    type Output = std::result::Result<
        crate::output::ListDataSourcesOutput,
        crate::error::ListDataSourcesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_data_sources_error(response)
        } else {
            crate::operation_deser::parse_list_data_sources_response(response)
        }
    }
}

/// <p>Gets statistics about synchronizing Amazon Kendra with a data
/// source.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDataSourceSyncJobs {
    _private: (),
}
impl ListDataSourceSyncJobs {
    /// Creates a new builder-style object to manufacture [`ListDataSourceSyncJobsInput`](crate::input::ListDataSourceSyncJobsInput)
    pub fn builder() -> crate::input::list_data_source_sync_jobs_input::Builder {
        crate::input::list_data_source_sync_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDataSourceSyncJobs {
    type Output = std::result::Result<
        crate::output::ListDataSourceSyncJobsOutput,
        crate::error::ListDataSourceSyncJobsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_data_source_sync_jobs_error(response)
        } else {
            crate::operation_deser::parse_list_data_source_sync_jobs_response(response)
        }
    }
}

/// <p>Gets a list of FAQ lists associated with an index.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListFaqs {
    _private: (),
}
impl ListFaqs {
    /// Creates a new builder-style object to manufacture [`ListFaqsInput`](crate::input::ListFaqsInput)
    pub fn builder() -> crate::input::list_faqs_input::Builder {
        crate::input::list_faqs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListFaqs {
    type Output = std::result::Result<crate::output::ListFaqsOutput, crate::error::ListFaqsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_faqs_error(response)
        } else {
            crate::operation_deser::parse_list_faqs_response(response)
        }
    }
}

/// <p>Lists the Amazon Kendra indexes that you have created.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListIndices {
    _private: (),
}
impl ListIndices {
    /// Creates a new builder-style object to manufacture [`ListIndicesInput`](crate::input::ListIndicesInput)
    pub fn builder() -> crate::input::list_indices_input::Builder {
        crate::input::list_indices_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListIndices {
    type Output =
        std::result::Result<crate::output::ListIndicesOutput, crate::error::ListIndicesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_indices_error(response)
        } else {
            crate::operation_deser::parse_list_indices_response(response)
        }
    }
}

/// <p>Lists the block lists used for query suggestions for an index.</p>
/// <p>For information on the current quota limits for block lists, see
/// <a href="https://docs.aws.amazon.com/kendra/latest/dg/quotas.html">Quotas
/// for Amazon Kendra</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListQuerySuggestionsBlockLists {
    _private: (),
}
impl ListQuerySuggestionsBlockLists {
    /// Creates a new builder-style object to manufacture [`ListQuerySuggestionsBlockListsInput`](crate::input::ListQuerySuggestionsBlockListsInput)
    pub fn builder() -> crate::input::list_query_suggestions_block_lists_input::Builder {
        crate::input::list_query_suggestions_block_lists_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListQuerySuggestionsBlockLists {
    type Output = std::result::Result<
        crate::output::ListQuerySuggestionsBlockListsOutput,
        crate::error::ListQuerySuggestionsBlockListsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_query_suggestions_block_lists_error(response)
        } else {
            crate::operation_deser::parse_list_query_suggestions_block_lists_response(response)
        }
    }
}

/// <p>Gets a list of tags associated with a specified resource. Indexes,
/// FAQs, and data sources can have tags associated with them.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Lists the Amazon Kendra thesauri associated with an index.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListThesauri {
    _private: (),
}
impl ListThesauri {
    /// Creates a new builder-style object to manufacture [`ListThesauriInput`](crate::input::ListThesauriInput)
    pub fn builder() -> crate::input::list_thesauri_input::Builder {
        crate::input::list_thesauri_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListThesauri {
    type Output =
        std::result::Result<crate::output::ListThesauriOutput, crate::error::ListThesauriError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_thesauri_error(response)
        } else {
            crate::operation_deser::parse_list_thesauri_response(response)
        }
    }
}

/// <p>Searches an active index. Use this API to search your documents
/// using query. The <code>Query</code> operation enables to do faceted
/// search and to filter results based on document attributes.</p>
/// <p>It also enables you to provide user context that Amazon Kendra uses
/// to enforce document access control in the search results. </p>
/// <p>Amazon Kendra searches your index for text content and question and
/// answer (FAQ) content. By default the response contains three types of
/// results.</p>
/// <ul>
/// <li>
/// <p>Relevant passages</p>
/// </li>
/// <li>
/// <p>Matching FAQs</p>
/// </li>
/// <li>
/// <p>Relevant documents</p>
/// </li>
/// </ul>
/// <p>You can specify that the query return only one type of result using
/// the <code>QueryResultTypeConfig</code> parameter.</p>
/// <p>Each query returns the 100 most relevant results. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct Query {
    _private: (),
}
impl Query {
    /// Creates a new builder-style object to manufacture [`QueryInput`](crate::input::QueryInput)
    pub fn builder() -> crate::input::query_input::Builder {
        crate::input::query_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for Query {
    type Output = std::result::Result<crate::output::QueryOutput, crate::error::QueryError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_query_error(response)
        } else {
            crate::operation_deser::parse_query_response(response)
        }
    }
}

/// <p>Starts a synchronization job for a data source. If a synchronization
/// job is already in progress, Amazon Kendra returns a
/// <code>ResourceInUseException</code> exception.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartDataSourceSyncJob {
    _private: (),
}
impl StartDataSourceSyncJob {
    /// Creates a new builder-style object to manufacture [`StartDataSourceSyncJobInput`](crate::input::StartDataSourceSyncJobInput)
    pub fn builder() -> crate::input::start_data_source_sync_job_input::Builder {
        crate::input::start_data_source_sync_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartDataSourceSyncJob {
    type Output = std::result::Result<
        crate::output::StartDataSourceSyncJobOutput,
        crate::error::StartDataSourceSyncJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_data_source_sync_job_error(response)
        } else {
            crate::operation_deser::parse_start_data_source_sync_job_response(response)
        }
    }
}

/// <p>Stops a running synchronization job. You can't stop a scheduled
/// synchronization job.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopDataSourceSyncJob {
    _private: (),
}
impl StopDataSourceSyncJob {
    /// Creates a new builder-style object to manufacture [`StopDataSourceSyncJobInput`](crate::input::StopDataSourceSyncJobInput)
    pub fn builder() -> crate::input::stop_data_source_sync_job_input::Builder {
        crate::input::stop_data_source_sync_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopDataSourceSyncJob {
    type Output = std::result::Result<
        crate::output::StopDataSourceSyncJobOutput,
        crate::error::StopDataSourceSyncJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_data_source_sync_job_error(response)
        } else {
            crate::operation_deser::parse_stop_data_source_sync_job_response(response)
        }
    }
}

/// <p>Enables you to provide feedback to Amazon Kendra to improve the
/// performance of the service. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SubmitFeedback {
    _private: (),
}
impl SubmitFeedback {
    /// Creates a new builder-style object to manufacture [`SubmitFeedbackInput`](crate::input::SubmitFeedbackInput)
    pub fn builder() -> crate::input::submit_feedback_input::Builder {
        crate::input::submit_feedback_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SubmitFeedback {
    type Output =
        std::result::Result<crate::output::SubmitFeedbackOutput, crate::error::SubmitFeedbackError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_submit_feedback_error(response)
        } else {
            crate::operation_deser::parse_submit_feedback_response(response)
        }
    }
}

/// <p>Adds the specified tag to the specified index, FAQ, or data source
/// resource. If the tag already exists, the existing value is replaced with
/// the new value.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Removes a tag from an index, FAQ, or a data source.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Updates an existing Amazon Kendra data source.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDataSource {
    _private: (),
}
impl UpdateDataSource {
    /// Creates a new builder-style object to manufacture [`UpdateDataSourceInput`](crate::input::UpdateDataSourceInput)
    pub fn builder() -> crate::input::update_data_source_input::Builder {
        crate::input::update_data_source_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDataSource {
    type Output = std::result::Result<
        crate::output::UpdateDataSourceOutput,
        crate::error::UpdateDataSourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_data_source_error(response)
        } else {
            crate::operation_deser::parse_update_data_source_response(response)
        }
    }
}

/// <p>Updates an existing Amazon Kendra index.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateIndex {
    _private: (),
}
impl UpdateIndex {
    /// Creates a new builder-style object to manufacture [`UpdateIndexInput`](crate::input::UpdateIndexInput)
    pub fn builder() -> crate::input::update_index_input::Builder {
        crate::input::update_index_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateIndex {
    type Output =
        std::result::Result<crate::output::UpdateIndexOutput, crate::error::UpdateIndexError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_index_error(response)
        } else {
            crate::operation_deser::parse_update_index_response(response)
        }
    }
}

/// <p>Updates a block list used for query suggestions for an index.</p>
/// <p>Updates to a block list might not take effect right away. Amazon Kendra
/// needs to refresh the entire suggestions list to apply any updates to the
/// block list. Other changes not related to the block list apply immediately.</p>
/// <p>If a block list is updating, then you need to wait for the first update to
/// finish before submitting another update.</p>
/// <p>Amazon Kendra supports partial updates, so you only need to provide the fields
/// you want to update.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateQuerySuggestionsBlockList {
    _private: (),
}
impl UpdateQuerySuggestionsBlockList {
    /// Creates a new builder-style object to manufacture [`UpdateQuerySuggestionsBlockListInput`](crate::input::UpdateQuerySuggestionsBlockListInput)
    pub fn builder() -> crate::input::update_query_suggestions_block_list_input::Builder {
        crate::input::update_query_suggestions_block_list_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateQuerySuggestionsBlockList {
    type Output = std::result::Result<
        crate::output::UpdateQuerySuggestionsBlockListOutput,
        crate::error::UpdateQuerySuggestionsBlockListError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_query_suggestions_block_list_error(response)
        } else {
            crate::operation_deser::parse_update_query_suggestions_block_list_response(response)
        }
    }
}

/// <p>Updates the settings of query suggestions for an index.</p>
/// <p>Amazon Kendra supports partial updates, so you only need to provide
/// the fields you want to update.</p>
/// <p>If an update is currently processing (i.e. 'happening'), you
/// need to wait for the update to finish before making another update.</p>
/// <p>Updates to query suggestions settings might not take effect right away.
/// The time for your updated settings to take effect depends on the updates
/// made and the number of search queries in your index.</p>
/// <p>You can still enable/disable query suggestions at any time.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateQuerySuggestionsConfig {
    _private: (),
}
impl UpdateQuerySuggestionsConfig {
    /// Creates a new builder-style object to manufacture [`UpdateQuerySuggestionsConfigInput`](crate::input::UpdateQuerySuggestionsConfigInput)
    pub fn builder() -> crate::input::update_query_suggestions_config_input::Builder {
        crate::input::update_query_suggestions_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateQuerySuggestionsConfig {
    type Output = std::result::Result<
        crate::output::UpdateQuerySuggestionsConfigOutput,
        crate::error::UpdateQuerySuggestionsConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_query_suggestions_config_error(response)
        } else {
            crate::operation_deser::parse_update_query_suggestions_config_response(response)
        }
    }
}

/// <p>Updates a thesaurus file associated with an index.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateThesaurus {
    _private: (),
}
impl UpdateThesaurus {
    /// Creates a new builder-style object to manufacture [`UpdateThesaurusInput`](crate::input::UpdateThesaurusInput)
    pub fn builder() -> crate::input::update_thesaurus_input::Builder {
        crate::input::update_thesaurus_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateThesaurus {
    type Output = std::result::Result<
        crate::output::UpdateThesaurusOutput,
        crate::error::UpdateThesaurusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_thesaurus_error(response)
        } else {
            crate::operation_deser::parse_update_thesaurus_response(response)
        }
    }
}
