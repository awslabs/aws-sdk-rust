// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Information required to find a specific file in an Amazon S3 bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3Path {
    /// <p>The name of the S3 bucket that contains the file.</p>
    #[doc(hidden)]
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The name of the file.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
}
impl S3Path {
    /// <p>The name of the S3 bucket that contains the file.</p>
    pub fn bucket(&self) -> std::option::Option<&str> {
        self.bucket.as_deref()
    }
    /// <p>The name of the file.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
}
/// See [`S3Path`](crate::model::S3Path).
pub mod s3_path {

    /// A builder for [`S3Path`](crate::model::S3Path).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the S3 bucket that contains the file.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        /// <p>The name of the S3 bucket that contains the file.</p>
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The name of the file.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The name of the file.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// Consumes the builder and constructs a [`S3Path`](crate::model::S3Path).
        pub fn build(self) -> crate::model::S3Path {
            crate::model::S3Path {
                bucket: self.bucket,
                key: self.key,
            }
        }
    }
}
impl S3Path {
    /// Creates a new builder-style object to manufacture [`S3Path`](crate::model::S3Path).
    pub fn builder() -> crate::model::s3_path::Builder {
        crate::model::s3_path::Builder::default()
    }
}

/// When writing a match expression against `Mode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let mode = unimplemented!();
/// match mode {
///     Mode::Enabled => { /* ... */ },
///     Mode::LearnOnly => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `mode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Mode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Mode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Mode::NewFeature` is defined.
/// Specifically, when `mode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Mode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Mode {
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    #[allow(missing_docs)] // documentation missing in model
    LearnOnly,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Mode {
    fn from(s: &str) -> Self {
        match s {
            "ENABLED" => Mode::Enabled,
            "LEARN_ONLY" => Mode::LearnOnly,
            other => Mode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Mode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Mode::from(s))
    }
}
impl Mode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Mode::Enabled => "ENABLED",
            Mode::LearnOnly => "LEARN_ONLY",
            Mode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ENABLED", "LEARN_ONLY"]
    }
}
impl AsRef<str> for Mode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides the configuration information to fetch access levels of groups and users from an IAM Identity Center (successor to Single Sign-On) identity source. This is useful for user context filtering, where search results are filtered based on the user or their group access to documents. You can also use the <a href="https://docs.aws.amazon.com/kendra/latest/dg/API_PutPrincipalMapping.html">PutPrincipalMapping</a> API to map users to their groups so that you only need to provide the user ID when you issue the query.</p>
/// <p>To set up an IAM Identity Center identity source in the console to use with Amazon Kendra, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/getting-started-aws-sso.html">Getting started with an IAM Identity Center identity source</a>. You must also grant the required permissions to use IAM Identity Center with Amazon Kendra. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/iam-roles.html#iam-roles-aws-sso">IAM roles for IAM Identity Center</a>.</p>
/// <p>Amazon Kendra currently does not support using <code>UserGroupResolutionConfiguration</code> with an Amazon Web Services organization member account for your IAM Identity Center identify source. You must create your index in the management account for the organization in order to use <code>UserGroupResolutionConfiguration</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UserGroupResolutionConfiguration {
    /// <p>The identity store provider (mode) you want to use to fetch access levels of groups and users. IAM Identity Center (successor to Single Sign-On) is currently the only available mode. Your users and groups must exist in an IAM Identity Center identity source in order to use this mode.</p>
    #[doc(hidden)]
    pub user_group_resolution_mode: std::option::Option<crate::model::UserGroupResolutionMode>,
}
impl UserGroupResolutionConfiguration {
    /// <p>The identity store provider (mode) you want to use to fetch access levels of groups and users. IAM Identity Center (successor to Single Sign-On) is currently the only available mode. Your users and groups must exist in an IAM Identity Center identity source in order to use this mode.</p>
    pub fn user_group_resolution_mode(
        &self,
    ) -> std::option::Option<&crate::model::UserGroupResolutionMode> {
        self.user_group_resolution_mode.as_ref()
    }
}
/// See [`UserGroupResolutionConfiguration`](crate::model::UserGroupResolutionConfiguration).
pub mod user_group_resolution_configuration {

    /// A builder for [`UserGroupResolutionConfiguration`](crate::model::UserGroupResolutionConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_group_resolution_mode:
            std::option::Option<crate::model::UserGroupResolutionMode>,
    }
    impl Builder {
        /// <p>The identity store provider (mode) you want to use to fetch access levels of groups and users. IAM Identity Center (successor to Single Sign-On) is currently the only available mode. Your users and groups must exist in an IAM Identity Center identity source in order to use this mode.</p>
        pub fn user_group_resolution_mode(
            mut self,
            input: crate::model::UserGroupResolutionMode,
        ) -> Self {
            self.user_group_resolution_mode = Some(input);
            self
        }
        /// <p>The identity store provider (mode) you want to use to fetch access levels of groups and users. IAM Identity Center (successor to Single Sign-On) is currently the only available mode. Your users and groups must exist in an IAM Identity Center identity source in order to use this mode.</p>
        pub fn set_user_group_resolution_mode(
            mut self,
            input: std::option::Option<crate::model::UserGroupResolutionMode>,
        ) -> Self {
            self.user_group_resolution_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`UserGroupResolutionConfiguration`](crate::model::UserGroupResolutionConfiguration).
        pub fn build(self) -> crate::model::UserGroupResolutionConfiguration {
            crate::model::UserGroupResolutionConfiguration {
                user_group_resolution_mode: self.user_group_resolution_mode,
            }
        }
    }
}
impl UserGroupResolutionConfiguration {
    /// Creates a new builder-style object to manufacture [`UserGroupResolutionConfiguration`](crate::model::UserGroupResolutionConfiguration).
    pub fn builder() -> crate::model::user_group_resolution_configuration::Builder {
        crate::model::user_group_resolution_configuration::Builder::default()
    }
}

/// When writing a match expression against `UserGroupResolutionMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let usergroupresolutionmode = unimplemented!();
/// match usergroupresolutionmode {
///     UserGroupResolutionMode::AwsSso => { /* ... */ },
///     UserGroupResolutionMode::None => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `usergroupresolutionmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UserGroupResolutionMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UserGroupResolutionMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UserGroupResolutionMode::NewFeature` is defined.
/// Specifically, when `usergroupresolutionmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UserGroupResolutionMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UserGroupResolutionMode {
    #[allow(missing_docs)] // documentation missing in model
    AwsSso,
    #[allow(missing_docs)] // documentation missing in model
    None,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for UserGroupResolutionMode {
    fn from(s: &str) -> Self {
        match s {
            "AWS_SSO" => UserGroupResolutionMode::AwsSso,
            "NONE" => UserGroupResolutionMode::None,
            other => UserGroupResolutionMode::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for UserGroupResolutionMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UserGroupResolutionMode::from(s))
    }
}
impl UserGroupResolutionMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UserGroupResolutionMode::AwsSso => "AWS_SSO",
            UserGroupResolutionMode::None => "NONE",
            UserGroupResolutionMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AWS_SSO", "NONE"]
    }
}
impl AsRef<str> for UserGroupResolutionMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `UserContextPolicy`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let usercontextpolicy = unimplemented!();
/// match usercontextpolicy {
///     UserContextPolicy::AttributeFilter => { /* ... */ },
///     UserContextPolicy::UserToken => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `usercontextpolicy` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UserContextPolicy::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UserContextPolicy::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UserContextPolicy::NewFeature` is defined.
/// Specifically, when `usercontextpolicy` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UserContextPolicy::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UserContextPolicy {
    #[allow(missing_docs)] // documentation missing in model
    AttributeFilter,
    #[allow(missing_docs)] // documentation missing in model
    UserToken,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for UserContextPolicy {
    fn from(s: &str) -> Self {
        match s {
            "ATTRIBUTE_FILTER" => UserContextPolicy::AttributeFilter,
            "USER_TOKEN" => UserContextPolicy::UserToken,
            other => {
                UserContextPolicy::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for UserContextPolicy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UserContextPolicy::from(s))
    }
}
impl UserContextPolicy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UserContextPolicy::AttributeFilter => "ATTRIBUTE_FILTER",
            UserContextPolicy::UserToken => "USER_TOKEN",
            UserContextPolicy::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ATTRIBUTE_FILTER", "USER_TOKEN"]
    }
}
impl AsRef<str> for UserContextPolicy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides the configuration information for a token.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UserTokenConfiguration {
    /// <p>Information about the JWT token type configuration.</p>
    #[doc(hidden)]
    pub jwt_token_type_configuration: std::option::Option<crate::model::JwtTokenTypeConfiguration>,
    /// <p>Information about the JSON token type configuration.</p>
    #[doc(hidden)]
    pub json_token_type_configuration:
        std::option::Option<crate::model::JsonTokenTypeConfiguration>,
}
impl UserTokenConfiguration {
    /// <p>Information about the JWT token type configuration.</p>
    pub fn jwt_token_type_configuration(
        &self,
    ) -> std::option::Option<&crate::model::JwtTokenTypeConfiguration> {
        self.jwt_token_type_configuration.as_ref()
    }
    /// <p>Information about the JSON token type configuration.</p>
    pub fn json_token_type_configuration(
        &self,
    ) -> std::option::Option<&crate::model::JsonTokenTypeConfiguration> {
        self.json_token_type_configuration.as_ref()
    }
}
/// See [`UserTokenConfiguration`](crate::model::UserTokenConfiguration).
pub mod user_token_configuration {

    /// A builder for [`UserTokenConfiguration`](crate::model::UserTokenConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) jwt_token_type_configuration:
            std::option::Option<crate::model::JwtTokenTypeConfiguration>,
        pub(crate) json_token_type_configuration:
            std::option::Option<crate::model::JsonTokenTypeConfiguration>,
    }
    impl Builder {
        /// <p>Information about the JWT token type configuration.</p>
        pub fn jwt_token_type_configuration(
            mut self,
            input: crate::model::JwtTokenTypeConfiguration,
        ) -> Self {
            self.jwt_token_type_configuration = Some(input);
            self
        }
        /// <p>Information about the JWT token type configuration.</p>
        pub fn set_jwt_token_type_configuration(
            mut self,
            input: std::option::Option<crate::model::JwtTokenTypeConfiguration>,
        ) -> Self {
            self.jwt_token_type_configuration = input;
            self
        }
        /// <p>Information about the JSON token type configuration.</p>
        pub fn json_token_type_configuration(
            mut self,
            input: crate::model::JsonTokenTypeConfiguration,
        ) -> Self {
            self.json_token_type_configuration = Some(input);
            self
        }
        /// <p>Information about the JSON token type configuration.</p>
        pub fn set_json_token_type_configuration(
            mut self,
            input: std::option::Option<crate::model::JsonTokenTypeConfiguration>,
        ) -> Self {
            self.json_token_type_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`UserTokenConfiguration`](crate::model::UserTokenConfiguration).
        pub fn build(self) -> crate::model::UserTokenConfiguration {
            crate::model::UserTokenConfiguration {
                jwt_token_type_configuration: self.jwt_token_type_configuration,
                json_token_type_configuration: self.json_token_type_configuration,
            }
        }
    }
}
impl UserTokenConfiguration {
    /// Creates a new builder-style object to manufacture [`UserTokenConfiguration`](crate::model::UserTokenConfiguration).
    pub fn builder() -> crate::model::user_token_configuration::Builder {
        crate::model::user_token_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information for the JSON token type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JsonTokenTypeConfiguration {
    /// <p>The user name attribute field.</p>
    #[doc(hidden)]
    pub user_name_attribute_field: std::option::Option<std::string::String>,
    /// <p>The group attribute field.</p>
    #[doc(hidden)]
    pub group_attribute_field: std::option::Option<std::string::String>,
}
impl JsonTokenTypeConfiguration {
    /// <p>The user name attribute field.</p>
    pub fn user_name_attribute_field(&self) -> std::option::Option<&str> {
        self.user_name_attribute_field.as_deref()
    }
    /// <p>The group attribute field.</p>
    pub fn group_attribute_field(&self) -> std::option::Option<&str> {
        self.group_attribute_field.as_deref()
    }
}
/// See [`JsonTokenTypeConfiguration`](crate::model::JsonTokenTypeConfiguration).
pub mod json_token_type_configuration {

    /// A builder for [`JsonTokenTypeConfiguration`](crate::model::JsonTokenTypeConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name_attribute_field: std::option::Option<std::string::String>,
        pub(crate) group_attribute_field: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The user name attribute field.</p>
        pub fn user_name_attribute_field(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_name_attribute_field = Some(input.into());
            self
        }
        /// <p>The user name attribute field.</p>
        pub fn set_user_name_attribute_field(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.user_name_attribute_field = input;
            self
        }
        /// <p>The group attribute field.</p>
        pub fn group_attribute_field(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_attribute_field = Some(input.into());
            self
        }
        /// <p>The group attribute field.</p>
        pub fn set_group_attribute_field(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.group_attribute_field = input;
            self
        }
        /// Consumes the builder and constructs a [`JsonTokenTypeConfiguration`](crate::model::JsonTokenTypeConfiguration).
        pub fn build(self) -> crate::model::JsonTokenTypeConfiguration {
            crate::model::JsonTokenTypeConfiguration {
                user_name_attribute_field: self.user_name_attribute_field,
                group_attribute_field: self.group_attribute_field,
            }
        }
    }
}
impl JsonTokenTypeConfiguration {
    /// Creates a new builder-style object to manufacture [`JsonTokenTypeConfiguration`](crate::model::JsonTokenTypeConfiguration).
    pub fn builder() -> crate::model::json_token_type_configuration::Builder {
        crate::model::json_token_type_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information for the JWT token type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JwtTokenTypeConfiguration {
    /// <p>The location of the key.</p>
    #[doc(hidden)]
    pub key_location: std::option::Option<crate::model::KeyLocation>,
    /// <p>The signing key URL.</p>
    #[doc(hidden)]
    pub url: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (arn) of the secret.</p>
    #[doc(hidden)]
    pub secret_manager_arn: std::option::Option<std::string::String>,
    /// <p>The user name attribute field.</p>
    #[doc(hidden)]
    pub user_name_attribute_field: std::option::Option<std::string::String>,
    /// <p>The group attribute field.</p>
    #[doc(hidden)]
    pub group_attribute_field: std::option::Option<std::string::String>,
    /// <p>The issuer of the token.</p>
    #[doc(hidden)]
    pub issuer: std::option::Option<std::string::String>,
    /// <p>The regular expression that identifies the claim.</p>
    #[doc(hidden)]
    pub claim_regex: std::option::Option<std::string::String>,
}
impl JwtTokenTypeConfiguration {
    /// <p>The location of the key.</p>
    pub fn key_location(&self) -> std::option::Option<&crate::model::KeyLocation> {
        self.key_location.as_ref()
    }
    /// <p>The signing key URL.</p>
    pub fn url(&self) -> std::option::Option<&str> {
        self.url.as_deref()
    }
    /// <p>The Amazon Resource Name (arn) of the secret.</p>
    pub fn secret_manager_arn(&self) -> std::option::Option<&str> {
        self.secret_manager_arn.as_deref()
    }
    /// <p>The user name attribute field.</p>
    pub fn user_name_attribute_field(&self) -> std::option::Option<&str> {
        self.user_name_attribute_field.as_deref()
    }
    /// <p>The group attribute field.</p>
    pub fn group_attribute_field(&self) -> std::option::Option<&str> {
        self.group_attribute_field.as_deref()
    }
    /// <p>The issuer of the token.</p>
    pub fn issuer(&self) -> std::option::Option<&str> {
        self.issuer.as_deref()
    }
    /// <p>The regular expression that identifies the claim.</p>
    pub fn claim_regex(&self) -> std::option::Option<&str> {
        self.claim_regex.as_deref()
    }
}
/// See [`JwtTokenTypeConfiguration`](crate::model::JwtTokenTypeConfiguration).
pub mod jwt_token_type_configuration {

    /// A builder for [`JwtTokenTypeConfiguration`](crate::model::JwtTokenTypeConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key_location: std::option::Option<crate::model::KeyLocation>,
        pub(crate) url: std::option::Option<std::string::String>,
        pub(crate) secret_manager_arn: std::option::Option<std::string::String>,
        pub(crate) user_name_attribute_field: std::option::Option<std::string::String>,
        pub(crate) group_attribute_field: std::option::Option<std::string::String>,
        pub(crate) issuer: std::option::Option<std::string::String>,
        pub(crate) claim_regex: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The location of the key.</p>
        pub fn key_location(mut self, input: crate::model::KeyLocation) -> Self {
            self.key_location = Some(input);
            self
        }
        /// <p>The location of the key.</p>
        pub fn set_key_location(
            mut self,
            input: std::option::Option<crate::model::KeyLocation>,
        ) -> Self {
            self.key_location = input;
            self
        }
        /// <p>The signing key URL.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        /// <p>The signing key URL.</p>
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// <p>The Amazon Resource Name (arn) of the secret.</p>
        pub fn secret_manager_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_manager_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (arn) of the secret.</p>
        pub fn set_secret_manager_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.secret_manager_arn = input;
            self
        }
        /// <p>The user name attribute field.</p>
        pub fn user_name_attribute_field(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_name_attribute_field = Some(input.into());
            self
        }
        /// <p>The user name attribute field.</p>
        pub fn set_user_name_attribute_field(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.user_name_attribute_field = input;
            self
        }
        /// <p>The group attribute field.</p>
        pub fn group_attribute_field(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_attribute_field = Some(input.into());
            self
        }
        /// <p>The group attribute field.</p>
        pub fn set_group_attribute_field(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.group_attribute_field = input;
            self
        }
        /// <p>The issuer of the token.</p>
        pub fn issuer(mut self, input: impl Into<std::string::String>) -> Self {
            self.issuer = Some(input.into());
            self
        }
        /// <p>The issuer of the token.</p>
        pub fn set_issuer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.issuer = input;
            self
        }
        /// <p>The regular expression that identifies the claim.</p>
        pub fn claim_regex(mut self, input: impl Into<std::string::String>) -> Self {
            self.claim_regex = Some(input.into());
            self
        }
        /// <p>The regular expression that identifies the claim.</p>
        pub fn set_claim_regex(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.claim_regex = input;
            self
        }
        /// Consumes the builder and constructs a [`JwtTokenTypeConfiguration`](crate::model::JwtTokenTypeConfiguration).
        pub fn build(self) -> crate::model::JwtTokenTypeConfiguration {
            crate::model::JwtTokenTypeConfiguration {
                key_location: self.key_location,
                url: self.url,
                secret_manager_arn: self.secret_manager_arn,
                user_name_attribute_field: self.user_name_attribute_field,
                group_attribute_field: self.group_attribute_field,
                issuer: self.issuer,
                claim_regex: self.claim_regex,
            }
        }
    }
}
impl JwtTokenTypeConfiguration {
    /// Creates a new builder-style object to manufacture [`JwtTokenTypeConfiguration`](crate::model::JwtTokenTypeConfiguration).
    pub fn builder() -> crate::model::jwt_token_type_configuration::Builder {
        crate::model::jwt_token_type_configuration::Builder::default()
    }
}

/// When writing a match expression against `KeyLocation`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let keylocation = unimplemented!();
/// match keylocation {
///     KeyLocation::SecretManager => { /* ... */ },
///     KeyLocation::Url => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `keylocation` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `KeyLocation::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `KeyLocation::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `KeyLocation::NewFeature` is defined.
/// Specifically, when `keylocation` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `KeyLocation::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum KeyLocation {
    #[allow(missing_docs)] // documentation missing in model
    SecretManager,
    #[allow(missing_docs)] // documentation missing in model
    Url,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for KeyLocation {
    fn from(s: &str) -> Self {
        match s {
            "SECRET_MANAGER" => KeyLocation::SecretManager,
            "URL" => KeyLocation::Url,
            other => KeyLocation::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for KeyLocation {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(KeyLocation::from(s))
    }
}
impl KeyLocation {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            KeyLocation::SecretManager => "SECRET_MANAGER",
            KeyLocation::Url => "URL",
            KeyLocation::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SECRET_MANAGER", "URL"]
    }
}
impl AsRef<str> for KeyLocation {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies additional capacity units configured for your Enterprise Edition index. You can add and remove capacity units to fit your usage requirements.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CapacityUnitsConfiguration {
    /// <p>The amount of extra storage capacity for an index. A single capacity unit provides 30 GB of storage space or 100,000 documents, whichever is reached first. You can add up to 100 extra capacity units.</p>
    #[doc(hidden)]
    pub storage_capacity_units: std::option::Option<i32>,
    /// <p>The amount of extra query capacity for an index and <a href="https://docs.aws.amazon.com/kendra/latest/dg/API_GetQuerySuggestions.html">GetQuerySuggestions</a> capacity.</p>
    /// <p>A single extra capacity unit for an index provides 0.1 queries per second or approximately 8,000 queries per day. You can add up to 100 extra capacity units.</p>
    /// <p> <code>GetQuerySuggestions</code> capacity is five times the provisioned query capacity for an index, or the base capacity of 2.5 calls per second, whichever is higher. For example, the base capacity for an index is 0.1 queries per second, and <code>GetQuerySuggestions</code> capacity has a base of 2.5 calls per second. If you add another 0.1 queries per second to total 0.2 queries per second for an index, the <code>GetQuerySuggestions</code> capacity is 2.5 calls per second (higher than five times 0.2 queries per second).</p>
    #[doc(hidden)]
    pub query_capacity_units: std::option::Option<i32>,
}
impl CapacityUnitsConfiguration {
    /// <p>The amount of extra storage capacity for an index. A single capacity unit provides 30 GB of storage space or 100,000 documents, whichever is reached first. You can add up to 100 extra capacity units.</p>
    pub fn storage_capacity_units(&self) -> std::option::Option<i32> {
        self.storage_capacity_units
    }
    /// <p>The amount of extra query capacity for an index and <a href="https://docs.aws.amazon.com/kendra/latest/dg/API_GetQuerySuggestions.html">GetQuerySuggestions</a> capacity.</p>
    /// <p>A single extra capacity unit for an index provides 0.1 queries per second or approximately 8,000 queries per day. You can add up to 100 extra capacity units.</p>
    /// <p> <code>GetQuerySuggestions</code> capacity is five times the provisioned query capacity for an index, or the base capacity of 2.5 calls per second, whichever is higher. For example, the base capacity for an index is 0.1 queries per second, and <code>GetQuerySuggestions</code> capacity has a base of 2.5 calls per second. If you add another 0.1 queries per second to total 0.2 queries per second for an index, the <code>GetQuerySuggestions</code> capacity is 2.5 calls per second (higher than five times 0.2 queries per second).</p>
    pub fn query_capacity_units(&self) -> std::option::Option<i32> {
        self.query_capacity_units
    }
}
/// See [`CapacityUnitsConfiguration`](crate::model::CapacityUnitsConfiguration).
pub mod capacity_units_configuration {

    /// A builder for [`CapacityUnitsConfiguration`](crate::model::CapacityUnitsConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) storage_capacity_units: std::option::Option<i32>,
        pub(crate) query_capacity_units: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The amount of extra storage capacity for an index. A single capacity unit provides 30 GB of storage space or 100,000 documents, whichever is reached first. You can add up to 100 extra capacity units.</p>
        pub fn storage_capacity_units(mut self, input: i32) -> Self {
            self.storage_capacity_units = Some(input);
            self
        }
        /// <p>The amount of extra storage capacity for an index. A single capacity unit provides 30 GB of storage space or 100,000 documents, whichever is reached first. You can add up to 100 extra capacity units.</p>
        pub fn set_storage_capacity_units(mut self, input: std::option::Option<i32>) -> Self {
            self.storage_capacity_units = input;
            self
        }
        /// <p>The amount of extra query capacity for an index and <a href="https://docs.aws.amazon.com/kendra/latest/dg/API_GetQuerySuggestions.html">GetQuerySuggestions</a> capacity.</p>
        /// <p>A single extra capacity unit for an index provides 0.1 queries per second or approximately 8,000 queries per day. You can add up to 100 extra capacity units.</p>
        /// <p> <code>GetQuerySuggestions</code> capacity is five times the provisioned query capacity for an index, or the base capacity of 2.5 calls per second, whichever is higher. For example, the base capacity for an index is 0.1 queries per second, and <code>GetQuerySuggestions</code> capacity has a base of 2.5 calls per second. If you add another 0.1 queries per second to total 0.2 queries per second for an index, the <code>GetQuerySuggestions</code> capacity is 2.5 calls per second (higher than five times 0.2 queries per second).</p>
        pub fn query_capacity_units(mut self, input: i32) -> Self {
            self.query_capacity_units = Some(input);
            self
        }
        /// <p>The amount of extra query capacity for an index and <a href="https://docs.aws.amazon.com/kendra/latest/dg/API_GetQuerySuggestions.html">GetQuerySuggestions</a> capacity.</p>
        /// <p>A single extra capacity unit for an index provides 0.1 queries per second or approximately 8,000 queries per day. You can add up to 100 extra capacity units.</p>
        /// <p> <code>GetQuerySuggestions</code> capacity is five times the provisioned query capacity for an index, or the base capacity of 2.5 calls per second, whichever is higher. For example, the base capacity for an index is 0.1 queries per second, and <code>GetQuerySuggestions</code> capacity has a base of 2.5 calls per second. If you add another 0.1 queries per second to total 0.2 queries per second for an index, the <code>GetQuerySuggestions</code> capacity is 2.5 calls per second (higher than five times 0.2 queries per second).</p>
        pub fn set_query_capacity_units(mut self, input: std::option::Option<i32>) -> Self {
            self.query_capacity_units = input;
            self
        }
        /// Consumes the builder and constructs a [`CapacityUnitsConfiguration`](crate::model::CapacityUnitsConfiguration).
        pub fn build(self) -> crate::model::CapacityUnitsConfiguration {
            crate::model::CapacityUnitsConfiguration {
                storage_capacity_units: self.storage_capacity_units,
                query_capacity_units: self.query_capacity_units,
            }
        }
    }
}
impl CapacityUnitsConfiguration {
    /// Creates a new builder-style object to manufacture [`CapacityUnitsConfiguration`](crate::model::CapacityUnitsConfiguration).
    pub fn builder() -> crate::model::capacity_units_configuration::Builder {
        crate::model::capacity_units_configuration::Builder::default()
    }
}

/// <p>Specifies the properties, such as relevance tuning and searchability, of an index field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DocumentMetadataConfiguration {
    /// <p>The name of the index field.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data type of the index field. </p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::DocumentAttributeValueType>,
    /// <p>Provides tuning parameters to determine how the field affects the search results.</p>
    #[doc(hidden)]
    pub relevance: std::option::Option<crate::model::Relevance>,
    /// <p>Provides information about how the field is used during a search.</p>
    #[doc(hidden)]
    pub search: std::option::Option<crate::model::Search>,
}
impl DocumentMetadataConfiguration {
    /// <p>The name of the index field.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data type of the index field. </p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::DocumentAttributeValueType> {
        self.r#type.as_ref()
    }
    /// <p>Provides tuning parameters to determine how the field affects the search results.</p>
    pub fn relevance(&self) -> std::option::Option<&crate::model::Relevance> {
        self.relevance.as_ref()
    }
    /// <p>Provides information about how the field is used during a search.</p>
    pub fn search(&self) -> std::option::Option<&crate::model::Search> {
        self.search.as_ref()
    }
}
/// See [`DocumentMetadataConfiguration`](crate::model::DocumentMetadataConfiguration).
pub mod document_metadata_configuration {

    /// A builder for [`DocumentMetadataConfiguration`](crate::model::DocumentMetadataConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::DocumentAttributeValueType>,
        pub(crate) relevance: std::option::Option<crate::model::Relevance>,
        pub(crate) search: std::option::Option<crate::model::Search>,
    }
    impl Builder {
        /// <p>The name of the index field.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the index field.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The data type of the index field. </p>
        pub fn r#type(mut self, input: crate::model::DocumentAttributeValueType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The data type of the index field. </p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::DocumentAttributeValueType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Provides tuning parameters to determine how the field affects the search results.</p>
        pub fn relevance(mut self, input: crate::model::Relevance) -> Self {
            self.relevance = Some(input);
            self
        }
        /// <p>Provides tuning parameters to determine how the field affects the search results.</p>
        pub fn set_relevance(
            mut self,
            input: std::option::Option<crate::model::Relevance>,
        ) -> Self {
            self.relevance = input;
            self
        }
        /// <p>Provides information about how the field is used during a search.</p>
        pub fn search(mut self, input: crate::model::Search) -> Self {
            self.search = Some(input);
            self
        }
        /// <p>Provides information about how the field is used during a search.</p>
        pub fn set_search(mut self, input: std::option::Option<crate::model::Search>) -> Self {
            self.search = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentMetadataConfiguration`](crate::model::DocumentMetadataConfiguration).
        pub fn build(self) -> crate::model::DocumentMetadataConfiguration {
            crate::model::DocumentMetadataConfiguration {
                name: self.name,
                r#type: self.r#type,
                relevance: self.relevance,
                search: self.search,
            }
        }
    }
}
impl DocumentMetadataConfiguration {
    /// Creates a new builder-style object to manufacture [`DocumentMetadataConfiguration`](crate::model::DocumentMetadataConfiguration).
    pub fn builder() -> crate::model::document_metadata_configuration::Builder {
        crate::model::document_metadata_configuration::Builder::default()
    }
}

/// <p>Provides information about how a custom index field is used during a search.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Search {
    /// <p>Indicates that the field can be used to create search facets, a count of results for each value in the field. The default is <code>false</code> .</p>
    #[doc(hidden)]
    pub facetable: bool,
    /// <p>Determines whether the field is used in the search. If the <code>Searchable</code> field is <code>true</code>, you can use relevance tuning to manually tune how Amazon Kendra weights the field in the search. The default is <code>true</code> for string fields and <code>false</code> for number and date fields.</p>
    #[doc(hidden)]
    pub searchable: bool,
    /// <p>Determines whether the field is returned in the query response. The default is <code>true</code>.</p>
    #[doc(hidden)]
    pub displayable: bool,
    /// <p>Determines whether the field can be used to sort the results of a query. If you specify sorting on a field that does not have <code>Sortable</code> set to <code>true</code>, Amazon Kendra returns an exception. The default is <code>false</code>.</p>
    #[doc(hidden)]
    pub sortable: bool,
}
impl Search {
    /// <p>Indicates that the field can be used to create search facets, a count of results for each value in the field. The default is <code>false</code> .</p>
    pub fn facetable(&self) -> bool {
        self.facetable
    }
    /// <p>Determines whether the field is used in the search. If the <code>Searchable</code> field is <code>true</code>, you can use relevance tuning to manually tune how Amazon Kendra weights the field in the search. The default is <code>true</code> for string fields and <code>false</code> for number and date fields.</p>
    pub fn searchable(&self) -> bool {
        self.searchable
    }
    /// <p>Determines whether the field is returned in the query response. The default is <code>true</code>.</p>
    pub fn displayable(&self) -> bool {
        self.displayable
    }
    /// <p>Determines whether the field can be used to sort the results of a query. If you specify sorting on a field that does not have <code>Sortable</code> set to <code>true</code>, Amazon Kendra returns an exception. The default is <code>false</code>.</p>
    pub fn sortable(&self) -> bool {
        self.sortable
    }
}
/// See [`Search`](crate::model::Search).
pub mod search {

    /// A builder for [`Search`](crate::model::Search).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) facetable: std::option::Option<bool>,
        pub(crate) searchable: std::option::Option<bool>,
        pub(crate) displayable: std::option::Option<bool>,
        pub(crate) sortable: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Indicates that the field can be used to create search facets, a count of results for each value in the field. The default is <code>false</code> .</p>
        pub fn facetable(mut self, input: bool) -> Self {
            self.facetable = Some(input);
            self
        }
        /// <p>Indicates that the field can be used to create search facets, a count of results for each value in the field. The default is <code>false</code> .</p>
        pub fn set_facetable(mut self, input: std::option::Option<bool>) -> Self {
            self.facetable = input;
            self
        }
        /// <p>Determines whether the field is used in the search. If the <code>Searchable</code> field is <code>true</code>, you can use relevance tuning to manually tune how Amazon Kendra weights the field in the search. The default is <code>true</code> for string fields and <code>false</code> for number and date fields.</p>
        pub fn searchable(mut self, input: bool) -> Self {
            self.searchable = Some(input);
            self
        }
        /// <p>Determines whether the field is used in the search. If the <code>Searchable</code> field is <code>true</code>, you can use relevance tuning to manually tune how Amazon Kendra weights the field in the search. The default is <code>true</code> for string fields and <code>false</code> for number and date fields.</p>
        pub fn set_searchable(mut self, input: std::option::Option<bool>) -> Self {
            self.searchable = input;
            self
        }
        /// <p>Determines whether the field is returned in the query response. The default is <code>true</code>.</p>
        pub fn displayable(mut self, input: bool) -> Self {
            self.displayable = Some(input);
            self
        }
        /// <p>Determines whether the field is returned in the query response. The default is <code>true</code>.</p>
        pub fn set_displayable(mut self, input: std::option::Option<bool>) -> Self {
            self.displayable = input;
            self
        }
        /// <p>Determines whether the field can be used to sort the results of a query. If you specify sorting on a field that does not have <code>Sortable</code> set to <code>true</code>, Amazon Kendra returns an exception. The default is <code>false</code>.</p>
        pub fn sortable(mut self, input: bool) -> Self {
            self.sortable = Some(input);
            self
        }
        /// <p>Determines whether the field can be used to sort the results of a query. If you specify sorting on a field that does not have <code>Sortable</code> set to <code>true</code>, Amazon Kendra returns an exception. The default is <code>false</code>.</p>
        pub fn set_sortable(mut self, input: std::option::Option<bool>) -> Self {
            self.sortable = input;
            self
        }
        /// Consumes the builder and constructs a [`Search`](crate::model::Search).
        pub fn build(self) -> crate::model::Search {
            crate::model::Search {
                facetable: self.facetable.unwrap_or_default(),
                searchable: self.searchable.unwrap_or_default(),
                displayable: self.displayable.unwrap_or_default(),
                sortable: self.sortable.unwrap_or_default(),
            }
        }
    }
}
impl Search {
    /// Creates a new builder-style object to manufacture [`Search`](crate::model::Search).
    pub fn builder() -> crate::model::search::Builder {
        crate::model::search::Builder::default()
    }
}

/// <p>Provides information for tuning the relevance of a field in a search. When a query includes terms that match the field, the results are given a boost in the response based on these tuning parameters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Relevance {
    /// <p>Indicates that this field determines how "fresh" a document is. For example, if document 1 was created on November 5, and document 2 was created on October 31, document 1 is "fresher" than document 2. You can only set the <code>Freshness</code> field on one <code>DATE</code> type field. Only applies to <code>DATE</code> fields.</p>
    #[doc(hidden)]
    pub freshness: std::option::Option<bool>,
    /// <p>The relative importance of the field in the search. Larger numbers provide more of a boost than smaller numbers.</p>
    #[doc(hidden)]
    pub importance: std::option::Option<i32>,
    /// <p>Specifies the time period that the boost applies to. For example, to make the boost apply to documents with the field value within the last month, you would use "2628000s". Once the field value is beyond the specified range, the effect of the boost drops off. The higher the importance, the faster the effect drops off. If you don't specify a value, the default is 3 months. The value of the field is a numeric string followed by the character "s", for example "86400s" for one day, or "604800s" for one week. </p>
    /// <p>Only applies to <code>DATE</code> fields.</p>
    #[doc(hidden)]
    pub duration: std::option::Option<std::string::String>,
    /// <p>Determines how values should be interpreted.</p>
    /// <p>When the <code>RankOrder</code> field is <code>ASCENDING</code>, higher numbers are better. For example, a document with a rating score of 10 is higher ranking than a document with a rating score of 1.</p>
    /// <p>When the <code>RankOrder</code> field is <code>DESCENDING</code>, lower numbers are better. For example, in a task tracking application, a priority 1 task is more important than a priority 5 task.</p>
    /// <p>Only applies to <code>LONG</code> and <code>DOUBLE</code> fields.</p>
    #[doc(hidden)]
    pub rank_order: std::option::Option<crate::model::Order>,
    /// <p>A list of values that should be given a different boost when they appear in the result list. For example, if you are boosting a field called "department," query terms that match the department field are boosted in the result. However, you can add entries from the department field to boost documents with those values higher. </p>
    /// <p>For example, you can add entries to the map with names of departments. If you add "HR",5 and "Legal",3 those departments are given special attention when they appear in the metadata of a document. When those terms appear they are given the specified importance instead of the regular importance for the boost.</p>
    #[doc(hidden)]
    pub value_importance_map:
        std::option::Option<std::collections::HashMap<std::string::String, i32>>,
}
impl Relevance {
    /// <p>Indicates that this field determines how "fresh" a document is. For example, if document 1 was created on November 5, and document 2 was created on October 31, document 1 is "fresher" than document 2. You can only set the <code>Freshness</code> field on one <code>DATE</code> type field. Only applies to <code>DATE</code> fields.</p>
    pub fn freshness(&self) -> std::option::Option<bool> {
        self.freshness
    }
    /// <p>The relative importance of the field in the search. Larger numbers provide more of a boost than smaller numbers.</p>
    pub fn importance(&self) -> std::option::Option<i32> {
        self.importance
    }
    /// <p>Specifies the time period that the boost applies to. For example, to make the boost apply to documents with the field value within the last month, you would use "2628000s". Once the field value is beyond the specified range, the effect of the boost drops off. The higher the importance, the faster the effect drops off. If you don't specify a value, the default is 3 months. The value of the field is a numeric string followed by the character "s", for example "86400s" for one day, or "604800s" for one week. </p>
    /// <p>Only applies to <code>DATE</code> fields.</p>
    pub fn duration(&self) -> std::option::Option<&str> {
        self.duration.as_deref()
    }
    /// <p>Determines how values should be interpreted.</p>
    /// <p>When the <code>RankOrder</code> field is <code>ASCENDING</code>, higher numbers are better. For example, a document with a rating score of 10 is higher ranking than a document with a rating score of 1.</p>
    /// <p>When the <code>RankOrder</code> field is <code>DESCENDING</code>, lower numbers are better. For example, in a task tracking application, a priority 1 task is more important than a priority 5 task.</p>
    /// <p>Only applies to <code>LONG</code> and <code>DOUBLE</code> fields.</p>
    pub fn rank_order(&self) -> std::option::Option<&crate::model::Order> {
        self.rank_order.as_ref()
    }
    /// <p>A list of values that should be given a different boost when they appear in the result list. For example, if you are boosting a field called "department," query terms that match the department field are boosted in the result. However, you can add entries from the department field to boost documents with those values higher. </p>
    /// <p>For example, you can add entries to the map with names of departments. If you add "HR",5 and "Legal",3 those departments are given special attention when they appear in the metadata of a document. When those terms appear they are given the specified importance instead of the regular importance for the boost.</p>
    pub fn value_importance_map(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, i32>> {
        self.value_importance_map.as_ref()
    }
}
/// See [`Relevance`](crate::model::Relevance).
pub mod relevance {

    /// A builder for [`Relevance`](crate::model::Relevance).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) freshness: std::option::Option<bool>,
        pub(crate) importance: std::option::Option<i32>,
        pub(crate) duration: std::option::Option<std::string::String>,
        pub(crate) rank_order: std::option::Option<crate::model::Order>,
        pub(crate) value_importance_map:
            std::option::Option<std::collections::HashMap<std::string::String, i32>>,
    }
    impl Builder {
        /// <p>Indicates that this field determines how "fresh" a document is. For example, if document 1 was created on November 5, and document 2 was created on October 31, document 1 is "fresher" than document 2. You can only set the <code>Freshness</code> field on one <code>DATE</code> type field. Only applies to <code>DATE</code> fields.</p>
        pub fn freshness(mut self, input: bool) -> Self {
            self.freshness = Some(input);
            self
        }
        /// <p>Indicates that this field determines how "fresh" a document is. For example, if document 1 was created on November 5, and document 2 was created on October 31, document 1 is "fresher" than document 2. You can only set the <code>Freshness</code> field on one <code>DATE</code> type field. Only applies to <code>DATE</code> fields.</p>
        pub fn set_freshness(mut self, input: std::option::Option<bool>) -> Self {
            self.freshness = input;
            self
        }
        /// <p>The relative importance of the field in the search. Larger numbers provide more of a boost than smaller numbers.</p>
        pub fn importance(mut self, input: i32) -> Self {
            self.importance = Some(input);
            self
        }
        /// <p>The relative importance of the field in the search. Larger numbers provide more of a boost than smaller numbers.</p>
        pub fn set_importance(mut self, input: std::option::Option<i32>) -> Self {
            self.importance = input;
            self
        }
        /// <p>Specifies the time period that the boost applies to. For example, to make the boost apply to documents with the field value within the last month, you would use "2628000s". Once the field value is beyond the specified range, the effect of the boost drops off. The higher the importance, the faster the effect drops off. If you don't specify a value, the default is 3 months. The value of the field is a numeric string followed by the character "s", for example "86400s" for one day, or "604800s" for one week. </p>
        /// <p>Only applies to <code>DATE</code> fields.</p>
        pub fn duration(mut self, input: impl Into<std::string::String>) -> Self {
            self.duration = Some(input.into());
            self
        }
        /// <p>Specifies the time period that the boost applies to. For example, to make the boost apply to documents with the field value within the last month, you would use "2628000s". Once the field value is beyond the specified range, the effect of the boost drops off. The higher the importance, the faster the effect drops off. If you don't specify a value, the default is 3 months. The value of the field is a numeric string followed by the character "s", for example "86400s" for one day, or "604800s" for one week. </p>
        /// <p>Only applies to <code>DATE</code> fields.</p>
        pub fn set_duration(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.duration = input;
            self
        }
        /// <p>Determines how values should be interpreted.</p>
        /// <p>When the <code>RankOrder</code> field is <code>ASCENDING</code>, higher numbers are better. For example, a document with a rating score of 10 is higher ranking than a document with a rating score of 1.</p>
        /// <p>When the <code>RankOrder</code> field is <code>DESCENDING</code>, lower numbers are better. For example, in a task tracking application, a priority 1 task is more important than a priority 5 task.</p>
        /// <p>Only applies to <code>LONG</code> and <code>DOUBLE</code> fields.</p>
        pub fn rank_order(mut self, input: crate::model::Order) -> Self {
            self.rank_order = Some(input);
            self
        }
        /// <p>Determines how values should be interpreted.</p>
        /// <p>When the <code>RankOrder</code> field is <code>ASCENDING</code>, higher numbers are better. For example, a document with a rating score of 10 is higher ranking than a document with a rating score of 1.</p>
        /// <p>When the <code>RankOrder</code> field is <code>DESCENDING</code>, lower numbers are better. For example, in a task tracking application, a priority 1 task is more important than a priority 5 task.</p>
        /// <p>Only applies to <code>LONG</code> and <code>DOUBLE</code> fields.</p>
        pub fn set_rank_order(mut self, input: std::option::Option<crate::model::Order>) -> Self {
            self.rank_order = input;
            self
        }
        /// Adds a key-value pair to `value_importance_map`.
        ///
        /// To override the contents of this collection use [`set_value_importance_map`](Self::set_value_importance_map).
        ///
        /// <p>A list of values that should be given a different boost when they appear in the result list. For example, if you are boosting a field called "department," query terms that match the department field are boosted in the result. However, you can add entries from the department field to boost documents with those values higher. </p>
        /// <p>For example, you can add entries to the map with names of departments. If you add "HR",5 and "Legal",3 those departments are given special attention when they appear in the metadata of a document. When those terms appear they are given the specified importance instead of the regular importance for the boost.</p>
        pub fn value_importance_map(mut self, k: impl Into<std::string::String>, v: i32) -> Self {
            let mut hash_map = self.value_importance_map.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.value_importance_map = Some(hash_map);
            self
        }
        /// <p>A list of values that should be given a different boost when they appear in the result list. For example, if you are boosting a field called "department," query terms that match the department field are boosted in the result. However, you can add entries from the department field to boost documents with those values higher. </p>
        /// <p>For example, you can add entries to the map with names of departments. If you add "HR",5 and "Legal",3 those departments are given special attention when they appear in the metadata of a document. When those terms appear they are given the specified importance instead of the regular importance for the boost.</p>
        pub fn set_value_importance_map(
            mut self,
            input: std::option::Option<std::collections::HashMap<std::string::String, i32>>,
        ) -> Self {
            self.value_importance_map = input;
            self
        }
        /// Consumes the builder and constructs a [`Relevance`](crate::model::Relevance).
        pub fn build(self) -> crate::model::Relevance {
            crate::model::Relevance {
                freshness: self.freshness,
                importance: self.importance,
                duration: self.duration,
                rank_order: self.rank_order,
                value_importance_map: self.value_importance_map,
            }
        }
    }
}
impl Relevance {
    /// Creates a new builder-style object to manufacture [`Relevance`](crate::model::Relevance).
    pub fn builder() -> crate::model::relevance::Builder {
        crate::model::relevance::Builder::default()
    }
}

/// When writing a match expression against `Order`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let order = unimplemented!();
/// match order {
///     Order::Ascending => { /* ... */ },
///     Order::Descending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `order` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Order::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Order::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Order::NewFeature` is defined.
/// Specifically, when `order` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Order::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Order {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Order {
    fn from(s: &str) -> Self {
        match s {
            "ASCENDING" => Order::Ascending,
            "DESCENDING" => Order::Descending,
            other => Order::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Order {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Order::from(s))
    }
}
impl Order {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Order::Ascending => "ASCENDING",
            Order::Descending => "DESCENDING",
            Order::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ASCENDING", "DESCENDING"]
    }
}
impl AsRef<str> for Order {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DocumentAttributeValueType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let documentattributevaluetype = unimplemented!();
/// match documentattributevaluetype {
///     DocumentAttributeValueType::DateValue => { /* ... */ },
///     DocumentAttributeValueType::LongValue => { /* ... */ },
///     DocumentAttributeValueType::StringListValue => { /* ... */ },
///     DocumentAttributeValueType::StringValue => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `documentattributevaluetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DocumentAttributeValueType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DocumentAttributeValueType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DocumentAttributeValueType::NewFeature` is defined.
/// Specifically, when `documentattributevaluetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DocumentAttributeValueType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DocumentAttributeValueType {
    #[allow(missing_docs)] // documentation missing in model
    DateValue,
    #[allow(missing_docs)] // documentation missing in model
    LongValue,
    #[allow(missing_docs)] // documentation missing in model
    StringListValue,
    #[allow(missing_docs)] // documentation missing in model
    StringValue,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DocumentAttributeValueType {
    fn from(s: &str) -> Self {
        match s {
            "DATE_VALUE" => DocumentAttributeValueType::DateValue,
            "LONG_VALUE" => DocumentAttributeValueType::LongValue,
            "STRING_LIST_VALUE" => DocumentAttributeValueType::StringListValue,
            "STRING_VALUE" => DocumentAttributeValueType::StringValue,
            other => DocumentAttributeValueType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for DocumentAttributeValueType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DocumentAttributeValueType::from(s))
    }
}
impl DocumentAttributeValueType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DocumentAttributeValueType::DateValue => "DATE_VALUE",
            DocumentAttributeValueType::LongValue => "LONG_VALUE",
            DocumentAttributeValueType::StringListValue => "STRING_LIST_VALUE",
            DocumentAttributeValueType::StringValue => "STRING_VALUE",
            DocumentAttributeValueType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DATE_VALUE",
            "LONG_VALUE",
            "STRING_LIST_VALUE",
            "STRING_VALUE",
        ]
    }
}
impl AsRef<str> for DocumentAttributeValueType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides the configuration information for your Amazon Kendra experience. This includes the data source IDs and/or FAQ IDs, and user or group information to grant access to your Amazon Kendra experience.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExperienceConfiguration {
    /// <p>The identifiers of your data sources and FAQs. Or, you can specify that you want to use documents indexed via the <code>BatchPutDocument</code> API. This is the content you want to use for your Amazon Kendra experience.</p>
    #[doc(hidden)]
    pub content_source_configuration: std::option::Option<crate::model::ContentSourceConfiguration>,
    /// <p>The IAM Identity Center field name that contains the identifiers of your users, such as their emails.</p>
    #[doc(hidden)]
    pub user_identity_configuration: std::option::Option<crate::model::UserIdentityConfiguration>,
}
impl ExperienceConfiguration {
    /// <p>The identifiers of your data sources and FAQs. Or, you can specify that you want to use documents indexed via the <code>BatchPutDocument</code> API. This is the content you want to use for your Amazon Kendra experience.</p>
    pub fn content_source_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ContentSourceConfiguration> {
        self.content_source_configuration.as_ref()
    }
    /// <p>The IAM Identity Center field name that contains the identifiers of your users, such as their emails.</p>
    pub fn user_identity_configuration(
        &self,
    ) -> std::option::Option<&crate::model::UserIdentityConfiguration> {
        self.user_identity_configuration.as_ref()
    }
}
/// See [`ExperienceConfiguration`](crate::model::ExperienceConfiguration).
pub mod experience_configuration {

    /// A builder for [`ExperienceConfiguration`](crate::model::ExperienceConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) content_source_configuration:
            std::option::Option<crate::model::ContentSourceConfiguration>,
        pub(crate) user_identity_configuration:
            std::option::Option<crate::model::UserIdentityConfiguration>,
    }
    impl Builder {
        /// <p>The identifiers of your data sources and FAQs. Or, you can specify that you want to use documents indexed via the <code>BatchPutDocument</code> API. This is the content you want to use for your Amazon Kendra experience.</p>
        pub fn content_source_configuration(
            mut self,
            input: crate::model::ContentSourceConfiguration,
        ) -> Self {
            self.content_source_configuration = Some(input);
            self
        }
        /// <p>The identifiers of your data sources and FAQs. Or, you can specify that you want to use documents indexed via the <code>BatchPutDocument</code> API. This is the content you want to use for your Amazon Kendra experience.</p>
        pub fn set_content_source_configuration(
            mut self,
            input: std::option::Option<crate::model::ContentSourceConfiguration>,
        ) -> Self {
            self.content_source_configuration = input;
            self
        }
        /// <p>The IAM Identity Center field name that contains the identifiers of your users, such as their emails.</p>
        pub fn user_identity_configuration(
            mut self,
            input: crate::model::UserIdentityConfiguration,
        ) -> Self {
            self.user_identity_configuration = Some(input);
            self
        }
        /// <p>The IAM Identity Center field name that contains the identifiers of your users, such as their emails.</p>
        pub fn set_user_identity_configuration(
            mut self,
            input: std::option::Option<crate::model::UserIdentityConfiguration>,
        ) -> Self {
            self.user_identity_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`ExperienceConfiguration`](crate::model::ExperienceConfiguration).
        pub fn build(self) -> crate::model::ExperienceConfiguration {
            crate::model::ExperienceConfiguration {
                content_source_configuration: self.content_source_configuration,
                user_identity_configuration: self.user_identity_configuration,
            }
        }
    }
}
impl ExperienceConfiguration {
    /// Creates a new builder-style object to manufacture [`ExperienceConfiguration`](crate::model::ExperienceConfiguration).
    pub fn builder() -> crate::model::experience_configuration::Builder {
        crate::model::experience_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information for the identifiers of your users.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UserIdentityConfiguration {
    /// <p>The IAM Identity Center field name that contains the identifiers of your users, such as their emails. This is used for <a href="https://docs.aws.amazon.com/kendra/latest/dg/user-context-filter.html">user context filtering</a> and for granting access to your Amazon Kendra experience. You must set up IAM Identity Center with Amazon Kendra. You must include your users and groups in your Access Control List when you ingest documents into your index. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/getting-started-aws-sso.html">Getting started with an IAM Identity Center identity source</a>.</p>
    #[doc(hidden)]
    pub identity_attribute_name: std::option::Option<std::string::String>,
}
impl UserIdentityConfiguration {
    /// <p>The IAM Identity Center field name that contains the identifiers of your users, such as their emails. This is used for <a href="https://docs.aws.amazon.com/kendra/latest/dg/user-context-filter.html">user context filtering</a> and for granting access to your Amazon Kendra experience. You must set up IAM Identity Center with Amazon Kendra. You must include your users and groups in your Access Control List when you ingest documents into your index. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/getting-started-aws-sso.html">Getting started with an IAM Identity Center identity source</a>.</p>
    pub fn identity_attribute_name(&self) -> std::option::Option<&str> {
        self.identity_attribute_name.as_deref()
    }
}
/// See [`UserIdentityConfiguration`](crate::model::UserIdentityConfiguration).
pub mod user_identity_configuration {

    /// A builder for [`UserIdentityConfiguration`](crate::model::UserIdentityConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identity_attribute_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IAM Identity Center field name that contains the identifiers of your users, such as their emails. This is used for <a href="https://docs.aws.amazon.com/kendra/latest/dg/user-context-filter.html">user context filtering</a> and for granting access to your Amazon Kendra experience. You must set up IAM Identity Center with Amazon Kendra. You must include your users and groups in your Access Control List when you ingest documents into your index. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/getting-started-aws-sso.html">Getting started with an IAM Identity Center identity source</a>.</p>
        pub fn identity_attribute_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.identity_attribute_name = Some(input.into());
            self
        }
        /// <p>The IAM Identity Center field name that contains the identifiers of your users, such as their emails. This is used for <a href="https://docs.aws.amazon.com/kendra/latest/dg/user-context-filter.html">user context filtering</a> and for granting access to your Amazon Kendra experience. You must set up IAM Identity Center with Amazon Kendra. You must include your users and groups in your Access Control List when you ingest documents into your index. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/getting-started-aws-sso.html">Getting started with an IAM Identity Center identity source</a>.</p>
        pub fn set_identity_attribute_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.identity_attribute_name = input;
            self
        }
        /// Consumes the builder and constructs a [`UserIdentityConfiguration`](crate::model::UserIdentityConfiguration).
        pub fn build(self) -> crate::model::UserIdentityConfiguration {
            crate::model::UserIdentityConfiguration {
                identity_attribute_name: self.identity_attribute_name,
            }
        }
    }
}
impl UserIdentityConfiguration {
    /// Creates a new builder-style object to manufacture [`UserIdentityConfiguration`](crate::model::UserIdentityConfiguration).
    pub fn builder() -> crate::model::user_identity_configuration::Builder {
        crate::model::user_identity_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information for your content sources, such as data sources, FAQs, and content indexed directly via <a href="https://docs.aws.amazon.com/kendra/latest/dg/API_BatchPutDocument.html">BatchPutDocument</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ContentSourceConfiguration {
    /// <p>The identifier of the data sources you want to use for your Amazon Kendra experience.</p>
    #[doc(hidden)]
    pub data_source_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The identifier of the FAQs that you want to use for your Amazon Kendra experience.</p>
    #[doc(hidden)]
    pub faq_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> <code>TRUE</code> to use documents you indexed directly using the <code>BatchPutDocument</code> API.</p>
    #[doc(hidden)]
    pub direct_put_content: bool,
}
impl ContentSourceConfiguration {
    /// <p>The identifier of the data sources you want to use for your Amazon Kendra experience.</p>
    pub fn data_source_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.data_source_ids.as_deref()
    }
    /// <p>The identifier of the FAQs that you want to use for your Amazon Kendra experience.</p>
    pub fn faq_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.faq_ids.as_deref()
    }
    /// <p> <code>TRUE</code> to use documents you indexed directly using the <code>BatchPutDocument</code> API.</p>
    pub fn direct_put_content(&self) -> bool {
        self.direct_put_content
    }
}
/// See [`ContentSourceConfiguration`](crate::model::ContentSourceConfiguration).
pub mod content_source_configuration {

    /// A builder for [`ContentSourceConfiguration`](crate::model::ContentSourceConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_source_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) faq_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) direct_put_content: std::option::Option<bool>,
    }
    impl Builder {
        /// Appends an item to `data_source_ids`.
        ///
        /// To override the contents of this collection use [`set_data_source_ids`](Self::set_data_source_ids).
        ///
        /// <p>The identifier of the data sources you want to use for your Amazon Kendra experience.</p>
        pub fn data_source_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.data_source_ids.unwrap_or_default();
            v.push(input.into());
            self.data_source_ids = Some(v);
            self
        }
        /// <p>The identifier of the data sources you want to use for your Amazon Kendra experience.</p>
        pub fn set_data_source_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.data_source_ids = input;
            self
        }
        /// Appends an item to `faq_ids`.
        ///
        /// To override the contents of this collection use [`set_faq_ids`](Self::set_faq_ids).
        ///
        /// <p>The identifier of the FAQs that you want to use for your Amazon Kendra experience.</p>
        pub fn faq_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.faq_ids.unwrap_or_default();
            v.push(input.into());
            self.faq_ids = Some(v);
            self
        }
        /// <p>The identifier of the FAQs that you want to use for your Amazon Kendra experience.</p>
        pub fn set_faq_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.faq_ids = input;
            self
        }
        /// <p> <code>TRUE</code> to use documents you indexed directly using the <code>BatchPutDocument</code> API.</p>
        pub fn direct_put_content(mut self, input: bool) -> Self {
            self.direct_put_content = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to use documents you indexed directly using the <code>BatchPutDocument</code> API.</p>
        pub fn set_direct_put_content(mut self, input: std::option::Option<bool>) -> Self {
            self.direct_put_content = input;
            self
        }
        /// Consumes the builder and constructs a [`ContentSourceConfiguration`](crate::model::ContentSourceConfiguration).
        pub fn build(self) -> crate::model::ContentSourceConfiguration {
            crate::model::ContentSourceConfiguration {
                data_source_ids: self.data_source_ids,
                faq_ids: self.faq_ids,
                direct_put_content: self.direct_put_content.unwrap_or_default(),
            }
        }
    }
}
impl ContentSourceConfiguration {
    /// Creates a new builder-style object to manufacture [`ContentSourceConfiguration`](crate::model::ContentSourceConfiguration).
    pub fn builder() -> crate::model::content_source_configuration::Builder {
        crate::model::content_source_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information for altering document metadata and content during the document ingestion process.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html">Customizing document metadata during the ingestion process</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomDocumentEnrichmentConfiguration {
    /// <p>Configuration information to alter document attributes or metadata fields and content when ingesting documents into Amazon Kendra.</p>
    #[doc(hidden)]
    pub inline_configurations: std::option::Option<
        std::vec::Vec<crate::model::InlineCustomDocumentEnrichmentConfiguration>,
    >,
    /// <p>Configuration information for invoking a Lambda function in Lambda on the original or raw documents before extracting their metadata and text. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#advanced-data-manipulation">Advanced data manipulation</a>.</p>
    #[doc(hidden)]
    pub pre_extraction_hook_configuration: std::option::Option<crate::model::HookConfiguration>,
    /// <p>Configuration information for invoking a Lambda function in Lambda on the structured documents with their metadata and text extracted. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#advanced-data-manipulation">Advanced data manipulation</a>.</p>
    #[doc(hidden)]
    pub post_extraction_hook_configuration: std::option::Option<crate::model::HookConfiguration>,
    /// <p>The Amazon Resource Name (ARN) of a role with permission to run <code>PreExtractionHookConfiguration</code> and <code>PostExtractionHookConfiguration</code> for altering document metadata and content during the document ingestion process. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/iam-roles.html">IAM roles for Amazon Kendra</a>.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
}
impl CustomDocumentEnrichmentConfiguration {
    /// <p>Configuration information to alter document attributes or metadata fields and content when ingesting documents into Amazon Kendra.</p>
    pub fn inline_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::InlineCustomDocumentEnrichmentConfiguration]> {
        self.inline_configurations.as_deref()
    }
    /// <p>Configuration information for invoking a Lambda function in Lambda on the original or raw documents before extracting their metadata and text. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#advanced-data-manipulation">Advanced data manipulation</a>.</p>
    pub fn pre_extraction_hook_configuration(
        &self,
    ) -> std::option::Option<&crate::model::HookConfiguration> {
        self.pre_extraction_hook_configuration.as_ref()
    }
    /// <p>Configuration information for invoking a Lambda function in Lambda on the structured documents with their metadata and text extracted. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#advanced-data-manipulation">Advanced data manipulation</a>.</p>
    pub fn post_extraction_hook_configuration(
        &self,
    ) -> std::option::Option<&crate::model::HookConfiguration> {
        self.post_extraction_hook_configuration.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of a role with permission to run <code>PreExtractionHookConfiguration</code> and <code>PostExtractionHookConfiguration</code> for altering document metadata and content during the document ingestion process. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/iam-roles.html">IAM roles for Amazon Kendra</a>.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
}
/// See [`CustomDocumentEnrichmentConfiguration`](crate::model::CustomDocumentEnrichmentConfiguration).
pub mod custom_document_enrichment_configuration {

    /// A builder for [`CustomDocumentEnrichmentConfiguration`](crate::model::CustomDocumentEnrichmentConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) inline_configurations: std::option::Option<
            std::vec::Vec<crate::model::InlineCustomDocumentEnrichmentConfiguration>,
        >,
        pub(crate) pre_extraction_hook_configuration:
            std::option::Option<crate::model::HookConfiguration>,
        pub(crate) post_extraction_hook_configuration:
            std::option::Option<crate::model::HookConfiguration>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `inline_configurations`.
        ///
        /// To override the contents of this collection use [`set_inline_configurations`](Self::set_inline_configurations).
        ///
        /// <p>Configuration information to alter document attributes or metadata fields and content when ingesting documents into Amazon Kendra.</p>
        pub fn inline_configurations(
            mut self,
            input: crate::model::InlineCustomDocumentEnrichmentConfiguration,
        ) -> Self {
            let mut v = self.inline_configurations.unwrap_or_default();
            v.push(input);
            self.inline_configurations = Some(v);
            self
        }
        /// <p>Configuration information to alter document attributes or metadata fields and content when ingesting documents into Amazon Kendra.</p>
        pub fn set_inline_configurations(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::InlineCustomDocumentEnrichmentConfiguration>,
            >,
        ) -> Self {
            self.inline_configurations = input;
            self
        }
        /// <p>Configuration information for invoking a Lambda function in Lambda on the original or raw documents before extracting their metadata and text. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#advanced-data-manipulation">Advanced data manipulation</a>.</p>
        pub fn pre_extraction_hook_configuration(
            mut self,
            input: crate::model::HookConfiguration,
        ) -> Self {
            self.pre_extraction_hook_configuration = Some(input);
            self
        }
        /// <p>Configuration information for invoking a Lambda function in Lambda on the original or raw documents before extracting their metadata and text. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#advanced-data-manipulation">Advanced data manipulation</a>.</p>
        pub fn set_pre_extraction_hook_configuration(
            mut self,
            input: std::option::Option<crate::model::HookConfiguration>,
        ) -> Self {
            self.pre_extraction_hook_configuration = input;
            self
        }
        /// <p>Configuration information for invoking a Lambda function in Lambda on the structured documents with their metadata and text extracted. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#advanced-data-manipulation">Advanced data manipulation</a>.</p>
        pub fn post_extraction_hook_configuration(
            mut self,
            input: crate::model::HookConfiguration,
        ) -> Self {
            self.post_extraction_hook_configuration = Some(input);
            self
        }
        /// <p>Configuration information for invoking a Lambda function in Lambda on the structured documents with their metadata and text extracted. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#advanced-data-manipulation">Advanced data manipulation</a>.</p>
        pub fn set_post_extraction_hook_configuration(
            mut self,
            input: std::option::Option<crate::model::HookConfiguration>,
        ) -> Self {
            self.post_extraction_hook_configuration = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a role with permission to run <code>PreExtractionHookConfiguration</code> and <code>PostExtractionHookConfiguration</code> for altering document metadata and content during the document ingestion process. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/iam-roles.html">IAM roles for Amazon Kendra</a>.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a role with permission to run <code>PreExtractionHookConfiguration</code> and <code>PostExtractionHookConfiguration</code> for altering document metadata and content during the document ingestion process. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/iam-roles.html">IAM roles for Amazon Kendra</a>.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomDocumentEnrichmentConfiguration`](crate::model::CustomDocumentEnrichmentConfiguration).
        pub fn build(self) -> crate::model::CustomDocumentEnrichmentConfiguration {
            crate::model::CustomDocumentEnrichmentConfiguration {
                inline_configurations: self.inline_configurations,
                pre_extraction_hook_configuration: self.pre_extraction_hook_configuration,
                post_extraction_hook_configuration: self.post_extraction_hook_configuration,
                role_arn: self.role_arn,
            }
        }
    }
}
impl CustomDocumentEnrichmentConfiguration {
    /// Creates a new builder-style object to manufacture [`CustomDocumentEnrichmentConfiguration`](crate::model::CustomDocumentEnrichmentConfiguration).
    pub fn builder() -> crate::model::custom_document_enrichment_configuration::Builder {
        crate::model::custom_document_enrichment_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information for invoking a Lambda function in Lambda to alter document metadata and content when ingesting documents into Amazon Kendra. You can configure your Lambda function using <a href="https://docs.aws.amazon.com/kendra/latest/dg/API_CustomDocumentEnrichmentConfiguration.html">PreExtractionHookConfiguration</a> if you want to apply advanced alterations on the original or raw documents. If you want to apply advanced alterations on the Amazon Kendra structured documents, you must configure your Lambda function using <a href="https://docs.aws.amazon.com/kendra/latest/dg/API_CustomDocumentEnrichmentConfiguration.html">PostExtractionHookConfiguration</a>. You can only invoke one Lambda function. However, this function can invoke other functions it requires.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html">Customizing document metadata during the ingestion process</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HookConfiguration {
    /// <p>The condition used for when a Lambda function should be invoked.</p>
    /// <p>For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time.</p>
    #[doc(hidden)]
    pub invocation_condition: std::option::Option<crate::model::DocumentAttributeCondition>,
    /// <p>The Amazon Resource Name (ARN) of a role with permission to run a Lambda function during ingestion. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/iam-roles.html">IAM roles for Amazon Kendra</a>.</p>
    #[doc(hidden)]
    pub lambda_arn: std::option::Option<std::string::String>,
    /// <p>Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#cde-data-contracts-lambda">Data contracts for Lambda functions</a>.</p>
    #[doc(hidden)]
    pub s3_bucket: std::option::Option<std::string::String>,
}
impl HookConfiguration {
    /// <p>The condition used for when a Lambda function should be invoked.</p>
    /// <p>For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time.</p>
    pub fn invocation_condition(
        &self,
    ) -> std::option::Option<&crate::model::DocumentAttributeCondition> {
        self.invocation_condition.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of a role with permission to run a Lambda function during ingestion. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/iam-roles.html">IAM roles for Amazon Kendra</a>.</p>
    pub fn lambda_arn(&self) -> std::option::Option<&str> {
        self.lambda_arn.as_deref()
    }
    /// <p>Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#cde-data-contracts-lambda">Data contracts for Lambda functions</a>.</p>
    pub fn s3_bucket(&self) -> std::option::Option<&str> {
        self.s3_bucket.as_deref()
    }
}
/// See [`HookConfiguration`](crate::model::HookConfiguration).
pub mod hook_configuration {

    /// A builder for [`HookConfiguration`](crate::model::HookConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) invocation_condition:
            std::option::Option<crate::model::DocumentAttributeCondition>,
        pub(crate) lambda_arn: std::option::Option<std::string::String>,
        pub(crate) s3_bucket: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The condition used for when a Lambda function should be invoked.</p>
        /// <p>For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time.</p>
        pub fn invocation_condition(
            mut self,
            input: crate::model::DocumentAttributeCondition,
        ) -> Self {
            self.invocation_condition = Some(input);
            self
        }
        /// <p>The condition used for when a Lambda function should be invoked.</p>
        /// <p>For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time.</p>
        pub fn set_invocation_condition(
            mut self,
            input: std::option::Option<crate::model::DocumentAttributeCondition>,
        ) -> Self {
            self.invocation_condition = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a role with permission to run a Lambda function during ingestion. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/iam-roles.html">IAM roles for Amazon Kendra</a>.</p>
        pub fn lambda_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.lambda_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a role with permission to run a Lambda function during ingestion. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/iam-roles.html">IAM roles for Amazon Kendra</a>.</p>
        pub fn set_lambda_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lambda_arn = input;
            self
        }
        /// <p>Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#cde-data-contracts-lambda">Data contracts for Lambda functions</a>.</p>
        pub fn s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket = Some(input.into());
            self
        }
        /// <p>Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html#cde-data-contracts-lambda">Data contracts for Lambda functions</a>.</p>
        pub fn set_s3_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_bucket = input;
            self
        }
        /// Consumes the builder and constructs a [`HookConfiguration`](crate::model::HookConfiguration).
        pub fn build(self) -> crate::model::HookConfiguration {
            crate::model::HookConfiguration {
                invocation_condition: self.invocation_condition,
                lambda_arn: self.lambda_arn,
                s3_bucket: self.s3_bucket,
            }
        }
    }
}
impl HookConfiguration {
    /// Creates a new builder-style object to manufacture [`HookConfiguration`](crate::model::HookConfiguration).
    pub fn builder() -> crate::model::hook_configuration::Builder {
        crate::model::hook_configuration::Builder::default()
    }
}

/// <p>The condition used for the target document attribute or metadata field when ingesting documents into Amazon Kendra. You use this with <a href="https://docs.aws.amazon.com/kendra/latest/dg/API_DocumentAttributeTarget.html">DocumentAttributeTarget to apply the condition</a>.</p>
/// <p>For example, you can create the 'Department' target field and have it prefill department names associated with the documents based on information in the 'Source_URI' field. Set the condition that if the 'Source_URI' field contains 'financial' in its URI value, then prefill the target field 'Department' with the target value 'Finance' for the document.</p>
/// <p>Amazon Kendra cannot create a target field if it has not already been created as an index field. After you create your index field, you can create a document metadata field using <code>DocumentAttributeTarget</code>. Amazon Kendra then will map your newly created metadata field to your index field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DocumentAttributeCondition {
    /// <p>The identifier of the document attribute used for the condition.</p>
    /// <p>For example, 'Source_URI' could be an identifier for the attribute or metadata field that contains source URIs associated with the documents.</p>
    /// <p>Amazon Kendra currently does not support <code>_document_body</code> as an attribute key used for the condition.</p>
    #[doc(hidden)]
    pub condition_document_attribute_key: std::option::Option<std::string::String>,
    /// <p>The condition operator.</p>
    /// <p>For example, you can use 'Contains' to partially match a string.</p>
    #[doc(hidden)]
    pub operator: std::option::Option<crate::model::ConditionOperator>,
    /// <p>The value used by the operator.</p>
    /// <p>For example, you can specify the value 'financial' for strings in the 'Source_URI' field that partially match or contain this value.</p>
    #[doc(hidden)]
    pub condition_on_value: std::option::Option<crate::model::DocumentAttributeValue>,
}
impl DocumentAttributeCondition {
    /// <p>The identifier of the document attribute used for the condition.</p>
    /// <p>For example, 'Source_URI' could be an identifier for the attribute or metadata field that contains source URIs associated with the documents.</p>
    /// <p>Amazon Kendra currently does not support <code>_document_body</code> as an attribute key used for the condition.</p>
    pub fn condition_document_attribute_key(&self) -> std::option::Option<&str> {
        self.condition_document_attribute_key.as_deref()
    }
    /// <p>The condition operator.</p>
    /// <p>For example, you can use 'Contains' to partially match a string.</p>
    pub fn operator(&self) -> std::option::Option<&crate::model::ConditionOperator> {
        self.operator.as_ref()
    }
    /// <p>The value used by the operator.</p>
    /// <p>For example, you can specify the value 'financial' for strings in the 'Source_URI' field that partially match or contain this value.</p>
    pub fn condition_on_value(&self) -> std::option::Option<&crate::model::DocumentAttributeValue> {
        self.condition_on_value.as_ref()
    }
}
/// See [`DocumentAttributeCondition`](crate::model::DocumentAttributeCondition).
pub mod document_attribute_condition {

    /// A builder for [`DocumentAttributeCondition`](crate::model::DocumentAttributeCondition).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) condition_document_attribute_key: std::option::Option<std::string::String>,
        pub(crate) operator: std::option::Option<crate::model::ConditionOperator>,
        pub(crate) condition_on_value: std::option::Option<crate::model::DocumentAttributeValue>,
    }
    impl Builder {
        /// <p>The identifier of the document attribute used for the condition.</p>
        /// <p>For example, 'Source_URI' could be an identifier for the attribute or metadata field that contains source URIs associated with the documents.</p>
        /// <p>Amazon Kendra currently does not support <code>_document_body</code> as an attribute key used for the condition.</p>
        pub fn condition_document_attribute_key(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.condition_document_attribute_key = Some(input.into());
            self
        }
        /// <p>The identifier of the document attribute used for the condition.</p>
        /// <p>For example, 'Source_URI' could be an identifier for the attribute or metadata field that contains source URIs associated with the documents.</p>
        /// <p>Amazon Kendra currently does not support <code>_document_body</code> as an attribute key used for the condition.</p>
        pub fn set_condition_document_attribute_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.condition_document_attribute_key = input;
            self
        }
        /// <p>The condition operator.</p>
        /// <p>For example, you can use 'Contains' to partially match a string.</p>
        pub fn operator(mut self, input: crate::model::ConditionOperator) -> Self {
            self.operator = Some(input);
            self
        }
        /// <p>The condition operator.</p>
        /// <p>For example, you can use 'Contains' to partially match a string.</p>
        pub fn set_operator(
            mut self,
            input: std::option::Option<crate::model::ConditionOperator>,
        ) -> Self {
            self.operator = input;
            self
        }
        /// <p>The value used by the operator.</p>
        /// <p>For example, you can specify the value 'financial' for strings in the 'Source_URI' field that partially match or contain this value.</p>
        pub fn condition_on_value(mut self, input: crate::model::DocumentAttributeValue) -> Self {
            self.condition_on_value = Some(input);
            self
        }
        /// <p>The value used by the operator.</p>
        /// <p>For example, you can specify the value 'financial' for strings in the 'Source_URI' field that partially match or contain this value.</p>
        pub fn set_condition_on_value(
            mut self,
            input: std::option::Option<crate::model::DocumentAttributeValue>,
        ) -> Self {
            self.condition_on_value = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentAttributeCondition`](crate::model::DocumentAttributeCondition).
        pub fn build(self) -> crate::model::DocumentAttributeCondition {
            crate::model::DocumentAttributeCondition {
                condition_document_attribute_key: self.condition_document_attribute_key,
                operator: self.operator,
                condition_on_value: self.condition_on_value,
            }
        }
    }
}
impl DocumentAttributeCondition {
    /// Creates a new builder-style object to manufacture [`DocumentAttributeCondition`](crate::model::DocumentAttributeCondition).
    pub fn builder() -> crate::model::document_attribute_condition::Builder {
        crate::model::document_attribute_condition::Builder::default()
    }
}

/// <p>The value of a document attribute. You can only provide one value for a document attribute.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DocumentAttributeValue {
    /// <p>A string, such as "department".</p>
    #[doc(hidden)]
    pub string_value: std::option::Option<std::string::String>,
    /// <p>A list of strings. The default maximum length or number of strings is 10.</p>
    #[doc(hidden)]
    pub string_list_value: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A long integer value.</p>
    #[doc(hidden)]
    pub long_value: std::option::Option<i64>,
    /// <p>A date expressed as an ISO 8601 string.</p>
    /// <p>It is important for the time zone to be included in the ISO 8601 date-time format. For example, 2012-03-25T12:30:10+01:00 is the ISO 8601 date-time format for March 25th 2012 at 12:30PM (plus 10 seconds) in Central European Time.</p>
    #[doc(hidden)]
    pub date_value: std::option::Option<aws_smithy_types::DateTime>,
}
impl DocumentAttributeValue {
    /// <p>A string, such as "department".</p>
    pub fn string_value(&self) -> std::option::Option<&str> {
        self.string_value.as_deref()
    }
    /// <p>A list of strings. The default maximum length or number of strings is 10.</p>
    pub fn string_list_value(&self) -> std::option::Option<&[std::string::String]> {
        self.string_list_value.as_deref()
    }
    /// <p>A long integer value.</p>
    pub fn long_value(&self) -> std::option::Option<i64> {
        self.long_value
    }
    /// <p>A date expressed as an ISO 8601 string.</p>
    /// <p>It is important for the time zone to be included in the ISO 8601 date-time format. For example, 2012-03-25T12:30:10+01:00 is the ISO 8601 date-time format for March 25th 2012 at 12:30PM (plus 10 seconds) in Central European Time.</p>
    pub fn date_value(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.date_value.as_ref()
    }
}
/// See [`DocumentAttributeValue`](crate::model::DocumentAttributeValue).
pub mod document_attribute_value {

    /// A builder for [`DocumentAttributeValue`](crate::model::DocumentAttributeValue).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) string_value: std::option::Option<std::string::String>,
        pub(crate) string_list_value: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) long_value: std::option::Option<i64>,
        pub(crate) date_value: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>A string, such as "department".</p>
        pub fn string_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.string_value = Some(input.into());
            self
        }
        /// <p>A string, such as "department".</p>
        pub fn set_string_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.string_value = input;
            self
        }
        /// Appends an item to `string_list_value`.
        ///
        /// To override the contents of this collection use [`set_string_list_value`](Self::set_string_list_value).
        ///
        /// <p>A list of strings. The default maximum length or number of strings is 10.</p>
        pub fn string_list_value(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.string_list_value.unwrap_or_default();
            v.push(input.into());
            self.string_list_value = Some(v);
            self
        }
        /// <p>A list of strings. The default maximum length or number of strings is 10.</p>
        pub fn set_string_list_value(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.string_list_value = input;
            self
        }
        /// <p>A long integer value.</p>
        pub fn long_value(mut self, input: i64) -> Self {
            self.long_value = Some(input);
            self
        }
        /// <p>A long integer value.</p>
        pub fn set_long_value(mut self, input: std::option::Option<i64>) -> Self {
            self.long_value = input;
            self
        }
        /// <p>A date expressed as an ISO 8601 string.</p>
        /// <p>It is important for the time zone to be included in the ISO 8601 date-time format. For example, 2012-03-25T12:30:10+01:00 is the ISO 8601 date-time format for March 25th 2012 at 12:30PM (plus 10 seconds) in Central European Time.</p>
        pub fn date_value(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.date_value = Some(input);
            self
        }
        /// <p>A date expressed as an ISO 8601 string.</p>
        /// <p>It is important for the time zone to be included in the ISO 8601 date-time format. For example, 2012-03-25T12:30:10+01:00 is the ISO 8601 date-time format for March 25th 2012 at 12:30PM (plus 10 seconds) in Central European Time.</p>
        pub fn set_date_value(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.date_value = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentAttributeValue`](crate::model::DocumentAttributeValue).
        pub fn build(self) -> crate::model::DocumentAttributeValue {
            crate::model::DocumentAttributeValue {
                string_value: self.string_value,
                string_list_value: self.string_list_value,
                long_value: self.long_value,
                date_value: self.date_value,
            }
        }
    }
}
impl DocumentAttributeValue {
    /// Creates a new builder-style object to manufacture [`DocumentAttributeValue`](crate::model::DocumentAttributeValue).
    pub fn builder() -> crate::model::document_attribute_value::Builder {
        crate::model::document_attribute_value::Builder::default()
    }
}

/// When writing a match expression against `ConditionOperator`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let conditionoperator = unimplemented!();
/// match conditionoperator {
///     ConditionOperator::BeginsWith => { /* ... */ },
///     ConditionOperator::Contains => { /* ... */ },
///     ConditionOperator::Equals => { /* ... */ },
///     ConditionOperator::Exists => { /* ... */ },
///     ConditionOperator::GreaterThan => { /* ... */ },
///     ConditionOperator::GreaterThanOrEquals => { /* ... */ },
///     ConditionOperator::LessThan => { /* ... */ },
///     ConditionOperator::LessThanOrEquals => { /* ... */ },
///     ConditionOperator::NotContains => { /* ... */ },
///     ConditionOperator::NotEquals => { /* ... */ },
///     ConditionOperator::NotExists => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `conditionoperator` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConditionOperator::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConditionOperator::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConditionOperator::NewFeature` is defined.
/// Specifically, when `conditionoperator` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConditionOperator::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConditionOperator {
    #[allow(missing_docs)] // documentation missing in model
    BeginsWith,
    #[allow(missing_docs)] // documentation missing in model
    Contains,
    #[allow(missing_docs)] // documentation missing in model
    Equals,
    #[allow(missing_docs)] // documentation missing in model
    Exists,
    #[allow(missing_docs)] // documentation missing in model
    GreaterThan,
    #[allow(missing_docs)] // documentation missing in model
    GreaterThanOrEquals,
    #[allow(missing_docs)] // documentation missing in model
    LessThan,
    #[allow(missing_docs)] // documentation missing in model
    LessThanOrEquals,
    #[allow(missing_docs)] // documentation missing in model
    NotContains,
    #[allow(missing_docs)] // documentation missing in model
    NotEquals,
    #[allow(missing_docs)] // documentation missing in model
    NotExists,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConditionOperator {
    fn from(s: &str) -> Self {
        match s {
            "BeginsWith" => ConditionOperator::BeginsWith,
            "Contains" => ConditionOperator::Contains,
            "Equals" => ConditionOperator::Equals,
            "Exists" => ConditionOperator::Exists,
            "GreaterThan" => ConditionOperator::GreaterThan,
            "GreaterThanOrEquals" => ConditionOperator::GreaterThanOrEquals,
            "LessThan" => ConditionOperator::LessThan,
            "LessThanOrEquals" => ConditionOperator::LessThanOrEquals,
            "NotContains" => ConditionOperator::NotContains,
            "NotEquals" => ConditionOperator::NotEquals,
            "NotExists" => ConditionOperator::NotExists,
            other => {
                ConditionOperator::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ConditionOperator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConditionOperator::from(s))
    }
}
impl ConditionOperator {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConditionOperator::BeginsWith => "BeginsWith",
            ConditionOperator::Contains => "Contains",
            ConditionOperator::Equals => "Equals",
            ConditionOperator::Exists => "Exists",
            ConditionOperator::GreaterThan => "GreaterThan",
            ConditionOperator::GreaterThanOrEquals => "GreaterThanOrEquals",
            ConditionOperator::LessThan => "LessThan",
            ConditionOperator::LessThanOrEquals => "LessThanOrEquals",
            ConditionOperator::NotContains => "NotContains",
            ConditionOperator::NotEquals => "NotEquals",
            ConditionOperator::NotExists => "NotExists",
            ConditionOperator::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BeginsWith",
            "Contains",
            "Equals",
            "Exists",
            "GreaterThan",
            "GreaterThanOrEquals",
            "LessThan",
            "LessThanOrEquals",
            "NotContains",
            "NotEquals",
            "NotExists",
        ]
    }
}
impl AsRef<str> for ConditionOperator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides the configuration information for applying basic logic to alter document metadata and content when ingesting documents into Amazon Kendra. To apply advanced logic, to go beyond what you can do with basic logic, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/API_HookConfiguration.html">HookConfiguration</a>.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/custom-document-enrichment.html">Customizing document metadata during the ingestion process</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InlineCustomDocumentEnrichmentConfiguration {
    /// <p>Configuration of the condition used for the target document attribute or metadata field when ingesting documents into Amazon Kendra.</p>
    #[doc(hidden)]
    pub condition: std::option::Option<crate::model::DocumentAttributeCondition>,
    /// <p>Configuration of the target document attribute or metadata field when ingesting documents into Amazon Kendra. You can also include a value.</p>
    #[doc(hidden)]
    pub target: std::option::Option<crate::model::DocumentAttributeTarget>,
    /// <p> <code>TRUE</code> to delete content if the condition used for the target attribute is met.</p>
    #[doc(hidden)]
    pub document_content_deletion: bool,
}
impl InlineCustomDocumentEnrichmentConfiguration {
    /// <p>Configuration of the condition used for the target document attribute or metadata field when ingesting documents into Amazon Kendra.</p>
    pub fn condition(&self) -> std::option::Option<&crate::model::DocumentAttributeCondition> {
        self.condition.as_ref()
    }
    /// <p>Configuration of the target document attribute or metadata field when ingesting documents into Amazon Kendra. You can also include a value.</p>
    pub fn target(&self) -> std::option::Option<&crate::model::DocumentAttributeTarget> {
        self.target.as_ref()
    }
    /// <p> <code>TRUE</code> to delete content if the condition used for the target attribute is met.</p>
    pub fn document_content_deletion(&self) -> bool {
        self.document_content_deletion
    }
}
/// See [`InlineCustomDocumentEnrichmentConfiguration`](crate::model::InlineCustomDocumentEnrichmentConfiguration).
pub mod inline_custom_document_enrichment_configuration {

    /// A builder for [`InlineCustomDocumentEnrichmentConfiguration`](crate::model::InlineCustomDocumentEnrichmentConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) condition: std::option::Option<crate::model::DocumentAttributeCondition>,
        pub(crate) target: std::option::Option<crate::model::DocumentAttributeTarget>,
        pub(crate) document_content_deletion: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Configuration of the condition used for the target document attribute or metadata field when ingesting documents into Amazon Kendra.</p>
        pub fn condition(mut self, input: crate::model::DocumentAttributeCondition) -> Self {
            self.condition = Some(input);
            self
        }
        /// <p>Configuration of the condition used for the target document attribute or metadata field when ingesting documents into Amazon Kendra.</p>
        pub fn set_condition(
            mut self,
            input: std::option::Option<crate::model::DocumentAttributeCondition>,
        ) -> Self {
            self.condition = input;
            self
        }
        /// <p>Configuration of the target document attribute or metadata field when ingesting documents into Amazon Kendra. You can also include a value.</p>
        pub fn target(mut self, input: crate::model::DocumentAttributeTarget) -> Self {
            self.target = Some(input);
            self
        }
        /// <p>Configuration of the target document attribute or metadata field when ingesting documents into Amazon Kendra. You can also include a value.</p>
        pub fn set_target(
            mut self,
            input: std::option::Option<crate::model::DocumentAttributeTarget>,
        ) -> Self {
            self.target = input;
            self
        }
        /// <p> <code>TRUE</code> to delete content if the condition used for the target attribute is met.</p>
        pub fn document_content_deletion(mut self, input: bool) -> Self {
            self.document_content_deletion = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to delete content if the condition used for the target attribute is met.</p>
        pub fn set_document_content_deletion(mut self, input: std::option::Option<bool>) -> Self {
            self.document_content_deletion = input;
            self
        }
        /// Consumes the builder and constructs a [`InlineCustomDocumentEnrichmentConfiguration`](crate::model::InlineCustomDocumentEnrichmentConfiguration).
        pub fn build(self) -> crate::model::InlineCustomDocumentEnrichmentConfiguration {
            crate::model::InlineCustomDocumentEnrichmentConfiguration {
                condition: self.condition,
                target: self.target,
                document_content_deletion: self.document_content_deletion.unwrap_or_default(),
            }
        }
    }
}
impl InlineCustomDocumentEnrichmentConfiguration {
    /// Creates a new builder-style object to manufacture [`InlineCustomDocumentEnrichmentConfiguration`](crate::model::InlineCustomDocumentEnrichmentConfiguration).
    pub fn builder() -> crate::model::inline_custom_document_enrichment_configuration::Builder {
        crate::model::inline_custom_document_enrichment_configuration::Builder::default()
    }
}

/// <p>The target document attribute or metadata field you want to alter when ingesting documents into Amazon Kendra.</p>
/// <p>For example, you can delete customer identification numbers associated with the documents, stored in the document metadata field called 'Customer_ID'. You set the target key as 'Customer_ID' and the deletion flag to <code>TRUE</code>. This removes all customer ID values in the field 'Customer_ID'. This would scrub personally identifiable information from each document's metadata.</p>
/// <p>Amazon Kendra cannot create a target field if it has not already been created as an index field. After you create your index field, you can create a document metadata field using <code>DocumentAttributeTarget</code>. Amazon Kendra then will map your newly created metadata field to your index field.</p>
/// <p>You can also use this with <a href="https://docs.aws.amazon.com/kendra/latest/dg/API_DocumentAttributeCondition.html">DocumentAttributeCondition</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DocumentAttributeTarget {
    /// <p>The identifier of the target document attribute or metadata field.</p>
    /// <p>For example, 'Department' could be an identifier for the target attribute or metadata field that includes the department names associated with the documents.</p>
    #[doc(hidden)]
    pub target_document_attribute_key: std::option::Option<std::string::String>,
    /// <p> <code>TRUE</code> to delete the existing target value for your specified target attribute key. You cannot create a target value and set this to <code>TRUE</code>. To create a target value (<code>TargetDocumentAttributeValue</code>), set this to <code>FALSE</code>.</p>
    #[doc(hidden)]
    pub target_document_attribute_value_deletion: bool,
    /// <p>The target value you want to create for the target attribute.</p>
    /// <p>For example, 'Finance' could be the target value for the target attribute key 'Department'.</p>
    #[doc(hidden)]
    pub target_document_attribute_value: std::option::Option<crate::model::DocumentAttributeValue>,
}
impl DocumentAttributeTarget {
    /// <p>The identifier of the target document attribute or metadata field.</p>
    /// <p>For example, 'Department' could be an identifier for the target attribute or metadata field that includes the department names associated with the documents.</p>
    pub fn target_document_attribute_key(&self) -> std::option::Option<&str> {
        self.target_document_attribute_key.as_deref()
    }
    /// <p> <code>TRUE</code> to delete the existing target value for your specified target attribute key. You cannot create a target value and set this to <code>TRUE</code>. To create a target value (<code>TargetDocumentAttributeValue</code>), set this to <code>FALSE</code>.</p>
    pub fn target_document_attribute_value_deletion(&self) -> bool {
        self.target_document_attribute_value_deletion
    }
    /// <p>The target value you want to create for the target attribute.</p>
    /// <p>For example, 'Finance' could be the target value for the target attribute key 'Department'.</p>
    pub fn target_document_attribute_value(
        &self,
    ) -> std::option::Option<&crate::model::DocumentAttributeValue> {
        self.target_document_attribute_value.as_ref()
    }
}
/// See [`DocumentAttributeTarget`](crate::model::DocumentAttributeTarget).
pub mod document_attribute_target {

    /// A builder for [`DocumentAttributeTarget`](crate::model::DocumentAttributeTarget).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_document_attribute_key: std::option::Option<std::string::String>,
        pub(crate) target_document_attribute_value_deletion: std::option::Option<bool>,
        pub(crate) target_document_attribute_value:
            std::option::Option<crate::model::DocumentAttributeValue>,
    }
    impl Builder {
        /// <p>The identifier of the target document attribute or metadata field.</p>
        /// <p>For example, 'Department' could be an identifier for the target attribute or metadata field that includes the department names associated with the documents.</p>
        pub fn target_document_attribute_key(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.target_document_attribute_key = Some(input.into());
            self
        }
        /// <p>The identifier of the target document attribute or metadata field.</p>
        /// <p>For example, 'Department' could be an identifier for the target attribute or metadata field that includes the department names associated with the documents.</p>
        pub fn set_target_document_attribute_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_document_attribute_key = input;
            self
        }
        /// <p> <code>TRUE</code> to delete the existing target value for your specified target attribute key. You cannot create a target value and set this to <code>TRUE</code>. To create a target value (<code>TargetDocumentAttributeValue</code>), set this to <code>FALSE</code>.</p>
        pub fn target_document_attribute_value_deletion(mut self, input: bool) -> Self {
            self.target_document_attribute_value_deletion = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to delete the existing target value for your specified target attribute key. You cannot create a target value and set this to <code>TRUE</code>. To create a target value (<code>TargetDocumentAttributeValue</code>), set this to <code>FALSE</code>.</p>
        pub fn set_target_document_attribute_value_deletion(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.target_document_attribute_value_deletion = input;
            self
        }
        /// <p>The target value you want to create for the target attribute.</p>
        /// <p>For example, 'Finance' could be the target value for the target attribute key 'Department'.</p>
        pub fn target_document_attribute_value(
            mut self,
            input: crate::model::DocumentAttributeValue,
        ) -> Self {
            self.target_document_attribute_value = Some(input);
            self
        }
        /// <p>The target value you want to create for the target attribute.</p>
        /// <p>For example, 'Finance' could be the target value for the target attribute key 'Department'.</p>
        pub fn set_target_document_attribute_value(
            mut self,
            input: std::option::Option<crate::model::DocumentAttributeValue>,
        ) -> Self {
            self.target_document_attribute_value = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentAttributeTarget`](crate::model::DocumentAttributeTarget).
        pub fn build(self) -> crate::model::DocumentAttributeTarget {
            crate::model::DocumentAttributeTarget {
                target_document_attribute_key: self.target_document_attribute_key,
                target_document_attribute_value_deletion: self
                    .target_document_attribute_value_deletion
                    .unwrap_or_default(),
                target_document_attribute_value: self.target_document_attribute_value,
            }
        }
    }
}
impl DocumentAttributeTarget {
    /// Creates a new builder-style object to manufacture [`DocumentAttributeTarget`](crate::model::DocumentAttributeTarget).
    pub fn builder() -> crate::model::document_attribute_target::Builder {
        crate::model::document_attribute_target::Builder::default()
    }
}

/// <p>Provides the configuration information to connect to an Amazon VPC.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSourceVpcConfiguration {
    /// <p>A list of identifiers for subnets within your Amazon VPC. The subnets should be able to connect to each other in the VPC, and they should have outgoing access to the Internet through a NAT device.</p>
    #[doc(hidden)]
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of identifiers of security groups within your Amazon VPC. The security groups should enable Amazon Kendra to connect to the data source.</p>
    #[doc(hidden)]
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl DataSourceVpcConfiguration {
    /// <p>A list of identifiers for subnets within your Amazon VPC. The subnets should be able to connect to each other in the VPC, and they should have outgoing access to the Internet through a NAT device.</p>
    pub fn subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_ids.as_deref()
    }
    /// <p>A list of identifiers of security groups within your Amazon VPC. The security groups should enable Amazon Kendra to connect to the data source.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
}
/// See [`DataSourceVpcConfiguration`](crate::model::DataSourceVpcConfiguration).
pub mod data_source_vpc_configuration {

    /// A builder for [`DataSourceVpcConfiguration`](crate::model::DataSourceVpcConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `subnet_ids`.
        ///
        /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
        ///
        /// <p>A list of identifiers for subnets within your Amazon VPC. The subnets should be able to connect to each other in the VPC, and they should have outgoing access to the Internet through a NAT device.</p>
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        /// <p>A list of identifiers for subnets within your Amazon VPC. The subnets should be able to connect to each other in the VPC, and they should have outgoing access to the Internet through a NAT device.</p>
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        /// Appends an item to `security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
        ///
        /// <p>A list of identifiers of security groups within your Amazon VPC. The security groups should enable Amazon Kendra to connect to the data source.</p>
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        /// <p>A list of identifiers of security groups within your Amazon VPC. The security groups should enable Amazon Kendra to connect to the data source.</p>
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSourceVpcConfiguration`](crate::model::DataSourceVpcConfiguration).
        pub fn build(self) -> crate::model::DataSourceVpcConfiguration {
            crate::model::DataSourceVpcConfiguration {
                subnet_ids: self.subnet_ids,
                security_group_ids: self.security_group_ids,
            }
        }
    }
}
impl DataSourceVpcConfiguration {
    /// Creates a new builder-style object to manufacture [`DataSourceVpcConfiguration`](crate::model::DataSourceVpcConfiguration).
    pub fn builder() -> crate::model::data_source_vpc_configuration::Builder {
        crate::model::data_source_vpc_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information for an Amazon Kendra data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSourceConfiguration {
    /// <p>Provides the configuration information to connect to an Amazon S3 bucket as your data source.</p>
    #[doc(hidden)]
    pub s3_configuration: std::option::Option<crate::model::S3DataSourceConfiguration>,
    /// <p>Provides the configuration information to connect to Microsoft SharePoint as your data source.</p>
    #[doc(hidden)]
    pub share_point_configuration: std::option::Option<crate::model::SharePointConfiguration>,
    /// <p>Provides the configuration information to connect to a database as your data source.</p>
    #[doc(hidden)]
    pub database_configuration: std::option::Option<crate::model::DatabaseConfiguration>,
    /// <p>Provides the configuration information to connect to Salesforce as your data source.</p>
    #[doc(hidden)]
    pub salesforce_configuration: std::option::Option<crate::model::SalesforceConfiguration>,
    /// <p>Provides the configuration information to connect to Microsoft OneDrive as your data source.</p>
    #[doc(hidden)]
    pub one_drive_configuration: std::option::Option<crate::model::OneDriveConfiguration>,
    /// <p>Provides the configuration information to connect to ServiceNow as your data source.</p>
    #[doc(hidden)]
    pub service_now_configuration: std::option::Option<crate::model::ServiceNowConfiguration>,
    /// <p>Provides the configuration information to connect to Confluence as your data source.</p>
    #[doc(hidden)]
    pub confluence_configuration: std::option::Option<crate::model::ConfluenceConfiguration>,
    /// <p>Provides the configuration information to connect to Google Drive as your data source.</p>
    #[doc(hidden)]
    pub google_drive_configuration: std::option::Option<crate::model::GoogleDriveConfiguration>,
    /// <p>Provides the configuration information required for Amazon Kendra Web Crawler.</p>
    #[doc(hidden)]
    pub web_crawler_configuration: std::option::Option<crate::model::WebCrawlerConfiguration>,
    /// <p>Provides the configuration information to connect to Amazon WorkDocs as your data source.</p>
    #[doc(hidden)]
    pub work_docs_configuration: std::option::Option<crate::model::WorkDocsConfiguration>,
    /// <p>Provides the configuration information to connect to Amazon FSx as your data source.</p>
    #[doc(hidden)]
    pub fsx_configuration: std::option::Option<crate::model::FsxConfiguration>,
    /// <p>Provides the configuration information to connect to Slack as your data source.</p>
    #[doc(hidden)]
    pub slack_configuration: std::option::Option<crate::model::SlackConfiguration>,
    /// <p>Provides the configuration information to connect to Box as your data source.</p>
    #[doc(hidden)]
    pub box_configuration: std::option::Option<crate::model::BoxConfiguration>,
    /// <p>Provides the configuration information to connect to Quip as your data source.</p>
    #[doc(hidden)]
    pub quip_configuration: std::option::Option<crate::model::QuipConfiguration>,
    /// <p>Provides the configuration information to connect to Jira as your data source.</p>
    #[doc(hidden)]
    pub jira_configuration: std::option::Option<crate::model::JiraConfiguration>,
    /// <p>Provides the configuration information to connect to GitHub as your data source.</p>
    #[doc(hidden)]
    pub git_hub_configuration: std::option::Option<crate::model::GitHubConfiguration>,
    /// <p>Provides the configuration information to connect to Alfresco as your data source.</p>
    #[doc(hidden)]
    pub alfresco_configuration: std::option::Option<crate::model::AlfrescoConfiguration>,
    /// <p>Provides a template for the configuration information to connect to your data source.</p>
    #[doc(hidden)]
    pub template_configuration: std::option::Option<crate::model::TemplateConfiguration>,
}
impl DataSourceConfiguration {
    /// <p>Provides the configuration information to connect to an Amazon S3 bucket as your data source.</p>
    pub fn s3_configuration(
        &self,
    ) -> std::option::Option<&crate::model::S3DataSourceConfiguration> {
        self.s3_configuration.as_ref()
    }
    /// <p>Provides the configuration information to connect to Microsoft SharePoint as your data source.</p>
    pub fn share_point_configuration(
        &self,
    ) -> std::option::Option<&crate::model::SharePointConfiguration> {
        self.share_point_configuration.as_ref()
    }
    /// <p>Provides the configuration information to connect to a database as your data source.</p>
    pub fn database_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DatabaseConfiguration> {
        self.database_configuration.as_ref()
    }
    /// <p>Provides the configuration information to connect to Salesforce as your data source.</p>
    pub fn salesforce_configuration(
        &self,
    ) -> std::option::Option<&crate::model::SalesforceConfiguration> {
        self.salesforce_configuration.as_ref()
    }
    /// <p>Provides the configuration information to connect to Microsoft OneDrive as your data source.</p>
    pub fn one_drive_configuration(
        &self,
    ) -> std::option::Option<&crate::model::OneDriveConfiguration> {
        self.one_drive_configuration.as_ref()
    }
    /// <p>Provides the configuration information to connect to ServiceNow as your data source.</p>
    pub fn service_now_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ServiceNowConfiguration> {
        self.service_now_configuration.as_ref()
    }
    /// <p>Provides the configuration information to connect to Confluence as your data source.</p>
    pub fn confluence_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ConfluenceConfiguration> {
        self.confluence_configuration.as_ref()
    }
    /// <p>Provides the configuration information to connect to Google Drive as your data source.</p>
    pub fn google_drive_configuration(
        &self,
    ) -> std::option::Option<&crate::model::GoogleDriveConfiguration> {
        self.google_drive_configuration.as_ref()
    }
    /// <p>Provides the configuration information required for Amazon Kendra Web Crawler.</p>
    pub fn web_crawler_configuration(
        &self,
    ) -> std::option::Option<&crate::model::WebCrawlerConfiguration> {
        self.web_crawler_configuration.as_ref()
    }
    /// <p>Provides the configuration information to connect to Amazon WorkDocs as your data source.</p>
    pub fn work_docs_configuration(
        &self,
    ) -> std::option::Option<&crate::model::WorkDocsConfiguration> {
        self.work_docs_configuration.as_ref()
    }
    /// <p>Provides the configuration information to connect to Amazon FSx as your data source.</p>
    pub fn fsx_configuration(&self) -> std::option::Option<&crate::model::FsxConfiguration> {
        self.fsx_configuration.as_ref()
    }
    /// <p>Provides the configuration information to connect to Slack as your data source.</p>
    pub fn slack_configuration(&self) -> std::option::Option<&crate::model::SlackConfiguration> {
        self.slack_configuration.as_ref()
    }
    /// <p>Provides the configuration information to connect to Box as your data source.</p>
    pub fn box_configuration(&self) -> std::option::Option<&crate::model::BoxConfiguration> {
        self.box_configuration.as_ref()
    }
    /// <p>Provides the configuration information to connect to Quip as your data source.</p>
    pub fn quip_configuration(&self) -> std::option::Option<&crate::model::QuipConfiguration> {
        self.quip_configuration.as_ref()
    }
    /// <p>Provides the configuration information to connect to Jira as your data source.</p>
    pub fn jira_configuration(&self) -> std::option::Option<&crate::model::JiraConfiguration> {
        self.jira_configuration.as_ref()
    }
    /// <p>Provides the configuration information to connect to GitHub as your data source.</p>
    pub fn git_hub_configuration(&self) -> std::option::Option<&crate::model::GitHubConfiguration> {
        self.git_hub_configuration.as_ref()
    }
    /// <p>Provides the configuration information to connect to Alfresco as your data source.</p>
    pub fn alfresco_configuration(
        &self,
    ) -> std::option::Option<&crate::model::AlfrescoConfiguration> {
        self.alfresco_configuration.as_ref()
    }
    /// <p>Provides a template for the configuration information to connect to your data source.</p>
    pub fn template_configuration(
        &self,
    ) -> std::option::Option<&crate::model::TemplateConfiguration> {
        self.template_configuration.as_ref()
    }
}
/// See [`DataSourceConfiguration`](crate::model::DataSourceConfiguration).
pub mod data_source_configuration {

    /// A builder for [`DataSourceConfiguration`](crate::model::DataSourceConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_configuration: std::option::Option<crate::model::S3DataSourceConfiguration>,
        pub(crate) share_point_configuration:
            std::option::Option<crate::model::SharePointConfiguration>,
        pub(crate) database_configuration: std::option::Option<crate::model::DatabaseConfiguration>,
        pub(crate) salesforce_configuration:
            std::option::Option<crate::model::SalesforceConfiguration>,
        pub(crate) one_drive_configuration:
            std::option::Option<crate::model::OneDriveConfiguration>,
        pub(crate) service_now_configuration:
            std::option::Option<crate::model::ServiceNowConfiguration>,
        pub(crate) confluence_configuration:
            std::option::Option<crate::model::ConfluenceConfiguration>,
        pub(crate) google_drive_configuration:
            std::option::Option<crate::model::GoogleDriveConfiguration>,
        pub(crate) web_crawler_configuration:
            std::option::Option<crate::model::WebCrawlerConfiguration>,
        pub(crate) work_docs_configuration:
            std::option::Option<crate::model::WorkDocsConfiguration>,
        pub(crate) fsx_configuration: std::option::Option<crate::model::FsxConfiguration>,
        pub(crate) slack_configuration: std::option::Option<crate::model::SlackConfiguration>,
        pub(crate) box_configuration: std::option::Option<crate::model::BoxConfiguration>,
        pub(crate) quip_configuration: std::option::Option<crate::model::QuipConfiguration>,
        pub(crate) jira_configuration: std::option::Option<crate::model::JiraConfiguration>,
        pub(crate) git_hub_configuration: std::option::Option<crate::model::GitHubConfiguration>,
        pub(crate) alfresco_configuration: std::option::Option<crate::model::AlfrescoConfiguration>,
        pub(crate) template_configuration: std::option::Option<crate::model::TemplateConfiguration>,
    }
    impl Builder {
        /// <p>Provides the configuration information to connect to an Amazon S3 bucket as your data source.</p>
        pub fn s3_configuration(mut self, input: crate::model::S3DataSourceConfiguration) -> Self {
            self.s3_configuration = Some(input);
            self
        }
        /// <p>Provides the configuration information to connect to an Amazon S3 bucket as your data source.</p>
        pub fn set_s3_configuration(
            mut self,
            input: std::option::Option<crate::model::S3DataSourceConfiguration>,
        ) -> Self {
            self.s3_configuration = input;
            self
        }
        /// <p>Provides the configuration information to connect to Microsoft SharePoint as your data source.</p>
        pub fn share_point_configuration(
            mut self,
            input: crate::model::SharePointConfiguration,
        ) -> Self {
            self.share_point_configuration = Some(input);
            self
        }
        /// <p>Provides the configuration information to connect to Microsoft SharePoint as your data source.</p>
        pub fn set_share_point_configuration(
            mut self,
            input: std::option::Option<crate::model::SharePointConfiguration>,
        ) -> Self {
            self.share_point_configuration = input;
            self
        }
        /// <p>Provides the configuration information to connect to a database as your data source.</p>
        pub fn database_configuration(
            mut self,
            input: crate::model::DatabaseConfiguration,
        ) -> Self {
            self.database_configuration = Some(input);
            self
        }
        /// <p>Provides the configuration information to connect to a database as your data source.</p>
        pub fn set_database_configuration(
            mut self,
            input: std::option::Option<crate::model::DatabaseConfiguration>,
        ) -> Self {
            self.database_configuration = input;
            self
        }
        /// <p>Provides the configuration information to connect to Salesforce as your data source.</p>
        pub fn salesforce_configuration(
            mut self,
            input: crate::model::SalesforceConfiguration,
        ) -> Self {
            self.salesforce_configuration = Some(input);
            self
        }
        /// <p>Provides the configuration information to connect to Salesforce as your data source.</p>
        pub fn set_salesforce_configuration(
            mut self,
            input: std::option::Option<crate::model::SalesforceConfiguration>,
        ) -> Self {
            self.salesforce_configuration = input;
            self
        }
        /// <p>Provides the configuration information to connect to Microsoft OneDrive as your data source.</p>
        pub fn one_drive_configuration(
            mut self,
            input: crate::model::OneDriveConfiguration,
        ) -> Self {
            self.one_drive_configuration = Some(input);
            self
        }
        /// <p>Provides the configuration information to connect to Microsoft OneDrive as your data source.</p>
        pub fn set_one_drive_configuration(
            mut self,
            input: std::option::Option<crate::model::OneDriveConfiguration>,
        ) -> Self {
            self.one_drive_configuration = input;
            self
        }
        /// <p>Provides the configuration information to connect to ServiceNow as your data source.</p>
        pub fn service_now_configuration(
            mut self,
            input: crate::model::ServiceNowConfiguration,
        ) -> Self {
            self.service_now_configuration = Some(input);
            self
        }
        /// <p>Provides the configuration information to connect to ServiceNow as your data source.</p>
        pub fn set_service_now_configuration(
            mut self,
            input: std::option::Option<crate::model::ServiceNowConfiguration>,
        ) -> Self {
            self.service_now_configuration = input;
            self
        }
        /// <p>Provides the configuration information to connect to Confluence as your data source.</p>
        pub fn confluence_configuration(
            mut self,
            input: crate::model::ConfluenceConfiguration,
        ) -> Self {
            self.confluence_configuration = Some(input);
            self
        }
        /// <p>Provides the configuration information to connect to Confluence as your data source.</p>
        pub fn set_confluence_configuration(
            mut self,
            input: std::option::Option<crate::model::ConfluenceConfiguration>,
        ) -> Self {
            self.confluence_configuration = input;
            self
        }
        /// <p>Provides the configuration information to connect to Google Drive as your data source.</p>
        pub fn google_drive_configuration(
            mut self,
            input: crate::model::GoogleDriveConfiguration,
        ) -> Self {
            self.google_drive_configuration = Some(input);
            self
        }
        /// <p>Provides the configuration information to connect to Google Drive as your data source.</p>
        pub fn set_google_drive_configuration(
            mut self,
            input: std::option::Option<crate::model::GoogleDriveConfiguration>,
        ) -> Self {
            self.google_drive_configuration = input;
            self
        }
        /// <p>Provides the configuration information required for Amazon Kendra Web Crawler.</p>
        pub fn web_crawler_configuration(
            mut self,
            input: crate::model::WebCrawlerConfiguration,
        ) -> Self {
            self.web_crawler_configuration = Some(input);
            self
        }
        /// <p>Provides the configuration information required for Amazon Kendra Web Crawler.</p>
        pub fn set_web_crawler_configuration(
            mut self,
            input: std::option::Option<crate::model::WebCrawlerConfiguration>,
        ) -> Self {
            self.web_crawler_configuration = input;
            self
        }
        /// <p>Provides the configuration information to connect to Amazon WorkDocs as your data source.</p>
        pub fn work_docs_configuration(
            mut self,
            input: crate::model::WorkDocsConfiguration,
        ) -> Self {
            self.work_docs_configuration = Some(input);
            self
        }
        /// <p>Provides the configuration information to connect to Amazon WorkDocs as your data source.</p>
        pub fn set_work_docs_configuration(
            mut self,
            input: std::option::Option<crate::model::WorkDocsConfiguration>,
        ) -> Self {
            self.work_docs_configuration = input;
            self
        }
        /// <p>Provides the configuration information to connect to Amazon FSx as your data source.</p>
        pub fn fsx_configuration(mut self, input: crate::model::FsxConfiguration) -> Self {
            self.fsx_configuration = Some(input);
            self
        }
        /// <p>Provides the configuration information to connect to Amazon FSx as your data source.</p>
        pub fn set_fsx_configuration(
            mut self,
            input: std::option::Option<crate::model::FsxConfiguration>,
        ) -> Self {
            self.fsx_configuration = input;
            self
        }
        /// <p>Provides the configuration information to connect to Slack as your data source.</p>
        pub fn slack_configuration(mut self, input: crate::model::SlackConfiguration) -> Self {
            self.slack_configuration = Some(input);
            self
        }
        /// <p>Provides the configuration information to connect to Slack as your data source.</p>
        pub fn set_slack_configuration(
            mut self,
            input: std::option::Option<crate::model::SlackConfiguration>,
        ) -> Self {
            self.slack_configuration = input;
            self
        }
        /// <p>Provides the configuration information to connect to Box as your data source.</p>
        pub fn box_configuration(mut self, input: crate::model::BoxConfiguration) -> Self {
            self.box_configuration = Some(input);
            self
        }
        /// <p>Provides the configuration information to connect to Box as your data source.</p>
        pub fn set_box_configuration(
            mut self,
            input: std::option::Option<crate::model::BoxConfiguration>,
        ) -> Self {
            self.box_configuration = input;
            self
        }
        /// <p>Provides the configuration information to connect to Quip as your data source.</p>
        pub fn quip_configuration(mut self, input: crate::model::QuipConfiguration) -> Self {
            self.quip_configuration = Some(input);
            self
        }
        /// <p>Provides the configuration information to connect to Quip as your data source.</p>
        pub fn set_quip_configuration(
            mut self,
            input: std::option::Option<crate::model::QuipConfiguration>,
        ) -> Self {
            self.quip_configuration = input;
            self
        }
        /// <p>Provides the configuration information to connect to Jira as your data source.</p>
        pub fn jira_configuration(mut self, input: crate::model::JiraConfiguration) -> Self {
            self.jira_configuration = Some(input);
            self
        }
        /// <p>Provides the configuration information to connect to Jira as your data source.</p>
        pub fn set_jira_configuration(
            mut self,
            input: std::option::Option<crate::model::JiraConfiguration>,
        ) -> Self {
            self.jira_configuration = input;
            self
        }
        /// <p>Provides the configuration information to connect to GitHub as your data source.</p>
        pub fn git_hub_configuration(mut self, input: crate::model::GitHubConfiguration) -> Self {
            self.git_hub_configuration = Some(input);
            self
        }
        /// <p>Provides the configuration information to connect to GitHub as your data source.</p>
        pub fn set_git_hub_configuration(
            mut self,
            input: std::option::Option<crate::model::GitHubConfiguration>,
        ) -> Self {
            self.git_hub_configuration = input;
            self
        }
        /// <p>Provides the configuration information to connect to Alfresco as your data source.</p>
        pub fn alfresco_configuration(
            mut self,
            input: crate::model::AlfrescoConfiguration,
        ) -> Self {
            self.alfresco_configuration = Some(input);
            self
        }
        /// <p>Provides the configuration information to connect to Alfresco as your data source.</p>
        pub fn set_alfresco_configuration(
            mut self,
            input: std::option::Option<crate::model::AlfrescoConfiguration>,
        ) -> Self {
            self.alfresco_configuration = input;
            self
        }
        /// <p>Provides a template for the configuration information to connect to your data source.</p>
        pub fn template_configuration(
            mut self,
            input: crate::model::TemplateConfiguration,
        ) -> Self {
            self.template_configuration = Some(input);
            self
        }
        /// <p>Provides a template for the configuration information to connect to your data source.</p>
        pub fn set_template_configuration(
            mut self,
            input: std::option::Option<crate::model::TemplateConfiguration>,
        ) -> Self {
            self.template_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSourceConfiguration`](crate::model::DataSourceConfiguration).
        pub fn build(self) -> crate::model::DataSourceConfiguration {
            crate::model::DataSourceConfiguration {
                s3_configuration: self.s3_configuration,
                share_point_configuration: self.share_point_configuration,
                database_configuration: self.database_configuration,
                salesforce_configuration: self.salesforce_configuration,
                one_drive_configuration: self.one_drive_configuration,
                service_now_configuration: self.service_now_configuration,
                confluence_configuration: self.confluence_configuration,
                google_drive_configuration: self.google_drive_configuration,
                web_crawler_configuration: self.web_crawler_configuration,
                work_docs_configuration: self.work_docs_configuration,
                fsx_configuration: self.fsx_configuration,
                slack_configuration: self.slack_configuration,
                box_configuration: self.box_configuration,
                quip_configuration: self.quip_configuration,
                jira_configuration: self.jira_configuration,
                git_hub_configuration: self.git_hub_configuration,
                alfresco_configuration: self.alfresco_configuration,
                template_configuration: self.template_configuration,
            }
        }
    }
}
impl DataSourceConfiguration {
    /// Creates a new builder-style object to manufacture [`DataSourceConfiguration`](crate::model::DataSourceConfiguration).
    pub fn builder() -> crate::model::data_source_configuration::Builder {
        crate::model::data_source_configuration::Builder::default()
    }
}

/// <p>Provides a template for the configuration information to connect to your data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TemplateConfiguration {
    /// <p>The template schema used for the data source, where templates schemas are supported.</p>
    /// <p>See <a href="https://docs.aws.amazon.com/kendra/latest/dg/ds-schemas.html">Data source template schemas</a>.</p>
    #[doc(hidden)]
    pub template: std::option::Option<aws_smithy_types::Document>,
}
impl TemplateConfiguration {
    /// <p>The template schema used for the data source, where templates schemas are supported.</p>
    /// <p>See <a href="https://docs.aws.amazon.com/kendra/latest/dg/ds-schemas.html">Data source template schemas</a>.</p>
    pub fn template(&self) -> std::option::Option<&aws_smithy_types::Document> {
        self.template.as_ref()
    }
}
/// See [`TemplateConfiguration`](crate::model::TemplateConfiguration).
pub mod template_configuration {

    /// A builder for [`TemplateConfiguration`](crate::model::TemplateConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) template: std::option::Option<aws_smithy_types::Document>,
    }
    impl Builder {
        /// <p>The template schema used for the data source, where templates schemas are supported.</p>
        /// <p>See <a href="https://docs.aws.amazon.com/kendra/latest/dg/ds-schemas.html">Data source template schemas</a>.</p>
        pub fn template(mut self, input: aws_smithy_types::Document) -> Self {
            self.template = Some(input);
            self
        }
        /// <p>The template schema used for the data source, where templates schemas are supported.</p>
        /// <p>See <a href="https://docs.aws.amazon.com/kendra/latest/dg/ds-schemas.html">Data source template schemas</a>.</p>
        pub fn set_template(
            mut self,
            input: std::option::Option<aws_smithy_types::Document>,
        ) -> Self {
            self.template = input;
            self
        }
        /// Consumes the builder and constructs a [`TemplateConfiguration`](crate::model::TemplateConfiguration).
        pub fn build(self) -> crate::model::TemplateConfiguration {
            crate::model::TemplateConfiguration {
                template: self.template,
            }
        }
    }
}
impl TemplateConfiguration {
    /// Creates a new builder-style object to manufacture [`TemplateConfiguration`](crate::model::TemplateConfiguration).
    pub fn builder() -> crate::model::template_configuration::Builder {
        crate::model::template_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information to connect to Alfresco as your data source.</p> <note>
/// <p>Alfresco data source connector is currently in preview mode. Basic authentication is currently supported. If you would like to use Alfresco connector in production, contact <a href="http://aws.amazon.com/contact-us/">Support</a>.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AlfrescoConfiguration {
    /// <p>The URL of the Alfresco site. For example, <i>https://hostname:8080</i>.</p>
    #[doc(hidden)]
    pub site_url: std::option::Option<std::string::String>,
    /// <p>The identifier of the Alfresco site. For example, <i>my-site</i>.</p>
    #[doc(hidden)]
    pub site_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs required to connect to your Alfresco data source. The secret must contain a JSON structure with the following keys:</p>
    /// <ul>
    /// <li> <p>username—The user name of the Alfresco account.</p> </li>
    /// <li> <p>password—The password of the Alfresco account.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub secret_arn: std::option::Option<std::string::String>,
    /// <p>The path to the SSL certificate stored in an Amazon S3 bucket. You use this to connect to Alfresco if you require a secure SSL connection.</p>
    /// <p>You can simply generate a self-signed X509 certificate on any computer using OpenSSL. For an example of using OpenSSL to create an X509 certificate, see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/configuring-https-ssl.html">Create and sign an X509 certificate</a>.</p>
    #[doc(hidden)]
    pub ssl_certificate_s3_path: std::option::Option<crate::model::S3Path>,
    /// <p> <code>TRUE</code> to index shared files.</p>
    #[doc(hidden)]
    pub crawl_system_folders: bool,
    /// <p> <code>TRUE</code> to index comments of blogs and other content.</p>
    #[doc(hidden)]
    pub crawl_comments: bool,
    /// <p>Specify whether to index document libraries, wikis, or blogs. You can specify one or more of these options.</p>
    #[doc(hidden)]
    pub entity_filter: std::option::Option<std::vec::Vec<crate::model::AlfrescoEntity>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Alfresco document libraries to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Alfresco fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Alfresco data source field names must exist in your Alfresco custom metadata.</p>
    #[doc(hidden)]
    pub document_library_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Alfresco blogs to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Alfresco fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Alfresco data source field names must exist in your Alfresco custom metadata.</p>
    #[doc(hidden)]
    pub blog_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Alfresco wikis to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Alfresco fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Alfresco data source field names must exist in your Alfresco custom metadata.</p>
    #[doc(hidden)]
    pub wiki_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>A list of regular expression patterns to include certain files in your Alfresco data source. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    #[doc(hidden)]
    pub inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of regular expression patterns to exclude certain files in your Alfresco data source. Files that match the patterns are excluded from the index. Files that don't match the patterns are included in the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    #[doc(hidden)]
    pub exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Configuration information for an Amazon Virtual Private Cloud to connect to your Alfresco. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
    #[doc(hidden)]
    pub vpc_configuration: std::option::Option<crate::model::DataSourceVpcConfiguration>,
}
impl AlfrescoConfiguration {
    /// <p>The URL of the Alfresco site. For example, <i>https://hostname:8080</i>.</p>
    pub fn site_url(&self) -> std::option::Option<&str> {
        self.site_url.as_deref()
    }
    /// <p>The identifier of the Alfresco site. For example, <i>my-site</i>.</p>
    pub fn site_id(&self) -> std::option::Option<&str> {
        self.site_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs required to connect to your Alfresco data source. The secret must contain a JSON structure with the following keys:</p>
    /// <ul>
    /// <li> <p>username—The user name of the Alfresco account.</p> </li>
    /// <li> <p>password—The password of the Alfresco account.</p> </li>
    /// </ul>
    pub fn secret_arn(&self) -> std::option::Option<&str> {
        self.secret_arn.as_deref()
    }
    /// <p>The path to the SSL certificate stored in an Amazon S3 bucket. You use this to connect to Alfresco if you require a secure SSL connection.</p>
    /// <p>You can simply generate a self-signed X509 certificate on any computer using OpenSSL. For an example of using OpenSSL to create an X509 certificate, see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/configuring-https-ssl.html">Create and sign an X509 certificate</a>.</p>
    pub fn ssl_certificate_s3_path(&self) -> std::option::Option<&crate::model::S3Path> {
        self.ssl_certificate_s3_path.as_ref()
    }
    /// <p> <code>TRUE</code> to index shared files.</p>
    pub fn crawl_system_folders(&self) -> bool {
        self.crawl_system_folders
    }
    /// <p> <code>TRUE</code> to index comments of blogs and other content.</p>
    pub fn crawl_comments(&self) -> bool {
        self.crawl_comments
    }
    /// <p>Specify whether to index document libraries, wikis, or blogs. You can specify one or more of these options.</p>
    pub fn entity_filter(&self) -> std::option::Option<&[crate::model::AlfrescoEntity]> {
        self.entity_filter.as_deref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Alfresco document libraries to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Alfresco fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Alfresco data source field names must exist in your Alfresco custom metadata.</p>
    pub fn document_library_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.document_library_field_mappings.as_deref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Alfresco blogs to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Alfresco fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Alfresco data source field names must exist in your Alfresco custom metadata.</p>
    pub fn blog_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.blog_field_mappings.as_deref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Alfresco wikis to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Alfresco fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Alfresco data source field names must exist in your Alfresco custom metadata.</p>
    pub fn wiki_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.wiki_field_mappings.as_deref()
    }
    /// <p>A list of regular expression patterns to include certain files in your Alfresco data source. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    pub fn inclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.inclusion_patterns.as_deref()
    }
    /// <p>A list of regular expression patterns to exclude certain files in your Alfresco data source. Files that match the patterns are excluded from the index. Files that don't match the patterns are included in the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    pub fn exclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.exclusion_patterns.as_deref()
    }
    /// <p>Configuration information for an Amazon Virtual Private Cloud to connect to your Alfresco. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
    pub fn vpc_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DataSourceVpcConfiguration> {
        self.vpc_configuration.as_ref()
    }
}
/// See [`AlfrescoConfiguration`](crate::model::AlfrescoConfiguration).
pub mod alfresco_configuration {

    /// A builder for [`AlfrescoConfiguration`](crate::model::AlfrescoConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) site_url: std::option::Option<std::string::String>,
        pub(crate) site_id: std::option::Option<std::string::String>,
        pub(crate) secret_arn: std::option::Option<std::string::String>,
        pub(crate) ssl_certificate_s3_path: std::option::Option<crate::model::S3Path>,
        pub(crate) crawl_system_folders: std::option::Option<bool>,
        pub(crate) crawl_comments: std::option::Option<bool>,
        pub(crate) entity_filter: std::option::Option<std::vec::Vec<crate::model::AlfrescoEntity>>,
        pub(crate) document_library_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) blog_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) wiki_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) vpc_configuration: std::option::Option<crate::model::DataSourceVpcConfiguration>,
    }
    impl Builder {
        /// <p>The URL of the Alfresco site. For example, <i>https://hostname:8080</i>.</p>
        pub fn site_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_url = Some(input.into());
            self
        }
        /// <p>The URL of the Alfresco site. For example, <i>https://hostname:8080</i>.</p>
        pub fn set_site_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.site_url = input;
            self
        }
        /// <p>The identifier of the Alfresco site. For example, <i>my-site</i>.</p>
        pub fn site_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Alfresco site. For example, <i>my-site</i>.</p>
        pub fn set_site_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.site_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs required to connect to your Alfresco data source. The secret must contain a JSON structure with the following keys:</p>
        /// <ul>
        /// <li> <p>username—The user name of the Alfresco account.</p> </li>
        /// <li> <p>password—The password of the Alfresco account.</p> </li>
        /// </ul>
        pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs required to connect to your Alfresco data source. The secret must contain a JSON structure with the following keys:</p>
        /// <ul>
        /// <li> <p>username—The user name of the Alfresco account.</p> </li>
        /// <li> <p>password—The password of the Alfresco account.</p> </li>
        /// </ul>
        pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_arn = input;
            self
        }
        /// <p>The path to the SSL certificate stored in an Amazon S3 bucket. You use this to connect to Alfresco if you require a secure SSL connection.</p>
        /// <p>You can simply generate a self-signed X509 certificate on any computer using OpenSSL. For an example of using OpenSSL to create an X509 certificate, see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/configuring-https-ssl.html">Create and sign an X509 certificate</a>.</p>
        pub fn ssl_certificate_s3_path(mut self, input: crate::model::S3Path) -> Self {
            self.ssl_certificate_s3_path = Some(input);
            self
        }
        /// <p>The path to the SSL certificate stored in an Amazon S3 bucket. You use this to connect to Alfresco if you require a secure SSL connection.</p>
        /// <p>You can simply generate a self-signed X509 certificate on any computer using OpenSSL. For an example of using OpenSSL to create an X509 certificate, see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/configuring-https-ssl.html">Create and sign an X509 certificate</a>.</p>
        pub fn set_ssl_certificate_s3_path(
            mut self,
            input: std::option::Option<crate::model::S3Path>,
        ) -> Self {
            self.ssl_certificate_s3_path = input;
            self
        }
        /// <p> <code>TRUE</code> to index shared files.</p>
        pub fn crawl_system_folders(mut self, input: bool) -> Self {
            self.crawl_system_folders = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to index shared files.</p>
        pub fn set_crawl_system_folders(mut self, input: std::option::Option<bool>) -> Self {
            self.crawl_system_folders = input;
            self
        }
        /// <p> <code>TRUE</code> to index comments of blogs and other content.</p>
        pub fn crawl_comments(mut self, input: bool) -> Self {
            self.crawl_comments = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to index comments of blogs and other content.</p>
        pub fn set_crawl_comments(mut self, input: std::option::Option<bool>) -> Self {
            self.crawl_comments = input;
            self
        }
        /// Appends an item to `entity_filter`.
        ///
        /// To override the contents of this collection use [`set_entity_filter`](Self::set_entity_filter).
        ///
        /// <p>Specify whether to index document libraries, wikis, or blogs. You can specify one or more of these options.</p>
        pub fn entity_filter(mut self, input: crate::model::AlfrescoEntity) -> Self {
            let mut v = self.entity_filter.unwrap_or_default();
            v.push(input);
            self.entity_filter = Some(v);
            self
        }
        /// <p>Specify whether to index document libraries, wikis, or blogs. You can specify one or more of these options.</p>
        pub fn set_entity_filter(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AlfrescoEntity>>,
        ) -> Self {
            self.entity_filter = input;
            self
        }
        /// Appends an item to `document_library_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_document_library_field_mappings`](Self::set_document_library_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Alfresco document libraries to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Alfresco fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Alfresco data source field names must exist in your Alfresco custom metadata.</p>
        pub fn document_library_field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.document_library_field_mappings.unwrap_or_default();
            v.push(input);
            self.document_library_field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Alfresco document libraries to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Alfresco fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Alfresco data source field names must exist in your Alfresco custom metadata.</p>
        pub fn set_document_library_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.document_library_field_mappings = input;
            self
        }
        /// Appends an item to `blog_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_blog_field_mappings`](Self::set_blog_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Alfresco blogs to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Alfresco fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Alfresco data source field names must exist in your Alfresco custom metadata.</p>
        pub fn blog_field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.blog_field_mappings.unwrap_or_default();
            v.push(input);
            self.blog_field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Alfresco blogs to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Alfresco fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Alfresco data source field names must exist in your Alfresco custom metadata.</p>
        pub fn set_blog_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.blog_field_mappings = input;
            self
        }
        /// Appends an item to `wiki_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_wiki_field_mappings`](Self::set_wiki_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Alfresco wikis to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Alfresco fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Alfresco data source field names must exist in your Alfresco custom metadata.</p>
        pub fn wiki_field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.wiki_field_mappings.unwrap_or_default();
            v.push(input);
            self.wiki_field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Alfresco wikis to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Alfresco fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Alfresco data source field names must exist in your Alfresco custom metadata.</p>
        pub fn set_wiki_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.wiki_field_mappings = input;
            self
        }
        /// Appends an item to `inclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_inclusion_patterns`](Self::set_inclusion_patterns).
        ///
        /// <p>A list of regular expression patterns to include certain files in your Alfresco data source. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn inclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.inclusion_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to include certain files in your Alfresco data source. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn set_inclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inclusion_patterns = input;
            self
        }
        /// Appends an item to `exclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_exclusion_patterns`](Self::set_exclusion_patterns).
        ///
        /// <p>A list of regular expression patterns to exclude certain files in your Alfresco data source. Files that match the patterns are excluded from the index. Files that don't match the patterns are included in the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn exclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.exclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.exclusion_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to exclude certain files in your Alfresco data source. Files that match the patterns are excluded from the index. Files that don't match the patterns are included in the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn set_exclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclusion_patterns = input;
            self
        }
        /// <p>Configuration information for an Amazon Virtual Private Cloud to connect to your Alfresco. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
        pub fn vpc_configuration(
            mut self,
            input: crate::model::DataSourceVpcConfiguration,
        ) -> Self {
            self.vpc_configuration = Some(input);
            self
        }
        /// <p>Configuration information for an Amazon Virtual Private Cloud to connect to your Alfresco. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
        pub fn set_vpc_configuration(
            mut self,
            input: std::option::Option<crate::model::DataSourceVpcConfiguration>,
        ) -> Self {
            self.vpc_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`AlfrescoConfiguration`](crate::model::AlfrescoConfiguration).
        pub fn build(self) -> crate::model::AlfrescoConfiguration {
            crate::model::AlfrescoConfiguration {
                site_url: self.site_url,
                site_id: self.site_id,
                secret_arn: self.secret_arn,
                ssl_certificate_s3_path: self.ssl_certificate_s3_path,
                crawl_system_folders: self.crawl_system_folders.unwrap_or_default(),
                crawl_comments: self.crawl_comments.unwrap_or_default(),
                entity_filter: self.entity_filter,
                document_library_field_mappings: self.document_library_field_mappings,
                blog_field_mappings: self.blog_field_mappings,
                wiki_field_mappings: self.wiki_field_mappings,
                inclusion_patterns: self.inclusion_patterns,
                exclusion_patterns: self.exclusion_patterns,
                vpc_configuration: self.vpc_configuration,
            }
        }
    }
}
impl AlfrescoConfiguration {
    /// Creates a new builder-style object to manufacture [`AlfrescoConfiguration`](crate::model::AlfrescoConfiguration).
    pub fn builder() -> crate::model::alfresco_configuration::Builder {
        crate::model::alfresco_configuration::Builder::default()
    }
}

/// <p>Maps a column or attribute in the data source to an index field. You must first create the fields in the index using the <code>UpdateIndex</code> API.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSourceToIndexFieldMapping {
    /// <p>The name of the column or attribute in the data source.</p>
    #[doc(hidden)]
    pub data_source_field_name: std::option::Option<std::string::String>,
    /// <p>The type of data stored in the column or attribute.</p>
    #[doc(hidden)]
    pub date_field_format: std::option::Option<std::string::String>,
    /// <p>The name of the field in the index.</p>
    #[doc(hidden)]
    pub index_field_name: std::option::Option<std::string::String>,
}
impl DataSourceToIndexFieldMapping {
    /// <p>The name of the column or attribute in the data source.</p>
    pub fn data_source_field_name(&self) -> std::option::Option<&str> {
        self.data_source_field_name.as_deref()
    }
    /// <p>The type of data stored in the column or attribute.</p>
    pub fn date_field_format(&self) -> std::option::Option<&str> {
        self.date_field_format.as_deref()
    }
    /// <p>The name of the field in the index.</p>
    pub fn index_field_name(&self) -> std::option::Option<&str> {
        self.index_field_name.as_deref()
    }
}
/// See [`DataSourceToIndexFieldMapping`](crate::model::DataSourceToIndexFieldMapping).
pub mod data_source_to_index_field_mapping {

    /// A builder for [`DataSourceToIndexFieldMapping`](crate::model::DataSourceToIndexFieldMapping).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_source_field_name: std::option::Option<std::string::String>,
        pub(crate) date_field_format: std::option::Option<std::string::String>,
        pub(crate) index_field_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the column or attribute in the data source.</p>
        pub fn data_source_field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_source_field_name = Some(input.into());
            self
        }
        /// <p>The name of the column or attribute in the data source.</p>
        pub fn set_data_source_field_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_source_field_name = input;
            self
        }
        /// <p>The type of data stored in the column or attribute.</p>
        pub fn date_field_format(mut self, input: impl Into<std::string::String>) -> Self {
            self.date_field_format = Some(input.into());
            self
        }
        /// <p>The type of data stored in the column or attribute.</p>
        pub fn set_date_field_format(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.date_field_format = input;
            self
        }
        /// <p>The name of the field in the index.</p>
        pub fn index_field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.index_field_name = Some(input.into());
            self
        }
        /// <p>The name of the field in the index.</p>
        pub fn set_index_field_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.index_field_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSourceToIndexFieldMapping`](crate::model::DataSourceToIndexFieldMapping).
        pub fn build(self) -> crate::model::DataSourceToIndexFieldMapping {
            crate::model::DataSourceToIndexFieldMapping {
                data_source_field_name: self.data_source_field_name,
                date_field_format: self.date_field_format,
                index_field_name: self.index_field_name,
            }
        }
    }
}
impl DataSourceToIndexFieldMapping {
    /// Creates a new builder-style object to manufacture [`DataSourceToIndexFieldMapping`](crate::model::DataSourceToIndexFieldMapping).
    pub fn builder() -> crate::model::data_source_to_index_field_mapping::Builder {
        crate::model::data_source_to_index_field_mapping::Builder::default()
    }
}

/// When writing a match expression against `AlfrescoEntity`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let alfrescoentity = unimplemented!();
/// match alfrescoentity {
///     AlfrescoEntity::Blog => { /* ... */ },
///     AlfrescoEntity::DocumentLibrary => { /* ... */ },
///     AlfrescoEntity::Wiki => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `alfrescoentity` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AlfrescoEntity::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AlfrescoEntity::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AlfrescoEntity::NewFeature` is defined.
/// Specifically, when `alfrescoentity` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AlfrescoEntity::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AlfrescoEntity {
    #[allow(missing_docs)] // documentation missing in model
    Blog,
    #[allow(missing_docs)] // documentation missing in model
    DocumentLibrary,
    #[allow(missing_docs)] // documentation missing in model
    Wiki,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AlfrescoEntity {
    fn from(s: &str) -> Self {
        match s {
            "blog" => AlfrescoEntity::Blog,
            "documentLibrary" => AlfrescoEntity::DocumentLibrary,
            "wiki" => AlfrescoEntity::Wiki,
            other => AlfrescoEntity::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AlfrescoEntity {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AlfrescoEntity::from(s))
    }
}
impl AlfrescoEntity {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AlfrescoEntity::Blog => "blog",
            AlfrescoEntity::DocumentLibrary => "documentLibrary",
            AlfrescoEntity::Wiki => "wiki",
            AlfrescoEntity::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["blog", "documentLibrary", "wiki"]
    }
}
impl AsRef<str> for AlfrescoEntity {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides the configuration information to connect to GitHub as your data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GitHubConfiguration {
    /// <p>Configuration information to connect to GitHub Enterprise Cloud (SaaS).</p>
    #[doc(hidden)]
    pub saa_s_configuration: std::option::Option<crate::model::SaaSConfiguration>,
    /// <p>Configuration information to connect to GitHub Enterprise Server (on premises).</p>
    #[doc(hidden)]
    pub on_premise_configuration: std::option::Option<crate::model::OnPremiseConfiguration>,
    /// <p>The type of GitHub service you want to connect to—GitHub Enterprise Cloud (SaaS) or GitHub Enterprise Server (on premises).</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::Type>,
    /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs required to connect to your GitHub. The secret must contain a JSON structure with the following keys:</p>
    /// <ul>
    /// <li> <p>personalToken—The access token created in GitHub. For more information on creating a token in GitHub, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-github.html">Using a GitHub data source</a>.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub secret_arn: std::option::Option<std::string::String>,
    /// <p> <code>TRUE</code> to use the GitHub change log to determine which documents require updating in the index. Depending on the GitHub change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents in GitHub.</p>
    #[doc(hidden)]
    pub use_change_log: bool,
    /// <p>Configuration information to include certain types of GitHub content. You can configure to index repository files only, or also include issues and pull requests, comments, and comment attachments.</p>
    #[doc(hidden)]
    pub git_hub_document_crawl_properties:
        std::option::Option<crate::model::GitHubDocumentCrawlProperties>,
    /// <p>A list of names of the specific repositories you want to index.</p>
    #[doc(hidden)]
    pub repository_filter: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of regular expression patterns to include certain folder names in your GitHub repository or repositories. Folder names that match the patterns are included in the index. Folder names that don't match the patterns are excluded from the index. If a folder matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the folder isn't included in the index.</p>
    #[doc(hidden)]
    pub inclusion_folder_name_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of regular expression patterns to include certain file types in your GitHub repository or repositories. File types that match the patterns are included in the index. File types that don't match the patterns are excluded from the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    #[doc(hidden)]
    pub inclusion_file_type_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of regular expression patterns to include certain file names in your GitHub repository or repositories. File names that match the patterns are included in the index. File names that don't match the patterns are excluded from the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    #[doc(hidden)]
    pub inclusion_file_name_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of regular expression patterns to exclude certain folder names in your GitHub repository or repositories. Folder names that match the patterns are excluded from the index. Folder names that don't match the patterns are included in the index. If a folder matches both an exclusion and inclusion pattern, the exclusion pattern takes precedence and the folder isn't included in the index.</p>
    #[doc(hidden)]
    pub exclusion_folder_name_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of regular expression patterns to exclude certain file types in your GitHub repository or repositories. File types that match the patterns are excluded from the index. File types that don't match the patterns are included in the index. If a file matches both an exclusion and inclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    #[doc(hidden)]
    pub exclusion_file_type_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of regular expression patterns to exclude certain file names in your GitHub repository or repositories. File names that match the patterns are excluded from the index. File names that don't match the patterns are included in the index. If a file matches both an exclusion and inclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    #[doc(hidden)]
    pub exclusion_file_name_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Configuration information of an Amazon Virtual Private Cloud to connect to your GitHub. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
    #[doc(hidden)]
    pub vpc_configuration: std::option::Option<crate::model::DataSourceVpcConfiguration>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map GitHub repository attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
    #[doc(hidden)]
    pub git_hub_repository_configuration_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub commits to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
    #[doc(hidden)]
    pub git_hub_commit_configuration_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub issues to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
    #[doc(hidden)]
    pub git_hub_issue_document_configuration_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub issue comments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
    #[doc(hidden)]
    pub git_hub_issue_comment_configuration_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub issue attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
    #[doc(hidden)]
    pub git_hub_issue_attachment_configuration_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub pull request comments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
    #[doc(hidden)]
    pub git_hub_pull_request_comment_configuration_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub pull requests to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
    #[doc(hidden)]
    pub git_hub_pull_request_document_configuration_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub pull request attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
    #[doc(hidden)]
    pub git_hub_pull_request_document_attachment_configuration_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
}
impl GitHubConfiguration {
    /// <p>Configuration information to connect to GitHub Enterprise Cloud (SaaS).</p>
    pub fn saa_s_configuration(&self) -> std::option::Option<&crate::model::SaaSConfiguration> {
        self.saa_s_configuration.as_ref()
    }
    /// <p>Configuration information to connect to GitHub Enterprise Server (on premises).</p>
    pub fn on_premise_configuration(
        &self,
    ) -> std::option::Option<&crate::model::OnPremiseConfiguration> {
        self.on_premise_configuration.as_ref()
    }
    /// <p>The type of GitHub service you want to connect to—GitHub Enterprise Cloud (SaaS) or GitHub Enterprise Server (on premises).</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::Type> {
        self.r#type.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs required to connect to your GitHub. The secret must contain a JSON structure with the following keys:</p>
    /// <ul>
    /// <li> <p>personalToken—The access token created in GitHub. For more information on creating a token in GitHub, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-github.html">Using a GitHub data source</a>.</p> </li>
    /// </ul>
    pub fn secret_arn(&self) -> std::option::Option<&str> {
        self.secret_arn.as_deref()
    }
    /// <p> <code>TRUE</code> to use the GitHub change log to determine which documents require updating in the index. Depending on the GitHub change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents in GitHub.</p>
    pub fn use_change_log(&self) -> bool {
        self.use_change_log
    }
    /// <p>Configuration information to include certain types of GitHub content. You can configure to index repository files only, or also include issues and pull requests, comments, and comment attachments.</p>
    pub fn git_hub_document_crawl_properties(
        &self,
    ) -> std::option::Option<&crate::model::GitHubDocumentCrawlProperties> {
        self.git_hub_document_crawl_properties.as_ref()
    }
    /// <p>A list of names of the specific repositories you want to index.</p>
    pub fn repository_filter(&self) -> std::option::Option<&[std::string::String]> {
        self.repository_filter.as_deref()
    }
    /// <p>A list of regular expression patterns to include certain folder names in your GitHub repository or repositories. Folder names that match the patterns are included in the index. Folder names that don't match the patterns are excluded from the index. If a folder matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the folder isn't included in the index.</p>
    pub fn inclusion_folder_name_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.inclusion_folder_name_patterns.as_deref()
    }
    /// <p>A list of regular expression patterns to include certain file types in your GitHub repository or repositories. File types that match the patterns are included in the index. File types that don't match the patterns are excluded from the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    pub fn inclusion_file_type_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.inclusion_file_type_patterns.as_deref()
    }
    /// <p>A list of regular expression patterns to include certain file names in your GitHub repository or repositories. File names that match the patterns are included in the index. File names that don't match the patterns are excluded from the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    pub fn inclusion_file_name_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.inclusion_file_name_patterns.as_deref()
    }
    /// <p>A list of regular expression patterns to exclude certain folder names in your GitHub repository or repositories. Folder names that match the patterns are excluded from the index. Folder names that don't match the patterns are included in the index. If a folder matches both an exclusion and inclusion pattern, the exclusion pattern takes precedence and the folder isn't included in the index.</p>
    pub fn exclusion_folder_name_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.exclusion_folder_name_patterns.as_deref()
    }
    /// <p>A list of regular expression patterns to exclude certain file types in your GitHub repository or repositories. File types that match the patterns are excluded from the index. File types that don't match the patterns are included in the index. If a file matches both an exclusion and inclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    pub fn exclusion_file_type_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.exclusion_file_type_patterns.as_deref()
    }
    /// <p>A list of regular expression patterns to exclude certain file names in your GitHub repository or repositories. File names that match the patterns are excluded from the index. File names that don't match the patterns are included in the index. If a file matches both an exclusion and inclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    pub fn exclusion_file_name_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.exclusion_file_name_patterns.as_deref()
    }
    /// <p>Configuration information of an Amazon Virtual Private Cloud to connect to your GitHub. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
    pub fn vpc_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DataSourceVpcConfiguration> {
        self.vpc_configuration.as_ref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map GitHub repository attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
    pub fn git_hub_repository_configuration_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.git_hub_repository_configuration_field_mappings
            .as_deref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub commits to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
    pub fn git_hub_commit_configuration_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.git_hub_commit_configuration_field_mappings.as_deref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub issues to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
    pub fn git_hub_issue_document_configuration_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.git_hub_issue_document_configuration_field_mappings
            .as_deref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub issue comments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
    pub fn git_hub_issue_comment_configuration_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.git_hub_issue_comment_configuration_field_mappings
            .as_deref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub issue attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
    pub fn git_hub_issue_attachment_configuration_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.git_hub_issue_attachment_configuration_field_mappings
            .as_deref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub pull request comments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
    pub fn git_hub_pull_request_comment_configuration_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.git_hub_pull_request_comment_configuration_field_mappings
            .as_deref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub pull requests to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
    pub fn git_hub_pull_request_document_configuration_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.git_hub_pull_request_document_configuration_field_mappings
            .as_deref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub pull request attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
    pub fn git_hub_pull_request_document_attachment_configuration_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.git_hub_pull_request_document_attachment_configuration_field_mappings
            .as_deref()
    }
}
/// See [`GitHubConfiguration`](crate::model::GitHubConfiguration).
pub mod git_hub_configuration {

    /// A builder for [`GitHubConfiguration`](crate::model::GitHubConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) saa_s_configuration: std::option::Option<crate::model::SaaSConfiguration>,
        pub(crate) on_premise_configuration:
            std::option::Option<crate::model::OnPremiseConfiguration>,
        pub(crate) r#type: std::option::Option<crate::model::Type>,
        pub(crate) secret_arn: std::option::Option<std::string::String>,
        pub(crate) use_change_log: std::option::Option<bool>,
        pub(crate) git_hub_document_crawl_properties:
            std::option::Option<crate::model::GitHubDocumentCrawlProperties>,
        pub(crate) repository_filter: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) inclusion_folder_name_patterns:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) inclusion_file_type_patterns:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) inclusion_file_name_patterns:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) exclusion_folder_name_patterns:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) exclusion_file_type_patterns:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) exclusion_file_name_patterns:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) vpc_configuration: std::option::Option<crate::model::DataSourceVpcConfiguration>,
        pub(crate) git_hub_repository_configuration_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) git_hub_commit_configuration_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) git_hub_issue_document_configuration_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) git_hub_issue_comment_configuration_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) git_hub_issue_attachment_configuration_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) git_hub_pull_request_comment_configuration_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) git_hub_pull_request_document_configuration_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) git_hub_pull_request_document_attachment_configuration_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    }
    impl Builder {
        /// <p>Configuration information to connect to GitHub Enterprise Cloud (SaaS).</p>
        pub fn saa_s_configuration(mut self, input: crate::model::SaaSConfiguration) -> Self {
            self.saa_s_configuration = Some(input);
            self
        }
        /// <p>Configuration information to connect to GitHub Enterprise Cloud (SaaS).</p>
        pub fn set_saa_s_configuration(
            mut self,
            input: std::option::Option<crate::model::SaaSConfiguration>,
        ) -> Self {
            self.saa_s_configuration = input;
            self
        }
        /// <p>Configuration information to connect to GitHub Enterprise Server (on premises).</p>
        pub fn on_premise_configuration(
            mut self,
            input: crate::model::OnPremiseConfiguration,
        ) -> Self {
            self.on_premise_configuration = Some(input);
            self
        }
        /// <p>Configuration information to connect to GitHub Enterprise Server (on premises).</p>
        pub fn set_on_premise_configuration(
            mut self,
            input: std::option::Option<crate::model::OnPremiseConfiguration>,
        ) -> Self {
            self.on_premise_configuration = input;
            self
        }
        /// <p>The type of GitHub service you want to connect to—GitHub Enterprise Cloud (SaaS) or GitHub Enterprise Server (on premises).</p>
        pub fn r#type(mut self, input: crate::model::Type) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of GitHub service you want to connect to—GitHub Enterprise Cloud (SaaS) or GitHub Enterprise Server (on premises).</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::Type>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs required to connect to your GitHub. The secret must contain a JSON structure with the following keys:</p>
        /// <ul>
        /// <li> <p>personalToken—The access token created in GitHub. For more information on creating a token in GitHub, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-github.html">Using a GitHub data source</a>.</p> </li>
        /// </ul>
        pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs required to connect to your GitHub. The secret must contain a JSON structure with the following keys:</p>
        /// <ul>
        /// <li> <p>personalToken—The access token created in GitHub. For more information on creating a token in GitHub, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-github.html">Using a GitHub data source</a>.</p> </li>
        /// </ul>
        pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_arn = input;
            self
        }
        /// <p> <code>TRUE</code> to use the GitHub change log to determine which documents require updating in the index. Depending on the GitHub change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents in GitHub.</p>
        pub fn use_change_log(mut self, input: bool) -> Self {
            self.use_change_log = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to use the GitHub change log to determine which documents require updating in the index. Depending on the GitHub change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents in GitHub.</p>
        pub fn set_use_change_log(mut self, input: std::option::Option<bool>) -> Self {
            self.use_change_log = input;
            self
        }
        /// <p>Configuration information to include certain types of GitHub content. You can configure to index repository files only, or also include issues and pull requests, comments, and comment attachments.</p>
        pub fn git_hub_document_crawl_properties(
            mut self,
            input: crate::model::GitHubDocumentCrawlProperties,
        ) -> Self {
            self.git_hub_document_crawl_properties = Some(input);
            self
        }
        /// <p>Configuration information to include certain types of GitHub content. You can configure to index repository files only, or also include issues and pull requests, comments, and comment attachments.</p>
        pub fn set_git_hub_document_crawl_properties(
            mut self,
            input: std::option::Option<crate::model::GitHubDocumentCrawlProperties>,
        ) -> Self {
            self.git_hub_document_crawl_properties = input;
            self
        }
        /// Appends an item to `repository_filter`.
        ///
        /// To override the contents of this collection use [`set_repository_filter`](Self::set_repository_filter).
        ///
        /// <p>A list of names of the specific repositories you want to index.</p>
        pub fn repository_filter(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.repository_filter.unwrap_or_default();
            v.push(input.into());
            self.repository_filter = Some(v);
            self
        }
        /// <p>A list of names of the specific repositories you want to index.</p>
        pub fn set_repository_filter(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.repository_filter = input;
            self
        }
        /// Appends an item to `inclusion_folder_name_patterns`.
        ///
        /// To override the contents of this collection use [`set_inclusion_folder_name_patterns`](Self::set_inclusion_folder_name_patterns).
        ///
        /// <p>A list of regular expression patterns to include certain folder names in your GitHub repository or repositories. Folder names that match the patterns are included in the index. Folder names that don't match the patterns are excluded from the index. If a folder matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the folder isn't included in the index.</p>
        pub fn inclusion_folder_name_patterns(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.inclusion_folder_name_patterns.unwrap_or_default();
            v.push(input.into());
            self.inclusion_folder_name_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to include certain folder names in your GitHub repository or repositories. Folder names that match the patterns are included in the index. Folder names that don't match the patterns are excluded from the index. If a folder matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the folder isn't included in the index.</p>
        pub fn set_inclusion_folder_name_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inclusion_folder_name_patterns = input;
            self
        }
        /// Appends an item to `inclusion_file_type_patterns`.
        ///
        /// To override the contents of this collection use [`set_inclusion_file_type_patterns`](Self::set_inclusion_file_type_patterns).
        ///
        /// <p>A list of regular expression patterns to include certain file types in your GitHub repository or repositories. File types that match the patterns are included in the index. File types that don't match the patterns are excluded from the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn inclusion_file_type_patterns(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.inclusion_file_type_patterns.unwrap_or_default();
            v.push(input.into());
            self.inclusion_file_type_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to include certain file types in your GitHub repository or repositories. File types that match the patterns are included in the index. File types that don't match the patterns are excluded from the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn set_inclusion_file_type_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inclusion_file_type_patterns = input;
            self
        }
        /// Appends an item to `inclusion_file_name_patterns`.
        ///
        /// To override the contents of this collection use [`set_inclusion_file_name_patterns`](Self::set_inclusion_file_name_patterns).
        ///
        /// <p>A list of regular expression patterns to include certain file names in your GitHub repository or repositories. File names that match the patterns are included in the index. File names that don't match the patterns are excluded from the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn inclusion_file_name_patterns(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.inclusion_file_name_patterns.unwrap_or_default();
            v.push(input.into());
            self.inclusion_file_name_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to include certain file names in your GitHub repository or repositories. File names that match the patterns are included in the index. File names that don't match the patterns are excluded from the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn set_inclusion_file_name_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inclusion_file_name_patterns = input;
            self
        }
        /// Appends an item to `exclusion_folder_name_patterns`.
        ///
        /// To override the contents of this collection use [`set_exclusion_folder_name_patterns`](Self::set_exclusion_folder_name_patterns).
        ///
        /// <p>A list of regular expression patterns to exclude certain folder names in your GitHub repository or repositories. Folder names that match the patterns are excluded from the index. Folder names that don't match the patterns are included in the index. If a folder matches both an exclusion and inclusion pattern, the exclusion pattern takes precedence and the folder isn't included in the index.</p>
        pub fn exclusion_folder_name_patterns(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.exclusion_folder_name_patterns.unwrap_or_default();
            v.push(input.into());
            self.exclusion_folder_name_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to exclude certain folder names in your GitHub repository or repositories. Folder names that match the patterns are excluded from the index. Folder names that don't match the patterns are included in the index. If a folder matches both an exclusion and inclusion pattern, the exclusion pattern takes precedence and the folder isn't included in the index.</p>
        pub fn set_exclusion_folder_name_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclusion_folder_name_patterns = input;
            self
        }
        /// Appends an item to `exclusion_file_type_patterns`.
        ///
        /// To override the contents of this collection use [`set_exclusion_file_type_patterns`](Self::set_exclusion_file_type_patterns).
        ///
        /// <p>A list of regular expression patterns to exclude certain file types in your GitHub repository or repositories. File types that match the patterns are excluded from the index. File types that don't match the patterns are included in the index. If a file matches both an exclusion and inclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn exclusion_file_type_patterns(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.exclusion_file_type_patterns.unwrap_or_default();
            v.push(input.into());
            self.exclusion_file_type_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to exclude certain file types in your GitHub repository or repositories. File types that match the patterns are excluded from the index. File types that don't match the patterns are included in the index. If a file matches both an exclusion and inclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn set_exclusion_file_type_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclusion_file_type_patterns = input;
            self
        }
        /// Appends an item to `exclusion_file_name_patterns`.
        ///
        /// To override the contents of this collection use [`set_exclusion_file_name_patterns`](Self::set_exclusion_file_name_patterns).
        ///
        /// <p>A list of regular expression patterns to exclude certain file names in your GitHub repository or repositories. File names that match the patterns are excluded from the index. File names that don't match the patterns are included in the index. If a file matches both an exclusion and inclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn exclusion_file_name_patterns(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.exclusion_file_name_patterns.unwrap_or_default();
            v.push(input.into());
            self.exclusion_file_name_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to exclude certain file names in your GitHub repository or repositories. File names that match the patterns are excluded from the index. File names that don't match the patterns are included in the index. If a file matches both an exclusion and inclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn set_exclusion_file_name_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclusion_file_name_patterns = input;
            self
        }
        /// <p>Configuration information of an Amazon Virtual Private Cloud to connect to your GitHub. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
        pub fn vpc_configuration(
            mut self,
            input: crate::model::DataSourceVpcConfiguration,
        ) -> Self {
            self.vpc_configuration = Some(input);
            self
        }
        /// <p>Configuration information of an Amazon Virtual Private Cloud to connect to your GitHub. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
        pub fn set_vpc_configuration(
            mut self,
            input: std::option::Option<crate::model::DataSourceVpcConfiguration>,
        ) -> Self {
            self.vpc_configuration = input;
            self
        }
        /// Appends an item to `git_hub_repository_configuration_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_git_hub_repository_configuration_field_mappings`](Self::set_git_hub_repository_configuration_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map GitHub repository attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
        pub fn git_hub_repository_configuration_field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self
                .git_hub_repository_configuration_field_mappings
                .unwrap_or_default();
            v.push(input);
            self.git_hub_repository_configuration_field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map GitHub repository attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
        pub fn set_git_hub_repository_configuration_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.git_hub_repository_configuration_field_mappings = input;
            self
        }
        /// Appends an item to `git_hub_commit_configuration_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_git_hub_commit_configuration_field_mappings`](Self::set_git_hub_commit_configuration_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub commits to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
        pub fn git_hub_commit_configuration_field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self
                .git_hub_commit_configuration_field_mappings
                .unwrap_or_default();
            v.push(input);
            self.git_hub_commit_configuration_field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub commits to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
        pub fn set_git_hub_commit_configuration_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.git_hub_commit_configuration_field_mappings = input;
            self
        }
        /// Appends an item to `git_hub_issue_document_configuration_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_git_hub_issue_document_configuration_field_mappings`](Self::set_git_hub_issue_document_configuration_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub issues to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
        pub fn git_hub_issue_document_configuration_field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self
                .git_hub_issue_document_configuration_field_mappings
                .unwrap_or_default();
            v.push(input);
            self.git_hub_issue_document_configuration_field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub issues to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
        pub fn set_git_hub_issue_document_configuration_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.git_hub_issue_document_configuration_field_mappings = input;
            self
        }
        /// Appends an item to `git_hub_issue_comment_configuration_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_git_hub_issue_comment_configuration_field_mappings`](Self::set_git_hub_issue_comment_configuration_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub issue comments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
        pub fn git_hub_issue_comment_configuration_field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self
                .git_hub_issue_comment_configuration_field_mappings
                .unwrap_or_default();
            v.push(input);
            self.git_hub_issue_comment_configuration_field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub issue comments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
        pub fn set_git_hub_issue_comment_configuration_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.git_hub_issue_comment_configuration_field_mappings = input;
            self
        }
        /// Appends an item to `git_hub_issue_attachment_configuration_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_git_hub_issue_attachment_configuration_field_mappings`](Self::set_git_hub_issue_attachment_configuration_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub issue attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
        pub fn git_hub_issue_attachment_configuration_field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self
                .git_hub_issue_attachment_configuration_field_mappings
                .unwrap_or_default();
            v.push(input);
            self.git_hub_issue_attachment_configuration_field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub issue attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
        pub fn set_git_hub_issue_attachment_configuration_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.git_hub_issue_attachment_configuration_field_mappings = input;
            self
        }
        /// Appends an item to `git_hub_pull_request_comment_configuration_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_git_hub_pull_request_comment_configuration_field_mappings`](Self::set_git_hub_pull_request_comment_configuration_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub pull request comments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
        pub fn git_hub_pull_request_comment_configuration_field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self
                .git_hub_pull_request_comment_configuration_field_mappings
                .unwrap_or_default();
            v.push(input);
            self.git_hub_pull_request_comment_configuration_field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub pull request comments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
        pub fn set_git_hub_pull_request_comment_configuration_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.git_hub_pull_request_comment_configuration_field_mappings = input;
            self
        }
        /// Appends an item to `git_hub_pull_request_document_configuration_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_git_hub_pull_request_document_configuration_field_mappings`](Self::set_git_hub_pull_request_document_configuration_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub pull requests to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
        pub fn git_hub_pull_request_document_configuration_field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self
                .git_hub_pull_request_document_configuration_field_mappings
                .unwrap_or_default();
            v.push(input);
            self.git_hub_pull_request_document_configuration_field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub pull requests to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
        pub fn set_git_hub_pull_request_document_configuration_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.git_hub_pull_request_document_configuration_field_mappings = input;
            self
        }
        /// Appends an item to `git_hub_pull_request_document_attachment_configuration_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_git_hub_pull_request_document_attachment_configuration_field_mappings`](Self::set_git_hub_pull_request_document_attachment_configuration_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub pull request attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
        pub fn git_hub_pull_request_document_attachment_configuration_field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self
                .git_hub_pull_request_document_attachment_configuration_field_mappings
                .unwrap_or_default();
            v.push(input);
            self.git_hub_pull_request_document_attachment_configuration_field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of GitHub pull request attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to GitHub fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The GitHub data source field names must exist in your GitHub custom metadata.</p>
        pub fn set_git_hub_pull_request_document_attachment_configuration_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.git_hub_pull_request_document_attachment_configuration_field_mappings = input;
            self
        }
        /// Consumes the builder and constructs a [`GitHubConfiguration`](crate::model::GitHubConfiguration).
        pub fn build(self) -> crate::model::GitHubConfiguration {
            crate::model::GitHubConfiguration {
                saa_s_configuration: self.saa_s_configuration,
                on_premise_configuration: self.on_premise_configuration,
                r#type: self.r#type,
                secret_arn: self.secret_arn,
                use_change_log: self.use_change_log.unwrap_or_default(),
                git_hub_document_crawl_properties: self.git_hub_document_crawl_properties,
                repository_filter: self.repository_filter,
                inclusion_folder_name_patterns: self.inclusion_folder_name_patterns,
                inclusion_file_type_patterns: self.inclusion_file_type_patterns,
                inclusion_file_name_patterns: self.inclusion_file_name_patterns,
                exclusion_folder_name_patterns: self.exclusion_folder_name_patterns,
                exclusion_file_type_patterns: self.exclusion_file_type_patterns,
                exclusion_file_name_patterns: self.exclusion_file_name_patterns,
                vpc_configuration: self.vpc_configuration,
                git_hub_repository_configuration_field_mappings: self
                    .git_hub_repository_configuration_field_mappings,
                git_hub_commit_configuration_field_mappings: self
                    .git_hub_commit_configuration_field_mappings,
                git_hub_issue_document_configuration_field_mappings: self
                    .git_hub_issue_document_configuration_field_mappings,
                git_hub_issue_comment_configuration_field_mappings: self
                    .git_hub_issue_comment_configuration_field_mappings,
                git_hub_issue_attachment_configuration_field_mappings: self
                    .git_hub_issue_attachment_configuration_field_mappings,
                git_hub_pull_request_comment_configuration_field_mappings: self
                    .git_hub_pull_request_comment_configuration_field_mappings,
                git_hub_pull_request_document_configuration_field_mappings: self
                    .git_hub_pull_request_document_configuration_field_mappings,
                git_hub_pull_request_document_attachment_configuration_field_mappings: self
                    .git_hub_pull_request_document_attachment_configuration_field_mappings,
            }
        }
    }
}
impl GitHubConfiguration {
    /// Creates a new builder-style object to manufacture [`GitHubConfiguration`](crate::model::GitHubConfiguration).
    pub fn builder() -> crate::model::git_hub_configuration::Builder {
        crate::model::git_hub_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information to include certain types of GitHub content. You can configure to index repository files only, or also include issues and pull requests, comments, and comment attachments.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GitHubDocumentCrawlProperties {
    /// <p> <code>TRUE</code> to index all files with a repository.</p>
    #[doc(hidden)]
    pub crawl_repository_documents: bool,
    /// <p> <code>TRUE</code> to index all issues within a repository.</p>
    #[doc(hidden)]
    pub crawl_issue: bool,
    /// <p> <code>TRUE</code> to index all comments on issues.</p>
    #[doc(hidden)]
    pub crawl_issue_comment: bool,
    /// <p> <code>TRUE</code> to include all comment attachments for issues.</p>
    #[doc(hidden)]
    pub crawl_issue_comment_attachment: bool,
    /// <p> <code>TRUE</code> to index all pull requests within a repository.</p>
    #[doc(hidden)]
    pub crawl_pull_request: bool,
    /// <p> <code>TRUE</code> to index all comments on pull requests.</p>
    #[doc(hidden)]
    pub crawl_pull_request_comment: bool,
    /// <p> <code>TRUE</code> to include all comment attachments for pull requests.</p>
    #[doc(hidden)]
    pub crawl_pull_request_comment_attachment: bool,
}
impl GitHubDocumentCrawlProperties {
    /// <p> <code>TRUE</code> to index all files with a repository.</p>
    pub fn crawl_repository_documents(&self) -> bool {
        self.crawl_repository_documents
    }
    /// <p> <code>TRUE</code> to index all issues within a repository.</p>
    pub fn crawl_issue(&self) -> bool {
        self.crawl_issue
    }
    /// <p> <code>TRUE</code> to index all comments on issues.</p>
    pub fn crawl_issue_comment(&self) -> bool {
        self.crawl_issue_comment
    }
    /// <p> <code>TRUE</code> to include all comment attachments for issues.</p>
    pub fn crawl_issue_comment_attachment(&self) -> bool {
        self.crawl_issue_comment_attachment
    }
    /// <p> <code>TRUE</code> to index all pull requests within a repository.</p>
    pub fn crawl_pull_request(&self) -> bool {
        self.crawl_pull_request
    }
    /// <p> <code>TRUE</code> to index all comments on pull requests.</p>
    pub fn crawl_pull_request_comment(&self) -> bool {
        self.crawl_pull_request_comment
    }
    /// <p> <code>TRUE</code> to include all comment attachments for pull requests.</p>
    pub fn crawl_pull_request_comment_attachment(&self) -> bool {
        self.crawl_pull_request_comment_attachment
    }
}
/// See [`GitHubDocumentCrawlProperties`](crate::model::GitHubDocumentCrawlProperties).
pub mod git_hub_document_crawl_properties {

    /// A builder for [`GitHubDocumentCrawlProperties`](crate::model::GitHubDocumentCrawlProperties).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) crawl_repository_documents: std::option::Option<bool>,
        pub(crate) crawl_issue: std::option::Option<bool>,
        pub(crate) crawl_issue_comment: std::option::Option<bool>,
        pub(crate) crawl_issue_comment_attachment: std::option::Option<bool>,
        pub(crate) crawl_pull_request: std::option::Option<bool>,
        pub(crate) crawl_pull_request_comment: std::option::Option<bool>,
        pub(crate) crawl_pull_request_comment_attachment: std::option::Option<bool>,
    }
    impl Builder {
        /// <p> <code>TRUE</code> to index all files with a repository.</p>
        pub fn crawl_repository_documents(mut self, input: bool) -> Self {
            self.crawl_repository_documents = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to index all files with a repository.</p>
        pub fn set_crawl_repository_documents(mut self, input: std::option::Option<bool>) -> Self {
            self.crawl_repository_documents = input;
            self
        }
        /// <p> <code>TRUE</code> to index all issues within a repository.</p>
        pub fn crawl_issue(mut self, input: bool) -> Self {
            self.crawl_issue = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to index all issues within a repository.</p>
        pub fn set_crawl_issue(mut self, input: std::option::Option<bool>) -> Self {
            self.crawl_issue = input;
            self
        }
        /// <p> <code>TRUE</code> to index all comments on issues.</p>
        pub fn crawl_issue_comment(mut self, input: bool) -> Self {
            self.crawl_issue_comment = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to index all comments on issues.</p>
        pub fn set_crawl_issue_comment(mut self, input: std::option::Option<bool>) -> Self {
            self.crawl_issue_comment = input;
            self
        }
        /// <p> <code>TRUE</code> to include all comment attachments for issues.</p>
        pub fn crawl_issue_comment_attachment(mut self, input: bool) -> Self {
            self.crawl_issue_comment_attachment = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to include all comment attachments for issues.</p>
        pub fn set_crawl_issue_comment_attachment(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.crawl_issue_comment_attachment = input;
            self
        }
        /// <p> <code>TRUE</code> to index all pull requests within a repository.</p>
        pub fn crawl_pull_request(mut self, input: bool) -> Self {
            self.crawl_pull_request = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to index all pull requests within a repository.</p>
        pub fn set_crawl_pull_request(mut self, input: std::option::Option<bool>) -> Self {
            self.crawl_pull_request = input;
            self
        }
        /// <p> <code>TRUE</code> to index all comments on pull requests.</p>
        pub fn crawl_pull_request_comment(mut self, input: bool) -> Self {
            self.crawl_pull_request_comment = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to index all comments on pull requests.</p>
        pub fn set_crawl_pull_request_comment(mut self, input: std::option::Option<bool>) -> Self {
            self.crawl_pull_request_comment = input;
            self
        }
        /// <p> <code>TRUE</code> to include all comment attachments for pull requests.</p>
        pub fn crawl_pull_request_comment_attachment(mut self, input: bool) -> Self {
            self.crawl_pull_request_comment_attachment = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to include all comment attachments for pull requests.</p>
        pub fn set_crawl_pull_request_comment_attachment(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.crawl_pull_request_comment_attachment = input;
            self
        }
        /// Consumes the builder and constructs a [`GitHubDocumentCrawlProperties`](crate::model::GitHubDocumentCrawlProperties).
        pub fn build(self) -> crate::model::GitHubDocumentCrawlProperties {
            crate::model::GitHubDocumentCrawlProperties {
                crawl_repository_documents: self.crawl_repository_documents.unwrap_or_default(),
                crawl_issue: self.crawl_issue.unwrap_or_default(),
                crawl_issue_comment: self.crawl_issue_comment.unwrap_or_default(),
                crawl_issue_comment_attachment: self
                    .crawl_issue_comment_attachment
                    .unwrap_or_default(),
                crawl_pull_request: self.crawl_pull_request.unwrap_or_default(),
                crawl_pull_request_comment: self.crawl_pull_request_comment.unwrap_or_default(),
                crawl_pull_request_comment_attachment: self
                    .crawl_pull_request_comment_attachment
                    .unwrap_or_default(),
            }
        }
    }
}
impl GitHubDocumentCrawlProperties {
    /// Creates a new builder-style object to manufacture [`GitHubDocumentCrawlProperties`](crate::model::GitHubDocumentCrawlProperties).
    pub fn builder() -> crate::model::git_hub_document_crawl_properties::Builder {
        crate::model::git_hub_document_crawl_properties::Builder::default()
    }
}

/// When writing a match expression against `Type`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let type = unimplemented!();
/// match type {
///     Type::OnPremise => { /* ... */ },
///     Type::Saas => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `type` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Type::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Type::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Type::NewFeature` is defined.
/// Specifically, when `type` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Type::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Type {
    #[allow(missing_docs)] // documentation missing in model
    OnPremise,
    #[allow(missing_docs)] // documentation missing in model
    Saas,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Type {
    fn from(s: &str) -> Self {
        match s {
            "ON_PREMISE" => Type::OnPremise,
            "SAAS" => Type::Saas,
            other => Type::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Type {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Type::from(s))
    }
}
impl Type {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Type::OnPremise => "ON_PREMISE",
            Type::Saas => "SAAS",
            Type::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ON_PREMISE", "SAAS"]
    }
}
impl AsRef<str> for Type {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides the configuration information to connect to GitHub Enterprise Server (on premises).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OnPremiseConfiguration {
    /// <p>The GitHub host URL or API endpoint URL. For example, <i>https://on-prem-host-url/api/v3/</i> </p>
    #[doc(hidden)]
    pub host_url: std::option::Option<std::string::String>,
    /// <p>The name of the organization of the GitHub Enterprise Server (in-premise) account you want to connect to. You can find your organization name by logging into GitHub desktop and selecting <b>Your organizations</b> under your profile picture dropdown.</p>
    #[doc(hidden)]
    pub organization_name: std::option::Option<std::string::String>,
    /// <p>The path to the SSL certificate stored in an Amazon S3 bucket. You use this to connect to GitHub if you require a secure SSL connection.</p>
    /// <p>You can simply generate a self-signed X509 certificate on any computer using OpenSSL. For an example of using OpenSSL to create an X509 certificate, see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/configuring-https-ssl.html">Create and sign an X509 certificate</a>.</p>
    #[doc(hidden)]
    pub ssl_certificate_s3_path: std::option::Option<crate::model::S3Path>,
}
impl OnPremiseConfiguration {
    /// <p>The GitHub host URL or API endpoint URL. For example, <i>https://on-prem-host-url/api/v3/</i> </p>
    pub fn host_url(&self) -> std::option::Option<&str> {
        self.host_url.as_deref()
    }
    /// <p>The name of the organization of the GitHub Enterprise Server (in-premise) account you want to connect to. You can find your organization name by logging into GitHub desktop and selecting <b>Your organizations</b> under your profile picture dropdown.</p>
    pub fn organization_name(&self) -> std::option::Option<&str> {
        self.organization_name.as_deref()
    }
    /// <p>The path to the SSL certificate stored in an Amazon S3 bucket. You use this to connect to GitHub if you require a secure SSL connection.</p>
    /// <p>You can simply generate a self-signed X509 certificate on any computer using OpenSSL. For an example of using OpenSSL to create an X509 certificate, see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/configuring-https-ssl.html">Create and sign an X509 certificate</a>.</p>
    pub fn ssl_certificate_s3_path(&self) -> std::option::Option<&crate::model::S3Path> {
        self.ssl_certificate_s3_path.as_ref()
    }
}
/// See [`OnPremiseConfiguration`](crate::model::OnPremiseConfiguration).
pub mod on_premise_configuration {

    /// A builder for [`OnPremiseConfiguration`](crate::model::OnPremiseConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) host_url: std::option::Option<std::string::String>,
        pub(crate) organization_name: std::option::Option<std::string::String>,
        pub(crate) ssl_certificate_s3_path: std::option::Option<crate::model::S3Path>,
    }
    impl Builder {
        /// <p>The GitHub host URL or API endpoint URL. For example, <i>https://on-prem-host-url/api/v3/</i> </p>
        pub fn host_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.host_url = Some(input.into());
            self
        }
        /// <p>The GitHub host URL or API endpoint URL. For example, <i>https://on-prem-host-url/api/v3/</i> </p>
        pub fn set_host_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host_url = input;
            self
        }
        /// <p>The name of the organization of the GitHub Enterprise Server (in-premise) account you want to connect to. You can find your organization name by logging into GitHub desktop and selecting <b>Your organizations</b> under your profile picture dropdown.</p>
        pub fn organization_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.organization_name = Some(input.into());
            self
        }
        /// <p>The name of the organization of the GitHub Enterprise Server (in-premise) account you want to connect to. You can find your organization name by logging into GitHub desktop and selecting <b>Your organizations</b> under your profile picture dropdown.</p>
        pub fn set_organization_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.organization_name = input;
            self
        }
        /// <p>The path to the SSL certificate stored in an Amazon S3 bucket. You use this to connect to GitHub if you require a secure SSL connection.</p>
        /// <p>You can simply generate a self-signed X509 certificate on any computer using OpenSSL. For an example of using OpenSSL to create an X509 certificate, see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/configuring-https-ssl.html">Create and sign an X509 certificate</a>.</p>
        pub fn ssl_certificate_s3_path(mut self, input: crate::model::S3Path) -> Self {
            self.ssl_certificate_s3_path = Some(input);
            self
        }
        /// <p>The path to the SSL certificate stored in an Amazon S3 bucket. You use this to connect to GitHub if you require a secure SSL connection.</p>
        /// <p>You can simply generate a self-signed X509 certificate on any computer using OpenSSL. For an example of using OpenSSL to create an X509 certificate, see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/configuring-https-ssl.html">Create and sign an X509 certificate</a>.</p>
        pub fn set_ssl_certificate_s3_path(
            mut self,
            input: std::option::Option<crate::model::S3Path>,
        ) -> Self {
            self.ssl_certificate_s3_path = input;
            self
        }
        /// Consumes the builder and constructs a [`OnPremiseConfiguration`](crate::model::OnPremiseConfiguration).
        pub fn build(self) -> crate::model::OnPremiseConfiguration {
            crate::model::OnPremiseConfiguration {
                host_url: self.host_url,
                organization_name: self.organization_name,
                ssl_certificate_s3_path: self.ssl_certificate_s3_path,
            }
        }
    }
}
impl OnPremiseConfiguration {
    /// Creates a new builder-style object to manufacture [`OnPremiseConfiguration`](crate::model::OnPremiseConfiguration).
    pub fn builder() -> crate::model::on_premise_configuration::Builder {
        crate::model::on_premise_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information to connect to GitHub Enterprise Cloud (SaaS).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SaaSConfiguration {
    /// <p>The name of the organization of the GitHub Enterprise Cloud (SaaS) account you want to connect to. You can find your organization name by logging into GitHub desktop and selecting <b>Your organizations</b> under your profile picture dropdown.</p>
    #[doc(hidden)]
    pub organization_name: std::option::Option<std::string::String>,
    /// <p>The GitHub host URL or API endpoint URL. For example, <i>https://api.github.com</i>.</p>
    #[doc(hidden)]
    pub host_url: std::option::Option<std::string::String>,
}
impl SaaSConfiguration {
    /// <p>The name of the organization of the GitHub Enterprise Cloud (SaaS) account you want to connect to. You can find your organization name by logging into GitHub desktop and selecting <b>Your organizations</b> under your profile picture dropdown.</p>
    pub fn organization_name(&self) -> std::option::Option<&str> {
        self.organization_name.as_deref()
    }
    /// <p>The GitHub host URL or API endpoint URL. For example, <i>https://api.github.com</i>.</p>
    pub fn host_url(&self) -> std::option::Option<&str> {
        self.host_url.as_deref()
    }
}
/// See [`SaaSConfiguration`](crate::model::SaaSConfiguration).
pub mod saa_s_configuration {

    /// A builder for [`SaaSConfiguration`](crate::model::SaaSConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) organization_name: std::option::Option<std::string::String>,
        pub(crate) host_url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the organization of the GitHub Enterprise Cloud (SaaS) account you want to connect to. You can find your organization name by logging into GitHub desktop and selecting <b>Your organizations</b> under your profile picture dropdown.</p>
        pub fn organization_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.organization_name = Some(input.into());
            self
        }
        /// <p>The name of the organization of the GitHub Enterprise Cloud (SaaS) account you want to connect to. You can find your organization name by logging into GitHub desktop and selecting <b>Your organizations</b> under your profile picture dropdown.</p>
        pub fn set_organization_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.organization_name = input;
            self
        }
        /// <p>The GitHub host URL or API endpoint URL. For example, <i>https://api.github.com</i>.</p>
        pub fn host_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.host_url = Some(input.into());
            self
        }
        /// <p>The GitHub host URL or API endpoint URL. For example, <i>https://api.github.com</i>.</p>
        pub fn set_host_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host_url = input;
            self
        }
        /// Consumes the builder and constructs a [`SaaSConfiguration`](crate::model::SaaSConfiguration).
        pub fn build(self) -> crate::model::SaaSConfiguration {
            crate::model::SaaSConfiguration {
                organization_name: self.organization_name,
                host_url: self.host_url,
            }
        }
    }
}
impl SaaSConfiguration {
    /// Creates a new builder-style object to manufacture [`SaaSConfiguration`](crate::model::SaaSConfiguration).
    pub fn builder() -> crate::model::saa_s_configuration::Builder {
        crate::model::saa_s_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information to connect to Jira as your data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JiraConfiguration {
    /// <p>The URL of the Jira account. For example, <i>company.atlassian.net</i>.</p>
    #[doc(hidden)]
    pub jira_account_url: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of a secret in Secrets Manager contains the key-value pairs required to connect to your Jira data source. The secret must contain a JSON structure with the following keys:</p>
    /// <ul>
    /// <li> <p>jiraId—The Jira user name or email.</p> </li>
    /// <li> <p>jiraCredentials—The Jira API token. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-jira.html">Using a Jira data source</a>.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub secret_arn: std::option::Option<std::string::String>,
    /// <p> <code>TRUE</code> to use the Jira change log to determine which documents require updating in the index. Depending on the change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents in Jira.</p>
    #[doc(hidden)]
    pub use_change_log: bool,
    /// <p>Specify which projects to crawl in your Jira data source. You can specify one or more Jira project IDs.</p>
    #[doc(hidden)]
    pub project: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specify which issue types to crawl in your Jira data source. You can specify one or more of these options to crawl.</p>
    #[doc(hidden)]
    pub issue_type: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specify which statuses to crawl in your Jira data source. You can specify one or more of these options to crawl.</p>
    #[doc(hidden)]
    pub status: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specify whether to crawl comments, attachments, and work logs. You can specify one or more of these options.</p>
    #[doc(hidden)]
    pub issue_sub_entity_filter: std::option::Option<std::vec::Vec<crate::model::IssueSubEntity>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Jira attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Jira fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Jira data source field names must exist in your Jira custom metadata.</p>
    #[doc(hidden)]
    pub attachment_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Jira comments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Jira fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Jira data source field names must exist in your Jira custom metadata.</p>
    #[doc(hidden)]
    pub comment_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Jira issues to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Jira fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Jira data source field names must exist in your Jira custom metadata.</p>
    #[doc(hidden)]
    pub issue_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Jira projects to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Jira fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Jira data source field names must exist in your Jira custom metadata.</p>
    #[doc(hidden)]
    pub project_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Jira work logs to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Jira fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Jira data source field names must exist in your Jira custom metadata.</p>
    #[doc(hidden)]
    pub work_log_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>A list of regular expression patterns to include certain file paths, file names, and file types in your Jira data source. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    #[doc(hidden)]
    pub inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of regular expression patterns to exclude certain file paths, file names, and file types in your Jira data source. Files that match the patterns are excluded from the index. Files that don’t match the patterns are included in the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    #[doc(hidden)]
    pub exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Configuration information for an Amazon Virtual Private Cloud to connect to your Jira. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
    #[doc(hidden)]
    pub vpc_configuration: std::option::Option<crate::model::DataSourceVpcConfiguration>,
}
impl JiraConfiguration {
    /// <p>The URL of the Jira account. For example, <i>company.atlassian.net</i>.</p>
    pub fn jira_account_url(&self) -> std::option::Option<&str> {
        self.jira_account_url.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of a secret in Secrets Manager contains the key-value pairs required to connect to your Jira data source. The secret must contain a JSON structure with the following keys:</p>
    /// <ul>
    /// <li> <p>jiraId—The Jira user name or email.</p> </li>
    /// <li> <p>jiraCredentials—The Jira API token. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-jira.html">Using a Jira data source</a>.</p> </li>
    /// </ul>
    pub fn secret_arn(&self) -> std::option::Option<&str> {
        self.secret_arn.as_deref()
    }
    /// <p> <code>TRUE</code> to use the Jira change log to determine which documents require updating in the index. Depending on the change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents in Jira.</p>
    pub fn use_change_log(&self) -> bool {
        self.use_change_log
    }
    /// <p>Specify which projects to crawl in your Jira data source. You can specify one or more Jira project IDs.</p>
    pub fn project(&self) -> std::option::Option<&[std::string::String]> {
        self.project.as_deref()
    }
    /// <p>Specify which issue types to crawl in your Jira data source. You can specify one or more of these options to crawl.</p>
    pub fn issue_type(&self) -> std::option::Option<&[std::string::String]> {
        self.issue_type.as_deref()
    }
    /// <p>Specify which statuses to crawl in your Jira data source. You can specify one or more of these options to crawl.</p>
    pub fn status(&self) -> std::option::Option<&[std::string::String]> {
        self.status.as_deref()
    }
    /// <p>Specify whether to crawl comments, attachments, and work logs. You can specify one or more of these options.</p>
    pub fn issue_sub_entity_filter(&self) -> std::option::Option<&[crate::model::IssueSubEntity]> {
        self.issue_sub_entity_filter.as_deref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Jira attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Jira fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Jira data source field names must exist in your Jira custom metadata.</p>
    pub fn attachment_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.attachment_field_mappings.as_deref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Jira comments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Jira fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Jira data source field names must exist in your Jira custom metadata.</p>
    pub fn comment_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.comment_field_mappings.as_deref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Jira issues to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Jira fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Jira data source field names must exist in your Jira custom metadata.</p>
    pub fn issue_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.issue_field_mappings.as_deref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Jira projects to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Jira fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Jira data source field names must exist in your Jira custom metadata.</p>
    pub fn project_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.project_field_mappings.as_deref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Jira work logs to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Jira fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Jira data source field names must exist in your Jira custom metadata.</p>
    pub fn work_log_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.work_log_field_mappings.as_deref()
    }
    /// <p>A list of regular expression patterns to include certain file paths, file names, and file types in your Jira data source. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    pub fn inclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.inclusion_patterns.as_deref()
    }
    /// <p>A list of regular expression patterns to exclude certain file paths, file names, and file types in your Jira data source. Files that match the patterns are excluded from the index. Files that don’t match the patterns are included in the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    pub fn exclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.exclusion_patterns.as_deref()
    }
    /// <p>Configuration information for an Amazon Virtual Private Cloud to connect to your Jira. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
    pub fn vpc_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DataSourceVpcConfiguration> {
        self.vpc_configuration.as_ref()
    }
}
/// See [`JiraConfiguration`](crate::model::JiraConfiguration).
pub mod jira_configuration {

    /// A builder for [`JiraConfiguration`](crate::model::JiraConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) jira_account_url: std::option::Option<std::string::String>,
        pub(crate) secret_arn: std::option::Option<std::string::String>,
        pub(crate) use_change_log: std::option::Option<bool>,
        pub(crate) project: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) issue_type: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) status: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) issue_sub_entity_filter:
            std::option::Option<std::vec::Vec<crate::model::IssueSubEntity>>,
        pub(crate) attachment_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) comment_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) issue_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) project_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) work_log_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) vpc_configuration: std::option::Option<crate::model::DataSourceVpcConfiguration>,
    }
    impl Builder {
        /// <p>The URL of the Jira account. For example, <i>company.atlassian.net</i>.</p>
        pub fn jira_account_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.jira_account_url = Some(input.into());
            self
        }
        /// <p>The URL of the Jira account. For example, <i>company.atlassian.net</i>.</p>
        pub fn set_jira_account_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.jira_account_url = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a secret in Secrets Manager contains the key-value pairs required to connect to your Jira data source. The secret must contain a JSON structure with the following keys:</p>
        /// <ul>
        /// <li> <p>jiraId—The Jira user name or email.</p> </li>
        /// <li> <p>jiraCredentials—The Jira API token. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-jira.html">Using a Jira data source</a>.</p> </li>
        /// </ul>
        pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a secret in Secrets Manager contains the key-value pairs required to connect to your Jira data source. The secret must contain a JSON structure with the following keys:</p>
        /// <ul>
        /// <li> <p>jiraId—The Jira user name or email.</p> </li>
        /// <li> <p>jiraCredentials—The Jira API token. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-jira.html">Using a Jira data source</a>.</p> </li>
        /// </ul>
        pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_arn = input;
            self
        }
        /// <p> <code>TRUE</code> to use the Jira change log to determine which documents require updating in the index. Depending on the change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents in Jira.</p>
        pub fn use_change_log(mut self, input: bool) -> Self {
            self.use_change_log = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to use the Jira change log to determine which documents require updating in the index. Depending on the change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents in Jira.</p>
        pub fn set_use_change_log(mut self, input: std::option::Option<bool>) -> Self {
            self.use_change_log = input;
            self
        }
        /// Appends an item to `project`.
        ///
        /// To override the contents of this collection use [`set_project`](Self::set_project).
        ///
        /// <p>Specify which projects to crawl in your Jira data source. You can specify one or more Jira project IDs.</p>
        pub fn project(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.project.unwrap_or_default();
            v.push(input.into());
            self.project = Some(v);
            self
        }
        /// <p>Specify which projects to crawl in your Jira data source. You can specify one or more Jira project IDs.</p>
        pub fn set_project(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.project = input;
            self
        }
        /// Appends an item to `issue_type`.
        ///
        /// To override the contents of this collection use [`set_issue_type`](Self::set_issue_type).
        ///
        /// <p>Specify which issue types to crawl in your Jira data source. You can specify one or more of these options to crawl.</p>
        pub fn issue_type(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.issue_type.unwrap_or_default();
            v.push(input.into());
            self.issue_type = Some(v);
            self
        }
        /// <p>Specify which issue types to crawl in your Jira data source. You can specify one or more of these options to crawl.</p>
        pub fn set_issue_type(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.issue_type = input;
            self
        }
        /// Appends an item to `status`.
        ///
        /// To override the contents of this collection use [`set_status`](Self::set_status).
        ///
        /// <p>Specify which statuses to crawl in your Jira data source. You can specify one or more of these options to crawl.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.status.unwrap_or_default();
            v.push(input.into());
            self.status = Some(v);
            self
        }
        /// <p>Specify which statuses to crawl in your Jira data source. You can specify one or more of these options to crawl.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Appends an item to `issue_sub_entity_filter`.
        ///
        /// To override the contents of this collection use [`set_issue_sub_entity_filter`](Self::set_issue_sub_entity_filter).
        ///
        /// <p>Specify whether to crawl comments, attachments, and work logs. You can specify one or more of these options.</p>
        pub fn issue_sub_entity_filter(mut self, input: crate::model::IssueSubEntity) -> Self {
            let mut v = self.issue_sub_entity_filter.unwrap_or_default();
            v.push(input);
            self.issue_sub_entity_filter = Some(v);
            self
        }
        /// <p>Specify whether to crawl comments, attachments, and work logs. You can specify one or more of these options.</p>
        pub fn set_issue_sub_entity_filter(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IssueSubEntity>>,
        ) -> Self {
            self.issue_sub_entity_filter = input;
            self
        }
        /// Appends an item to `attachment_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_attachment_field_mappings`](Self::set_attachment_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Jira attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Jira fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Jira data source field names must exist in your Jira custom metadata.</p>
        pub fn attachment_field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.attachment_field_mappings.unwrap_or_default();
            v.push(input);
            self.attachment_field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Jira attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Jira fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Jira data source field names must exist in your Jira custom metadata.</p>
        pub fn set_attachment_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.attachment_field_mappings = input;
            self
        }
        /// Appends an item to `comment_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_comment_field_mappings`](Self::set_comment_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Jira comments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Jira fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Jira data source field names must exist in your Jira custom metadata.</p>
        pub fn comment_field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.comment_field_mappings.unwrap_or_default();
            v.push(input);
            self.comment_field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Jira comments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Jira fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Jira data source field names must exist in your Jira custom metadata.</p>
        pub fn set_comment_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.comment_field_mappings = input;
            self
        }
        /// Appends an item to `issue_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_issue_field_mappings`](Self::set_issue_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Jira issues to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Jira fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Jira data source field names must exist in your Jira custom metadata.</p>
        pub fn issue_field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.issue_field_mappings.unwrap_or_default();
            v.push(input);
            self.issue_field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Jira issues to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Jira fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Jira data source field names must exist in your Jira custom metadata.</p>
        pub fn set_issue_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.issue_field_mappings = input;
            self
        }
        /// Appends an item to `project_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_project_field_mappings`](Self::set_project_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Jira projects to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Jira fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Jira data source field names must exist in your Jira custom metadata.</p>
        pub fn project_field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.project_field_mappings.unwrap_or_default();
            v.push(input);
            self.project_field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Jira projects to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Jira fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Jira data source field names must exist in your Jira custom metadata.</p>
        pub fn set_project_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.project_field_mappings = input;
            self
        }
        /// Appends an item to `work_log_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_work_log_field_mappings`](Self::set_work_log_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Jira work logs to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Jira fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Jira data source field names must exist in your Jira custom metadata.</p>
        pub fn work_log_field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.work_log_field_mappings.unwrap_or_default();
            v.push(input);
            self.work_log_field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Jira work logs to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Jira fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html"> Mapping data source fields</a>. The Jira data source field names must exist in your Jira custom metadata.</p>
        pub fn set_work_log_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.work_log_field_mappings = input;
            self
        }
        /// Appends an item to `inclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_inclusion_patterns`](Self::set_inclusion_patterns).
        ///
        /// <p>A list of regular expression patterns to include certain file paths, file names, and file types in your Jira data source. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn inclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.inclusion_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to include certain file paths, file names, and file types in your Jira data source. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn set_inclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inclusion_patterns = input;
            self
        }
        /// Appends an item to `exclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_exclusion_patterns`](Self::set_exclusion_patterns).
        ///
        /// <p>A list of regular expression patterns to exclude certain file paths, file names, and file types in your Jira data source. Files that match the patterns are excluded from the index. Files that don’t match the patterns are included in the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn exclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.exclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.exclusion_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to exclude certain file paths, file names, and file types in your Jira data source. Files that match the patterns are excluded from the index. Files that don’t match the patterns are included in the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn set_exclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclusion_patterns = input;
            self
        }
        /// <p>Configuration information for an Amazon Virtual Private Cloud to connect to your Jira. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
        pub fn vpc_configuration(
            mut self,
            input: crate::model::DataSourceVpcConfiguration,
        ) -> Self {
            self.vpc_configuration = Some(input);
            self
        }
        /// <p>Configuration information for an Amazon Virtual Private Cloud to connect to your Jira. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
        pub fn set_vpc_configuration(
            mut self,
            input: std::option::Option<crate::model::DataSourceVpcConfiguration>,
        ) -> Self {
            self.vpc_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`JiraConfiguration`](crate::model::JiraConfiguration).
        pub fn build(self) -> crate::model::JiraConfiguration {
            crate::model::JiraConfiguration {
                jira_account_url: self.jira_account_url,
                secret_arn: self.secret_arn,
                use_change_log: self.use_change_log.unwrap_or_default(),
                project: self.project,
                issue_type: self.issue_type,
                status: self.status,
                issue_sub_entity_filter: self.issue_sub_entity_filter,
                attachment_field_mappings: self.attachment_field_mappings,
                comment_field_mappings: self.comment_field_mappings,
                issue_field_mappings: self.issue_field_mappings,
                project_field_mappings: self.project_field_mappings,
                work_log_field_mappings: self.work_log_field_mappings,
                inclusion_patterns: self.inclusion_patterns,
                exclusion_patterns: self.exclusion_patterns,
                vpc_configuration: self.vpc_configuration,
            }
        }
    }
}
impl JiraConfiguration {
    /// Creates a new builder-style object to manufacture [`JiraConfiguration`](crate::model::JiraConfiguration).
    pub fn builder() -> crate::model::jira_configuration::Builder {
        crate::model::jira_configuration::Builder::default()
    }
}

/// When writing a match expression against `IssueSubEntity`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let issuesubentity = unimplemented!();
/// match issuesubentity {
///     IssueSubEntity::Attachments => { /* ... */ },
///     IssueSubEntity::Comments => { /* ... */ },
///     IssueSubEntity::Worklogs => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `issuesubentity` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `IssueSubEntity::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `IssueSubEntity::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `IssueSubEntity::NewFeature` is defined.
/// Specifically, when `issuesubentity` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `IssueSubEntity::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum IssueSubEntity {
    #[allow(missing_docs)] // documentation missing in model
    Attachments,
    #[allow(missing_docs)] // documentation missing in model
    Comments,
    #[allow(missing_docs)] // documentation missing in model
    Worklogs,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for IssueSubEntity {
    fn from(s: &str) -> Self {
        match s {
            "ATTACHMENTS" => IssueSubEntity::Attachments,
            "COMMENTS" => IssueSubEntity::Comments,
            "WORKLOGS" => IssueSubEntity::Worklogs,
            other => IssueSubEntity::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for IssueSubEntity {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(IssueSubEntity::from(s))
    }
}
impl IssueSubEntity {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            IssueSubEntity::Attachments => "ATTACHMENTS",
            IssueSubEntity::Comments => "COMMENTS",
            IssueSubEntity::Worklogs => "WORKLOGS",
            IssueSubEntity::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ATTACHMENTS", "COMMENTS", "WORKLOGS"]
    }
}
impl AsRef<str> for IssueSubEntity {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides the configuration information to connect to Quip as your data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QuipConfiguration {
    /// <p>The Quip site domain. For example, <i>https://quip-company.quipdomain.com/browse</i>. The domain in this example is "quipdomain".</p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs that are required to connect to your Quip. The secret must contain a JSON structure with the following keys:</p>
    /// <ul>
    /// <li> <p>accessToken—The token created in Quip. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-slack.html">Using a Quip data source</a>.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub secret_arn: std::option::Option<std::string::String>,
    /// <p> <code>TRUE</code> to index file comments.</p>
    #[doc(hidden)]
    pub crawl_file_comments: bool,
    /// <p> <code>TRUE</code> to index the contents of chat rooms.</p>
    #[doc(hidden)]
    pub crawl_chat_rooms: bool,
    /// <p> <code>TRUE</code> to index attachments.</p>
    #[doc(hidden)]
    pub crawl_attachments: bool,
    /// <p>The identifiers of the Quip folders you want to index. You can find the folder ID in your browser URL when you access your folder in Quip. For example, <i>https://quip-company.quipdomain.com/zlLuOVNSarTL/folder-name</i>. The folder ID in this example is "zlLuOVNSarTL".</p>
    #[doc(hidden)]
    pub folder_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip threads to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
    #[doc(hidden)]
    pub thread_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip messages to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
    #[doc(hidden)]
    pub message_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
    #[doc(hidden)]
    pub attachment_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>A list of regular expression patterns to include certain files in your Quip file system. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence, and the file isn't included in the index.</p>
    #[doc(hidden)]
    pub inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of regular expression patterns to exclude certain files in your Quip file system. Files that match the patterns are excluded from the index. Files that don’t match the patterns are included in the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence, and the file isn't included in the index.</p>
    #[doc(hidden)]
    pub exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Configuration information for an Amazon Virtual Private Cloud (VPC) to connect to your Quip. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
    #[doc(hidden)]
    pub vpc_configuration: std::option::Option<crate::model::DataSourceVpcConfiguration>,
}
impl QuipConfiguration {
    /// <p>The Quip site domain. For example, <i>https://quip-company.quipdomain.com/browse</i>. The domain in this example is "quipdomain".</p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs that are required to connect to your Quip. The secret must contain a JSON structure with the following keys:</p>
    /// <ul>
    /// <li> <p>accessToken—The token created in Quip. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-slack.html">Using a Quip data source</a>.</p> </li>
    /// </ul>
    pub fn secret_arn(&self) -> std::option::Option<&str> {
        self.secret_arn.as_deref()
    }
    /// <p> <code>TRUE</code> to index file comments.</p>
    pub fn crawl_file_comments(&self) -> bool {
        self.crawl_file_comments
    }
    /// <p> <code>TRUE</code> to index the contents of chat rooms.</p>
    pub fn crawl_chat_rooms(&self) -> bool {
        self.crawl_chat_rooms
    }
    /// <p> <code>TRUE</code> to index attachments.</p>
    pub fn crawl_attachments(&self) -> bool {
        self.crawl_attachments
    }
    /// <p>The identifiers of the Quip folders you want to index. You can find the folder ID in your browser URL when you access your folder in Quip. For example, <i>https://quip-company.quipdomain.com/zlLuOVNSarTL/folder-name</i>. The folder ID in this example is "zlLuOVNSarTL".</p>
    pub fn folder_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.folder_ids.as_deref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip threads to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
    pub fn thread_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.thread_field_mappings.as_deref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip messages to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
    pub fn message_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.message_field_mappings.as_deref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
    pub fn attachment_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.attachment_field_mappings.as_deref()
    }
    /// <p>A list of regular expression patterns to include certain files in your Quip file system. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence, and the file isn't included in the index.</p>
    pub fn inclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.inclusion_patterns.as_deref()
    }
    /// <p>A list of regular expression patterns to exclude certain files in your Quip file system. Files that match the patterns are excluded from the index. Files that don’t match the patterns are included in the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence, and the file isn't included in the index.</p>
    pub fn exclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.exclusion_patterns.as_deref()
    }
    /// <p>Configuration information for an Amazon Virtual Private Cloud (VPC) to connect to your Quip. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
    pub fn vpc_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DataSourceVpcConfiguration> {
        self.vpc_configuration.as_ref()
    }
}
/// See [`QuipConfiguration`](crate::model::QuipConfiguration).
pub mod quip_configuration {

    /// A builder for [`QuipConfiguration`](crate::model::QuipConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) secret_arn: std::option::Option<std::string::String>,
        pub(crate) crawl_file_comments: std::option::Option<bool>,
        pub(crate) crawl_chat_rooms: std::option::Option<bool>,
        pub(crate) crawl_attachments: std::option::Option<bool>,
        pub(crate) folder_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) thread_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) message_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) attachment_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) vpc_configuration: std::option::Option<crate::model::DataSourceVpcConfiguration>,
    }
    impl Builder {
        /// <p>The Quip site domain. For example, <i>https://quip-company.quipdomain.com/browse</i>. The domain in this example is "quipdomain".</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p>The Quip site domain. For example, <i>https://quip-company.quipdomain.com/browse</i>. The domain in this example is "quipdomain".</p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs that are required to connect to your Quip. The secret must contain a JSON structure with the following keys:</p>
        /// <ul>
        /// <li> <p>accessToken—The token created in Quip. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-slack.html">Using a Quip data source</a>.</p> </li>
        /// </ul>
        pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs that are required to connect to your Quip. The secret must contain a JSON structure with the following keys:</p>
        /// <ul>
        /// <li> <p>accessToken—The token created in Quip. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-slack.html">Using a Quip data source</a>.</p> </li>
        /// </ul>
        pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_arn = input;
            self
        }
        /// <p> <code>TRUE</code> to index file comments.</p>
        pub fn crawl_file_comments(mut self, input: bool) -> Self {
            self.crawl_file_comments = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to index file comments.</p>
        pub fn set_crawl_file_comments(mut self, input: std::option::Option<bool>) -> Self {
            self.crawl_file_comments = input;
            self
        }
        /// <p> <code>TRUE</code> to index the contents of chat rooms.</p>
        pub fn crawl_chat_rooms(mut self, input: bool) -> Self {
            self.crawl_chat_rooms = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to index the contents of chat rooms.</p>
        pub fn set_crawl_chat_rooms(mut self, input: std::option::Option<bool>) -> Self {
            self.crawl_chat_rooms = input;
            self
        }
        /// <p> <code>TRUE</code> to index attachments.</p>
        pub fn crawl_attachments(mut self, input: bool) -> Self {
            self.crawl_attachments = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to index attachments.</p>
        pub fn set_crawl_attachments(mut self, input: std::option::Option<bool>) -> Self {
            self.crawl_attachments = input;
            self
        }
        /// Appends an item to `folder_ids`.
        ///
        /// To override the contents of this collection use [`set_folder_ids`](Self::set_folder_ids).
        ///
        /// <p>The identifiers of the Quip folders you want to index. You can find the folder ID in your browser URL when you access your folder in Quip. For example, <i>https://quip-company.quipdomain.com/zlLuOVNSarTL/folder-name</i>. The folder ID in this example is "zlLuOVNSarTL".</p>
        pub fn folder_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.folder_ids.unwrap_or_default();
            v.push(input.into());
            self.folder_ids = Some(v);
            self
        }
        /// <p>The identifiers of the Quip folders you want to index. You can find the folder ID in your browser URL when you access your folder in Quip. For example, <i>https://quip-company.quipdomain.com/zlLuOVNSarTL/folder-name</i>. The folder ID in this example is "zlLuOVNSarTL".</p>
        pub fn set_folder_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.folder_ids = input;
            self
        }
        /// Appends an item to `thread_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_thread_field_mappings`](Self::set_thread_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip threads to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
        pub fn thread_field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.thread_field_mappings.unwrap_or_default();
            v.push(input);
            self.thread_field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip threads to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
        pub fn set_thread_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.thread_field_mappings = input;
            self
        }
        /// Appends an item to `message_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_message_field_mappings`](Self::set_message_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip messages to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
        pub fn message_field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.message_field_mappings.unwrap_or_default();
            v.push(input);
            self.message_field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip messages to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
        pub fn set_message_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.message_field_mappings = input;
            self
        }
        /// Appends an item to `attachment_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_attachment_field_mappings`](Self::set_attachment_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
        pub fn attachment_field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.attachment_field_mappings.unwrap_or_default();
            v.push(input);
            self.attachment_field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Quip attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Quip fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Quip field names must exist in your Quip custom metadata.</p>
        pub fn set_attachment_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.attachment_field_mappings = input;
            self
        }
        /// Appends an item to `inclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_inclusion_patterns`](Self::set_inclusion_patterns).
        ///
        /// <p>A list of regular expression patterns to include certain files in your Quip file system. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence, and the file isn't included in the index.</p>
        pub fn inclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.inclusion_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to include certain files in your Quip file system. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence, and the file isn't included in the index.</p>
        pub fn set_inclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inclusion_patterns = input;
            self
        }
        /// Appends an item to `exclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_exclusion_patterns`](Self::set_exclusion_patterns).
        ///
        /// <p>A list of regular expression patterns to exclude certain files in your Quip file system. Files that match the patterns are excluded from the index. Files that don’t match the patterns are included in the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence, and the file isn't included in the index.</p>
        pub fn exclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.exclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.exclusion_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to exclude certain files in your Quip file system. Files that match the patterns are excluded from the index. Files that don’t match the patterns are included in the index. If a file matches both an inclusion pattern and an exclusion pattern, the exclusion pattern takes precedence, and the file isn't included in the index.</p>
        pub fn set_exclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclusion_patterns = input;
            self
        }
        /// <p>Configuration information for an Amazon Virtual Private Cloud (VPC) to connect to your Quip. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
        pub fn vpc_configuration(
            mut self,
            input: crate::model::DataSourceVpcConfiguration,
        ) -> Self {
            self.vpc_configuration = Some(input);
            self
        }
        /// <p>Configuration information for an Amazon Virtual Private Cloud (VPC) to connect to your Quip. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
        pub fn set_vpc_configuration(
            mut self,
            input: std::option::Option<crate::model::DataSourceVpcConfiguration>,
        ) -> Self {
            self.vpc_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`QuipConfiguration`](crate::model::QuipConfiguration).
        pub fn build(self) -> crate::model::QuipConfiguration {
            crate::model::QuipConfiguration {
                domain: self.domain,
                secret_arn: self.secret_arn,
                crawl_file_comments: self.crawl_file_comments.unwrap_or_default(),
                crawl_chat_rooms: self.crawl_chat_rooms.unwrap_or_default(),
                crawl_attachments: self.crawl_attachments.unwrap_or_default(),
                folder_ids: self.folder_ids,
                thread_field_mappings: self.thread_field_mappings,
                message_field_mappings: self.message_field_mappings,
                attachment_field_mappings: self.attachment_field_mappings,
                inclusion_patterns: self.inclusion_patterns,
                exclusion_patterns: self.exclusion_patterns,
                vpc_configuration: self.vpc_configuration,
            }
        }
    }
}
impl QuipConfiguration {
    /// Creates a new builder-style object to manufacture [`QuipConfiguration`](crate::model::QuipConfiguration).
    pub fn builder() -> crate::model::quip_configuration::Builder {
        crate::model::quip_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information to connect to Box as your data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BoxConfiguration {
    /// <p>The identifier of the Box Enterprise platform. You can find the enterprise ID in the Box Developer Console settings or when you create an app in Box and download your authentication credentials. For example, <i>801234567</i>.</p>
    #[doc(hidden)]
    pub enterprise_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs required to connect to your Box platform. The secret must contain a JSON structure with the following keys:</p>
    /// <ul>
    /// <li> <p>clientID—The identifier of the client OAuth 2.0 authentication application created in Box.</p> </li>
    /// <li> <p>clientSecret—A set of characters known only to the OAuth 2.0 authentication application created in Box.</p> </li>
    /// <li> <p>publicKeyId—The identifier of the public key contained within an identity certificate.</p> </li>
    /// <li> <p>privateKey—A set of characters that make up an encryption key.</p> </li>
    /// <li> <p>passphrase—A set of characters that act like a password.</p> </li>
    /// </ul>
    /// <p>You create an application in Box to generate the keys or credentials required for the secret. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-box.html">Using a Box data source</a>.</p>
    #[doc(hidden)]
    pub secret_arn: std::option::Option<std::string::String>,
    /// <p> <code>TRUE</code> to use the Slack change log to determine which documents require updating in the index. Depending on the data source change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents.</p>
    #[doc(hidden)]
    pub use_change_log: bool,
    /// <p> <code>TRUE</code> to index comments.</p>
    #[doc(hidden)]
    pub crawl_comments: bool,
    /// <p> <code>TRUE</code> to index the contents of tasks.</p>
    #[doc(hidden)]
    pub crawl_tasks: bool,
    /// <p> <code>TRUE</code> to index web links.</p>
    #[doc(hidden)]
    pub crawl_web_links: bool,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Box files to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Box fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Box field names must exist in your Box custom metadata.</p>
    #[doc(hidden)]
    pub file_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Box tasks to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Box fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Box field names must exist in your Box custom metadata.</p>
    #[doc(hidden)]
    pub task_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Box comments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Box fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Box field names must exist in your Box custom metadata.</p>
    #[doc(hidden)]
    pub comment_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Box web links to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Box fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Box field names must exist in your Box custom metadata.</p>
    #[doc(hidden)]
    pub web_link_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>A list of regular expression patterns to include certain files and folders in your Box platform. Files and folders that match the patterns are included in the index. Files and folders that don't match the patterns are excluded from the index. If a file or folder matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file or folder isn't included in the index.</p>
    #[doc(hidden)]
    pub inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of regular expression patterns to exclude certain files and folders from your Box platform. Files and folders that match the patterns are excluded from the index.Files and folders that don't match the patterns are included in the index. If a file or folder matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file or folder isn't included in the index.</p>
    #[doc(hidden)]
    pub exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Configuration information for an Amazon VPC to connect to your Box. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
    #[doc(hidden)]
    pub vpc_configuration: std::option::Option<crate::model::DataSourceVpcConfiguration>,
}
impl BoxConfiguration {
    /// <p>The identifier of the Box Enterprise platform. You can find the enterprise ID in the Box Developer Console settings or when you create an app in Box and download your authentication credentials. For example, <i>801234567</i>.</p>
    pub fn enterprise_id(&self) -> std::option::Option<&str> {
        self.enterprise_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs required to connect to your Box platform. The secret must contain a JSON structure with the following keys:</p>
    /// <ul>
    /// <li> <p>clientID—The identifier of the client OAuth 2.0 authentication application created in Box.</p> </li>
    /// <li> <p>clientSecret—A set of characters known only to the OAuth 2.0 authentication application created in Box.</p> </li>
    /// <li> <p>publicKeyId—The identifier of the public key contained within an identity certificate.</p> </li>
    /// <li> <p>privateKey—A set of characters that make up an encryption key.</p> </li>
    /// <li> <p>passphrase—A set of characters that act like a password.</p> </li>
    /// </ul>
    /// <p>You create an application in Box to generate the keys or credentials required for the secret. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-box.html">Using a Box data source</a>.</p>
    pub fn secret_arn(&self) -> std::option::Option<&str> {
        self.secret_arn.as_deref()
    }
    /// <p> <code>TRUE</code> to use the Slack change log to determine which documents require updating in the index. Depending on the data source change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents.</p>
    pub fn use_change_log(&self) -> bool {
        self.use_change_log
    }
    /// <p> <code>TRUE</code> to index comments.</p>
    pub fn crawl_comments(&self) -> bool {
        self.crawl_comments
    }
    /// <p> <code>TRUE</code> to index the contents of tasks.</p>
    pub fn crawl_tasks(&self) -> bool {
        self.crawl_tasks
    }
    /// <p> <code>TRUE</code> to index web links.</p>
    pub fn crawl_web_links(&self) -> bool {
        self.crawl_web_links
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Box files to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Box fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Box field names must exist in your Box custom metadata.</p>
    pub fn file_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.file_field_mappings.as_deref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Box tasks to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Box fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Box field names must exist in your Box custom metadata.</p>
    pub fn task_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.task_field_mappings.as_deref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Box comments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Box fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Box field names must exist in your Box custom metadata.</p>
    pub fn comment_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.comment_field_mappings.as_deref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Box web links to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Box fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Box field names must exist in your Box custom metadata.</p>
    pub fn web_link_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.web_link_field_mappings.as_deref()
    }
    /// <p>A list of regular expression patterns to include certain files and folders in your Box platform. Files and folders that match the patterns are included in the index. Files and folders that don't match the patterns are excluded from the index. If a file or folder matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file or folder isn't included in the index.</p>
    pub fn inclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.inclusion_patterns.as_deref()
    }
    /// <p>A list of regular expression patterns to exclude certain files and folders from your Box platform. Files and folders that match the patterns are excluded from the index.Files and folders that don't match the patterns are included in the index. If a file or folder matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file or folder isn't included in the index.</p>
    pub fn exclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.exclusion_patterns.as_deref()
    }
    /// <p>Configuration information for an Amazon VPC to connect to your Box. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
    pub fn vpc_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DataSourceVpcConfiguration> {
        self.vpc_configuration.as_ref()
    }
}
/// See [`BoxConfiguration`](crate::model::BoxConfiguration).
pub mod box_configuration {

    /// A builder for [`BoxConfiguration`](crate::model::BoxConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enterprise_id: std::option::Option<std::string::String>,
        pub(crate) secret_arn: std::option::Option<std::string::String>,
        pub(crate) use_change_log: std::option::Option<bool>,
        pub(crate) crawl_comments: std::option::Option<bool>,
        pub(crate) crawl_tasks: std::option::Option<bool>,
        pub(crate) crawl_web_links: std::option::Option<bool>,
        pub(crate) file_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) task_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) comment_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) web_link_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) vpc_configuration: std::option::Option<crate::model::DataSourceVpcConfiguration>,
    }
    impl Builder {
        /// <p>The identifier of the Box Enterprise platform. You can find the enterprise ID in the Box Developer Console settings or when you create an app in Box and download your authentication credentials. For example, <i>801234567</i>.</p>
        pub fn enterprise_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.enterprise_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Box Enterprise platform. You can find the enterprise ID in the Box Developer Console settings or when you create an app in Box and download your authentication credentials. For example, <i>801234567</i>.</p>
        pub fn set_enterprise_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.enterprise_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs required to connect to your Box platform. The secret must contain a JSON structure with the following keys:</p>
        /// <ul>
        /// <li> <p>clientID—The identifier of the client OAuth 2.0 authentication application created in Box.</p> </li>
        /// <li> <p>clientSecret—A set of characters known only to the OAuth 2.0 authentication application created in Box.</p> </li>
        /// <li> <p>publicKeyId—The identifier of the public key contained within an identity certificate.</p> </li>
        /// <li> <p>privateKey—A set of characters that make up an encryption key.</p> </li>
        /// <li> <p>passphrase—A set of characters that act like a password.</p> </li>
        /// </ul>
        /// <p>You create an application in Box to generate the keys or credentials required for the secret. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-box.html">Using a Box data source</a>.</p>
        pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs required to connect to your Box platform. The secret must contain a JSON structure with the following keys:</p>
        /// <ul>
        /// <li> <p>clientID—The identifier of the client OAuth 2.0 authentication application created in Box.</p> </li>
        /// <li> <p>clientSecret—A set of characters known only to the OAuth 2.0 authentication application created in Box.</p> </li>
        /// <li> <p>publicKeyId—The identifier of the public key contained within an identity certificate.</p> </li>
        /// <li> <p>privateKey—A set of characters that make up an encryption key.</p> </li>
        /// <li> <p>passphrase—A set of characters that act like a password.</p> </li>
        /// </ul>
        /// <p>You create an application in Box to generate the keys or credentials required for the secret. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-box.html">Using a Box data source</a>.</p>
        pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_arn = input;
            self
        }
        /// <p> <code>TRUE</code> to use the Slack change log to determine which documents require updating in the index. Depending on the data source change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents.</p>
        pub fn use_change_log(mut self, input: bool) -> Self {
            self.use_change_log = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to use the Slack change log to determine which documents require updating in the index. Depending on the data source change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents.</p>
        pub fn set_use_change_log(mut self, input: std::option::Option<bool>) -> Self {
            self.use_change_log = input;
            self
        }
        /// <p> <code>TRUE</code> to index comments.</p>
        pub fn crawl_comments(mut self, input: bool) -> Self {
            self.crawl_comments = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to index comments.</p>
        pub fn set_crawl_comments(mut self, input: std::option::Option<bool>) -> Self {
            self.crawl_comments = input;
            self
        }
        /// <p> <code>TRUE</code> to index the contents of tasks.</p>
        pub fn crawl_tasks(mut self, input: bool) -> Self {
            self.crawl_tasks = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to index the contents of tasks.</p>
        pub fn set_crawl_tasks(mut self, input: std::option::Option<bool>) -> Self {
            self.crawl_tasks = input;
            self
        }
        /// <p> <code>TRUE</code> to index web links.</p>
        pub fn crawl_web_links(mut self, input: bool) -> Self {
            self.crawl_web_links = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to index web links.</p>
        pub fn set_crawl_web_links(mut self, input: std::option::Option<bool>) -> Self {
            self.crawl_web_links = input;
            self
        }
        /// Appends an item to `file_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_file_field_mappings`](Self::set_file_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Box files to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Box fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Box field names must exist in your Box custom metadata.</p>
        pub fn file_field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.file_field_mappings.unwrap_or_default();
            v.push(input);
            self.file_field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Box files to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Box fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Box field names must exist in your Box custom metadata.</p>
        pub fn set_file_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.file_field_mappings = input;
            self
        }
        /// Appends an item to `task_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_task_field_mappings`](Self::set_task_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Box tasks to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Box fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Box field names must exist in your Box custom metadata.</p>
        pub fn task_field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.task_field_mappings.unwrap_or_default();
            v.push(input);
            self.task_field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Box tasks to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Box fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Box field names must exist in your Box custom metadata.</p>
        pub fn set_task_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.task_field_mappings = input;
            self
        }
        /// Appends an item to `comment_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_comment_field_mappings`](Self::set_comment_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Box comments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Box fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Box field names must exist in your Box custom metadata.</p>
        pub fn comment_field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.comment_field_mappings.unwrap_or_default();
            v.push(input);
            self.comment_field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Box comments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Box fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Box field names must exist in your Box custom metadata.</p>
        pub fn set_comment_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.comment_field_mappings = input;
            self
        }
        /// Appends an item to `web_link_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_web_link_field_mappings`](Self::set_web_link_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Box web links to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Box fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Box field names must exist in your Box custom metadata.</p>
        pub fn web_link_field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.web_link_field_mappings.unwrap_or_default();
            v.push(input);
            self.web_link_field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map attributes or field names of Box web links to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Box fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Box field names must exist in your Box custom metadata.</p>
        pub fn set_web_link_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.web_link_field_mappings = input;
            self
        }
        /// Appends an item to `inclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_inclusion_patterns`](Self::set_inclusion_patterns).
        ///
        /// <p>A list of regular expression patterns to include certain files and folders in your Box platform. Files and folders that match the patterns are included in the index. Files and folders that don't match the patterns are excluded from the index. If a file or folder matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file or folder isn't included in the index.</p>
        pub fn inclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.inclusion_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to include certain files and folders in your Box platform. Files and folders that match the patterns are included in the index. Files and folders that don't match the patterns are excluded from the index. If a file or folder matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file or folder isn't included in the index.</p>
        pub fn set_inclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inclusion_patterns = input;
            self
        }
        /// Appends an item to `exclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_exclusion_patterns`](Self::set_exclusion_patterns).
        ///
        /// <p>A list of regular expression patterns to exclude certain files and folders from your Box platform. Files and folders that match the patterns are excluded from the index.Files and folders that don't match the patterns are included in the index. If a file or folder matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file or folder isn't included in the index.</p>
        pub fn exclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.exclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.exclusion_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to exclude certain files and folders from your Box platform. Files and folders that match the patterns are excluded from the index.Files and folders that don't match the patterns are included in the index. If a file or folder matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file or folder isn't included in the index.</p>
        pub fn set_exclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclusion_patterns = input;
            self
        }
        /// <p>Configuration information for an Amazon VPC to connect to your Box. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
        pub fn vpc_configuration(
            mut self,
            input: crate::model::DataSourceVpcConfiguration,
        ) -> Self {
            self.vpc_configuration = Some(input);
            self
        }
        /// <p>Configuration information for an Amazon VPC to connect to your Box. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
        pub fn set_vpc_configuration(
            mut self,
            input: std::option::Option<crate::model::DataSourceVpcConfiguration>,
        ) -> Self {
            self.vpc_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`BoxConfiguration`](crate::model::BoxConfiguration).
        pub fn build(self) -> crate::model::BoxConfiguration {
            crate::model::BoxConfiguration {
                enterprise_id: self.enterprise_id,
                secret_arn: self.secret_arn,
                use_change_log: self.use_change_log.unwrap_or_default(),
                crawl_comments: self.crawl_comments.unwrap_or_default(),
                crawl_tasks: self.crawl_tasks.unwrap_or_default(),
                crawl_web_links: self.crawl_web_links.unwrap_or_default(),
                file_field_mappings: self.file_field_mappings,
                task_field_mappings: self.task_field_mappings,
                comment_field_mappings: self.comment_field_mappings,
                web_link_field_mappings: self.web_link_field_mappings,
                inclusion_patterns: self.inclusion_patterns,
                exclusion_patterns: self.exclusion_patterns,
                vpc_configuration: self.vpc_configuration,
            }
        }
    }
}
impl BoxConfiguration {
    /// Creates a new builder-style object to manufacture [`BoxConfiguration`](crate::model::BoxConfiguration).
    pub fn builder() -> crate::model::box_configuration::Builder {
        crate::model::box_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information to connect to Slack as your data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SlackConfiguration {
    /// <p>The identifier of the team in the Slack workspace. For example, <i>T0123456789</i>.</p>
    /// <p>You can find your team ID in the URL of the main page of your Slack workspace. When you log in to Slack via a browser, you are directed to the URL of the main page. For example, <i>https://app.slack.com/client/<b>T0123456789</b>/...</i>.</p>
    #[doc(hidden)]
    pub team_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs required to connect to your Slack workspace team. The secret must contain a JSON structure with the following keys:</p>
    /// <ul>
    /// <li> <p>slackToken—The user or bot token created in Slack. For more information on creating a token in Slack, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-slack.html#slack-authentication">Authentication for a Slack data source</a>.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub secret_arn: std::option::Option<std::string::String>,
    /// <p>Configuration information for an Amazon Virtual Private Cloud to connect to your Slack. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
    #[doc(hidden)]
    pub vpc_configuration: std::option::Option<crate::model::DataSourceVpcConfiguration>,
    /// <p>Specify whether to index public channels, private channels, group messages, and direct messages. You can specify one or more of these options.</p>
    #[doc(hidden)]
    pub slack_entity_list: std::option::Option<std::vec::Vec<crate::model::SlackEntity>>,
    /// <p> <code>TRUE</code> to use the Slack change log to determine which documents require updating in the index. Depending on the Slack change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents in Slack.</p>
    #[doc(hidden)]
    pub use_change_log: bool,
    /// <p> <code>TRUE</code> to index bot messages from your Slack workspace team.</p>
    #[doc(hidden)]
    pub crawl_bot_message: bool,
    /// <p> <code>TRUE</code> to exclude archived messages to index from your Slack workspace team.</p>
    #[doc(hidden)]
    pub exclude_archived: bool,
    /// <p>The date to start crawling your data from your Slack workspace team. The date must follow this format: <code>yyyy-mm-dd</code>.</p>
    #[doc(hidden)]
    pub since_crawl_date: std::option::Option<std::string::String>,
    /// <p>The number of hours for change log to look back from when you last synchronized your data. You can look back up to 7 days or 168 hours.</p>
    /// <p>Change log updates your index only if new content was added since you last synced your data. Updated or deleted content from before you last synced does not get updated in your index. To capture updated or deleted content before you last synced, set the <code>LookBackPeriod</code> to the number of hours you want change log to look back.</p>
    #[doc(hidden)]
    pub look_back_period: std::option::Option<i32>,
    /// <p>The list of private channel names from your Slack workspace team. You use this if you want to index specific private channels, not all private channels. You can also use regular expression patterns to filter private channels.</p>
    #[doc(hidden)]
    pub private_channel_filter: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The list of public channel names to index from your Slack workspace team. You use this if you want to index specific public channels, not all public channels. You can also use regular expression patterns to filter public channels.</p>
    #[doc(hidden)]
    pub public_channel_filter: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of regular expression patterns to include certain attached files in your Slack workspace team. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    #[doc(hidden)]
    pub inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of regular expression patterns to exclude certain attached files in your Slack workspace team. Files that match the patterns are excluded from the index. Files that don’t match the patterns are included in the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    #[doc(hidden)]
    pub exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map Slack data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Slack fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Slack data source field names must exist in your Slack custom metadata.</p>
    #[doc(hidden)]
    pub field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
}
impl SlackConfiguration {
    /// <p>The identifier of the team in the Slack workspace. For example, <i>T0123456789</i>.</p>
    /// <p>You can find your team ID in the URL of the main page of your Slack workspace. When you log in to Slack via a browser, you are directed to the URL of the main page. For example, <i>https://app.slack.com/client/<b>T0123456789</b>/...</i>.</p>
    pub fn team_id(&self) -> std::option::Option<&str> {
        self.team_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs required to connect to your Slack workspace team. The secret must contain a JSON structure with the following keys:</p>
    /// <ul>
    /// <li> <p>slackToken—The user or bot token created in Slack. For more information on creating a token in Slack, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-slack.html#slack-authentication">Authentication for a Slack data source</a>.</p> </li>
    /// </ul>
    pub fn secret_arn(&self) -> std::option::Option<&str> {
        self.secret_arn.as_deref()
    }
    /// <p>Configuration information for an Amazon Virtual Private Cloud to connect to your Slack. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
    pub fn vpc_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DataSourceVpcConfiguration> {
        self.vpc_configuration.as_ref()
    }
    /// <p>Specify whether to index public channels, private channels, group messages, and direct messages. You can specify one or more of these options.</p>
    pub fn slack_entity_list(&self) -> std::option::Option<&[crate::model::SlackEntity]> {
        self.slack_entity_list.as_deref()
    }
    /// <p> <code>TRUE</code> to use the Slack change log to determine which documents require updating in the index. Depending on the Slack change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents in Slack.</p>
    pub fn use_change_log(&self) -> bool {
        self.use_change_log
    }
    /// <p> <code>TRUE</code> to index bot messages from your Slack workspace team.</p>
    pub fn crawl_bot_message(&self) -> bool {
        self.crawl_bot_message
    }
    /// <p> <code>TRUE</code> to exclude archived messages to index from your Slack workspace team.</p>
    pub fn exclude_archived(&self) -> bool {
        self.exclude_archived
    }
    /// <p>The date to start crawling your data from your Slack workspace team. The date must follow this format: <code>yyyy-mm-dd</code>.</p>
    pub fn since_crawl_date(&self) -> std::option::Option<&str> {
        self.since_crawl_date.as_deref()
    }
    /// <p>The number of hours for change log to look back from when you last synchronized your data. You can look back up to 7 days or 168 hours.</p>
    /// <p>Change log updates your index only if new content was added since you last synced your data. Updated or deleted content from before you last synced does not get updated in your index. To capture updated or deleted content before you last synced, set the <code>LookBackPeriod</code> to the number of hours you want change log to look back.</p>
    pub fn look_back_period(&self) -> std::option::Option<i32> {
        self.look_back_period
    }
    /// <p>The list of private channel names from your Slack workspace team. You use this if you want to index specific private channels, not all private channels. You can also use regular expression patterns to filter private channels.</p>
    pub fn private_channel_filter(&self) -> std::option::Option<&[std::string::String]> {
        self.private_channel_filter.as_deref()
    }
    /// <p>The list of public channel names to index from your Slack workspace team. You use this if you want to index specific public channels, not all public channels. You can also use regular expression patterns to filter public channels.</p>
    pub fn public_channel_filter(&self) -> std::option::Option<&[std::string::String]> {
        self.public_channel_filter.as_deref()
    }
    /// <p>A list of regular expression patterns to include certain attached files in your Slack workspace team. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    pub fn inclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.inclusion_patterns.as_deref()
    }
    /// <p>A list of regular expression patterns to exclude certain attached files in your Slack workspace team. Files that match the patterns are excluded from the index. Files that don’t match the patterns are included in the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    pub fn exclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.exclusion_patterns.as_deref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map Slack data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Slack fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Slack data source field names must exist in your Slack custom metadata.</p>
    pub fn field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.field_mappings.as_deref()
    }
}
/// See [`SlackConfiguration`](crate::model::SlackConfiguration).
pub mod slack_configuration {

    /// A builder for [`SlackConfiguration`](crate::model::SlackConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) team_id: std::option::Option<std::string::String>,
        pub(crate) secret_arn: std::option::Option<std::string::String>,
        pub(crate) vpc_configuration: std::option::Option<crate::model::DataSourceVpcConfiguration>,
        pub(crate) slack_entity_list: std::option::Option<std::vec::Vec<crate::model::SlackEntity>>,
        pub(crate) use_change_log: std::option::Option<bool>,
        pub(crate) crawl_bot_message: std::option::Option<bool>,
        pub(crate) exclude_archived: std::option::Option<bool>,
        pub(crate) since_crawl_date: std::option::Option<std::string::String>,
        pub(crate) look_back_period: std::option::Option<i32>,
        pub(crate) private_channel_filter: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) public_channel_filter: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    }
    impl Builder {
        /// <p>The identifier of the team in the Slack workspace. For example, <i>T0123456789</i>.</p>
        /// <p>You can find your team ID in the URL of the main page of your Slack workspace. When you log in to Slack via a browser, you are directed to the URL of the main page. For example, <i>https://app.slack.com/client/<b>T0123456789</b>/...</i>.</p>
        pub fn team_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.team_id = Some(input.into());
            self
        }
        /// <p>The identifier of the team in the Slack workspace. For example, <i>T0123456789</i>.</p>
        /// <p>You can find your team ID in the URL of the main page of your Slack workspace. When you log in to Slack via a browser, you are directed to the URL of the main page. For example, <i>https://app.slack.com/client/<b>T0123456789</b>/...</i>.</p>
        pub fn set_team_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.team_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs required to connect to your Slack workspace team. The secret must contain a JSON structure with the following keys:</p>
        /// <ul>
        /// <li> <p>slackToken—The user or bot token created in Slack. For more information on creating a token in Slack, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-slack.html#slack-authentication">Authentication for a Slack data source</a>.</p> </li>
        /// </ul>
        pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs required to connect to your Slack workspace team. The secret must contain a JSON structure with the following keys:</p>
        /// <ul>
        /// <li> <p>slackToken—The user or bot token created in Slack. For more information on creating a token in Slack, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-slack.html#slack-authentication">Authentication for a Slack data source</a>.</p> </li>
        /// </ul>
        pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_arn = input;
            self
        }
        /// <p>Configuration information for an Amazon Virtual Private Cloud to connect to your Slack. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
        pub fn vpc_configuration(
            mut self,
            input: crate::model::DataSourceVpcConfiguration,
        ) -> Self {
            self.vpc_configuration = Some(input);
            self
        }
        /// <p>Configuration information for an Amazon Virtual Private Cloud to connect to your Slack. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
        pub fn set_vpc_configuration(
            mut self,
            input: std::option::Option<crate::model::DataSourceVpcConfiguration>,
        ) -> Self {
            self.vpc_configuration = input;
            self
        }
        /// Appends an item to `slack_entity_list`.
        ///
        /// To override the contents of this collection use [`set_slack_entity_list`](Self::set_slack_entity_list).
        ///
        /// <p>Specify whether to index public channels, private channels, group messages, and direct messages. You can specify one or more of these options.</p>
        pub fn slack_entity_list(mut self, input: crate::model::SlackEntity) -> Self {
            let mut v = self.slack_entity_list.unwrap_or_default();
            v.push(input);
            self.slack_entity_list = Some(v);
            self
        }
        /// <p>Specify whether to index public channels, private channels, group messages, and direct messages. You can specify one or more of these options.</p>
        pub fn set_slack_entity_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SlackEntity>>,
        ) -> Self {
            self.slack_entity_list = input;
            self
        }
        /// <p> <code>TRUE</code> to use the Slack change log to determine which documents require updating in the index. Depending on the Slack change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents in Slack.</p>
        pub fn use_change_log(mut self, input: bool) -> Self {
            self.use_change_log = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to use the Slack change log to determine which documents require updating in the index. Depending on the Slack change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents in Slack.</p>
        pub fn set_use_change_log(mut self, input: std::option::Option<bool>) -> Self {
            self.use_change_log = input;
            self
        }
        /// <p> <code>TRUE</code> to index bot messages from your Slack workspace team.</p>
        pub fn crawl_bot_message(mut self, input: bool) -> Self {
            self.crawl_bot_message = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to index bot messages from your Slack workspace team.</p>
        pub fn set_crawl_bot_message(mut self, input: std::option::Option<bool>) -> Self {
            self.crawl_bot_message = input;
            self
        }
        /// <p> <code>TRUE</code> to exclude archived messages to index from your Slack workspace team.</p>
        pub fn exclude_archived(mut self, input: bool) -> Self {
            self.exclude_archived = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to exclude archived messages to index from your Slack workspace team.</p>
        pub fn set_exclude_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.exclude_archived = input;
            self
        }
        /// <p>The date to start crawling your data from your Slack workspace team. The date must follow this format: <code>yyyy-mm-dd</code>.</p>
        pub fn since_crawl_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.since_crawl_date = Some(input.into());
            self
        }
        /// <p>The date to start crawling your data from your Slack workspace team. The date must follow this format: <code>yyyy-mm-dd</code>.</p>
        pub fn set_since_crawl_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.since_crawl_date = input;
            self
        }
        /// <p>The number of hours for change log to look back from when you last synchronized your data. You can look back up to 7 days or 168 hours.</p>
        /// <p>Change log updates your index only if new content was added since you last synced your data. Updated or deleted content from before you last synced does not get updated in your index. To capture updated or deleted content before you last synced, set the <code>LookBackPeriod</code> to the number of hours you want change log to look back.</p>
        pub fn look_back_period(mut self, input: i32) -> Self {
            self.look_back_period = Some(input);
            self
        }
        /// <p>The number of hours for change log to look back from when you last synchronized your data. You can look back up to 7 days or 168 hours.</p>
        /// <p>Change log updates your index only if new content was added since you last synced your data. Updated or deleted content from before you last synced does not get updated in your index. To capture updated or deleted content before you last synced, set the <code>LookBackPeriod</code> to the number of hours you want change log to look back.</p>
        pub fn set_look_back_period(mut self, input: std::option::Option<i32>) -> Self {
            self.look_back_period = input;
            self
        }
        /// Appends an item to `private_channel_filter`.
        ///
        /// To override the contents of this collection use [`set_private_channel_filter`](Self::set_private_channel_filter).
        ///
        /// <p>The list of private channel names from your Slack workspace team. You use this if you want to index specific private channels, not all private channels. You can also use regular expression patterns to filter private channels.</p>
        pub fn private_channel_filter(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.private_channel_filter.unwrap_or_default();
            v.push(input.into());
            self.private_channel_filter = Some(v);
            self
        }
        /// <p>The list of private channel names from your Slack workspace team. You use this if you want to index specific private channels, not all private channels. You can also use regular expression patterns to filter private channels.</p>
        pub fn set_private_channel_filter(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.private_channel_filter = input;
            self
        }
        /// Appends an item to `public_channel_filter`.
        ///
        /// To override the contents of this collection use [`set_public_channel_filter`](Self::set_public_channel_filter).
        ///
        /// <p>The list of public channel names to index from your Slack workspace team. You use this if you want to index specific public channels, not all public channels. You can also use regular expression patterns to filter public channels.</p>
        pub fn public_channel_filter(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.public_channel_filter.unwrap_or_default();
            v.push(input.into());
            self.public_channel_filter = Some(v);
            self
        }
        /// <p>The list of public channel names to index from your Slack workspace team. You use this if you want to index specific public channels, not all public channels. You can also use regular expression patterns to filter public channels.</p>
        pub fn set_public_channel_filter(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.public_channel_filter = input;
            self
        }
        /// Appends an item to `inclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_inclusion_patterns`](Self::set_inclusion_patterns).
        ///
        /// <p>A list of regular expression patterns to include certain attached files in your Slack workspace team. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn inclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.inclusion_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to include certain attached files in your Slack workspace team. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn set_inclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inclusion_patterns = input;
            self
        }
        /// Appends an item to `exclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_exclusion_patterns`](Self::set_exclusion_patterns).
        ///
        /// <p>A list of regular expression patterns to exclude certain attached files in your Slack workspace team. Files that match the patterns are excluded from the index. Files that don’t match the patterns are included in the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn exclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.exclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.exclusion_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to exclude certain attached files in your Slack workspace team. Files that match the patterns are excluded from the index. Files that don’t match the patterns are included in the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn set_exclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclusion_patterns = input;
            self
        }
        /// Appends an item to `field_mappings`.
        ///
        /// To override the contents of this collection use [`set_field_mappings`](Self::set_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map Slack data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Slack fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Slack data source field names must exist in your Slack custom metadata.</p>
        pub fn field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.field_mappings.unwrap_or_default();
            v.push(input);
            self.field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map Slack data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Slack fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Slack data source field names must exist in your Slack custom metadata.</p>
        pub fn set_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.field_mappings = input;
            self
        }
        /// Consumes the builder and constructs a [`SlackConfiguration`](crate::model::SlackConfiguration).
        pub fn build(self) -> crate::model::SlackConfiguration {
            crate::model::SlackConfiguration {
                team_id: self.team_id,
                secret_arn: self.secret_arn,
                vpc_configuration: self.vpc_configuration,
                slack_entity_list: self.slack_entity_list,
                use_change_log: self.use_change_log.unwrap_or_default(),
                crawl_bot_message: self.crawl_bot_message.unwrap_or_default(),
                exclude_archived: self.exclude_archived.unwrap_or_default(),
                since_crawl_date: self.since_crawl_date,
                look_back_period: self.look_back_period,
                private_channel_filter: self.private_channel_filter,
                public_channel_filter: self.public_channel_filter,
                inclusion_patterns: self.inclusion_patterns,
                exclusion_patterns: self.exclusion_patterns,
                field_mappings: self.field_mappings,
            }
        }
    }
}
impl SlackConfiguration {
    /// Creates a new builder-style object to manufacture [`SlackConfiguration`](crate::model::SlackConfiguration).
    pub fn builder() -> crate::model::slack_configuration::Builder {
        crate::model::slack_configuration::Builder::default()
    }
}

/// When writing a match expression against `SlackEntity`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let slackentity = unimplemented!();
/// match slackentity {
///     SlackEntity::DirectMessage => { /* ... */ },
///     SlackEntity::GroupMessage => { /* ... */ },
///     SlackEntity::PrivateChannel => { /* ... */ },
///     SlackEntity::PublicChannel => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `slackentity` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SlackEntity::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SlackEntity::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SlackEntity::NewFeature` is defined.
/// Specifically, when `slackentity` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SlackEntity::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SlackEntity {
    #[allow(missing_docs)] // documentation missing in model
    DirectMessage,
    #[allow(missing_docs)] // documentation missing in model
    GroupMessage,
    #[allow(missing_docs)] // documentation missing in model
    PrivateChannel,
    #[allow(missing_docs)] // documentation missing in model
    PublicChannel,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SlackEntity {
    fn from(s: &str) -> Self {
        match s {
            "DIRECT_MESSAGE" => SlackEntity::DirectMessage,
            "GROUP_MESSAGE" => SlackEntity::GroupMessage,
            "PRIVATE_CHANNEL" => SlackEntity::PrivateChannel,
            "PUBLIC_CHANNEL" => SlackEntity::PublicChannel,
            other => SlackEntity::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SlackEntity {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SlackEntity::from(s))
    }
}
impl SlackEntity {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SlackEntity::DirectMessage => "DIRECT_MESSAGE",
            SlackEntity::GroupMessage => "GROUP_MESSAGE",
            SlackEntity::PrivateChannel => "PRIVATE_CHANNEL",
            SlackEntity::PublicChannel => "PUBLIC_CHANNEL",
            SlackEntity::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DIRECT_MESSAGE",
            "GROUP_MESSAGE",
            "PRIVATE_CHANNEL",
            "PUBLIC_CHANNEL",
        ]
    }
}
impl AsRef<str> for SlackEntity {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides the configuration information to connect to Amazon FSx as your data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FsxConfiguration {
    /// <p>The identifier of the Amazon FSx file system.</p>
    /// <p>You can find your file system ID on the file system dashboard in the Amazon FSx console. For information on how to create a file system in Amazon FSx console, using Windows File Server as an example, see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/getting-started-step1.html">Amazon FSx Getting started guide</a>.</p>
    #[doc(hidden)]
    pub file_system_id: std::option::Option<std::string::String>,
    /// <p>The Amazon FSx file system type. Windows is currently the only supported type.</p>
    #[doc(hidden)]
    pub file_system_type: std::option::Option<crate::model::FsxFileSystemType>,
    /// <p>Configuration information for an Amazon Virtual Private Cloud to connect to your Amazon FSx. Your Amazon FSx instance must reside inside your VPC.</p>
    #[doc(hidden)]
    pub vpc_configuration: std::option::Option<crate::model::DataSourceVpcConfiguration>,
    /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs required to connect to your Amazon FSx file system. Windows is currently the only supported type. The secret must contain a JSON structure with the following keys:</p>
    /// <ul>
    /// <li> <p>username—The Active Directory user name, along with the Domain Name System (DNS) domain name. For example, <i>user@corp.example.com</i>. The Active Directory user account must have read and mounting access to the Amazon FSx file system for Windows.</p> </li>
    /// <li> <p>password—The password of the Active Directory user account with read and mounting access to the Amazon FSx Windows file system.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub secret_arn: std::option::Option<std::string::String>,
    /// <p>A list of regular expression patterns to include certain files in your Amazon FSx file system. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    #[doc(hidden)]
    pub inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of regular expression patterns to exclude certain files in your Amazon FSx file system. Files that match the patterns are excluded from the index. Files that don't match the patterns are included in the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    #[doc(hidden)]
    pub exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map Amazon FSx data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Amazon FSx fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Amazon FSx data source field names must exist in your Amazon FSx custom metadata.</p>
    #[doc(hidden)]
    pub field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
}
impl FsxConfiguration {
    /// <p>The identifier of the Amazon FSx file system.</p>
    /// <p>You can find your file system ID on the file system dashboard in the Amazon FSx console. For information on how to create a file system in Amazon FSx console, using Windows File Server as an example, see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/getting-started-step1.html">Amazon FSx Getting started guide</a>.</p>
    pub fn file_system_id(&self) -> std::option::Option<&str> {
        self.file_system_id.as_deref()
    }
    /// <p>The Amazon FSx file system type. Windows is currently the only supported type.</p>
    pub fn file_system_type(&self) -> std::option::Option<&crate::model::FsxFileSystemType> {
        self.file_system_type.as_ref()
    }
    /// <p>Configuration information for an Amazon Virtual Private Cloud to connect to your Amazon FSx. Your Amazon FSx instance must reside inside your VPC.</p>
    pub fn vpc_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DataSourceVpcConfiguration> {
        self.vpc_configuration.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs required to connect to your Amazon FSx file system. Windows is currently the only supported type. The secret must contain a JSON structure with the following keys:</p>
    /// <ul>
    /// <li> <p>username—The Active Directory user name, along with the Domain Name System (DNS) domain name. For example, <i>user@corp.example.com</i>. The Active Directory user account must have read and mounting access to the Amazon FSx file system for Windows.</p> </li>
    /// <li> <p>password—The password of the Active Directory user account with read and mounting access to the Amazon FSx Windows file system.</p> </li>
    /// </ul>
    pub fn secret_arn(&self) -> std::option::Option<&str> {
        self.secret_arn.as_deref()
    }
    /// <p>A list of regular expression patterns to include certain files in your Amazon FSx file system. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    pub fn inclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.inclusion_patterns.as_deref()
    }
    /// <p>A list of regular expression patterns to exclude certain files in your Amazon FSx file system. Files that match the patterns are excluded from the index. Files that don't match the patterns are included in the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    pub fn exclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.exclusion_patterns.as_deref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map Amazon FSx data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Amazon FSx fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Amazon FSx data source field names must exist in your Amazon FSx custom metadata.</p>
    pub fn field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.field_mappings.as_deref()
    }
}
/// See [`FsxConfiguration`](crate::model::FsxConfiguration).
pub mod fsx_configuration {

    /// A builder for [`FsxConfiguration`](crate::model::FsxConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) file_system_id: std::option::Option<std::string::String>,
        pub(crate) file_system_type: std::option::Option<crate::model::FsxFileSystemType>,
        pub(crate) vpc_configuration: std::option::Option<crate::model::DataSourceVpcConfiguration>,
        pub(crate) secret_arn: std::option::Option<std::string::String>,
        pub(crate) inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon FSx file system.</p>
        /// <p>You can find your file system ID on the file system dashboard in the Amazon FSx console. For information on how to create a file system in Amazon FSx console, using Windows File Server as an example, see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/getting-started-step1.html">Amazon FSx Getting started guide</a>.</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_system_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon FSx file system.</p>
        /// <p>You can find your file system ID on the file system dashboard in the Amazon FSx console. For information on how to create a file system in Amazon FSx console, using Windows File Server as an example, see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/getting-started-step1.html">Amazon FSx Getting started guide</a>.</p>
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.file_system_id = input;
            self
        }
        /// <p>The Amazon FSx file system type. Windows is currently the only supported type.</p>
        pub fn file_system_type(mut self, input: crate::model::FsxFileSystemType) -> Self {
            self.file_system_type = Some(input);
            self
        }
        /// <p>The Amazon FSx file system type. Windows is currently the only supported type.</p>
        pub fn set_file_system_type(
            mut self,
            input: std::option::Option<crate::model::FsxFileSystemType>,
        ) -> Self {
            self.file_system_type = input;
            self
        }
        /// <p>Configuration information for an Amazon Virtual Private Cloud to connect to your Amazon FSx. Your Amazon FSx instance must reside inside your VPC.</p>
        pub fn vpc_configuration(
            mut self,
            input: crate::model::DataSourceVpcConfiguration,
        ) -> Self {
            self.vpc_configuration = Some(input);
            self
        }
        /// <p>Configuration information for an Amazon Virtual Private Cloud to connect to your Amazon FSx. Your Amazon FSx instance must reside inside your VPC.</p>
        pub fn set_vpc_configuration(
            mut self,
            input: std::option::Option<crate::model::DataSourceVpcConfiguration>,
        ) -> Self {
            self.vpc_configuration = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs required to connect to your Amazon FSx file system. Windows is currently the only supported type. The secret must contain a JSON structure with the following keys:</p>
        /// <ul>
        /// <li> <p>username—The Active Directory user name, along with the Domain Name System (DNS) domain name. For example, <i>user@corp.example.com</i>. The Active Directory user account must have read and mounting access to the Amazon FSx file system for Windows.</p> </li>
        /// <li> <p>password—The password of the Active Directory user account with read and mounting access to the Amazon FSx Windows file system.</p> </li>
        /// </ul>
        pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the key-value pairs required to connect to your Amazon FSx file system. Windows is currently the only supported type. The secret must contain a JSON structure with the following keys:</p>
        /// <ul>
        /// <li> <p>username—The Active Directory user name, along with the Domain Name System (DNS) domain name. For example, <i>user@corp.example.com</i>. The Active Directory user account must have read and mounting access to the Amazon FSx file system for Windows.</p> </li>
        /// <li> <p>password—The password of the Active Directory user account with read and mounting access to the Amazon FSx Windows file system.</p> </li>
        /// </ul>
        pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_arn = input;
            self
        }
        /// Appends an item to `inclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_inclusion_patterns`](Self::set_inclusion_patterns).
        ///
        /// <p>A list of regular expression patterns to include certain files in your Amazon FSx file system. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn inclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.inclusion_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to include certain files in your Amazon FSx file system. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn set_inclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inclusion_patterns = input;
            self
        }
        /// Appends an item to `exclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_exclusion_patterns`](Self::set_exclusion_patterns).
        ///
        /// <p>A list of regular expression patterns to exclude certain files in your Amazon FSx file system. Files that match the patterns are excluded from the index. Files that don't match the patterns are included in the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn exclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.exclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.exclusion_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to exclude certain files in your Amazon FSx file system. Files that match the patterns are excluded from the index. Files that don't match the patterns are included in the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn set_exclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclusion_patterns = input;
            self
        }
        /// Appends an item to `field_mappings`.
        ///
        /// To override the contents of this collection use [`set_field_mappings`](Self::set_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map Amazon FSx data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Amazon FSx fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Amazon FSx data source field names must exist in your Amazon FSx custom metadata.</p>
        pub fn field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.field_mappings.unwrap_or_default();
            v.push(input);
            self.field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map Amazon FSx data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Amazon FSx fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Amazon FSx data source field names must exist in your Amazon FSx custom metadata.</p>
        pub fn set_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.field_mappings = input;
            self
        }
        /// Consumes the builder and constructs a [`FsxConfiguration`](crate::model::FsxConfiguration).
        pub fn build(self) -> crate::model::FsxConfiguration {
            crate::model::FsxConfiguration {
                file_system_id: self.file_system_id,
                file_system_type: self.file_system_type,
                vpc_configuration: self.vpc_configuration,
                secret_arn: self.secret_arn,
                inclusion_patterns: self.inclusion_patterns,
                exclusion_patterns: self.exclusion_patterns,
                field_mappings: self.field_mappings,
            }
        }
    }
}
impl FsxConfiguration {
    /// Creates a new builder-style object to manufacture [`FsxConfiguration`](crate::model::FsxConfiguration).
    pub fn builder() -> crate::model::fsx_configuration::Builder {
        crate::model::fsx_configuration::Builder::default()
    }
}

/// When writing a match expression against `FsxFileSystemType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let fsxfilesystemtype = unimplemented!();
/// match fsxfilesystemtype {
///     FsxFileSystemType::Windows => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `fsxfilesystemtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FsxFileSystemType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FsxFileSystemType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FsxFileSystemType::NewFeature` is defined.
/// Specifically, when `fsxfilesystemtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FsxFileSystemType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FsxFileSystemType {
    #[allow(missing_docs)] // documentation missing in model
    Windows,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FsxFileSystemType {
    fn from(s: &str) -> Self {
        match s {
            "WINDOWS" => FsxFileSystemType::Windows,
            other => {
                FsxFileSystemType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for FsxFileSystemType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FsxFileSystemType::from(s))
    }
}
impl FsxFileSystemType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FsxFileSystemType::Windows => "WINDOWS",
            FsxFileSystemType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["WINDOWS"]
    }
}
impl AsRef<str> for FsxFileSystemType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides the configuration information to connect to Amazon WorkDocs as your data source.</p>
/// <p>Amazon WorkDocs connector is available in Oregon, North Virginia, Sydney, Singapore and Ireland regions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkDocsConfiguration {
    /// <p>The identifier of the directory corresponding to your Amazon WorkDocs site repository.</p>
    /// <p>You can find the organization ID in the <a href="https://console.aws.amazon.com/directoryservicev2/">Directory Service</a> by going to <b>Active Directory</b>, then <b>Directories</b>. Your Amazon WorkDocs site directory has an ID, which is the organization ID. You can also set up a new Amazon WorkDocs directory in the Directory Service console and enable a Amazon WorkDocs site for the directory in the Amazon WorkDocs console.</p>
    #[doc(hidden)]
    pub organization_id: std::option::Option<std::string::String>,
    /// <p> <code>TRUE</code> to include comments on documents in your index. Including comments in your index means each comment is a document that can be searched on.</p>
    /// <p>The default is set to <code>FALSE</code>.</p>
    #[doc(hidden)]
    pub crawl_comments: bool,
    /// <p> <code>TRUE</code> to use the Amazon WorkDocs change log to determine which documents require updating in the index. Depending on the change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents in Amazon WorkDocs.</p>
    #[doc(hidden)]
    pub use_change_log: bool,
    /// <p>A list of regular expression patterns to include certain files in your Amazon WorkDocs site repository. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    #[doc(hidden)]
    pub inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of regular expression patterns to exclude certain files in your Amazon WorkDocs site repository. Files that match the patterns are excluded from the index. Files that don’t match the patterns are included in the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    #[doc(hidden)]
    pub exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map Amazon WorkDocs data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Amazon WorkDocs fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Amazon WorkDocs data source field names must exist in your Amazon WorkDocs custom metadata.</p>
    #[doc(hidden)]
    pub field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
}
impl WorkDocsConfiguration {
    /// <p>The identifier of the directory corresponding to your Amazon WorkDocs site repository.</p>
    /// <p>You can find the organization ID in the <a href="https://console.aws.amazon.com/directoryservicev2/">Directory Service</a> by going to <b>Active Directory</b>, then <b>Directories</b>. Your Amazon WorkDocs site directory has an ID, which is the organization ID. You can also set up a new Amazon WorkDocs directory in the Directory Service console and enable a Amazon WorkDocs site for the directory in the Amazon WorkDocs console.</p>
    pub fn organization_id(&self) -> std::option::Option<&str> {
        self.organization_id.as_deref()
    }
    /// <p> <code>TRUE</code> to include comments on documents in your index. Including comments in your index means each comment is a document that can be searched on.</p>
    /// <p>The default is set to <code>FALSE</code>.</p>
    pub fn crawl_comments(&self) -> bool {
        self.crawl_comments
    }
    /// <p> <code>TRUE</code> to use the Amazon WorkDocs change log to determine which documents require updating in the index. Depending on the change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents in Amazon WorkDocs.</p>
    pub fn use_change_log(&self) -> bool {
        self.use_change_log
    }
    /// <p>A list of regular expression patterns to include certain files in your Amazon WorkDocs site repository. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    pub fn inclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.inclusion_patterns.as_deref()
    }
    /// <p>A list of regular expression patterns to exclude certain files in your Amazon WorkDocs site repository. Files that match the patterns are excluded from the index. Files that don’t match the patterns are included in the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
    pub fn exclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.exclusion_patterns.as_deref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map Amazon WorkDocs data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Amazon WorkDocs fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Amazon WorkDocs data source field names must exist in your Amazon WorkDocs custom metadata.</p>
    pub fn field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.field_mappings.as_deref()
    }
}
/// See [`WorkDocsConfiguration`](crate::model::WorkDocsConfiguration).
pub mod work_docs_configuration {

    /// A builder for [`WorkDocsConfiguration`](crate::model::WorkDocsConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) organization_id: std::option::Option<std::string::String>,
        pub(crate) crawl_comments: std::option::Option<bool>,
        pub(crate) use_change_log: std::option::Option<bool>,
        pub(crate) inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    }
    impl Builder {
        /// <p>The identifier of the directory corresponding to your Amazon WorkDocs site repository.</p>
        /// <p>You can find the organization ID in the <a href="https://console.aws.amazon.com/directoryservicev2/">Directory Service</a> by going to <b>Active Directory</b>, then <b>Directories</b>. Your Amazon WorkDocs site directory has an ID, which is the organization ID. You can also set up a new Amazon WorkDocs directory in the Directory Service console and enable a Amazon WorkDocs site for the directory in the Amazon WorkDocs console.</p>
        pub fn organization_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.organization_id = Some(input.into());
            self
        }
        /// <p>The identifier of the directory corresponding to your Amazon WorkDocs site repository.</p>
        /// <p>You can find the organization ID in the <a href="https://console.aws.amazon.com/directoryservicev2/">Directory Service</a> by going to <b>Active Directory</b>, then <b>Directories</b>. Your Amazon WorkDocs site directory has an ID, which is the organization ID. You can also set up a new Amazon WorkDocs directory in the Directory Service console and enable a Amazon WorkDocs site for the directory in the Amazon WorkDocs console.</p>
        pub fn set_organization_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.organization_id = input;
            self
        }
        /// <p> <code>TRUE</code> to include comments on documents in your index. Including comments in your index means each comment is a document that can be searched on.</p>
        /// <p>The default is set to <code>FALSE</code>.</p>
        pub fn crawl_comments(mut self, input: bool) -> Self {
            self.crawl_comments = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to include comments on documents in your index. Including comments in your index means each comment is a document that can be searched on.</p>
        /// <p>The default is set to <code>FALSE</code>.</p>
        pub fn set_crawl_comments(mut self, input: std::option::Option<bool>) -> Self {
            self.crawl_comments = input;
            self
        }
        /// <p> <code>TRUE</code> to use the Amazon WorkDocs change log to determine which documents require updating in the index. Depending on the change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents in Amazon WorkDocs.</p>
        pub fn use_change_log(mut self, input: bool) -> Self {
            self.use_change_log = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to use the Amazon WorkDocs change log to determine which documents require updating in the index. Depending on the change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents in Amazon WorkDocs.</p>
        pub fn set_use_change_log(mut self, input: std::option::Option<bool>) -> Self {
            self.use_change_log = input;
            self
        }
        /// Appends an item to `inclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_inclusion_patterns`](Self::set_inclusion_patterns).
        ///
        /// <p>A list of regular expression patterns to include certain files in your Amazon WorkDocs site repository. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn inclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.inclusion_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to include certain files in your Amazon WorkDocs site repository. Files that match the patterns are included in the index. Files that don't match the patterns are excluded from the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn set_inclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inclusion_patterns = input;
            self
        }
        /// Appends an item to `exclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_exclusion_patterns`](Self::set_exclusion_patterns).
        ///
        /// <p>A list of regular expression patterns to exclude certain files in your Amazon WorkDocs site repository. Files that match the patterns are excluded from the index. Files that don’t match the patterns are included in the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn exclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.exclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.exclusion_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to exclude certain files in your Amazon WorkDocs site repository. Files that match the patterns are excluded from the index. Files that don’t match the patterns are included in the index. If a file matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the file isn't included in the index.</p>
        pub fn set_exclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclusion_patterns = input;
            self
        }
        /// Appends an item to `field_mappings`.
        ///
        /// To override the contents of this collection use [`set_field_mappings`](Self::set_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map Amazon WorkDocs data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Amazon WorkDocs fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Amazon WorkDocs data source field names must exist in your Amazon WorkDocs custom metadata.</p>
        pub fn field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.field_mappings.unwrap_or_default();
            v.push(input);
            self.field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map Amazon WorkDocs data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Amazon WorkDocs fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Amazon WorkDocs data source field names must exist in your Amazon WorkDocs custom metadata.</p>
        pub fn set_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.field_mappings = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkDocsConfiguration`](crate::model::WorkDocsConfiguration).
        pub fn build(self) -> crate::model::WorkDocsConfiguration {
            crate::model::WorkDocsConfiguration {
                organization_id: self.organization_id,
                crawl_comments: self.crawl_comments.unwrap_or_default(),
                use_change_log: self.use_change_log.unwrap_or_default(),
                inclusion_patterns: self.inclusion_patterns,
                exclusion_patterns: self.exclusion_patterns,
                field_mappings: self.field_mappings,
            }
        }
    }
}
impl WorkDocsConfiguration {
    /// Creates a new builder-style object to manufacture [`WorkDocsConfiguration`](crate::model::WorkDocsConfiguration).
    pub fn builder() -> crate::model::work_docs_configuration::Builder {
        crate::model::work_docs_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information required for Amazon Kendra Web Crawler.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WebCrawlerConfiguration {
    /// <p>Specifies the seed or starting point URLs of the websites or the sitemap URLs of the websites you want to crawl.</p>
    /// <p>You can include website subdomains. You can list up to 100 seed URLs and up to three sitemap URLs.</p>
    /// <p>You can only crawl websites that use the secure communication protocol, Hypertext Transfer Protocol Secure (HTTPS). If you receive an error when crawling a website, it could be that the website is blocked from crawling.</p>
    /// <p> <i>When selecting websites to index, you must adhere to the <a href="https://aws.amazon.com/aup/">Amazon Acceptable Use Policy</a> and all other Amazon terms. Remember that you must only use Amazon Kendra Web Crawler to index your own webpages, or webpages that you have authorization to index.</i> </p>
    #[doc(hidden)]
    pub urls: std::option::Option<crate::model::Urls>,
    /// <p>Specifies the number of levels in a website that you want to crawl.</p>
    /// <p>The first level begins from the website seed or starting point URL. For example, if a website has 3 levels – index level (i.e. seed in this example), sections level, and subsections level – and you are only interested in crawling information up to the sections level (i.e. levels 0-1), you can set your depth to 1.</p>
    /// <p>The default crawl depth is set to 2.</p>
    #[doc(hidden)]
    pub crawl_depth: std::option::Option<i32>,
    /// <p>The maximum number of URLs on a webpage to include when crawling a website. This number is per webpage.</p>
    /// <p>As a website’s webpages are crawled, any URLs the webpages link to are also crawled. URLs on a webpage are crawled in order of appearance.</p>
    /// <p>The default maximum links per page is 100.</p>
    #[doc(hidden)]
    pub max_links_per_page: std::option::Option<i32>,
    /// <p>The maximum size (in MB) of a webpage or attachment to crawl.</p>
    /// <p>Files larger than this size (in MB) are skipped/not crawled.</p>
    /// <p>The default maximum size of a webpage or attachment is set to 50 MB.</p>
    #[doc(hidden)]
    pub max_content_size_per_page_in_mega_bytes: std::option::Option<f32>,
    /// <p>The maximum number of URLs crawled per website host per minute.</p>
    /// <p>A minimum of one URL is required.</p>
    /// <p>The default maximum number of URLs crawled per website host per minute is 300.</p>
    #[doc(hidden)]
    pub max_urls_per_minute_crawl_rate: std::option::Option<i32>,
    /// <p>A list of regular expression patterns to include certain URLs to crawl. URLs that match the patterns are included in the index. URLs that don't match the patterns are excluded from the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index.</p>
    #[doc(hidden)]
    pub url_inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of regular expression patterns to exclude certain URLs to crawl. URLs that match the patterns are excluded from the index. URLs that don't match the patterns are included in the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index.</p>
    #[doc(hidden)]
    pub url_exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Configuration information required to connect to your internal websites via a web proxy.</p>
    /// <p>You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS.</p>
    /// <p>Web proxy credentials are optional and you can use them to connect to a web proxy server that requires basic authentication. To store web proxy credentials, you use a secret in <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html">Secrets Manager</a>.</p>
    #[doc(hidden)]
    pub proxy_configuration: std::option::Option<crate::model::ProxyConfiguration>,
    /// <p>Configuration information required to connect to websites using authentication.</p>
    /// <p>You can connect to websites using basic authentication of user name and password. You use a secret in <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html">Secrets Manager</a> to store your authentication credentials.</p>
    /// <p>You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS.</p>
    #[doc(hidden)]
    pub authentication_configuration:
        std::option::Option<crate::model::AuthenticationConfiguration>,
}
impl WebCrawlerConfiguration {
    /// <p>Specifies the seed or starting point URLs of the websites or the sitemap URLs of the websites you want to crawl.</p>
    /// <p>You can include website subdomains. You can list up to 100 seed URLs and up to three sitemap URLs.</p>
    /// <p>You can only crawl websites that use the secure communication protocol, Hypertext Transfer Protocol Secure (HTTPS). If you receive an error when crawling a website, it could be that the website is blocked from crawling.</p>
    /// <p> <i>When selecting websites to index, you must adhere to the <a href="https://aws.amazon.com/aup/">Amazon Acceptable Use Policy</a> and all other Amazon terms. Remember that you must only use Amazon Kendra Web Crawler to index your own webpages, or webpages that you have authorization to index.</i> </p>
    pub fn urls(&self) -> std::option::Option<&crate::model::Urls> {
        self.urls.as_ref()
    }
    /// <p>Specifies the number of levels in a website that you want to crawl.</p>
    /// <p>The first level begins from the website seed or starting point URL. For example, if a website has 3 levels – index level (i.e. seed in this example), sections level, and subsections level – and you are only interested in crawling information up to the sections level (i.e. levels 0-1), you can set your depth to 1.</p>
    /// <p>The default crawl depth is set to 2.</p>
    pub fn crawl_depth(&self) -> std::option::Option<i32> {
        self.crawl_depth
    }
    /// <p>The maximum number of URLs on a webpage to include when crawling a website. This number is per webpage.</p>
    /// <p>As a website’s webpages are crawled, any URLs the webpages link to are also crawled. URLs on a webpage are crawled in order of appearance.</p>
    /// <p>The default maximum links per page is 100.</p>
    pub fn max_links_per_page(&self) -> std::option::Option<i32> {
        self.max_links_per_page
    }
    /// <p>The maximum size (in MB) of a webpage or attachment to crawl.</p>
    /// <p>Files larger than this size (in MB) are skipped/not crawled.</p>
    /// <p>The default maximum size of a webpage or attachment is set to 50 MB.</p>
    pub fn max_content_size_per_page_in_mega_bytes(&self) -> std::option::Option<f32> {
        self.max_content_size_per_page_in_mega_bytes
    }
    /// <p>The maximum number of URLs crawled per website host per minute.</p>
    /// <p>A minimum of one URL is required.</p>
    /// <p>The default maximum number of URLs crawled per website host per minute is 300.</p>
    pub fn max_urls_per_minute_crawl_rate(&self) -> std::option::Option<i32> {
        self.max_urls_per_minute_crawl_rate
    }
    /// <p>A list of regular expression patterns to include certain URLs to crawl. URLs that match the patterns are included in the index. URLs that don't match the patterns are excluded from the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index.</p>
    pub fn url_inclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.url_inclusion_patterns.as_deref()
    }
    /// <p>A list of regular expression patterns to exclude certain URLs to crawl. URLs that match the patterns are excluded from the index. URLs that don't match the patterns are included in the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index.</p>
    pub fn url_exclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.url_exclusion_patterns.as_deref()
    }
    /// <p>Configuration information required to connect to your internal websites via a web proxy.</p>
    /// <p>You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS.</p>
    /// <p>Web proxy credentials are optional and you can use them to connect to a web proxy server that requires basic authentication. To store web proxy credentials, you use a secret in <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html">Secrets Manager</a>.</p>
    pub fn proxy_configuration(&self) -> std::option::Option<&crate::model::ProxyConfiguration> {
        self.proxy_configuration.as_ref()
    }
    /// <p>Configuration information required to connect to websites using authentication.</p>
    /// <p>You can connect to websites using basic authentication of user name and password. You use a secret in <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html">Secrets Manager</a> to store your authentication credentials.</p>
    /// <p>You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS.</p>
    pub fn authentication_configuration(
        &self,
    ) -> std::option::Option<&crate::model::AuthenticationConfiguration> {
        self.authentication_configuration.as_ref()
    }
}
/// See [`WebCrawlerConfiguration`](crate::model::WebCrawlerConfiguration).
pub mod web_crawler_configuration {

    /// A builder for [`WebCrawlerConfiguration`](crate::model::WebCrawlerConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) urls: std::option::Option<crate::model::Urls>,
        pub(crate) crawl_depth: std::option::Option<i32>,
        pub(crate) max_links_per_page: std::option::Option<i32>,
        pub(crate) max_content_size_per_page_in_mega_bytes: std::option::Option<f32>,
        pub(crate) max_urls_per_minute_crawl_rate: std::option::Option<i32>,
        pub(crate) url_inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) url_exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) proxy_configuration: std::option::Option<crate::model::ProxyConfiguration>,
        pub(crate) authentication_configuration:
            std::option::Option<crate::model::AuthenticationConfiguration>,
    }
    impl Builder {
        /// <p>Specifies the seed or starting point URLs of the websites or the sitemap URLs of the websites you want to crawl.</p>
        /// <p>You can include website subdomains. You can list up to 100 seed URLs and up to three sitemap URLs.</p>
        /// <p>You can only crawl websites that use the secure communication protocol, Hypertext Transfer Protocol Secure (HTTPS). If you receive an error when crawling a website, it could be that the website is blocked from crawling.</p>
        /// <p> <i>When selecting websites to index, you must adhere to the <a href="https://aws.amazon.com/aup/">Amazon Acceptable Use Policy</a> and all other Amazon terms. Remember that you must only use Amazon Kendra Web Crawler to index your own webpages, or webpages that you have authorization to index.</i> </p>
        pub fn urls(mut self, input: crate::model::Urls) -> Self {
            self.urls = Some(input);
            self
        }
        /// <p>Specifies the seed or starting point URLs of the websites or the sitemap URLs of the websites you want to crawl.</p>
        /// <p>You can include website subdomains. You can list up to 100 seed URLs and up to three sitemap URLs.</p>
        /// <p>You can only crawl websites that use the secure communication protocol, Hypertext Transfer Protocol Secure (HTTPS). If you receive an error when crawling a website, it could be that the website is blocked from crawling.</p>
        /// <p> <i>When selecting websites to index, you must adhere to the <a href="https://aws.amazon.com/aup/">Amazon Acceptable Use Policy</a> and all other Amazon terms. Remember that you must only use Amazon Kendra Web Crawler to index your own webpages, or webpages that you have authorization to index.</i> </p>
        pub fn set_urls(mut self, input: std::option::Option<crate::model::Urls>) -> Self {
            self.urls = input;
            self
        }
        /// <p>Specifies the number of levels in a website that you want to crawl.</p>
        /// <p>The first level begins from the website seed or starting point URL. For example, if a website has 3 levels – index level (i.e. seed in this example), sections level, and subsections level – and you are only interested in crawling information up to the sections level (i.e. levels 0-1), you can set your depth to 1.</p>
        /// <p>The default crawl depth is set to 2.</p>
        pub fn crawl_depth(mut self, input: i32) -> Self {
            self.crawl_depth = Some(input);
            self
        }
        /// <p>Specifies the number of levels in a website that you want to crawl.</p>
        /// <p>The first level begins from the website seed or starting point URL. For example, if a website has 3 levels – index level (i.e. seed in this example), sections level, and subsections level – and you are only interested in crawling information up to the sections level (i.e. levels 0-1), you can set your depth to 1.</p>
        /// <p>The default crawl depth is set to 2.</p>
        pub fn set_crawl_depth(mut self, input: std::option::Option<i32>) -> Self {
            self.crawl_depth = input;
            self
        }
        /// <p>The maximum number of URLs on a webpage to include when crawling a website. This number is per webpage.</p>
        /// <p>As a website’s webpages are crawled, any URLs the webpages link to are also crawled. URLs on a webpage are crawled in order of appearance.</p>
        /// <p>The default maximum links per page is 100.</p>
        pub fn max_links_per_page(mut self, input: i32) -> Self {
            self.max_links_per_page = Some(input);
            self
        }
        /// <p>The maximum number of URLs on a webpage to include when crawling a website. This number is per webpage.</p>
        /// <p>As a website’s webpages are crawled, any URLs the webpages link to are also crawled. URLs on a webpage are crawled in order of appearance.</p>
        /// <p>The default maximum links per page is 100.</p>
        pub fn set_max_links_per_page(mut self, input: std::option::Option<i32>) -> Self {
            self.max_links_per_page = input;
            self
        }
        /// <p>The maximum size (in MB) of a webpage or attachment to crawl.</p>
        /// <p>Files larger than this size (in MB) are skipped/not crawled.</p>
        /// <p>The default maximum size of a webpage or attachment is set to 50 MB.</p>
        pub fn max_content_size_per_page_in_mega_bytes(mut self, input: f32) -> Self {
            self.max_content_size_per_page_in_mega_bytes = Some(input);
            self
        }
        /// <p>The maximum size (in MB) of a webpage or attachment to crawl.</p>
        /// <p>Files larger than this size (in MB) are skipped/not crawled.</p>
        /// <p>The default maximum size of a webpage or attachment is set to 50 MB.</p>
        pub fn set_max_content_size_per_page_in_mega_bytes(
            mut self,
            input: std::option::Option<f32>,
        ) -> Self {
            self.max_content_size_per_page_in_mega_bytes = input;
            self
        }
        /// <p>The maximum number of URLs crawled per website host per minute.</p>
        /// <p>A minimum of one URL is required.</p>
        /// <p>The default maximum number of URLs crawled per website host per minute is 300.</p>
        pub fn max_urls_per_minute_crawl_rate(mut self, input: i32) -> Self {
            self.max_urls_per_minute_crawl_rate = Some(input);
            self
        }
        /// <p>The maximum number of URLs crawled per website host per minute.</p>
        /// <p>A minimum of one URL is required.</p>
        /// <p>The default maximum number of URLs crawled per website host per minute is 300.</p>
        pub fn set_max_urls_per_minute_crawl_rate(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.max_urls_per_minute_crawl_rate = input;
            self
        }
        /// Appends an item to `url_inclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_url_inclusion_patterns`](Self::set_url_inclusion_patterns).
        ///
        /// <p>A list of regular expression patterns to include certain URLs to crawl. URLs that match the patterns are included in the index. URLs that don't match the patterns are excluded from the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index.</p>
        pub fn url_inclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.url_inclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.url_inclusion_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to include certain URLs to crawl. URLs that match the patterns are included in the index. URLs that don't match the patterns are excluded from the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index.</p>
        pub fn set_url_inclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.url_inclusion_patterns = input;
            self
        }
        /// Appends an item to `url_exclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_url_exclusion_patterns`](Self::set_url_exclusion_patterns).
        ///
        /// <p>A list of regular expression patterns to exclude certain URLs to crawl. URLs that match the patterns are excluded from the index. URLs that don't match the patterns are included in the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index.</p>
        pub fn url_exclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.url_exclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.url_exclusion_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to exclude certain URLs to crawl. URLs that match the patterns are excluded from the index. URLs that don't match the patterns are included in the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index.</p>
        pub fn set_url_exclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.url_exclusion_patterns = input;
            self
        }
        /// <p>Configuration information required to connect to your internal websites via a web proxy.</p>
        /// <p>You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS.</p>
        /// <p>Web proxy credentials are optional and you can use them to connect to a web proxy server that requires basic authentication. To store web proxy credentials, you use a secret in <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html">Secrets Manager</a>.</p>
        pub fn proxy_configuration(mut self, input: crate::model::ProxyConfiguration) -> Self {
            self.proxy_configuration = Some(input);
            self
        }
        /// <p>Configuration information required to connect to your internal websites via a web proxy.</p>
        /// <p>You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS.</p>
        /// <p>Web proxy credentials are optional and you can use them to connect to a web proxy server that requires basic authentication. To store web proxy credentials, you use a secret in <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html">Secrets Manager</a>.</p>
        pub fn set_proxy_configuration(
            mut self,
            input: std::option::Option<crate::model::ProxyConfiguration>,
        ) -> Self {
            self.proxy_configuration = input;
            self
        }
        /// <p>Configuration information required to connect to websites using authentication.</p>
        /// <p>You can connect to websites using basic authentication of user name and password. You use a secret in <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html">Secrets Manager</a> to store your authentication credentials.</p>
        /// <p>You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS.</p>
        pub fn authentication_configuration(
            mut self,
            input: crate::model::AuthenticationConfiguration,
        ) -> Self {
            self.authentication_configuration = Some(input);
            self
        }
        /// <p>Configuration information required to connect to websites using authentication.</p>
        /// <p>You can connect to websites using basic authentication of user name and password. You use a secret in <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html">Secrets Manager</a> to store your authentication credentials.</p>
        /// <p>You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS.</p>
        pub fn set_authentication_configuration(
            mut self,
            input: std::option::Option<crate::model::AuthenticationConfiguration>,
        ) -> Self {
            self.authentication_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`WebCrawlerConfiguration`](crate::model::WebCrawlerConfiguration).
        pub fn build(self) -> crate::model::WebCrawlerConfiguration {
            crate::model::WebCrawlerConfiguration {
                urls: self.urls,
                crawl_depth: self.crawl_depth,
                max_links_per_page: self.max_links_per_page,
                max_content_size_per_page_in_mega_bytes: self
                    .max_content_size_per_page_in_mega_bytes,
                max_urls_per_minute_crawl_rate: self.max_urls_per_minute_crawl_rate,
                url_inclusion_patterns: self.url_inclusion_patterns,
                url_exclusion_patterns: self.url_exclusion_patterns,
                proxy_configuration: self.proxy_configuration,
                authentication_configuration: self.authentication_configuration,
            }
        }
    }
}
impl WebCrawlerConfiguration {
    /// Creates a new builder-style object to manufacture [`WebCrawlerConfiguration`](crate::model::WebCrawlerConfiguration).
    pub fn builder() -> crate::model::web_crawler_configuration::Builder {
        crate::model::web_crawler_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information to connect to websites that require user authentication.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AuthenticationConfiguration {
    /// <p>The list of configuration information that's required to connect to and crawl a website host using basic authentication credentials.</p>
    /// <p>The list includes the name and port number of the website host.</p>
    #[doc(hidden)]
    pub basic_authentication:
        std::option::Option<std::vec::Vec<crate::model::BasicAuthenticationConfiguration>>,
}
impl AuthenticationConfiguration {
    /// <p>The list of configuration information that's required to connect to and crawl a website host using basic authentication credentials.</p>
    /// <p>The list includes the name and port number of the website host.</p>
    pub fn basic_authentication(
        &self,
    ) -> std::option::Option<&[crate::model::BasicAuthenticationConfiguration]> {
        self.basic_authentication.as_deref()
    }
}
/// See [`AuthenticationConfiguration`](crate::model::AuthenticationConfiguration).
pub mod authentication_configuration {

    /// A builder for [`AuthenticationConfiguration`](crate::model::AuthenticationConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) basic_authentication:
            std::option::Option<std::vec::Vec<crate::model::BasicAuthenticationConfiguration>>,
    }
    impl Builder {
        /// Appends an item to `basic_authentication`.
        ///
        /// To override the contents of this collection use [`set_basic_authentication`](Self::set_basic_authentication).
        ///
        /// <p>The list of configuration information that's required to connect to and crawl a website host using basic authentication credentials.</p>
        /// <p>The list includes the name and port number of the website host.</p>
        pub fn basic_authentication(
            mut self,
            input: crate::model::BasicAuthenticationConfiguration,
        ) -> Self {
            let mut v = self.basic_authentication.unwrap_or_default();
            v.push(input);
            self.basic_authentication = Some(v);
            self
        }
        /// <p>The list of configuration information that's required to connect to and crawl a website host using basic authentication credentials.</p>
        /// <p>The list includes the name and port number of the website host.</p>
        pub fn set_basic_authentication(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::BasicAuthenticationConfiguration>,
            >,
        ) -> Self {
            self.basic_authentication = input;
            self
        }
        /// Consumes the builder and constructs a [`AuthenticationConfiguration`](crate::model::AuthenticationConfiguration).
        pub fn build(self) -> crate::model::AuthenticationConfiguration {
            crate::model::AuthenticationConfiguration {
                basic_authentication: self.basic_authentication,
            }
        }
    }
}
impl AuthenticationConfiguration {
    /// Creates a new builder-style object to manufacture [`AuthenticationConfiguration`](crate::model::AuthenticationConfiguration).
    pub fn builder() -> crate::model::authentication_configuration::Builder {
        crate::model::authentication_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information to connect to websites that require basic user authentication.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BasicAuthenticationConfiguration {
    /// <p>The name of the website host you want to connect to using authentication credentials.</p>
    /// <p>For example, the host name of https://a.example.com/page1.html is "a.example.com".</p>
    #[doc(hidden)]
    pub host: std::option::Option<std::string::String>,
    /// <p>The port number of the website host you want to connect to using authentication credentials.</p>
    /// <p>For example, the port for https://a.example.com/page1.html is 443, the standard port for HTTPS.</p>
    #[doc(hidden)]
    pub port: std::option::Option<i32>,
    /// <p>Your secret ARN, which you can create in <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html">Secrets Manager</a> </p>
    /// <p>You use a secret if basic authentication credentials are required to connect to a website. The secret stores your credentials of user name and password.</p>
    #[doc(hidden)]
    pub credentials: std::option::Option<std::string::String>,
}
impl BasicAuthenticationConfiguration {
    /// <p>The name of the website host you want to connect to using authentication credentials.</p>
    /// <p>For example, the host name of https://a.example.com/page1.html is "a.example.com".</p>
    pub fn host(&self) -> std::option::Option<&str> {
        self.host.as_deref()
    }
    /// <p>The port number of the website host you want to connect to using authentication credentials.</p>
    /// <p>For example, the port for https://a.example.com/page1.html is 443, the standard port for HTTPS.</p>
    pub fn port(&self) -> std::option::Option<i32> {
        self.port
    }
    /// <p>Your secret ARN, which you can create in <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html">Secrets Manager</a> </p>
    /// <p>You use a secret if basic authentication credentials are required to connect to a website. The secret stores your credentials of user name and password.</p>
    pub fn credentials(&self) -> std::option::Option<&str> {
        self.credentials.as_deref()
    }
}
/// See [`BasicAuthenticationConfiguration`](crate::model::BasicAuthenticationConfiguration).
pub mod basic_authentication_configuration {

    /// A builder for [`BasicAuthenticationConfiguration`](crate::model::BasicAuthenticationConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) host: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) credentials: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the website host you want to connect to using authentication credentials.</p>
        /// <p>For example, the host name of https://a.example.com/page1.html is "a.example.com".</p>
        pub fn host(mut self, input: impl Into<std::string::String>) -> Self {
            self.host = Some(input.into());
            self
        }
        /// <p>The name of the website host you want to connect to using authentication credentials.</p>
        /// <p>For example, the host name of https://a.example.com/page1.html is "a.example.com".</p>
        pub fn set_host(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host = input;
            self
        }
        /// <p>The port number of the website host you want to connect to using authentication credentials.</p>
        /// <p>For example, the port for https://a.example.com/page1.html is 443, the standard port for HTTPS.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>The port number of the website host you want to connect to using authentication credentials.</p>
        /// <p>For example, the port for https://a.example.com/page1.html is 443, the standard port for HTTPS.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// <p>Your secret ARN, which you can create in <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html">Secrets Manager</a> </p>
        /// <p>You use a secret if basic authentication credentials are required to connect to a website. The secret stores your credentials of user name and password.</p>
        pub fn credentials(mut self, input: impl Into<std::string::String>) -> Self {
            self.credentials = Some(input.into());
            self
        }
        /// <p>Your secret ARN, which you can create in <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html">Secrets Manager</a> </p>
        /// <p>You use a secret if basic authentication credentials are required to connect to a website. The secret stores your credentials of user name and password.</p>
        pub fn set_credentials(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.credentials = input;
            self
        }
        /// Consumes the builder and constructs a [`BasicAuthenticationConfiguration`](crate::model::BasicAuthenticationConfiguration).
        pub fn build(self) -> crate::model::BasicAuthenticationConfiguration {
            crate::model::BasicAuthenticationConfiguration {
                host: self.host,
                port: self.port,
                credentials: self.credentials,
            }
        }
    }
}
impl BasicAuthenticationConfiguration {
    /// Creates a new builder-style object to manufacture [`BasicAuthenticationConfiguration`](crate::model::BasicAuthenticationConfiguration).
    pub fn builder() -> crate::model::basic_authentication_configuration::Builder {
        crate::model::basic_authentication_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information for a web proxy to connect to website hosts.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProxyConfiguration {
    /// <p>The name of the website host you want to connect to via a web proxy server.</p>
    /// <p>For example, the host name of https://a.example.com/page1.html is "a.example.com".</p>
    #[doc(hidden)]
    pub host: std::option::Option<std::string::String>,
    /// <p>The port number of the website host you want to connect to via a web proxy server. </p>
    /// <p>For example, the port for https://a.example.com/page1.html is 443, the standard port for HTTPS.</p>
    #[doc(hidden)]
    pub port: std::option::Option<i32>,
    /// <p>Your secret ARN, which you can create in <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html">Secrets Manager</a> </p>
    /// <p>The credentials are optional. You use a secret if web proxy credentials are required to connect to a website host. Amazon Kendra currently support basic authentication to connect to a web proxy server. The secret stores your credentials.</p>
    #[doc(hidden)]
    pub credentials: std::option::Option<std::string::String>,
}
impl ProxyConfiguration {
    /// <p>The name of the website host you want to connect to via a web proxy server.</p>
    /// <p>For example, the host name of https://a.example.com/page1.html is "a.example.com".</p>
    pub fn host(&self) -> std::option::Option<&str> {
        self.host.as_deref()
    }
    /// <p>The port number of the website host you want to connect to via a web proxy server. </p>
    /// <p>For example, the port for https://a.example.com/page1.html is 443, the standard port for HTTPS.</p>
    pub fn port(&self) -> std::option::Option<i32> {
        self.port
    }
    /// <p>Your secret ARN, which you can create in <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html">Secrets Manager</a> </p>
    /// <p>The credentials are optional. You use a secret if web proxy credentials are required to connect to a website host. Amazon Kendra currently support basic authentication to connect to a web proxy server. The secret stores your credentials.</p>
    pub fn credentials(&self) -> std::option::Option<&str> {
        self.credentials.as_deref()
    }
}
/// See [`ProxyConfiguration`](crate::model::ProxyConfiguration).
pub mod proxy_configuration {

    /// A builder for [`ProxyConfiguration`](crate::model::ProxyConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) host: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) credentials: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the website host you want to connect to via a web proxy server.</p>
        /// <p>For example, the host name of https://a.example.com/page1.html is "a.example.com".</p>
        pub fn host(mut self, input: impl Into<std::string::String>) -> Self {
            self.host = Some(input.into());
            self
        }
        /// <p>The name of the website host you want to connect to via a web proxy server.</p>
        /// <p>For example, the host name of https://a.example.com/page1.html is "a.example.com".</p>
        pub fn set_host(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host = input;
            self
        }
        /// <p>The port number of the website host you want to connect to via a web proxy server. </p>
        /// <p>For example, the port for https://a.example.com/page1.html is 443, the standard port for HTTPS.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>The port number of the website host you want to connect to via a web proxy server. </p>
        /// <p>For example, the port for https://a.example.com/page1.html is 443, the standard port for HTTPS.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// <p>Your secret ARN, which you can create in <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html">Secrets Manager</a> </p>
        /// <p>The credentials are optional. You use a secret if web proxy credentials are required to connect to a website host. Amazon Kendra currently support basic authentication to connect to a web proxy server. The secret stores your credentials.</p>
        pub fn credentials(mut self, input: impl Into<std::string::String>) -> Self {
            self.credentials = Some(input.into());
            self
        }
        /// <p>Your secret ARN, which you can create in <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html">Secrets Manager</a> </p>
        /// <p>The credentials are optional. You use a secret if web proxy credentials are required to connect to a website host. Amazon Kendra currently support basic authentication to connect to a web proxy server. The secret stores your credentials.</p>
        pub fn set_credentials(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.credentials = input;
            self
        }
        /// Consumes the builder and constructs a [`ProxyConfiguration`](crate::model::ProxyConfiguration).
        pub fn build(self) -> crate::model::ProxyConfiguration {
            crate::model::ProxyConfiguration {
                host: self.host,
                port: self.port,
                credentials: self.credentials,
            }
        }
    }
}
impl ProxyConfiguration {
    /// Creates a new builder-style object to manufacture [`ProxyConfiguration`](crate::model::ProxyConfiguration).
    pub fn builder() -> crate::model::proxy_configuration::Builder {
        crate::model::proxy_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information of the URLs to crawl.</p>
/// <p>You can only crawl websites that use the secure communication protocol, Hypertext Transfer Protocol Secure (HTTPS). If you receive an error when crawling a website, it could be that the website is blocked from crawling.</p>
/// <p> <i>When selecting websites to index, you must adhere to the <a href="https://aws.amazon.com/aup/">Amazon Acceptable Use Policy</a> and all other Amazon terms. Remember that you must only use Amazon Kendra Web Crawler to index your own webpages, or webpages that you have authorization to index.</i> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Urls {
    /// <p>Configuration of the seed or starting point URLs of the websites you want to crawl.</p>
    /// <p>You can choose to crawl only the website host names, or the website host names with subdomains, or the website host names with subdomains and other domains that the webpages link to.</p>
    /// <p>You can list up to 100 seed URLs.</p>
    #[doc(hidden)]
    pub seed_url_configuration: std::option::Option<crate::model::SeedUrlConfiguration>,
    /// <p>Configuration of the sitemap URLs of the websites you want to crawl.</p>
    /// <p>Only URLs belonging to the same website host names are crawled. You can list up to three sitemap URLs.</p>
    #[doc(hidden)]
    pub site_maps_configuration: std::option::Option<crate::model::SiteMapsConfiguration>,
}
impl Urls {
    /// <p>Configuration of the seed or starting point URLs of the websites you want to crawl.</p>
    /// <p>You can choose to crawl only the website host names, or the website host names with subdomains, or the website host names with subdomains and other domains that the webpages link to.</p>
    /// <p>You can list up to 100 seed URLs.</p>
    pub fn seed_url_configuration(
        &self,
    ) -> std::option::Option<&crate::model::SeedUrlConfiguration> {
        self.seed_url_configuration.as_ref()
    }
    /// <p>Configuration of the sitemap URLs of the websites you want to crawl.</p>
    /// <p>Only URLs belonging to the same website host names are crawled. You can list up to three sitemap URLs.</p>
    pub fn site_maps_configuration(
        &self,
    ) -> std::option::Option<&crate::model::SiteMapsConfiguration> {
        self.site_maps_configuration.as_ref()
    }
}
/// See [`Urls`](crate::model::Urls).
pub mod urls {

    /// A builder for [`Urls`](crate::model::Urls).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) seed_url_configuration: std::option::Option<crate::model::SeedUrlConfiguration>,
        pub(crate) site_maps_configuration:
            std::option::Option<crate::model::SiteMapsConfiguration>,
    }
    impl Builder {
        /// <p>Configuration of the seed or starting point URLs of the websites you want to crawl.</p>
        /// <p>You can choose to crawl only the website host names, or the website host names with subdomains, or the website host names with subdomains and other domains that the webpages link to.</p>
        /// <p>You can list up to 100 seed URLs.</p>
        pub fn seed_url_configuration(mut self, input: crate::model::SeedUrlConfiguration) -> Self {
            self.seed_url_configuration = Some(input);
            self
        }
        /// <p>Configuration of the seed or starting point URLs of the websites you want to crawl.</p>
        /// <p>You can choose to crawl only the website host names, or the website host names with subdomains, or the website host names with subdomains and other domains that the webpages link to.</p>
        /// <p>You can list up to 100 seed URLs.</p>
        pub fn set_seed_url_configuration(
            mut self,
            input: std::option::Option<crate::model::SeedUrlConfiguration>,
        ) -> Self {
            self.seed_url_configuration = input;
            self
        }
        /// <p>Configuration of the sitemap URLs of the websites you want to crawl.</p>
        /// <p>Only URLs belonging to the same website host names are crawled. You can list up to three sitemap URLs.</p>
        pub fn site_maps_configuration(
            mut self,
            input: crate::model::SiteMapsConfiguration,
        ) -> Self {
            self.site_maps_configuration = Some(input);
            self
        }
        /// <p>Configuration of the sitemap URLs of the websites you want to crawl.</p>
        /// <p>Only URLs belonging to the same website host names are crawled. You can list up to three sitemap URLs.</p>
        pub fn set_site_maps_configuration(
            mut self,
            input: std::option::Option<crate::model::SiteMapsConfiguration>,
        ) -> Self {
            self.site_maps_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`Urls`](crate::model::Urls).
        pub fn build(self) -> crate::model::Urls {
            crate::model::Urls {
                seed_url_configuration: self.seed_url_configuration,
                site_maps_configuration: self.site_maps_configuration,
            }
        }
    }
}
impl Urls {
    /// Creates a new builder-style object to manufacture [`Urls`](crate::model::Urls).
    pub fn builder() -> crate::model::urls::Builder {
        crate::model::urls::Builder::default()
    }
}

/// <p>Provides the configuration information for the sitemap URLs to crawl.</p>
/// <p> <i>When selecting websites to index, you must adhere to the <a href="https://aws.amazon.com/aup/">Amazon Acceptable Use Policy</a> and all other Amazon terms. Remember that you must only use Amazon Kendra Web Crawler to index your own webpages, or webpages that you have authorization to index.</i> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SiteMapsConfiguration {
    /// <p>The list of sitemap URLs of the websites you want to crawl.</p>
    /// <p>The list can include a maximum of three sitemap URLs.</p>
    #[doc(hidden)]
    pub site_maps: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl SiteMapsConfiguration {
    /// <p>The list of sitemap URLs of the websites you want to crawl.</p>
    /// <p>The list can include a maximum of three sitemap URLs.</p>
    pub fn site_maps(&self) -> std::option::Option<&[std::string::String]> {
        self.site_maps.as_deref()
    }
}
/// See [`SiteMapsConfiguration`](crate::model::SiteMapsConfiguration).
pub mod site_maps_configuration {

    /// A builder for [`SiteMapsConfiguration`](crate::model::SiteMapsConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) site_maps: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `site_maps`.
        ///
        /// To override the contents of this collection use [`set_site_maps`](Self::set_site_maps).
        ///
        /// <p>The list of sitemap URLs of the websites you want to crawl.</p>
        /// <p>The list can include a maximum of three sitemap URLs.</p>
        pub fn site_maps(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.site_maps.unwrap_or_default();
            v.push(input.into());
            self.site_maps = Some(v);
            self
        }
        /// <p>The list of sitemap URLs of the websites you want to crawl.</p>
        /// <p>The list can include a maximum of three sitemap URLs.</p>
        pub fn set_site_maps(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.site_maps = input;
            self
        }
        /// Consumes the builder and constructs a [`SiteMapsConfiguration`](crate::model::SiteMapsConfiguration).
        pub fn build(self) -> crate::model::SiteMapsConfiguration {
            crate::model::SiteMapsConfiguration {
                site_maps: self.site_maps,
            }
        }
    }
}
impl SiteMapsConfiguration {
    /// Creates a new builder-style object to manufacture [`SiteMapsConfiguration`](crate::model::SiteMapsConfiguration).
    pub fn builder() -> crate::model::site_maps_configuration::Builder {
        crate::model::site_maps_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information for the seed or starting point URLs to crawl.</p>
/// <p> <i>When selecting websites to index, you must adhere to the <a href="https://aws.amazon.com/aup/">Amazon Acceptable Use Policy</a> and all other Amazon terms. Remember that you must only use Amazon Kendra Web Crawler to index your own webpages, or webpages that you have authorization to index.</i> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SeedUrlConfiguration {
    /// <p>The list of seed or starting point URLs of the websites you want to crawl.</p>
    /// <p>The list can include a maximum of 100 seed URLs.</p>
    #[doc(hidden)]
    pub seed_urls: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>You can choose one of the following modes:</p>
    /// <ul>
    /// <li> <p> <code>HOST_ONLY</code> – crawl only the website host names. For example, if the seed URL is "abc.example.com", then only URLs with host name "abc.example.com" are crawled.</p> </li>
    /// <li> <p> <code>SUBDOMAINS</code> – crawl the website host names with subdomains. For example, if the seed URL is "abc.example.com", then "a.abc.example.com" and "b.abc.example.com" are also crawled.</p> </li>
    /// <li> <p> <code>EVERYTHING</code> – crawl the website host names with subdomains and other domains that the webpages link to.</p> </li>
    /// </ul>
    /// <p>The default mode is set to <code>HOST_ONLY</code>.</p>
    #[doc(hidden)]
    pub web_crawler_mode: std::option::Option<crate::model::WebCrawlerMode>,
}
impl SeedUrlConfiguration {
    /// <p>The list of seed or starting point URLs of the websites you want to crawl.</p>
    /// <p>The list can include a maximum of 100 seed URLs.</p>
    pub fn seed_urls(&self) -> std::option::Option<&[std::string::String]> {
        self.seed_urls.as_deref()
    }
    /// <p>You can choose one of the following modes:</p>
    /// <ul>
    /// <li> <p> <code>HOST_ONLY</code> – crawl only the website host names. For example, if the seed URL is "abc.example.com", then only URLs with host name "abc.example.com" are crawled.</p> </li>
    /// <li> <p> <code>SUBDOMAINS</code> – crawl the website host names with subdomains. For example, if the seed URL is "abc.example.com", then "a.abc.example.com" and "b.abc.example.com" are also crawled.</p> </li>
    /// <li> <p> <code>EVERYTHING</code> – crawl the website host names with subdomains and other domains that the webpages link to.</p> </li>
    /// </ul>
    /// <p>The default mode is set to <code>HOST_ONLY</code>.</p>
    pub fn web_crawler_mode(&self) -> std::option::Option<&crate::model::WebCrawlerMode> {
        self.web_crawler_mode.as_ref()
    }
}
/// See [`SeedUrlConfiguration`](crate::model::SeedUrlConfiguration).
pub mod seed_url_configuration {

    /// A builder for [`SeedUrlConfiguration`](crate::model::SeedUrlConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) seed_urls: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) web_crawler_mode: std::option::Option<crate::model::WebCrawlerMode>,
    }
    impl Builder {
        /// Appends an item to `seed_urls`.
        ///
        /// To override the contents of this collection use [`set_seed_urls`](Self::set_seed_urls).
        ///
        /// <p>The list of seed or starting point URLs of the websites you want to crawl.</p>
        /// <p>The list can include a maximum of 100 seed URLs.</p>
        pub fn seed_urls(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.seed_urls.unwrap_or_default();
            v.push(input.into());
            self.seed_urls = Some(v);
            self
        }
        /// <p>The list of seed or starting point URLs of the websites you want to crawl.</p>
        /// <p>The list can include a maximum of 100 seed URLs.</p>
        pub fn set_seed_urls(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.seed_urls = input;
            self
        }
        /// <p>You can choose one of the following modes:</p>
        /// <ul>
        /// <li> <p> <code>HOST_ONLY</code> – crawl only the website host names. For example, if the seed URL is "abc.example.com", then only URLs with host name "abc.example.com" are crawled.</p> </li>
        /// <li> <p> <code>SUBDOMAINS</code> – crawl the website host names with subdomains. For example, if the seed URL is "abc.example.com", then "a.abc.example.com" and "b.abc.example.com" are also crawled.</p> </li>
        /// <li> <p> <code>EVERYTHING</code> – crawl the website host names with subdomains and other domains that the webpages link to.</p> </li>
        /// </ul>
        /// <p>The default mode is set to <code>HOST_ONLY</code>.</p>
        pub fn web_crawler_mode(mut self, input: crate::model::WebCrawlerMode) -> Self {
            self.web_crawler_mode = Some(input);
            self
        }
        /// <p>You can choose one of the following modes:</p>
        /// <ul>
        /// <li> <p> <code>HOST_ONLY</code> – crawl only the website host names. For example, if the seed URL is "abc.example.com", then only URLs with host name "abc.example.com" are crawled.</p> </li>
        /// <li> <p> <code>SUBDOMAINS</code> – crawl the website host names with subdomains. For example, if the seed URL is "abc.example.com", then "a.abc.example.com" and "b.abc.example.com" are also crawled.</p> </li>
        /// <li> <p> <code>EVERYTHING</code> – crawl the website host names with subdomains and other domains that the webpages link to.</p> </li>
        /// </ul>
        /// <p>The default mode is set to <code>HOST_ONLY</code>.</p>
        pub fn set_web_crawler_mode(
            mut self,
            input: std::option::Option<crate::model::WebCrawlerMode>,
        ) -> Self {
            self.web_crawler_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`SeedUrlConfiguration`](crate::model::SeedUrlConfiguration).
        pub fn build(self) -> crate::model::SeedUrlConfiguration {
            crate::model::SeedUrlConfiguration {
                seed_urls: self.seed_urls,
                web_crawler_mode: self.web_crawler_mode,
            }
        }
    }
}
impl SeedUrlConfiguration {
    /// Creates a new builder-style object to manufacture [`SeedUrlConfiguration`](crate::model::SeedUrlConfiguration).
    pub fn builder() -> crate::model::seed_url_configuration::Builder {
        crate::model::seed_url_configuration::Builder::default()
    }
}

/// When writing a match expression against `WebCrawlerMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let webcrawlermode = unimplemented!();
/// match webcrawlermode {
///     WebCrawlerMode::Everything => { /* ... */ },
///     WebCrawlerMode::HostOnly => { /* ... */ },
///     WebCrawlerMode::Subdomains => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `webcrawlermode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WebCrawlerMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WebCrawlerMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WebCrawlerMode::NewFeature` is defined.
/// Specifically, when `webcrawlermode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WebCrawlerMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WebCrawlerMode {
    #[allow(missing_docs)] // documentation missing in model
    Everything,
    #[allow(missing_docs)] // documentation missing in model
    HostOnly,
    #[allow(missing_docs)] // documentation missing in model
    Subdomains,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WebCrawlerMode {
    fn from(s: &str) -> Self {
        match s {
            "EVERYTHING" => WebCrawlerMode::Everything,
            "HOST_ONLY" => WebCrawlerMode::HostOnly,
            "SUBDOMAINS" => WebCrawlerMode::Subdomains,
            other => WebCrawlerMode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for WebCrawlerMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WebCrawlerMode::from(s))
    }
}
impl WebCrawlerMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WebCrawlerMode::Everything => "EVERYTHING",
            WebCrawlerMode::HostOnly => "HOST_ONLY",
            WebCrawlerMode::Subdomains => "SUBDOMAINS",
            WebCrawlerMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EVERYTHING", "HOST_ONLY", "SUBDOMAINS"]
    }
}
impl AsRef<str> for WebCrawlerMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides the configuration information to connect to Google Drive as your data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GoogleDriveConfiguration {
    /// <p>The Amazon Resource Name (ARN) of a Secrets Managersecret that contains the credentials required to connect to Google Drive. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-google-drive.html">Using a Google Workspace Drive data source</a>.</p>
    #[doc(hidden)]
    pub secret_arn: std::option::Option<std::string::String>,
    /// <p>A list of regular expression patterns to include certain items in your Google Drive, including shared drives and users' My Drives. Items that match the patterns are included in the index. Items that don't match the patterns are excluded from the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.</p>
    #[doc(hidden)]
    pub inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of regular expression patterns to exclude certain items in your Google Drive, including shared drives and users' My Drives. Items that match the patterns are excluded from the index. Items that don't match the patterns are included in the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.</p>
    #[doc(hidden)]
    pub exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Maps Google Drive data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Google Drive fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Google Drive data source field names must exist in your Google Drive custom metadata.</p>
    #[doc(hidden)]
    pub field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>A list of MIME types to exclude from the index. All documents matching the specified MIME type are excluded. </p>
    /// <p>For a list of MIME types, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-google-drive.html">Using a Google Workspace Drive data source</a>.</p>
    #[doc(hidden)]
    pub exclude_mime_types: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of email addresses of the users. Documents owned by these users are excluded from the index. Documents shared with excluded users are indexed unless they are excluded in another way.</p>
    #[doc(hidden)]
    pub exclude_user_accounts: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of identifiers or shared drives to exclude from the index. All files and folders stored on the shared drive are excluded.</p>
    #[doc(hidden)]
    pub exclude_shared_drives: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl GoogleDriveConfiguration {
    /// <p>The Amazon Resource Name (ARN) of a Secrets Managersecret that contains the credentials required to connect to Google Drive. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-google-drive.html">Using a Google Workspace Drive data source</a>.</p>
    pub fn secret_arn(&self) -> std::option::Option<&str> {
        self.secret_arn.as_deref()
    }
    /// <p>A list of regular expression patterns to include certain items in your Google Drive, including shared drives and users' My Drives. Items that match the patterns are included in the index. Items that don't match the patterns are excluded from the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.</p>
    pub fn inclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.inclusion_patterns.as_deref()
    }
    /// <p>A list of regular expression patterns to exclude certain items in your Google Drive, including shared drives and users' My Drives. Items that match the patterns are excluded from the index. Items that don't match the patterns are included in the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.</p>
    pub fn exclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.exclusion_patterns.as_deref()
    }
    /// <p>Maps Google Drive data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Google Drive fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Google Drive data source field names must exist in your Google Drive custom metadata.</p>
    pub fn field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.field_mappings.as_deref()
    }
    /// <p>A list of MIME types to exclude from the index. All documents matching the specified MIME type are excluded. </p>
    /// <p>For a list of MIME types, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-google-drive.html">Using a Google Workspace Drive data source</a>.</p>
    pub fn exclude_mime_types(&self) -> std::option::Option<&[std::string::String]> {
        self.exclude_mime_types.as_deref()
    }
    /// <p>A list of email addresses of the users. Documents owned by these users are excluded from the index. Documents shared with excluded users are indexed unless they are excluded in another way.</p>
    pub fn exclude_user_accounts(&self) -> std::option::Option<&[std::string::String]> {
        self.exclude_user_accounts.as_deref()
    }
    /// <p>A list of identifiers or shared drives to exclude from the index. All files and folders stored on the shared drive are excluded.</p>
    pub fn exclude_shared_drives(&self) -> std::option::Option<&[std::string::String]> {
        self.exclude_shared_drives.as_deref()
    }
}
/// See [`GoogleDriveConfiguration`](crate::model::GoogleDriveConfiguration).
pub mod google_drive_configuration {

    /// A builder for [`GoogleDriveConfiguration`](crate::model::GoogleDriveConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) secret_arn: std::option::Option<std::string::String>,
        pub(crate) inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) exclude_mime_types: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) exclude_user_accounts: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) exclude_shared_drives: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of a Secrets Managersecret that contains the credentials required to connect to Google Drive. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-google-drive.html">Using a Google Workspace Drive data source</a>.</p>
        pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a Secrets Managersecret that contains the credentials required to connect to Google Drive. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-google-drive.html">Using a Google Workspace Drive data source</a>.</p>
        pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_arn = input;
            self
        }
        /// Appends an item to `inclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_inclusion_patterns`](Self::set_inclusion_patterns).
        ///
        /// <p>A list of regular expression patterns to include certain items in your Google Drive, including shared drives and users' My Drives. Items that match the patterns are included in the index. Items that don't match the patterns are excluded from the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.</p>
        pub fn inclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.inclusion_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to include certain items in your Google Drive, including shared drives and users' My Drives. Items that match the patterns are included in the index. Items that don't match the patterns are excluded from the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.</p>
        pub fn set_inclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inclusion_patterns = input;
            self
        }
        /// Appends an item to `exclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_exclusion_patterns`](Self::set_exclusion_patterns).
        ///
        /// <p>A list of regular expression patterns to exclude certain items in your Google Drive, including shared drives and users' My Drives. Items that match the patterns are excluded from the index. Items that don't match the patterns are included in the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.</p>
        pub fn exclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.exclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.exclusion_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to exclude certain items in your Google Drive, including shared drives and users' My Drives. Items that match the patterns are excluded from the index. Items that don't match the patterns are included in the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.</p>
        pub fn set_exclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclusion_patterns = input;
            self
        }
        /// Appends an item to `field_mappings`.
        ///
        /// To override the contents of this collection use [`set_field_mappings`](Self::set_field_mappings).
        ///
        /// <p>Maps Google Drive data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Google Drive fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Google Drive data source field names must exist in your Google Drive custom metadata.</p>
        pub fn field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.field_mappings.unwrap_or_default();
            v.push(input);
            self.field_mappings = Some(v);
            self
        }
        /// <p>Maps Google Drive data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Google Drive fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Google Drive data source field names must exist in your Google Drive custom metadata.</p>
        pub fn set_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.field_mappings = input;
            self
        }
        /// Appends an item to `exclude_mime_types`.
        ///
        /// To override the contents of this collection use [`set_exclude_mime_types`](Self::set_exclude_mime_types).
        ///
        /// <p>A list of MIME types to exclude from the index. All documents matching the specified MIME type are excluded. </p>
        /// <p>For a list of MIME types, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-google-drive.html">Using a Google Workspace Drive data source</a>.</p>
        pub fn exclude_mime_types(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.exclude_mime_types.unwrap_or_default();
            v.push(input.into());
            self.exclude_mime_types = Some(v);
            self
        }
        /// <p>A list of MIME types to exclude from the index. All documents matching the specified MIME type are excluded. </p>
        /// <p>For a list of MIME types, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-google-drive.html">Using a Google Workspace Drive data source</a>.</p>
        pub fn set_exclude_mime_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclude_mime_types = input;
            self
        }
        /// Appends an item to `exclude_user_accounts`.
        ///
        /// To override the contents of this collection use [`set_exclude_user_accounts`](Self::set_exclude_user_accounts).
        ///
        /// <p>A list of email addresses of the users. Documents owned by these users are excluded from the index. Documents shared with excluded users are indexed unless they are excluded in another way.</p>
        pub fn exclude_user_accounts(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.exclude_user_accounts.unwrap_or_default();
            v.push(input.into());
            self.exclude_user_accounts = Some(v);
            self
        }
        /// <p>A list of email addresses of the users. Documents owned by these users are excluded from the index. Documents shared with excluded users are indexed unless they are excluded in another way.</p>
        pub fn set_exclude_user_accounts(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclude_user_accounts = input;
            self
        }
        /// Appends an item to `exclude_shared_drives`.
        ///
        /// To override the contents of this collection use [`set_exclude_shared_drives`](Self::set_exclude_shared_drives).
        ///
        /// <p>A list of identifiers or shared drives to exclude from the index. All files and folders stored on the shared drive are excluded.</p>
        pub fn exclude_shared_drives(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.exclude_shared_drives.unwrap_or_default();
            v.push(input.into());
            self.exclude_shared_drives = Some(v);
            self
        }
        /// <p>A list of identifiers or shared drives to exclude from the index. All files and folders stored on the shared drive are excluded.</p>
        pub fn set_exclude_shared_drives(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclude_shared_drives = input;
            self
        }
        /// Consumes the builder and constructs a [`GoogleDriveConfiguration`](crate::model::GoogleDriveConfiguration).
        pub fn build(self) -> crate::model::GoogleDriveConfiguration {
            crate::model::GoogleDriveConfiguration {
                secret_arn: self.secret_arn,
                inclusion_patterns: self.inclusion_patterns,
                exclusion_patterns: self.exclusion_patterns,
                field_mappings: self.field_mappings,
                exclude_mime_types: self.exclude_mime_types,
                exclude_user_accounts: self.exclude_user_accounts,
                exclude_shared_drives: self.exclude_shared_drives,
            }
        }
    }
}
impl GoogleDriveConfiguration {
    /// Creates a new builder-style object to manufacture [`GoogleDriveConfiguration`](crate::model::GoogleDriveConfiguration).
    pub fn builder() -> crate::model::google_drive_configuration::Builder {
        crate::model::google_drive_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information to connect to Confluence as your data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfluenceConfiguration {
    /// <p>The URL of your Confluence instance. Use the full URL of the server. For example, <i>https://server.example.com:port/</i>. You can also use an IP address, for example, <i>https://192.168.1.113/</i>.</p>
    #[doc(hidden)]
    pub server_url: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the user name and password required to connect to the Confluence instance. If you use Confluence Cloud, you use a generated API token as the password.</p>
    /// <p>You can also provide authentication credentials in the form of a personal access token. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-confluence.html">Using a Confluence data source</a>.</p>
    #[doc(hidden)]
    pub secret_arn: std::option::Option<std::string::String>,
    /// <p>The version or the type of Confluence installation to connect to.</p>
    #[doc(hidden)]
    pub version: std::option::Option<crate::model::ConfluenceVersion>,
    /// <p>Configuration information for indexing Confluence spaces.</p>
    #[doc(hidden)]
    pub space_configuration: std::option::Option<crate::model::ConfluenceSpaceConfiguration>,
    /// <p>Configuration information for indexing Confluence pages.</p>
    #[doc(hidden)]
    pub page_configuration: std::option::Option<crate::model::ConfluencePageConfiguration>,
    /// <p>Configuration information for indexing Confluence blogs.</p>
    #[doc(hidden)]
    pub blog_configuration: std::option::Option<crate::model::ConfluenceBlogConfiguration>,
    /// <p>Configuration information for indexing attachments to Confluence blogs and pages.</p>
    #[doc(hidden)]
    pub attachment_configuration:
        std::option::Option<crate::model::ConfluenceAttachmentConfiguration>,
    /// <p>Configuration information for an Amazon Virtual Private Cloud to connect to your Confluence. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
    #[doc(hidden)]
    pub vpc_configuration: std::option::Option<crate::model::DataSourceVpcConfiguration>,
    /// <p>A list of regular expression patterns to include certain blog posts, pages, spaces, or attachments in your Confluence. Content that matches the patterns are included in the index. Content that doesn't match the patterns is excluded from the index. If content matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the content isn't included in the index.</p>
    #[doc(hidden)]
    pub inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of regular expression patterns to exclude certain blog posts, pages, spaces, or attachments in your Confluence. Content that matches the patterns are excluded from the index. Content that doesn't match the patterns is included in the index. If content matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the content isn't included in the index.</p>
    #[doc(hidden)]
    pub exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Configuration information to connect to your Confluence URL instance via a web proxy. You can use this option for Confluence Server.</p>
    /// <p>You must provide the website host name and port number. For example, the host name of <i>https://a.example.com/page1.html</i> is "a.example.com" and the port is 443, the standard port for HTTPS.</p>
    /// <p>Web proxy credentials are optional and you can use them to connect to a web proxy server that requires basic authentication of user name and password. To store web proxy credentials, you use a secret in Secrets Manager.</p>
    /// <p>It is recommended that you follow best security practices when configuring your web proxy. This includes setting up throttling, setting up logging and monitoring, and applying security patches on a regular basis. If you use your web proxy with multiple data sources, sync jobs that occur at the same time could strain the load on your proxy. It is recommended you prepare your proxy beforehand for any security and load requirements.</p>
    #[doc(hidden)]
    pub proxy_configuration: std::option::Option<crate::model::ProxyConfiguration>,
    /// <p>Whether you want to connect to Confluence using basic authentication of user name and password, or a personal access token. You can use a personal access token for Confluence Server.</p>
    #[doc(hidden)]
    pub authentication_type: std::option::Option<crate::model::ConfluenceAuthenticationType>,
}
impl ConfluenceConfiguration {
    /// <p>The URL of your Confluence instance. Use the full URL of the server. For example, <i>https://server.example.com:port/</i>. You can also use an IP address, for example, <i>https://192.168.1.113/</i>.</p>
    pub fn server_url(&self) -> std::option::Option<&str> {
        self.server_url.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the user name and password required to connect to the Confluence instance. If you use Confluence Cloud, you use a generated API token as the password.</p>
    /// <p>You can also provide authentication credentials in the form of a personal access token. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-confluence.html">Using a Confluence data source</a>.</p>
    pub fn secret_arn(&self) -> std::option::Option<&str> {
        self.secret_arn.as_deref()
    }
    /// <p>The version or the type of Confluence installation to connect to.</p>
    pub fn version(&self) -> std::option::Option<&crate::model::ConfluenceVersion> {
        self.version.as_ref()
    }
    /// <p>Configuration information for indexing Confluence spaces.</p>
    pub fn space_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ConfluenceSpaceConfiguration> {
        self.space_configuration.as_ref()
    }
    /// <p>Configuration information for indexing Confluence pages.</p>
    pub fn page_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ConfluencePageConfiguration> {
        self.page_configuration.as_ref()
    }
    /// <p>Configuration information for indexing Confluence blogs.</p>
    pub fn blog_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ConfluenceBlogConfiguration> {
        self.blog_configuration.as_ref()
    }
    /// <p>Configuration information for indexing attachments to Confluence blogs and pages.</p>
    pub fn attachment_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ConfluenceAttachmentConfiguration> {
        self.attachment_configuration.as_ref()
    }
    /// <p>Configuration information for an Amazon Virtual Private Cloud to connect to your Confluence. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
    pub fn vpc_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DataSourceVpcConfiguration> {
        self.vpc_configuration.as_ref()
    }
    /// <p>A list of regular expression patterns to include certain blog posts, pages, spaces, or attachments in your Confluence. Content that matches the patterns are included in the index. Content that doesn't match the patterns is excluded from the index. If content matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the content isn't included in the index.</p>
    pub fn inclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.inclusion_patterns.as_deref()
    }
    /// <p>A list of regular expression patterns to exclude certain blog posts, pages, spaces, or attachments in your Confluence. Content that matches the patterns are excluded from the index. Content that doesn't match the patterns is included in the index. If content matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the content isn't included in the index.</p>
    pub fn exclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.exclusion_patterns.as_deref()
    }
    /// <p>Configuration information to connect to your Confluence URL instance via a web proxy. You can use this option for Confluence Server.</p>
    /// <p>You must provide the website host name and port number. For example, the host name of <i>https://a.example.com/page1.html</i> is "a.example.com" and the port is 443, the standard port for HTTPS.</p>
    /// <p>Web proxy credentials are optional and you can use them to connect to a web proxy server that requires basic authentication of user name and password. To store web proxy credentials, you use a secret in Secrets Manager.</p>
    /// <p>It is recommended that you follow best security practices when configuring your web proxy. This includes setting up throttling, setting up logging and monitoring, and applying security patches on a regular basis. If you use your web proxy with multiple data sources, sync jobs that occur at the same time could strain the load on your proxy. It is recommended you prepare your proxy beforehand for any security and load requirements.</p>
    pub fn proxy_configuration(&self) -> std::option::Option<&crate::model::ProxyConfiguration> {
        self.proxy_configuration.as_ref()
    }
    /// <p>Whether you want to connect to Confluence using basic authentication of user name and password, or a personal access token. You can use a personal access token for Confluence Server.</p>
    pub fn authentication_type(
        &self,
    ) -> std::option::Option<&crate::model::ConfluenceAuthenticationType> {
        self.authentication_type.as_ref()
    }
}
/// See [`ConfluenceConfiguration`](crate::model::ConfluenceConfiguration).
pub mod confluence_configuration {

    /// A builder for [`ConfluenceConfiguration`](crate::model::ConfluenceConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) server_url: std::option::Option<std::string::String>,
        pub(crate) secret_arn: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<crate::model::ConfluenceVersion>,
        pub(crate) space_configuration:
            std::option::Option<crate::model::ConfluenceSpaceConfiguration>,
        pub(crate) page_configuration:
            std::option::Option<crate::model::ConfluencePageConfiguration>,
        pub(crate) blog_configuration:
            std::option::Option<crate::model::ConfluenceBlogConfiguration>,
        pub(crate) attachment_configuration:
            std::option::Option<crate::model::ConfluenceAttachmentConfiguration>,
        pub(crate) vpc_configuration: std::option::Option<crate::model::DataSourceVpcConfiguration>,
        pub(crate) inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) proxy_configuration: std::option::Option<crate::model::ProxyConfiguration>,
        pub(crate) authentication_type:
            std::option::Option<crate::model::ConfluenceAuthenticationType>,
    }
    impl Builder {
        /// <p>The URL of your Confluence instance. Use the full URL of the server. For example, <i>https://server.example.com:port/</i>. You can also use an IP address, for example, <i>https://192.168.1.113/</i>.</p>
        pub fn server_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.server_url = Some(input.into());
            self
        }
        /// <p>The URL of your Confluence instance. Use the full URL of the server. For example, <i>https://server.example.com:port/</i>. You can also use an IP address, for example, <i>https://192.168.1.113/</i>.</p>
        pub fn set_server_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.server_url = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the user name and password required to connect to the Confluence instance. If you use Confluence Cloud, you use a generated API token as the password.</p>
        /// <p>You can also provide authentication credentials in the form of a personal access token. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-confluence.html">Using a Confluence data source</a>.</p>
        pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the user name and password required to connect to the Confluence instance. If you use Confluence Cloud, you use a generated API token as the password.</p>
        /// <p>You can also provide authentication credentials in the form of a personal access token. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-confluence.html">Using a Confluence data source</a>.</p>
        pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_arn = input;
            self
        }
        /// <p>The version or the type of Confluence installation to connect to.</p>
        pub fn version(mut self, input: crate::model::ConfluenceVersion) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>The version or the type of Confluence installation to connect to.</p>
        pub fn set_version(
            mut self,
            input: std::option::Option<crate::model::ConfluenceVersion>,
        ) -> Self {
            self.version = input;
            self
        }
        /// <p>Configuration information for indexing Confluence spaces.</p>
        pub fn space_configuration(
            mut self,
            input: crate::model::ConfluenceSpaceConfiguration,
        ) -> Self {
            self.space_configuration = Some(input);
            self
        }
        /// <p>Configuration information for indexing Confluence spaces.</p>
        pub fn set_space_configuration(
            mut self,
            input: std::option::Option<crate::model::ConfluenceSpaceConfiguration>,
        ) -> Self {
            self.space_configuration = input;
            self
        }
        /// <p>Configuration information for indexing Confluence pages.</p>
        pub fn page_configuration(
            mut self,
            input: crate::model::ConfluencePageConfiguration,
        ) -> Self {
            self.page_configuration = Some(input);
            self
        }
        /// <p>Configuration information for indexing Confluence pages.</p>
        pub fn set_page_configuration(
            mut self,
            input: std::option::Option<crate::model::ConfluencePageConfiguration>,
        ) -> Self {
            self.page_configuration = input;
            self
        }
        /// <p>Configuration information for indexing Confluence blogs.</p>
        pub fn blog_configuration(
            mut self,
            input: crate::model::ConfluenceBlogConfiguration,
        ) -> Self {
            self.blog_configuration = Some(input);
            self
        }
        /// <p>Configuration information for indexing Confluence blogs.</p>
        pub fn set_blog_configuration(
            mut self,
            input: std::option::Option<crate::model::ConfluenceBlogConfiguration>,
        ) -> Self {
            self.blog_configuration = input;
            self
        }
        /// <p>Configuration information for indexing attachments to Confluence blogs and pages.</p>
        pub fn attachment_configuration(
            mut self,
            input: crate::model::ConfluenceAttachmentConfiguration,
        ) -> Self {
            self.attachment_configuration = Some(input);
            self
        }
        /// <p>Configuration information for indexing attachments to Confluence blogs and pages.</p>
        pub fn set_attachment_configuration(
            mut self,
            input: std::option::Option<crate::model::ConfluenceAttachmentConfiguration>,
        ) -> Self {
            self.attachment_configuration = input;
            self
        }
        /// <p>Configuration information for an Amazon Virtual Private Cloud to connect to your Confluence. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
        pub fn vpc_configuration(
            mut self,
            input: crate::model::DataSourceVpcConfiguration,
        ) -> Self {
            self.vpc_configuration = Some(input);
            self
        }
        /// <p>Configuration information for an Amazon Virtual Private Cloud to connect to your Confluence. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
        pub fn set_vpc_configuration(
            mut self,
            input: std::option::Option<crate::model::DataSourceVpcConfiguration>,
        ) -> Self {
            self.vpc_configuration = input;
            self
        }
        /// Appends an item to `inclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_inclusion_patterns`](Self::set_inclusion_patterns).
        ///
        /// <p>A list of regular expression patterns to include certain blog posts, pages, spaces, or attachments in your Confluence. Content that matches the patterns are included in the index. Content that doesn't match the patterns is excluded from the index. If content matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the content isn't included in the index.</p>
        pub fn inclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.inclusion_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to include certain blog posts, pages, spaces, or attachments in your Confluence. Content that matches the patterns are included in the index. Content that doesn't match the patterns is excluded from the index. If content matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the content isn't included in the index.</p>
        pub fn set_inclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inclusion_patterns = input;
            self
        }
        /// Appends an item to `exclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_exclusion_patterns`](Self::set_exclusion_patterns).
        ///
        /// <p>A list of regular expression patterns to exclude certain blog posts, pages, spaces, or attachments in your Confluence. Content that matches the patterns are excluded from the index. Content that doesn't match the patterns is included in the index. If content matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the content isn't included in the index.</p>
        pub fn exclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.exclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.exclusion_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to exclude certain blog posts, pages, spaces, or attachments in your Confluence. Content that matches the patterns are excluded from the index. Content that doesn't match the patterns is included in the index. If content matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the content isn't included in the index.</p>
        pub fn set_exclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclusion_patterns = input;
            self
        }
        /// <p>Configuration information to connect to your Confluence URL instance via a web proxy. You can use this option for Confluence Server.</p>
        /// <p>You must provide the website host name and port number. For example, the host name of <i>https://a.example.com/page1.html</i> is "a.example.com" and the port is 443, the standard port for HTTPS.</p>
        /// <p>Web proxy credentials are optional and you can use them to connect to a web proxy server that requires basic authentication of user name and password. To store web proxy credentials, you use a secret in Secrets Manager.</p>
        /// <p>It is recommended that you follow best security practices when configuring your web proxy. This includes setting up throttling, setting up logging and monitoring, and applying security patches on a regular basis. If you use your web proxy with multiple data sources, sync jobs that occur at the same time could strain the load on your proxy. It is recommended you prepare your proxy beforehand for any security and load requirements.</p>
        pub fn proxy_configuration(mut self, input: crate::model::ProxyConfiguration) -> Self {
            self.proxy_configuration = Some(input);
            self
        }
        /// <p>Configuration information to connect to your Confluence URL instance via a web proxy. You can use this option for Confluence Server.</p>
        /// <p>You must provide the website host name and port number. For example, the host name of <i>https://a.example.com/page1.html</i> is "a.example.com" and the port is 443, the standard port for HTTPS.</p>
        /// <p>Web proxy credentials are optional and you can use them to connect to a web proxy server that requires basic authentication of user name and password. To store web proxy credentials, you use a secret in Secrets Manager.</p>
        /// <p>It is recommended that you follow best security practices when configuring your web proxy. This includes setting up throttling, setting up logging and monitoring, and applying security patches on a regular basis. If you use your web proxy with multiple data sources, sync jobs that occur at the same time could strain the load on your proxy. It is recommended you prepare your proxy beforehand for any security and load requirements.</p>
        pub fn set_proxy_configuration(
            mut self,
            input: std::option::Option<crate::model::ProxyConfiguration>,
        ) -> Self {
            self.proxy_configuration = input;
            self
        }
        /// <p>Whether you want to connect to Confluence using basic authentication of user name and password, or a personal access token. You can use a personal access token for Confluence Server.</p>
        pub fn authentication_type(
            mut self,
            input: crate::model::ConfluenceAuthenticationType,
        ) -> Self {
            self.authentication_type = Some(input);
            self
        }
        /// <p>Whether you want to connect to Confluence using basic authentication of user name and password, or a personal access token. You can use a personal access token for Confluence Server.</p>
        pub fn set_authentication_type(
            mut self,
            input: std::option::Option<crate::model::ConfluenceAuthenticationType>,
        ) -> Self {
            self.authentication_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfluenceConfiguration`](crate::model::ConfluenceConfiguration).
        pub fn build(self) -> crate::model::ConfluenceConfiguration {
            crate::model::ConfluenceConfiguration {
                server_url: self.server_url,
                secret_arn: self.secret_arn,
                version: self.version,
                space_configuration: self.space_configuration,
                page_configuration: self.page_configuration,
                blog_configuration: self.blog_configuration,
                attachment_configuration: self.attachment_configuration,
                vpc_configuration: self.vpc_configuration,
                inclusion_patterns: self.inclusion_patterns,
                exclusion_patterns: self.exclusion_patterns,
                proxy_configuration: self.proxy_configuration,
                authentication_type: self.authentication_type,
            }
        }
    }
}
impl ConfluenceConfiguration {
    /// Creates a new builder-style object to manufacture [`ConfluenceConfiguration`](crate::model::ConfluenceConfiguration).
    pub fn builder() -> crate::model::confluence_configuration::Builder {
        crate::model::confluence_configuration::Builder::default()
    }
}

/// When writing a match expression against `ConfluenceAuthenticationType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let confluenceauthenticationtype = unimplemented!();
/// match confluenceauthenticationtype {
///     ConfluenceAuthenticationType::HttpBasic => { /* ... */ },
///     ConfluenceAuthenticationType::Pat => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `confluenceauthenticationtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConfluenceAuthenticationType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConfluenceAuthenticationType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConfluenceAuthenticationType::NewFeature` is defined.
/// Specifically, when `confluenceauthenticationtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConfluenceAuthenticationType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConfluenceAuthenticationType {
    #[allow(missing_docs)] // documentation missing in model
    HttpBasic,
    #[allow(missing_docs)] // documentation missing in model
    Pat,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConfluenceAuthenticationType {
    fn from(s: &str) -> Self {
        match s {
            "HTTP_BASIC" => ConfluenceAuthenticationType::HttpBasic,
            "PAT" => ConfluenceAuthenticationType::Pat,
            other => ConfluenceAuthenticationType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ConfluenceAuthenticationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConfluenceAuthenticationType::from(s))
    }
}
impl ConfluenceAuthenticationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConfluenceAuthenticationType::HttpBasic => "HTTP_BASIC",
            ConfluenceAuthenticationType::Pat => "PAT",
            ConfluenceAuthenticationType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["HTTP_BASIC", "PAT"]
    }
}
impl AsRef<str> for ConfluenceAuthenticationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration of attachment settings for the Confluence data source. Attachment settings are optional, if you don't specify settings attachments, Amazon Kendra won't index them.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfluenceAttachmentConfiguration {
    /// <p> <code>TRUE</code> to index attachments of pages and blogs in Confluence.</p>
    #[doc(hidden)]
    pub crawl_attachments: bool,
    /// <p>Maps attributes or field names of Confluence attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Confluence fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Confluence data source field names must exist in your Confluence custom metadata.</p>
    /// <p>If you specify the <code>AttachentFieldMappings</code> parameter, you must specify at least one field mapping.</p>
    #[doc(hidden)]
    pub attachment_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::ConfluenceAttachmentToIndexFieldMapping>>,
}
impl ConfluenceAttachmentConfiguration {
    /// <p> <code>TRUE</code> to index attachments of pages and blogs in Confluence.</p>
    pub fn crawl_attachments(&self) -> bool {
        self.crawl_attachments
    }
    /// <p>Maps attributes or field names of Confluence attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Confluence fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Confluence data source field names must exist in your Confluence custom metadata.</p>
    /// <p>If you specify the <code>AttachentFieldMappings</code> parameter, you must specify at least one field mapping.</p>
    pub fn attachment_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::ConfluenceAttachmentToIndexFieldMapping]> {
        self.attachment_field_mappings.as_deref()
    }
}
/// See [`ConfluenceAttachmentConfiguration`](crate::model::ConfluenceAttachmentConfiguration).
pub mod confluence_attachment_configuration {

    /// A builder for [`ConfluenceAttachmentConfiguration`](crate::model::ConfluenceAttachmentConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) crawl_attachments: std::option::Option<bool>,
        pub(crate) attachment_field_mappings: std::option::Option<
            std::vec::Vec<crate::model::ConfluenceAttachmentToIndexFieldMapping>,
        >,
    }
    impl Builder {
        /// <p> <code>TRUE</code> to index attachments of pages and blogs in Confluence.</p>
        pub fn crawl_attachments(mut self, input: bool) -> Self {
            self.crawl_attachments = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to index attachments of pages and blogs in Confluence.</p>
        pub fn set_crawl_attachments(mut self, input: std::option::Option<bool>) -> Self {
            self.crawl_attachments = input;
            self
        }
        /// Appends an item to `attachment_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_attachment_field_mappings`](Self::set_attachment_field_mappings).
        ///
        /// <p>Maps attributes or field names of Confluence attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Confluence fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Confluence data source field names must exist in your Confluence custom metadata.</p>
        /// <p>If you specify the <code>AttachentFieldMappings</code> parameter, you must specify at least one field mapping.</p>
        pub fn attachment_field_mappings(
            mut self,
            input: crate::model::ConfluenceAttachmentToIndexFieldMapping,
        ) -> Self {
            let mut v = self.attachment_field_mappings.unwrap_or_default();
            v.push(input);
            self.attachment_field_mappings = Some(v);
            self
        }
        /// <p>Maps attributes or field names of Confluence attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Confluence fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Confluence data source field names must exist in your Confluence custom metadata.</p>
        /// <p>If you specify the <code>AttachentFieldMappings</code> parameter, you must specify at least one field mapping.</p>
        pub fn set_attachment_field_mappings(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ConfluenceAttachmentToIndexFieldMapping>,
            >,
        ) -> Self {
            self.attachment_field_mappings = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfluenceAttachmentConfiguration`](crate::model::ConfluenceAttachmentConfiguration).
        pub fn build(self) -> crate::model::ConfluenceAttachmentConfiguration {
            crate::model::ConfluenceAttachmentConfiguration {
                crawl_attachments: self.crawl_attachments.unwrap_or_default(),
                attachment_field_mappings: self.attachment_field_mappings,
            }
        }
    }
}
impl ConfluenceAttachmentConfiguration {
    /// Creates a new builder-style object to manufacture [`ConfluenceAttachmentConfiguration`](crate::model::ConfluenceAttachmentConfiguration).
    pub fn builder() -> crate::model::confluence_attachment_configuration::Builder {
        crate::model::confluence_attachment_configuration::Builder::default()
    }
}

/// <p>Maps attributes or field names of Confluence attachments to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Confluence fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Confuence data source field names must exist in your Confluence custom metadata.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfluenceAttachmentToIndexFieldMapping {
    /// <p>The name of the field in the data source. </p>
    /// <p>You must first create the index field using the <code>UpdateIndex</code> API. </p>
    #[doc(hidden)]
    pub data_source_field_name: std::option::Option<crate::model::ConfluenceAttachmentFieldName>,
    /// <p>The format for date fields in the data source. If the field specified in <code>DataSourceFieldName</code> is a date field you must specify the date format. If the field is not a date field, an exception is thrown.</p>
    #[doc(hidden)]
    pub date_field_format: std::option::Option<std::string::String>,
    /// <p>The name of the index field to map to the Confluence data source field. The index field type must match the Confluence field type.</p>
    #[doc(hidden)]
    pub index_field_name: std::option::Option<std::string::String>,
}
impl ConfluenceAttachmentToIndexFieldMapping {
    /// <p>The name of the field in the data source. </p>
    /// <p>You must first create the index field using the <code>UpdateIndex</code> API. </p>
    pub fn data_source_field_name(
        &self,
    ) -> std::option::Option<&crate::model::ConfluenceAttachmentFieldName> {
        self.data_source_field_name.as_ref()
    }
    /// <p>The format for date fields in the data source. If the field specified in <code>DataSourceFieldName</code> is a date field you must specify the date format. If the field is not a date field, an exception is thrown.</p>
    pub fn date_field_format(&self) -> std::option::Option<&str> {
        self.date_field_format.as_deref()
    }
    /// <p>The name of the index field to map to the Confluence data source field. The index field type must match the Confluence field type.</p>
    pub fn index_field_name(&self) -> std::option::Option<&str> {
        self.index_field_name.as_deref()
    }
}
/// See [`ConfluenceAttachmentToIndexFieldMapping`](crate::model::ConfluenceAttachmentToIndexFieldMapping).
pub mod confluence_attachment_to_index_field_mapping {

    /// A builder for [`ConfluenceAttachmentToIndexFieldMapping`](crate::model::ConfluenceAttachmentToIndexFieldMapping).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_source_field_name:
            std::option::Option<crate::model::ConfluenceAttachmentFieldName>,
        pub(crate) date_field_format: std::option::Option<std::string::String>,
        pub(crate) index_field_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the field in the data source. </p>
        /// <p>You must first create the index field using the <code>UpdateIndex</code> API. </p>
        pub fn data_source_field_name(
            mut self,
            input: crate::model::ConfluenceAttachmentFieldName,
        ) -> Self {
            self.data_source_field_name = Some(input);
            self
        }
        /// <p>The name of the field in the data source. </p>
        /// <p>You must first create the index field using the <code>UpdateIndex</code> API. </p>
        pub fn set_data_source_field_name(
            mut self,
            input: std::option::Option<crate::model::ConfluenceAttachmentFieldName>,
        ) -> Self {
            self.data_source_field_name = input;
            self
        }
        /// <p>The format for date fields in the data source. If the field specified in <code>DataSourceFieldName</code> is a date field you must specify the date format. If the field is not a date field, an exception is thrown.</p>
        pub fn date_field_format(mut self, input: impl Into<std::string::String>) -> Self {
            self.date_field_format = Some(input.into());
            self
        }
        /// <p>The format for date fields in the data source. If the field specified in <code>DataSourceFieldName</code> is a date field you must specify the date format. If the field is not a date field, an exception is thrown.</p>
        pub fn set_date_field_format(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.date_field_format = input;
            self
        }
        /// <p>The name of the index field to map to the Confluence data source field. The index field type must match the Confluence field type.</p>
        pub fn index_field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.index_field_name = Some(input.into());
            self
        }
        /// <p>The name of the index field to map to the Confluence data source field. The index field type must match the Confluence field type.</p>
        pub fn set_index_field_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.index_field_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfluenceAttachmentToIndexFieldMapping`](crate::model::ConfluenceAttachmentToIndexFieldMapping).
        pub fn build(self) -> crate::model::ConfluenceAttachmentToIndexFieldMapping {
            crate::model::ConfluenceAttachmentToIndexFieldMapping {
                data_source_field_name: self.data_source_field_name,
                date_field_format: self.date_field_format,
                index_field_name: self.index_field_name,
            }
        }
    }
}
impl ConfluenceAttachmentToIndexFieldMapping {
    /// Creates a new builder-style object to manufacture [`ConfluenceAttachmentToIndexFieldMapping`](crate::model::ConfluenceAttachmentToIndexFieldMapping).
    pub fn builder() -> crate::model::confluence_attachment_to_index_field_mapping::Builder {
        crate::model::confluence_attachment_to_index_field_mapping::Builder::default()
    }
}

/// When writing a match expression against `ConfluenceAttachmentFieldName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let confluenceattachmentfieldname = unimplemented!();
/// match confluenceattachmentfieldname {
///     ConfluenceAttachmentFieldName::Author => { /* ... */ },
///     ConfluenceAttachmentFieldName::ContentType => { /* ... */ },
///     ConfluenceAttachmentFieldName::CreatedDate => { /* ... */ },
///     ConfluenceAttachmentFieldName::DisplayUrl => { /* ... */ },
///     ConfluenceAttachmentFieldName::FileSize => { /* ... */ },
///     ConfluenceAttachmentFieldName::ItemType => { /* ... */ },
///     ConfluenceAttachmentFieldName::ParentId => { /* ... */ },
///     ConfluenceAttachmentFieldName::SpaceKey => { /* ... */ },
///     ConfluenceAttachmentFieldName::SpaceName => { /* ... */ },
///     ConfluenceAttachmentFieldName::Url => { /* ... */ },
///     ConfluenceAttachmentFieldName::Version => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `confluenceattachmentfieldname` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConfluenceAttachmentFieldName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConfluenceAttachmentFieldName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConfluenceAttachmentFieldName::NewFeature` is defined.
/// Specifically, when `confluenceattachmentfieldname` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConfluenceAttachmentFieldName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConfluenceAttachmentFieldName {
    #[allow(missing_docs)] // documentation missing in model
    Author,
    #[allow(missing_docs)] // documentation missing in model
    ContentType,
    #[allow(missing_docs)] // documentation missing in model
    CreatedDate,
    #[allow(missing_docs)] // documentation missing in model
    DisplayUrl,
    #[allow(missing_docs)] // documentation missing in model
    FileSize,
    #[allow(missing_docs)] // documentation missing in model
    ItemType,
    #[allow(missing_docs)] // documentation missing in model
    ParentId,
    #[allow(missing_docs)] // documentation missing in model
    SpaceKey,
    #[allow(missing_docs)] // documentation missing in model
    SpaceName,
    #[allow(missing_docs)] // documentation missing in model
    Url,
    #[allow(missing_docs)] // documentation missing in model
    Version,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConfluenceAttachmentFieldName {
    fn from(s: &str) -> Self {
        match s {
            "AUTHOR" => ConfluenceAttachmentFieldName::Author,
            "CONTENT_TYPE" => ConfluenceAttachmentFieldName::ContentType,
            "CREATED_DATE" => ConfluenceAttachmentFieldName::CreatedDate,
            "DISPLAY_URL" => ConfluenceAttachmentFieldName::DisplayUrl,
            "FILE_SIZE" => ConfluenceAttachmentFieldName::FileSize,
            "ITEM_TYPE" => ConfluenceAttachmentFieldName::ItemType,
            "PARENT_ID" => ConfluenceAttachmentFieldName::ParentId,
            "SPACE_KEY" => ConfluenceAttachmentFieldName::SpaceKey,
            "SPACE_NAME" => ConfluenceAttachmentFieldName::SpaceName,
            "URL" => ConfluenceAttachmentFieldName::Url,
            "VERSION" => ConfluenceAttachmentFieldName::Version,
            other => ConfluenceAttachmentFieldName::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ConfluenceAttachmentFieldName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConfluenceAttachmentFieldName::from(s))
    }
}
impl ConfluenceAttachmentFieldName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConfluenceAttachmentFieldName::Author => "AUTHOR",
            ConfluenceAttachmentFieldName::ContentType => "CONTENT_TYPE",
            ConfluenceAttachmentFieldName::CreatedDate => "CREATED_DATE",
            ConfluenceAttachmentFieldName::DisplayUrl => "DISPLAY_URL",
            ConfluenceAttachmentFieldName::FileSize => "FILE_SIZE",
            ConfluenceAttachmentFieldName::ItemType => "ITEM_TYPE",
            ConfluenceAttachmentFieldName::ParentId => "PARENT_ID",
            ConfluenceAttachmentFieldName::SpaceKey => "SPACE_KEY",
            ConfluenceAttachmentFieldName::SpaceName => "SPACE_NAME",
            ConfluenceAttachmentFieldName::Url => "URL",
            ConfluenceAttachmentFieldName::Version => "VERSION",
            ConfluenceAttachmentFieldName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AUTHOR",
            "CONTENT_TYPE",
            "CREATED_DATE",
            "DISPLAY_URL",
            "FILE_SIZE",
            "ITEM_TYPE",
            "PARENT_ID",
            "SPACE_KEY",
            "SPACE_NAME",
            "URL",
            "VERSION",
        ]
    }
}
impl AsRef<str> for ConfluenceAttachmentFieldName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration of blog settings for the Confluence data source. Blogs are always indexed unless filtered from the index by the <code>ExclusionPatterns</code> or <code>InclusionPatterns</code> fields in the <code>ConfluenceConfiguration</code> object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfluenceBlogConfiguration {
    /// <p>Maps attributes or field names of Confluence blogs to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Confluence fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Confluence data source field names must exist in your Confluence custom metadata.</p>
    /// <p>If you specify the <code>BlogFieldMappings</code> parameter, you must specify at least one field mapping.</p>
    #[doc(hidden)]
    pub blog_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::ConfluenceBlogToIndexFieldMapping>>,
}
impl ConfluenceBlogConfiguration {
    /// <p>Maps attributes or field names of Confluence blogs to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Confluence fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Confluence data source field names must exist in your Confluence custom metadata.</p>
    /// <p>If you specify the <code>BlogFieldMappings</code> parameter, you must specify at least one field mapping.</p>
    pub fn blog_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::ConfluenceBlogToIndexFieldMapping]> {
        self.blog_field_mappings.as_deref()
    }
}
/// See [`ConfluenceBlogConfiguration`](crate::model::ConfluenceBlogConfiguration).
pub mod confluence_blog_configuration {

    /// A builder for [`ConfluenceBlogConfiguration`](crate::model::ConfluenceBlogConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) blog_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::ConfluenceBlogToIndexFieldMapping>>,
    }
    impl Builder {
        /// Appends an item to `blog_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_blog_field_mappings`](Self::set_blog_field_mappings).
        ///
        /// <p>Maps attributes or field names of Confluence blogs to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Confluence fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Confluence data source field names must exist in your Confluence custom metadata.</p>
        /// <p>If you specify the <code>BlogFieldMappings</code> parameter, you must specify at least one field mapping.</p>
        pub fn blog_field_mappings(
            mut self,
            input: crate::model::ConfluenceBlogToIndexFieldMapping,
        ) -> Self {
            let mut v = self.blog_field_mappings.unwrap_or_default();
            v.push(input);
            self.blog_field_mappings = Some(v);
            self
        }
        /// <p>Maps attributes or field names of Confluence blogs to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Confluence fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Confluence data source field names must exist in your Confluence custom metadata.</p>
        /// <p>If you specify the <code>BlogFieldMappings</code> parameter, you must specify at least one field mapping.</p>
        pub fn set_blog_field_mappings(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ConfluenceBlogToIndexFieldMapping>,
            >,
        ) -> Self {
            self.blog_field_mappings = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfluenceBlogConfiguration`](crate::model::ConfluenceBlogConfiguration).
        pub fn build(self) -> crate::model::ConfluenceBlogConfiguration {
            crate::model::ConfluenceBlogConfiguration {
                blog_field_mappings: self.blog_field_mappings,
            }
        }
    }
}
impl ConfluenceBlogConfiguration {
    /// Creates a new builder-style object to manufacture [`ConfluenceBlogConfiguration`](crate::model::ConfluenceBlogConfiguration).
    pub fn builder() -> crate::model::confluence_blog_configuration::Builder {
        crate::model::confluence_blog_configuration::Builder::default()
    }
}

/// <p>Maps attributes or field names of Confluence blog to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Confluence fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Confluence data source field names must exist in your Confluence custom metadata.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfluenceBlogToIndexFieldMapping {
    /// <p>The name of the field in the data source. </p>
    #[doc(hidden)]
    pub data_source_field_name: std::option::Option<crate::model::ConfluenceBlogFieldName>,
    /// <p>The format for date fields in the data source. If the field specified in <code>DataSourceFieldName</code> is a date field you must specify the date format. If the field is not a date field, an exception is thrown.</p>
    #[doc(hidden)]
    pub date_field_format: std::option::Option<std::string::String>,
    /// <p>The name of the index field to map to the Confluence data source field. The index field type must match the Confluence field type.</p>
    #[doc(hidden)]
    pub index_field_name: std::option::Option<std::string::String>,
}
impl ConfluenceBlogToIndexFieldMapping {
    /// <p>The name of the field in the data source. </p>
    pub fn data_source_field_name(
        &self,
    ) -> std::option::Option<&crate::model::ConfluenceBlogFieldName> {
        self.data_source_field_name.as_ref()
    }
    /// <p>The format for date fields in the data source. If the field specified in <code>DataSourceFieldName</code> is a date field you must specify the date format. If the field is not a date field, an exception is thrown.</p>
    pub fn date_field_format(&self) -> std::option::Option<&str> {
        self.date_field_format.as_deref()
    }
    /// <p>The name of the index field to map to the Confluence data source field. The index field type must match the Confluence field type.</p>
    pub fn index_field_name(&self) -> std::option::Option<&str> {
        self.index_field_name.as_deref()
    }
}
/// See [`ConfluenceBlogToIndexFieldMapping`](crate::model::ConfluenceBlogToIndexFieldMapping).
pub mod confluence_blog_to_index_field_mapping {

    /// A builder for [`ConfluenceBlogToIndexFieldMapping`](crate::model::ConfluenceBlogToIndexFieldMapping).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_source_field_name:
            std::option::Option<crate::model::ConfluenceBlogFieldName>,
        pub(crate) date_field_format: std::option::Option<std::string::String>,
        pub(crate) index_field_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the field in the data source. </p>
        pub fn data_source_field_name(
            mut self,
            input: crate::model::ConfluenceBlogFieldName,
        ) -> Self {
            self.data_source_field_name = Some(input);
            self
        }
        /// <p>The name of the field in the data source. </p>
        pub fn set_data_source_field_name(
            mut self,
            input: std::option::Option<crate::model::ConfluenceBlogFieldName>,
        ) -> Self {
            self.data_source_field_name = input;
            self
        }
        /// <p>The format for date fields in the data source. If the field specified in <code>DataSourceFieldName</code> is a date field you must specify the date format. If the field is not a date field, an exception is thrown.</p>
        pub fn date_field_format(mut self, input: impl Into<std::string::String>) -> Self {
            self.date_field_format = Some(input.into());
            self
        }
        /// <p>The format for date fields in the data source. If the field specified in <code>DataSourceFieldName</code> is a date field you must specify the date format. If the field is not a date field, an exception is thrown.</p>
        pub fn set_date_field_format(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.date_field_format = input;
            self
        }
        /// <p>The name of the index field to map to the Confluence data source field. The index field type must match the Confluence field type.</p>
        pub fn index_field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.index_field_name = Some(input.into());
            self
        }
        /// <p>The name of the index field to map to the Confluence data source field. The index field type must match the Confluence field type.</p>
        pub fn set_index_field_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.index_field_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfluenceBlogToIndexFieldMapping`](crate::model::ConfluenceBlogToIndexFieldMapping).
        pub fn build(self) -> crate::model::ConfluenceBlogToIndexFieldMapping {
            crate::model::ConfluenceBlogToIndexFieldMapping {
                data_source_field_name: self.data_source_field_name,
                date_field_format: self.date_field_format,
                index_field_name: self.index_field_name,
            }
        }
    }
}
impl ConfluenceBlogToIndexFieldMapping {
    /// Creates a new builder-style object to manufacture [`ConfluenceBlogToIndexFieldMapping`](crate::model::ConfluenceBlogToIndexFieldMapping).
    pub fn builder() -> crate::model::confluence_blog_to_index_field_mapping::Builder {
        crate::model::confluence_blog_to_index_field_mapping::Builder::default()
    }
}

/// When writing a match expression against `ConfluenceBlogFieldName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let confluenceblogfieldname = unimplemented!();
/// match confluenceblogfieldname {
///     ConfluenceBlogFieldName::Author => { /* ... */ },
///     ConfluenceBlogFieldName::DisplayUrl => { /* ... */ },
///     ConfluenceBlogFieldName::ItemType => { /* ... */ },
///     ConfluenceBlogFieldName::Labels => { /* ... */ },
///     ConfluenceBlogFieldName::PublishDate => { /* ... */ },
///     ConfluenceBlogFieldName::SpaceKey => { /* ... */ },
///     ConfluenceBlogFieldName::SpaceName => { /* ... */ },
///     ConfluenceBlogFieldName::Url => { /* ... */ },
///     ConfluenceBlogFieldName::Version => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `confluenceblogfieldname` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConfluenceBlogFieldName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConfluenceBlogFieldName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConfluenceBlogFieldName::NewFeature` is defined.
/// Specifically, when `confluenceblogfieldname` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConfluenceBlogFieldName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConfluenceBlogFieldName {
    #[allow(missing_docs)] // documentation missing in model
    Author,
    #[allow(missing_docs)] // documentation missing in model
    DisplayUrl,
    #[allow(missing_docs)] // documentation missing in model
    ItemType,
    #[allow(missing_docs)] // documentation missing in model
    Labels,
    #[allow(missing_docs)] // documentation missing in model
    PublishDate,
    #[allow(missing_docs)] // documentation missing in model
    SpaceKey,
    #[allow(missing_docs)] // documentation missing in model
    SpaceName,
    #[allow(missing_docs)] // documentation missing in model
    Url,
    #[allow(missing_docs)] // documentation missing in model
    Version,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConfluenceBlogFieldName {
    fn from(s: &str) -> Self {
        match s {
            "AUTHOR" => ConfluenceBlogFieldName::Author,
            "DISPLAY_URL" => ConfluenceBlogFieldName::DisplayUrl,
            "ITEM_TYPE" => ConfluenceBlogFieldName::ItemType,
            "LABELS" => ConfluenceBlogFieldName::Labels,
            "PUBLISH_DATE" => ConfluenceBlogFieldName::PublishDate,
            "SPACE_KEY" => ConfluenceBlogFieldName::SpaceKey,
            "SPACE_NAME" => ConfluenceBlogFieldName::SpaceName,
            "URL" => ConfluenceBlogFieldName::Url,
            "VERSION" => ConfluenceBlogFieldName::Version,
            other => ConfluenceBlogFieldName::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ConfluenceBlogFieldName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConfluenceBlogFieldName::from(s))
    }
}
impl ConfluenceBlogFieldName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConfluenceBlogFieldName::Author => "AUTHOR",
            ConfluenceBlogFieldName::DisplayUrl => "DISPLAY_URL",
            ConfluenceBlogFieldName::ItemType => "ITEM_TYPE",
            ConfluenceBlogFieldName::Labels => "LABELS",
            ConfluenceBlogFieldName::PublishDate => "PUBLISH_DATE",
            ConfluenceBlogFieldName::SpaceKey => "SPACE_KEY",
            ConfluenceBlogFieldName::SpaceName => "SPACE_NAME",
            ConfluenceBlogFieldName::Url => "URL",
            ConfluenceBlogFieldName::Version => "VERSION",
            ConfluenceBlogFieldName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AUTHOR",
            "DISPLAY_URL",
            "ITEM_TYPE",
            "LABELS",
            "PUBLISH_DATE",
            "SPACE_KEY",
            "SPACE_NAME",
            "URL",
            "VERSION",
        ]
    }
}
impl AsRef<str> for ConfluenceBlogFieldName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration of the page settings for the Confluence data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfluencePageConfiguration {
    /// <p>Maps attributes or field names of Confluence pages to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Confluence fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Confluence data source field names must exist in your Confluence custom metadata.</p>
    /// <p>If you specify the <code>PageFieldMappings</code> parameter, you must specify at least one field mapping.</p>
    #[doc(hidden)]
    pub page_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::ConfluencePageToIndexFieldMapping>>,
}
impl ConfluencePageConfiguration {
    /// <p>Maps attributes or field names of Confluence pages to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Confluence fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Confluence data source field names must exist in your Confluence custom metadata.</p>
    /// <p>If you specify the <code>PageFieldMappings</code> parameter, you must specify at least one field mapping.</p>
    pub fn page_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::ConfluencePageToIndexFieldMapping]> {
        self.page_field_mappings.as_deref()
    }
}
/// See [`ConfluencePageConfiguration`](crate::model::ConfluencePageConfiguration).
pub mod confluence_page_configuration {

    /// A builder for [`ConfluencePageConfiguration`](crate::model::ConfluencePageConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::ConfluencePageToIndexFieldMapping>>,
    }
    impl Builder {
        /// Appends an item to `page_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_page_field_mappings`](Self::set_page_field_mappings).
        ///
        /// <p>Maps attributes or field names of Confluence pages to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Confluence fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Confluence data source field names must exist in your Confluence custom metadata.</p>
        /// <p>If you specify the <code>PageFieldMappings</code> parameter, you must specify at least one field mapping.</p>
        pub fn page_field_mappings(
            mut self,
            input: crate::model::ConfluencePageToIndexFieldMapping,
        ) -> Self {
            let mut v = self.page_field_mappings.unwrap_or_default();
            v.push(input);
            self.page_field_mappings = Some(v);
            self
        }
        /// <p>Maps attributes or field names of Confluence pages to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Confluence fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Confluence data source field names must exist in your Confluence custom metadata.</p>
        /// <p>If you specify the <code>PageFieldMappings</code> parameter, you must specify at least one field mapping.</p>
        pub fn set_page_field_mappings(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ConfluencePageToIndexFieldMapping>,
            >,
        ) -> Self {
            self.page_field_mappings = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfluencePageConfiguration`](crate::model::ConfluencePageConfiguration).
        pub fn build(self) -> crate::model::ConfluencePageConfiguration {
            crate::model::ConfluencePageConfiguration {
                page_field_mappings: self.page_field_mappings,
            }
        }
    }
}
impl ConfluencePageConfiguration {
    /// Creates a new builder-style object to manufacture [`ConfluencePageConfiguration`](crate::model::ConfluencePageConfiguration).
    pub fn builder() -> crate::model::confluence_page_configuration::Builder {
        crate::model::confluence_page_configuration::Builder::default()
    }
}

/// <p>Maps attributes or field names of Confluence pages to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Confluence fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Confluence data source field names must exist in your Confluence custom metadata.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfluencePageToIndexFieldMapping {
    /// <p>The name of the field in the data source.</p>
    #[doc(hidden)]
    pub data_source_field_name: std::option::Option<crate::model::ConfluencePageFieldName>,
    /// <p>The format for date fields in the data source. If the field specified in <code>DataSourceFieldName</code> is a date field you must specify the date format. If the field is not a date field, an exception is thrown.</p>
    #[doc(hidden)]
    pub date_field_format: std::option::Option<std::string::String>,
    /// <p>The name of the index field to map to the Confluence data source field. The index field type must match the Confluence field type.</p>
    #[doc(hidden)]
    pub index_field_name: std::option::Option<std::string::String>,
}
impl ConfluencePageToIndexFieldMapping {
    /// <p>The name of the field in the data source.</p>
    pub fn data_source_field_name(
        &self,
    ) -> std::option::Option<&crate::model::ConfluencePageFieldName> {
        self.data_source_field_name.as_ref()
    }
    /// <p>The format for date fields in the data source. If the field specified in <code>DataSourceFieldName</code> is a date field you must specify the date format. If the field is not a date field, an exception is thrown.</p>
    pub fn date_field_format(&self) -> std::option::Option<&str> {
        self.date_field_format.as_deref()
    }
    /// <p>The name of the index field to map to the Confluence data source field. The index field type must match the Confluence field type.</p>
    pub fn index_field_name(&self) -> std::option::Option<&str> {
        self.index_field_name.as_deref()
    }
}
/// See [`ConfluencePageToIndexFieldMapping`](crate::model::ConfluencePageToIndexFieldMapping).
pub mod confluence_page_to_index_field_mapping {

    /// A builder for [`ConfluencePageToIndexFieldMapping`](crate::model::ConfluencePageToIndexFieldMapping).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_source_field_name:
            std::option::Option<crate::model::ConfluencePageFieldName>,
        pub(crate) date_field_format: std::option::Option<std::string::String>,
        pub(crate) index_field_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the field in the data source.</p>
        pub fn data_source_field_name(
            mut self,
            input: crate::model::ConfluencePageFieldName,
        ) -> Self {
            self.data_source_field_name = Some(input);
            self
        }
        /// <p>The name of the field in the data source.</p>
        pub fn set_data_source_field_name(
            mut self,
            input: std::option::Option<crate::model::ConfluencePageFieldName>,
        ) -> Self {
            self.data_source_field_name = input;
            self
        }
        /// <p>The format for date fields in the data source. If the field specified in <code>DataSourceFieldName</code> is a date field you must specify the date format. If the field is not a date field, an exception is thrown.</p>
        pub fn date_field_format(mut self, input: impl Into<std::string::String>) -> Self {
            self.date_field_format = Some(input.into());
            self
        }
        /// <p>The format for date fields in the data source. If the field specified in <code>DataSourceFieldName</code> is a date field you must specify the date format. If the field is not a date field, an exception is thrown.</p>
        pub fn set_date_field_format(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.date_field_format = input;
            self
        }
        /// <p>The name of the index field to map to the Confluence data source field. The index field type must match the Confluence field type.</p>
        pub fn index_field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.index_field_name = Some(input.into());
            self
        }
        /// <p>The name of the index field to map to the Confluence data source field. The index field type must match the Confluence field type.</p>
        pub fn set_index_field_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.index_field_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfluencePageToIndexFieldMapping`](crate::model::ConfluencePageToIndexFieldMapping).
        pub fn build(self) -> crate::model::ConfluencePageToIndexFieldMapping {
            crate::model::ConfluencePageToIndexFieldMapping {
                data_source_field_name: self.data_source_field_name,
                date_field_format: self.date_field_format,
                index_field_name: self.index_field_name,
            }
        }
    }
}
impl ConfluencePageToIndexFieldMapping {
    /// Creates a new builder-style object to manufacture [`ConfluencePageToIndexFieldMapping`](crate::model::ConfluencePageToIndexFieldMapping).
    pub fn builder() -> crate::model::confluence_page_to_index_field_mapping::Builder {
        crate::model::confluence_page_to_index_field_mapping::Builder::default()
    }
}

/// When writing a match expression against `ConfluencePageFieldName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let confluencepagefieldname = unimplemented!();
/// match confluencepagefieldname {
///     ConfluencePageFieldName::Author => { /* ... */ },
///     ConfluencePageFieldName::ContentStatus => { /* ... */ },
///     ConfluencePageFieldName::CreatedDate => { /* ... */ },
///     ConfluencePageFieldName::DisplayUrl => { /* ... */ },
///     ConfluencePageFieldName::ItemType => { /* ... */ },
///     ConfluencePageFieldName::Labels => { /* ... */ },
///     ConfluencePageFieldName::ModifiedDate => { /* ... */ },
///     ConfluencePageFieldName::ParentId => { /* ... */ },
///     ConfluencePageFieldName::SpaceKey => { /* ... */ },
///     ConfluencePageFieldName::SpaceName => { /* ... */ },
///     ConfluencePageFieldName::Url => { /* ... */ },
///     ConfluencePageFieldName::Version => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `confluencepagefieldname` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConfluencePageFieldName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConfluencePageFieldName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConfluencePageFieldName::NewFeature` is defined.
/// Specifically, when `confluencepagefieldname` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConfluencePageFieldName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConfluencePageFieldName {
    #[allow(missing_docs)] // documentation missing in model
    Author,
    #[allow(missing_docs)] // documentation missing in model
    ContentStatus,
    #[allow(missing_docs)] // documentation missing in model
    CreatedDate,
    #[allow(missing_docs)] // documentation missing in model
    DisplayUrl,
    #[allow(missing_docs)] // documentation missing in model
    ItemType,
    #[allow(missing_docs)] // documentation missing in model
    Labels,
    #[allow(missing_docs)] // documentation missing in model
    ModifiedDate,
    #[allow(missing_docs)] // documentation missing in model
    ParentId,
    #[allow(missing_docs)] // documentation missing in model
    SpaceKey,
    #[allow(missing_docs)] // documentation missing in model
    SpaceName,
    #[allow(missing_docs)] // documentation missing in model
    Url,
    #[allow(missing_docs)] // documentation missing in model
    Version,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConfluencePageFieldName {
    fn from(s: &str) -> Self {
        match s {
            "AUTHOR" => ConfluencePageFieldName::Author,
            "CONTENT_STATUS" => ConfluencePageFieldName::ContentStatus,
            "CREATED_DATE" => ConfluencePageFieldName::CreatedDate,
            "DISPLAY_URL" => ConfluencePageFieldName::DisplayUrl,
            "ITEM_TYPE" => ConfluencePageFieldName::ItemType,
            "LABELS" => ConfluencePageFieldName::Labels,
            "MODIFIED_DATE" => ConfluencePageFieldName::ModifiedDate,
            "PARENT_ID" => ConfluencePageFieldName::ParentId,
            "SPACE_KEY" => ConfluencePageFieldName::SpaceKey,
            "SPACE_NAME" => ConfluencePageFieldName::SpaceName,
            "URL" => ConfluencePageFieldName::Url,
            "VERSION" => ConfluencePageFieldName::Version,
            other => ConfluencePageFieldName::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ConfluencePageFieldName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConfluencePageFieldName::from(s))
    }
}
impl ConfluencePageFieldName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConfluencePageFieldName::Author => "AUTHOR",
            ConfluencePageFieldName::ContentStatus => "CONTENT_STATUS",
            ConfluencePageFieldName::CreatedDate => "CREATED_DATE",
            ConfluencePageFieldName::DisplayUrl => "DISPLAY_URL",
            ConfluencePageFieldName::ItemType => "ITEM_TYPE",
            ConfluencePageFieldName::Labels => "LABELS",
            ConfluencePageFieldName::ModifiedDate => "MODIFIED_DATE",
            ConfluencePageFieldName::ParentId => "PARENT_ID",
            ConfluencePageFieldName::SpaceKey => "SPACE_KEY",
            ConfluencePageFieldName::SpaceName => "SPACE_NAME",
            ConfluencePageFieldName::Url => "URL",
            ConfluencePageFieldName::Version => "VERSION",
            ConfluencePageFieldName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AUTHOR",
            "CONTENT_STATUS",
            "CREATED_DATE",
            "DISPLAY_URL",
            "ITEM_TYPE",
            "LABELS",
            "MODIFIED_DATE",
            "PARENT_ID",
            "SPACE_KEY",
            "SPACE_NAME",
            "URL",
            "VERSION",
        ]
    }
}
impl AsRef<str> for ConfluencePageFieldName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration information for indexing Confluence spaces.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfluenceSpaceConfiguration {
    /// <p> <code>TRUE</code> to index personal spaces. You can add restrictions to items in personal spaces. If personal spaces are indexed, queries without user context information may return restricted items from a personal space in their results. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/user-context-filter.html">Filtering on user context</a>.</p>
    #[doc(hidden)]
    pub crawl_personal_spaces: bool,
    /// <p> <code>TRUE</code> to index archived spaces.</p>
    #[doc(hidden)]
    pub crawl_archived_spaces: bool,
    /// <p>A list of space keys for Confluence spaces. If you include a key, the blogs, documents, and attachments in the space are indexed. Spaces that aren't in the list aren't indexed. A space in the list must exist. Otherwise, Amazon Kendra logs an error when the data source is synchronized. If a space is in both the <code>IncludeSpaces</code> and the <code>ExcludeSpaces</code> list, the space is excluded.</p>
    #[doc(hidden)]
    pub include_spaces: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of space keys of Confluence spaces. If you include a key, the blogs, documents, and attachments in the space are not indexed. If a space is in both the <code>ExcludeSpaces</code> and the <code>IncludeSpaces</code> list, the space is excluded.</p>
    #[doc(hidden)]
    pub exclude_spaces: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Maps attributes or field names of Confluence spaces to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Confluence fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Confluence data source field names must exist in your Confluence custom metadata.</p>
    /// <p>If you specify the <code>SpaceFieldMappings</code> parameter, you must specify at least one field mapping.</p>
    #[doc(hidden)]
    pub space_field_mappings:
        std::option::Option<std::vec::Vec<crate::model::ConfluenceSpaceToIndexFieldMapping>>,
}
impl ConfluenceSpaceConfiguration {
    /// <p> <code>TRUE</code> to index personal spaces. You can add restrictions to items in personal spaces. If personal spaces are indexed, queries without user context information may return restricted items from a personal space in their results. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/user-context-filter.html">Filtering on user context</a>.</p>
    pub fn crawl_personal_spaces(&self) -> bool {
        self.crawl_personal_spaces
    }
    /// <p> <code>TRUE</code> to index archived spaces.</p>
    pub fn crawl_archived_spaces(&self) -> bool {
        self.crawl_archived_spaces
    }
    /// <p>A list of space keys for Confluence spaces. If you include a key, the blogs, documents, and attachments in the space are indexed. Spaces that aren't in the list aren't indexed. A space in the list must exist. Otherwise, Amazon Kendra logs an error when the data source is synchronized. If a space is in both the <code>IncludeSpaces</code> and the <code>ExcludeSpaces</code> list, the space is excluded.</p>
    pub fn include_spaces(&self) -> std::option::Option<&[std::string::String]> {
        self.include_spaces.as_deref()
    }
    /// <p>A list of space keys of Confluence spaces. If you include a key, the blogs, documents, and attachments in the space are not indexed. If a space is in both the <code>ExcludeSpaces</code> and the <code>IncludeSpaces</code> list, the space is excluded.</p>
    pub fn exclude_spaces(&self) -> std::option::Option<&[std::string::String]> {
        self.exclude_spaces.as_deref()
    }
    /// <p>Maps attributes or field names of Confluence spaces to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Confluence fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Confluence data source field names must exist in your Confluence custom metadata.</p>
    /// <p>If you specify the <code>SpaceFieldMappings</code> parameter, you must specify at least one field mapping.</p>
    pub fn space_field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::ConfluenceSpaceToIndexFieldMapping]> {
        self.space_field_mappings.as_deref()
    }
}
/// See [`ConfluenceSpaceConfiguration`](crate::model::ConfluenceSpaceConfiguration).
pub mod confluence_space_configuration {

    /// A builder for [`ConfluenceSpaceConfiguration`](crate::model::ConfluenceSpaceConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) crawl_personal_spaces: std::option::Option<bool>,
        pub(crate) crawl_archived_spaces: std::option::Option<bool>,
        pub(crate) include_spaces: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) exclude_spaces: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) space_field_mappings:
            std::option::Option<std::vec::Vec<crate::model::ConfluenceSpaceToIndexFieldMapping>>,
    }
    impl Builder {
        /// <p> <code>TRUE</code> to index personal spaces. You can add restrictions to items in personal spaces. If personal spaces are indexed, queries without user context information may return restricted items from a personal space in their results. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/user-context-filter.html">Filtering on user context</a>.</p>
        pub fn crawl_personal_spaces(mut self, input: bool) -> Self {
            self.crawl_personal_spaces = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to index personal spaces. You can add restrictions to items in personal spaces. If personal spaces are indexed, queries without user context information may return restricted items from a personal space in their results. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/user-context-filter.html">Filtering on user context</a>.</p>
        pub fn set_crawl_personal_spaces(mut self, input: std::option::Option<bool>) -> Self {
            self.crawl_personal_spaces = input;
            self
        }
        /// <p> <code>TRUE</code> to index archived spaces.</p>
        pub fn crawl_archived_spaces(mut self, input: bool) -> Self {
            self.crawl_archived_spaces = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to index archived spaces.</p>
        pub fn set_crawl_archived_spaces(mut self, input: std::option::Option<bool>) -> Self {
            self.crawl_archived_spaces = input;
            self
        }
        /// Appends an item to `include_spaces`.
        ///
        /// To override the contents of this collection use [`set_include_spaces`](Self::set_include_spaces).
        ///
        /// <p>A list of space keys for Confluence spaces. If you include a key, the blogs, documents, and attachments in the space are indexed. Spaces that aren't in the list aren't indexed. A space in the list must exist. Otherwise, Amazon Kendra logs an error when the data source is synchronized. If a space is in both the <code>IncludeSpaces</code> and the <code>ExcludeSpaces</code> list, the space is excluded.</p>
        pub fn include_spaces(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.include_spaces.unwrap_or_default();
            v.push(input.into());
            self.include_spaces = Some(v);
            self
        }
        /// <p>A list of space keys for Confluence spaces. If you include a key, the blogs, documents, and attachments in the space are indexed. Spaces that aren't in the list aren't indexed. A space in the list must exist. Otherwise, Amazon Kendra logs an error when the data source is synchronized. If a space is in both the <code>IncludeSpaces</code> and the <code>ExcludeSpaces</code> list, the space is excluded.</p>
        pub fn set_include_spaces(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.include_spaces = input;
            self
        }
        /// Appends an item to `exclude_spaces`.
        ///
        /// To override the contents of this collection use [`set_exclude_spaces`](Self::set_exclude_spaces).
        ///
        /// <p>A list of space keys of Confluence spaces. If you include a key, the blogs, documents, and attachments in the space are not indexed. If a space is in both the <code>ExcludeSpaces</code> and the <code>IncludeSpaces</code> list, the space is excluded.</p>
        pub fn exclude_spaces(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.exclude_spaces.unwrap_or_default();
            v.push(input.into());
            self.exclude_spaces = Some(v);
            self
        }
        /// <p>A list of space keys of Confluence spaces. If you include a key, the blogs, documents, and attachments in the space are not indexed. If a space is in both the <code>ExcludeSpaces</code> and the <code>IncludeSpaces</code> list, the space is excluded.</p>
        pub fn set_exclude_spaces(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclude_spaces = input;
            self
        }
        /// Appends an item to `space_field_mappings`.
        ///
        /// To override the contents of this collection use [`set_space_field_mappings`](Self::set_space_field_mappings).
        ///
        /// <p>Maps attributes or field names of Confluence spaces to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Confluence fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Confluence data source field names must exist in your Confluence custom metadata.</p>
        /// <p>If you specify the <code>SpaceFieldMappings</code> parameter, you must specify at least one field mapping.</p>
        pub fn space_field_mappings(
            mut self,
            input: crate::model::ConfluenceSpaceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.space_field_mappings.unwrap_or_default();
            v.push(input);
            self.space_field_mappings = Some(v);
            self
        }
        /// <p>Maps attributes or field names of Confluence spaces to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Confluence fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Confluence data source field names must exist in your Confluence custom metadata.</p>
        /// <p>If you specify the <code>SpaceFieldMappings</code> parameter, you must specify at least one field mapping.</p>
        pub fn set_space_field_mappings(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ConfluenceSpaceToIndexFieldMapping>,
            >,
        ) -> Self {
            self.space_field_mappings = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfluenceSpaceConfiguration`](crate::model::ConfluenceSpaceConfiguration).
        pub fn build(self) -> crate::model::ConfluenceSpaceConfiguration {
            crate::model::ConfluenceSpaceConfiguration {
                crawl_personal_spaces: self.crawl_personal_spaces.unwrap_or_default(),
                crawl_archived_spaces: self.crawl_archived_spaces.unwrap_or_default(),
                include_spaces: self.include_spaces,
                exclude_spaces: self.exclude_spaces,
                space_field_mappings: self.space_field_mappings,
            }
        }
    }
}
impl ConfluenceSpaceConfiguration {
    /// Creates a new builder-style object to manufacture [`ConfluenceSpaceConfiguration`](crate::model::ConfluenceSpaceConfiguration).
    pub fn builder() -> crate::model::confluence_space_configuration::Builder {
        crate::model::confluence_space_configuration::Builder::default()
    }
}

/// <p>Maps attributes or field names of Confluence spaces to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Confluence fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Confluence data source field names must exist in your Confluence custom metadata.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfluenceSpaceToIndexFieldMapping {
    /// <p>The name of the field in the data source. </p>
    #[doc(hidden)]
    pub data_source_field_name: std::option::Option<crate::model::ConfluenceSpaceFieldName>,
    /// <p>The format for date fields in the data source. If the field specified in <code>DataSourceFieldName</code> is a date field you must specify the date format. If the field is not a date field, an exception is thrown.</p>
    #[doc(hidden)]
    pub date_field_format: std::option::Option<std::string::String>,
    /// <p>The name of the index field to map to the Confluence data source field. The index field type must match the Confluence field type.</p>
    #[doc(hidden)]
    pub index_field_name: std::option::Option<std::string::String>,
}
impl ConfluenceSpaceToIndexFieldMapping {
    /// <p>The name of the field in the data source. </p>
    pub fn data_source_field_name(
        &self,
    ) -> std::option::Option<&crate::model::ConfluenceSpaceFieldName> {
        self.data_source_field_name.as_ref()
    }
    /// <p>The format for date fields in the data source. If the field specified in <code>DataSourceFieldName</code> is a date field you must specify the date format. If the field is not a date field, an exception is thrown.</p>
    pub fn date_field_format(&self) -> std::option::Option<&str> {
        self.date_field_format.as_deref()
    }
    /// <p>The name of the index field to map to the Confluence data source field. The index field type must match the Confluence field type.</p>
    pub fn index_field_name(&self) -> std::option::Option<&str> {
        self.index_field_name.as_deref()
    }
}
/// See [`ConfluenceSpaceToIndexFieldMapping`](crate::model::ConfluenceSpaceToIndexFieldMapping).
pub mod confluence_space_to_index_field_mapping {

    /// A builder for [`ConfluenceSpaceToIndexFieldMapping`](crate::model::ConfluenceSpaceToIndexFieldMapping).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_source_field_name:
            std::option::Option<crate::model::ConfluenceSpaceFieldName>,
        pub(crate) date_field_format: std::option::Option<std::string::String>,
        pub(crate) index_field_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the field in the data source. </p>
        pub fn data_source_field_name(
            mut self,
            input: crate::model::ConfluenceSpaceFieldName,
        ) -> Self {
            self.data_source_field_name = Some(input);
            self
        }
        /// <p>The name of the field in the data source. </p>
        pub fn set_data_source_field_name(
            mut self,
            input: std::option::Option<crate::model::ConfluenceSpaceFieldName>,
        ) -> Self {
            self.data_source_field_name = input;
            self
        }
        /// <p>The format for date fields in the data source. If the field specified in <code>DataSourceFieldName</code> is a date field you must specify the date format. If the field is not a date field, an exception is thrown.</p>
        pub fn date_field_format(mut self, input: impl Into<std::string::String>) -> Self {
            self.date_field_format = Some(input.into());
            self
        }
        /// <p>The format for date fields in the data source. If the field specified in <code>DataSourceFieldName</code> is a date field you must specify the date format. If the field is not a date field, an exception is thrown.</p>
        pub fn set_date_field_format(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.date_field_format = input;
            self
        }
        /// <p>The name of the index field to map to the Confluence data source field. The index field type must match the Confluence field type.</p>
        pub fn index_field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.index_field_name = Some(input.into());
            self
        }
        /// <p>The name of the index field to map to the Confluence data source field. The index field type must match the Confluence field type.</p>
        pub fn set_index_field_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.index_field_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfluenceSpaceToIndexFieldMapping`](crate::model::ConfluenceSpaceToIndexFieldMapping).
        pub fn build(self) -> crate::model::ConfluenceSpaceToIndexFieldMapping {
            crate::model::ConfluenceSpaceToIndexFieldMapping {
                data_source_field_name: self.data_source_field_name,
                date_field_format: self.date_field_format,
                index_field_name: self.index_field_name,
            }
        }
    }
}
impl ConfluenceSpaceToIndexFieldMapping {
    /// Creates a new builder-style object to manufacture [`ConfluenceSpaceToIndexFieldMapping`](crate::model::ConfluenceSpaceToIndexFieldMapping).
    pub fn builder() -> crate::model::confluence_space_to_index_field_mapping::Builder {
        crate::model::confluence_space_to_index_field_mapping::Builder::default()
    }
}

/// When writing a match expression against `ConfluenceSpaceFieldName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let confluencespacefieldname = unimplemented!();
/// match confluencespacefieldname {
///     ConfluenceSpaceFieldName::DisplayUrl => { /* ... */ },
///     ConfluenceSpaceFieldName::ItemType => { /* ... */ },
///     ConfluenceSpaceFieldName::SpaceKey => { /* ... */ },
///     ConfluenceSpaceFieldName::Url => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `confluencespacefieldname` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConfluenceSpaceFieldName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConfluenceSpaceFieldName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConfluenceSpaceFieldName::NewFeature` is defined.
/// Specifically, when `confluencespacefieldname` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConfluenceSpaceFieldName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConfluenceSpaceFieldName {
    #[allow(missing_docs)] // documentation missing in model
    DisplayUrl,
    #[allow(missing_docs)] // documentation missing in model
    ItemType,
    #[allow(missing_docs)] // documentation missing in model
    SpaceKey,
    #[allow(missing_docs)] // documentation missing in model
    Url,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConfluenceSpaceFieldName {
    fn from(s: &str) -> Self {
        match s {
            "DISPLAY_URL" => ConfluenceSpaceFieldName::DisplayUrl,
            "ITEM_TYPE" => ConfluenceSpaceFieldName::ItemType,
            "SPACE_KEY" => ConfluenceSpaceFieldName::SpaceKey,
            "URL" => ConfluenceSpaceFieldName::Url,
            other => ConfluenceSpaceFieldName::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ConfluenceSpaceFieldName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConfluenceSpaceFieldName::from(s))
    }
}
impl ConfluenceSpaceFieldName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConfluenceSpaceFieldName::DisplayUrl => "DISPLAY_URL",
            ConfluenceSpaceFieldName::ItemType => "ITEM_TYPE",
            ConfluenceSpaceFieldName::SpaceKey => "SPACE_KEY",
            ConfluenceSpaceFieldName::Url => "URL",
            ConfluenceSpaceFieldName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISPLAY_URL", "ITEM_TYPE", "SPACE_KEY", "URL"]
    }
}
impl AsRef<str> for ConfluenceSpaceFieldName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ConfluenceVersion`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let confluenceversion = unimplemented!();
/// match confluenceversion {
///     ConfluenceVersion::Cloud => { /* ... */ },
///     ConfluenceVersion::Server => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `confluenceversion` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConfluenceVersion::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConfluenceVersion::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConfluenceVersion::NewFeature` is defined.
/// Specifically, when `confluenceversion` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConfluenceVersion::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConfluenceVersion {
    #[allow(missing_docs)] // documentation missing in model
    Cloud,
    #[allow(missing_docs)] // documentation missing in model
    Server,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConfluenceVersion {
    fn from(s: &str) -> Self {
        match s {
            "CLOUD" => ConfluenceVersion::Cloud,
            "SERVER" => ConfluenceVersion::Server,
            other => {
                ConfluenceVersion::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ConfluenceVersion {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConfluenceVersion::from(s))
    }
}
impl ConfluenceVersion {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConfluenceVersion::Cloud => "CLOUD",
            ConfluenceVersion::Server => "SERVER",
            ConfluenceVersion::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CLOUD", "SERVER"]
    }
}
impl AsRef<str> for ConfluenceVersion {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides the configuration information to connect to ServiceNow as your data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceNowConfiguration {
    /// <p>The ServiceNow instance that the data source connects to. The host endpoint should look like the following: <i>{instance}.service-now.com.</i> </p>
    #[doc(hidden)]
    pub host_url: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Secrets Manager secret that contains the user name and password required to connect to the ServiceNow instance. You can also provide OAuth authentication credentials of user name, password, client ID, and client secret. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-servicenow.html">Using a ServiceNow data source</a>.</p>
    #[doc(hidden)]
    pub secret_arn: std::option::Option<std::string::String>,
    /// <p>The identifier of the release that the ServiceNow host is running. If the host is not running the <code>LONDON</code> release, use <code>OTHERS</code>.</p>
    #[doc(hidden)]
    pub service_now_build_version: std::option::Option<crate::model::ServiceNowBuildVersionType>,
    /// <p>Configuration information for crawling knowledge articles in the ServiceNow site.</p>
    #[doc(hidden)]
    pub knowledge_article_configuration:
        std::option::Option<crate::model::ServiceNowKnowledgeArticleConfiguration>,
    /// <p>Configuration information for crawling service catalogs in the ServiceNow site.</p>
    #[doc(hidden)]
    pub service_catalog_configuration:
        std::option::Option<crate::model::ServiceNowServiceCatalogConfiguration>,
    /// <p>The type of authentication used to connect to the ServiceNow instance. If you choose <code>HTTP_BASIC</code>, Amazon Kendra is authenticated using the user name and password provided in the Secrets Manager secret in the <code>SecretArn</code> field. If you choose <code>OAUTH2</code>, Amazon Kendra is authenticated using the credentials of client ID, client secret, user name and password.</p>
    /// <p>When you use <code>OAUTH2</code> authentication, you must generate a token and a client secret using the ServiceNow console. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-servicenow.html">Using a ServiceNow data source</a>.</p>
    #[doc(hidden)]
    pub authentication_type: std::option::Option<crate::model::ServiceNowAuthenticationType>,
}
impl ServiceNowConfiguration {
    /// <p>The ServiceNow instance that the data source connects to. The host endpoint should look like the following: <i>{instance}.service-now.com.</i> </p>
    pub fn host_url(&self) -> std::option::Option<&str> {
        self.host_url.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Secrets Manager secret that contains the user name and password required to connect to the ServiceNow instance. You can also provide OAuth authentication credentials of user name, password, client ID, and client secret. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-servicenow.html">Using a ServiceNow data source</a>.</p>
    pub fn secret_arn(&self) -> std::option::Option<&str> {
        self.secret_arn.as_deref()
    }
    /// <p>The identifier of the release that the ServiceNow host is running. If the host is not running the <code>LONDON</code> release, use <code>OTHERS</code>.</p>
    pub fn service_now_build_version(
        &self,
    ) -> std::option::Option<&crate::model::ServiceNowBuildVersionType> {
        self.service_now_build_version.as_ref()
    }
    /// <p>Configuration information for crawling knowledge articles in the ServiceNow site.</p>
    pub fn knowledge_article_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ServiceNowKnowledgeArticleConfiguration> {
        self.knowledge_article_configuration.as_ref()
    }
    /// <p>Configuration information for crawling service catalogs in the ServiceNow site.</p>
    pub fn service_catalog_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ServiceNowServiceCatalogConfiguration> {
        self.service_catalog_configuration.as_ref()
    }
    /// <p>The type of authentication used to connect to the ServiceNow instance. If you choose <code>HTTP_BASIC</code>, Amazon Kendra is authenticated using the user name and password provided in the Secrets Manager secret in the <code>SecretArn</code> field. If you choose <code>OAUTH2</code>, Amazon Kendra is authenticated using the credentials of client ID, client secret, user name and password.</p>
    /// <p>When you use <code>OAUTH2</code> authentication, you must generate a token and a client secret using the ServiceNow console. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-servicenow.html">Using a ServiceNow data source</a>.</p>
    pub fn authentication_type(
        &self,
    ) -> std::option::Option<&crate::model::ServiceNowAuthenticationType> {
        self.authentication_type.as_ref()
    }
}
/// See [`ServiceNowConfiguration`](crate::model::ServiceNowConfiguration).
pub mod service_now_configuration {

    /// A builder for [`ServiceNowConfiguration`](crate::model::ServiceNowConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) host_url: std::option::Option<std::string::String>,
        pub(crate) secret_arn: std::option::Option<std::string::String>,
        pub(crate) service_now_build_version:
            std::option::Option<crate::model::ServiceNowBuildVersionType>,
        pub(crate) knowledge_article_configuration:
            std::option::Option<crate::model::ServiceNowKnowledgeArticleConfiguration>,
        pub(crate) service_catalog_configuration:
            std::option::Option<crate::model::ServiceNowServiceCatalogConfiguration>,
        pub(crate) authentication_type:
            std::option::Option<crate::model::ServiceNowAuthenticationType>,
    }
    impl Builder {
        /// <p>The ServiceNow instance that the data source connects to. The host endpoint should look like the following: <i>{instance}.service-now.com.</i> </p>
        pub fn host_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.host_url = Some(input.into());
            self
        }
        /// <p>The ServiceNow instance that the data source connects to. The host endpoint should look like the following: <i>{instance}.service-now.com.</i> </p>
        pub fn set_host_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host_url = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Secrets Manager secret that contains the user name and password required to connect to the ServiceNow instance. You can also provide OAuth authentication credentials of user name, password, client ID, and client secret. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-servicenow.html">Using a ServiceNow data source</a>.</p>
        pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Secrets Manager secret that contains the user name and password required to connect to the ServiceNow instance. You can also provide OAuth authentication credentials of user name, password, client ID, and client secret. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-servicenow.html">Using a ServiceNow data source</a>.</p>
        pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_arn = input;
            self
        }
        /// <p>The identifier of the release that the ServiceNow host is running. If the host is not running the <code>LONDON</code> release, use <code>OTHERS</code>.</p>
        pub fn service_now_build_version(
            mut self,
            input: crate::model::ServiceNowBuildVersionType,
        ) -> Self {
            self.service_now_build_version = Some(input);
            self
        }
        /// <p>The identifier of the release that the ServiceNow host is running. If the host is not running the <code>LONDON</code> release, use <code>OTHERS</code>.</p>
        pub fn set_service_now_build_version(
            mut self,
            input: std::option::Option<crate::model::ServiceNowBuildVersionType>,
        ) -> Self {
            self.service_now_build_version = input;
            self
        }
        /// <p>Configuration information for crawling knowledge articles in the ServiceNow site.</p>
        pub fn knowledge_article_configuration(
            mut self,
            input: crate::model::ServiceNowKnowledgeArticleConfiguration,
        ) -> Self {
            self.knowledge_article_configuration = Some(input);
            self
        }
        /// <p>Configuration information for crawling knowledge articles in the ServiceNow site.</p>
        pub fn set_knowledge_article_configuration(
            mut self,
            input: std::option::Option<crate::model::ServiceNowKnowledgeArticleConfiguration>,
        ) -> Self {
            self.knowledge_article_configuration = input;
            self
        }
        /// <p>Configuration information for crawling service catalogs in the ServiceNow site.</p>
        pub fn service_catalog_configuration(
            mut self,
            input: crate::model::ServiceNowServiceCatalogConfiguration,
        ) -> Self {
            self.service_catalog_configuration = Some(input);
            self
        }
        /// <p>Configuration information for crawling service catalogs in the ServiceNow site.</p>
        pub fn set_service_catalog_configuration(
            mut self,
            input: std::option::Option<crate::model::ServiceNowServiceCatalogConfiguration>,
        ) -> Self {
            self.service_catalog_configuration = input;
            self
        }
        /// <p>The type of authentication used to connect to the ServiceNow instance. If you choose <code>HTTP_BASIC</code>, Amazon Kendra is authenticated using the user name and password provided in the Secrets Manager secret in the <code>SecretArn</code> field. If you choose <code>OAUTH2</code>, Amazon Kendra is authenticated using the credentials of client ID, client secret, user name and password.</p>
        /// <p>When you use <code>OAUTH2</code> authentication, you must generate a token and a client secret using the ServiceNow console. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-servicenow.html">Using a ServiceNow data source</a>.</p>
        pub fn authentication_type(
            mut self,
            input: crate::model::ServiceNowAuthenticationType,
        ) -> Self {
            self.authentication_type = Some(input);
            self
        }
        /// <p>The type of authentication used to connect to the ServiceNow instance. If you choose <code>HTTP_BASIC</code>, Amazon Kendra is authenticated using the user name and password provided in the Secrets Manager secret in the <code>SecretArn</code> field. If you choose <code>OAUTH2</code>, Amazon Kendra is authenticated using the credentials of client ID, client secret, user name and password.</p>
        /// <p>When you use <code>OAUTH2</code> authentication, you must generate a token and a client secret using the ServiceNow console. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-servicenow.html">Using a ServiceNow data source</a>.</p>
        pub fn set_authentication_type(
            mut self,
            input: std::option::Option<crate::model::ServiceNowAuthenticationType>,
        ) -> Self {
            self.authentication_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceNowConfiguration`](crate::model::ServiceNowConfiguration).
        pub fn build(self) -> crate::model::ServiceNowConfiguration {
            crate::model::ServiceNowConfiguration {
                host_url: self.host_url,
                secret_arn: self.secret_arn,
                service_now_build_version: self.service_now_build_version,
                knowledge_article_configuration: self.knowledge_article_configuration,
                service_catalog_configuration: self.service_catalog_configuration,
                authentication_type: self.authentication_type,
            }
        }
    }
}
impl ServiceNowConfiguration {
    /// Creates a new builder-style object to manufacture [`ServiceNowConfiguration`](crate::model::ServiceNowConfiguration).
    pub fn builder() -> crate::model::service_now_configuration::Builder {
        crate::model::service_now_configuration::Builder::default()
    }
}

/// When writing a match expression against `ServiceNowAuthenticationType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let servicenowauthenticationtype = unimplemented!();
/// match servicenowauthenticationtype {
///     ServiceNowAuthenticationType::HttpBasic => { /* ... */ },
///     ServiceNowAuthenticationType::Oauth2 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `servicenowauthenticationtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ServiceNowAuthenticationType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ServiceNowAuthenticationType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ServiceNowAuthenticationType::NewFeature` is defined.
/// Specifically, when `servicenowauthenticationtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ServiceNowAuthenticationType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ServiceNowAuthenticationType {
    #[allow(missing_docs)] // documentation missing in model
    HttpBasic,
    #[allow(missing_docs)] // documentation missing in model
    Oauth2,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ServiceNowAuthenticationType {
    fn from(s: &str) -> Self {
        match s {
            "HTTP_BASIC" => ServiceNowAuthenticationType::HttpBasic,
            "OAUTH2" => ServiceNowAuthenticationType::Oauth2,
            other => ServiceNowAuthenticationType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ServiceNowAuthenticationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ServiceNowAuthenticationType::from(s))
    }
}
impl ServiceNowAuthenticationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ServiceNowAuthenticationType::HttpBasic => "HTTP_BASIC",
            ServiceNowAuthenticationType::Oauth2 => "OAUTH2",
            ServiceNowAuthenticationType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["HTTP_BASIC", "OAUTH2"]
    }
}
impl AsRef<str> for ServiceNowAuthenticationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides the configuration information for crawling service catalog items in the ServiceNow site</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceNowServiceCatalogConfiguration {
    /// <p> <code>TRUE</code> to index attachments to service catalog items.</p>
    #[doc(hidden)]
    pub crawl_attachments: bool,
    /// <p>A list of regular expression patterns to include certain attachments of catalogs in your ServiceNow. Item that match the patterns are included in the index. Items that don't match the patterns are excluded from the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.</p>
    /// <p>The regex is applied to the file name of the attachment.</p>
    #[doc(hidden)]
    pub include_attachment_file_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of regular expression patterns to exclude certain attachments of catalogs in your ServiceNow. Item that match the patterns are excluded from the index. Items that don't match the patterns are included in the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.</p>
    /// <p>The regex is applied to the file name of the attachment.</p>
    #[doc(hidden)]
    pub exclude_attachment_file_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of the ServiceNow field that is mapped to the index document contents field in the Amazon Kendra index.</p>
    #[doc(hidden)]
    pub document_data_field_name: std::option::Option<std::string::String>,
    /// <p>The name of the ServiceNow field that is mapped to the index document title field.</p>
    #[doc(hidden)]
    pub document_title_field_name: std::option::Option<std::string::String>,
    /// <p>Maps attributes or field names of catalogs to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to ServiceNow fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The ServiceNow data source field names must exist in your ServiceNow custom metadata.</p>
    #[doc(hidden)]
    pub field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
}
impl ServiceNowServiceCatalogConfiguration {
    /// <p> <code>TRUE</code> to index attachments to service catalog items.</p>
    pub fn crawl_attachments(&self) -> bool {
        self.crawl_attachments
    }
    /// <p>A list of regular expression patterns to include certain attachments of catalogs in your ServiceNow. Item that match the patterns are included in the index. Items that don't match the patterns are excluded from the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.</p>
    /// <p>The regex is applied to the file name of the attachment.</p>
    pub fn include_attachment_file_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.include_attachment_file_patterns.as_deref()
    }
    /// <p>A list of regular expression patterns to exclude certain attachments of catalogs in your ServiceNow. Item that match the patterns are excluded from the index. Items that don't match the patterns are included in the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.</p>
    /// <p>The regex is applied to the file name of the attachment.</p>
    pub fn exclude_attachment_file_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.exclude_attachment_file_patterns.as_deref()
    }
    /// <p>The name of the ServiceNow field that is mapped to the index document contents field in the Amazon Kendra index.</p>
    pub fn document_data_field_name(&self) -> std::option::Option<&str> {
        self.document_data_field_name.as_deref()
    }
    /// <p>The name of the ServiceNow field that is mapped to the index document title field.</p>
    pub fn document_title_field_name(&self) -> std::option::Option<&str> {
        self.document_title_field_name.as_deref()
    }
    /// <p>Maps attributes or field names of catalogs to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to ServiceNow fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The ServiceNow data source field names must exist in your ServiceNow custom metadata.</p>
    pub fn field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.field_mappings.as_deref()
    }
}
/// See [`ServiceNowServiceCatalogConfiguration`](crate::model::ServiceNowServiceCatalogConfiguration).
pub mod service_now_service_catalog_configuration {

    /// A builder for [`ServiceNowServiceCatalogConfiguration`](crate::model::ServiceNowServiceCatalogConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) crawl_attachments: std::option::Option<bool>,
        pub(crate) include_attachment_file_patterns:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) exclude_attachment_file_patterns:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) document_data_field_name: std::option::Option<std::string::String>,
        pub(crate) document_title_field_name: std::option::Option<std::string::String>,
        pub(crate) field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    }
    impl Builder {
        /// <p> <code>TRUE</code> to index attachments to service catalog items.</p>
        pub fn crawl_attachments(mut self, input: bool) -> Self {
            self.crawl_attachments = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to index attachments to service catalog items.</p>
        pub fn set_crawl_attachments(mut self, input: std::option::Option<bool>) -> Self {
            self.crawl_attachments = input;
            self
        }
        /// Appends an item to `include_attachment_file_patterns`.
        ///
        /// To override the contents of this collection use [`set_include_attachment_file_patterns`](Self::set_include_attachment_file_patterns).
        ///
        /// <p>A list of regular expression patterns to include certain attachments of catalogs in your ServiceNow. Item that match the patterns are included in the index. Items that don't match the patterns are excluded from the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.</p>
        /// <p>The regex is applied to the file name of the attachment.</p>
        pub fn include_attachment_file_patterns(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.include_attachment_file_patterns.unwrap_or_default();
            v.push(input.into());
            self.include_attachment_file_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to include certain attachments of catalogs in your ServiceNow. Item that match the patterns are included in the index. Items that don't match the patterns are excluded from the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.</p>
        /// <p>The regex is applied to the file name of the attachment.</p>
        pub fn set_include_attachment_file_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.include_attachment_file_patterns = input;
            self
        }
        /// Appends an item to `exclude_attachment_file_patterns`.
        ///
        /// To override the contents of this collection use [`set_exclude_attachment_file_patterns`](Self::set_exclude_attachment_file_patterns).
        ///
        /// <p>A list of regular expression patterns to exclude certain attachments of catalogs in your ServiceNow. Item that match the patterns are excluded from the index. Items that don't match the patterns are included in the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.</p>
        /// <p>The regex is applied to the file name of the attachment.</p>
        pub fn exclude_attachment_file_patterns(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.exclude_attachment_file_patterns.unwrap_or_default();
            v.push(input.into());
            self.exclude_attachment_file_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to exclude certain attachments of catalogs in your ServiceNow. Item that match the patterns are excluded from the index. Items that don't match the patterns are included in the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.</p>
        /// <p>The regex is applied to the file name of the attachment.</p>
        pub fn set_exclude_attachment_file_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclude_attachment_file_patterns = input;
            self
        }
        /// <p>The name of the ServiceNow field that is mapped to the index document contents field in the Amazon Kendra index.</p>
        pub fn document_data_field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_data_field_name = Some(input.into());
            self
        }
        /// <p>The name of the ServiceNow field that is mapped to the index document contents field in the Amazon Kendra index.</p>
        pub fn set_document_data_field_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_data_field_name = input;
            self
        }
        /// <p>The name of the ServiceNow field that is mapped to the index document title field.</p>
        pub fn document_title_field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_title_field_name = Some(input.into());
            self
        }
        /// <p>The name of the ServiceNow field that is mapped to the index document title field.</p>
        pub fn set_document_title_field_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_title_field_name = input;
            self
        }
        /// Appends an item to `field_mappings`.
        ///
        /// To override the contents of this collection use [`set_field_mappings`](Self::set_field_mappings).
        ///
        /// <p>Maps attributes or field names of catalogs to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to ServiceNow fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The ServiceNow data source field names must exist in your ServiceNow custom metadata.</p>
        pub fn field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.field_mappings.unwrap_or_default();
            v.push(input);
            self.field_mappings = Some(v);
            self
        }
        /// <p>Maps attributes or field names of catalogs to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to ServiceNow fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The ServiceNow data source field names must exist in your ServiceNow custom metadata.</p>
        pub fn set_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.field_mappings = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceNowServiceCatalogConfiguration`](crate::model::ServiceNowServiceCatalogConfiguration).
        pub fn build(self) -> crate::model::ServiceNowServiceCatalogConfiguration {
            crate::model::ServiceNowServiceCatalogConfiguration {
                crawl_attachments: self.crawl_attachments.unwrap_or_default(),
                include_attachment_file_patterns: self.include_attachment_file_patterns,
                exclude_attachment_file_patterns: self.exclude_attachment_file_patterns,
                document_data_field_name: self.document_data_field_name,
                document_title_field_name: self.document_title_field_name,
                field_mappings: self.field_mappings,
            }
        }
    }
}
impl ServiceNowServiceCatalogConfiguration {
    /// Creates a new builder-style object to manufacture [`ServiceNowServiceCatalogConfiguration`](crate::model::ServiceNowServiceCatalogConfiguration).
    pub fn builder() -> crate::model::service_now_service_catalog_configuration::Builder {
        crate::model::service_now_service_catalog_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information for crawling knowledge articles in the ServiceNow site.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceNowKnowledgeArticleConfiguration {
    /// <p> <code>TRUE</code> to index attachments to knowledge articles.</p>
    #[doc(hidden)]
    pub crawl_attachments: bool,
    /// <p>A list of regular expression patterns to include certain attachments of knowledge articles in your ServiceNow. Item that match the patterns are included in the index. Items that don't match the patterns are excluded from the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.</p>
    /// <p>The regex is applied to the field specified in the <code>PatternTargetField</code>.</p>
    #[doc(hidden)]
    pub include_attachment_file_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of regular expression patterns to exclude certain attachments of knowledge articles in your ServiceNow. Item that match the patterns are excluded from the index. Items that don't match the patterns are included in the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.</p>
    /// <p>The regex is applied to the field specified in the <code>PatternTargetField</code>.</p>
    #[doc(hidden)]
    pub exclude_attachment_file_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of the ServiceNow field that is mapped to the index document contents field in the Amazon Kendra index.</p>
    #[doc(hidden)]
    pub document_data_field_name: std::option::Option<std::string::String>,
    /// <p>The name of the ServiceNow field that is mapped to the index document title field.</p>
    #[doc(hidden)]
    pub document_title_field_name: std::option::Option<std::string::String>,
    /// <p>Maps attributes or field names of knoweldge articles to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to ServiceNow fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The ServiceNow data source field names must exist in your ServiceNow custom metadata.</p>
    #[doc(hidden)]
    pub field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>A query that selects the knowledge articles to index. The query can return articles from multiple knowledge bases, and the knowledge bases can be public or private.</p>
    /// <p>The query string must be one generated by the ServiceNow console. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/servicenow-query.html">Specifying documents to index with a query</a>. </p>
    #[doc(hidden)]
    pub filter_query: std::option::Option<std::string::String>,
}
impl ServiceNowKnowledgeArticleConfiguration {
    /// <p> <code>TRUE</code> to index attachments to knowledge articles.</p>
    pub fn crawl_attachments(&self) -> bool {
        self.crawl_attachments
    }
    /// <p>A list of regular expression patterns to include certain attachments of knowledge articles in your ServiceNow. Item that match the patterns are included in the index. Items that don't match the patterns are excluded from the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.</p>
    /// <p>The regex is applied to the field specified in the <code>PatternTargetField</code>.</p>
    pub fn include_attachment_file_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.include_attachment_file_patterns.as_deref()
    }
    /// <p>A list of regular expression patterns to exclude certain attachments of knowledge articles in your ServiceNow. Item that match the patterns are excluded from the index. Items that don't match the patterns are included in the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.</p>
    /// <p>The regex is applied to the field specified in the <code>PatternTargetField</code>.</p>
    pub fn exclude_attachment_file_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.exclude_attachment_file_patterns.as_deref()
    }
    /// <p>The name of the ServiceNow field that is mapped to the index document contents field in the Amazon Kendra index.</p>
    pub fn document_data_field_name(&self) -> std::option::Option<&str> {
        self.document_data_field_name.as_deref()
    }
    /// <p>The name of the ServiceNow field that is mapped to the index document title field.</p>
    pub fn document_title_field_name(&self) -> std::option::Option<&str> {
        self.document_title_field_name.as_deref()
    }
    /// <p>Maps attributes or field names of knoweldge articles to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to ServiceNow fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The ServiceNow data source field names must exist in your ServiceNow custom metadata.</p>
    pub fn field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.field_mappings.as_deref()
    }
    /// <p>A query that selects the knowledge articles to index. The query can return articles from multiple knowledge bases, and the knowledge bases can be public or private.</p>
    /// <p>The query string must be one generated by the ServiceNow console. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/servicenow-query.html">Specifying documents to index with a query</a>. </p>
    pub fn filter_query(&self) -> std::option::Option<&str> {
        self.filter_query.as_deref()
    }
}
/// See [`ServiceNowKnowledgeArticleConfiguration`](crate::model::ServiceNowKnowledgeArticleConfiguration).
pub mod service_now_knowledge_article_configuration {

    /// A builder for [`ServiceNowKnowledgeArticleConfiguration`](crate::model::ServiceNowKnowledgeArticleConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) crawl_attachments: std::option::Option<bool>,
        pub(crate) include_attachment_file_patterns:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) exclude_attachment_file_patterns:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) document_data_field_name: std::option::Option<std::string::String>,
        pub(crate) document_title_field_name: std::option::Option<std::string::String>,
        pub(crate) field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) filter_query: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> <code>TRUE</code> to index attachments to knowledge articles.</p>
        pub fn crawl_attachments(mut self, input: bool) -> Self {
            self.crawl_attachments = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to index attachments to knowledge articles.</p>
        pub fn set_crawl_attachments(mut self, input: std::option::Option<bool>) -> Self {
            self.crawl_attachments = input;
            self
        }
        /// Appends an item to `include_attachment_file_patterns`.
        ///
        /// To override the contents of this collection use [`set_include_attachment_file_patterns`](Self::set_include_attachment_file_patterns).
        ///
        /// <p>A list of regular expression patterns to include certain attachments of knowledge articles in your ServiceNow. Item that match the patterns are included in the index. Items that don't match the patterns are excluded from the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.</p>
        /// <p>The regex is applied to the field specified in the <code>PatternTargetField</code>.</p>
        pub fn include_attachment_file_patterns(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.include_attachment_file_patterns.unwrap_or_default();
            v.push(input.into());
            self.include_attachment_file_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to include certain attachments of knowledge articles in your ServiceNow. Item that match the patterns are included in the index. Items that don't match the patterns are excluded from the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.</p>
        /// <p>The regex is applied to the field specified in the <code>PatternTargetField</code>.</p>
        pub fn set_include_attachment_file_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.include_attachment_file_patterns = input;
            self
        }
        /// Appends an item to `exclude_attachment_file_patterns`.
        ///
        /// To override the contents of this collection use [`set_exclude_attachment_file_patterns`](Self::set_exclude_attachment_file_patterns).
        ///
        /// <p>A list of regular expression patterns to exclude certain attachments of knowledge articles in your ServiceNow. Item that match the patterns are excluded from the index. Items that don't match the patterns are included in the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.</p>
        /// <p>The regex is applied to the field specified in the <code>PatternTargetField</code>.</p>
        pub fn exclude_attachment_file_patterns(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.exclude_attachment_file_patterns.unwrap_or_default();
            v.push(input.into());
            self.exclude_attachment_file_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to exclude certain attachments of knowledge articles in your ServiceNow. Item that match the patterns are excluded from the index. Items that don't match the patterns are included in the index. If an item matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the item isn't included in the index.</p>
        /// <p>The regex is applied to the field specified in the <code>PatternTargetField</code>.</p>
        pub fn set_exclude_attachment_file_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclude_attachment_file_patterns = input;
            self
        }
        /// <p>The name of the ServiceNow field that is mapped to the index document contents field in the Amazon Kendra index.</p>
        pub fn document_data_field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_data_field_name = Some(input.into());
            self
        }
        /// <p>The name of the ServiceNow field that is mapped to the index document contents field in the Amazon Kendra index.</p>
        pub fn set_document_data_field_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_data_field_name = input;
            self
        }
        /// <p>The name of the ServiceNow field that is mapped to the index document title field.</p>
        pub fn document_title_field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_title_field_name = Some(input.into());
            self
        }
        /// <p>The name of the ServiceNow field that is mapped to the index document title field.</p>
        pub fn set_document_title_field_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_title_field_name = input;
            self
        }
        /// Appends an item to `field_mappings`.
        ///
        /// To override the contents of this collection use [`set_field_mappings`](Self::set_field_mappings).
        ///
        /// <p>Maps attributes or field names of knoweldge articles to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to ServiceNow fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The ServiceNow data source field names must exist in your ServiceNow custom metadata.</p>
        pub fn field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.field_mappings.unwrap_or_default();
            v.push(input);
            self.field_mappings = Some(v);
            self
        }
        /// <p>Maps attributes or field names of knoweldge articles to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to ServiceNow fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The ServiceNow data source field names must exist in your ServiceNow custom metadata.</p>
        pub fn set_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.field_mappings = input;
            self
        }
        /// <p>A query that selects the knowledge articles to index. The query can return articles from multiple knowledge bases, and the knowledge bases can be public or private.</p>
        /// <p>The query string must be one generated by the ServiceNow console. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/servicenow-query.html">Specifying documents to index with a query</a>. </p>
        pub fn filter_query(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_query = Some(input.into());
            self
        }
        /// <p>A query that selects the knowledge articles to index. The query can return articles from multiple knowledge bases, and the knowledge bases can be public or private.</p>
        /// <p>The query string must be one generated by the ServiceNow console. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/servicenow-query.html">Specifying documents to index with a query</a>. </p>
        pub fn set_filter_query(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.filter_query = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceNowKnowledgeArticleConfiguration`](crate::model::ServiceNowKnowledgeArticleConfiguration).
        pub fn build(self) -> crate::model::ServiceNowKnowledgeArticleConfiguration {
            crate::model::ServiceNowKnowledgeArticleConfiguration {
                crawl_attachments: self.crawl_attachments.unwrap_or_default(),
                include_attachment_file_patterns: self.include_attachment_file_patterns,
                exclude_attachment_file_patterns: self.exclude_attachment_file_patterns,
                document_data_field_name: self.document_data_field_name,
                document_title_field_name: self.document_title_field_name,
                field_mappings: self.field_mappings,
                filter_query: self.filter_query,
            }
        }
    }
}
impl ServiceNowKnowledgeArticleConfiguration {
    /// Creates a new builder-style object to manufacture [`ServiceNowKnowledgeArticleConfiguration`](crate::model::ServiceNowKnowledgeArticleConfiguration).
    pub fn builder() -> crate::model::service_now_knowledge_article_configuration::Builder {
        crate::model::service_now_knowledge_article_configuration::Builder::default()
    }
}

/// When writing a match expression against `ServiceNowBuildVersionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let servicenowbuildversiontype = unimplemented!();
/// match servicenowbuildversiontype {
///     ServiceNowBuildVersionType::London => { /* ... */ },
///     ServiceNowBuildVersionType::Others => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `servicenowbuildversiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ServiceNowBuildVersionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ServiceNowBuildVersionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ServiceNowBuildVersionType::NewFeature` is defined.
/// Specifically, when `servicenowbuildversiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ServiceNowBuildVersionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ServiceNowBuildVersionType {
    #[allow(missing_docs)] // documentation missing in model
    London,
    #[allow(missing_docs)] // documentation missing in model
    Others,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ServiceNowBuildVersionType {
    fn from(s: &str) -> Self {
        match s {
            "LONDON" => ServiceNowBuildVersionType::London,
            "OTHERS" => ServiceNowBuildVersionType::Others,
            other => ServiceNowBuildVersionType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ServiceNowBuildVersionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ServiceNowBuildVersionType::from(s))
    }
}
impl ServiceNowBuildVersionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ServiceNowBuildVersionType::London => "LONDON",
            ServiceNowBuildVersionType::Others => "OTHERS",
            ServiceNowBuildVersionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LONDON", "OTHERS"]
    }
}
impl AsRef<str> for ServiceNowBuildVersionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides the configuration information to connect to OneDrive as your data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OneDriveConfiguration {
    /// <p>The Azure Active Directory domain of the organization. </p>
    #[doc(hidden)]
    pub tenant_domain: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of an Secrets Managersecret that contains the user name and password to connect to OneDrive. The user name should be the application ID for the OneDrive application, and the password is the application key for the OneDrive application.</p>
    #[doc(hidden)]
    pub secret_arn: std::option::Option<std::string::String>,
    /// <p>A list of user accounts whose documents should be indexed.</p>
    #[doc(hidden)]
    pub one_drive_users: std::option::Option<crate::model::OneDriveUsers>,
    /// <p>A list of regular expression patterns to include certain documents in your OneDrive. Documents that match the patterns are included in the index. Documents that don't match the patterns are excluded from the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.</p>
    /// <p>The pattern is applied to the file name.</p>
    #[doc(hidden)]
    pub inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of regular expression patterns to exclude certain documents in your OneDrive. Documents that match the patterns are excluded from the index. Documents that don't match the patterns are included in the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.</p>
    /// <p>The pattern is applied to the file name.</p>
    #[doc(hidden)]
    pub exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map OneDrive data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to OneDrive fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The OneDrive data source field names must exist in your OneDrive custom metadata.</p>
    #[doc(hidden)]
    pub field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p> <code>TRUE</code> to disable local groups information.</p>
    #[doc(hidden)]
    pub disable_local_groups: bool,
}
impl OneDriveConfiguration {
    /// <p>The Azure Active Directory domain of the organization. </p>
    pub fn tenant_domain(&self) -> std::option::Option<&str> {
        self.tenant_domain.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of an Secrets Managersecret that contains the user name and password to connect to OneDrive. The user name should be the application ID for the OneDrive application, and the password is the application key for the OneDrive application.</p>
    pub fn secret_arn(&self) -> std::option::Option<&str> {
        self.secret_arn.as_deref()
    }
    /// <p>A list of user accounts whose documents should be indexed.</p>
    pub fn one_drive_users(&self) -> std::option::Option<&crate::model::OneDriveUsers> {
        self.one_drive_users.as_ref()
    }
    /// <p>A list of regular expression patterns to include certain documents in your OneDrive. Documents that match the patterns are included in the index. Documents that don't match the patterns are excluded from the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.</p>
    /// <p>The pattern is applied to the file name.</p>
    pub fn inclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.inclusion_patterns.as_deref()
    }
    /// <p>A list of regular expression patterns to exclude certain documents in your OneDrive. Documents that match the patterns are excluded from the index. Documents that don't match the patterns are included in the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.</p>
    /// <p>The pattern is applied to the file name.</p>
    pub fn exclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.exclusion_patterns.as_deref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map OneDrive data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to OneDrive fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The OneDrive data source field names must exist in your OneDrive custom metadata.</p>
    pub fn field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.field_mappings.as_deref()
    }
    /// <p> <code>TRUE</code> to disable local groups information.</p>
    pub fn disable_local_groups(&self) -> bool {
        self.disable_local_groups
    }
}
/// See [`OneDriveConfiguration`](crate::model::OneDriveConfiguration).
pub mod one_drive_configuration {

    /// A builder for [`OneDriveConfiguration`](crate::model::OneDriveConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tenant_domain: std::option::Option<std::string::String>,
        pub(crate) secret_arn: std::option::Option<std::string::String>,
        pub(crate) one_drive_users: std::option::Option<crate::model::OneDriveUsers>,
        pub(crate) inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) disable_local_groups: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The Azure Active Directory domain of the organization. </p>
        pub fn tenant_domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.tenant_domain = Some(input.into());
            self
        }
        /// <p>The Azure Active Directory domain of the organization. </p>
        pub fn set_tenant_domain(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tenant_domain = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an Secrets Managersecret that contains the user name and password to connect to OneDrive. The user name should be the application ID for the OneDrive application, and the password is the application key for the OneDrive application.</p>
        pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an Secrets Managersecret that contains the user name and password to connect to OneDrive. The user name should be the application ID for the OneDrive application, and the password is the application key for the OneDrive application.</p>
        pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_arn = input;
            self
        }
        /// <p>A list of user accounts whose documents should be indexed.</p>
        pub fn one_drive_users(mut self, input: crate::model::OneDriveUsers) -> Self {
            self.one_drive_users = Some(input);
            self
        }
        /// <p>A list of user accounts whose documents should be indexed.</p>
        pub fn set_one_drive_users(
            mut self,
            input: std::option::Option<crate::model::OneDriveUsers>,
        ) -> Self {
            self.one_drive_users = input;
            self
        }
        /// Appends an item to `inclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_inclusion_patterns`](Self::set_inclusion_patterns).
        ///
        /// <p>A list of regular expression patterns to include certain documents in your OneDrive. Documents that match the patterns are included in the index. Documents that don't match the patterns are excluded from the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.</p>
        /// <p>The pattern is applied to the file name.</p>
        pub fn inclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.inclusion_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to include certain documents in your OneDrive. Documents that match the patterns are included in the index. Documents that don't match the patterns are excluded from the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.</p>
        /// <p>The pattern is applied to the file name.</p>
        pub fn set_inclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inclusion_patterns = input;
            self
        }
        /// Appends an item to `exclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_exclusion_patterns`](Self::set_exclusion_patterns).
        ///
        /// <p>A list of regular expression patterns to exclude certain documents in your OneDrive. Documents that match the patterns are excluded from the index. Documents that don't match the patterns are included in the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.</p>
        /// <p>The pattern is applied to the file name.</p>
        pub fn exclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.exclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.exclusion_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to exclude certain documents in your OneDrive. Documents that match the patterns are excluded from the index. Documents that don't match the patterns are included in the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.</p>
        /// <p>The pattern is applied to the file name.</p>
        pub fn set_exclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclusion_patterns = input;
            self
        }
        /// Appends an item to `field_mappings`.
        ///
        /// To override the contents of this collection use [`set_field_mappings`](Self::set_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map OneDrive data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to OneDrive fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The OneDrive data source field names must exist in your OneDrive custom metadata.</p>
        pub fn field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.field_mappings.unwrap_or_default();
            v.push(input);
            self.field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map OneDrive data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to OneDrive fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The OneDrive data source field names must exist in your OneDrive custom metadata.</p>
        pub fn set_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.field_mappings = input;
            self
        }
        /// <p> <code>TRUE</code> to disable local groups information.</p>
        pub fn disable_local_groups(mut self, input: bool) -> Self {
            self.disable_local_groups = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to disable local groups information.</p>
        pub fn set_disable_local_groups(mut self, input: std::option::Option<bool>) -> Self {
            self.disable_local_groups = input;
            self
        }
        /// Consumes the builder and constructs a [`OneDriveConfiguration`](crate::model::OneDriveConfiguration).
        pub fn build(self) -> crate::model::OneDriveConfiguration {
            crate::model::OneDriveConfiguration {
                tenant_domain: self.tenant_domain,
                secret_arn: self.secret_arn,
                one_drive_users: self.one_drive_users,
                inclusion_patterns: self.inclusion_patterns,
                exclusion_patterns: self.exclusion_patterns,
                field_mappings: self.field_mappings,
                disable_local_groups: self.disable_local_groups.unwrap_or_default(),
            }
        }
    }
}
impl OneDriveConfiguration {
    /// Creates a new builder-style object to manufacture [`OneDriveConfiguration`](crate::model::OneDriveConfiguration).
    pub fn builder() -> crate::model::one_drive_configuration::Builder {
        crate::model::one_drive_configuration::Builder::default()
    }
}

/// <p>User accounts whose documents should be indexed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OneDriveUsers {
    /// <p>A list of users whose documents should be indexed. Specify the user names in email format, for example, <code>username@tenantdomain</code>. If you need to index the documents of more than 100 users, use the <code>OneDriveUserS3Path</code> field to specify the location of a file containing a list of users.</p>
    #[doc(hidden)]
    pub one_drive_user_list: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The S3 bucket location of a file containing a list of users whose documents should be indexed.</p>
    #[doc(hidden)]
    pub one_drive_user_s3_path: std::option::Option<crate::model::S3Path>,
}
impl OneDriveUsers {
    /// <p>A list of users whose documents should be indexed. Specify the user names in email format, for example, <code>username@tenantdomain</code>. If you need to index the documents of more than 100 users, use the <code>OneDriveUserS3Path</code> field to specify the location of a file containing a list of users.</p>
    pub fn one_drive_user_list(&self) -> std::option::Option<&[std::string::String]> {
        self.one_drive_user_list.as_deref()
    }
    /// <p>The S3 bucket location of a file containing a list of users whose documents should be indexed.</p>
    pub fn one_drive_user_s3_path(&self) -> std::option::Option<&crate::model::S3Path> {
        self.one_drive_user_s3_path.as_ref()
    }
}
/// See [`OneDriveUsers`](crate::model::OneDriveUsers).
pub mod one_drive_users {

    /// A builder for [`OneDriveUsers`](crate::model::OneDriveUsers).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) one_drive_user_list: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) one_drive_user_s3_path: std::option::Option<crate::model::S3Path>,
    }
    impl Builder {
        /// Appends an item to `one_drive_user_list`.
        ///
        /// To override the contents of this collection use [`set_one_drive_user_list`](Self::set_one_drive_user_list).
        ///
        /// <p>A list of users whose documents should be indexed. Specify the user names in email format, for example, <code>username@tenantdomain</code>. If you need to index the documents of more than 100 users, use the <code>OneDriveUserS3Path</code> field to specify the location of a file containing a list of users.</p>
        pub fn one_drive_user_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.one_drive_user_list.unwrap_or_default();
            v.push(input.into());
            self.one_drive_user_list = Some(v);
            self
        }
        /// <p>A list of users whose documents should be indexed. Specify the user names in email format, for example, <code>username@tenantdomain</code>. If you need to index the documents of more than 100 users, use the <code>OneDriveUserS3Path</code> field to specify the location of a file containing a list of users.</p>
        pub fn set_one_drive_user_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.one_drive_user_list = input;
            self
        }
        /// <p>The S3 bucket location of a file containing a list of users whose documents should be indexed.</p>
        pub fn one_drive_user_s3_path(mut self, input: crate::model::S3Path) -> Self {
            self.one_drive_user_s3_path = Some(input);
            self
        }
        /// <p>The S3 bucket location of a file containing a list of users whose documents should be indexed.</p>
        pub fn set_one_drive_user_s3_path(
            mut self,
            input: std::option::Option<crate::model::S3Path>,
        ) -> Self {
            self.one_drive_user_s3_path = input;
            self
        }
        /// Consumes the builder and constructs a [`OneDriveUsers`](crate::model::OneDriveUsers).
        pub fn build(self) -> crate::model::OneDriveUsers {
            crate::model::OneDriveUsers {
                one_drive_user_list: self.one_drive_user_list,
                one_drive_user_s3_path: self.one_drive_user_s3_path,
            }
        }
    }
}
impl OneDriveUsers {
    /// Creates a new builder-style object to manufacture [`OneDriveUsers`](crate::model::OneDriveUsers).
    pub fn builder() -> crate::model::one_drive_users::Builder {
        crate::model::one_drive_users::Builder::default()
    }
}

/// <p>Provides the configuration information to connect to Salesforce as your data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SalesforceConfiguration {
    /// <p>The instance URL for the Salesforce site that you want to index.</p>
    #[doc(hidden)]
    pub server_url: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of an Secrets Managersecret that contains the key/value pairs required to connect to your Salesforce instance. The secret must contain a JSON structure with the following keys:</p>
    /// <ul>
    /// <li> <p>authenticationUrl - The OAUTH endpoint that Amazon Kendra connects to get an OAUTH token. </p> </li>
    /// <li> <p>consumerKey - The application public key generated when you created your Salesforce application.</p> </li>
    /// <li> <p>consumerSecret - The application private key generated when you created your Salesforce application.</p> </li>
    /// <li> <p>password - The password associated with the user logging in to the Salesforce instance.</p> </li>
    /// <li> <p>securityToken - The token associated with the user account logging in to the Salesforce instance.</p> </li>
    /// <li> <p>username - The user name of the user logging in to the Salesforce instance.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub secret_arn: std::option::Option<std::string::String>,
    /// <p>Configuration of the Salesforce standard objects that Amazon Kendra indexes.</p>
    #[doc(hidden)]
    pub standard_object_configurations:
        std::option::Option<std::vec::Vec<crate::model::SalesforceStandardObjectConfiguration>>,
    /// <p>Configuration information for the knowledge article types that Amazon Kendra indexes. Amazon Kendra indexes standard knowledge articles and the standard fields of knowledge articles, or the custom fields of custom knowledge articles, but not both.</p>
    #[doc(hidden)]
    pub knowledge_article_configuration:
        std::option::Option<crate::model::SalesforceKnowledgeArticleConfiguration>,
    /// <p>Configuration information for Salesforce chatter feeds.</p>
    #[doc(hidden)]
    pub chatter_feed_configuration:
        std::option::Option<crate::model::SalesforceChatterFeedConfiguration>,
    /// <p>Indicates whether Amazon Kendra should index attachments to Salesforce objects.</p>
    #[doc(hidden)]
    pub crawl_attachments: bool,
    /// <p>Configuration information for processing attachments to Salesforce standard objects. </p>
    #[doc(hidden)]
    pub standard_object_attachment_configuration:
        std::option::Option<crate::model::SalesforceStandardObjectAttachmentConfiguration>,
    /// <p>A list of regular expression patterns to include certain documents in your Salesforce. Documents that match the patterns are included in the index. Documents that don't match the patterns are excluded from the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.</p>
    /// <p>The pattern is applied to the name of the attached file.</p>
    #[doc(hidden)]
    pub include_attachment_file_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of regular expression patterns to exclude certain documents in your Salesforce. Documents that match the patterns are excluded from the index. Documents that don't match the patterns are included in the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.</p>
    /// <p>The pattern is applied to the name of the attached file.</p>
    #[doc(hidden)]
    pub exclude_attachment_file_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl SalesforceConfiguration {
    /// <p>The instance URL for the Salesforce site that you want to index.</p>
    pub fn server_url(&self) -> std::option::Option<&str> {
        self.server_url.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of an Secrets Managersecret that contains the key/value pairs required to connect to your Salesforce instance. The secret must contain a JSON structure with the following keys:</p>
    /// <ul>
    /// <li> <p>authenticationUrl - The OAUTH endpoint that Amazon Kendra connects to get an OAUTH token. </p> </li>
    /// <li> <p>consumerKey - The application public key generated when you created your Salesforce application.</p> </li>
    /// <li> <p>consumerSecret - The application private key generated when you created your Salesforce application.</p> </li>
    /// <li> <p>password - The password associated with the user logging in to the Salesforce instance.</p> </li>
    /// <li> <p>securityToken - The token associated with the user account logging in to the Salesforce instance.</p> </li>
    /// <li> <p>username - The user name of the user logging in to the Salesforce instance.</p> </li>
    /// </ul>
    pub fn secret_arn(&self) -> std::option::Option<&str> {
        self.secret_arn.as_deref()
    }
    /// <p>Configuration of the Salesforce standard objects that Amazon Kendra indexes.</p>
    pub fn standard_object_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::SalesforceStandardObjectConfiguration]> {
        self.standard_object_configurations.as_deref()
    }
    /// <p>Configuration information for the knowledge article types that Amazon Kendra indexes. Amazon Kendra indexes standard knowledge articles and the standard fields of knowledge articles, or the custom fields of custom knowledge articles, but not both.</p>
    pub fn knowledge_article_configuration(
        &self,
    ) -> std::option::Option<&crate::model::SalesforceKnowledgeArticleConfiguration> {
        self.knowledge_article_configuration.as_ref()
    }
    /// <p>Configuration information for Salesforce chatter feeds.</p>
    pub fn chatter_feed_configuration(
        &self,
    ) -> std::option::Option<&crate::model::SalesforceChatterFeedConfiguration> {
        self.chatter_feed_configuration.as_ref()
    }
    /// <p>Indicates whether Amazon Kendra should index attachments to Salesforce objects.</p>
    pub fn crawl_attachments(&self) -> bool {
        self.crawl_attachments
    }
    /// <p>Configuration information for processing attachments to Salesforce standard objects. </p>
    pub fn standard_object_attachment_configuration(
        &self,
    ) -> std::option::Option<&crate::model::SalesforceStandardObjectAttachmentConfiguration> {
        self.standard_object_attachment_configuration.as_ref()
    }
    /// <p>A list of regular expression patterns to include certain documents in your Salesforce. Documents that match the patterns are included in the index. Documents that don't match the patterns are excluded from the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.</p>
    /// <p>The pattern is applied to the name of the attached file.</p>
    pub fn include_attachment_file_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.include_attachment_file_patterns.as_deref()
    }
    /// <p>A list of regular expression patterns to exclude certain documents in your Salesforce. Documents that match the patterns are excluded from the index. Documents that don't match the patterns are included in the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.</p>
    /// <p>The pattern is applied to the name of the attached file.</p>
    pub fn exclude_attachment_file_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.exclude_attachment_file_patterns.as_deref()
    }
}
/// See [`SalesforceConfiguration`](crate::model::SalesforceConfiguration).
pub mod salesforce_configuration {

    /// A builder for [`SalesforceConfiguration`](crate::model::SalesforceConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) server_url: std::option::Option<std::string::String>,
        pub(crate) secret_arn: std::option::Option<std::string::String>,
        pub(crate) standard_object_configurations:
            std::option::Option<std::vec::Vec<crate::model::SalesforceStandardObjectConfiguration>>,
        pub(crate) knowledge_article_configuration:
            std::option::Option<crate::model::SalesforceKnowledgeArticleConfiguration>,
        pub(crate) chatter_feed_configuration:
            std::option::Option<crate::model::SalesforceChatterFeedConfiguration>,
        pub(crate) crawl_attachments: std::option::Option<bool>,
        pub(crate) standard_object_attachment_configuration:
            std::option::Option<crate::model::SalesforceStandardObjectAttachmentConfiguration>,
        pub(crate) include_attachment_file_patterns:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) exclude_attachment_file_patterns:
            std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The instance URL for the Salesforce site that you want to index.</p>
        pub fn server_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.server_url = Some(input.into());
            self
        }
        /// <p>The instance URL for the Salesforce site that you want to index.</p>
        pub fn set_server_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.server_url = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an Secrets Managersecret that contains the key/value pairs required to connect to your Salesforce instance. The secret must contain a JSON structure with the following keys:</p>
        /// <ul>
        /// <li> <p>authenticationUrl - The OAUTH endpoint that Amazon Kendra connects to get an OAUTH token. </p> </li>
        /// <li> <p>consumerKey - The application public key generated when you created your Salesforce application.</p> </li>
        /// <li> <p>consumerSecret - The application private key generated when you created your Salesforce application.</p> </li>
        /// <li> <p>password - The password associated with the user logging in to the Salesforce instance.</p> </li>
        /// <li> <p>securityToken - The token associated with the user account logging in to the Salesforce instance.</p> </li>
        /// <li> <p>username - The user name of the user logging in to the Salesforce instance.</p> </li>
        /// </ul>
        pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an Secrets Managersecret that contains the key/value pairs required to connect to your Salesforce instance. The secret must contain a JSON structure with the following keys:</p>
        /// <ul>
        /// <li> <p>authenticationUrl - The OAUTH endpoint that Amazon Kendra connects to get an OAUTH token. </p> </li>
        /// <li> <p>consumerKey - The application public key generated when you created your Salesforce application.</p> </li>
        /// <li> <p>consumerSecret - The application private key generated when you created your Salesforce application.</p> </li>
        /// <li> <p>password - The password associated with the user logging in to the Salesforce instance.</p> </li>
        /// <li> <p>securityToken - The token associated with the user account logging in to the Salesforce instance.</p> </li>
        /// <li> <p>username - The user name of the user logging in to the Salesforce instance.</p> </li>
        /// </ul>
        pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_arn = input;
            self
        }
        /// Appends an item to `standard_object_configurations`.
        ///
        /// To override the contents of this collection use [`set_standard_object_configurations`](Self::set_standard_object_configurations).
        ///
        /// <p>Configuration of the Salesforce standard objects that Amazon Kendra indexes.</p>
        pub fn standard_object_configurations(
            mut self,
            input: crate::model::SalesforceStandardObjectConfiguration,
        ) -> Self {
            let mut v = self.standard_object_configurations.unwrap_or_default();
            v.push(input);
            self.standard_object_configurations = Some(v);
            self
        }
        /// <p>Configuration of the Salesforce standard objects that Amazon Kendra indexes.</p>
        pub fn set_standard_object_configurations(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::SalesforceStandardObjectConfiguration>,
            >,
        ) -> Self {
            self.standard_object_configurations = input;
            self
        }
        /// <p>Configuration information for the knowledge article types that Amazon Kendra indexes. Amazon Kendra indexes standard knowledge articles and the standard fields of knowledge articles, or the custom fields of custom knowledge articles, but not both.</p>
        pub fn knowledge_article_configuration(
            mut self,
            input: crate::model::SalesforceKnowledgeArticleConfiguration,
        ) -> Self {
            self.knowledge_article_configuration = Some(input);
            self
        }
        /// <p>Configuration information for the knowledge article types that Amazon Kendra indexes. Amazon Kendra indexes standard knowledge articles and the standard fields of knowledge articles, or the custom fields of custom knowledge articles, but not both.</p>
        pub fn set_knowledge_article_configuration(
            mut self,
            input: std::option::Option<crate::model::SalesforceKnowledgeArticleConfiguration>,
        ) -> Self {
            self.knowledge_article_configuration = input;
            self
        }
        /// <p>Configuration information for Salesforce chatter feeds.</p>
        pub fn chatter_feed_configuration(
            mut self,
            input: crate::model::SalesforceChatterFeedConfiguration,
        ) -> Self {
            self.chatter_feed_configuration = Some(input);
            self
        }
        /// <p>Configuration information for Salesforce chatter feeds.</p>
        pub fn set_chatter_feed_configuration(
            mut self,
            input: std::option::Option<crate::model::SalesforceChatterFeedConfiguration>,
        ) -> Self {
            self.chatter_feed_configuration = input;
            self
        }
        /// <p>Indicates whether Amazon Kendra should index attachments to Salesforce objects.</p>
        pub fn crawl_attachments(mut self, input: bool) -> Self {
            self.crawl_attachments = Some(input);
            self
        }
        /// <p>Indicates whether Amazon Kendra should index attachments to Salesforce objects.</p>
        pub fn set_crawl_attachments(mut self, input: std::option::Option<bool>) -> Self {
            self.crawl_attachments = input;
            self
        }
        /// <p>Configuration information for processing attachments to Salesforce standard objects. </p>
        pub fn standard_object_attachment_configuration(
            mut self,
            input: crate::model::SalesforceStandardObjectAttachmentConfiguration,
        ) -> Self {
            self.standard_object_attachment_configuration = Some(input);
            self
        }
        /// <p>Configuration information for processing attachments to Salesforce standard objects. </p>
        pub fn set_standard_object_attachment_configuration(
            mut self,
            input: std::option::Option<
                crate::model::SalesforceStandardObjectAttachmentConfiguration,
            >,
        ) -> Self {
            self.standard_object_attachment_configuration = input;
            self
        }
        /// Appends an item to `include_attachment_file_patterns`.
        ///
        /// To override the contents of this collection use [`set_include_attachment_file_patterns`](Self::set_include_attachment_file_patterns).
        ///
        /// <p>A list of regular expression patterns to include certain documents in your Salesforce. Documents that match the patterns are included in the index. Documents that don't match the patterns are excluded from the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.</p>
        /// <p>The pattern is applied to the name of the attached file.</p>
        pub fn include_attachment_file_patterns(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.include_attachment_file_patterns.unwrap_or_default();
            v.push(input.into());
            self.include_attachment_file_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to include certain documents in your Salesforce. Documents that match the patterns are included in the index. Documents that don't match the patterns are excluded from the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.</p>
        /// <p>The pattern is applied to the name of the attached file.</p>
        pub fn set_include_attachment_file_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.include_attachment_file_patterns = input;
            self
        }
        /// Appends an item to `exclude_attachment_file_patterns`.
        ///
        /// To override the contents of this collection use [`set_exclude_attachment_file_patterns`](Self::set_exclude_attachment_file_patterns).
        ///
        /// <p>A list of regular expression patterns to exclude certain documents in your Salesforce. Documents that match the patterns are excluded from the index. Documents that don't match the patterns are included in the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.</p>
        /// <p>The pattern is applied to the name of the attached file.</p>
        pub fn exclude_attachment_file_patterns(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.exclude_attachment_file_patterns.unwrap_or_default();
            v.push(input.into());
            self.exclude_attachment_file_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to exclude certain documents in your Salesforce. Documents that match the patterns are excluded from the index. Documents that don't match the patterns are included in the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.</p>
        /// <p>The pattern is applied to the name of the attached file.</p>
        pub fn set_exclude_attachment_file_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclude_attachment_file_patterns = input;
            self
        }
        /// Consumes the builder and constructs a [`SalesforceConfiguration`](crate::model::SalesforceConfiguration).
        pub fn build(self) -> crate::model::SalesforceConfiguration {
            crate::model::SalesforceConfiguration {
                server_url: self.server_url,
                secret_arn: self.secret_arn,
                standard_object_configurations: self.standard_object_configurations,
                knowledge_article_configuration: self.knowledge_article_configuration,
                chatter_feed_configuration: self.chatter_feed_configuration,
                crawl_attachments: self.crawl_attachments.unwrap_or_default(),
                standard_object_attachment_configuration: self
                    .standard_object_attachment_configuration,
                include_attachment_file_patterns: self.include_attachment_file_patterns,
                exclude_attachment_file_patterns: self.exclude_attachment_file_patterns,
            }
        }
    }
}
impl SalesforceConfiguration {
    /// Creates a new builder-style object to manufacture [`SalesforceConfiguration`](crate::model::SalesforceConfiguration).
    pub fn builder() -> crate::model::salesforce_configuration::Builder {
        crate::model::salesforce_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information for processing attachments to Salesforce standard objects.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SalesforceStandardObjectAttachmentConfiguration {
    /// <p>The name of the field used for the document title.</p>
    #[doc(hidden)]
    pub document_title_field_name: std::option::Option<std::string::String>,
    /// <p>One or more objects that map fields in attachments to Amazon Kendra index fields.</p>
    #[doc(hidden)]
    pub field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
}
impl SalesforceStandardObjectAttachmentConfiguration {
    /// <p>The name of the field used for the document title.</p>
    pub fn document_title_field_name(&self) -> std::option::Option<&str> {
        self.document_title_field_name.as_deref()
    }
    /// <p>One or more objects that map fields in attachments to Amazon Kendra index fields.</p>
    pub fn field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.field_mappings.as_deref()
    }
}
/// See [`SalesforceStandardObjectAttachmentConfiguration`](crate::model::SalesforceStandardObjectAttachmentConfiguration).
pub mod salesforce_standard_object_attachment_configuration {

    /// A builder for [`SalesforceStandardObjectAttachmentConfiguration`](crate::model::SalesforceStandardObjectAttachmentConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_title_field_name: std::option::Option<std::string::String>,
        pub(crate) field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    }
    impl Builder {
        /// <p>The name of the field used for the document title.</p>
        pub fn document_title_field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_title_field_name = Some(input.into());
            self
        }
        /// <p>The name of the field used for the document title.</p>
        pub fn set_document_title_field_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_title_field_name = input;
            self
        }
        /// Appends an item to `field_mappings`.
        ///
        /// To override the contents of this collection use [`set_field_mappings`](Self::set_field_mappings).
        ///
        /// <p>One or more objects that map fields in attachments to Amazon Kendra index fields.</p>
        pub fn field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.field_mappings.unwrap_or_default();
            v.push(input);
            self.field_mappings = Some(v);
            self
        }
        /// <p>One or more objects that map fields in attachments to Amazon Kendra index fields.</p>
        pub fn set_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.field_mappings = input;
            self
        }
        /// Consumes the builder and constructs a [`SalesforceStandardObjectAttachmentConfiguration`](crate::model::SalesforceStandardObjectAttachmentConfiguration).
        pub fn build(self) -> crate::model::SalesforceStandardObjectAttachmentConfiguration {
            crate::model::SalesforceStandardObjectAttachmentConfiguration {
                document_title_field_name: self.document_title_field_name,
                field_mappings: self.field_mappings,
            }
        }
    }
}
impl SalesforceStandardObjectAttachmentConfiguration {
    /// Creates a new builder-style object to manufacture [`SalesforceStandardObjectAttachmentConfiguration`](crate::model::SalesforceStandardObjectAttachmentConfiguration).
    pub fn builder() -> crate::model::salesforce_standard_object_attachment_configuration::Builder {
        crate::model::salesforce_standard_object_attachment_configuration::Builder::default()
    }
}

/// <p>The configuration information for syncing a Salesforce chatter feed. The contents of the object comes from the Salesforce FeedItem table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SalesforceChatterFeedConfiguration {
    /// <p>The name of the column in the Salesforce FeedItem table that contains the content to index. Typically this is the <code>Body</code> column.</p>
    #[doc(hidden)]
    pub document_data_field_name: std::option::Option<std::string::String>,
    /// <p>The name of the column in the Salesforce FeedItem table that contains the title of the document. This is typically the <code>Title</code> column.</p>
    #[doc(hidden)]
    pub document_title_field_name: std::option::Option<std::string::String>,
    /// <p>Maps fields from a Salesforce chatter feed into Amazon Kendra index fields.</p>
    #[doc(hidden)]
    pub field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>Filters the documents in the feed based on status of the user. When you specify <code>ACTIVE_USERS</code> only documents from users who have an active account are indexed. When you specify <code>STANDARD_USER</code> only documents for Salesforce standard users are documented. You can specify both.</p>
    #[doc(hidden)]
    pub include_filter_types:
        std::option::Option<std::vec::Vec<crate::model::SalesforceChatterFeedIncludeFilterType>>,
}
impl SalesforceChatterFeedConfiguration {
    /// <p>The name of the column in the Salesforce FeedItem table that contains the content to index. Typically this is the <code>Body</code> column.</p>
    pub fn document_data_field_name(&self) -> std::option::Option<&str> {
        self.document_data_field_name.as_deref()
    }
    /// <p>The name of the column in the Salesforce FeedItem table that contains the title of the document. This is typically the <code>Title</code> column.</p>
    pub fn document_title_field_name(&self) -> std::option::Option<&str> {
        self.document_title_field_name.as_deref()
    }
    /// <p>Maps fields from a Salesforce chatter feed into Amazon Kendra index fields.</p>
    pub fn field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.field_mappings.as_deref()
    }
    /// <p>Filters the documents in the feed based on status of the user. When you specify <code>ACTIVE_USERS</code> only documents from users who have an active account are indexed. When you specify <code>STANDARD_USER</code> only documents for Salesforce standard users are documented. You can specify both.</p>
    pub fn include_filter_types(
        &self,
    ) -> std::option::Option<&[crate::model::SalesforceChatterFeedIncludeFilterType]> {
        self.include_filter_types.as_deref()
    }
}
/// See [`SalesforceChatterFeedConfiguration`](crate::model::SalesforceChatterFeedConfiguration).
pub mod salesforce_chatter_feed_configuration {

    /// A builder for [`SalesforceChatterFeedConfiguration`](crate::model::SalesforceChatterFeedConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_data_field_name: std::option::Option<std::string::String>,
        pub(crate) document_title_field_name: std::option::Option<std::string::String>,
        pub(crate) field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) include_filter_types: std::option::Option<
            std::vec::Vec<crate::model::SalesforceChatterFeedIncludeFilterType>,
        >,
    }
    impl Builder {
        /// <p>The name of the column in the Salesforce FeedItem table that contains the content to index. Typically this is the <code>Body</code> column.</p>
        pub fn document_data_field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_data_field_name = Some(input.into());
            self
        }
        /// <p>The name of the column in the Salesforce FeedItem table that contains the content to index. Typically this is the <code>Body</code> column.</p>
        pub fn set_document_data_field_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_data_field_name = input;
            self
        }
        /// <p>The name of the column in the Salesforce FeedItem table that contains the title of the document. This is typically the <code>Title</code> column.</p>
        pub fn document_title_field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_title_field_name = Some(input.into());
            self
        }
        /// <p>The name of the column in the Salesforce FeedItem table that contains the title of the document. This is typically the <code>Title</code> column.</p>
        pub fn set_document_title_field_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_title_field_name = input;
            self
        }
        /// Appends an item to `field_mappings`.
        ///
        /// To override the contents of this collection use [`set_field_mappings`](Self::set_field_mappings).
        ///
        /// <p>Maps fields from a Salesforce chatter feed into Amazon Kendra index fields.</p>
        pub fn field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.field_mappings.unwrap_or_default();
            v.push(input);
            self.field_mappings = Some(v);
            self
        }
        /// <p>Maps fields from a Salesforce chatter feed into Amazon Kendra index fields.</p>
        pub fn set_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.field_mappings = input;
            self
        }
        /// Appends an item to `include_filter_types`.
        ///
        /// To override the contents of this collection use [`set_include_filter_types`](Self::set_include_filter_types).
        ///
        /// <p>Filters the documents in the feed based on status of the user. When you specify <code>ACTIVE_USERS</code> only documents from users who have an active account are indexed. When you specify <code>STANDARD_USER</code> only documents for Salesforce standard users are documented. You can specify both.</p>
        pub fn include_filter_types(
            mut self,
            input: crate::model::SalesforceChatterFeedIncludeFilterType,
        ) -> Self {
            let mut v = self.include_filter_types.unwrap_or_default();
            v.push(input);
            self.include_filter_types = Some(v);
            self
        }
        /// <p>Filters the documents in the feed based on status of the user. When you specify <code>ACTIVE_USERS</code> only documents from users who have an active account are indexed. When you specify <code>STANDARD_USER</code> only documents for Salesforce standard users are documented. You can specify both.</p>
        pub fn set_include_filter_types(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::SalesforceChatterFeedIncludeFilterType>,
            >,
        ) -> Self {
            self.include_filter_types = input;
            self
        }
        /// Consumes the builder and constructs a [`SalesforceChatterFeedConfiguration`](crate::model::SalesforceChatterFeedConfiguration).
        pub fn build(self) -> crate::model::SalesforceChatterFeedConfiguration {
            crate::model::SalesforceChatterFeedConfiguration {
                document_data_field_name: self.document_data_field_name,
                document_title_field_name: self.document_title_field_name,
                field_mappings: self.field_mappings,
                include_filter_types: self.include_filter_types,
            }
        }
    }
}
impl SalesforceChatterFeedConfiguration {
    /// Creates a new builder-style object to manufacture [`SalesforceChatterFeedConfiguration`](crate::model::SalesforceChatterFeedConfiguration).
    pub fn builder() -> crate::model::salesforce_chatter_feed_configuration::Builder {
        crate::model::salesforce_chatter_feed_configuration::Builder::default()
    }
}

/// When writing a match expression against `SalesforceChatterFeedIncludeFilterType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let salesforcechatterfeedincludefiltertype = unimplemented!();
/// match salesforcechatterfeedincludefiltertype {
///     SalesforceChatterFeedIncludeFilterType::ActiveUser => { /* ... */ },
///     SalesforceChatterFeedIncludeFilterType::StandardUser => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `salesforcechatterfeedincludefiltertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SalesforceChatterFeedIncludeFilterType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SalesforceChatterFeedIncludeFilterType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SalesforceChatterFeedIncludeFilterType::NewFeature` is defined.
/// Specifically, when `salesforcechatterfeedincludefiltertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SalesforceChatterFeedIncludeFilterType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SalesforceChatterFeedIncludeFilterType {
    #[allow(missing_docs)] // documentation missing in model
    ActiveUser,
    #[allow(missing_docs)] // documentation missing in model
    StandardUser,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SalesforceChatterFeedIncludeFilterType {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE_USER" => SalesforceChatterFeedIncludeFilterType::ActiveUser,
            "STANDARD_USER" => SalesforceChatterFeedIncludeFilterType::StandardUser,
            other => SalesforceChatterFeedIncludeFilterType::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for SalesforceChatterFeedIncludeFilterType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SalesforceChatterFeedIncludeFilterType::from(s))
    }
}
impl SalesforceChatterFeedIncludeFilterType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SalesforceChatterFeedIncludeFilterType::ActiveUser => "ACTIVE_USER",
            SalesforceChatterFeedIncludeFilterType::StandardUser => "STANDARD_USER",
            SalesforceChatterFeedIncludeFilterType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE_USER", "STANDARD_USER"]
    }
}
impl AsRef<str> for SalesforceChatterFeedIncludeFilterType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides the configuration information for the knowledge article types that Amazon Kendra indexes. Amazon Kendra indexes standard knowledge articles and the standard fields of knowledge articles, or the custom fields of custom knowledge articles, but not both </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SalesforceKnowledgeArticleConfiguration {
    /// <p>Specifies the document states that should be included when Amazon Kendra indexes knowledge articles. You must specify at least one state.</p>
    #[doc(hidden)]
    pub included_states:
        std::option::Option<std::vec::Vec<crate::model::SalesforceKnowledgeArticleState>>,
    /// <p>Configuration information for standard Salesforce knowledge articles.</p>
    #[doc(hidden)]
    pub standard_knowledge_article_type_configuration:
        std::option::Option<crate::model::SalesforceStandardKnowledgeArticleTypeConfiguration>,
    /// <p>Configuration information for custom Salesforce knowledge articles.</p>
    #[doc(hidden)]
    pub custom_knowledge_article_type_configurations: std::option::Option<
        std::vec::Vec<crate::model::SalesforceCustomKnowledgeArticleTypeConfiguration>,
    >,
}
impl SalesforceKnowledgeArticleConfiguration {
    /// <p>Specifies the document states that should be included when Amazon Kendra indexes knowledge articles. You must specify at least one state.</p>
    pub fn included_states(
        &self,
    ) -> std::option::Option<&[crate::model::SalesforceKnowledgeArticleState]> {
        self.included_states.as_deref()
    }
    /// <p>Configuration information for standard Salesforce knowledge articles.</p>
    pub fn standard_knowledge_article_type_configuration(
        &self,
    ) -> std::option::Option<&crate::model::SalesforceStandardKnowledgeArticleTypeConfiguration>
    {
        self.standard_knowledge_article_type_configuration.as_ref()
    }
    /// <p>Configuration information for custom Salesforce knowledge articles.</p>
    pub fn custom_knowledge_article_type_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::SalesforceCustomKnowledgeArticleTypeConfiguration]>
    {
        self.custom_knowledge_article_type_configurations.as_deref()
    }
}
/// See [`SalesforceKnowledgeArticleConfiguration`](crate::model::SalesforceKnowledgeArticleConfiguration).
pub mod salesforce_knowledge_article_configuration {

    /// A builder for [`SalesforceKnowledgeArticleConfiguration`](crate::model::SalesforceKnowledgeArticleConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) included_states:
            std::option::Option<std::vec::Vec<crate::model::SalesforceKnowledgeArticleState>>,
        pub(crate) standard_knowledge_article_type_configuration:
            std::option::Option<crate::model::SalesforceStandardKnowledgeArticleTypeConfiguration>,
        pub(crate) custom_knowledge_article_type_configurations: std::option::Option<
            std::vec::Vec<crate::model::SalesforceCustomKnowledgeArticleTypeConfiguration>,
        >,
    }
    impl Builder {
        /// Appends an item to `included_states`.
        ///
        /// To override the contents of this collection use [`set_included_states`](Self::set_included_states).
        ///
        /// <p>Specifies the document states that should be included when Amazon Kendra indexes knowledge articles. You must specify at least one state.</p>
        pub fn included_states(
            mut self,
            input: crate::model::SalesforceKnowledgeArticleState,
        ) -> Self {
            let mut v = self.included_states.unwrap_or_default();
            v.push(input);
            self.included_states = Some(v);
            self
        }
        /// <p>Specifies the document states that should be included when Amazon Kendra indexes knowledge articles. You must specify at least one state.</p>
        pub fn set_included_states(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::SalesforceKnowledgeArticleState>,
            >,
        ) -> Self {
            self.included_states = input;
            self
        }
        /// <p>Configuration information for standard Salesforce knowledge articles.</p>
        pub fn standard_knowledge_article_type_configuration(
            mut self,
            input: crate::model::SalesforceStandardKnowledgeArticleTypeConfiguration,
        ) -> Self {
            self.standard_knowledge_article_type_configuration = Some(input);
            self
        }
        /// <p>Configuration information for standard Salesforce knowledge articles.</p>
        pub fn set_standard_knowledge_article_type_configuration(
            mut self,
            input: std::option::Option<
                crate::model::SalesforceStandardKnowledgeArticleTypeConfiguration,
            >,
        ) -> Self {
            self.standard_knowledge_article_type_configuration = input;
            self
        }
        /// Appends an item to `custom_knowledge_article_type_configurations`.
        ///
        /// To override the contents of this collection use [`set_custom_knowledge_article_type_configurations`](Self::set_custom_knowledge_article_type_configurations).
        ///
        /// <p>Configuration information for custom Salesforce knowledge articles.</p>
        pub fn custom_knowledge_article_type_configurations(
            mut self,
            input: crate::model::SalesforceCustomKnowledgeArticleTypeConfiguration,
        ) -> Self {
            let mut v = self
                .custom_knowledge_article_type_configurations
                .unwrap_or_default();
            v.push(input);
            self.custom_knowledge_article_type_configurations = Some(v);
            self
        }
        /// <p>Configuration information for custom Salesforce knowledge articles.</p>
        pub fn set_custom_knowledge_article_type_configurations(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::SalesforceCustomKnowledgeArticleTypeConfiguration>,
            >,
        ) -> Self {
            self.custom_knowledge_article_type_configurations = input;
            self
        }
        /// Consumes the builder and constructs a [`SalesforceKnowledgeArticleConfiguration`](crate::model::SalesforceKnowledgeArticleConfiguration).
        pub fn build(self) -> crate::model::SalesforceKnowledgeArticleConfiguration {
            crate::model::SalesforceKnowledgeArticleConfiguration {
                included_states: self.included_states,
                standard_knowledge_article_type_configuration: self
                    .standard_knowledge_article_type_configuration,
                custom_knowledge_article_type_configurations: self
                    .custom_knowledge_article_type_configurations,
            }
        }
    }
}
impl SalesforceKnowledgeArticleConfiguration {
    /// Creates a new builder-style object to manufacture [`SalesforceKnowledgeArticleConfiguration`](crate::model::SalesforceKnowledgeArticleConfiguration).
    pub fn builder() -> crate::model::salesforce_knowledge_article_configuration::Builder {
        crate::model::salesforce_knowledge_article_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information for indexing Salesforce custom articles.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SalesforceCustomKnowledgeArticleTypeConfiguration {
    /// <p>The name of the configuration.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the field in the custom knowledge article that contains the document data to index.</p>
    #[doc(hidden)]
    pub document_data_field_name: std::option::Option<std::string::String>,
    /// <p>The name of the field in the custom knowledge article that contains the document title.</p>
    #[doc(hidden)]
    pub document_title_field_name: std::option::Option<std::string::String>,
    /// <p>Maps attributes or field names of the custom knowledge article to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Salesforce fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Salesforce data source field names must exist in your Salesforce custom metadata.</p>
    #[doc(hidden)]
    pub field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
}
impl SalesforceCustomKnowledgeArticleTypeConfiguration {
    /// <p>The name of the configuration.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the field in the custom knowledge article that contains the document data to index.</p>
    pub fn document_data_field_name(&self) -> std::option::Option<&str> {
        self.document_data_field_name.as_deref()
    }
    /// <p>The name of the field in the custom knowledge article that contains the document title.</p>
    pub fn document_title_field_name(&self) -> std::option::Option<&str> {
        self.document_title_field_name.as_deref()
    }
    /// <p>Maps attributes or field names of the custom knowledge article to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Salesforce fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Salesforce data source field names must exist in your Salesforce custom metadata.</p>
    pub fn field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.field_mappings.as_deref()
    }
}
/// See [`SalesforceCustomKnowledgeArticleTypeConfiguration`](crate::model::SalesforceCustomKnowledgeArticleTypeConfiguration).
pub mod salesforce_custom_knowledge_article_type_configuration {

    /// A builder for [`SalesforceCustomKnowledgeArticleTypeConfiguration`](crate::model::SalesforceCustomKnowledgeArticleTypeConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) document_data_field_name: std::option::Option<std::string::String>,
        pub(crate) document_title_field_name: std::option::Option<std::string::String>,
        pub(crate) field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    }
    impl Builder {
        /// <p>The name of the configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the configuration.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the field in the custom knowledge article that contains the document data to index.</p>
        pub fn document_data_field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_data_field_name = Some(input.into());
            self
        }
        /// <p>The name of the field in the custom knowledge article that contains the document data to index.</p>
        pub fn set_document_data_field_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_data_field_name = input;
            self
        }
        /// <p>The name of the field in the custom knowledge article that contains the document title.</p>
        pub fn document_title_field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_title_field_name = Some(input.into());
            self
        }
        /// <p>The name of the field in the custom knowledge article that contains the document title.</p>
        pub fn set_document_title_field_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_title_field_name = input;
            self
        }
        /// Appends an item to `field_mappings`.
        ///
        /// To override the contents of this collection use [`set_field_mappings`](Self::set_field_mappings).
        ///
        /// <p>Maps attributes or field names of the custom knowledge article to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Salesforce fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Salesforce data source field names must exist in your Salesforce custom metadata.</p>
        pub fn field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.field_mappings.unwrap_or_default();
            v.push(input);
            self.field_mappings = Some(v);
            self
        }
        /// <p>Maps attributes or field names of the custom knowledge article to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Salesforce fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Salesforce data source field names must exist in your Salesforce custom metadata.</p>
        pub fn set_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.field_mappings = input;
            self
        }
        /// Consumes the builder and constructs a [`SalesforceCustomKnowledgeArticleTypeConfiguration`](crate::model::SalesforceCustomKnowledgeArticleTypeConfiguration).
        pub fn build(self) -> crate::model::SalesforceCustomKnowledgeArticleTypeConfiguration {
            crate::model::SalesforceCustomKnowledgeArticleTypeConfiguration {
                name: self.name,
                document_data_field_name: self.document_data_field_name,
                document_title_field_name: self.document_title_field_name,
                field_mappings: self.field_mappings,
            }
        }
    }
}
impl SalesforceCustomKnowledgeArticleTypeConfiguration {
    /// Creates a new builder-style object to manufacture [`SalesforceCustomKnowledgeArticleTypeConfiguration`](crate::model::SalesforceCustomKnowledgeArticleTypeConfiguration).
    pub fn builder() -> crate::model::salesforce_custom_knowledge_article_type_configuration::Builder
    {
        crate::model::salesforce_custom_knowledge_article_type_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information for standard Salesforce knowledge articles.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SalesforceStandardKnowledgeArticleTypeConfiguration {
    /// <p>The name of the field that contains the document data to index.</p>
    #[doc(hidden)]
    pub document_data_field_name: std::option::Option<std::string::String>,
    /// <p>The name of the field that contains the document title.</p>
    #[doc(hidden)]
    pub document_title_field_name: std::option::Option<std::string::String>,
    /// <p>Maps attributes or field names of the knowledge article to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Salesforce fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Salesforce data source field names must exist in your Salesforce custom metadata.</p>
    #[doc(hidden)]
    pub field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
}
impl SalesforceStandardKnowledgeArticleTypeConfiguration {
    /// <p>The name of the field that contains the document data to index.</p>
    pub fn document_data_field_name(&self) -> std::option::Option<&str> {
        self.document_data_field_name.as_deref()
    }
    /// <p>The name of the field that contains the document title.</p>
    pub fn document_title_field_name(&self) -> std::option::Option<&str> {
        self.document_title_field_name.as_deref()
    }
    /// <p>Maps attributes or field names of the knowledge article to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Salesforce fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Salesforce data source field names must exist in your Salesforce custom metadata.</p>
    pub fn field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.field_mappings.as_deref()
    }
}
/// See [`SalesforceStandardKnowledgeArticleTypeConfiguration`](crate::model::SalesforceStandardKnowledgeArticleTypeConfiguration).
pub mod salesforce_standard_knowledge_article_type_configuration {

    /// A builder for [`SalesforceStandardKnowledgeArticleTypeConfiguration`](crate::model::SalesforceStandardKnowledgeArticleTypeConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_data_field_name: std::option::Option<std::string::String>,
        pub(crate) document_title_field_name: std::option::Option<std::string::String>,
        pub(crate) field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    }
    impl Builder {
        /// <p>The name of the field that contains the document data to index.</p>
        pub fn document_data_field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_data_field_name = Some(input.into());
            self
        }
        /// <p>The name of the field that contains the document data to index.</p>
        pub fn set_document_data_field_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_data_field_name = input;
            self
        }
        /// <p>The name of the field that contains the document title.</p>
        pub fn document_title_field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_title_field_name = Some(input.into());
            self
        }
        /// <p>The name of the field that contains the document title.</p>
        pub fn set_document_title_field_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_title_field_name = input;
            self
        }
        /// Appends an item to `field_mappings`.
        ///
        /// To override the contents of this collection use [`set_field_mappings`](Self::set_field_mappings).
        ///
        /// <p>Maps attributes or field names of the knowledge article to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Salesforce fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Salesforce data source field names must exist in your Salesforce custom metadata.</p>
        pub fn field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.field_mappings.unwrap_or_default();
            v.push(input);
            self.field_mappings = Some(v);
            self
        }
        /// <p>Maps attributes or field names of the knowledge article to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Salesforce fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Salesforce data source field names must exist in your Salesforce custom metadata.</p>
        pub fn set_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.field_mappings = input;
            self
        }
        /// Consumes the builder and constructs a [`SalesforceStandardKnowledgeArticleTypeConfiguration`](crate::model::SalesforceStandardKnowledgeArticleTypeConfiguration).
        pub fn build(self) -> crate::model::SalesforceStandardKnowledgeArticleTypeConfiguration {
            crate::model::SalesforceStandardKnowledgeArticleTypeConfiguration {
                document_data_field_name: self.document_data_field_name,
                document_title_field_name: self.document_title_field_name,
                field_mappings: self.field_mappings,
            }
        }
    }
}
impl SalesforceStandardKnowledgeArticleTypeConfiguration {
    /// Creates a new builder-style object to manufacture [`SalesforceStandardKnowledgeArticleTypeConfiguration`](crate::model::SalesforceStandardKnowledgeArticleTypeConfiguration).
    pub fn builder(
    ) -> crate::model::salesforce_standard_knowledge_article_type_configuration::Builder {
        crate::model::salesforce_standard_knowledge_article_type_configuration::Builder::default()
    }
}

/// When writing a match expression against `SalesforceKnowledgeArticleState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let salesforceknowledgearticlestate = unimplemented!();
/// match salesforceknowledgearticlestate {
///     SalesforceKnowledgeArticleState::Archived => { /* ... */ },
///     SalesforceKnowledgeArticleState::Draft => { /* ... */ },
///     SalesforceKnowledgeArticleState::Published => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `salesforceknowledgearticlestate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SalesforceKnowledgeArticleState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SalesforceKnowledgeArticleState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SalesforceKnowledgeArticleState::NewFeature` is defined.
/// Specifically, when `salesforceknowledgearticlestate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SalesforceKnowledgeArticleState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SalesforceKnowledgeArticleState {
    #[allow(missing_docs)] // documentation missing in model
    Archived,
    #[allow(missing_docs)] // documentation missing in model
    Draft,
    #[allow(missing_docs)] // documentation missing in model
    Published,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SalesforceKnowledgeArticleState {
    fn from(s: &str) -> Self {
        match s {
            "ARCHIVED" => SalesforceKnowledgeArticleState::Archived,
            "DRAFT" => SalesforceKnowledgeArticleState::Draft,
            "PUBLISHED" => SalesforceKnowledgeArticleState::Published,
            other => SalesforceKnowledgeArticleState::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for SalesforceKnowledgeArticleState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SalesforceKnowledgeArticleState::from(s))
    }
}
impl SalesforceKnowledgeArticleState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SalesforceKnowledgeArticleState::Archived => "ARCHIVED",
            SalesforceKnowledgeArticleState::Draft => "DRAFT",
            SalesforceKnowledgeArticleState::Published => "PUBLISHED",
            SalesforceKnowledgeArticleState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ARCHIVED", "DRAFT", "PUBLISHED"]
    }
}
impl AsRef<str> for SalesforceKnowledgeArticleState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides the configuration information for indexing a single standard object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SalesforceStandardObjectConfiguration {
    /// <p>The name of the standard object.</p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::SalesforceStandardObjectName>,
    /// <p>The name of the field in the standard object table that contains the document contents.</p>
    #[doc(hidden)]
    pub document_data_field_name: std::option::Option<std::string::String>,
    /// <p>The name of the field in the standard object table that contains the document title.</p>
    #[doc(hidden)]
    pub document_title_field_name: std::option::Option<std::string::String>,
    /// <p>Maps attributes or field names of the standard object to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Salesforce fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Salesforce data source field names must exist in your Salesforce custom metadata.</p>
    #[doc(hidden)]
    pub field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
}
impl SalesforceStandardObjectConfiguration {
    /// <p>The name of the standard object.</p>
    pub fn name(&self) -> std::option::Option<&crate::model::SalesforceStandardObjectName> {
        self.name.as_ref()
    }
    /// <p>The name of the field in the standard object table that contains the document contents.</p>
    pub fn document_data_field_name(&self) -> std::option::Option<&str> {
        self.document_data_field_name.as_deref()
    }
    /// <p>The name of the field in the standard object table that contains the document title.</p>
    pub fn document_title_field_name(&self) -> std::option::Option<&str> {
        self.document_title_field_name.as_deref()
    }
    /// <p>Maps attributes or field names of the standard object to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Salesforce fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Salesforce data source field names must exist in your Salesforce custom metadata.</p>
    pub fn field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.field_mappings.as_deref()
    }
}
/// See [`SalesforceStandardObjectConfiguration`](crate::model::SalesforceStandardObjectConfiguration).
pub mod salesforce_standard_object_configuration {

    /// A builder for [`SalesforceStandardObjectConfiguration`](crate::model::SalesforceStandardObjectConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::SalesforceStandardObjectName>,
        pub(crate) document_data_field_name: std::option::Option<std::string::String>,
        pub(crate) document_title_field_name: std::option::Option<std::string::String>,
        pub(crate) field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    }
    impl Builder {
        /// <p>The name of the standard object.</p>
        pub fn name(mut self, input: crate::model::SalesforceStandardObjectName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the standard object.</p>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::SalesforceStandardObjectName>,
        ) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the field in the standard object table that contains the document contents.</p>
        pub fn document_data_field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_data_field_name = Some(input.into());
            self
        }
        /// <p>The name of the field in the standard object table that contains the document contents.</p>
        pub fn set_document_data_field_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_data_field_name = input;
            self
        }
        /// <p>The name of the field in the standard object table that contains the document title.</p>
        pub fn document_title_field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_title_field_name = Some(input.into());
            self
        }
        /// <p>The name of the field in the standard object table that contains the document title.</p>
        pub fn set_document_title_field_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_title_field_name = input;
            self
        }
        /// Appends an item to `field_mappings`.
        ///
        /// To override the contents of this collection use [`set_field_mappings`](Self::set_field_mappings).
        ///
        /// <p>Maps attributes or field names of the standard object to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Salesforce fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Salesforce data source field names must exist in your Salesforce custom metadata.</p>
        pub fn field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.field_mappings.unwrap_or_default();
            v.push(input);
            self.field_mappings = Some(v);
            self
        }
        /// <p>Maps attributes or field names of the standard object to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to Salesforce fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The Salesforce data source field names must exist in your Salesforce custom metadata.</p>
        pub fn set_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.field_mappings = input;
            self
        }
        /// Consumes the builder and constructs a [`SalesforceStandardObjectConfiguration`](crate::model::SalesforceStandardObjectConfiguration).
        pub fn build(self) -> crate::model::SalesforceStandardObjectConfiguration {
            crate::model::SalesforceStandardObjectConfiguration {
                name: self.name,
                document_data_field_name: self.document_data_field_name,
                document_title_field_name: self.document_title_field_name,
                field_mappings: self.field_mappings,
            }
        }
    }
}
impl SalesforceStandardObjectConfiguration {
    /// Creates a new builder-style object to manufacture [`SalesforceStandardObjectConfiguration`](crate::model::SalesforceStandardObjectConfiguration).
    pub fn builder() -> crate::model::salesforce_standard_object_configuration::Builder {
        crate::model::salesforce_standard_object_configuration::Builder::default()
    }
}

/// When writing a match expression against `SalesforceStandardObjectName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let salesforcestandardobjectname = unimplemented!();
/// match salesforcestandardobjectname {
///     SalesforceStandardObjectName::Account => { /* ... */ },
///     SalesforceStandardObjectName::Campaign => { /* ... */ },
///     SalesforceStandardObjectName::Case => { /* ... */ },
///     SalesforceStandardObjectName::Contact => { /* ... */ },
///     SalesforceStandardObjectName::Contract => { /* ... */ },
///     SalesforceStandardObjectName::Document => { /* ... */ },
///     SalesforceStandardObjectName::Group => { /* ... */ },
///     SalesforceStandardObjectName::Idea => { /* ... */ },
///     SalesforceStandardObjectName::Lead => { /* ... */ },
///     SalesforceStandardObjectName::Opportunity => { /* ... */ },
///     SalesforceStandardObjectName::Partner => { /* ... */ },
///     SalesforceStandardObjectName::Pricebook => { /* ... */ },
///     SalesforceStandardObjectName::Product => { /* ... */ },
///     SalesforceStandardObjectName::Profile => { /* ... */ },
///     SalesforceStandardObjectName::Solution => { /* ... */ },
///     SalesforceStandardObjectName::Task => { /* ... */ },
///     SalesforceStandardObjectName::User => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `salesforcestandardobjectname` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SalesforceStandardObjectName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SalesforceStandardObjectName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SalesforceStandardObjectName::NewFeature` is defined.
/// Specifically, when `salesforcestandardobjectname` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SalesforceStandardObjectName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SalesforceStandardObjectName {
    #[allow(missing_docs)] // documentation missing in model
    Account,
    #[allow(missing_docs)] // documentation missing in model
    Campaign,
    #[allow(missing_docs)] // documentation missing in model
    Case,
    #[allow(missing_docs)] // documentation missing in model
    Contact,
    #[allow(missing_docs)] // documentation missing in model
    Contract,
    #[allow(missing_docs)] // documentation missing in model
    Document,
    #[allow(missing_docs)] // documentation missing in model
    Group,
    #[allow(missing_docs)] // documentation missing in model
    Idea,
    #[allow(missing_docs)] // documentation missing in model
    Lead,
    #[allow(missing_docs)] // documentation missing in model
    Opportunity,
    #[allow(missing_docs)] // documentation missing in model
    Partner,
    #[allow(missing_docs)] // documentation missing in model
    Pricebook,
    #[allow(missing_docs)] // documentation missing in model
    Product,
    #[allow(missing_docs)] // documentation missing in model
    Profile,
    #[allow(missing_docs)] // documentation missing in model
    Solution,
    #[allow(missing_docs)] // documentation missing in model
    Task,
    #[allow(missing_docs)] // documentation missing in model
    User,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SalesforceStandardObjectName {
    fn from(s: &str) -> Self {
        match s {
            "ACCOUNT" => SalesforceStandardObjectName::Account,
            "CAMPAIGN" => SalesforceStandardObjectName::Campaign,
            "CASE" => SalesforceStandardObjectName::Case,
            "CONTACT" => SalesforceStandardObjectName::Contact,
            "CONTRACT" => SalesforceStandardObjectName::Contract,
            "DOCUMENT" => SalesforceStandardObjectName::Document,
            "GROUP" => SalesforceStandardObjectName::Group,
            "IDEA" => SalesforceStandardObjectName::Idea,
            "LEAD" => SalesforceStandardObjectName::Lead,
            "OPPORTUNITY" => SalesforceStandardObjectName::Opportunity,
            "PARTNER" => SalesforceStandardObjectName::Partner,
            "PRICEBOOK" => SalesforceStandardObjectName::Pricebook,
            "PRODUCT" => SalesforceStandardObjectName::Product,
            "PROFILE" => SalesforceStandardObjectName::Profile,
            "SOLUTION" => SalesforceStandardObjectName::Solution,
            "TASK" => SalesforceStandardObjectName::Task,
            "USER" => SalesforceStandardObjectName::User,
            other => SalesforceStandardObjectName::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for SalesforceStandardObjectName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SalesforceStandardObjectName::from(s))
    }
}
impl SalesforceStandardObjectName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SalesforceStandardObjectName::Account => "ACCOUNT",
            SalesforceStandardObjectName::Campaign => "CAMPAIGN",
            SalesforceStandardObjectName::Case => "CASE",
            SalesforceStandardObjectName::Contact => "CONTACT",
            SalesforceStandardObjectName::Contract => "CONTRACT",
            SalesforceStandardObjectName::Document => "DOCUMENT",
            SalesforceStandardObjectName::Group => "GROUP",
            SalesforceStandardObjectName::Idea => "IDEA",
            SalesforceStandardObjectName::Lead => "LEAD",
            SalesforceStandardObjectName::Opportunity => "OPPORTUNITY",
            SalesforceStandardObjectName::Partner => "PARTNER",
            SalesforceStandardObjectName::Pricebook => "PRICEBOOK",
            SalesforceStandardObjectName::Product => "PRODUCT",
            SalesforceStandardObjectName::Profile => "PROFILE",
            SalesforceStandardObjectName::Solution => "SOLUTION",
            SalesforceStandardObjectName::Task => "TASK",
            SalesforceStandardObjectName::User => "USER",
            SalesforceStandardObjectName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACCOUNT",
            "CAMPAIGN",
            "CASE",
            "CONTACT",
            "CONTRACT",
            "DOCUMENT",
            "GROUP",
            "IDEA",
            "LEAD",
            "OPPORTUNITY",
            "PARTNER",
            "PRICEBOOK",
            "PRODUCT",
            "PROFILE",
            "SOLUTION",
            "TASK",
            "USER",
        ]
    }
}
impl AsRef<str> for SalesforceStandardObjectName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides the configuration information to connect to a index. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DatabaseConfiguration {
    /// <p>The type of database engine that runs the database.</p>
    #[doc(hidden)]
    pub database_engine_type: std::option::Option<crate::model::DatabaseEngineType>,
    /// <p>Configuration information that's required to connect to a database.</p>
    #[doc(hidden)]
    pub connection_configuration: std::option::Option<crate::model::ConnectionConfiguration>,
    /// <p>Provides the configuration information to connect to an Amazon VPC.</p>
    #[doc(hidden)]
    pub vpc_configuration: std::option::Option<crate::model::DataSourceVpcConfiguration>,
    /// <p>Information about where the index should get the document information from the database.</p>
    #[doc(hidden)]
    pub column_configuration: std::option::Option<crate::model::ColumnConfiguration>,
    /// <p>Information about the database column that provides information for user context filtering.</p>
    #[doc(hidden)]
    pub acl_configuration: std::option::Option<crate::model::AclConfiguration>,
    /// <p>Provides information about how Amazon Kendra uses quote marks around SQL identifiers when querying a database data source.</p>
    #[doc(hidden)]
    pub sql_configuration: std::option::Option<crate::model::SqlConfiguration>,
}
impl DatabaseConfiguration {
    /// <p>The type of database engine that runs the database.</p>
    pub fn database_engine_type(&self) -> std::option::Option<&crate::model::DatabaseEngineType> {
        self.database_engine_type.as_ref()
    }
    /// <p>Configuration information that's required to connect to a database.</p>
    pub fn connection_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ConnectionConfiguration> {
        self.connection_configuration.as_ref()
    }
    /// <p>Provides the configuration information to connect to an Amazon VPC.</p>
    pub fn vpc_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DataSourceVpcConfiguration> {
        self.vpc_configuration.as_ref()
    }
    /// <p>Information about where the index should get the document information from the database.</p>
    pub fn column_configuration(&self) -> std::option::Option<&crate::model::ColumnConfiguration> {
        self.column_configuration.as_ref()
    }
    /// <p>Information about the database column that provides information for user context filtering.</p>
    pub fn acl_configuration(&self) -> std::option::Option<&crate::model::AclConfiguration> {
        self.acl_configuration.as_ref()
    }
    /// <p>Provides information about how Amazon Kendra uses quote marks around SQL identifiers when querying a database data source.</p>
    pub fn sql_configuration(&self) -> std::option::Option<&crate::model::SqlConfiguration> {
        self.sql_configuration.as_ref()
    }
}
/// See [`DatabaseConfiguration`](crate::model::DatabaseConfiguration).
pub mod database_configuration {

    /// A builder for [`DatabaseConfiguration`](crate::model::DatabaseConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) database_engine_type: std::option::Option<crate::model::DatabaseEngineType>,
        pub(crate) connection_configuration:
            std::option::Option<crate::model::ConnectionConfiguration>,
        pub(crate) vpc_configuration: std::option::Option<crate::model::DataSourceVpcConfiguration>,
        pub(crate) column_configuration: std::option::Option<crate::model::ColumnConfiguration>,
        pub(crate) acl_configuration: std::option::Option<crate::model::AclConfiguration>,
        pub(crate) sql_configuration: std::option::Option<crate::model::SqlConfiguration>,
    }
    impl Builder {
        /// <p>The type of database engine that runs the database.</p>
        pub fn database_engine_type(mut self, input: crate::model::DatabaseEngineType) -> Self {
            self.database_engine_type = Some(input);
            self
        }
        /// <p>The type of database engine that runs the database.</p>
        pub fn set_database_engine_type(
            mut self,
            input: std::option::Option<crate::model::DatabaseEngineType>,
        ) -> Self {
            self.database_engine_type = input;
            self
        }
        /// <p>Configuration information that's required to connect to a database.</p>
        pub fn connection_configuration(
            mut self,
            input: crate::model::ConnectionConfiguration,
        ) -> Self {
            self.connection_configuration = Some(input);
            self
        }
        /// <p>Configuration information that's required to connect to a database.</p>
        pub fn set_connection_configuration(
            mut self,
            input: std::option::Option<crate::model::ConnectionConfiguration>,
        ) -> Self {
            self.connection_configuration = input;
            self
        }
        /// <p>Provides the configuration information to connect to an Amazon VPC.</p>
        pub fn vpc_configuration(
            mut self,
            input: crate::model::DataSourceVpcConfiguration,
        ) -> Self {
            self.vpc_configuration = Some(input);
            self
        }
        /// <p>Provides the configuration information to connect to an Amazon VPC.</p>
        pub fn set_vpc_configuration(
            mut self,
            input: std::option::Option<crate::model::DataSourceVpcConfiguration>,
        ) -> Self {
            self.vpc_configuration = input;
            self
        }
        /// <p>Information about where the index should get the document information from the database.</p>
        pub fn column_configuration(mut self, input: crate::model::ColumnConfiguration) -> Self {
            self.column_configuration = Some(input);
            self
        }
        /// <p>Information about where the index should get the document information from the database.</p>
        pub fn set_column_configuration(
            mut self,
            input: std::option::Option<crate::model::ColumnConfiguration>,
        ) -> Self {
            self.column_configuration = input;
            self
        }
        /// <p>Information about the database column that provides information for user context filtering.</p>
        pub fn acl_configuration(mut self, input: crate::model::AclConfiguration) -> Self {
            self.acl_configuration = Some(input);
            self
        }
        /// <p>Information about the database column that provides information for user context filtering.</p>
        pub fn set_acl_configuration(
            mut self,
            input: std::option::Option<crate::model::AclConfiguration>,
        ) -> Self {
            self.acl_configuration = input;
            self
        }
        /// <p>Provides information about how Amazon Kendra uses quote marks around SQL identifiers when querying a database data source.</p>
        pub fn sql_configuration(mut self, input: crate::model::SqlConfiguration) -> Self {
            self.sql_configuration = Some(input);
            self
        }
        /// <p>Provides information about how Amazon Kendra uses quote marks around SQL identifiers when querying a database data source.</p>
        pub fn set_sql_configuration(
            mut self,
            input: std::option::Option<crate::model::SqlConfiguration>,
        ) -> Self {
            self.sql_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`DatabaseConfiguration`](crate::model::DatabaseConfiguration).
        pub fn build(self) -> crate::model::DatabaseConfiguration {
            crate::model::DatabaseConfiguration {
                database_engine_type: self.database_engine_type,
                connection_configuration: self.connection_configuration,
                vpc_configuration: self.vpc_configuration,
                column_configuration: self.column_configuration,
                acl_configuration: self.acl_configuration,
                sql_configuration: self.sql_configuration,
            }
        }
    }
}
impl DatabaseConfiguration {
    /// Creates a new builder-style object to manufacture [`DatabaseConfiguration`](crate::model::DatabaseConfiguration).
    pub fn builder() -> crate::model::database_configuration::Builder {
        crate::model::database_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information to use a SQL database.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SqlConfiguration {
    /// <p>Determines whether Amazon Kendra encloses SQL identifiers for tables and column names in double quotes (") when making a database query.</p>
    /// <p>By default, Amazon Kendra passes SQL identifiers the way that they are entered into the data source configuration. It does not change the case of identifiers or enclose them in quotes.</p>
    /// <p>PostgreSQL internally converts uppercase characters to lower case characters in identifiers unless they are quoted. Choosing this option encloses identifiers in quotes so that PostgreSQL does not convert the character's case.</p>
    /// <p>For MySQL databases, you must enable the <code>ansi_quotes</code> option when you set this field to <code>DOUBLE_QUOTES</code>.</p>
    #[doc(hidden)]
    pub query_identifiers_enclosing_option:
        std::option::Option<crate::model::QueryIdentifiersEnclosingOption>,
}
impl SqlConfiguration {
    /// <p>Determines whether Amazon Kendra encloses SQL identifiers for tables and column names in double quotes (") when making a database query.</p>
    /// <p>By default, Amazon Kendra passes SQL identifiers the way that they are entered into the data source configuration. It does not change the case of identifiers or enclose them in quotes.</p>
    /// <p>PostgreSQL internally converts uppercase characters to lower case characters in identifiers unless they are quoted. Choosing this option encloses identifiers in quotes so that PostgreSQL does not convert the character's case.</p>
    /// <p>For MySQL databases, you must enable the <code>ansi_quotes</code> option when you set this field to <code>DOUBLE_QUOTES</code>.</p>
    pub fn query_identifiers_enclosing_option(
        &self,
    ) -> std::option::Option<&crate::model::QueryIdentifiersEnclosingOption> {
        self.query_identifiers_enclosing_option.as_ref()
    }
}
/// See [`SqlConfiguration`](crate::model::SqlConfiguration).
pub mod sql_configuration {

    /// A builder for [`SqlConfiguration`](crate::model::SqlConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) query_identifiers_enclosing_option:
            std::option::Option<crate::model::QueryIdentifiersEnclosingOption>,
    }
    impl Builder {
        /// <p>Determines whether Amazon Kendra encloses SQL identifiers for tables and column names in double quotes (") when making a database query.</p>
        /// <p>By default, Amazon Kendra passes SQL identifiers the way that they are entered into the data source configuration. It does not change the case of identifiers or enclose them in quotes.</p>
        /// <p>PostgreSQL internally converts uppercase characters to lower case characters in identifiers unless they are quoted. Choosing this option encloses identifiers in quotes so that PostgreSQL does not convert the character's case.</p>
        /// <p>For MySQL databases, you must enable the <code>ansi_quotes</code> option when you set this field to <code>DOUBLE_QUOTES</code>.</p>
        pub fn query_identifiers_enclosing_option(
            mut self,
            input: crate::model::QueryIdentifiersEnclosingOption,
        ) -> Self {
            self.query_identifiers_enclosing_option = Some(input);
            self
        }
        /// <p>Determines whether Amazon Kendra encloses SQL identifiers for tables and column names in double quotes (") when making a database query.</p>
        /// <p>By default, Amazon Kendra passes SQL identifiers the way that they are entered into the data source configuration. It does not change the case of identifiers or enclose them in quotes.</p>
        /// <p>PostgreSQL internally converts uppercase characters to lower case characters in identifiers unless they are quoted. Choosing this option encloses identifiers in quotes so that PostgreSQL does not convert the character's case.</p>
        /// <p>For MySQL databases, you must enable the <code>ansi_quotes</code> option when you set this field to <code>DOUBLE_QUOTES</code>.</p>
        pub fn set_query_identifiers_enclosing_option(
            mut self,
            input: std::option::Option<crate::model::QueryIdentifiersEnclosingOption>,
        ) -> Self {
            self.query_identifiers_enclosing_option = input;
            self
        }
        /// Consumes the builder and constructs a [`SqlConfiguration`](crate::model::SqlConfiguration).
        pub fn build(self) -> crate::model::SqlConfiguration {
            crate::model::SqlConfiguration {
                query_identifiers_enclosing_option: self.query_identifiers_enclosing_option,
            }
        }
    }
}
impl SqlConfiguration {
    /// Creates a new builder-style object to manufacture [`SqlConfiguration`](crate::model::SqlConfiguration).
    pub fn builder() -> crate::model::sql_configuration::Builder {
        crate::model::sql_configuration::Builder::default()
    }
}

/// When writing a match expression against `QueryIdentifiersEnclosingOption`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let queryidentifiersenclosingoption = unimplemented!();
/// match queryidentifiersenclosingoption {
///     QueryIdentifiersEnclosingOption::DoubleQuotes => { /* ... */ },
///     QueryIdentifiersEnclosingOption::None => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `queryidentifiersenclosingoption` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `QueryIdentifiersEnclosingOption::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `QueryIdentifiersEnclosingOption::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `QueryIdentifiersEnclosingOption::NewFeature` is defined.
/// Specifically, when `queryidentifiersenclosingoption` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `QueryIdentifiersEnclosingOption::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum QueryIdentifiersEnclosingOption {
    #[allow(missing_docs)] // documentation missing in model
    DoubleQuotes,
    #[allow(missing_docs)] // documentation missing in model
    None,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for QueryIdentifiersEnclosingOption {
    fn from(s: &str) -> Self {
        match s {
            "DOUBLE_QUOTES" => QueryIdentifiersEnclosingOption::DoubleQuotes,
            "NONE" => QueryIdentifiersEnclosingOption::None,
            other => QueryIdentifiersEnclosingOption::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for QueryIdentifiersEnclosingOption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(QueryIdentifiersEnclosingOption::from(s))
    }
}
impl QueryIdentifiersEnclosingOption {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            QueryIdentifiersEnclosingOption::DoubleQuotes => "DOUBLE_QUOTES",
            QueryIdentifiersEnclosingOption::None => "NONE",
            QueryIdentifiersEnclosingOption::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DOUBLE_QUOTES", "NONE"]
    }
}
impl AsRef<str> for QueryIdentifiersEnclosingOption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information about the column that should be used for filtering the query response by groups.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AclConfiguration {
    /// <p>A list of groups, separated by semi-colons, that filters a query response based on user context. The document is only returned to users that are in one of the groups specified in the <code>UserContext</code> field of the <code>Query</code> API.</p>
    #[doc(hidden)]
    pub allowed_groups_column_name: std::option::Option<std::string::String>,
}
impl AclConfiguration {
    /// <p>A list of groups, separated by semi-colons, that filters a query response based on user context. The document is only returned to users that are in one of the groups specified in the <code>UserContext</code> field of the <code>Query</code> API.</p>
    pub fn allowed_groups_column_name(&self) -> std::option::Option<&str> {
        self.allowed_groups_column_name.as_deref()
    }
}
/// See [`AclConfiguration`](crate::model::AclConfiguration).
pub mod acl_configuration {

    /// A builder for [`AclConfiguration`](crate::model::AclConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) allowed_groups_column_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A list of groups, separated by semi-colons, that filters a query response based on user context. The document is only returned to users that are in one of the groups specified in the <code>UserContext</code> field of the <code>Query</code> API.</p>
        pub fn allowed_groups_column_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.allowed_groups_column_name = Some(input.into());
            self
        }
        /// <p>A list of groups, separated by semi-colons, that filters a query response based on user context. The document is only returned to users that are in one of the groups specified in the <code>UserContext</code> field of the <code>Query</code> API.</p>
        pub fn set_allowed_groups_column_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.allowed_groups_column_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AclConfiguration`](crate::model::AclConfiguration).
        pub fn build(self) -> crate::model::AclConfiguration {
            crate::model::AclConfiguration {
                allowed_groups_column_name: self.allowed_groups_column_name,
            }
        }
    }
}
impl AclConfiguration {
    /// Creates a new builder-style object to manufacture [`AclConfiguration`](crate::model::AclConfiguration).
    pub fn builder() -> crate::model::acl_configuration::Builder {
        crate::model::acl_configuration::Builder::default()
    }
}

/// <p>Provides information about how Amazon Kendra should use the columns of a database in an index.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColumnConfiguration {
    /// <p>The column that provides the document's identifier.</p>
    #[doc(hidden)]
    pub document_id_column_name: std::option::Option<std::string::String>,
    /// <p>The column that contains the contents of the document.</p>
    #[doc(hidden)]
    pub document_data_column_name: std::option::Option<std::string::String>,
    /// <p>The column that contains the title of the document.</p>
    #[doc(hidden)]
    pub document_title_column_name: std::option::Option<std::string::String>,
    /// <p>An array of objects that map database column names to the corresponding fields in an index. You must first create the fields in the index using the <code>UpdateIndex</code> API.</p>
    #[doc(hidden)]
    pub field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>One to five columns that indicate when a document in the database has changed.</p>
    #[doc(hidden)]
    pub change_detecting_columns: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ColumnConfiguration {
    /// <p>The column that provides the document's identifier.</p>
    pub fn document_id_column_name(&self) -> std::option::Option<&str> {
        self.document_id_column_name.as_deref()
    }
    /// <p>The column that contains the contents of the document.</p>
    pub fn document_data_column_name(&self) -> std::option::Option<&str> {
        self.document_data_column_name.as_deref()
    }
    /// <p>The column that contains the title of the document.</p>
    pub fn document_title_column_name(&self) -> std::option::Option<&str> {
        self.document_title_column_name.as_deref()
    }
    /// <p>An array of objects that map database column names to the corresponding fields in an index. You must first create the fields in the index using the <code>UpdateIndex</code> API.</p>
    pub fn field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.field_mappings.as_deref()
    }
    /// <p>One to five columns that indicate when a document in the database has changed.</p>
    pub fn change_detecting_columns(&self) -> std::option::Option<&[std::string::String]> {
        self.change_detecting_columns.as_deref()
    }
}
/// See [`ColumnConfiguration`](crate::model::ColumnConfiguration).
pub mod column_configuration {

    /// A builder for [`ColumnConfiguration`](crate::model::ColumnConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_id_column_name: std::option::Option<std::string::String>,
        pub(crate) document_data_column_name: std::option::Option<std::string::String>,
        pub(crate) document_title_column_name: std::option::Option<std::string::String>,
        pub(crate) field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) change_detecting_columns:
            std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The column that provides the document's identifier.</p>
        pub fn document_id_column_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_id_column_name = Some(input.into());
            self
        }
        /// <p>The column that provides the document's identifier.</p>
        pub fn set_document_id_column_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_id_column_name = input;
            self
        }
        /// <p>The column that contains the contents of the document.</p>
        pub fn document_data_column_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_data_column_name = Some(input.into());
            self
        }
        /// <p>The column that contains the contents of the document.</p>
        pub fn set_document_data_column_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_data_column_name = input;
            self
        }
        /// <p>The column that contains the title of the document.</p>
        pub fn document_title_column_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_title_column_name = Some(input.into());
            self
        }
        /// <p>The column that contains the title of the document.</p>
        pub fn set_document_title_column_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_title_column_name = input;
            self
        }
        /// Appends an item to `field_mappings`.
        ///
        /// To override the contents of this collection use [`set_field_mappings`](Self::set_field_mappings).
        ///
        /// <p>An array of objects that map database column names to the corresponding fields in an index. You must first create the fields in the index using the <code>UpdateIndex</code> API.</p>
        pub fn field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.field_mappings.unwrap_or_default();
            v.push(input);
            self.field_mappings = Some(v);
            self
        }
        /// <p>An array of objects that map database column names to the corresponding fields in an index. You must first create the fields in the index using the <code>UpdateIndex</code> API.</p>
        pub fn set_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.field_mappings = input;
            self
        }
        /// Appends an item to `change_detecting_columns`.
        ///
        /// To override the contents of this collection use [`set_change_detecting_columns`](Self::set_change_detecting_columns).
        ///
        /// <p>One to five columns that indicate when a document in the database has changed.</p>
        pub fn change_detecting_columns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.change_detecting_columns.unwrap_or_default();
            v.push(input.into());
            self.change_detecting_columns = Some(v);
            self
        }
        /// <p>One to five columns that indicate when a document in the database has changed.</p>
        pub fn set_change_detecting_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.change_detecting_columns = input;
            self
        }
        /// Consumes the builder and constructs a [`ColumnConfiguration`](crate::model::ColumnConfiguration).
        pub fn build(self) -> crate::model::ColumnConfiguration {
            crate::model::ColumnConfiguration {
                document_id_column_name: self.document_id_column_name,
                document_data_column_name: self.document_data_column_name,
                document_title_column_name: self.document_title_column_name,
                field_mappings: self.field_mappings,
                change_detecting_columns: self.change_detecting_columns,
            }
        }
    }
}
impl ColumnConfiguration {
    /// Creates a new builder-style object to manufacture [`ColumnConfiguration`](crate::model::ColumnConfiguration).
    pub fn builder() -> crate::model::column_configuration::Builder {
        crate::model::column_configuration::Builder::default()
    }
}

/// <p>Provides the configuration information that's required to connect to a database.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConnectionConfiguration {
    /// <p>The name of the host for the database. Can be either a string (host.subdomain.domain.tld) or an IPv4 or IPv6 address.</p>
    #[doc(hidden)]
    pub database_host: std::option::Option<std::string::String>,
    /// <p>The port that the database uses for connections.</p>
    #[doc(hidden)]
    pub database_port: std::option::Option<i32>,
    /// <p>The name of the database containing the document data.</p>
    #[doc(hidden)]
    pub database_name: std::option::Option<std::string::String>,
    /// <p>The name of the table that contains the document data.</p>
    #[doc(hidden)]
    pub table_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of credentials stored in Secrets Manager. The credentials should be a user/password pair. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-database.html">Using a Database Data Source</a>. For more information about Secrets Manager, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html"> What Is Secrets Manager</a> in the <i> Secrets Manager </i> user guide.</p>
    #[doc(hidden)]
    pub secret_arn: std::option::Option<std::string::String>,
}
impl ConnectionConfiguration {
    /// <p>The name of the host for the database. Can be either a string (host.subdomain.domain.tld) or an IPv4 or IPv6 address.</p>
    pub fn database_host(&self) -> std::option::Option<&str> {
        self.database_host.as_deref()
    }
    /// <p>The port that the database uses for connections.</p>
    pub fn database_port(&self) -> std::option::Option<i32> {
        self.database_port
    }
    /// <p>The name of the database containing the document data.</p>
    pub fn database_name(&self) -> std::option::Option<&str> {
        self.database_name.as_deref()
    }
    /// <p>The name of the table that contains the document data.</p>
    pub fn table_name(&self) -> std::option::Option<&str> {
        self.table_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of credentials stored in Secrets Manager. The credentials should be a user/password pair. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-database.html">Using a Database Data Source</a>. For more information about Secrets Manager, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html"> What Is Secrets Manager</a> in the <i> Secrets Manager </i> user guide.</p>
    pub fn secret_arn(&self) -> std::option::Option<&str> {
        self.secret_arn.as_deref()
    }
}
/// See [`ConnectionConfiguration`](crate::model::ConnectionConfiguration).
pub mod connection_configuration {

    /// A builder for [`ConnectionConfiguration`](crate::model::ConnectionConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) database_host: std::option::Option<std::string::String>,
        pub(crate) database_port: std::option::Option<i32>,
        pub(crate) database_name: std::option::Option<std::string::String>,
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) secret_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the host for the database. Can be either a string (host.subdomain.domain.tld) or an IPv4 or IPv6 address.</p>
        pub fn database_host(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_host = Some(input.into());
            self
        }
        /// <p>The name of the host for the database. Can be either a string (host.subdomain.domain.tld) or an IPv4 or IPv6 address.</p>
        pub fn set_database_host(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_host = input;
            self
        }
        /// <p>The port that the database uses for connections.</p>
        pub fn database_port(mut self, input: i32) -> Self {
            self.database_port = Some(input);
            self
        }
        /// <p>The port that the database uses for connections.</p>
        pub fn set_database_port(mut self, input: std::option::Option<i32>) -> Self {
            self.database_port = input;
            self
        }
        /// <p>The name of the database containing the document data.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_name = Some(input.into());
            self
        }
        /// <p>The name of the database containing the document data.</p>
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_name = input;
            self
        }
        /// <p>The name of the table that contains the document data.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_name = Some(input.into());
            self
        }
        /// <p>The name of the table that contains the document data.</p>
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of credentials stored in Secrets Manager. The credentials should be a user/password pair. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-database.html">Using a Database Data Source</a>. For more information about Secrets Manager, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html"> What Is Secrets Manager</a> in the <i> Secrets Manager </i> user guide.</p>
        pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of credentials stored in Secrets Manager. The credentials should be a user/password pair. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-database.html">Using a Database Data Source</a>. For more information about Secrets Manager, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html"> What Is Secrets Manager</a> in the <i> Secrets Manager </i> user guide.</p>
        pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ConnectionConfiguration`](crate::model::ConnectionConfiguration).
        pub fn build(self) -> crate::model::ConnectionConfiguration {
            crate::model::ConnectionConfiguration {
                database_host: self.database_host,
                database_port: self.database_port,
                database_name: self.database_name,
                table_name: self.table_name,
                secret_arn: self.secret_arn,
            }
        }
    }
}
impl ConnectionConfiguration {
    /// Creates a new builder-style object to manufacture [`ConnectionConfiguration`](crate::model::ConnectionConfiguration).
    pub fn builder() -> crate::model::connection_configuration::Builder {
        crate::model::connection_configuration::Builder::default()
    }
}

/// When writing a match expression against `DatabaseEngineType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let databaseenginetype = unimplemented!();
/// match databaseenginetype {
///     DatabaseEngineType::RdsAuroraMysql => { /* ... */ },
///     DatabaseEngineType::RdsAuroraPostgresql => { /* ... */ },
///     DatabaseEngineType::RdsMysql => { /* ... */ },
///     DatabaseEngineType::RdsPostgresql => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `databaseenginetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DatabaseEngineType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DatabaseEngineType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DatabaseEngineType::NewFeature` is defined.
/// Specifically, when `databaseenginetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DatabaseEngineType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DatabaseEngineType {
    #[allow(missing_docs)] // documentation missing in model
    RdsAuroraMysql,
    #[allow(missing_docs)] // documentation missing in model
    RdsAuroraPostgresql,
    #[allow(missing_docs)] // documentation missing in model
    RdsMysql,
    #[allow(missing_docs)] // documentation missing in model
    RdsPostgresql,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DatabaseEngineType {
    fn from(s: &str) -> Self {
        match s {
            "RDS_AURORA_MYSQL" => DatabaseEngineType::RdsAuroraMysql,
            "RDS_AURORA_POSTGRESQL" => DatabaseEngineType::RdsAuroraPostgresql,
            "RDS_MYSQL" => DatabaseEngineType::RdsMysql,
            "RDS_POSTGRESQL" => DatabaseEngineType::RdsPostgresql,
            other => {
                DatabaseEngineType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for DatabaseEngineType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DatabaseEngineType::from(s))
    }
}
impl DatabaseEngineType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DatabaseEngineType::RdsAuroraMysql => "RDS_AURORA_MYSQL",
            DatabaseEngineType::RdsAuroraPostgresql => "RDS_AURORA_POSTGRESQL",
            DatabaseEngineType::RdsMysql => "RDS_MYSQL",
            DatabaseEngineType::RdsPostgresql => "RDS_POSTGRESQL",
            DatabaseEngineType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "RDS_AURORA_MYSQL",
            "RDS_AURORA_POSTGRESQL",
            "RDS_MYSQL",
            "RDS_POSTGRESQL",
        ]
    }
}
impl AsRef<str> for DatabaseEngineType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides the configuration information to connect to Microsoft SharePoint as your data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SharePointConfiguration {
    /// <p>The version of Microsoft SharePoint that you use.</p>
    #[doc(hidden)]
    pub share_point_version: std::option::Option<crate::model::SharePointVersion>,
    /// <p>The Microsoft SharePoint site URLs for the documents you want to index.</p>
    #[doc(hidden)]
    pub urls: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the user name and password required to connect to the SharePoint instance. If you use SharePoint Server, you also need to provide the sever domain name as part of the credentials. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-sharepoint.html">Using a Microsoft SharePoint Data Source</a>.</p>
    /// <p>You can also provide OAuth authentication credentials of user name, password, client ID, and client secret. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-sharepoint.html">Using a SharePoint data source</a>.</p>
    #[doc(hidden)]
    pub secret_arn: std::option::Option<std::string::String>,
    /// <p> <code>TRUE</code> to index document attachments.</p>
    #[doc(hidden)]
    pub crawl_attachments: bool,
    /// <p> <code>TRUE</code> to use the SharePoint change log to determine which documents require updating in the index. Depending on the change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents in SharePoint.</p>
    #[doc(hidden)]
    pub use_change_log: bool,
    /// <p>A list of regular expression patterns to include certain documents in your SharePoint. Documents that match the patterns are included in the index. Documents that don't match the patterns are excluded from the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.</p>
    /// <p>The regex applies to the display URL of the SharePoint document.</p>
    #[doc(hidden)]
    pub inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of regular expression patterns to exclude certain documents in your SharePoint. Documents that match the patterns are excluded from the index. Documents that don't match the patterns are included in the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.</p>
    /// <p>The regex applies to the display URL of the SharePoint document.</p>
    #[doc(hidden)]
    pub exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Configuration information for an Amazon Virtual Private Cloud to connect to your Microsoft SharePoint. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
    #[doc(hidden)]
    pub vpc_configuration: std::option::Option<crate::model::DataSourceVpcConfiguration>,
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map SharePoint data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to SharePoint fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The SharePoint data source field names must exist in your SharePoint custom metadata.</p>
    #[doc(hidden)]
    pub field_mappings:
        std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
    /// <p>The Microsoft SharePoint attribute field that contains the title of the document.</p>
    #[doc(hidden)]
    pub document_title_field_name: std::option::Option<std::string::String>,
    /// <p> <code>TRUE</code> to disable local groups information.</p>
    #[doc(hidden)]
    pub disable_local_groups: bool,
    /// <p>The path to the SSL certificate stored in an Amazon S3 bucket. You use this to connect to SharePoint Server if you require a secure SSL connection.</p>
    /// <p>You can simply generate a self-signed X509 certificate on any computer using OpenSSL. For an example of using OpenSSL to create an X509 certificate, see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/configuring-https-ssl.html">Create and sign an X509 certificate</a>.</p>
    #[doc(hidden)]
    pub ssl_certificate_s3_path: std::option::Option<crate::model::S3Path>,
    /// <p>Whether you want to connect to SharePoint using basic authentication of user name and password, or OAuth authentication of user name, password, client ID, and client secret. You can use OAuth authentication for SharePoint Online.</p>
    #[doc(hidden)]
    pub authentication_type: std::option::Option<crate::model::SharePointOnlineAuthenticationType>,
    /// <p>Configuration information to connect to your Microsoft SharePoint site URLs via instance via a web proxy. You can use this option for SharePoint Server.</p>
    /// <p>You must provide the website host name and port number. For example, the host name of <i>https://a.example.com/page1.html</i> is "a.example.com" and the port is 443, the standard port for HTTPS.</p>
    /// <p>Web proxy credentials are optional and you can use them to connect to a web proxy server that requires basic authentication of user name and password. To store web proxy credentials, you use a secret in Secrets Manager.</p>
    /// <p>It is recommended that you follow best security practices when configuring your web proxy. This includes setting up throttling, setting up logging and monitoring, and applying security patches on a regular basis. If you use your web proxy with multiple data sources, sync jobs that occur at the same time could strain the load on your proxy. It is recommended you prepare your proxy beforehand for any security and load requirements.</p>
    #[doc(hidden)]
    pub proxy_configuration: std::option::Option<crate::model::ProxyConfiguration>,
}
impl SharePointConfiguration {
    /// <p>The version of Microsoft SharePoint that you use.</p>
    pub fn share_point_version(&self) -> std::option::Option<&crate::model::SharePointVersion> {
        self.share_point_version.as_ref()
    }
    /// <p>The Microsoft SharePoint site URLs for the documents you want to index.</p>
    pub fn urls(&self) -> std::option::Option<&[std::string::String]> {
        self.urls.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the user name and password required to connect to the SharePoint instance. If you use SharePoint Server, you also need to provide the sever domain name as part of the credentials. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-sharepoint.html">Using a Microsoft SharePoint Data Source</a>.</p>
    /// <p>You can also provide OAuth authentication credentials of user name, password, client ID, and client secret. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-sharepoint.html">Using a SharePoint data source</a>.</p>
    pub fn secret_arn(&self) -> std::option::Option<&str> {
        self.secret_arn.as_deref()
    }
    /// <p> <code>TRUE</code> to index document attachments.</p>
    pub fn crawl_attachments(&self) -> bool {
        self.crawl_attachments
    }
    /// <p> <code>TRUE</code> to use the SharePoint change log to determine which documents require updating in the index. Depending on the change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents in SharePoint.</p>
    pub fn use_change_log(&self) -> bool {
        self.use_change_log
    }
    /// <p>A list of regular expression patterns to include certain documents in your SharePoint. Documents that match the patterns are included in the index. Documents that don't match the patterns are excluded from the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.</p>
    /// <p>The regex applies to the display URL of the SharePoint document.</p>
    pub fn inclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.inclusion_patterns.as_deref()
    }
    /// <p>A list of regular expression patterns to exclude certain documents in your SharePoint. Documents that match the patterns are excluded from the index. Documents that don't match the patterns are included in the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.</p>
    /// <p>The regex applies to the display URL of the SharePoint document.</p>
    pub fn exclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.exclusion_patterns.as_deref()
    }
    /// <p>Configuration information for an Amazon Virtual Private Cloud to connect to your Microsoft SharePoint. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
    pub fn vpc_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DataSourceVpcConfiguration> {
        self.vpc_configuration.as_ref()
    }
    /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map SharePoint data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to SharePoint fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The SharePoint data source field names must exist in your SharePoint custom metadata.</p>
    pub fn field_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceToIndexFieldMapping]> {
        self.field_mappings.as_deref()
    }
    /// <p>The Microsoft SharePoint attribute field that contains the title of the document.</p>
    pub fn document_title_field_name(&self) -> std::option::Option<&str> {
        self.document_title_field_name.as_deref()
    }
    /// <p> <code>TRUE</code> to disable local groups information.</p>
    pub fn disable_local_groups(&self) -> bool {
        self.disable_local_groups
    }
    /// <p>The path to the SSL certificate stored in an Amazon S3 bucket. You use this to connect to SharePoint Server if you require a secure SSL connection.</p>
    /// <p>You can simply generate a self-signed X509 certificate on any computer using OpenSSL. For an example of using OpenSSL to create an X509 certificate, see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/configuring-https-ssl.html">Create and sign an X509 certificate</a>.</p>
    pub fn ssl_certificate_s3_path(&self) -> std::option::Option<&crate::model::S3Path> {
        self.ssl_certificate_s3_path.as_ref()
    }
    /// <p>Whether you want to connect to SharePoint using basic authentication of user name and password, or OAuth authentication of user name, password, client ID, and client secret. You can use OAuth authentication for SharePoint Online.</p>
    pub fn authentication_type(
        &self,
    ) -> std::option::Option<&crate::model::SharePointOnlineAuthenticationType> {
        self.authentication_type.as_ref()
    }
    /// <p>Configuration information to connect to your Microsoft SharePoint site URLs via instance via a web proxy. You can use this option for SharePoint Server.</p>
    /// <p>You must provide the website host name and port number. For example, the host name of <i>https://a.example.com/page1.html</i> is "a.example.com" and the port is 443, the standard port for HTTPS.</p>
    /// <p>Web proxy credentials are optional and you can use them to connect to a web proxy server that requires basic authentication of user name and password. To store web proxy credentials, you use a secret in Secrets Manager.</p>
    /// <p>It is recommended that you follow best security practices when configuring your web proxy. This includes setting up throttling, setting up logging and monitoring, and applying security patches on a regular basis. If you use your web proxy with multiple data sources, sync jobs that occur at the same time could strain the load on your proxy. It is recommended you prepare your proxy beforehand for any security and load requirements.</p>
    pub fn proxy_configuration(&self) -> std::option::Option<&crate::model::ProxyConfiguration> {
        self.proxy_configuration.as_ref()
    }
}
/// See [`SharePointConfiguration`](crate::model::SharePointConfiguration).
pub mod share_point_configuration {

    /// A builder for [`SharePointConfiguration`](crate::model::SharePointConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) share_point_version: std::option::Option<crate::model::SharePointVersion>,
        pub(crate) urls: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) secret_arn: std::option::Option<std::string::String>,
        pub(crate) crawl_attachments: std::option::Option<bool>,
        pub(crate) use_change_log: std::option::Option<bool>,
        pub(crate) inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) vpc_configuration: std::option::Option<crate::model::DataSourceVpcConfiguration>,
        pub(crate) field_mappings:
            std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        pub(crate) document_title_field_name: std::option::Option<std::string::String>,
        pub(crate) disable_local_groups: std::option::Option<bool>,
        pub(crate) ssl_certificate_s3_path: std::option::Option<crate::model::S3Path>,
        pub(crate) authentication_type:
            std::option::Option<crate::model::SharePointOnlineAuthenticationType>,
        pub(crate) proxy_configuration: std::option::Option<crate::model::ProxyConfiguration>,
    }
    impl Builder {
        /// <p>The version of Microsoft SharePoint that you use.</p>
        pub fn share_point_version(mut self, input: crate::model::SharePointVersion) -> Self {
            self.share_point_version = Some(input);
            self
        }
        /// <p>The version of Microsoft SharePoint that you use.</p>
        pub fn set_share_point_version(
            mut self,
            input: std::option::Option<crate::model::SharePointVersion>,
        ) -> Self {
            self.share_point_version = input;
            self
        }
        /// Appends an item to `urls`.
        ///
        /// To override the contents of this collection use [`set_urls`](Self::set_urls).
        ///
        /// <p>The Microsoft SharePoint site URLs for the documents you want to index.</p>
        pub fn urls(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.urls.unwrap_or_default();
            v.push(input.into());
            self.urls = Some(v);
            self
        }
        /// <p>The Microsoft SharePoint site URLs for the documents you want to index.</p>
        pub fn set_urls(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.urls = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the user name and password required to connect to the SharePoint instance. If you use SharePoint Server, you also need to provide the sever domain name as part of the credentials. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-sharepoint.html">Using a Microsoft SharePoint Data Source</a>.</p>
        /// <p>You can also provide OAuth authentication credentials of user name, password, client ID, and client secret. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-sharepoint.html">Using a SharePoint data source</a>.</p>
        pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an Secrets Manager secret that contains the user name and password required to connect to the SharePoint instance. If you use SharePoint Server, you also need to provide the sever domain name as part of the credentials. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-sharepoint.html">Using a Microsoft SharePoint Data Source</a>.</p>
        /// <p>You can also provide OAuth authentication credentials of user name, password, client ID, and client secret. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/data-source-sharepoint.html">Using a SharePoint data source</a>.</p>
        pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_arn = input;
            self
        }
        /// <p> <code>TRUE</code> to index document attachments.</p>
        pub fn crawl_attachments(mut self, input: bool) -> Self {
            self.crawl_attachments = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to index document attachments.</p>
        pub fn set_crawl_attachments(mut self, input: std::option::Option<bool>) -> Self {
            self.crawl_attachments = input;
            self
        }
        /// <p> <code>TRUE</code> to use the SharePoint change log to determine which documents require updating in the index. Depending on the change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents in SharePoint.</p>
        pub fn use_change_log(mut self, input: bool) -> Self {
            self.use_change_log = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to use the SharePoint change log to determine which documents require updating in the index. Depending on the change log's size, it may take longer for Amazon Kendra to use the change log than to scan all of your documents in SharePoint.</p>
        pub fn set_use_change_log(mut self, input: std::option::Option<bool>) -> Self {
            self.use_change_log = input;
            self
        }
        /// Appends an item to `inclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_inclusion_patterns`](Self::set_inclusion_patterns).
        ///
        /// <p>A list of regular expression patterns to include certain documents in your SharePoint. Documents that match the patterns are included in the index. Documents that don't match the patterns are excluded from the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.</p>
        /// <p>The regex applies to the display URL of the SharePoint document.</p>
        pub fn inclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.inclusion_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to include certain documents in your SharePoint. Documents that match the patterns are included in the index. Documents that don't match the patterns are excluded from the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.</p>
        /// <p>The regex applies to the display URL of the SharePoint document.</p>
        pub fn set_inclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inclusion_patterns = input;
            self
        }
        /// Appends an item to `exclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_exclusion_patterns`](Self::set_exclusion_patterns).
        ///
        /// <p>A list of regular expression patterns to exclude certain documents in your SharePoint. Documents that match the patterns are excluded from the index. Documents that don't match the patterns are included in the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.</p>
        /// <p>The regex applies to the display URL of the SharePoint document.</p>
        pub fn exclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.exclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.exclusion_patterns = Some(v);
            self
        }
        /// <p>A list of regular expression patterns to exclude certain documents in your SharePoint. Documents that match the patterns are excluded from the index. Documents that don't match the patterns are included in the index. If a document matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the document isn't included in the index.</p>
        /// <p>The regex applies to the display URL of the SharePoint document.</p>
        pub fn set_exclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclusion_patterns = input;
            self
        }
        /// <p>Configuration information for an Amazon Virtual Private Cloud to connect to your Microsoft SharePoint. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
        pub fn vpc_configuration(
            mut self,
            input: crate::model::DataSourceVpcConfiguration,
        ) -> Self {
            self.vpc_configuration = Some(input);
            self
        }
        /// <p>Configuration information for an Amazon Virtual Private Cloud to connect to your Microsoft SharePoint. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/vpc-configuration.html">Configuring a VPC</a>.</p>
        pub fn set_vpc_configuration(
            mut self,
            input: std::option::Option<crate::model::DataSourceVpcConfiguration>,
        ) -> Self {
            self.vpc_configuration = input;
            self
        }
        /// Appends an item to `field_mappings`.
        ///
        /// To override the contents of this collection use [`set_field_mappings`](Self::set_field_mappings).
        ///
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map SharePoint data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to SharePoint fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The SharePoint data source field names must exist in your SharePoint custom metadata.</p>
        pub fn field_mappings(
            mut self,
            input: crate::model::DataSourceToIndexFieldMapping,
        ) -> Self {
            let mut v = self.field_mappings.unwrap_or_default();
            v.push(input);
            self.field_mappings = Some(v);
            self
        }
        /// <p>A list of <code>DataSourceToIndexFieldMapping</code> objects that map SharePoint data source attributes or field names to Amazon Kendra index field names. To create custom fields, use the <code>UpdateIndex</code> API before you map to SharePoint fields. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/field-mapping.html">Mapping data source fields</a>. The SharePoint data source field names must exist in your SharePoint custom metadata.</p>
        pub fn set_field_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceToIndexFieldMapping>>,
        ) -> Self {
            self.field_mappings = input;
            self
        }
        /// <p>The Microsoft SharePoint attribute field that contains the title of the document.</p>
        pub fn document_title_field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_title_field_name = Some(input.into());
            self
        }
        /// <p>The Microsoft SharePoint attribute field that contains the title of the document.</p>
        pub fn set_document_title_field_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_title_field_name = input;
            self
        }
        /// <p> <code>TRUE</code> to disable local groups information.</p>
        pub fn disable_local_groups(mut self, input: bool) -> Self {
            self.disable_local_groups = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to disable local groups information.</p>
        pub fn set_disable_local_groups(mut self, input: std::option::Option<bool>) -> Self {
            self.disable_local_groups = input;
            self
        }
        /// <p>The path to the SSL certificate stored in an Amazon S3 bucket. You use this to connect to SharePoint Server if you require a secure SSL connection.</p>
        /// <p>You can simply generate a self-signed X509 certificate on any computer using OpenSSL. For an example of using OpenSSL to create an X509 certificate, see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/configuring-https-ssl.html">Create and sign an X509 certificate</a>.</p>
        pub fn ssl_certificate_s3_path(mut self, input: crate::model::S3Path) -> Self {
            self.ssl_certificate_s3_path = Some(input);
            self
        }
        /// <p>The path to the SSL certificate stored in an Amazon S3 bucket. You use this to connect to SharePoint Server if you require a secure SSL connection.</p>
        /// <p>You can simply generate a self-signed X509 certificate on any computer using OpenSSL. For an example of using OpenSSL to create an X509 certificate, see <a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/configuring-https-ssl.html">Create and sign an X509 certificate</a>.</p>
        pub fn set_ssl_certificate_s3_path(
            mut self,
            input: std::option::Option<crate::model::S3Path>,
        ) -> Self {
            self.ssl_certificate_s3_path = input;
            self
        }
        /// <p>Whether you want to connect to SharePoint using basic authentication of user name and password, or OAuth authentication of user name, password, client ID, and client secret. You can use OAuth authentication for SharePoint Online.</p>
        pub fn authentication_type(
            mut self,
            input: crate::model::SharePointOnlineAuthenticationType,
        ) -> Self {
            self.authentication_type = Some(input);
            self
        }
        /// <p>Whether you want to connect to SharePoint using basic authentication of user name and password, or OAuth authentication of user name, password, client ID, and client secret. You can use OAuth authentication for SharePoint Online.</p>
        pub fn set_authentication_type(
            mut self,
            input: std::option::Option<crate::model::SharePointOnlineAuthenticationType>,
        ) -> Self {
            self.authentication_type = input;
            self
        }
        /// <p>Configuration information to connect to your Microsoft SharePoint site URLs via instance via a web proxy. You can use this option for SharePoint Server.</p>
        /// <p>You must provide the website host name and port number. For example, the host name of <i>https://a.example.com/page1.html</i> is "a.example.com" and the port is 443, the standard port for HTTPS.</p>
        /// <p>Web proxy credentials are optional and you can use them to connect to a web proxy server that requires basic authentication of user name and password. To store web proxy credentials, you use a secret in Secrets Manager.</p>
        /// <p>It is recommended that you follow best security practices when configuring your web proxy. This includes setting up throttling, setting up logging and monitoring, and applying security patches on a regular basis. If you use your web proxy with multiple data sources, sync jobs that occur at the same time could strain the load on your proxy. It is recommended you prepare your proxy beforehand for any security and load requirements.</p>
        pub fn proxy_configuration(mut self, input: crate::model::ProxyConfiguration) -> Self {
            self.proxy_configuration = Some(input);
            self
        }
        /// <p>Configuration information to connect to your Microsoft SharePoint site URLs via instance via a web proxy. You can use this option for SharePoint Server.</p>
        /// <p>You must provide the website host name and port number. For example, the host name of <i>https://a.example.com/page1.html</i> is "a.example.com" and the port is 443, the standard port for HTTPS.</p>
        /// <p>Web proxy credentials are optional and you can use them to connect to a web proxy server that requires basic authentication of user name and password. To store web proxy credentials, you use a secret in Secrets Manager.</p>
        /// <p>It is recommended that you follow best security practices when configuring your web proxy. This includes setting up throttling, setting up logging and monitoring, and applying security patches on a regular basis. If you use your web proxy with multiple data sources, sync jobs that occur at the same time could strain the load on your proxy. It is recommended you prepare your proxy beforehand for any security and load requirements.</p>
        pub fn set_proxy_configuration(
            mut self,
            input: std::option::Option<crate::model::ProxyConfiguration>,
        ) -> Self {
            self.proxy_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`SharePointConfiguration`](crate::model::SharePointConfiguration).
        pub fn build(self) -> crate::model::SharePointConfiguration {
            crate::model::SharePointConfiguration {
                share_point_version: self.share_point_version,
                urls: self.urls,
                secret_arn: self.secret_arn,
                crawl_attachments: self.crawl_attachments.unwrap_or_default(),
                use_change_log: self.use_change_log.unwrap_or_default(),
                inclusion_patterns: self.inclusion_patterns,
                exclusion_patterns: self.exclusion_patterns,
                vpc_configuration: self.vpc_configuration,
                field_mappings: self.field_mappings,
                document_title_field_name: self.document_title_field_name,
                disable_local_groups: self.disable_local_groups.unwrap_or_default(),
                ssl_certificate_s3_path: self.ssl_certificate_s3_path,
                authentication_type: self.authentication_type,
                proxy_configuration: self.proxy_configuration,
            }
        }
    }
}
impl SharePointConfiguration {
    /// Creates a new builder-style object to manufacture [`SharePointConfiguration`](crate::model::SharePointConfiguration).
    pub fn builder() -> crate::model::share_point_configuration::Builder {
        crate::model::share_point_configuration::Builder::default()
    }
}

/// When writing a match expression against `SharePointOnlineAuthenticationType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sharepointonlineauthenticationtype = unimplemented!();
/// match sharepointonlineauthenticationtype {
///     SharePointOnlineAuthenticationType::HttpBasic => { /* ... */ },
///     SharePointOnlineAuthenticationType::Oauth2 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sharepointonlineauthenticationtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SharePointOnlineAuthenticationType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SharePointOnlineAuthenticationType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SharePointOnlineAuthenticationType::NewFeature` is defined.
/// Specifically, when `sharepointonlineauthenticationtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SharePointOnlineAuthenticationType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SharePointOnlineAuthenticationType {
    #[allow(missing_docs)] // documentation missing in model
    HttpBasic,
    #[allow(missing_docs)] // documentation missing in model
    Oauth2,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SharePointOnlineAuthenticationType {
    fn from(s: &str) -> Self {
        match s {
            "HTTP_BASIC" => SharePointOnlineAuthenticationType::HttpBasic,
            "OAUTH2" => SharePointOnlineAuthenticationType::Oauth2,
            other => SharePointOnlineAuthenticationType::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for SharePointOnlineAuthenticationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SharePointOnlineAuthenticationType::from(s))
    }
}
impl SharePointOnlineAuthenticationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SharePointOnlineAuthenticationType::HttpBasic => "HTTP_BASIC",
            SharePointOnlineAuthenticationType::Oauth2 => "OAUTH2",
            SharePointOnlineAuthenticationType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["HTTP_BASIC", "OAUTH2"]
    }
}
impl AsRef<str> for SharePointOnlineAuthenticationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SharePointVersion`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sharepointversion = unimplemented!();
/// match sharepointversion {
///     SharePointVersion::Sharepoint2013 => { /* ... */ },
///     SharePointVersion::Sharepoint2016 => { /* ... */ },
///     SharePointVersion::Sharepoint2019 => { /* ... */ },
///     SharePointVersion::SharepointOnline => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sharepointversion` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SharePointVersion::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SharePointVersion::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SharePointVersion::NewFeature` is defined.
/// Specifically, when `sharepointversion` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SharePointVersion::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SharePointVersion {
    #[allow(missing_docs)] // documentation missing in model
    Sharepoint2013,
    #[allow(missing_docs)] // documentation missing in model
    Sharepoint2016,
    #[allow(missing_docs)] // documentation missing in model
    Sharepoint2019,
    #[allow(missing_docs)] // documentation missing in model
    SharepointOnline,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SharePointVersion {
    fn from(s: &str) -> Self {
        match s {
            "SHAREPOINT_2013" => SharePointVersion::Sharepoint2013,
            "SHAREPOINT_2016" => SharePointVersion::Sharepoint2016,
            "SHAREPOINT_2019" => SharePointVersion::Sharepoint2019,
            "SHAREPOINT_ONLINE" => SharePointVersion::SharepointOnline,
            other => {
                SharePointVersion::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for SharePointVersion {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SharePointVersion::from(s))
    }
}
impl SharePointVersion {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SharePointVersion::Sharepoint2013 => "SHAREPOINT_2013",
            SharePointVersion::Sharepoint2016 => "SHAREPOINT_2016",
            SharePointVersion::Sharepoint2019 => "SHAREPOINT_2019",
            SharePointVersion::SharepointOnline => "SHAREPOINT_ONLINE",
            SharePointVersion::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "SHAREPOINT_2013",
            "SHAREPOINT_2016",
            "SHAREPOINT_2019",
            "SHAREPOINT_ONLINE",
        ]
    }
}
impl AsRef<str> for SharePointVersion {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides the configuration information to connect to an Amazon S3 bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3DataSourceConfiguration {
    /// <p>The name of the bucket that contains the documents.</p>
    #[doc(hidden)]
    pub bucket_name: std::option::Option<std::string::String>,
    /// <p>A list of S3 prefixes for the documents that should be included in the index.</p>
    #[doc(hidden)]
    pub inclusion_prefixes: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of glob patterns for documents that should be indexed. If a document that matches an inclusion pattern also matches an exclusion pattern, the document is not indexed.</p>
    /// <p>Some <a href="https://docs.aws.amazon.com/cli/latest/reference/s3/#use-of-exclude-and-include-filters">examples</a> are:</p>
    /// <ul>
    /// <li> <p> <i>*.txt</i> will include all text files in a directory (files with the extension .txt).</p> </li>
    /// <li> <p> <i>**/*.txt</i> will include all text files in a directory and its subdirectories.</p> </li>
    /// <li> <p> <i>*tax*</i> will include all files in a directory that contain 'tax' in the file name, such as 'tax', 'taxes', 'income_tax'.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of glob patterns for documents that should not be indexed. If a document that matches an inclusion prefix or inclusion pattern also matches an exclusion pattern, the document is not indexed.</p>
    /// <p>Some <a href="https://docs.aws.amazon.com/cli/latest/reference/s3/#use-of-exclude-and-include-filters">examples</a> are:</p>
    /// <ul>
    /// <li> <p> <i>*.png , *.jpg</i> will exclude all PNG and JPEG image files in a directory (files with the extensions .png and .jpg).</p> </li>
    /// <li> <p> <i>*internal*</i> will exclude all files in a directory that contain 'internal' in the file name, such as 'internal', 'internal_only', 'company_internal'.</p> </li>
    /// <li> <p> <i>**/*internal*</i> will exclude all internal-related files in a directory and its subdirectories.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Document metadata files that contain information such as the document access control information, source URI, document author, and custom attributes. Each metadata file contains metadata about a single document.</p>
    #[doc(hidden)]
    pub documents_metadata_configuration:
        std::option::Option<crate::model::DocumentsMetadataConfiguration>,
    /// <p>Provides the path to the S3 bucket that contains the user context filtering files for the data source. For the format of the file, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/s3-acl.html">Access control for S3 data sources</a>.</p>
    #[doc(hidden)]
    pub access_control_list_configuration:
        std::option::Option<crate::model::AccessControlListConfiguration>,
}
impl S3DataSourceConfiguration {
    /// <p>The name of the bucket that contains the documents.</p>
    pub fn bucket_name(&self) -> std::option::Option<&str> {
        self.bucket_name.as_deref()
    }
    /// <p>A list of S3 prefixes for the documents that should be included in the index.</p>
    pub fn inclusion_prefixes(&self) -> std::option::Option<&[std::string::String]> {
        self.inclusion_prefixes.as_deref()
    }
    /// <p>A list of glob patterns for documents that should be indexed. If a document that matches an inclusion pattern also matches an exclusion pattern, the document is not indexed.</p>
    /// <p>Some <a href="https://docs.aws.amazon.com/cli/latest/reference/s3/#use-of-exclude-and-include-filters">examples</a> are:</p>
    /// <ul>
    /// <li> <p> <i>*.txt</i> will include all text files in a directory (files with the extension .txt).</p> </li>
    /// <li> <p> <i>**/*.txt</i> will include all text files in a directory and its subdirectories.</p> </li>
    /// <li> <p> <i>*tax*</i> will include all files in a directory that contain 'tax' in the file name, such as 'tax', 'taxes', 'income_tax'.</p> </li>
    /// </ul>
    pub fn inclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.inclusion_patterns.as_deref()
    }
    /// <p>A list of glob patterns for documents that should not be indexed. If a document that matches an inclusion prefix or inclusion pattern also matches an exclusion pattern, the document is not indexed.</p>
    /// <p>Some <a href="https://docs.aws.amazon.com/cli/latest/reference/s3/#use-of-exclude-and-include-filters">examples</a> are:</p>
    /// <ul>
    /// <li> <p> <i>*.png , *.jpg</i> will exclude all PNG and JPEG image files in a directory (files with the extensions .png and .jpg).</p> </li>
    /// <li> <p> <i>*internal*</i> will exclude all files in a directory that contain 'internal' in the file name, such as 'internal', 'internal_only', 'company_internal'.</p> </li>
    /// <li> <p> <i>**/*internal*</i> will exclude all internal-related files in a directory and its subdirectories.</p> </li>
    /// </ul>
    pub fn exclusion_patterns(&self) -> std::option::Option<&[std::string::String]> {
        self.exclusion_patterns.as_deref()
    }
    /// <p>Document metadata files that contain information such as the document access control information, source URI, document author, and custom attributes. Each metadata file contains metadata about a single document.</p>
    pub fn documents_metadata_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DocumentsMetadataConfiguration> {
        self.documents_metadata_configuration.as_ref()
    }
    /// <p>Provides the path to the S3 bucket that contains the user context filtering files for the data source. For the format of the file, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/s3-acl.html">Access control for S3 data sources</a>.</p>
    pub fn access_control_list_configuration(
        &self,
    ) -> std::option::Option<&crate::model::AccessControlListConfiguration> {
        self.access_control_list_configuration.as_ref()
    }
}
/// See [`S3DataSourceConfiguration`](crate::model::S3DataSourceConfiguration).
pub mod s3_data_source_configuration {

    /// A builder for [`S3DataSourceConfiguration`](crate::model::S3DataSourceConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_name: std::option::Option<std::string::String>,
        pub(crate) inclusion_prefixes: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) inclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) exclusion_patterns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) documents_metadata_configuration:
            std::option::Option<crate::model::DocumentsMetadataConfiguration>,
        pub(crate) access_control_list_configuration:
            std::option::Option<crate::model::AccessControlListConfiguration>,
    }
    impl Builder {
        /// <p>The name of the bucket that contains the documents.</p>
        pub fn bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_name = Some(input.into());
            self
        }
        /// <p>The name of the bucket that contains the documents.</p>
        pub fn set_bucket_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_name = input;
            self
        }
        /// Appends an item to `inclusion_prefixes`.
        ///
        /// To override the contents of this collection use [`set_inclusion_prefixes`](Self::set_inclusion_prefixes).
        ///
        /// <p>A list of S3 prefixes for the documents that should be included in the index.</p>
        pub fn inclusion_prefixes(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inclusion_prefixes.unwrap_or_default();
            v.push(input.into());
            self.inclusion_prefixes = Some(v);
            self
        }
        /// <p>A list of S3 prefixes for the documents that should be included in the index.</p>
        pub fn set_inclusion_prefixes(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inclusion_prefixes = input;
            self
        }
        /// Appends an item to `inclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_inclusion_patterns`](Self::set_inclusion_patterns).
        ///
        /// <p>A list of glob patterns for documents that should be indexed. If a document that matches an inclusion pattern also matches an exclusion pattern, the document is not indexed.</p>
        /// <p>Some <a href="https://docs.aws.amazon.com/cli/latest/reference/s3/#use-of-exclude-and-include-filters">examples</a> are:</p>
        /// <ul>
        /// <li> <p> <i>*.txt</i> will include all text files in a directory (files with the extension .txt).</p> </li>
        /// <li> <p> <i>**/*.txt</i> will include all text files in a directory and its subdirectories.</p> </li>
        /// <li> <p> <i>*tax*</i> will include all files in a directory that contain 'tax' in the file name, such as 'tax', 'taxes', 'income_tax'.</p> </li>
        /// </ul>
        pub fn inclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.inclusion_patterns = Some(v);
            self
        }
        /// <p>A list of glob patterns for documents that should be indexed. If a document that matches an inclusion pattern also matches an exclusion pattern, the document is not indexed.</p>
        /// <p>Some <a href="https://docs.aws.amazon.com/cli/latest/reference/s3/#use-of-exclude-and-include-filters">examples</a> are:</p>
        /// <ul>
        /// <li> <p> <i>*.txt</i> will include all text files in a directory (files with the extension .txt).</p> </li>
        /// <li> <p> <i>**/*.txt</i> will include all text files in a directory and its subdirectories.</p> </li>
        /// <li> <p> <i>*tax*</i> will include all files in a directory that contain 'tax' in the file name, such as 'tax', 'taxes', 'income_tax'.</p> </li>
        /// </ul>
        pub fn set_inclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inclusion_patterns = input;
            self
        }
        /// Appends an item to `exclusion_patterns`.
        ///
        /// To override the contents of this collection use [`set_exclusion_patterns`](Self::set_exclusion_patterns).
        ///
        /// <p>A list of glob patterns for documents that should not be indexed. If a document that matches an inclusion prefix or inclusion pattern also matches an exclusion pattern, the document is not indexed.</p>
        /// <p>Some <a href="https://docs.aws.amazon.com/cli/latest/reference/s3/#use-of-exclude-and-include-filters">examples</a> are:</p>
        /// <ul>
        /// <li> <p> <i>*.png , *.jpg</i> will exclude all PNG and JPEG image files in a directory (files with the extensions .png and .jpg).</p> </li>
        /// <li> <p> <i>*internal*</i> will exclude all files in a directory that contain 'internal' in the file name, such as 'internal', 'internal_only', 'company_internal'.</p> </li>
        /// <li> <p> <i>**/*internal*</i> will exclude all internal-related files in a directory and its subdirectories.</p> </li>
        /// </ul>
        pub fn exclusion_patterns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.exclusion_patterns.unwrap_or_default();
            v.push(input.into());
            self.exclusion_patterns = Some(v);
            self
        }
        /// <p>A list of glob patterns for documents that should not be indexed. If a document that matches an inclusion prefix or inclusion pattern also matches an exclusion pattern, the document is not indexed.</p>
        /// <p>Some <a href="https://docs.aws.amazon.com/cli/latest/reference/s3/#use-of-exclude-and-include-filters">examples</a> are:</p>
        /// <ul>
        /// <li> <p> <i>*.png , *.jpg</i> will exclude all PNG and JPEG image files in a directory (files with the extensions .png and .jpg).</p> </li>
        /// <li> <p> <i>*internal*</i> will exclude all files in a directory that contain 'internal' in the file name, such as 'internal', 'internal_only', 'company_internal'.</p> </li>
        /// <li> <p> <i>**/*internal*</i> will exclude all internal-related files in a directory and its subdirectories.</p> </li>
        /// </ul>
        pub fn set_exclusion_patterns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exclusion_patterns = input;
            self
        }
        /// <p>Document metadata files that contain information such as the document access control information, source URI, document author, and custom attributes. Each metadata file contains metadata about a single document.</p>
        pub fn documents_metadata_configuration(
            mut self,
            input: crate::model::DocumentsMetadataConfiguration,
        ) -> Self {
            self.documents_metadata_configuration = Some(input);
            self
        }
        /// <p>Document metadata files that contain information such as the document access control information, source URI, document author, and custom attributes. Each metadata file contains metadata about a single document.</p>
        pub fn set_documents_metadata_configuration(
            mut self,
            input: std::option::Option<crate::model::DocumentsMetadataConfiguration>,
        ) -> Self {
            self.documents_metadata_configuration = input;
            self
        }
        /// <p>Provides the path to the S3 bucket that contains the user context filtering files for the data source. For the format of the file, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/s3-acl.html">Access control for S3 data sources</a>.</p>
        pub fn access_control_list_configuration(
            mut self,
            input: crate::model::AccessControlListConfiguration,
        ) -> Self {
            self.access_control_list_configuration = Some(input);
            self
        }
        /// <p>Provides the path to the S3 bucket that contains the user context filtering files for the data source. For the format of the file, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/s3-acl.html">Access control for S3 data sources</a>.</p>
        pub fn set_access_control_list_configuration(
            mut self,
            input: std::option::Option<crate::model::AccessControlListConfiguration>,
        ) -> Self {
            self.access_control_list_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`S3DataSourceConfiguration`](crate::model::S3DataSourceConfiguration).
        pub fn build(self) -> crate::model::S3DataSourceConfiguration {
            crate::model::S3DataSourceConfiguration {
                bucket_name: self.bucket_name,
                inclusion_prefixes: self.inclusion_prefixes,
                inclusion_patterns: self.inclusion_patterns,
                exclusion_patterns: self.exclusion_patterns,
                documents_metadata_configuration: self.documents_metadata_configuration,
                access_control_list_configuration: self.access_control_list_configuration,
            }
        }
    }
}
impl S3DataSourceConfiguration {
    /// Creates a new builder-style object to manufacture [`S3DataSourceConfiguration`](crate::model::S3DataSourceConfiguration).
    pub fn builder() -> crate::model::s3_data_source_configuration::Builder {
        crate::model::s3_data_source_configuration::Builder::default()
    }
}

/// <p>Access Control List files for the documents in a data source. For the format of the file, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/s3-acl.html">Access control for S3 data sources</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccessControlListConfiguration {
    /// <p>Path to the Amazon S3 bucket that contains the ACL files.</p>
    #[doc(hidden)]
    pub key_path: std::option::Option<std::string::String>,
}
impl AccessControlListConfiguration {
    /// <p>Path to the Amazon S3 bucket that contains the ACL files.</p>
    pub fn key_path(&self) -> std::option::Option<&str> {
        self.key_path.as_deref()
    }
}
/// See [`AccessControlListConfiguration`](crate::model::AccessControlListConfiguration).
pub mod access_control_list_configuration {

    /// A builder for [`AccessControlListConfiguration`](crate::model::AccessControlListConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Path to the Amazon S3 bucket that contains the ACL files.</p>
        pub fn key_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_path = Some(input.into());
            self
        }
        /// <p>Path to the Amazon S3 bucket that contains the ACL files.</p>
        pub fn set_key_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_path = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessControlListConfiguration`](crate::model::AccessControlListConfiguration).
        pub fn build(self) -> crate::model::AccessControlListConfiguration {
            crate::model::AccessControlListConfiguration {
                key_path: self.key_path,
            }
        }
    }
}
impl AccessControlListConfiguration {
    /// Creates a new builder-style object to manufacture [`AccessControlListConfiguration`](crate::model::AccessControlListConfiguration).
    pub fn builder() -> crate::model::access_control_list_configuration::Builder {
        crate::model::access_control_list_configuration::Builder::default()
    }
}

/// <p>Document metadata files that contain information such as the document access control information, source URI, document author, and custom attributes. Each metadata file contains metadata about a single document.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DocumentsMetadataConfiguration {
    /// <p>A prefix used to filter metadata configuration files in the Amazon Web Services S3 bucket. The S3 bucket might contain multiple metadata files. Use <code>S3Prefix</code> to include only the desired metadata files.</p>
    #[doc(hidden)]
    pub s3_prefix: std::option::Option<std::string::String>,
}
impl DocumentsMetadataConfiguration {
    /// <p>A prefix used to filter metadata configuration files in the Amazon Web Services S3 bucket. The S3 bucket might contain multiple metadata files. Use <code>S3Prefix</code> to include only the desired metadata files.</p>
    pub fn s3_prefix(&self) -> std::option::Option<&str> {
        self.s3_prefix.as_deref()
    }
}
/// See [`DocumentsMetadataConfiguration`](crate::model::DocumentsMetadataConfiguration).
pub mod documents_metadata_configuration {

    /// A builder for [`DocumentsMetadataConfiguration`](crate::model::DocumentsMetadataConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A prefix used to filter metadata configuration files in the Amazon Web Services S3 bucket. The S3 bucket might contain multiple metadata files. Use <code>S3Prefix</code> to include only the desired metadata files.</p>
        pub fn s3_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_prefix = Some(input.into());
            self
        }
        /// <p>A prefix used to filter metadata configuration files in the Amazon Web Services S3 bucket. The S3 bucket might contain multiple metadata files. Use <code>S3Prefix</code> to include only the desired metadata files.</p>
        pub fn set_s3_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentsMetadataConfiguration`](crate::model::DocumentsMetadataConfiguration).
        pub fn build(self) -> crate::model::DocumentsMetadataConfiguration {
            crate::model::DocumentsMetadataConfiguration {
                s3_prefix: self.s3_prefix,
            }
        }
    }
}
impl DocumentsMetadataConfiguration {
    /// Creates a new builder-style object to manufacture [`DocumentsMetadataConfiguration`](crate::model::DocumentsMetadataConfiguration).
    pub fn builder() -> crate::model::documents_metadata_configuration::Builder {
        crate::model::documents_metadata_configuration::Builder::default()
    }
}

/// <p> Information to define the hierarchy for which documents users should have access to. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HierarchicalPrincipal {
    /// <p>A list of <a href="https://docs.aws.amazon.com/kendra/latest/dg/API_Principal.html">principal</a> lists that define the hierarchy for which documents users should have access to. Each hierarchical list specifies which user or group has allow or deny access for each document.</p>
    #[doc(hidden)]
    pub principal_list: std::option::Option<std::vec::Vec<crate::model::Principal>>,
}
impl HierarchicalPrincipal {
    /// <p>A list of <a href="https://docs.aws.amazon.com/kendra/latest/dg/API_Principal.html">principal</a> lists that define the hierarchy for which documents users should have access to. Each hierarchical list specifies which user or group has allow or deny access for each document.</p>
    pub fn principal_list(&self) -> std::option::Option<&[crate::model::Principal]> {
        self.principal_list.as_deref()
    }
}
/// See [`HierarchicalPrincipal`](crate::model::HierarchicalPrincipal).
pub mod hierarchical_principal {

    /// A builder for [`HierarchicalPrincipal`](crate::model::HierarchicalPrincipal).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) principal_list: std::option::Option<std::vec::Vec<crate::model::Principal>>,
    }
    impl Builder {
        /// Appends an item to `principal_list`.
        ///
        /// To override the contents of this collection use [`set_principal_list`](Self::set_principal_list).
        ///
        /// <p>A list of <a href="https://docs.aws.amazon.com/kendra/latest/dg/API_Principal.html">principal</a> lists that define the hierarchy for which documents users should have access to. Each hierarchical list specifies which user or group has allow or deny access for each document.</p>
        pub fn principal_list(mut self, input: crate::model::Principal) -> Self {
            let mut v = self.principal_list.unwrap_or_default();
            v.push(input);
            self.principal_list = Some(v);
            self
        }
        /// <p>A list of <a href="https://docs.aws.amazon.com/kendra/latest/dg/API_Principal.html">principal</a> lists that define the hierarchy for which documents users should have access to. Each hierarchical list specifies which user or group has allow or deny access for each document.</p>
        pub fn set_principal_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Principal>>,
        ) -> Self {
            self.principal_list = input;
            self
        }
        /// Consumes the builder and constructs a [`HierarchicalPrincipal`](crate::model::HierarchicalPrincipal).
        pub fn build(self) -> crate::model::HierarchicalPrincipal {
            crate::model::HierarchicalPrincipal {
                principal_list: self.principal_list,
            }
        }
    }
}
impl HierarchicalPrincipal {
    /// Creates a new builder-style object to manufacture [`HierarchicalPrincipal`](crate::model::HierarchicalPrincipal).
    pub fn builder() -> crate::model::hierarchical_principal::Builder {
        crate::model::hierarchical_principal::Builder::default()
    }
}

/// <p>Provides user and group information for <a href="https://docs.aws.amazon.com/kendra/latest/dg/user-context-filter.html">user context filtering</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Principal {
    /// <p>The name of the user or group.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of principal.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::PrincipalType>,
    /// <p>Whether to allow or deny document access to the principal.</p>
    #[doc(hidden)]
    pub access: std::option::Option<crate::model::ReadAccessType>,
    /// <p>The identifier of the data source the principal should access documents from.</p>
    #[doc(hidden)]
    pub data_source_id: std::option::Option<std::string::String>,
}
impl Principal {
    /// <p>The name of the user or group.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of principal.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::PrincipalType> {
        self.r#type.as_ref()
    }
    /// <p>Whether to allow or deny document access to the principal.</p>
    pub fn access(&self) -> std::option::Option<&crate::model::ReadAccessType> {
        self.access.as_ref()
    }
    /// <p>The identifier of the data source the principal should access documents from.</p>
    pub fn data_source_id(&self) -> std::option::Option<&str> {
        self.data_source_id.as_deref()
    }
}
/// See [`Principal`](crate::model::Principal).
pub mod principal {

    /// A builder for [`Principal`](crate::model::Principal).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::PrincipalType>,
        pub(crate) access: std::option::Option<crate::model::ReadAccessType>,
        pub(crate) data_source_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the user or group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the user or group.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of principal.</p>
        pub fn r#type(mut self, input: crate::model::PrincipalType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of principal.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::PrincipalType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Whether to allow or deny document access to the principal.</p>
        pub fn access(mut self, input: crate::model::ReadAccessType) -> Self {
            self.access = Some(input);
            self
        }
        /// <p>Whether to allow or deny document access to the principal.</p>
        pub fn set_access(
            mut self,
            input: std::option::Option<crate::model::ReadAccessType>,
        ) -> Self {
            self.access = input;
            self
        }
        /// <p>The identifier of the data source the principal should access documents from.</p>
        pub fn data_source_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_source_id = Some(input.into());
            self
        }
        /// <p>The identifier of the data source the principal should access documents from.</p>
        pub fn set_data_source_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_source_id = input;
            self
        }
        /// Consumes the builder and constructs a [`Principal`](crate::model::Principal).
        pub fn build(self) -> crate::model::Principal {
            crate::model::Principal {
                name: self.name,
                r#type: self.r#type,
                access: self.access,
                data_source_id: self.data_source_id,
            }
        }
    }
}
impl Principal {
    /// Creates a new builder-style object to manufacture [`Principal`](crate::model::Principal).
    pub fn builder() -> crate::model::principal::Builder {
        crate::model::principal::Builder::default()
    }
}

/// When writing a match expression against `ReadAccessType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let readaccesstype = unimplemented!();
/// match readaccesstype {
///     ReadAccessType::Allow => { /* ... */ },
///     ReadAccessType::Deny => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `readaccesstype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReadAccessType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReadAccessType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReadAccessType::NewFeature` is defined.
/// Specifically, when `readaccesstype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReadAccessType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReadAccessType {
    #[allow(missing_docs)] // documentation missing in model
    Allow,
    #[allow(missing_docs)] // documentation missing in model
    Deny,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReadAccessType {
    fn from(s: &str) -> Self {
        match s {
            "ALLOW" => ReadAccessType::Allow,
            "DENY" => ReadAccessType::Deny,
            other => ReadAccessType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ReadAccessType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReadAccessType::from(s))
    }
}
impl ReadAccessType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReadAccessType::Allow => "ALLOW",
            ReadAccessType::Deny => "DENY",
            ReadAccessType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALLOW", "DENY"]
    }
}
impl AsRef<str> for ReadAccessType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PrincipalType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let principaltype = unimplemented!();
/// match principaltype {
///     PrincipalType::Group => { /* ... */ },
///     PrincipalType::User => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `principaltype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PrincipalType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PrincipalType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PrincipalType::NewFeature` is defined.
/// Specifically, when `principaltype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PrincipalType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PrincipalType {
    #[allow(missing_docs)] // documentation missing in model
    Group,
    #[allow(missing_docs)] // documentation missing in model
    User,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PrincipalType {
    fn from(s: &str) -> Self {
        match s {
            "GROUP" => PrincipalType::Group,
            "USER" => PrincipalType::User,
            other => PrincipalType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PrincipalType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PrincipalType::from(s))
    }
}
impl PrincipalType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PrincipalType::Group => "GROUP",
            PrincipalType::User => "USER",
            PrincipalType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["GROUP", "USER"]
    }
}
impl AsRef<str> for PrincipalType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A list of key/value pairs that identify an index, FAQ, or data source. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Tag {
    /// <p>The key for the tag. Keys are not case sensitive and must be unique for the index, FAQ, or data source.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The value associated with the tag. The value may be an empty string but it can't be null.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>The key for the tag. Keys are not case sensitive and must be unique for the index, FAQ, or data source.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value associated with the tag. The value may be an empty string but it can't be null.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`Tag`](crate::model::Tag).
pub mod tag {

    /// A builder for [`Tag`](crate::model::Tag).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key for the tag. Keys are not case sensitive and must be unique for the index, FAQ, or data source.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The key for the tag. Keys are not case sensitive and must be unique for the index, FAQ, or data source.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value associated with the tag. The value may be an empty string but it can't be null.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value associated with the tag. The value may be an empty string but it can't be null.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag).
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag).
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>Provides feedback on how relevant a document is to a search. Your application uses the <code>SubmitFeedback</code> API to provide relevance information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RelevanceFeedback {
    /// <p>The identifier of the search result that the user provided relevance feedback for.</p>
    #[doc(hidden)]
    pub result_id: std::option::Option<std::string::String>,
    /// <p>Whether to document was relevant or not relevant to the search.</p>
    #[doc(hidden)]
    pub relevance_value: std::option::Option<crate::model::RelevanceType>,
}
impl RelevanceFeedback {
    /// <p>The identifier of the search result that the user provided relevance feedback for.</p>
    pub fn result_id(&self) -> std::option::Option<&str> {
        self.result_id.as_deref()
    }
    /// <p>Whether to document was relevant or not relevant to the search.</p>
    pub fn relevance_value(&self) -> std::option::Option<&crate::model::RelevanceType> {
        self.relevance_value.as_ref()
    }
}
/// See [`RelevanceFeedback`](crate::model::RelevanceFeedback).
pub mod relevance_feedback {

    /// A builder for [`RelevanceFeedback`](crate::model::RelevanceFeedback).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) result_id: std::option::Option<std::string::String>,
        pub(crate) relevance_value: std::option::Option<crate::model::RelevanceType>,
    }
    impl Builder {
        /// <p>The identifier of the search result that the user provided relevance feedback for.</p>
        pub fn result_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.result_id = Some(input.into());
            self
        }
        /// <p>The identifier of the search result that the user provided relevance feedback for.</p>
        pub fn set_result_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.result_id = input;
            self
        }
        /// <p>Whether to document was relevant or not relevant to the search.</p>
        pub fn relevance_value(mut self, input: crate::model::RelevanceType) -> Self {
            self.relevance_value = Some(input);
            self
        }
        /// <p>Whether to document was relevant or not relevant to the search.</p>
        pub fn set_relevance_value(
            mut self,
            input: std::option::Option<crate::model::RelevanceType>,
        ) -> Self {
            self.relevance_value = input;
            self
        }
        /// Consumes the builder and constructs a [`RelevanceFeedback`](crate::model::RelevanceFeedback).
        pub fn build(self) -> crate::model::RelevanceFeedback {
            crate::model::RelevanceFeedback {
                result_id: self.result_id,
                relevance_value: self.relevance_value,
            }
        }
    }
}
impl RelevanceFeedback {
    /// Creates a new builder-style object to manufacture [`RelevanceFeedback`](crate::model::RelevanceFeedback).
    pub fn builder() -> crate::model::relevance_feedback::Builder {
        crate::model::relevance_feedback::Builder::default()
    }
}

/// When writing a match expression against `RelevanceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let relevancetype = unimplemented!();
/// match relevancetype {
///     RelevanceType::NotRelevant => { /* ... */ },
///     RelevanceType::Relevant => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `relevancetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RelevanceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RelevanceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RelevanceType::NewFeature` is defined.
/// Specifically, when `relevancetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RelevanceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RelevanceType {
    #[allow(missing_docs)] // documentation missing in model
    NotRelevant,
    #[allow(missing_docs)] // documentation missing in model
    Relevant,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RelevanceType {
    fn from(s: &str) -> Self {
        match s {
            "NOT_RELEVANT" => RelevanceType::NotRelevant,
            "RELEVANT" => RelevanceType::Relevant,
            other => RelevanceType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for RelevanceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RelevanceType::from(s))
    }
}
impl RelevanceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RelevanceType::NotRelevant => "NOT_RELEVANT",
            RelevanceType::Relevant => "RELEVANT",
            RelevanceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["NOT_RELEVANT", "RELEVANT"]
    }
}
impl AsRef<str> for RelevanceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Gathers information about when a particular result was clicked by a user. Your application uses the <code>SubmitFeedback</code> API to provide click information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClickFeedback {
    /// <p>The identifier of the search result that was clicked.</p>
    #[doc(hidden)]
    pub result_id: std::option::Option<std::string::String>,
    /// <p>The Unix timestamp of the date and time that the result was clicked.</p>
    #[doc(hidden)]
    pub click_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ClickFeedback {
    /// <p>The identifier of the search result that was clicked.</p>
    pub fn result_id(&self) -> std::option::Option<&str> {
        self.result_id.as_deref()
    }
    /// <p>The Unix timestamp of the date and time that the result was clicked.</p>
    pub fn click_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.click_time.as_ref()
    }
}
/// See [`ClickFeedback`](crate::model::ClickFeedback).
pub mod click_feedback {

    /// A builder for [`ClickFeedback`](crate::model::ClickFeedback).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) result_id: std::option::Option<std::string::String>,
        pub(crate) click_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The identifier of the search result that was clicked.</p>
        pub fn result_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.result_id = Some(input.into());
            self
        }
        /// <p>The identifier of the search result that was clicked.</p>
        pub fn set_result_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.result_id = input;
            self
        }
        /// <p>The Unix timestamp of the date and time that the result was clicked.</p>
        pub fn click_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.click_time = Some(input);
            self
        }
        /// <p>The Unix timestamp of the date and time that the result was clicked.</p>
        pub fn set_click_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.click_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ClickFeedback`](crate::model::ClickFeedback).
        pub fn build(self) -> crate::model::ClickFeedback {
            crate::model::ClickFeedback {
                result_id: self.result_id,
                click_time: self.click_time,
            }
        }
    }
}
impl ClickFeedback {
    /// Creates a new builder-style object to manufacture [`ClickFeedback`](crate::model::ClickFeedback).
    pub fn builder() -> crate::model::click_feedback::Builder {
        crate::model::click_feedback::Builder::default()
    }
}

/// <p>A query with suggested spell corrections. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SpellCorrectedQuery {
    /// <p>The query with the suggested spell corrections.</p>
    #[doc(hidden)]
    pub suggested_query_text: std::option::Option<std::string::String>,
    /// <p>The corrected misspelled word or words in a query.</p>
    #[doc(hidden)]
    pub corrections: std::option::Option<std::vec::Vec<crate::model::Correction>>,
}
impl SpellCorrectedQuery {
    /// <p>The query with the suggested spell corrections.</p>
    pub fn suggested_query_text(&self) -> std::option::Option<&str> {
        self.suggested_query_text.as_deref()
    }
    /// <p>The corrected misspelled word or words in a query.</p>
    pub fn corrections(&self) -> std::option::Option<&[crate::model::Correction]> {
        self.corrections.as_deref()
    }
}
/// See [`SpellCorrectedQuery`](crate::model::SpellCorrectedQuery).
pub mod spell_corrected_query {

    /// A builder for [`SpellCorrectedQuery`](crate::model::SpellCorrectedQuery).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) suggested_query_text: std::option::Option<std::string::String>,
        pub(crate) corrections: std::option::Option<std::vec::Vec<crate::model::Correction>>,
    }
    impl Builder {
        /// <p>The query with the suggested spell corrections.</p>
        pub fn suggested_query_text(mut self, input: impl Into<std::string::String>) -> Self {
            self.suggested_query_text = Some(input.into());
            self
        }
        /// <p>The query with the suggested spell corrections.</p>
        pub fn set_suggested_query_text(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.suggested_query_text = input;
            self
        }
        /// Appends an item to `corrections`.
        ///
        /// To override the contents of this collection use [`set_corrections`](Self::set_corrections).
        ///
        /// <p>The corrected misspelled word or words in a query.</p>
        pub fn corrections(mut self, input: crate::model::Correction) -> Self {
            let mut v = self.corrections.unwrap_or_default();
            v.push(input);
            self.corrections = Some(v);
            self
        }
        /// <p>The corrected misspelled word or words in a query.</p>
        pub fn set_corrections(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Correction>>,
        ) -> Self {
            self.corrections = input;
            self
        }
        /// Consumes the builder and constructs a [`SpellCorrectedQuery`](crate::model::SpellCorrectedQuery).
        pub fn build(self) -> crate::model::SpellCorrectedQuery {
            crate::model::SpellCorrectedQuery {
                suggested_query_text: self.suggested_query_text,
                corrections: self.corrections,
            }
        }
    }
}
impl SpellCorrectedQuery {
    /// Creates a new builder-style object to manufacture [`SpellCorrectedQuery`](crate::model::SpellCorrectedQuery).
    pub fn builder() -> crate::model::spell_corrected_query::Builder {
        crate::model::spell_corrected_query::Builder::default()
    }
}

/// <p>A corrected misspelled word in a query.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Correction {
    /// <p>The zero-based location in the response string or text where the corrected word starts.</p>
    #[doc(hidden)]
    pub begin_offset: std::option::Option<i32>,
    /// <p>The zero-based location in the response string or text where the corrected word ends.</p>
    #[doc(hidden)]
    pub end_offset: std::option::Option<i32>,
    /// <p>The string or text of a misspelled word in a query.</p>
    #[doc(hidden)]
    pub term: std::option::Option<std::string::String>,
    /// <p>The string or text of a corrected misspelled word in a query.</p>
    #[doc(hidden)]
    pub corrected_term: std::option::Option<std::string::String>,
}
impl Correction {
    /// <p>The zero-based location in the response string or text where the corrected word starts.</p>
    pub fn begin_offset(&self) -> std::option::Option<i32> {
        self.begin_offset
    }
    /// <p>The zero-based location in the response string or text where the corrected word ends.</p>
    pub fn end_offset(&self) -> std::option::Option<i32> {
        self.end_offset
    }
    /// <p>The string or text of a misspelled word in a query.</p>
    pub fn term(&self) -> std::option::Option<&str> {
        self.term.as_deref()
    }
    /// <p>The string or text of a corrected misspelled word in a query.</p>
    pub fn corrected_term(&self) -> std::option::Option<&str> {
        self.corrected_term.as_deref()
    }
}
/// See [`Correction`](crate::model::Correction).
pub mod correction {

    /// A builder for [`Correction`](crate::model::Correction).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) begin_offset: std::option::Option<i32>,
        pub(crate) end_offset: std::option::Option<i32>,
        pub(crate) term: std::option::Option<std::string::String>,
        pub(crate) corrected_term: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The zero-based location in the response string or text where the corrected word starts.</p>
        pub fn begin_offset(mut self, input: i32) -> Self {
            self.begin_offset = Some(input);
            self
        }
        /// <p>The zero-based location in the response string or text where the corrected word starts.</p>
        pub fn set_begin_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.begin_offset = input;
            self
        }
        /// <p>The zero-based location in the response string or text where the corrected word ends.</p>
        pub fn end_offset(mut self, input: i32) -> Self {
            self.end_offset = Some(input);
            self
        }
        /// <p>The zero-based location in the response string or text where the corrected word ends.</p>
        pub fn set_end_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.end_offset = input;
            self
        }
        /// <p>The string or text of a misspelled word in a query.</p>
        pub fn term(mut self, input: impl Into<std::string::String>) -> Self {
            self.term = Some(input.into());
            self
        }
        /// <p>The string or text of a misspelled word in a query.</p>
        pub fn set_term(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.term = input;
            self
        }
        /// <p>The string or text of a corrected misspelled word in a query.</p>
        pub fn corrected_term(mut self, input: impl Into<std::string::String>) -> Self {
            self.corrected_term = Some(input.into());
            self
        }
        /// <p>The string or text of a corrected misspelled word in a query.</p>
        pub fn set_corrected_term(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.corrected_term = input;
            self
        }
        /// Consumes the builder and constructs a [`Correction`](crate::model::Correction).
        pub fn build(self) -> crate::model::Correction {
            crate::model::Correction {
                begin_offset: self.begin_offset,
                end_offset: self.end_offset,
                term: self.term,
                corrected_term: self.corrected_term,
            }
        }
    }
}
impl Correction {
    /// Creates a new builder-style object to manufacture [`Correction`](crate::model::Correction).
    pub fn builder() -> crate::model::correction::Builder {
        crate::model::correction::Builder::default()
    }
}

/// <p>The warning code and message that explains a problem with a query.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Warning {
    /// <p>The message that explains the problem with the query.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The code used to show the type of warning for the query.</p>
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::WarningCode>,
}
impl Warning {
    /// <p>The message that explains the problem with the query.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>The code used to show the type of warning for the query.</p>
    pub fn code(&self) -> std::option::Option<&crate::model::WarningCode> {
        self.code.as_ref()
    }
}
/// See [`Warning`](crate::model::Warning).
pub mod warning {

    /// A builder for [`Warning`](crate::model::Warning).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<crate::model::WarningCode>,
    }
    impl Builder {
        /// <p>The message that explains the problem with the query.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that explains the problem with the query.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The code used to show the type of warning for the query.</p>
        pub fn code(mut self, input: crate::model::WarningCode) -> Self {
            self.code = Some(input);
            self
        }
        /// <p>The code used to show the type of warning for the query.</p>
        pub fn set_code(mut self, input: std::option::Option<crate::model::WarningCode>) -> Self {
            self.code = input;
            self
        }
        /// Consumes the builder and constructs a [`Warning`](crate::model::Warning).
        pub fn build(self) -> crate::model::Warning {
            crate::model::Warning {
                message: self.message,
                code: self.code,
            }
        }
    }
}
impl Warning {
    /// Creates a new builder-style object to manufacture [`Warning`](crate::model::Warning).
    pub fn builder() -> crate::model::warning::Builder {
        crate::model::warning::Builder::default()
    }
}

/// When writing a match expression against `WarningCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let warningcode = unimplemented!();
/// match warningcode {
///     WarningCode::QueryLanguageInvalidSyntax => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `warningcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WarningCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WarningCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WarningCode::NewFeature` is defined.
/// Specifically, when `warningcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WarningCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WarningCode {
    #[allow(missing_docs)] // documentation missing in model
    QueryLanguageInvalidSyntax,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WarningCode {
    fn from(s: &str) -> Self {
        match s {
            "QUERY_LANGUAGE_INVALID_SYNTAX" => WarningCode::QueryLanguageInvalidSyntax,
            other => WarningCode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for WarningCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WarningCode::from(s))
    }
}
impl WarningCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WarningCode::QueryLanguageInvalidSyntax => "QUERY_LANGUAGE_INVALID_SYNTAX",
            WarningCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["QUERY_LANGUAGE_INVALID_SYNTAX"]
    }
}
impl AsRef<str> for WarningCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The facet values for the documents in the response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FacetResult {
    /// <p>The key for the facet values. This is the same as the <code>DocumentAttributeKey</code> provided in the query.</p>
    #[doc(hidden)]
    pub document_attribute_key: std::option::Option<std::string::String>,
    /// <p>The data type of the facet value. This is the same as the type defined for the index field when it was created.</p>
    #[doc(hidden)]
    pub document_attribute_value_type:
        std::option::Option<crate::model::DocumentAttributeValueType>,
    /// <p>An array of key/value pairs, where the key is the value of the attribute and the count is the number of documents that share the key value.</p>
    #[doc(hidden)]
    pub document_attribute_value_count_pairs:
        std::option::Option<std::vec::Vec<crate::model::DocumentAttributeValueCountPair>>,
}
impl FacetResult {
    /// <p>The key for the facet values. This is the same as the <code>DocumentAttributeKey</code> provided in the query.</p>
    pub fn document_attribute_key(&self) -> std::option::Option<&str> {
        self.document_attribute_key.as_deref()
    }
    /// <p>The data type of the facet value. This is the same as the type defined for the index field when it was created.</p>
    pub fn document_attribute_value_type(
        &self,
    ) -> std::option::Option<&crate::model::DocumentAttributeValueType> {
        self.document_attribute_value_type.as_ref()
    }
    /// <p>An array of key/value pairs, where the key is the value of the attribute and the count is the number of documents that share the key value.</p>
    pub fn document_attribute_value_count_pairs(
        &self,
    ) -> std::option::Option<&[crate::model::DocumentAttributeValueCountPair]> {
        self.document_attribute_value_count_pairs.as_deref()
    }
}
/// See [`FacetResult`](crate::model::FacetResult).
pub mod facet_result {

    /// A builder for [`FacetResult`](crate::model::FacetResult).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_attribute_key: std::option::Option<std::string::String>,
        pub(crate) document_attribute_value_type:
            std::option::Option<crate::model::DocumentAttributeValueType>,
        pub(crate) document_attribute_value_count_pairs:
            std::option::Option<std::vec::Vec<crate::model::DocumentAttributeValueCountPair>>,
    }
    impl Builder {
        /// <p>The key for the facet values. This is the same as the <code>DocumentAttributeKey</code> provided in the query.</p>
        pub fn document_attribute_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_attribute_key = Some(input.into());
            self
        }
        /// <p>The key for the facet values. This is the same as the <code>DocumentAttributeKey</code> provided in the query.</p>
        pub fn set_document_attribute_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_attribute_key = input;
            self
        }
        /// <p>The data type of the facet value. This is the same as the type defined for the index field when it was created.</p>
        pub fn document_attribute_value_type(
            mut self,
            input: crate::model::DocumentAttributeValueType,
        ) -> Self {
            self.document_attribute_value_type = Some(input);
            self
        }
        /// <p>The data type of the facet value. This is the same as the type defined for the index field when it was created.</p>
        pub fn set_document_attribute_value_type(
            mut self,
            input: std::option::Option<crate::model::DocumentAttributeValueType>,
        ) -> Self {
            self.document_attribute_value_type = input;
            self
        }
        /// Appends an item to `document_attribute_value_count_pairs`.
        ///
        /// To override the contents of this collection use [`set_document_attribute_value_count_pairs`](Self::set_document_attribute_value_count_pairs).
        ///
        /// <p>An array of key/value pairs, where the key is the value of the attribute and the count is the number of documents that share the key value.</p>
        pub fn document_attribute_value_count_pairs(
            mut self,
            input: crate::model::DocumentAttributeValueCountPair,
        ) -> Self {
            let mut v = self
                .document_attribute_value_count_pairs
                .unwrap_or_default();
            v.push(input);
            self.document_attribute_value_count_pairs = Some(v);
            self
        }
        /// <p>An array of key/value pairs, where the key is the value of the attribute and the count is the number of documents that share the key value.</p>
        pub fn set_document_attribute_value_count_pairs(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::DocumentAttributeValueCountPair>,
            >,
        ) -> Self {
            self.document_attribute_value_count_pairs = input;
            self
        }
        /// Consumes the builder and constructs a [`FacetResult`](crate::model::FacetResult).
        pub fn build(self) -> crate::model::FacetResult {
            crate::model::FacetResult {
                document_attribute_key: self.document_attribute_key,
                document_attribute_value_type: self.document_attribute_value_type,
                document_attribute_value_count_pairs: self.document_attribute_value_count_pairs,
            }
        }
    }
}
impl FacetResult {
    /// Creates a new builder-style object to manufacture [`FacetResult`](crate::model::FacetResult).
    pub fn builder() -> crate::model::facet_result::Builder {
        crate::model::facet_result::Builder::default()
    }
}

/// <p>Provides the count of documents that match a particular attribute when doing a faceted search.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DocumentAttributeValueCountPair {
    /// <p>The value of the attribute. For example, "HR".</p>
    #[doc(hidden)]
    pub document_attribute_value: std::option::Option<crate::model::DocumentAttributeValue>,
    /// <p>The number of documents in the response that have the attribute value for the key.</p>
    #[doc(hidden)]
    pub count: std::option::Option<i32>,
    /// <p>Contains the results of a document attribute that is a nested facet. A <code>FacetResult</code> contains the counts for each facet nested within a facet.</p>
    /// <p>For example, the document attribute or facet "Department" includes a value called "Engineering". In addition, the document attribute or facet "SubDepartment" includes the values "Frontend" and "Backend" for documents assigned to "Engineering". You can display nested facets in the search results so that documents can be searched not only by department but also by a sub department within a department. The counts for documents that belong to "Frontend" and "Backend" within "Engineering" are returned for a query.</p>
    #[doc(hidden)]
    pub facet_results: std::option::Option<std::vec::Vec<crate::model::FacetResult>>,
}
impl DocumentAttributeValueCountPair {
    /// <p>The value of the attribute. For example, "HR".</p>
    pub fn document_attribute_value(
        &self,
    ) -> std::option::Option<&crate::model::DocumentAttributeValue> {
        self.document_attribute_value.as_ref()
    }
    /// <p>The number of documents in the response that have the attribute value for the key.</p>
    pub fn count(&self) -> std::option::Option<i32> {
        self.count
    }
    /// <p>Contains the results of a document attribute that is a nested facet. A <code>FacetResult</code> contains the counts for each facet nested within a facet.</p>
    /// <p>For example, the document attribute or facet "Department" includes a value called "Engineering". In addition, the document attribute or facet "SubDepartment" includes the values "Frontend" and "Backend" for documents assigned to "Engineering". You can display nested facets in the search results so that documents can be searched not only by department but also by a sub department within a department. The counts for documents that belong to "Frontend" and "Backend" within "Engineering" are returned for a query.</p>
    pub fn facet_results(&self) -> std::option::Option<&[crate::model::FacetResult]> {
        self.facet_results.as_deref()
    }
}
/// See [`DocumentAttributeValueCountPair`](crate::model::DocumentAttributeValueCountPair).
pub mod document_attribute_value_count_pair {

    /// A builder for [`DocumentAttributeValueCountPair`](crate::model::DocumentAttributeValueCountPair).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_attribute_value:
            std::option::Option<crate::model::DocumentAttributeValue>,
        pub(crate) count: std::option::Option<i32>,
        pub(crate) facet_results: std::option::Option<std::vec::Vec<crate::model::FacetResult>>,
    }
    impl Builder {
        /// <p>The value of the attribute. For example, "HR".</p>
        pub fn document_attribute_value(
            mut self,
            input: crate::model::DocumentAttributeValue,
        ) -> Self {
            self.document_attribute_value = Some(input);
            self
        }
        /// <p>The value of the attribute. For example, "HR".</p>
        pub fn set_document_attribute_value(
            mut self,
            input: std::option::Option<crate::model::DocumentAttributeValue>,
        ) -> Self {
            self.document_attribute_value = input;
            self
        }
        /// <p>The number of documents in the response that have the attribute value for the key.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>The number of documents in the response that have the attribute value for the key.</p>
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// Appends an item to `facet_results`.
        ///
        /// To override the contents of this collection use [`set_facet_results`](Self::set_facet_results).
        ///
        /// <p>Contains the results of a document attribute that is a nested facet. A <code>FacetResult</code> contains the counts for each facet nested within a facet.</p>
        /// <p>For example, the document attribute or facet "Department" includes a value called "Engineering". In addition, the document attribute or facet "SubDepartment" includes the values "Frontend" and "Backend" for documents assigned to "Engineering". You can display nested facets in the search results so that documents can be searched not only by department but also by a sub department within a department. The counts for documents that belong to "Frontend" and "Backend" within "Engineering" are returned for a query.</p>
        pub fn facet_results(mut self, input: crate::model::FacetResult) -> Self {
            let mut v = self.facet_results.unwrap_or_default();
            v.push(input);
            self.facet_results = Some(v);
            self
        }
        /// <p>Contains the results of a document attribute that is a nested facet. A <code>FacetResult</code> contains the counts for each facet nested within a facet.</p>
        /// <p>For example, the document attribute or facet "Department" includes a value called "Engineering". In addition, the document attribute or facet "SubDepartment" includes the values "Frontend" and "Backend" for documents assigned to "Engineering". You can display nested facets in the search results so that documents can be searched not only by department but also by a sub department within a department. The counts for documents that belong to "Frontend" and "Backend" within "Engineering" are returned for a query.</p>
        pub fn set_facet_results(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FacetResult>>,
        ) -> Self {
            self.facet_results = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentAttributeValueCountPair`](crate::model::DocumentAttributeValueCountPair).
        pub fn build(self) -> crate::model::DocumentAttributeValueCountPair {
            crate::model::DocumentAttributeValueCountPair {
                document_attribute_value: self.document_attribute_value,
                count: self.count,
                facet_results: self.facet_results,
            }
        }
    }
}
impl DocumentAttributeValueCountPair {
    /// Creates a new builder-style object to manufacture [`DocumentAttributeValueCountPair`](crate::model::DocumentAttributeValueCountPair).
    pub fn builder() -> crate::model::document_attribute_value_count_pair::Builder {
        crate::model::document_attribute_value_count_pair::Builder::default()
    }
}

/// <p>A single query result.</p>
/// <p>A query result contains information about a document returned by the query. This includes the original location of the document, a list of attributes assigned to the document, and relevant text from the document that satisfies the query.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QueryResultItem {
    /// <p>The identifier for the query result.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The type of document within the response. For example, a response could include a question-answer that's relevant to the query.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::QueryResultType>,
    /// <p>If the <code>Type</code> of document within the response is <code>ANSWER</code>, then it is either a <code>TABLE</code> answer or <code>TEXT</code> answer. If it's a table answer, a table excerpt is returned in <code>TableExcerpt</code>. If it's a text answer, a text excerpt is returned in <code>DocumentExcerpt</code>.</p>
    #[doc(hidden)]
    pub format: std::option::Option<crate::model::QueryResultFormat>,
    /// <p>One or more additional attributes associated with the query result.</p>
    #[doc(hidden)]
    pub additional_attributes:
        std::option::Option<std::vec::Vec<crate::model::AdditionalResultAttribute>>,
    /// <p>The identifier for the document.</p>
    #[doc(hidden)]
    pub document_id: std::option::Option<std::string::String>,
    /// <p>The title of the document. Contains the text of the title and information for highlighting the relevant terms in the title.</p>
    #[doc(hidden)]
    pub document_title: std::option::Option<crate::model::TextWithHighlights>,
    /// <p>An extract of the text in the document. Contains information about highlighting the relevant terms in the excerpt.</p>
    #[doc(hidden)]
    pub document_excerpt: std::option::Option<crate::model::TextWithHighlights>,
    /// <p>The URI of the original location of the document.</p>
    #[doc(hidden)]
    pub document_uri: std::option::Option<std::string::String>,
    /// <p>An array of document attributes assigned to a document in the search results. For example, the document author (<code>_author</code>) or the source URI (<code>_source_uri</code>) of the document.</p>
    #[doc(hidden)]
    pub document_attributes: std::option::Option<std::vec::Vec<crate::model::DocumentAttribute>>,
    /// <p>Indicates the confidence that Amazon Kendra has that a result matches the query that you provided. Each result is placed into a bin that indicates the confidence, <code>VERY_HIGH</code>, <code>HIGH</code>, <code>MEDIUM</code> and <code>LOW</code>. You can use the score to determine if a response meets the confidence needed for your application.</p>
    /// <p>The field is only set to <code>LOW</code> when the <code>Type</code> field is set to <code>DOCUMENT</code> and Amazon Kendra is not confident that the result matches the query.</p>
    #[doc(hidden)]
    pub score_attributes: std::option::Option<crate::model::ScoreAttributes>,
    /// <p>A token that identifies a particular result from a particular query. Use this token to provide click-through feedback for the result. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/submitting-feedback.html">Submitting feedback </a>.</p>
    #[doc(hidden)]
    pub feedback_token: std::option::Option<std::string::String>,
    /// <p>An excerpt from a table within a document.</p>
    #[doc(hidden)]
    pub table_excerpt: std::option::Option<crate::model::TableExcerpt>,
}
impl QueryResultItem {
    /// <p>The identifier for the query result.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The type of document within the response. For example, a response could include a question-answer that's relevant to the query.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::QueryResultType> {
        self.r#type.as_ref()
    }
    /// <p>If the <code>Type</code> of document within the response is <code>ANSWER</code>, then it is either a <code>TABLE</code> answer or <code>TEXT</code> answer. If it's a table answer, a table excerpt is returned in <code>TableExcerpt</code>. If it's a text answer, a text excerpt is returned in <code>DocumentExcerpt</code>.</p>
    pub fn format(&self) -> std::option::Option<&crate::model::QueryResultFormat> {
        self.format.as_ref()
    }
    /// <p>One or more additional attributes associated with the query result.</p>
    pub fn additional_attributes(
        &self,
    ) -> std::option::Option<&[crate::model::AdditionalResultAttribute]> {
        self.additional_attributes.as_deref()
    }
    /// <p>The identifier for the document.</p>
    pub fn document_id(&self) -> std::option::Option<&str> {
        self.document_id.as_deref()
    }
    /// <p>The title of the document. Contains the text of the title and information for highlighting the relevant terms in the title.</p>
    pub fn document_title(&self) -> std::option::Option<&crate::model::TextWithHighlights> {
        self.document_title.as_ref()
    }
    /// <p>An extract of the text in the document. Contains information about highlighting the relevant terms in the excerpt.</p>
    pub fn document_excerpt(&self) -> std::option::Option<&crate::model::TextWithHighlights> {
        self.document_excerpt.as_ref()
    }
    /// <p>The URI of the original location of the document.</p>
    pub fn document_uri(&self) -> std::option::Option<&str> {
        self.document_uri.as_deref()
    }
    /// <p>An array of document attributes assigned to a document in the search results. For example, the document author (<code>_author</code>) or the source URI (<code>_source_uri</code>) of the document.</p>
    pub fn document_attributes(&self) -> std::option::Option<&[crate::model::DocumentAttribute]> {
        self.document_attributes.as_deref()
    }
    /// <p>Indicates the confidence that Amazon Kendra has that a result matches the query that you provided. Each result is placed into a bin that indicates the confidence, <code>VERY_HIGH</code>, <code>HIGH</code>, <code>MEDIUM</code> and <code>LOW</code>. You can use the score to determine if a response meets the confidence needed for your application.</p>
    /// <p>The field is only set to <code>LOW</code> when the <code>Type</code> field is set to <code>DOCUMENT</code> and Amazon Kendra is not confident that the result matches the query.</p>
    pub fn score_attributes(&self) -> std::option::Option<&crate::model::ScoreAttributes> {
        self.score_attributes.as_ref()
    }
    /// <p>A token that identifies a particular result from a particular query. Use this token to provide click-through feedback for the result. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/submitting-feedback.html">Submitting feedback </a>.</p>
    pub fn feedback_token(&self) -> std::option::Option<&str> {
        self.feedback_token.as_deref()
    }
    /// <p>An excerpt from a table within a document.</p>
    pub fn table_excerpt(&self) -> std::option::Option<&crate::model::TableExcerpt> {
        self.table_excerpt.as_ref()
    }
}
/// See [`QueryResultItem`](crate::model::QueryResultItem).
pub mod query_result_item {

    /// A builder for [`QueryResultItem`](crate::model::QueryResultItem).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::QueryResultType>,
        pub(crate) format: std::option::Option<crate::model::QueryResultFormat>,
        pub(crate) additional_attributes:
            std::option::Option<std::vec::Vec<crate::model::AdditionalResultAttribute>>,
        pub(crate) document_id: std::option::Option<std::string::String>,
        pub(crate) document_title: std::option::Option<crate::model::TextWithHighlights>,
        pub(crate) document_excerpt: std::option::Option<crate::model::TextWithHighlights>,
        pub(crate) document_uri: std::option::Option<std::string::String>,
        pub(crate) document_attributes:
            std::option::Option<std::vec::Vec<crate::model::DocumentAttribute>>,
        pub(crate) score_attributes: std::option::Option<crate::model::ScoreAttributes>,
        pub(crate) feedback_token: std::option::Option<std::string::String>,
        pub(crate) table_excerpt: std::option::Option<crate::model::TableExcerpt>,
    }
    impl Builder {
        /// <p>The identifier for the query result.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier for the query result.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The type of document within the response. For example, a response could include a question-answer that's relevant to the query.</p>
        pub fn r#type(mut self, input: crate::model::QueryResultType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of document within the response. For example, a response could include a question-answer that's relevant to the query.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::QueryResultType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>If the <code>Type</code> of document within the response is <code>ANSWER</code>, then it is either a <code>TABLE</code> answer or <code>TEXT</code> answer. If it's a table answer, a table excerpt is returned in <code>TableExcerpt</code>. If it's a text answer, a text excerpt is returned in <code>DocumentExcerpt</code>.</p>
        pub fn format(mut self, input: crate::model::QueryResultFormat) -> Self {
            self.format = Some(input);
            self
        }
        /// <p>If the <code>Type</code> of document within the response is <code>ANSWER</code>, then it is either a <code>TABLE</code> answer or <code>TEXT</code> answer. If it's a table answer, a table excerpt is returned in <code>TableExcerpt</code>. If it's a text answer, a text excerpt is returned in <code>DocumentExcerpt</code>.</p>
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::QueryResultFormat>,
        ) -> Self {
            self.format = input;
            self
        }
        /// Appends an item to `additional_attributes`.
        ///
        /// To override the contents of this collection use [`set_additional_attributes`](Self::set_additional_attributes).
        ///
        /// <p>One or more additional attributes associated with the query result.</p>
        pub fn additional_attributes(
            mut self,
            input: crate::model::AdditionalResultAttribute,
        ) -> Self {
            let mut v = self.additional_attributes.unwrap_or_default();
            v.push(input);
            self.additional_attributes = Some(v);
            self
        }
        /// <p>One or more additional attributes associated with the query result.</p>
        pub fn set_additional_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AdditionalResultAttribute>>,
        ) -> Self {
            self.additional_attributes = input;
            self
        }
        /// <p>The identifier for the document.</p>
        pub fn document_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_id = Some(input.into());
            self
        }
        /// <p>The identifier for the document.</p>
        pub fn set_document_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.document_id = input;
            self
        }
        /// <p>The title of the document. Contains the text of the title and information for highlighting the relevant terms in the title.</p>
        pub fn document_title(mut self, input: crate::model::TextWithHighlights) -> Self {
            self.document_title = Some(input);
            self
        }
        /// <p>The title of the document. Contains the text of the title and information for highlighting the relevant terms in the title.</p>
        pub fn set_document_title(
            mut self,
            input: std::option::Option<crate::model::TextWithHighlights>,
        ) -> Self {
            self.document_title = input;
            self
        }
        /// <p>An extract of the text in the document. Contains information about highlighting the relevant terms in the excerpt.</p>
        pub fn document_excerpt(mut self, input: crate::model::TextWithHighlights) -> Self {
            self.document_excerpt = Some(input);
            self
        }
        /// <p>An extract of the text in the document. Contains information about highlighting the relevant terms in the excerpt.</p>
        pub fn set_document_excerpt(
            mut self,
            input: std::option::Option<crate::model::TextWithHighlights>,
        ) -> Self {
            self.document_excerpt = input;
            self
        }
        /// <p>The URI of the original location of the document.</p>
        pub fn document_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_uri = Some(input.into());
            self
        }
        /// <p>The URI of the original location of the document.</p>
        pub fn set_document_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.document_uri = input;
            self
        }
        /// Appends an item to `document_attributes`.
        ///
        /// To override the contents of this collection use [`set_document_attributes`](Self::set_document_attributes).
        ///
        /// <p>An array of document attributes assigned to a document in the search results. For example, the document author (<code>_author</code>) or the source URI (<code>_source_uri</code>) of the document.</p>
        pub fn document_attributes(mut self, input: crate::model::DocumentAttribute) -> Self {
            let mut v = self.document_attributes.unwrap_or_default();
            v.push(input);
            self.document_attributes = Some(v);
            self
        }
        /// <p>An array of document attributes assigned to a document in the search results. For example, the document author (<code>_author</code>) or the source URI (<code>_source_uri</code>) of the document.</p>
        pub fn set_document_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DocumentAttribute>>,
        ) -> Self {
            self.document_attributes = input;
            self
        }
        /// <p>Indicates the confidence that Amazon Kendra has that a result matches the query that you provided. Each result is placed into a bin that indicates the confidence, <code>VERY_HIGH</code>, <code>HIGH</code>, <code>MEDIUM</code> and <code>LOW</code>. You can use the score to determine if a response meets the confidence needed for your application.</p>
        /// <p>The field is only set to <code>LOW</code> when the <code>Type</code> field is set to <code>DOCUMENT</code> and Amazon Kendra is not confident that the result matches the query.</p>
        pub fn score_attributes(mut self, input: crate::model::ScoreAttributes) -> Self {
            self.score_attributes = Some(input);
            self
        }
        /// <p>Indicates the confidence that Amazon Kendra has that a result matches the query that you provided. Each result is placed into a bin that indicates the confidence, <code>VERY_HIGH</code>, <code>HIGH</code>, <code>MEDIUM</code> and <code>LOW</code>. You can use the score to determine if a response meets the confidence needed for your application.</p>
        /// <p>The field is only set to <code>LOW</code> when the <code>Type</code> field is set to <code>DOCUMENT</code> and Amazon Kendra is not confident that the result matches the query.</p>
        pub fn set_score_attributes(
            mut self,
            input: std::option::Option<crate::model::ScoreAttributes>,
        ) -> Self {
            self.score_attributes = input;
            self
        }
        /// <p>A token that identifies a particular result from a particular query. Use this token to provide click-through feedback for the result. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/submitting-feedback.html">Submitting feedback </a>.</p>
        pub fn feedback_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.feedback_token = Some(input.into());
            self
        }
        /// <p>A token that identifies a particular result from a particular query. Use this token to provide click-through feedback for the result. For more information, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/submitting-feedback.html">Submitting feedback </a>.</p>
        pub fn set_feedback_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.feedback_token = input;
            self
        }
        /// <p>An excerpt from a table within a document.</p>
        pub fn table_excerpt(mut self, input: crate::model::TableExcerpt) -> Self {
            self.table_excerpt = Some(input);
            self
        }
        /// <p>An excerpt from a table within a document.</p>
        pub fn set_table_excerpt(
            mut self,
            input: std::option::Option<crate::model::TableExcerpt>,
        ) -> Self {
            self.table_excerpt = input;
            self
        }
        /// Consumes the builder and constructs a [`QueryResultItem`](crate::model::QueryResultItem).
        pub fn build(self) -> crate::model::QueryResultItem {
            crate::model::QueryResultItem {
                id: self.id,
                r#type: self.r#type,
                format: self.format,
                additional_attributes: self.additional_attributes,
                document_id: self.document_id,
                document_title: self.document_title,
                document_excerpt: self.document_excerpt,
                document_uri: self.document_uri,
                document_attributes: self.document_attributes,
                score_attributes: self.score_attributes,
                feedback_token: self.feedback_token,
                table_excerpt: self.table_excerpt,
            }
        }
    }
}
impl QueryResultItem {
    /// Creates a new builder-style object to manufacture [`QueryResultItem`](crate::model::QueryResultItem).
    pub fn builder() -> crate::model::query_result_item::Builder {
        crate::model::query_result_item::Builder::default()
    }
}

/// <p>An excerpt from a table within a document. The table excerpt displays up to five columns and three rows, depending on how many table cells are relevant to the query and how many columns are available in the original table. The top most relevant cell is displayed in the table excerpt, along with the next most relevant cells.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableExcerpt {
    /// <p>A list of rows in the table excerpt.</p>
    #[doc(hidden)]
    pub rows: std::option::Option<std::vec::Vec<crate::model::TableRow>>,
    /// <p>A count of the number of rows in the original table within the document.</p>
    #[doc(hidden)]
    pub total_number_of_rows: std::option::Option<i32>,
}
impl TableExcerpt {
    /// <p>A list of rows in the table excerpt.</p>
    pub fn rows(&self) -> std::option::Option<&[crate::model::TableRow]> {
        self.rows.as_deref()
    }
    /// <p>A count of the number of rows in the original table within the document.</p>
    pub fn total_number_of_rows(&self) -> std::option::Option<i32> {
        self.total_number_of_rows
    }
}
/// See [`TableExcerpt`](crate::model::TableExcerpt).
pub mod table_excerpt {

    /// A builder for [`TableExcerpt`](crate::model::TableExcerpt).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rows: std::option::Option<std::vec::Vec<crate::model::TableRow>>,
        pub(crate) total_number_of_rows: std::option::Option<i32>,
    }
    impl Builder {
        /// Appends an item to `rows`.
        ///
        /// To override the contents of this collection use [`set_rows`](Self::set_rows).
        ///
        /// <p>A list of rows in the table excerpt.</p>
        pub fn rows(mut self, input: crate::model::TableRow) -> Self {
            let mut v = self.rows.unwrap_or_default();
            v.push(input);
            self.rows = Some(v);
            self
        }
        /// <p>A list of rows in the table excerpt.</p>
        pub fn set_rows(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TableRow>>,
        ) -> Self {
            self.rows = input;
            self
        }
        /// <p>A count of the number of rows in the original table within the document.</p>
        pub fn total_number_of_rows(mut self, input: i32) -> Self {
            self.total_number_of_rows = Some(input);
            self
        }
        /// <p>A count of the number of rows in the original table within the document.</p>
        pub fn set_total_number_of_rows(mut self, input: std::option::Option<i32>) -> Self {
            self.total_number_of_rows = input;
            self
        }
        /// Consumes the builder and constructs a [`TableExcerpt`](crate::model::TableExcerpt).
        pub fn build(self) -> crate::model::TableExcerpt {
            crate::model::TableExcerpt {
                rows: self.rows,
                total_number_of_rows: self.total_number_of_rows,
            }
        }
    }
}
impl TableExcerpt {
    /// Creates a new builder-style object to manufacture [`TableExcerpt`](crate::model::TableExcerpt).
    pub fn builder() -> crate::model::table_excerpt::Builder {
        crate::model::table_excerpt::Builder::default()
    }
}

/// <p>Information about a row in a table excerpt.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableRow {
    /// <p>A list of table cells in a row.</p>
    #[doc(hidden)]
    pub cells: std::option::Option<std::vec::Vec<crate::model::TableCell>>,
}
impl TableRow {
    /// <p>A list of table cells in a row.</p>
    pub fn cells(&self) -> std::option::Option<&[crate::model::TableCell]> {
        self.cells.as_deref()
    }
}
/// See [`TableRow`](crate::model::TableRow).
pub mod table_row {

    /// A builder for [`TableRow`](crate::model::TableRow).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cells: std::option::Option<std::vec::Vec<crate::model::TableCell>>,
    }
    impl Builder {
        /// Appends an item to `cells`.
        ///
        /// To override the contents of this collection use [`set_cells`](Self::set_cells).
        ///
        /// <p>A list of table cells in a row.</p>
        pub fn cells(mut self, input: crate::model::TableCell) -> Self {
            let mut v = self.cells.unwrap_or_default();
            v.push(input);
            self.cells = Some(v);
            self
        }
        /// <p>A list of table cells in a row.</p>
        pub fn set_cells(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TableCell>>,
        ) -> Self {
            self.cells = input;
            self
        }
        /// Consumes the builder and constructs a [`TableRow`](crate::model::TableRow).
        pub fn build(self) -> crate::model::TableRow {
            crate::model::TableRow { cells: self.cells }
        }
    }
}
impl TableRow {
    /// Creates a new builder-style object to manufacture [`TableRow`](crate::model::TableRow).
    pub fn builder() -> crate::model::table_row::Builder {
        crate::model::table_row::Builder::default()
    }
}

/// <p>Provides information about a table cell in a table excerpt.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableCell {
    /// <p>The actual value or content within a table cell. A table cell could contain a date value of a year, or a string value of text, for example.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
    /// <p> <code>TRUE</code> if the response of the table cell is the top answer. This is the cell value or content with the highest confidence score or is the most relevant to the query.</p>
    #[doc(hidden)]
    pub top_answer: bool,
    /// <p> <code>TRUE</code> means that the table cell has a high enough confidence and is relevant to the query, so the value or content should be highlighted.</p>
    #[doc(hidden)]
    pub highlighted: bool,
    /// <p> <code>TRUE</code> means that the table cell should be treated as a header.</p>
    #[doc(hidden)]
    pub header: bool,
}
impl TableCell {
    /// <p>The actual value or content within a table cell. A table cell could contain a date value of a year, or a string value of text, for example.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p> <code>TRUE</code> if the response of the table cell is the top answer. This is the cell value or content with the highest confidence score or is the most relevant to the query.</p>
    pub fn top_answer(&self) -> bool {
        self.top_answer
    }
    /// <p> <code>TRUE</code> means that the table cell has a high enough confidence and is relevant to the query, so the value or content should be highlighted.</p>
    pub fn highlighted(&self) -> bool {
        self.highlighted
    }
    /// <p> <code>TRUE</code> means that the table cell should be treated as a header.</p>
    pub fn header(&self) -> bool {
        self.header
    }
}
/// See [`TableCell`](crate::model::TableCell).
pub mod table_cell {

    /// A builder for [`TableCell`](crate::model::TableCell).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) top_answer: std::option::Option<bool>,
        pub(crate) highlighted: std::option::Option<bool>,
        pub(crate) header: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The actual value or content within a table cell. A table cell could contain a date value of a year, or a string value of text, for example.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The actual value or content within a table cell. A table cell could contain a date value of a year, or a string value of text, for example.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p> <code>TRUE</code> if the response of the table cell is the top answer. This is the cell value or content with the highest confidence score or is the most relevant to the query.</p>
        pub fn top_answer(mut self, input: bool) -> Self {
            self.top_answer = Some(input);
            self
        }
        /// <p> <code>TRUE</code> if the response of the table cell is the top answer. This is the cell value or content with the highest confidence score or is the most relevant to the query.</p>
        pub fn set_top_answer(mut self, input: std::option::Option<bool>) -> Self {
            self.top_answer = input;
            self
        }
        /// <p> <code>TRUE</code> means that the table cell has a high enough confidence and is relevant to the query, so the value or content should be highlighted.</p>
        pub fn highlighted(mut self, input: bool) -> Self {
            self.highlighted = Some(input);
            self
        }
        /// <p> <code>TRUE</code> means that the table cell has a high enough confidence and is relevant to the query, so the value or content should be highlighted.</p>
        pub fn set_highlighted(mut self, input: std::option::Option<bool>) -> Self {
            self.highlighted = input;
            self
        }
        /// <p> <code>TRUE</code> means that the table cell should be treated as a header.</p>
        pub fn header(mut self, input: bool) -> Self {
            self.header = Some(input);
            self
        }
        /// <p> <code>TRUE</code> means that the table cell should be treated as a header.</p>
        pub fn set_header(mut self, input: std::option::Option<bool>) -> Self {
            self.header = input;
            self
        }
        /// Consumes the builder and constructs a [`TableCell`](crate::model::TableCell).
        pub fn build(self) -> crate::model::TableCell {
            crate::model::TableCell {
                value: self.value,
                top_answer: self.top_answer.unwrap_or_default(),
                highlighted: self.highlighted.unwrap_or_default(),
                header: self.header.unwrap_or_default(),
            }
        }
    }
}
impl TableCell {
    /// Creates a new builder-style object to manufacture [`TableCell`](crate::model::TableCell).
    pub fn builder() -> crate::model::table_cell::Builder {
        crate::model::table_cell::Builder::default()
    }
}

/// <p>Provides a relative ranking that indicates how confident Amazon Kendra is that the response matches the query.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ScoreAttributes {
    /// <p>A relative ranking for how well the response matches the query.</p>
    #[doc(hidden)]
    pub score_confidence: std::option::Option<crate::model::ScoreConfidence>,
}
impl ScoreAttributes {
    /// <p>A relative ranking for how well the response matches the query.</p>
    pub fn score_confidence(&self) -> std::option::Option<&crate::model::ScoreConfidence> {
        self.score_confidence.as_ref()
    }
}
/// See [`ScoreAttributes`](crate::model::ScoreAttributes).
pub mod score_attributes {

    /// A builder for [`ScoreAttributes`](crate::model::ScoreAttributes).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) score_confidence: std::option::Option<crate::model::ScoreConfidence>,
    }
    impl Builder {
        /// <p>A relative ranking for how well the response matches the query.</p>
        pub fn score_confidence(mut self, input: crate::model::ScoreConfidence) -> Self {
            self.score_confidence = Some(input);
            self
        }
        /// <p>A relative ranking for how well the response matches the query.</p>
        pub fn set_score_confidence(
            mut self,
            input: std::option::Option<crate::model::ScoreConfidence>,
        ) -> Self {
            self.score_confidence = input;
            self
        }
        /// Consumes the builder and constructs a [`ScoreAttributes`](crate::model::ScoreAttributes).
        pub fn build(self) -> crate::model::ScoreAttributes {
            crate::model::ScoreAttributes {
                score_confidence: self.score_confidence,
            }
        }
    }
}
impl ScoreAttributes {
    /// Creates a new builder-style object to manufacture [`ScoreAttributes`](crate::model::ScoreAttributes).
    pub fn builder() -> crate::model::score_attributes::Builder {
        crate::model::score_attributes::Builder::default()
    }
}

/// When writing a match expression against `ScoreConfidence`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let scoreconfidence = unimplemented!();
/// match scoreconfidence {
///     ScoreConfidence::High => { /* ... */ },
///     ScoreConfidence::Low => { /* ... */ },
///     ScoreConfidence::Medium => { /* ... */ },
///     ScoreConfidence::NotAvailable => { /* ... */ },
///     ScoreConfidence::VeryHigh => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `scoreconfidence` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ScoreConfidence::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ScoreConfidence::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ScoreConfidence::NewFeature` is defined.
/// Specifically, when `scoreconfidence` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ScoreConfidence::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// Enumeration for query score confidence.
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScoreConfidence {
    #[allow(missing_docs)] // documentation missing in model
    High,
    #[allow(missing_docs)] // documentation missing in model
    Low,
    #[allow(missing_docs)] // documentation missing in model
    Medium,
    #[allow(missing_docs)] // documentation missing in model
    NotAvailable,
    #[allow(missing_docs)] // documentation missing in model
    VeryHigh,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ScoreConfidence {
    fn from(s: &str) -> Self {
        match s {
            "HIGH" => ScoreConfidence::High,
            "LOW" => ScoreConfidence::Low,
            "MEDIUM" => ScoreConfidence::Medium,
            "NOT_AVAILABLE" => ScoreConfidence::NotAvailable,
            "VERY_HIGH" => ScoreConfidence::VeryHigh,
            other => ScoreConfidence::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ScoreConfidence {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScoreConfidence::from(s))
    }
}
impl ScoreConfidence {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ScoreConfidence::High => "HIGH",
            ScoreConfidence::Low => "LOW",
            ScoreConfidence::Medium => "MEDIUM",
            ScoreConfidence::NotAvailable => "NOT_AVAILABLE",
            ScoreConfidence::VeryHigh => "VERY_HIGH",
            ScoreConfidence::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["HIGH", "LOW", "MEDIUM", "NOT_AVAILABLE", "VERY_HIGH"]
    }
}
impl AsRef<str> for ScoreConfidence {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A document attribute or metadata field. To create custom document attributes, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/custom-attributes.html">Custom attributes</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DocumentAttribute {
    /// <p>The identifier for the attribute.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The value of the attribute.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::DocumentAttributeValue>,
}
impl DocumentAttribute {
    /// <p>The identifier for the attribute.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value of the attribute.</p>
    pub fn value(&self) -> std::option::Option<&crate::model::DocumentAttributeValue> {
        self.value.as_ref()
    }
}
/// See [`DocumentAttribute`](crate::model::DocumentAttribute).
pub mod document_attribute {

    /// A builder for [`DocumentAttribute`](crate::model::DocumentAttribute).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<crate::model::DocumentAttributeValue>,
    }
    impl Builder {
        /// <p>The identifier for the attribute.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The identifier for the attribute.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value of the attribute.</p>
        pub fn value(mut self, input: crate::model::DocumentAttributeValue) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the attribute.</p>
        pub fn set_value(
            mut self,
            input: std::option::Option<crate::model::DocumentAttributeValue>,
        ) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentAttribute`](crate::model::DocumentAttribute).
        pub fn build(self) -> crate::model::DocumentAttribute {
            crate::model::DocumentAttribute {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl DocumentAttribute {
    /// Creates a new builder-style object to manufacture [`DocumentAttribute`](crate::model::DocumentAttribute).
    pub fn builder() -> crate::model::document_attribute::Builder {
        crate::model::document_attribute::Builder::default()
    }
}

/// <p>Provides text and information about where to highlight the text.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TextWithHighlights {
    /// <p>The text to display to the user.</p>
    #[doc(hidden)]
    pub text: std::option::Option<std::string::String>,
    /// <p>The beginning and end of the text that should be highlighted.</p>
    #[doc(hidden)]
    pub highlights: std::option::Option<std::vec::Vec<crate::model::Highlight>>,
}
impl TextWithHighlights {
    /// <p>The text to display to the user.</p>
    pub fn text(&self) -> std::option::Option<&str> {
        self.text.as_deref()
    }
    /// <p>The beginning and end of the text that should be highlighted.</p>
    pub fn highlights(&self) -> std::option::Option<&[crate::model::Highlight]> {
        self.highlights.as_deref()
    }
}
/// See [`TextWithHighlights`](crate::model::TextWithHighlights).
pub mod text_with_highlights {

    /// A builder for [`TextWithHighlights`](crate::model::TextWithHighlights).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) text: std::option::Option<std::string::String>,
        pub(crate) highlights: std::option::Option<std::vec::Vec<crate::model::Highlight>>,
    }
    impl Builder {
        /// <p>The text to display to the user.</p>
        pub fn text(mut self, input: impl Into<std::string::String>) -> Self {
            self.text = Some(input.into());
            self
        }
        /// <p>The text to display to the user.</p>
        pub fn set_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.text = input;
            self
        }
        /// Appends an item to `highlights`.
        ///
        /// To override the contents of this collection use [`set_highlights`](Self::set_highlights).
        ///
        /// <p>The beginning and end of the text that should be highlighted.</p>
        pub fn highlights(mut self, input: crate::model::Highlight) -> Self {
            let mut v = self.highlights.unwrap_or_default();
            v.push(input);
            self.highlights = Some(v);
            self
        }
        /// <p>The beginning and end of the text that should be highlighted.</p>
        pub fn set_highlights(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Highlight>>,
        ) -> Self {
            self.highlights = input;
            self
        }
        /// Consumes the builder and constructs a [`TextWithHighlights`](crate::model::TextWithHighlights).
        pub fn build(self) -> crate::model::TextWithHighlights {
            crate::model::TextWithHighlights {
                text: self.text,
                highlights: self.highlights,
            }
        }
    }
}
impl TextWithHighlights {
    /// Creates a new builder-style object to manufacture [`TextWithHighlights`](crate::model::TextWithHighlights).
    pub fn builder() -> crate::model::text_with_highlights::Builder {
        crate::model::text_with_highlights::Builder::default()
    }
}

/// <p>Provides information that you can use to highlight a search result so that your users can quickly identify terms in the response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Highlight {
    /// <p>The zero-based location in the response string where the highlight starts.</p>
    #[doc(hidden)]
    pub begin_offset: std::option::Option<i32>,
    /// <p>The zero-based location in the response string where the highlight ends.</p>
    #[doc(hidden)]
    pub end_offset: std::option::Option<i32>,
    /// <p>Indicates whether the response is the best response. True if this is the best response; otherwise, false.</p>
    #[doc(hidden)]
    pub top_answer: bool,
    /// <p>The highlight type. </p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::HighlightType>,
}
impl Highlight {
    /// <p>The zero-based location in the response string where the highlight starts.</p>
    pub fn begin_offset(&self) -> std::option::Option<i32> {
        self.begin_offset
    }
    /// <p>The zero-based location in the response string where the highlight ends.</p>
    pub fn end_offset(&self) -> std::option::Option<i32> {
        self.end_offset
    }
    /// <p>Indicates whether the response is the best response. True if this is the best response; otherwise, false.</p>
    pub fn top_answer(&self) -> bool {
        self.top_answer
    }
    /// <p>The highlight type. </p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::HighlightType> {
        self.r#type.as_ref()
    }
}
/// See [`Highlight`](crate::model::Highlight).
pub mod highlight {

    /// A builder for [`Highlight`](crate::model::Highlight).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) begin_offset: std::option::Option<i32>,
        pub(crate) end_offset: std::option::Option<i32>,
        pub(crate) top_answer: std::option::Option<bool>,
        pub(crate) r#type: std::option::Option<crate::model::HighlightType>,
    }
    impl Builder {
        /// <p>The zero-based location in the response string where the highlight starts.</p>
        pub fn begin_offset(mut self, input: i32) -> Self {
            self.begin_offset = Some(input);
            self
        }
        /// <p>The zero-based location in the response string where the highlight starts.</p>
        pub fn set_begin_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.begin_offset = input;
            self
        }
        /// <p>The zero-based location in the response string where the highlight ends.</p>
        pub fn end_offset(mut self, input: i32) -> Self {
            self.end_offset = Some(input);
            self
        }
        /// <p>The zero-based location in the response string where the highlight ends.</p>
        pub fn set_end_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.end_offset = input;
            self
        }
        /// <p>Indicates whether the response is the best response. True if this is the best response; otherwise, false.</p>
        pub fn top_answer(mut self, input: bool) -> Self {
            self.top_answer = Some(input);
            self
        }
        /// <p>Indicates whether the response is the best response. True if this is the best response; otherwise, false.</p>
        pub fn set_top_answer(mut self, input: std::option::Option<bool>) -> Self {
            self.top_answer = input;
            self
        }
        /// <p>The highlight type. </p>
        pub fn r#type(mut self, input: crate::model::HighlightType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The highlight type. </p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::HighlightType>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`Highlight`](crate::model::Highlight).
        pub fn build(self) -> crate::model::Highlight {
            crate::model::Highlight {
                begin_offset: self.begin_offset,
                end_offset: self.end_offset,
                top_answer: self.top_answer.unwrap_or_default(),
                r#type: self.r#type,
            }
        }
    }
}
impl Highlight {
    /// Creates a new builder-style object to manufacture [`Highlight`](crate::model::Highlight).
    pub fn builder() -> crate::model::highlight::Builder {
        crate::model::highlight::Builder::default()
    }
}

/// When writing a match expression against `HighlightType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let highlighttype = unimplemented!();
/// match highlighttype {
///     HighlightType::Standard => { /* ... */ },
///     HighlightType::ThesaurusSynonym => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `highlighttype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `HighlightType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `HighlightType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `HighlightType::NewFeature` is defined.
/// Specifically, when `highlighttype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `HighlightType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HighlightType {
    #[allow(missing_docs)] // documentation missing in model
    Standard,
    #[allow(missing_docs)] // documentation missing in model
    ThesaurusSynonym,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for HighlightType {
    fn from(s: &str) -> Self {
        match s {
            "STANDARD" => HighlightType::Standard,
            "THESAURUS_SYNONYM" => HighlightType::ThesaurusSynonym,
            other => HighlightType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for HighlightType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HighlightType::from(s))
    }
}
impl HighlightType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HighlightType::Standard => "STANDARD",
            HighlightType::ThesaurusSynonym => "THESAURUS_SYNONYM",
            HighlightType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["STANDARD", "THESAURUS_SYNONYM"]
    }
}
impl AsRef<str> for HighlightType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An attribute returned from an index query.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AdditionalResultAttribute {
    /// <p>The key that identifies the attribute.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The data type of the <code>Value</code> property.</p>
    #[doc(hidden)]
    pub value_type: std::option::Option<crate::model::AdditionalResultAttributeValueType>,
    /// <p>An object that contains the attribute value.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::AdditionalResultAttributeValue>,
}
impl AdditionalResultAttribute {
    /// <p>The key that identifies the attribute.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The data type of the <code>Value</code> property.</p>
    pub fn value_type(
        &self,
    ) -> std::option::Option<&crate::model::AdditionalResultAttributeValueType> {
        self.value_type.as_ref()
    }
    /// <p>An object that contains the attribute value.</p>
    pub fn value(&self) -> std::option::Option<&crate::model::AdditionalResultAttributeValue> {
        self.value.as_ref()
    }
}
/// See [`AdditionalResultAttribute`](crate::model::AdditionalResultAttribute).
pub mod additional_result_attribute {

    /// A builder for [`AdditionalResultAttribute`](crate::model::AdditionalResultAttribute).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value_type:
            std::option::Option<crate::model::AdditionalResultAttributeValueType>,
        pub(crate) value: std::option::Option<crate::model::AdditionalResultAttributeValue>,
    }
    impl Builder {
        /// <p>The key that identifies the attribute.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The key that identifies the attribute.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The data type of the <code>Value</code> property.</p>
        pub fn value_type(
            mut self,
            input: crate::model::AdditionalResultAttributeValueType,
        ) -> Self {
            self.value_type = Some(input);
            self
        }
        /// <p>The data type of the <code>Value</code> property.</p>
        pub fn set_value_type(
            mut self,
            input: std::option::Option<crate::model::AdditionalResultAttributeValueType>,
        ) -> Self {
            self.value_type = input;
            self
        }
        /// <p>An object that contains the attribute value.</p>
        pub fn value(mut self, input: crate::model::AdditionalResultAttributeValue) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>An object that contains the attribute value.</p>
        pub fn set_value(
            mut self,
            input: std::option::Option<crate::model::AdditionalResultAttributeValue>,
        ) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AdditionalResultAttribute`](crate::model::AdditionalResultAttribute).
        pub fn build(self) -> crate::model::AdditionalResultAttribute {
            crate::model::AdditionalResultAttribute {
                key: self.key,
                value_type: self.value_type,
                value: self.value,
            }
        }
    }
}
impl AdditionalResultAttribute {
    /// Creates a new builder-style object to manufacture [`AdditionalResultAttribute`](crate::model::AdditionalResultAttribute).
    pub fn builder() -> crate::model::additional_result_attribute::Builder {
        crate::model::additional_result_attribute::Builder::default()
    }
}

/// <p>An attribute returned with a document from a search.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AdditionalResultAttributeValue {
    /// <p>The text associated with the attribute and information about the highlight to apply to the text.</p>
    #[doc(hidden)]
    pub text_with_highlights_value: std::option::Option<crate::model::TextWithHighlights>,
}
impl AdditionalResultAttributeValue {
    /// <p>The text associated with the attribute and information about the highlight to apply to the text.</p>
    pub fn text_with_highlights_value(
        &self,
    ) -> std::option::Option<&crate::model::TextWithHighlights> {
        self.text_with_highlights_value.as_ref()
    }
}
/// See [`AdditionalResultAttributeValue`](crate::model::AdditionalResultAttributeValue).
pub mod additional_result_attribute_value {

    /// A builder for [`AdditionalResultAttributeValue`](crate::model::AdditionalResultAttributeValue).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) text_with_highlights_value:
            std::option::Option<crate::model::TextWithHighlights>,
    }
    impl Builder {
        /// <p>The text associated with the attribute and information about the highlight to apply to the text.</p>
        pub fn text_with_highlights_value(
            mut self,
            input: crate::model::TextWithHighlights,
        ) -> Self {
            self.text_with_highlights_value = Some(input);
            self
        }
        /// <p>The text associated with the attribute and information about the highlight to apply to the text.</p>
        pub fn set_text_with_highlights_value(
            mut self,
            input: std::option::Option<crate::model::TextWithHighlights>,
        ) -> Self {
            self.text_with_highlights_value = input;
            self
        }
        /// Consumes the builder and constructs a [`AdditionalResultAttributeValue`](crate::model::AdditionalResultAttributeValue).
        pub fn build(self) -> crate::model::AdditionalResultAttributeValue {
            crate::model::AdditionalResultAttributeValue {
                text_with_highlights_value: self.text_with_highlights_value,
            }
        }
    }
}
impl AdditionalResultAttributeValue {
    /// Creates a new builder-style object to manufacture [`AdditionalResultAttributeValue`](crate::model::AdditionalResultAttributeValue).
    pub fn builder() -> crate::model::additional_result_attribute_value::Builder {
        crate::model::additional_result_attribute_value::Builder::default()
    }
}

/// When writing a match expression against `AdditionalResultAttributeValueType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let additionalresultattributevaluetype = unimplemented!();
/// match additionalresultattributevaluetype {
///     AdditionalResultAttributeValueType::TextWithHighlightsValue => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `additionalresultattributevaluetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AdditionalResultAttributeValueType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AdditionalResultAttributeValueType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AdditionalResultAttributeValueType::NewFeature` is defined.
/// Specifically, when `additionalresultattributevaluetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AdditionalResultAttributeValueType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AdditionalResultAttributeValueType {
    #[allow(missing_docs)] // documentation missing in model
    TextWithHighlightsValue,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AdditionalResultAttributeValueType {
    fn from(s: &str) -> Self {
        match s {
            "TEXT_WITH_HIGHLIGHTS_VALUE" => {
                AdditionalResultAttributeValueType::TextWithHighlightsValue
            }
            other => AdditionalResultAttributeValueType::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for AdditionalResultAttributeValueType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AdditionalResultAttributeValueType::from(s))
    }
}
impl AdditionalResultAttributeValueType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AdditionalResultAttributeValueType::TextWithHighlightsValue => {
                "TEXT_WITH_HIGHLIGHTS_VALUE"
            }
            AdditionalResultAttributeValueType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["TEXT_WITH_HIGHLIGHTS_VALUE"]
    }
}
impl AsRef<str> for AdditionalResultAttributeValueType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `QueryResultFormat`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let queryresultformat = unimplemented!();
/// match queryresultformat {
///     QueryResultFormat::Table => { /* ... */ },
///     QueryResultFormat::Text => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `queryresultformat` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `QueryResultFormat::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `QueryResultFormat::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `QueryResultFormat::NewFeature` is defined.
/// Specifically, when `queryresultformat` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `QueryResultFormat::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum QueryResultFormat {
    #[allow(missing_docs)] // documentation missing in model
    Table,
    #[allow(missing_docs)] // documentation missing in model
    Text,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for QueryResultFormat {
    fn from(s: &str) -> Self {
        match s {
            "TABLE" => QueryResultFormat::Table,
            "TEXT" => QueryResultFormat::Text,
            other => {
                QueryResultFormat::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for QueryResultFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(QueryResultFormat::from(s))
    }
}
impl QueryResultFormat {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            QueryResultFormat::Table => "TABLE",
            QueryResultFormat::Text => "TEXT",
            QueryResultFormat::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["TABLE", "TEXT"]
    }
}
impl AsRef<str> for QueryResultFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `QueryResultType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let queryresulttype = unimplemented!();
/// match queryresulttype {
///     QueryResultType::Answer => { /* ... */ },
///     QueryResultType::Document => { /* ... */ },
///     QueryResultType::QuestionAnswer => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `queryresulttype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `QueryResultType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `QueryResultType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `QueryResultType::NewFeature` is defined.
/// Specifically, when `queryresulttype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `QueryResultType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum QueryResultType {
    #[allow(missing_docs)] // documentation missing in model
    Answer,
    #[allow(missing_docs)] // documentation missing in model
    Document,
    #[allow(missing_docs)] // documentation missing in model
    QuestionAnswer,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for QueryResultType {
    fn from(s: &str) -> Self {
        match s {
            "ANSWER" => QueryResultType::Answer,
            "DOCUMENT" => QueryResultType::Document,
            "QUESTION_ANSWER" => QueryResultType::QuestionAnswer,
            other => QueryResultType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for QueryResultType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(QueryResultType::from(s))
    }
}
impl QueryResultType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            QueryResultType::Answer => "ANSWER",
            QueryResultType::Document => "DOCUMENT",
            QueryResultType::QuestionAnswer => "QUESTION_ANSWER",
            QueryResultType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ANSWER", "DOCUMENT", "QUESTION_ANSWER"]
    }
}
impl AsRef<str> for QueryResultType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides the configuration information for suggested query spell corrections.</p>
/// <p>Suggested spell corrections are based on words that appear in your indexed documents and how closely a corrected word matches a misspelled word.</p>
/// <p>This feature is designed with certain defaults or limits. For information on the current limits and how to request more support for some limits, see the <a href="https://docs.aws.amazon.com/kendra/latest/dg/query-spell-check.html">Spell Checker documentation</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SpellCorrectionConfiguration {
    /// <p> <code>TRUE</code> to suggest spell corrections for queries.</p>
    #[doc(hidden)]
    pub include_query_spell_check_suggestions: bool,
}
impl SpellCorrectionConfiguration {
    /// <p> <code>TRUE</code> to suggest spell corrections for queries.</p>
    pub fn include_query_spell_check_suggestions(&self) -> bool {
        self.include_query_spell_check_suggestions
    }
}
/// See [`SpellCorrectionConfiguration`](crate::model::SpellCorrectionConfiguration).
pub mod spell_correction_configuration {

    /// A builder for [`SpellCorrectionConfiguration`](crate::model::SpellCorrectionConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) include_query_spell_check_suggestions: std::option::Option<bool>,
    }
    impl Builder {
        /// <p> <code>TRUE</code> to suggest spell corrections for queries.</p>
        pub fn include_query_spell_check_suggestions(mut self, input: bool) -> Self {
            self.include_query_spell_check_suggestions = Some(input);
            self
        }
        /// <p> <code>TRUE</code> to suggest spell corrections for queries.</p>
        pub fn set_include_query_spell_check_suggestions(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.include_query_spell_check_suggestions = input;
            self
        }
        /// Consumes the builder and constructs a [`SpellCorrectionConfiguration`](crate::model::SpellCorrectionConfiguration).
        pub fn build(self) -> crate::model::SpellCorrectionConfiguration {
            crate::model::SpellCorrectionConfiguration {
                include_query_spell_check_suggestions: self
                    .include_query_spell_check_suggestions
                    .unwrap_or_default(),
            }
        }
    }
}
impl SpellCorrectionConfiguration {
    /// Creates a new builder-style object to manufacture [`SpellCorrectionConfiguration`](crate::model::SpellCorrectionConfiguration).
    pub fn builder() -> crate::model::spell_correction_configuration::Builder {
        crate::model::spell_correction_configuration::Builder::default()
    }
}

/// <p>Provides information about the user context for an Amazon Kendra index.</p>
/// <p>User context filtering is a kind of personalized search with the benefit of controlling access to documents. For example, not all teams that search the company portal for information should access top-secret company documents, nor are these documents relevant to all users. Only specific users or groups of teams given access to top-secret documents should see these documents in their search results.</p>
/// <p>You provide one of the following:</p>
/// <ul>
/// <li> <p>User token</p> </li>
/// <li> <p>User ID, the groups the user belongs to, and any data sources the groups can access.</p> </li>
/// </ul>
/// <p>If you provide both, an exception is thrown.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UserContext {
    /// <p>The user context token for filtering search results for a user. It must be a JWT or a JSON token.</p>
    #[doc(hidden)]
    pub token: std::option::Option<std::string::String>,
    /// <p>The identifier of the user you want to filter search results based on their access to documents.</p>
    #[doc(hidden)]
    pub user_id: std::option::Option<std::string::String>,
    /// <p>The list of groups you want to filter search results based on the groups' access to documents.</p>
    #[doc(hidden)]
    pub groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The list of data source groups you want to filter search results based on groups' access to documents in that data source.</p>
    #[doc(hidden)]
    pub data_source_groups: std::option::Option<std::vec::Vec<crate::model::DataSourceGroup>>,
}
impl UserContext {
    /// <p>The user context token for filtering search results for a user. It must be a JWT or a JSON token.</p>
    pub fn token(&self) -> std::option::Option<&str> {
        self.token.as_deref()
    }
    /// <p>The identifier of the user you want to filter search results based on their access to documents.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>The list of groups you want to filter search results based on the groups' access to documents.</p>
    pub fn groups(&self) -> std::option::Option<&[std::string::String]> {
        self.groups.as_deref()
    }
    /// <p>The list of data source groups you want to filter search results based on groups' access to documents in that data source.</p>
    pub fn data_source_groups(&self) -> std::option::Option<&[crate::model::DataSourceGroup]> {
        self.data_source_groups.as_deref()
    }
}
/// See [`UserContext`](crate::model::UserContext).
pub mod user_context {

    /// A builder for [`UserContext`](crate::model::UserContext).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) token: std::option::Option<std::string::String>,
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) data_source_groups:
            std::option::Option<std::vec::Vec<crate::model::DataSourceGroup>>,
    }
    impl Builder {
        /// <p>The user context token for filtering search results for a user. It must be a JWT or a JSON token.</p>
        pub fn token(mut self, input: impl Into<std::string::String>) -> Self {
            self.token = Some(input.into());
            self
        }
        /// <p>The user context token for filtering search results for a user. It must be a JWT or a JSON token.</p>
        pub fn set_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.token = input;
            self
        }
        /// <p>The identifier of the user you want to filter search results based on their access to documents.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The identifier of the user you want to filter search results based on their access to documents.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// Appends an item to `groups`.
        ///
        /// To override the contents of this collection use [`set_groups`](Self::set_groups).
        ///
        /// <p>The list of groups you want to filter search results based on the groups' access to documents.</p>
        pub fn groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.groups.unwrap_or_default();
            v.push(input.into());
            self.groups = Some(v);
            self
        }
        /// <p>The list of groups you want to filter search results based on the groups' access to documents.</p>
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.groups = input;
            self
        }
        /// Appends an item to `data_source_groups`.
        ///
        /// To override the contents of this collection use [`set_data_source_groups`](Self::set_data_source_groups).
        ///
        /// <p>The list of data source groups you want to filter search results based on groups' access to documents in that data source.</p>
        pub fn data_source_groups(mut self, input: crate::model::DataSourceGroup) -> Self {
            let mut v = self.data_source_groups.unwrap_or_default();
            v.push(input);
            self.data_source_groups = Some(v);
            self
        }
        /// <p>The list of data source groups you want to filter search results based on groups' access to documents in that data source.</p>
        pub fn set_data_source_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceGroup>>,
        ) -> Self {
            self.data_source_groups = input;
            self
        }
        /// Consumes the builder and constructs a [`UserContext`](crate::model::UserContext).
        pub fn build(self) -> crate::model::UserContext {
            crate::model::UserContext {
                token: self.token,
                user_id: self.user_id,
                groups: self.groups,
                data_source_groups: self.data_source_groups,
            }
        }
    }
}
impl UserContext {
    /// Creates a new builder-style object to manufacture [`UserContext`](crate::model::UserContext).
    pub fn builder() -> crate::model::user_context::Builder {
        crate::model::user_context::Builder::default()
    }
}

/// <p>Data source information for user context filtering.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSourceGroup {
    /// <p>The identifier of the group you want to add to your list of groups. This is for filtering search results based on the groups' access to documents.</p>
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the data source group you want to add to your list of data source groups. This is for filtering search results based on the groups' access to documents in that data source.</p>
    #[doc(hidden)]
    pub data_source_id: std::option::Option<std::string::String>,
}
impl DataSourceGroup {
    /// <p>The identifier of the group you want to add to your list of groups. This is for filtering search results based on the groups' access to documents.</p>
    pub fn group_id(&self) -> std::option::Option<&str> {
        self.group_id.as_deref()
    }
    /// <p>The identifier of the data source group you want to add to your list of data source groups. This is for filtering search results based on the groups' access to documents in that data source.</p>
    pub fn data_source_id(&self) -> std::option::Option<&str> {
        self.data_source_id.as_deref()
    }
}
/// See [`DataSourceGroup`](crate::model::DataSourceGroup).
pub mod data_source_group {

    /// A builder for [`DataSourceGroup`](crate::model::DataSourceGroup).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) data_source_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the group you want to add to your list of groups. This is for filtering search results based on the groups' access to documents.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// <p>The identifier of the group you want to add to your list of groups. This is for filtering search results based on the groups' access to documents.</p>
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input;
            self
        }
        /// <p>The identifier of the data source group you want to add to your list of data source groups. This is for filtering search results based on the groups' access to documents in that data source.</p>
        pub fn data_source_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_source_id = Some(input.into());
            self
        }
        /// <p>The identifier of the data source group you want to add to your list of data source groups. This is for filtering search results based on the groups' access to documents in that data source.</p>
        pub fn set_data_source_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_source_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSourceGroup`](crate::model::DataSourceGroup).
        pub fn build(self) -> crate::model::DataSourceGroup {
            crate::model::DataSourceGroup {
                group_id: self.group_id,
                data_source_id: self.data_source_id,
            }
        }
    }
}
impl DataSourceGroup {
    /// Creates a new builder-style object to manufacture [`DataSourceGroup`](crate::model::DataSourceGroup).
    pub fn builder() -> crate::model::data_source_group::Builder {
        crate::model::data_source_group::Builder::default()
    }
}

/// <p>Specifies the document attribute to use to sort the response to a Amazon Kendra query. You can specify a single attribute for sorting. The attribute must have the <code>Sortable</code> flag set to <code>true</code>, otherwise Amazon Kendra returns an exception.</p>
/// <p>You can sort attributes of the following types.</p>
/// <ul>
/// <li> <p>Date value</p> </li>
/// <li> <p>Long value</p> </li>
/// <li> <p>String value</p> </li>
/// </ul>
/// <p>You can't sort attributes of the following type.</p>
/// <ul>
/// <li> <p>String list value</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SortingConfiguration {
    /// <p>The name of the document attribute used to sort the response. You can use any field that has the <code>Sortable</code> flag set to true.</p>
    /// <p>You can also sort by any of the following built-in attributes:</p>
    /// <ul>
    /// <li> <p>_category</p> </li>
    /// <li> <p>_created_at</p> </li>
    /// <li> <p>_last_updated_at</p> </li>
    /// <li> <p>_version</p> </li>
    /// <li> <p>_view_count</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub document_attribute_key: std::option::Option<std::string::String>,
    /// <p>The order that the results should be returned in. In case of ties, the relevance assigned to the result by Amazon Kendra is used as the tie-breaker.</p>
    #[doc(hidden)]
    pub sort_order: std::option::Option<crate::model::SortOrder>,
}
impl SortingConfiguration {
    /// <p>The name of the document attribute used to sort the response. You can use any field that has the <code>Sortable</code> flag set to true.</p>
    /// <p>You can also sort by any of the following built-in attributes:</p>
    /// <ul>
    /// <li> <p>_category</p> </li>
    /// <li> <p>_created_at</p> </li>
    /// <li> <p>_last_updated_at</p> </li>
    /// <li> <p>_version</p> </li>
    /// <li> <p>_view_count</p> </li>
    /// </ul>
    pub fn document_attribute_key(&self) -> std::option::Option<&str> {
        self.document_attribute_key.as_deref()
    }
    /// <p>The order that the results should be returned in. In case of ties, the relevance assigned to the result by Amazon Kendra is used as the tie-breaker.</p>
    pub fn sort_order(&self) -> std::option::Option<&crate::model::SortOrder> {
        self.sort_order.as_ref()
    }
}
/// See [`SortingConfiguration`](crate::model::SortingConfiguration).
pub mod sorting_configuration {

    /// A builder for [`SortingConfiguration`](crate::model::SortingConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_attribute_key: std::option::Option<std::string::String>,
        pub(crate) sort_order: std::option::Option<crate::model::SortOrder>,
    }
    impl Builder {
        /// <p>The name of the document attribute used to sort the response. You can use any field that has the <code>Sortable</code> flag set to true.</p>
        /// <p>You can also sort by any of the following built-in attributes:</p>
        /// <ul>
        /// <li> <p>_category</p> </li>
        /// <li> <p>_created_at</p> </li>
        /// <li> <p>_last_updated_at</p> </li>
        /// <li> <p>_version</p> </li>
        /// <li> <p>_view_count</p> </li>
        /// </ul>
        pub fn document_attribute_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_attribute_key = Some(input.into());
            self
        }
        /// <p>The name of the document attribute used to sort the response. You can use any field that has the <code>Sortable</code> flag set to true.</p>
        /// <p>You can also sort by any of the following built-in attributes:</p>
        /// <ul>
        /// <li> <p>_category</p> </li>
        /// <li> <p>_created_at</p> </li>
        /// <li> <p>_last_updated_at</p> </li>
        /// <li> <p>_version</p> </li>
        /// <li> <p>_view_count</p> </li>
        /// </ul>
        pub fn set_document_attribute_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_attribute_key = input;
            self
        }
        /// <p>The order that the results should be returned in. In case of ties, the relevance assigned to the result by Amazon Kendra is used as the tie-breaker.</p>
        pub fn sort_order(mut self, input: crate::model::SortOrder) -> Self {
            self.sort_order = Some(input);
            self
        }
        /// <p>The order that the results should be returned in. In case of ties, the relevance assigned to the result by Amazon Kendra is used as the tie-breaker.</p>
        pub fn set_sort_order(
            mut self,
            input: std::option::Option<crate::model::SortOrder>,
        ) -> Self {
            self.sort_order = input;
            self
        }
        /// Consumes the builder and constructs a [`SortingConfiguration`](crate::model::SortingConfiguration).
        pub fn build(self) -> crate::model::SortingConfiguration {
            crate::model::SortingConfiguration {
                document_attribute_key: self.document_attribute_key,
                sort_order: self.sort_order,
            }
        }
    }
}
impl SortingConfiguration {
    /// Creates a new builder-style object to manufacture [`SortingConfiguration`](crate::model::SortingConfiguration).
    pub fn builder() -> crate::model::sorting_configuration::Builder {
        crate::model::sorting_configuration::Builder::default()
    }
}

/// When writing a match expression against `SortOrder`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sortorder = unimplemented!();
/// match sortorder {
///     SortOrder::Asc => { /* ... */ },
///     SortOrder::Desc => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sortorder` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SortOrder::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SortOrder::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SortOrder::NewFeature` is defined.
/// Specifically, when `sortorder` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SortOrder::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortOrder {
    #[allow(missing_docs)] // documentation missing in model
    Asc,
    #[allow(missing_docs)] // documentation missing in model
    Desc,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SortOrder {
    fn from(s: &str) -> Self {
        match s {
            "ASC" => SortOrder::Asc,
            "DESC" => SortOrder::Desc,
            other => SortOrder::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortOrder::from(s))
    }
}
impl SortOrder {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SortOrder::Asc => "ASC",
            SortOrder::Desc => "DESC",
            SortOrder::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ASC", "DESC"]
    }
}
impl AsRef<str> for SortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Overrides the document relevance properties of a custom index field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DocumentRelevanceConfiguration {
    /// <p>The name of the index field.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Provides information for tuning the relevance of a field in a search. When a query includes terms that match the field, the results are given a boost in the response based on these tuning parameters.</p>
    #[doc(hidden)]
    pub relevance: std::option::Option<crate::model::Relevance>,
}
impl DocumentRelevanceConfiguration {
    /// <p>The name of the index field.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Provides information for tuning the relevance of a field in a search. When a query includes terms that match the field, the results are given a boost in the response based on these tuning parameters.</p>
    pub fn relevance(&self) -> std::option::Option<&crate::model::Relevance> {
        self.relevance.as_ref()
    }
}
/// See [`DocumentRelevanceConfiguration`](crate::model::DocumentRelevanceConfiguration).
pub mod document_relevance_configuration {

    /// A builder for [`DocumentRelevanceConfiguration`](crate::model::DocumentRelevanceConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) relevance: std::option::Option<crate::model::Relevance>,
    }
    impl Builder {
        /// <p>The name of the index field.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the index field.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Provides information for tuning the relevance of a field in a search. When a query includes terms that match the field, the results are given a boost in the response based on these tuning parameters.</p>
        pub fn relevance(mut self, input: crate::model::Relevance) -> Self {
            self.relevance = Some(input);
            self
        }
        /// <p>Provides information for tuning the relevance of a field in a search. When a query includes terms that match the field, the results are given a boost in the response based on these tuning parameters.</p>
        pub fn set_relevance(
            mut self,
            input: std::option::Option<crate::model::Relevance>,
        ) -> Self {
            self.relevance = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentRelevanceConfiguration`](crate::model::DocumentRelevanceConfiguration).
        pub fn build(self) -> crate::model::DocumentRelevanceConfiguration {
            crate::model::DocumentRelevanceConfiguration {
                name: self.name,
                relevance: self.relevance,
            }
        }
    }
}
impl DocumentRelevanceConfiguration {
    /// Creates a new builder-style object to manufacture [`DocumentRelevanceConfiguration`](crate::model::DocumentRelevanceConfiguration).
    pub fn builder() -> crate::model::document_relevance_configuration::Builder {
        crate::model::document_relevance_configuration::Builder::default()
    }
}

/// <p>Information about a document attribute. You can use document attributes as facets.</p>
/// <p>For example, the document attribute or facet "Department" includes the values "HR", "Engineering", and "Accounting". You can display these values in the search results so that documents can be searched by department.</p>
/// <p>You can display up to 10 facet values per facet for a query. If you want to increase this limit, contact <a href="http://aws.amazon.com/contact-us/">Support</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Facet {
    /// <p>The unique key for the document attribute.</p>
    #[doc(hidden)]
    pub document_attribute_key: std::option::Option<std::string::String>,
    /// <p>An array of document attributes that are nested facets within a facet.</p>
    /// <p>For example, the document attribute or facet "Department" includes a value called "Engineering". In addition, the document attribute or facet "SubDepartment" includes the values "Frontend" and "Backend" for documents assigned to "Engineering". You can display nested facets in the search results so that documents can be searched not only by department but also by a sub department within a department. This helps your users further narrow their search.</p>
    /// <p>You can only have one nested facet within a facet. If you want to increase this limit, contact <a href="http://aws.amazon.com/contact-us/">Support</a>.</p>
    #[doc(hidden)]
    pub facets: std::option::Option<std::vec::Vec<crate::model::Facet>>,
    /// <p>Maximum number of facet values per facet. The default is 10. You can use this to limit the number of facet values to less than 10. If you want to increase the default, contact <a href="http://aws.amazon.com/contact-us/">Support</a>.</p>
    #[doc(hidden)]
    pub max_results: i32,
}
impl Facet {
    /// <p>The unique key for the document attribute.</p>
    pub fn document_attribute_key(&self) -> std::option::Option<&str> {
        self.document_attribute_key.as_deref()
    }
    /// <p>An array of document attributes that are nested facets within a facet.</p>
    /// <p>For example, the document attribute or facet "Department" includes a value called "Engineering". In addition, the document attribute or facet "SubDepartment" includes the values "Frontend" and "Backend" for documents assigned to "Engineering". You can display nested facets in the search results so that documents can be searched not only by department but also by a sub department within a department. This helps your users further narrow their search.</p>
    /// <p>You can only have one nested facet within a facet. If you want to increase this limit, contact <a href="http://aws.amazon.com/contact-us/">Support</a>.</p>
    pub fn facets(&self) -> std::option::Option<&[crate::model::Facet]> {
        self.facets.as_deref()
    }
    /// <p>Maximum number of facet values per facet. The default is 10. You can use this to limit the number of facet values to less than 10. If you want to increase the default, contact <a href="http://aws.amazon.com/contact-us/">Support</a>.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
}
/// See [`Facet`](crate::model::Facet).
pub mod facet {

    /// A builder for [`Facet`](crate::model::Facet).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_attribute_key: std::option::Option<std::string::String>,
        pub(crate) facets: std::option::Option<std::vec::Vec<crate::model::Facet>>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique key for the document attribute.</p>
        pub fn document_attribute_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_attribute_key = Some(input.into());
            self
        }
        /// <p>The unique key for the document attribute.</p>
        pub fn set_document_attribute_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_attribute_key = input;
            self
        }
        /// Appends an item to `facets`.
        ///
        /// To override the contents of this collection use [`set_facets`](Self::set_facets).
        ///
        /// <p>An array of document attributes that are nested facets within a facet.</p>
        /// <p>For example, the document attribute or facet "Department" includes a value called "Engineering". In addition, the document attribute or facet "SubDepartment" includes the values "Frontend" and "Backend" for documents assigned to "Engineering". You can display nested facets in the search results so that documents can be searched not only by department but also by a sub department within a department. This helps your users further narrow their search.</p>
        /// <p>You can only have one nested facet within a facet. If you want to increase this limit, contact <a href="http://aws.amazon.com/contact-us/">Support</a>.</p>
        pub fn facets(mut self, input: crate::model::Facet) -> Self {
            let mut v = self.facets.unwrap_or_default();
            v.push(input);
            self.facets = Some(v);
            self
        }
        /// <p>An array of document attributes that are nested facets within a facet.</p>
        /// <p>For example, the document attribute or facet "Department" includes a value called "Engineering". In addition, the document attribute or facet "SubDepartment" includes the values "Frontend" and "Backend" for documents assigned to "Engineering". You can display nested facets in the search results so that documents can be searched not only by department but also by a sub department within a department. This helps your users further narrow their search.</p>
        /// <p>You can only have one nested facet within a facet. If you want to increase this limit, contact <a href="http://aws.amazon.com/contact-us/">Support</a>.</p>
        pub fn set_facets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Facet>>,
        ) -> Self {
            self.facets = input;
            self
        }
        /// <p>Maximum number of facet values per facet. The default is 10. You can use this to limit the number of facet values to less than 10. If you want to increase the default, contact <a href="http://aws.amazon.com/contact-us/">Support</a>.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Maximum number of facet values per facet. The default is 10. You can use this to limit the number of facet values to less than 10. If you want to increase the default, contact <a href="http://aws.amazon.com/contact-us/">Support</a>.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`Facet`](crate::model::Facet).
        pub fn build(self) -> crate::model::Facet {
            crate::model::Facet {
                document_attribute_key: self.document_attribute_key,
                facets: self.facets,
                max_results: self.max_results.unwrap_or_default(),
            }
        }
    }
}
impl Facet {
    /// Creates a new builder-style object to manufacture [`Facet`](crate::model::Facet).
    pub fn builder() -> crate::model::facet::Builder {
        crate::model::facet::Builder::default()
    }
}

/// <p>Provides filtering the query results based on document attributes or metadata fields.</p>
/// <p>When you use the <code>AndAllFilters</code> or <code>OrAllFilters</code>, filters you can use 2 layers under the first attribute filter. For example, you can use:</p>
/// <p> <code>
/// <andallfilters></andallfilters></code> </p>
/// <ol>
/// <li> <p> <code>
/// <orallfilters></orallfilters></code> </p> </li>
/// <li> <p> <code>
/// <equalsto></equalsto></code> </p> </li>
/// </ol>
/// <p>If you use more than 2 layers, you receive a <code>ValidationException</code> exception with the message "<code>AttributeFilter</code> cannot have a depth of more than 2."</p>
/// <p>If you use more than 10 attribute filters in a given list for <code>AndAllFilters</code> or <code>OrAllFilters</code>, you receive a <code>ValidationException</code> with the message "<code>AttributeFilter</code> cannot have a length of more than 10".</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AttributeFilter {
    /// <p>Performs a logical <code>AND</code> operation on all supplied filters.</p>
    #[doc(hidden)]
    pub and_all_filters: std::option::Option<std::vec::Vec<crate::model::AttributeFilter>>,
    /// <p>Performs a logical <code>OR</code> operation on all supplied filters.</p>
    #[doc(hidden)]
    pub or_all_filters: std::option::Option<std::vec::Vec<crate::model::AttributeFilter>>,
    /// <p>Performs a logical <code>NOT</code> operation on all supplied filters.</p>
    #[doc(hidden)]
    pub not_filter: std::option::Option<std::boxed::Box<crate::model::AttributeFilter>>,
    /// <p>Performs an equals operation on two document attributes or metadata fields.</p>
    #[doc(hidden)]
    pub equals_to: std::option::Option<crate::model::DocumentAttribute>,
    /// <p>Returns true when a document contains all of the specified document attributes or metadata fields. This filter is only applicable to <code>StringListValue</code> metadata.</p>
    #[doc(hidden)]
    pub contains_all: std::option::Option<crate::model::DocumentAttribute>,
    /// <p>Returns true when a document contains any of the specified document attributes or metadata fields. This filter is only applicable to <code>StringListValue</code> metadata.</p>
    #[doc(hidden)]
    pub contains_any: std::option::Option<crate::model::DocumentAttribute>,
    /// <p>Performs a greater than operation on two document attributes or metadata fields. Use with a document attribute of type <code>Date</code> or <code>Long</code>.</p>
    #[doc(hidden)]
    pub greater_than: std::option::Option<crate::model::DocumentAttribute>,
    /// <p>Performs a greater or equals than operation on two document attributes or metadata fields. Use with a document attribute of type <code>Date</code> or <code>Long</code>.</p>
    #[doc(hidden)]
    pub greater_than_or_equals: std::option::Option<crate::model::DocumentAttribute>,
    /// <p>Performs a less than operation on two document attributes or metadata fields. Use with a document attribute of type <code>Date</code> or <code>Long</code>.</p>
    #[doc(hidden)]
    pub less_than: std::option::Option<crate::model::DocumentAttribute>,
    /// <p>Performs a less than or equals operation on two document attributes or metadata fields. Use with a document attribute of type <code>Date</code> or <code>Long</code>.</p>
    #[doc(hidden)]
    pub less_than_or_equals: std::option::Option<crate::model::DocumentAttribute>,
}
impl AttributeFilter {
    /// <p>Performs a logical <code>AND</code> operation on all supplied filters.</p>
    pub fn and_all_filters(&self) -> std::option::Option<&[crate::model::AttributeFilter]> {
        self.and_all_filters.as_deref()
    }
    /// <p>Performs a logical <code>OR</code> operation on all supplied filters.</p>
    pub fn or_all_filters(&self) -> std::option::Option<&[crate::model::AttributeFilter]> {
        self.or_all_filters.as_deref()
    }
    /// <p>Performs a logical <code>NOT</code> operation on all supplied filters.</p>
    pub fn not_filter(&self) -> std::option::Option<&crate::model::AttributeFilter> {
        self.not_filter.as_deref()
    }
    /// <p>Performs an equals operation on two document attributes or metadata fields.</p>
    pub fn equals_to(&self) -> std::option::Option<&crate::model::DocumentAttribute> {
        self.equals_to.as_ref()
    }
    /// <p>Returns true when a document contains all of the specified document attributes or metadata fields. This filter is only applicable to <code>StringListValue</code> metadata.</p>
    pub fn contains_all(&self) -> std::option::Option<&crate::model::DocumentAttribute> {
        self.contains_all.as_ref()
    }
    /// <p>Returns true when a document contains any of the specified document attributes or metadata fields. This filter is only applicable to <code>StringListValue</code> metadata.</p>
    pub fn contains_any(&self) -> std::option::Option<&crate::model::DocumentAttribute> {
        self.contains_any.as_ref()
    }
    /// <p>Performs a greater than operation on two document attributes or metadata fields. Use with a document attribute of type <code>Date</code> or <code>Long</code>.</p>
    pub fn greater_than(&self) -> std::option::Option<&crate::model::DocumentAttribute> {
        self.greater_than.as_ref()
    }
    /// <p>Performs a greater or equals than operation on two document attributes or metadata fields. Use with a document attribute of type <code>Date</code> or <code>Long</code>.</p>
    pub fn greater_than_or_equals(&self) -> std::option::Option<&crate::model::DocumentAttribute> {
        self.greater_than_or_equals.as_ref()
    }
    /// <p>Performs a less than operation on two document attributes or metadata fields. Use with a document attribute of type <code>Date</code> or <code>Long</code>.</p>
    pub fn less_than(&self) -> std::option::Option<&crate::model::DocumentAttribute> {
        self.less_than.as_ref()
    }
    /// <p>Performs a less than or equals operation on two document attributes or metadata fields. Use with a document attribute of type <code>Date</code> or <code>Long</code>.</p>
    pub fn less_than_or_equals(&self) -> std::option::Option<&crate::model::DocumentAttribute> {
        self.less_than_or_equals.as_ref()
    }
}
/// See [`AttributeFilter`](crate::model::AttributeFilter).
pub mod attribute_filter {

    /// A builder for [`AttributeFilter`](crate::model::AttributeFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) and_all_filters:
            std::option::Option<std::vec::Vec<crate::model::AttributeFilter>>,
        pub(crate) or_all_filters:
            std::option::Option<std::vec::Vec<crate::model::AttributeFilter>>,
        pub(crate) not_filter: std::option::Option<std::boxed::Box<crate::model::AttributeFilter>>,
        pub(crate) equals_to: std::option::Option<crate::model::DocumentAttribute>,
        pub(crate) contains_all: std::option::Option<crate::model::DocumentAttribute>,
        pub(crate) contains_any: std::option::Option<crate::model::DocumentAttribute>,
        pub(crate) greater_than: std::option::Option<crate::model::DocumentAttribute>,
        pub(crate) greater_than_or_equals: std::option::Option<crate::model::DocumentAttribute>,
        pub(crate) less_than: std::option::Option<crate::model::DocumentAttribute>,
        pub(crate) less_than_or_equals: std::option::Option<crate::model::DocumentAttribute>,
    }
    impl Builder {
        /// Appends an item to `and_all_filters`.
        ///
        /// To override the contents of this collection use [`set_and_all_filters`](Self::set_and_all_filters).
        ///
        /// <p>Performs a logical <code>AND</code> operation on all supplied filters.</p>
        pub fn and_all_filters(mut self, input: crate::model::AttributeFilter) -> Self {
            let mut v = self.and_all_filters.unwrap_or_default();
            v.push(input);
            self.and_all_filters = Some(v);
            self
        }
        /// <p>Performs a logical <code>AND</code> operation on all supplied filters.</p>
        pub fn set_and_all_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AttributeFilter>>,
        ) -> Self {
            self.and_all_filters = input;
            self
        }
        /// Appends an item to `or_all_filters`.
        ///
        /// To override the contents of this collection use [`set_or_all_filters`](Self::set_or_all_filters).
        ///
        /// <p>Performs a logical <code>OR</code> operation on all supplied filters.</p>
        pub fn or_all_filters(mut self, input: crate::model::AttributeFilter) -> Self {
            let mut v = self.or_all_filters.unwrap_or_default();
            v.push(input);
            self.or_all_filters = Some(v);
            self
        }
        /// <p>Performs a logical <code>OR</code> operation on all supplied filters.</p>
        pub fn set_or_all_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AttributeFilter>>,
        ) -> Self {
            self.or_all_filters = input;
            self
        }
        /// <p>Performs a logical <code>NOT</code> operation on all supplied filters.</p>
        pub fn not_filter(
            mut self,
            input: impl Into<std::boxed::Box<crate::model::AttributeFilter>>,
        ) -> Self {
            self.not_filter = Some(input.into());
            self
        }
        /// <p>Performs a logical <code>NOT</code> operation on all supplied filters.</p>
        pub fn set_not_filter(
            mut self,
            input: std::option::Option<std::boxed::Box<crate::model::AttributeFilter>>,
        ) -> Self {
            self.not_filter = input;
            self
        }
        /// <p>Performs an equals operation on two document attributes or metadata fields.</p>
        pub fn equals_to(mut self, input: crate::model::DocumentAttribute) -> Self {
            self.equals_to = Some(input);
            self
        }
        /// <p>Performs an equals operation on two document attributes or metadata fields.</p>
        pub fn set_equals_to(
            mut self,
            input: std::option::Option<crate::model::DocumentAttribute>,
        ) -> Self {
            self.equals_to = input;
            self
        }
        /// <p>Returns true when a document contains all of the specified document attributes or metadata fields. This filter is only applicable to <code>StringListValue</code> metadata.</p>
        pub fn contains_all(mut self, input: crate::model::DocumentAttribute) -> Self {
            self.contains_all = Some(input);
            self
        }
        /// <p>Returns true when a document contains all of the specified document attributes or metadata fields. This filter is only applicable to <code>StringListValue</code> metadata.</p>
        pub fn set_contains_all(
            mut self,
            input: std::option::Option<crate::model::DocumentAttribute>,
        ) -> Self {
            self.contains_all = input;
            self
        }
        /// <p>Returns true when a document contains any of the specified document attributes or metadata fields. This filter is only applicable to <code>StringListValue</code> metadata.</p>
        pub fn contains_any(mut self, input: crate::model::DocumentAttribute) -> Self {
            self.contains_any = Some(input);
            self
        }
        /// <p>Returns true when a document contains any of the specified document attributes or metadata fields. This filter is only applicable to <code>StringListValue</code> metadata.</p>
        pub fn set_contains_any(
            mut self,
            input: std::option::Option<crate::model::DocumentAttribute>,
        ) -> Self {
            self.contains_any = input;
            self
        }
        /// <p>Performs a greater than operation on two document attributes or metadata fields. Use with a document attribute of type <code>Date</code> or <code>Long</code>.</p>
        pub fn greater_than(mut self, input: crate::model::DocumentAttribute) -> Self {
            self.greater_than = Some(input);
            self
        }
        /// <p>Performs a greater than operation on two document attributes or metadata fields. Use with a document attribute of type <code>Date</code> or <code>Long</code>.</p>
        pub fn set_greater_than(
            mut self,
            input: std::option::Option<crate::model::DocumentAttribute>,
        ) -> Self {
            self.greater_than = input;
            self
        }
        /// <p>Performs a greater or equals than operation on two document attributes or metadata fields. Use with a document attribute of type <code>Date</code> or <code>Long</code>.</p>
        pub fn greater_than_or_equals(mut self, input: crate::model::DocumentAttribute) -> Self {
            self.greater_than_or_equals = Some(input);
            self
        }
        /// <p>Performs a greater or equals than operation on two document attributes or metadata fields. Use with a document attribute of type <code>Date</code> or <code>Long</code>.</p>
        pub fn set_greater_than_or_equals(
            mut self,
            input: std::option::Option<crate::model::DocumentAttribute>,
        ) -> Self {
            self.greater_than_or_equals = input;
            self
        }
        /// <p>Performs a less than operation on two document attributes or metadata fields. Use with a document attribute of type <code>Date</code> or <code>Long</code>.</p>
        pub fn less_than(mut self, input: crate::model::DocumentAttribute) -> Self {
            self.less_than = Some(input);
            self
        }
        /// <p>Performs a less than operation on two document attributes or metadata fields. Use with a document attribute of type <code>Date</code> or <code>Long</code>.</p>
        pub fn set_less_than(
            mut self,
            input: std::option::Option<crate::model::DocumentAttribute>,
        ) -> Self {
            self.less_than = input;
            self
        }
        /// <p>Performs a less than or equals operation on two document attributes or metadata fields. Use with a document attribute of type <code>Date</code> or <code>Long</code>.</p>
        pub fn less_than_or_equals(mut self, input: crate::model::DocumentAttribute) -> Self {
            self.less_than_or_equals = Some(input);
            self
        }
        /// <p>Performs a less than or equals operation on two document attributes or metadata fields. Use with a document attribute of type <code>Date</code> or <code>Long</code>.</p>
        pub fn set_less_than_or_equals(
            mut self,
            input: std::option::Option<crate::model::DocumentAttribute>,
        ) -> Self {
            self.less_than_or_equals = input;
            self
        }
        /// Consumes the builder and constructs a [`AttributeFilter`](crate::model::AttributeFilter).
        pub fn build(self) -> crate::model::AttributeFilter {
            crate::model::AttributeFilter {
                and_all_filters: self.and_all_filters,
                or_all_filters: self.or_all_filters,
                not_filter: self.not_filter,
                equals_to: self.equals_to,
                contains_all: self.contains_all,
                contains_any: self.contains_any,
                greater_than: self.greater_than,
                greater_than_or_equals: self.greater_than_or_equals,
                less_than: self.less_than,
                less_than_or_equals: self.less_than_or_equals,
            }
        }
    }
}
impl AttributeFilter {
    /// Creates a new builder-style object to manufacture [`AttributeFilter`](crate::model::AttributeFilter).
    pub fn builder() -> crate::model::attribute_filter::Builder {
        crate::model::attribute_filter::Builder::default()
    }
}

/// <p>A list of users or sub groups that belong to a group. This is useful for user context filtering, where search results are filtered based on the user or their group access to documents.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GroupMembers {
    /// <p>A list of sub groups that belong to a group. For example, the sub groups "Research", "Engineering", and "Sales and Marketing" all belong to the group "Company".</p>
    #[doc(hidden)]
    pub member_groups: std::option::Option<std::vec::Vec<crate::model::MemberGroup>>,
    /// <p>A list of users that belong to a group. For example, a list of interns all belong to the "Interns" group.</p>
    #[doc(hidden)]
    pub member_users: std::option::Option<std::vec::Vec<crate::model::MemberUser>>,
    /// <p>If you have more than 1000 users and/or sub groups for a single group, you need to provide the path to the S3 file that lists your users and sub groups for a group. Your sub groups can contain more than 1000 users, but the list of sub groups that belong to a group (and/or users) must be no more than 1000.</p>
    /// <p>You can download this <a href="https://docs.aws.amazon.com/kendra/latest/dg/samples/group_members.zip">example S3 file</a> that uses the correct format for listing group members. Note, <code>dataSourceId</code> is optional. The value of <code>type</code> for a group is always <code>GROUP</code> and for a user it is always <code>USER</code>.</p>
    #[doc(hidden)]
    pub s3_pathfor_group_members: std::option::Option<crate::model::S3Path>,
}
impl GroupMembers {
    /// <p>A list of sub groups that belong to a group. For example, the sub groups "Research", "Engineering", and "Sales and Marketing" all belong to the group "Company".</p>
    pub fn member_groups(&self) -> std::option::Option<&[crate::model::MemberGroup]> {
        self.member_groups.as_deref()
    }
    /// <p>A list of users that belong to a group. For example, a list of interns all belong to the "Interns" group.</p>
    pub fn member_users(&self) -> std::option::Option<&[crate::model::MemberUser]> {
        self.member_users.as_deref()
    }
    /// <p>If you have more than 1000 users and/or sub groups for a single group, you need to provide the path to the S3 file that lists your users and sub groups for a group. Your sub groups can contain more than 1000 users, but the list of sub groups that belong to a group (and/or users) must be no more than 1000.</p>
    /// <p>You can download this <a href="https://docs.aws.amazon.com/kendra/latest/dg/samples/group_members.zip">example S3 file</a> that uses the correct format for listing group members. Note, <code>dataSourceId</code> is optional. The value of <code>type</code> for a group is always <code>GROUP</code> and for a user it is always <code>USER</code>.</p>
    pub fn s3_pathfor_group_members(&self) -> std::option::Option<&crate::model::S3Path> {
        self.s3_pathfor_group_members.as_ref()
    }
}
/// See [`GroupMembers`](crate::model::GroupMembers).
pub mod group_members {

    /// A builder for [`GroupMembers`](crate::model::GroupMembers).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) member_groups: std::option::Option<std::vec::Vec<crate::model::MemberGroup>>,
        pub(crate) member_users: std::option::Option<std::vec::Vec<crate::model::MemberUser>>,
        pub(crate) s3_pathfor_group_members: std::option::Option<crate::model::S3Path>,
    }
    impl Builder {
        /// Appends an item to `member_groups`.
        ///
        /// To override the contents of this collection use [`set_member_groups`](Self::set_member_groups).
        ///
        /// <p>A list of sub groups that belong to a group. For example, the sub groups "Research", "Engineering", and "Sales and Marketing" all belong to the group "Company".</p>
        pub fn member_groups(mut self, input: crate::model::MemberGroup) -> Self {
            let mut v = self.member_groups.unwrap_or_default();
            v.push(input);
            self.member_groups = Some(v);
            self
        }
        /// <p>A list of sub groups that belong to a group. For example, the sub groups "Research", "Engineering", and "Sales and Marketing" all belong to the group "Company".</p>
        pub fn set_member_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MemberGroup>>,
        ) -> Self {
            self.member_groups = input;
            self
        }
        /// Appends an item to `member_users`.
        ///
        /// To override the contents of this collection use [`set_member_users`](Self::set_member_users).
        ///
        /// <p>A list of users that belong to a group. For example, a list of interns all belong to the "Interns" group.</p>
        pub fn member_users(mut self, input: crate::model::MemberUser) -> Self {
            let mut v = self.member_users.unwrap_or_default();
            v.push(input);
            self.member_users = Some(v);
            self
        }
        /// <p>A list of users that belong to a group. For example, a list of interns all belong to the "Interns" group.</p>
        pub fn set_member_users(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MemberUser>>,
        ) -> Self {
            self.member_users = input;
            self
        }
        /// <p>If you have more than 1000 users and/or sub groups for a single group, you need to provide the path to the S3 file that lists your users and sub groups for a group. Your sub groups can contain more than 1000 users, but the list of sub groups that belong to a group (and/or users) must be no more than 1000.</p>
        /// <p>You can download this <a href="https://docs.aws.amazon.com/kendra/latest/dg/samples/group_members.zip">example S3 file</a> that uses the correct format for listing group members. Note, <code>dataSourceId</code> is optional. The value of <code>type</code> for a group is always <code>GROUP</code> and for a user it is always <code>USER</code>.</p>
        pub fn s3_pathfor_group_members(mut self, input: crate::model::S3Path) -> Self {
            self.s3_pathfor_group_members = Some(input);
            self
        }
        /// <p>If you have more than 1000 users and/or sub groups for a single group, you need to provide the path to the S3 file that lists your users and sub groups for a group. Your sub groups can contain more than 1000 users, but the list of sub groups that belong to a group (and/or users) must be no more than 1000.</p>
        /// <p>You can download this <a href="https://docs.aws.amazon.com/kendra/latest/dg/samples/group_members.zip">example S3 file</a> that uses the correct format for listing group members. Note, <code>dataSourceId</code> is optional. The value of <code>type</code> for a group is always <code>GROUP</code> and for a user it is always <code>USER</code>.</p>
        pub fn set_s3_pathfor_group_members(
            mut self,
            input: std::option::Option<crate::model::S3Path>,
        ) -> Self {
            self.s3_pathfor_group_members = input;
            self
        }
        /// Consumes the builder and constructs a [`GroupMembers`](crate::model::GroupMembers).
        pub fn build(self) -> crate::model::GroupMembers {
            crate::model::GroupMembers {
                member_groups: self.member_groups,
                member_users: self.member_users,
                s3_pathfor_group_members: self.s3_pathfor_group_members,
            }
        }
    }
}
impl GroupMembers {
    /// Creates a new builder-style object to manufacture [`GroupMembers`](crate::model::GroupMembers).
    pub fn builder() -> crate::model::group_members::Builder {
        crate::model::group_members::Builder::default()
    }
}

/// <p>The users that belong to a group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MemberUser {
    /// <p>The identifier of the user you want to map to a group.</p>
    #[doc(hidden)]
    pub user_id: std::option::Option<std::string::String>,
}
impl MemberUser {
    /// <p>The identifier of the user you want to map to a group.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
}
/// See [`MemberUser`](crate::model::MemberUser).
pub mod member_user {

    /// A builder for [`MemberUser`](crate::model::MemberUser).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the user you want to map to a group.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The identifier of the user you want to map to a group.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// Consumes the builder and constructs a [`MemberUser`](crate::model::MemberUser).
        pub fn build(self) -> crate::model::MemberUser {
            crate::model::MemberUser {
                user_id: self.user_id,
            }
        }
    }
}
impl MemberUser {
    /// Creates a new builder-style object to manufacture [`MemberUser`](crate::model::MemberUser).
    pub fn builder() -> crate::model::member_user::Builder {
        crate::model::member_user::Builder::default()
    }
}

/// <p>The sub groups that belong to a group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MemberGroup {
    /// <p>The identifier of the sub group you want to map to a group.</p>
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the data source for the sub group you want to map to a group.</p>
    #[doc(hidden)]
    pub data_source_id: std::option::Option<std::string::String>,
}
impl MemberGroup {
    /// <p>The identifier of the sub group you want to map to a group.</p>
    pub fn group_id(&self) -> std::option::Option<&str> {
        self.group_id.as_deref()
    }
    /// <p>The identifier of the data source for the sub group you want to map to a group.</p>
    pub fn data_source_id(&self) -> std::option::Option<&str> {
        self.data_source_id.as_deref()
    }
}
/// See [`MemberGroup`](crate::model::MemberGroup).
pub mod member_group {

    /// A builder for [`MemberGroup`](crate::model::MemberGroup).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) data_source_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the sub group you want to map to a group.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// <p>The identifier of the sub group you want to map to a group.</p>
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input;
            self
        }
        /// <p>The identifier of the data source for the sub group you want to map to a group.</p>
        pub fn data_source_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_source_id = Some(input.into());
            self
        }
        /// <p>The identifier of the data source for the sub group you want to map to a group.</p>
        pub fn set_data_source_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_source_id = input;
            self
        }
        /// Consumes the builder and constructs a [`MemberGroup`](crate::model::MemberGroup).
        pub fn build(self) -> crate::model::MemberGroup {
            crate::model::MemberGroup {
                group_id: self.group_id,
                data_source_id: self.data_source_id,
            }
        }
    }
}
impl MemberGroup {
    /// Creates a new builder-style object to manufacture [`MemberGroup`](crate::model::MemberGroup).
    pub fn builder() -> crate::model::member_group::Builder {
        crate::model::member_group::Builder::default()
    }
}

/// <p>An array of summary information for a thesaurus or multiple thesauri.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ThesaurusSummary {
    /// <p>The identifier of the thesaurus.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the thesaurus.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The status of the thesaurus.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ThesaurusStatus>,
    /// <p>The Unix datetime that the thesaurus was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The Unix datetime that the thesaurus was last updated.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl ThesaurusSummary {
    /// <p>The identifier of the thesaurus.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the thesaurus.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The status of the thesaurus.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ThesaurusStatus> {
        self.status.as_ref()
    }
    /// <p>The Unix datetime that the thesaurus was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The Unix datetime that the thesaurus was last updated.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
}
/// See [`ThesaurusSummary`](crate::model::ThesaurusSummary).
pub mod thesaurus_summary {

    /// A builder for [`ThesaurusSummary`](crate::model::ThesaurusSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ThesaurusStatus>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The identifier of the thesaurus.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the thesaurus.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the thesaurus.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the thesaurus.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The status of the thesaurus.</p>
        pub fn status(mut self, input: crate::model::ThesaurusStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the thesaurus.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ThesaurusStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The Unix datetime that the thesaurus was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The Unix datetime that the thesaurus was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The Unix datetime that the thesaurus was last updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The Unix datetime that the thesaurus was last updated.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// Consumes the builder and constructs a [`ThesaurusSummary`](crate::model::ThesaurusSummary).
        pub fn build(self) -> crate::model::ThesaurusSummary {
            crate::model::ThesaurusSummary {
                id: self.id,
                name: self.name,
                status: self.status,
                created_at: self.created_at,
                updated_at: self.updated_at,
            }
        }
    }
}
impl ThesaurusSummary {
    /// Creates a new builder-style object to manufacture [`ThesaurusSummary`](crate::model::ThesaurusSummary).
    pub fn builder() -> crate::model::thesaurus_summary::Builder {
        crate::model::thesaurus_summary::Builder::default()
    }
}

/// When writing a match expression against `ThesaurusStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let thesaurusstatus = unimplemented!();
/// match thesaurusstatus {
///     ThesaurusStatus::Active => { /* ... */ },
///     ThesaurusStatus::ActiveButUpdateFailed => { /* ... */ },
///     ThesaurusStatus::Creating => { /* ... */ },
///     ThesaurusStatus::Deleting => { /* ... */ },
///     ThesaurusStatus::Failed => { /* ... */ },
///     ThesaurusStatus::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `thesaurusstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ThesaurusStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ThesaurusStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ThesaurusStatus::NewFeature` is defined.
/// Specifically, when `thesaurusstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ThesaurusStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ThesaurusStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    ActiveButUpdateFailed,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ThesaurusStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => ThesaurusStatus::Active,
            "ACTIVE_BUT_UPDATE_FAILED" => ThesaurusStatus::ActiveButUpdateFailed,
            "CREATING" => ThesaurusStatus::Creating,
            "DELETING" => ThesaurusStatus::Deleting,
            "FAILED" => ThesaurusStatus::Failed,
            "UPDATING" => ThesaurusStatus::Updating,
            other => ThesaurusStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ThesaurusStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ThesaurusStatus::from(s))
    }
}
impl ThesaurusStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ThesaurusStatus::Active => "ACTIVE",
            ThesaurusStatus::ActiveButUpdateFailed => "ACTIVE_BUT_UPDATE_FAILED",
            ThesaurusStatus::Creating => "CREATING",
            ThesaurusStatus::Deleting => "DELETING",
            ThesaurusStatus::Failed => "FAILED",
            ThesaurusStatus::Updating => "UPDATING",
            ThesaurusStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACTIVE",
            "ACTIVE_BUT_UPDATE_FAILED",
            "CREATING",
            "DELETING",
            "FAILED",
            "UPDATING",
        ]
    }
}
impl AsRef<str> for ThesaurusStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary information on a query suggestions block list.</p>
/// <p>This includes information on the block list ID, block list name, when the block list was created, when the block list was last updated, and the count of block words/phrases in the block list.</p>
/// <p>For information on the current quota limits for block lists, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/quotas.html">Quotas for Amazon Kendra</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QuerySuggestionsBlockListSummary {
    /// <p>The identifier of a block list.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the block list.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The status of the block list.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::QuerySuggestionsBlockListStatus>,
    /// <p>The date-time summary information for a query suggestions block list was last created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date-time the block list was last updated.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The number of items in the block list file.</p>
    #[doc(hidden)]
    pub item_count: std::option::Option<i32>,
}
impl QuerySuggestionsBlockListSummary {
    /// <p>The identifier of a block list.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the block list.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The status of the block list.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::QuerySuggestionsBlockListStatus> {
        self.status.as_ref()
    }
    /// <p>The date-time summary information for a query suggestions block list was last created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The date-time the block list was last updated.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The number of items in the block list file.</p>
    pub fn item_count(&self) -> std::option::Option<i32> {
        self.item_count
    }
}
/// See [`QuerySuggestionsBlockListSummary`](crate::model::QuerySuggestionsBlockListSummary).
pub mod query_suggestions_block_list_summary {

    /// A builder for [`QuerySuggestionsBlockListSummary`](crate::model::QuerySuggestionsBlockListSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::QuerySuggestionsBlockListStatus>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) item_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The identifier of a block list.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of a block list.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the block list.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the block list.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The status of the block list.</p>
        pub fn status(mut self, input: crate::model::QuerySuggestionsBlockListStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the block list.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::QuerySuggestionsBlockListStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The date-time summary information for a query suggestions block list was last created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The date-time summary information for a query suggestions block list was last created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The date-time the block list was last updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The date-time the block list was last updated.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The number of items in the block list file.</p>
        pub fn item_count(mut self, input: i32) -> Self {
            self.item_count = Some(input);
            self
        }
        /// <p>The number of items in the block list file.</p>
        pub fn set_item_count(mut self, input: std::option::Option<i32>) -> Self {
            self.item_count = input;
            self
        }
        /// Consumes the builder and constructs a [`QuerySuggestionsBlockListSummary`](crate::model::QuerySuggestionsBlockListSummary).
        pub fn build(self) -> crate::model::QuerySuggestionsBlockListSummary {
            crate::model::QuerySuggestionsBlockListSummary {
                id: self.id,
                name: self.name,
                status: self.status,
                created_at: self.created_at,
                updated_at: self.updated_at,
                item_count: self.item_count,
            }
        }
    }
}
impl QuerySuggestionsBlockListSummary {
    /// Creates a new builder-style object to manufacture [`QuerySuggestionsBlockListSummary`](crate::model::QuerySuggestionsBlockListSummary).
    pub fn builder() -> crate::model::query_suggestions_block_list_summary::Builder {
        crate::model::query_suggestions_block_list_summary::Builder::default()
    }
}

/// When writing a match expression against `QuerySuggestionsBlockListStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let querysuggestionsblockliststatus = unimplemented!();
/// match querysuggestionsblockliststatus {
///     QuerySuggestionsBlockListStatus::Active => { /* ... */ },
///     QuerySuggestionsBlockListStatus::ActiveButUpdateFailed => { /* ... */ },
///     QuerySuggestionsBlockListStatus::Creating => { /* ... */ },
///     QuerySuggestionsBlockListStatus::Deleting => { /* ... */ },
///     QuerySuggestionsBlockListStatus::Failed => { /* ... */ },
///     QuerySuggestionsBlockListStatus::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `querysuggestionsblockliststatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `QuerySuggestionsBlockListStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `QuerySuggestionsBlockListStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `QuerySuggestionsBlockListStatus::NewFeature` is defined.
/// Specifically, when `querysuggestionsblockliststatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `QuerySuggestionsBlockListStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum QuerySuggestionsBlockListStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    ActiveButUpdateFailed,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for QuerySuggestionsBlockListStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => QuerySuggestionsBlockListStatus::Active,
            "ACTIVE_BUT_UPDATE_FAILED" => QuerySuggestionsBlockListStatus::ActiveButUpdateFailed,
            "CREATING" => QuerySuggestionsBlockListStatus::Creating,
            "DELETING" => QuerySuggestionsBlockListStatus::Deleting,
            "FAILED" => QuerySuggestionsBlockListStatus::Failed,
            "UPDATING" => QuerySuggestionsBlockListStatus::Updating,
            other => QuerySuggestionsBlockListStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for QuerySuggestionsBlockListStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(QuerySuggestionsBlockListStatus::from(s))
    }
}
impl QuerySuggestionsBlockListStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            QuerySuggestionsBlockListStatus::Active => "ACTIVE",
            QuerySuggestionsBlockListStatus::ActiveButUpdateFailed => "ACTIVE_BUT_UPDATE_FAILED",
            QuerySuggestionsBlockListStatus::Creating => "CREATING",
            QuerySuggestionsBlockListStatus::Deleting => "DELETING",
            QuerySuggestionsBlockListStatus::Failed => "FAILED",
            QuerySuggestionsBlockListStatus::Updating => "UPDATING",
            QuerySuggestionsBlockListStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACTIVE",
            "ACTIVE_BUT_UPDATE_FAILED",
            "CREATING",
            "DELETING",
            "FAILED",
            "UPDATING",
        ]
    }
}
impl AsRef<str> for QuerySuggestionsBlockListStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary information on the configuration of an index.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IndexConfigurationSummary {
    /// <p>The name of the index.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A identifier for the index. Use this to identify the index when you are using APIs such as <code>Query</code>, <code>DescribeIndex</code>, <code>UpdateIndex</code>, and <code>DeleteIndex</code>.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>Indicates whether the index is a Enterprise Edition index or a Developer Edition index. </p>
    #[doc(hidden)]
    pub edition: std::option::Option<crate::model::IndexEdition>,
    /// <p>The Unix timestamp when the index was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The Unix timestamp when the index was last updated by the <code>UpdateIndex</code> API.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The current status of the index. When the status is <code>ACTIVE</code>, the index is ready to search.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::IndexStatus>,
}
impl IndexConfigurationSummary {
    /// <p>The name of the index.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A identifier for the index. Use this to identify the index when you are using APIs such as <code>Query</code>, <code>DescribeIndex</code>, <code>UpdateIndex</code>, and <code>DeleteIndex</code>.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>Indicates whether the index is a Enterprise Edition index or a Developer Edition index. </p>
    pub fn edition(&self) -> std::option::Option<&crate::model::IndexEdition> {
        self.edition.as_ref()
    }
    /// <p>The Unix timestamp when the index was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The Unix timestamp when the index was last updated by the <code>UpdateIndex</code> API.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The current status of the index. When the status is <code>ACTIVE</code>, the index is ready to search.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::IndexStatus> {
        self.status.as_ref()
    }
}
/// See [`IndexConfigurationSummary`](crate::model::IndexConfigurationSummary).
pub mod index_configuration_summary {

    /// A builder for [`IndexConfigurationSummary`](crate::model::IndexConfigurationSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) edition: std::option::Option<crate::model::IndexEdition>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status: std::option::Option<crate::model::IndexStatus>,
    }
    impl Builder {
        /// <p>The name of the index.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the index.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A identifier for the index. Use this to identify the index when you are using APIs such as <code>Query</code>, <code>DescribeIndex</code>, <code>UpdateIndex</code>, and <code>DeleteIndex</code>.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>A identifier for the index. Use this to identify the index when you are using APIs such as <code>Query</code>, <code>DescribeIndex</code>, <code>UpdateIndex</code>, and <code>DeleteIndex</code>.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>Indicates whether the index is a Enterprise Edition index or a Developer Edition index. </p>
        pub fn edition(mut self, input: crate::model::IndexEdition) -> Self {
            self.edition = Some(input);
            self
        }
        /// <p>Indicates whether the index is a Enterprise Edition index or a Developer Edition index. </p>
        pub fn set_edition(
            mut self,
            input: std::option::Option<crate::model::IndexEdition>,
        ) -> Self {
            self.edition = input;
            self
        }
        /// <p>The Unix timestamp when the index was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The Unix timestamp when the index was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The Unix timestamp when the index was last updated by the <code>UpdateIndex</code> API.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The Unix timestamp when the index was last updated by the <code>UpdateIndex</code> API.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The current status of the index. When the status is <code>ACTIVE</code>, the index is ready to search.</p>
        pub fn status(mut self, input: crate::model::IndexStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the index. When the status is <code>ACTIVE</code>, the index is ready to search.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::IndexStatus>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`IndexConfigurationSummary`](crate::model::IndexConfigurationSummary).
        pub fn build(self) -> crate::model::IndexConfigurationSummary {
            crate::model::IndexConfigurationSummary {
                name: self.name,
                id: self.id,
                edition: self.edition,
                created_at: self.created_at,
                updated_at: self.updated_at,
                status: self.status,
            }
        }
    }
}
impl IndexConfigurationSummary {
    /// Creates a new builder-style object to manufacture [`IndexConfigurationSummary`](crate::model::IndexConfigurationSummary).
    pub fn builder() -> crate::model::index_configuration_summary::Builder {
        crate::model::index_configuration_summary::Builder::default()
    }
}

/// When writing a match expression against `IndexStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let indexstatus = unimplemented!();
/// match indexstatus {
///     IndexStatus::Active => { /* ... */ },
///     IndexStatus::Creating => { /* ... */ },
///     IndexStatus::Deleting => { /* ... */ },
///     IndexStatus::Failed => { /* ... */ },
///     IndexStatus::SystemUpdating => { /* ... */ },
///     IndexStatus::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `indexstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `IndexStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `IndexStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `IndexStatus::NewFeature` is defined.
/// Specifically, when `indexstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `IndexStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum IndexStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    SystemUpdating,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for IndexStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => IndexStatus::Active,
            "CREATING" => IndexStatus::Creating,
            "DELETING" => IndexStatus::Deleting,
            "FAILED" => IndexStatus::Failed,
            "SYSTEM_UPDATING" => IndexStatus::SystemUpdating,
            "UPDATING" => IndexStatus::Updating,
            other => IndexStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for IndexStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(IndexStatus::from(s))
    }
}
impl IndexStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            IndexStatus::Active => "ACTIVE",
            IndexStatus::Creating => "CREATING",
            IndexStatus::Deleting => "DELETING",
            IndexStatus::Failed => "FAILED",
            IndexStatus::SystemUpdating => "SYSTEM_UPDATING",
            IndexStatus::Updating => "UPDATING",
            IndexStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACTIVE",
            "CREATING",
            "DELETING",
            "FAILED",
            "SYSTEM_UPDATING",
            "UPDATING",
        ]
    }
}
impl AsRef<str> for IndexStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `IndexEdition`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let indexedition = unimplemented!();
/// match indexedition {
///     IndexEdition::DeveloperEdition => { /* ... */ },
///     IndexEdition::EnterpriseEdition => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `indexedition` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `IndexEdition::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `IndexEdition::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `IndexEdition::NewFeature` is defined.
/// Specifically, when `indexedition` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `IndexEdition::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum IndexEdition {
    #[allow(missing_docs)] // documentation missing in model
    DeveloperEdition,
    #[allow(missing_docs)] // documentation missing in model
    EnterpriseEdition,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for IndexEdition {
    fn from(s: &str) -> Self {
        match s {
            "DEVELOPER_EDITION" => IndexEdition::DeveloperEdition,
            "ENTERPRISE_EDITION" => IndexEdition::EnterpriseEdition,
            other => IndexEdition::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for IndexEdition {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(IndexEdition::from(s))
    }
}
impl IndexEdition {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            IndexEdition::DeveloperEdition => "DEVELOPER_EDITION",
            IndexEdition::EnterpriseEdition => "ENTERPRISE_EDITION",
            IndexEdition::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DEVELOPER_EDITION", "ENTERPRISE_EDITION"]
    }
}
impl AsRef<str> for IndexEdition {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary information for groups.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GroupSummary {
    /// <p>The identifier of the group you want group summary information on.</p>
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
    /// <p>The timestamp identifier used for the latest <code>PUT</code> or <code>DELETE</code> action.</p>
    #[doc(hidden)]
    pub ordering_id: std::option::Option<i64>,
}
impl GroupSummary {
    /// <p>The identifier of the group you want group summary information on.</p>
    pub fn group_id(&self) -> std::option::Option<&str> {
        self.group_id.as_deref()
    }
    /// <p>The timestamp identifier used for the latest <code>PUT</code> or <code>DELETE</code> action.</p>
    pub fn ordering_id(&self) -> std::option::Option<i64> {
        self.ordering_id
    }
}
/// See [`GroupSummary`](crate::model::GroupSummary).
pub mod group_summary {

    /// A builder for [`GroupSummary`](crate::model::GroupSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) ordering_id: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The identifier of the group you want group summary information on.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// <p>The identifier of the group you want group summary information on.</p>
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input;
            self
        }
        /// <p>The timestamp identifier used for the latest <code>PUT</code> or <code>DELETE</code> action.</p>
        pub fn ordering_id(mut self, input: i64) -> Self {
            self.ordering_id = Some(input);
            self
        }
        /// <p>The timestamp identifier used for the latest <code>PUT</code> or <code>DELETE</code> action.</p>
        pub fn set_ordering_id(mut self, input: std::option::Option<i64>) -> Self {
            self.ordering_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GroupSummary`](crate::model::GroupSummary).
        pub fn build(self) -> crate::model::GroupSummary {
            crate::model::GroupSummary {
                group_id: self.group_id,
                ordering_id: self.ordering_id,
            }
        }
    }
}
impl GroupSummary {
    /// Creates a new builder-style object to manufacture [`GroupSummary`](crate::model::GroupSummary).
    pub fn builder() -> crate::model::group_summary::Builder {
        crate::model::group_summary::Builder::default()
    }
}

/// <p>Summary information for frequently asked questions and answers included in an index.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FaqSummary {
    /// <p>The identifier of the FAQ.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name that you assigned the FAQ when you created or updated the FAQ.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The current status of the FAQ. When the status is <code>ACTIVE</code> the FAQ is ready for use.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::FaqStatus>,
    /// <p>The UNIX datetime that the FAQ was added to the index.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The UNIX datetime that the FAQ was last updated.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The file type used to create the FAQ. </p>
    #[doc(hidden)]
    pub file_format: std::option::Option<crate::model::FaqFileFormat>,
    /// <p>The code for a language. This shows a supported language for the FAQ document as part of the summary information for FAQs. English is supported by default. For more information on supported languages, including their codes, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/in-adding-languages.html">Adding documents in languages other than English</a>.</p>
    #[doc(hidden)]
    pub language_code: std::option::Option<std::string::String>,
}
impl FaqSummary {
    /// <p>The identifier of the FAQ.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name that you assigned the FAQ when you created or updated the FAQ.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The current status of the FAQ. When the status is <code>ACTIVE</code> the FAQ is ready for use.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::FaqStatus> {
        self.status.as_ref()
    }
    /// <p>The UNIX datetime that the FAQ was added to the index.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The UNIX datetime that the FAQ was last updated.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The file type used to create the FAQ. </p>
    pub fn file_format(&self) -> std::option::Option<&crate::model::FaqFileFormat> {
        self.file_format.as_ref()
    }
    /// <p>The code for a language. This shows a supported language for the FAQ document as part of the summary information for FAQs. English is supported by default. For more information on supported languages, including their codes, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/in-adding-languages.html">Adding documents in languages other than English</a>.</p>
    pub fn language_code(&self) -> std::option::Option<&str> {
        self.language_code.as_deref()
    }
}
/// See [`FaqSummary`](crate::model::FaqSummary).
pub mod faq_summary {

    /// A builder for [`FaqSummary`](crate::model::FaqSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::FaqStatus>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) file_format: std::option::Option<crate::model::FaqFileFormat>,
        pub(crate) language_code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the FAQ.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the FAQ.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name that you assigned the FAQ when you created or updated the FAQ.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name that you assigned the FAQ when you created or updated the FAQ.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The current status of the FAQ. When the status is <code>ACTIVE</code> the FAQ is ready for use.</p>
        pub fn status(mut self, input: crate::model::FaqStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the FAQ. When the status is <code>ACTIVE</code> the FAQ is ready for use.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::FaqStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>The UNIX datetime that the FAQ was added to the index.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The UNIX datetime that the FAQ was added to the index.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The UNIX datetime that the FAQ was last updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The UNIX datetime that the FAQ was last updated.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The file type used to create the FAQ. </p>
        pub fn file_format(mut self, input: crate::model::FaqFileFormat) -> Self {
            self.file_format = Some(input);
            self
        }
        /// <p>The file type used to create the FAQ. </p>
        pub fn set_file_format(
            mut self,
            input: std::option::Option<crate::model::FaqFileFormat>,
        ) -> Self {
            self.file_format = input;
            self
        }
        /// <p>The code for a language. This shows a supported language for the FAQ document as part of the summary information for FAQs. English is supported by default. For more information on supported languages, including their codes, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/in-adding-languages.html">Adding documents in languages other than English</a>.</p>
        pub fn language_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.language_code = Some(input.into());
            self
        }
        /// <p>The code for a language. This shows a supported language for the FAQ document as part of the summary information for FAQs. English is supported by default. For more information on supported languages, including their codes, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/in-adding-languages.html">Adding documents in languages other than English</a>.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// Consumes the builder and constructs a [`FaqSummary`](crate::model::FaqSummary).
        pub fn build(self) -> crate::model::FaqSummary {
            crate::model::FaqSummary {
                id: self.id,
                name: self.name,
                status: self.status,
                created_at: self.created_at,
                updated_at: self.updated_at,
                file_format: self.file_format,
                language_code: self.language_code,
            }
        }
    }
}
impl FaqSummary {
    /// Creates a new builder-style object to manufacture [`FaqSummary`](crate::model::FaqSummary).
    pub fn builder() -> crate::model::faq_summary::Builder {
        crate::model::faq_summary::Builder::default()
    }
}

/// When writing a match expression against `FaqFileFormat`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let faqfileformat = unimplemented!();
/// match faqfileformat {
///     FaqFileFormat::Csv => { /* ... */ },
///     FaqFileFormat::CsvWithHeader => { /* ... */ },
///     FaqFileFormat::Json => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `faqfileformat` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FaqFileFormat::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FaqFileFormat::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FaqFileFormat::NewFeature` is defined.
/// Specifically, when `faqfileformat` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FaqFileFormat::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FaqFileFormat {
    #[allow(missing_docs)] // documentation missing in model
    Csv,
    #[allow(missing_docs)] // documentation missing in model
    CsvWithHeader,
    #[allow(missing_docs)] // documentation missing in model
    Json,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FaqFileFormat {
    fn from(s: &str) -> Self {
        match s {
            "CSV" => FaqFileFormat::Csv,
            "CSV_WITH_HEADER" => FaqFileFormat::CsvWithHeader,
            "JSON" => FaqFileFormat::Json,
            other => FaqFileFormat::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FaqFileFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FaqFileFormat::from(s))
    }
}
impl FaqFileFormat {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FaqFileFormat::Csv => "CSV",
            FaqFileFormat::CsvWithHeader => "CSV_WITH_HEADER",
            FaqFileFormat::Json => "JSON",
            FaqFileFormat::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CSV", "CSV_WITH_HEADER", "JSON"]
    }
}
impl AsRef<str> for FaqFileFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `FaqStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let faqstatus = unimplemented!();
/// match faqstatus {
///     FaqStatus::Active => { /* ... */ },
///     FaqStatus::Creating => { /* ... */ },
///     FaqStatus::Deleting => { /* ... */ },
///     FaqStatus::Failed => { /* ... */ },
///     FaqStatus::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `faqstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FaqStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FaqStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FaqStatus::NewFeature` is defined.
/// Specifically, when `faqstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FaqStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FaqStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FaqStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => FaqStatus::Active,
            "CREATING" => FaqStatus::Creating,
            "DELETING" => FaqStatus::Deleting,
            "FAILED" => FaqStatus::Failed,
            "UPDATING" => FaqStatus::Updating,
            other => FaqStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FaqStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FaqStatus::from(s))
    }
}
impl FaqStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FaqStatus::Active => "ACTIVE",
            FaqStatus::Creating => "CREATING",
            FaqStatus::Deleting => "DELETING",
            FaqStatus::Failed => "FAILED",
            FaqStatus::Updating => "UPDATING",
            FaqStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "CREATING", "DELETING", "FAILED", "UPDATING"]
    }
}
impl AsRef<str> for FaqStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary information for your Amazon Kendra experience. You can create an Amazon Kendra experience such as a search application. For more information on creating a search application experience, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/deploying-search-experience-no-code.html">Building a search experience with no code</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExperiencesSummary {
    /// <p>The name of your Amazon Kendra experience.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The identifier of your Amazon Kendra experience.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The date-time your Amazon Kendra experience was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The processing status of your Amazon Kendra experience.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ExperienceStatus>,
    /// <p>The endpoint URLs for your Amazon Kendra experiences. The URLs are unique and fully hosted by Amazon Web Services.</p>
    #[doc(hidden)]
    pub endpoints: std::option::Option<std::vec::Vec<crate::model::ExperienceEndpoint>>,
}
impl ExperiencesSummary {
    /// <p>The name of your Amazon Kendra experience.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The identifier of your Amazon Kendra experience.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The date-time your Amazon Kendra experience was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The processing status of your Amazon Kendra experience.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ExperienceStatus> {
        self.status.as_ref()
    }
    /// <p>The endpoint URLs for your Amazon Kendra experiences. The URLs are unique and fully hosted by Amazon Web Services.</p>
    pub fn endpoints(&self) -> std::option::Option<&[crate::model::ExperienceEndpoint]> {
        self.endpoints.as_deref()
    }
}
/// See [`ExperiencesSummary`](crate::model::ExperiencesSummary).
pub mod experiences_summary {

    /// A builder for [`ExperiencesSummary`](crate::model::ExperiencesSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status: std::option::Option<crate::model::ExperienceStatus>,
        pub(crate) endpoints: std::option::Option<std::vec::Vec<crate::model::ExperienceEndpoint>>,
    }
    impl Builder {
        /// <p>The name of your Amazon Kendra experience.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of your Amazon Kendra experience.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The identifier of your Amazon Kendra experience.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of your Amazon Kendra experience.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The date-time your Amazon Kendra experience was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The date-time your Amazon Kendra experience was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The processing status of your Amazon Kendra experience.</p>
        pub fn status(mut self, input: crate::model::ExperienceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The processing status of your Amazon Kendra experience.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ExperienceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Appends an item to `endpoints`.
        ///
        /// To override the contents of this collection use [`set_endpoints`](Self::set_endpoints).
        ///
        /// <p>The endpoint URLs for your Amazon Kendra experiences. The URLs are unique and fully hosted by Amazon Web Services.</p>
        pub fn endpoints(mut self, input: crate::model::ExperienceEndpoint) -> Self {
            let mut v = self.endpoints.unwrap_or_default();
            v.push(input);
            self.endpoints = Some(v);
            self
        }
        /// <p>The endpoint URLs for your Amazon Kendra experiences. The URLs are unique and fully hosted by Amazon Web Services.</p>
        pub fn set_endpoints(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ExperienceEndpoint>>,
        ) -> Self {
            self.endpoints = input;
            self
        }
        /// Consumes the builder and constructs a [`ExperiencesSummary`](crate::model::ExperiencesSummary).
        pub fn build(self) -> crate::model::ExperiencesSummary {
            crate::model::ExperiencesSummary {
                name: self.name,
                id: self.id,
                created_at: self.created_at,
                status: self.status,
                endpoints: self.endpoints,
            }
        }
    }
}
impl ExperiencesSummary {
    /// Creates a new builder-style object to manufacture [`ExperiencesSummary`](crate::model::ExperiencesSummary).
    pub fn builder() -> crate::model::experiences_summary::Builder {
        crate::model::experiences_summary::Builder::default()
    }
}

/// <p>Provides the configuration information for the endpoint for your Amazon Kendra experience.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExperienceEndpoint {
    /// <p>The type of endpoint for your Amazon Kendra experience. The type currently available is <code>HOME</code>, which is a unique and fully hosted URL to the home page of your Amazon Kendra experience.</p>
    #[doc(hidden)]
    pub endpoint_type: std::option::Option<crate::model::EndpointType>,
    /// <p>The endpoint of your Amazon Kendra experience.</p>
    #[doc(hidden)]
    pub endpoint: std::option::Option<std::string::String>,
}
impl ExperienceEndpoint {
    /// <p>The type of endpoint for your Amazon Kendra experience. The type currently available is <code>HOME</code>, which is a unique and fully hosted URL to the home page of your Amazon Kendra experience.</p>
    pub fn endpoint_type(&self) -> std::option::Option<&crate::model::EndpointType> {
        self.endpoint_type.as_ref()
    }
    /// <p>The endpoint of your Amazon Kendra experience.</p>
    pub fn endpoint(&self) -> std::option::Option<&str> {
        self.endpoint.as_deref()
    }
}
/// See [`ExperienceEndpoint`](crate::model::ExperienceEndpoint).
pub mod experience_endpoint {

    /// A builder for [`ExperienceEndpoint`](crate::model::ExperienceEndpoint).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_type: std::option::Option<crate::model::EndpointType>,
        pub(crate) endpoint: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of endpoint for your Amazon Kendra experience. The type currently available is <code>HOME</code>, which is a unique and fully hosted URL to the home page of your Amazon Kendra experience.</p>
        pub fn endpoint_type(mut self, input: crate::model::EndpointType) -> Self {
            self.endpoint_type = Some(input);
            self
        }
        /// <p>The type of endpoint for your Amazon Kendra experience. The type currently available is <code>HOME</code>, which is a unique and fully hosted URL to the home page of your Amazon Kendra experience.</p>
        pub fn set_endpoint_type(
            mut self,
            input: std::option::Option<crate::model::EndpointType>,
        ) -> Self {
            self.endpoint_type = input;
            self
        }
        /// <p>The endpoint of your Amazon Kendra experience.</p>
        pub fn endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint = Some(input.into());
            self
        }
        /// <p>The endpoint of your Amazon Kendra experience.</p>
        pub fn set_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint = input;
            self
        }
        /// Consumes the builder and constructs a [`ExperienceEndpoint`](crate::model::ExperienceEndpoint).
        pub fn build(self) -> crate::model::ExperienceEndpoint {
            crate::model::ExperienceEndpoint {
                endpoint_type: self.endpoint_type,
                endpoint: self.endpoint,
            }
        }
    }
}
impl ExperienceEndpoint {
    /// Creates a new builder-style object to manufacture [`ExperienceEndpoint`](crate::model::ExperienceEndpoint).
    pub fn builder() -> crate::model::experience_endpoint::Builder {
        crate::model::experience_endpoint::Builder::default()
    }
}

/// When writing a match expression against `EndpointType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let endpointtype = unimplemented!();
/// match endpointtype {
///     EndpointType::Home => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `endpointtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EndpointType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EndpointType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EndpointType::NewFeature` is defined.
/// Specifically, when `endpointtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EndpointType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EndpointType {
    #[allow(missing_docs)] // documentation missing in model
    Home,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EndpointType {
    fn from(s: &str) -> Self {
        match s {
            "HOME" => EndpointType::Home,
            other => EndpointType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EndpointType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EndpointType::from(s))
    }
}
impl EndpointType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EndpointType::Home => "HOME",
            EndpointType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["HOME"]
    }
}
impl AsRef<str> for EndpointType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ExperienceStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let experiencestatus = unimplemented!();
/// match experiencestatus {
///     ExperienceStatus::Active => { /* ... */ },
///     ExperienceStatus::Creating => { /* ... */ },
///     ExperienceStatus::Deleting => { /* ... */ },
///     ExperienceStatus::Failed => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `experiencestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ExperienceStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ExperienceStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ExperienceStatus::NewFeature` is defined.
/// Specifically, when `experiencestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ExperienceStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ExperienceStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ExperienceStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => ExperienceStatus::Active,
            "CREATING" => ExperienceStatus::Creating,
            "DELETING" => ExperienceStatus::Deleting,
            "FAILED" => ExperienceStatus::Failed,
            other => ExperienceStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ExperienceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ExperienceStatus::from(s))
    }
}
impl ExperienceStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ExperienceStatus::Active => "ACTIVE",
            ExperienceStatus::Creating => "CREATING",
            ExperienceStatus::Deleting => "DELETING",
            ExperienceStatus::Failed => "FAILED",
            ExperienceStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "CREATING", "DELETING", "FAILED"]
    }
}
impl AsRef<str> for ExperienceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary information for users or groups in your IAM Identity Center identity source with granted access to your Amazon Kendra experience. You can create an Amazon Kendra experience such as a search application. For more information on creating a search application experience, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/deploying-search-experience-no-code.html">Building a search experience with no code</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExperienceEntitiesSummary {
    /// <p>The identifier of a user or group in your IAM Identity Center identity source. For example, a user ID could be an email.</p>
    #[doc(hidden)]
    pub entity_id: std::option::Option<std::string::String>,
    /// <p>Shows the type as <code>User</code> or <code>Group</code>.</p>
    #[doc(hidden)]
    pub entity_type: std::option::Option<crate::model::EntityType>,
    /// <p>Information about the user entity.</p>
    #[doc(hidden)]
    pub display_data: std::option::Option<crate::model::EntityDisplayData>,
}
impl ExperienceEntitiesSummary {
    /// <p>The identifier of a user or group in your IAM Identity Center identity source. For example, a user ID could be an email.</p>
    pub fn entity_id(&self) -> std::option::Option<&str> {
        self.entity_id.as_deref()
    }
    /// <p>Shows the type as <code>User</code> or <code>Group</code>.</p>
    pub fn entity_type(&self) -> std::option::Option<&crate::model::EntityType> {
        self.entity_type.as_ref()
    }
    /// <p>Information about the user entity.</p>
    pub fn display_data(&self) -> std::option::Option<&crate::model::EntityDisplayData> {
        self.display_data.as_ref()
    }
}
/// See [`ExperienceEntitiesSummary`](crate::model::ExperienceEntitiesSummary).
pub mod experience_entities_summary {

    /// A builder for [`ExperienceEntitiesSummary`](crate::model::ExperienceEntitiesSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entity_id: std::option::Option<std::string::String>,
        pub(crate) entity_type: std::option::Option<crate::model::EntityType>,
        pub(crate) display_data: std::option::Option<crate::model::EntityDisplayData>,
    }
    impl Builder {
        /// <p>The identifier of a user or group in your IAM Identity Center identity source. For example, a user ID could be an email.</p>
        pub fn entity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entity_id = Some(input.into());
            self
        }
        /// <p>The identifier of a user or group in your IAM Identity Center identity source. For example, a user ID could be an email.</p>
        pub fn set_entity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entity_id = input;
            self
        }
        /// <p>Shows the type as <code>User</code> or <code>Group</code>.</p>
        pub fn entity_type(mut self, input: crate::model::EntityType) -> Self {
            self.entity_type = Some(input);
            self
        }
        /// <p>Shows the type as <code>User</code> or <code>Group</code>.</p>
        pub fn set_entity_type(
            mut self,
            input: std::option::Option<crate::model::EntityType>,
        ) -> Self {
            self.entity_type = input;
            self
        }
        /// <p>Information about the user entity.</p>
        pub fn display_data(mut self, input: crate::model::EntityDisplayData) -> Self {
            self.display_data = Some(input);
            self
        }
        /// <p>Information about the user entity.</p>
        pub fn set_display_data(
            mut self,
            input: std::option::Option<crate::model::EntityDisplayData>,
        ) -> Self {
            self.display_data = input;
            self
        }
        /// Consumes the builder and constructs a [`ExperienceEntitiesSummary`](crate::model::ExperienceEntitiesSummary).
        pub fn build(self) -> crate::model::ExperienceEntitiesSummary {
            crate::model::ExperienceEntitiesSummary {
                entity_id: self.entity_id,
                entity_type: self.entity_type,
                display_data: self.display_data,
            }
        }
    }
}
impl ExperienceEntitiesSummary {
    /// Creates a new builder-style object to manufacture [`ExperienceEntitiesSummary`](crate::model::ExperienceEntitiesSummary).
    pub fn builder() -> crate::model::experience_entities_summary::Builder {
        crate::model::experience_entities_summary::Builder::default()
    }
}

/// <p>Information about the user entity.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EntityDisplayData {
    /// <p>The name of the user.</p>
    #[doc(hidden)]
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The name of the group.</p>
    #[doc(hidden)]
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The user name of the user.</p>
    #[doc(hidden)]
    pub identified_user_name: std::option::Option<std::string::String>,
    /// <p>The first name of the user.</p>
    #[doc(hidden)]
    pub first_name: std::option::Option<std::string::String>,
    /// <p>The last name of the user.</p>
    #[doc(hidden)]
    pub last_name: std::option::Option<std::string::String>,
}
impl EntityDisplayData {
    /// <p>The name of the user.</p>
    pub fn user_name(&self) -> std::option::Option<&str> {
        self.user_name.as_deref()
    }
    /// <p>The name of the group.</p>
    pub fn group_name(&self) -> std::option::Option<&str> {
        self.group_name.as_deref()
    }
    /// <p>The user name of the user.</p>
    pub fn identified_user_name(&self) -> std::option::Option<&str> {
        self.identified_user_name.as_deref()
    }
    /// <p>The first name of the user.</p>
    pub fn first_name(&self) -> std::option::Option<&str> {
        self.first_name.as_deref()
    }
    /// <p>The last name of the user.</p>
    pub fn last_name(&self) -> std::option::Option<&str> {
        self.last_name.as_deref()
    }
}
impl std::fmt::Debug for EntityDisplayData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EntityDisplayData");
        formatter.field("user_name", &"*** Sensitive Data Redacted ***");
        formatter.field("group_name", &"*** Sensitive Data Redacted ***");
        formatter.field("identified_user_name", &"*** Sensitive Data Redacted ***");
        formatter.field("first_name", &"*** Sensitive Data Redacted ***");
        formatter.field("last_name", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`EntityDisplayData`](crate::model::EntityDisplayData).
pub mod entity_display_data {

    /// A builder for [`EntityDisplayData`](crate::model::EntityDisplayData).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) identified_user_name: std::option::Option<std::string::String>,
        pub(crate) first_name: std::option::Option<std::string::String>,
        pub(crate) last_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the user.</p>
        pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_name = Some(input.into());
            self
        }
        /// <p>The name of the user.</p>
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_name = input;
            self
        }
        /// <p>The name of the group.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        /// <p>The name of the group.</p>
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// <p>The user name of the user.</p>
        pub fn identified_user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.identified_user_name = Some(input.into());
            self
        }
        /// <p>The user name of the user.</p>
        pub fn set_identified_user_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.identified_user_name = input;
            self
        }
        /// <p>The first name of the user.</p>
        pub fn first_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.first_name = Some(input.into());
            self
        }
        /// <p>The first name of the user.</p>
        pub fn set_first_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.first_name = input;
            self
        }
        /// <p>The last name of the user.</p>
        pub fn last_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_name = Some(input.into());
            self
        }
        /// <p>The last name of the user.</p>
        pub fn set_last_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.last_name = input;
            self
        }
        /// Consumes the builder and constructs a [`EntityDisplayData`](crate::model::EntityDisplayData).
        pub fn build(self) -> crate::model::EntityDisplayData {
            crate::model::EntityDisplayData {
                user_name: self.user_name,
                group_name: self.group_name,
                identified_user_name: self.identified_user_name,
                first_name: self.first_name,
                last_name: self.last_name,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("user_name", &"*** Sensitive Data Redacted ***");
            formatter.field("group_name", &"*** Sensitive Data Redacted ***");
            formatter.field("identified_user_name", &"*** Sensitive Data Redacted ***");
            formatter.field("first_name", &"*** Sensitive Data Redacted ***");
            formatter.field("last_name", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl EntityDisplayData {
    /// Creates a new builder-style object to manufacture [`EntityDisplayData`](crate::model::EntityDisplayData).
    pub fn builder() -> crate::model::entity_display_data::Builder {
        crate::model::entity_display_data::Builder::default()
    }
}

/// When writing a match expression against `EntityType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let entitytype = unimplemented!();
/// match entitytype {
///     EntityType::Group => { /* ... */ },
///     EntityType::User => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `entitytype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EntityType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EntityType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EntityType::NewFeature` is defined.
/// Specifically, when `entitytype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EntityType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EntityType {
    #[allow(missing_docs)] // documentation missing in model
    Group,
    #[allow(missing_docs)] // documentation missing in model
    User,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EntityType {
    fn from(s: &str) -> Self {
        match s {
            "GROUP" => EntityType::Group,
            "USER" => EntityType::User,
            other => EntityType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EntityType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EntityType::from(s))
    }
}
impl EntityType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EntityType::Group => "GROUP",
            EntityType::User => "USER",
            EntityType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["GROUP", "USER"]
    }
}
impl AsRef<str> for EntityType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary information for users or groups in your IAM Identity Center identity source. This applies to users and groups with specific permissions that define their level of access to your Amazon Kendra experience. You can create an Amazon Kendra experience such as a search application. For more information on creating a search application experience, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/deploying-search-experience-no-code.html">Building a search experience with no code</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PersonasSummary {
    /// <p>The identifier of a user or group in your IAM Identity Center identity source. For example, a user ID could be an email.</p>
    #[doc(hidden)]
    pub entity_id: std::option::Option<std::string::String>,
    /// <p>The persona that defines the specific permissions of the user or group in your IAM Identity Center identity source. The available personas or access roles are <code>Owner</code> and <code>Viewer</code>. For more information on these personas, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/deploying-search-experience-no-code.html#access-search-experience">Providing access to your search page</a>.</p>
    #[doc(hidden)]
    pub persona: std::option::Option<crate::model::Persona>,
    /// <p>The date-time the summary information was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date-time the summary information was last updated.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl PersonasSummary {
    /// <p>The identifier of a user or group in your IAM Identity Center identity source. For example, a user ID could be an email.</p>
    pub fn entity_id(&self) -> std::option::Option<&str> {
        self.entity_id.as_deref()
    }
    /// <p>The persona that defines the specific permissions of the user or group in your IAM Identity Center identity source. The available personas or access roles are <code>Owner</code> and <code>Viewer</code>. For more information on these personas, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/deploying-search-experience-no-code.html#access-search-experience">Providing access to your search page</a>.</p>
    pub fn persona(&self) -> std::option::Option<&crate::model::Persona> {
        self.persona.as_ref()
    }
    /// <p>The date-time the summary information was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The date-time the summary information was last updated.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
}
/// See [`PersonasSummary`](crate::model::PersonasSummary).
pub mod personas_summary {

    /// A builder for [`PersonasSummary`](crate::model::PersonasSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entity_id: std::option::Option<std::string::String>,
        pub(crate) persona: std::option::Option<crate::model::Persona>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The identifier of a user or group in your IAM Identity Center identity source. For example, a user ID could be an email.</p>
        pub fn entity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entity_id = Some(input.into());
            self
        }
        /// <p>The identifier of a user or group in your IAM Identity Center identity source. For example, a user ID could be an email.</p>
        pub fn set_entity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entity_id = input;
            self
        }
        /// <p>The persona that defines the specific permissions of the user or group in your IAM Identity Center identity source. The available personas or access roles are <code>Owner</code> and <code>Viewer</code>. For more information on these personas, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/deploying-search-experience-no-code.html#access-search-experience">Providing access to your search page</a>.</p>
        pub fn persona(mut self, input: crate::model::Persona) -> Self {
            self.persona = Some(input);
            self
        }
        /// <p>The persona that defines the specific permissions of the user or group in your IAM Identity Center identity source. The available personas or access roles are <code>Owner</code> and <code>Viewer</code>. For more information on these personas, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/deploying-search-experience-no-code.html#access-search-experience">Providing access to your search page</a>.</p>
        pub fn set_persona(mut self, input: std::option::Option<crate::model::Persona>) -> Self {
            self.persona = input;
            self
        }
        /// <p>The date-time the summary information was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The date-time the summary information was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The date-time the summary information was last updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The date-time the summary information was last updated.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// Consumes the builder and constructs a [`PersonasSummary`](crate::model::PersonasSummary).
        pub fn build(self) -> crate::model::PersonasSummary {
            crate::model::PersonasSummary {
                entity_id: self.entity_id,
                persona: self.persona,
                created_at: self.created_at,
                updated_at: self.updated_at,
            }
        }
    }
}
impl PersonasSummary {
    /// Creates a new builder-style object to manufacture [`PersonasSummary`](crate::model::PersonasSummary).
    pub fn builder() -> crate::model::personas_summary::Builder {
        crate::model::personas_summary::Builder::default()
    }
}

/// When writing a match expression against `Persona`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let persona = unimplemented!();
/// match persona {
///     Persona::Owner => { /* ... */ },
///     Persona::Viewer => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `persona` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Persona::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Persona::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Persona::NewFeature` is defined.
/// Specifically, when `persona` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Persona::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Persona {
    #[allow(missing_docs)] // documentation missing in model
    Owner,
    #[allow(missing_docs)] // documentation missing in model
    Viewer,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Persona {
    fn from(s: &str) -> Self {
        match s {
            "OWNER" => Persona::Owner,
            "VIEWER" => Persona::Viewer,
            other => Persona::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Persona {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Persona::from(s))
    }
}
impl Persona {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Persona::Owner => "OWNER",
            Persona::Viewer => "VIEWER",
            Persona::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["OWNER", "VIEWER"]
    }
}
impl AsRef<str> for Persona {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information about a data source synchronization job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSourceSyncJob {
    /// <p>A identifier for the synchronization job.</p>
    #[doc(hidden)]
    pub execution_id: std::option::Option<std::string::String>,
    /// <p>The UNIX datetime that the synchronization job started.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The UNIX datetime that the synchronization job completed.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The execution status of the synchronization job. When the <code>Status</code> field is set to <code>SUCCEEDED</code>, the synchronization job is done. If the status code is set to <code>FAILED</code>, the <code>ErrorCode</code> and <code>ErrorMessage</code> fields give you the reason for the failure.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::DataSourceSyncJobStatus>,
    /// <p>If the <code>Status</code> field is set to <code>ERROR</code>, the <code>ErrorMessage</code> field contains a description of the error that caused the synchronization to fail.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>If the <code>Status</code> field is set to <code>FAILED</code>, the <code>ErrorCode</code> field indicates the reason the synchronization failed.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<crate::model::ErrorCode>,
    /// <p>If the reason that the synchronization failed is due to an error with the underlying data source, this field contains a code that identifies the error.</p>
    #[doc(hidden)]
    pub data_source_error_code: std::option::Option<std::string::String>,
    /// <p>Maps a batch delete document request to a specific data source sync job. This is optional and should only be supplied when documents are deleted by a data source connector.</p>
    #[doc(hidden)]
    pub metrics: std::option::Option<crate::model::DataSourceSyncJobMetrics>,
}
impl DataSourceSyncJob {
    /// <p>A identifier for the synchronization job.</p>
    pub fn execution_id(&self) -> std::option::Option<&str> {
        self.execution_id.as_deref()
    }
    /// <p>The UNIX datetime that the synchronization job started.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The UNIX datetime that the synchronization job completed.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>The execution status of the synchronization job. When the <code>Status</code> field is set to <code>SUCCEEDED</code>, the synchronization job is done. If the status code is set to <code>FAILED</code>, the <code>ErrorCode</code> and <code>ErrorMessage</code> fields give you the reason for the failure.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::DataSourceSyncJobStatus> {
        self.status.as_ref()
    }
    /// <p>If the <code>Status</code> field is set to <code>ERROR</code>, the <code>ErrorMessage</code> field contains a description of the error that caused the synchronization to fail.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>If the <code>Status</code> field is set to <code>FAILED</code>, the <code>ErrorCode</code> field indicates the reason the synchronization failed.</p>
    pub fn error_code(&self) -> std::option::Option<&crate::model::ErrorCode> {
        self.error_code.as_ref()
    }
    /// <p>If the reason that the synchronization failed is due to an error with the underlying data source, this field contains a code that identifies the error.</p>
    pub fn data_source_error_code(&self) -> std::option::Option<&str> {
        self.data_source_error_code.as_deref()
    }
    /// <p>Maps a batch delete document request to a specific data source sync job. This is optional and should only be supplied when documents are deleted by a data source connector.</p>
    pub fn metrics(&self) -> std::option::Option<&crate::model::DataSourceSyncJobMetrics> {
        self.metrics.as_ref()
    }
}
/// See [`DataSourceSyncJob`](crate::model::DataSourceSyncJob).
pub mod data_source_sync_job {

    /// A builder for [`DataSourceSyncJob`](crate::model::DataSourceSyncJob).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) execution_id: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status: std::option::Option<crate::model::DataSourceSyncJobStatus>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) data_source_error_code: std::option::Option<std::string::String>,
        pub(crate) metrics: std::option::Option<crate::model::DataSourceSyncJobMetrics>,
    }
    impl Builder {
        /// <p>A identifier for the synchronization job.</p>
        pub fn execution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.execution_id = Some(input.into());
            self
        }
        /// <p>A identifier for the synchronization job.</p>
        pub fn set_execution_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.execution_id = input;
            self
        }
        /// <p>The UNIX datetime that the synchronization job started.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The UNIX datetime that the synchronization job started.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The UNIX datetime that the synchronization job completed.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The UNIX datetime that the synchronization job completed.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The execution status of the synchronization job. When the <code>Status</code> field is set to <code>SUCCEEDED</code>, the synchronization job is done. If the status code is set to <code>FAILED</code>, the <code>ErrorCode</code> and <code>ErrorMessage</code> fields give you the reason for the failure.</p>
        pub fn status(mut self, input: crate::model::DataSourceSyncJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The execution status of the synchronization job. When the <code>Status</code> field is set to <code>SUCCEEDED</code>, the synchronization job is done. If the status code is set to <code>FAILED</code>, the <code>ErrorCode</code> and <code>ErrorMessage</code> fields give you the reason for the failure.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::DataSourceSyncJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>If the <code>Status</code> field is set to <code>ERROR</code>, the <code>ErrorMessage</code> field contains a description of the error that caused the synchronization to fail.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>If the <code>Status</code> field is set to <code>ERROR</code>, the <code>ErrorMessage</code> field contains a description of the error that caused the synchronization to fail.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>If the <code>Status</code> field is set to <code>FAILED</code>, the <code>ErrorCode</code> field indicates the reason the synchronization failed.</p>
        pub fn error_code(mut self, input: crate::model::ErrorCode) -> Self {
            self.error_code = Some(input);
            self
        }
        /// <p>If the <code>Status</code> field is set to <code>FAILED</code>, the <code>ErrorCode</code> field indicates the reason the synchronization failed.</p>
        pub fn set_error_code(
            mut self,
            input: std::option::Option<crate::model::ErrorCode>,
        ) -> Self {
            self.error_code = input;
            self
        }
        /// <p>If the reason that the synchronization failed is due to an error with the underlying data source, this field contains a code that identifies the error.</p>
        pub fn data_source_error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_source_error_code = Some(input.into());
            self
        }
        /// <p>If the reason that the synchronization failed is due to an error with the underlying data source, this field contains a code that identifies the error.</p>
        pub fn set_data_source_error_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_source_error_code = input;
            self
        }
        /// <p>Maps a batch delete document request to a specific data source sync job. This is optional and should only be supplied when documents are deleted by a data source connector.</p>
        pub fn metrics(mut self, input: crate::model::DataSourceSyncJobMetrics) -> Self {
            self.metrics = Some(input);
            self
        }
        /// <p>Maps a batch delete document request to a specific data source sync job. This is optional and should only be supplied when documents are deleted by a data source connector.</p>
        pub fn set_metrics(
            mut self,
            input: std::option::Option<crate::model::DataSourceSyncJobMetrics>,
        ) -> Self {
            self.metrics = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSourceSyncJob`](crate::model::DataSourceSyncJob).
        pub fn build(self) -> crate::model::DataSourceSyncJob {
            crate::model::DataSourceSyncJob {
                execution_id: self.execution_id,
                start_time: self.start_time,
                end_time: self.end_time,
                status: self.status,
                error_message: self.error_message,
                error_code: self.error_code,
                data_source_error_code: self.data_source_error_code,
                metrics: self.metrics,
            }
        }
    }
}
impl DataSourceSyncJob {
    /// Creates a new builder-style object to manufacture [`DataSourceSyncJob`](crate::model::DataSourceSyncJob).
    pub fn builder() -> crate::model::data_source_sync_job::Builder {
        crate::model::data_source_sync_job::Builder::default()
    }
}

/// <p>Maps a batch delete document request to a specific data source sync job. This is optional and should only be supplied when documents are deleted by a data source connector.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSourceSyncJobMetrics {
    /// <p>The number of documents added from the data source up to now in the data source sync.</p>
    #[doc(hidden)]
    pub documents_added: std::option::Option<std::string::String>,
    /// <p>The number of documents modified in the data source up to now in the data source sync run.</p>
    #[doc(hidden)]
    pub documents_modified: std::option::Option<std::string::String>,
    /// <p>The number of documents deleted from the data source up to now in the data source sync run.</p>
    #[doc(hidden)]
    pub documents_deleted: std::option::Option<std::string::String>,
    /// <p>The number of documents that failed to sync from the data source up to now in the data source sync run.</p>
    #[doc(hidden)]
    pub documents_failed: std::option::Option<std::string::String>,
    /// <p>The current number of documents crawled by the current sync job in the data source.</p>
    #[doc(hidden)]
    pub documents_scanned: std::option::Option<std::string::String>,
}
impl DataSourceSyncJobMetrics {
    /// <p>The number of documents added from the data source up to now in the data source sync.</p>
    pub fn documents_added(&self) -> std::option::Option<&str> {
        self.documents_added.as_deref()
    }
    /// <p>The number of documents modified in the data source up to now in the data source sync run.</p>
    pub fn documents_modified(&self) -> std::option::Option<&str> {
        self.documents_modified.as_deref()
    }
    /// <p>The number of documents deleted from the data source up to now in the data source sync run.</p>
    pub fn documents_deleted(&self) -> std::option::Option<&str> {
        self.documents_deleted.as_deref()
    }
    /// <p>The number of documents that failed to sync from the data source up to now in the data source sync run.</p>
    pub fn documents_failed(&self) -> std::option::Option<&str> {
        self.documents_failed.as_deref()
    }
    /// <p>The current number of documents crawled by the current sync job in the data source.</p>
    pub fn documents_scanned(&self) -> std::option::Option<&str> {
        self.documents_scanned.as_deref()
    }
}
/// See [`DataSourceSyncJobMetrics`](crate::model::DataSourceSyncJobMetrics).
pub mod data_source_sync_job_metrics {

    /// A builder for [`DataSourceSyncJobMetrics`](crate::model::DataSourceSyncJobMetrics).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) documents_added: std::option::Option<std::string::String>,
        pub(crate) documents_modified: std::option::Option<std::string::String>,
        pub(crate) documents_deleted: std::option::Option<std::string::String>,
        pub(crate) documents_failed: std::option::Option<std::string::String>,
        pub(crate) documents_scanned: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of documents added from the data source up to now in the data source sync.</p>
        pub fn documents_added(mut self, input: impl Into<std::string::String>) -> Self {
            self.documents_added = Some(input.into());
            self
        }
        /// <p>The number of documents added from the data source up to now in the data source sync.</p>
        pub fn set_documents_added(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.documents_added = input;
            self
        }
        /// <p>The number of documents modified in the data source up to now in the data source sync run.</p>
        pub fn documents_modified(mut self, input: impl Into<std::string::String>) -> Self {
            self.documents_modified = Some(input.into());
            self
        }
        /// <p>The number of documents modified in the data source up to now in the data source sync run.</p>
        pub fn set_documents_modified(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.documents_modified = input;
            self
        }
        /// <p>The number of documents deleted from the data source up to now in the data source sync run.</p>
        pub fn documents_deleted(mut self, input: impl Into<std::string::String>) -> Self {
            self.documents_deleted = Some(input.into());
            self
        }
        /// <p>The number of documents deleted from the data source up to now in the data source sync run.</p>
        pub fn set_documents_deleted(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.documents_deleted = input;
            self
        }
        /// <p>The number of documents that failed to sync from the data source up to now in the data source sync run.</p>
        pub fn documents_failed(mut self, input: impl Into<std::string::String>) -> Self {
            self.documents_failed = Some(input.into());
            self
        }
        /// <p>The number of documents that failed to sync from the data source up to now in the data source sync run.</p>
        pub fn set_documents_failed(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.documents_failed = input;
            self
        }
        /// <p>The current number of documents crawled by the current sync job in the data source.</p>
        pub fn documents_scanned(mut self, input: impl Into<std::string::String>) -> Self {
            self.documents_scanned = Some(input.into());
            self
        }
        /// <p>The current number of documents crawled by the current sync job in the data source.</p>
        pub fn set_documents_scanned(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.documents_scanned = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSourceSyncJobMetrics`](crate::model::DataSourceSyncJobMetrics).
        pub fn build(self) -> crate::model::DataSourceSyncJobMetrics {
            crate::model::DataSourceSyncJobMetrics {
                documents_added: self.documents_added,
                documents_modified: self.documents_modified,
                documents_deleted: self.documents_deleted,
                documents_failed: self.documents_failed,
                documents_scanned: self.documents_scanned,
            }
        }
    }
}
impl DataSourceSyncJobMetrics {
    /// Creates a new builder-style object to manufacture [`DataSourceSyncJobMetrics`](crate::model::DataSourceSyncJobMetrics).
    pub fn builder() -> crate::model::data_source_sync_job_metrics::Builder {
        crate::model::data_source_sync_job_metrics::Builder::default()
    }
}

/// When writing a match expression against `ErrorCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let errorcode = unimplemented!();
/// match errorcode {
///     ErrorCode::InternalError => { /* ... */ },
///     ErrorCode::InvalidRequest => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `errorcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ErrorCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ErrorCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ErrorCode::NewFeature` is defined.
/// Specifically, when `errorcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ErrorCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    InternalError,
    #[allow(missing_docs)] // documentation missing in model
    InvalidRequest,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "InternalError" => ErrorCode::InternalError,
            "InvalidRequest" => ErrorCode::InvalidRequest,
            other => ErrorCode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ErrorCode::from(s))
    }
}
impl ErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ErrorCode::InternalError => "InternalError",
            ErrorCode::InvalidRequest => "InvalidRequest",
            ErrorCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["InternalError", "InvalidRequest"]
    }
}
impl AsRef<str> for ErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DataSourceSyncJobStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datasourcesyncjobstatus = unimplemented!();
/// match datasourcesyncjobstatus {
///     DataSourceSyncJobStatus::Aborted => { /* ... */ },
///     DataSourceSyncJobStatus::Failed => { /* ... */ },
///     DataSourceSyncJobStatus::Incomplete => { /* ... */ },
///     DataSourceSyncJobStatus::Stopping => { /* ... */ },
///     DataSourceSyncJobStatus::Succeeded => { /* ... */ },
///     DataSourceSyncJobStatus::Syncing => { /* ... */ },
///     DataSourceSyncJobStatus::SyncingIndexing => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datasourcesyncjobstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataSourceSyncJobStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataSourceSyncJobStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataSourceSyncJobStatus::NewFeature` is defined.
/// Specifically, when `datasourcesyncjobstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataSourceSyncJobStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataSourceSyncJobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Aborted,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Incomplete,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    #[allow(missing_docs)] // documentation missing in model
    Syncing,
    #[allow(missing_docs)] // documentation missing in model
    SyncingIndexing,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataSourceSyncJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "ABORTED" => DataSourceSyncJobStatus::Aborted,
            "FAILED" => DataSourceSyncJobStatus::Failed,
            "INCOMPLETE" => DataSourceSyncJobStatus::Incomplete,
            "STOPPING" => DataSourceSyncJobStatus::Stopping,
            "SUCCEEDED" => DataSourceSyncJobStatus::Succeeded,
            "SYNCING" => DataSourceSyncJobStatus::Syncing,
            "SYNCING_INDEXING" => DataSourceSyncJobStatus::SyncingIndexing,
            other => DataSourceSyncJobStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for DataSourceSyncJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataSourceSyncJobStatus::from(s))
    }
}
impl DataSourceSyncJobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataSourceSyncJobStatus::Aborted => "ABORTED",
            DataSourceSyncJobStatus::Failed => "FAILED",
            DataSourceSyncJobStatus::Incomplete => "INCOMPLETE",
            DataSourceSyncJobStatus::Stopping => "STOPPING",
            DataSourceSyncJobStatus::Succeeded => "SUCCEEDED",
            DataSourceSyncJobStatus::Syncing => "SYNCING",
            DataSourceSyncJobStatus::SyncingIndexing => "SYNCING_INDEXING",
            DataSourceSyncJobStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ABORTED",
            "FAILED",
            "INCOMPLETE",
            "STOPPING",
            "SUCCEEDED",
            "SYNCING",
            "SYNCING_INDEXING",
        ]
    }
}
impl AsRef<str> for DataSourceSyncJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides a range of time.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TimeRange {
    /// <p>The UNIX datetime of the beginning of the time range.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The UNIX datetime of the end of the time range.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl TimeRange {
    /// <p>The UNIX datetime of the beginning of the time range.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The UNIX datetime of the end of the time range.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
}
/// See [`TimeRange`](crate::model::TimeRange).
pub mod time_range {

    /// A builder for [`TimeRange`](crate::model::TimeRange).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The UNIX datetime of the beginning of the time range.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The UNIX datetime of the beginning of the time range.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The UNIX datetime of the end of the time range.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The UNIX datetime of the end of the time range.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// Consumes the builder and constructs a [`TimeRange`](crate::model::TimeRange).
        pub fn build(self) -> crate::model::TimeRange {
            crate::model::TimeRange {
                start_time: self.start_time,
                end_time: self.end_time,
            }
        }
    }
}
impl TimeRange {
    /// Creates a new builder-style object to manufacture [`TimeRange`](crate::model::TimeRange).
    pub fn builder() -> crate::model::time_range::Builder {
        crate::model::time_range::Builder::default()
    }
}

/// <p>Summary information for a Amazon Kendra data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSourceSummary {
    /// <p>The name of the data source.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The identifier for the data source.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The type of the data source.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::DataSourceType>,
    /// <p>The UNIX datetime that the data source was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The UNIX datetime that the data source was lasted updated. </p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the data source. When the status is <code>ACTIVE</code> the data source is ready to use.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::DataSourceStatus>,
    /// <p>The code for a language. This shows a supported language for all documents in the data source. English is supported by default. For more information on supported languages, including their codes, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/in-adding-languages.html">Adding documents in languages other than English</a>.</p>
    #[doc(hidden)]
    pub language_code: std::option::Option<std::string::String>,
}
impl DataSourceSummary {
    /// <p>The name of the data source.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The identifier for the data source.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The type of the data source.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::DataSourceType> {
        self.r#type.as_ref()
    }
    /// <p>The UNIX datetime that the data source was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The UNIX datetime that the data source was lasted updated. </p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The status of the data source. When the status is <code>ACTIVE</code> the data source is ready to use.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::DataSourceStatus> {
        self.status.as_ref()
    }
    /// <p>The code for a language. This shows a supported language for all documents in the data source. English is supported by default. For more information on supported languages, including their codes, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/in-adding-languages.html">Adding documents in languages other than English</a>.</p>
    pub fn language_code(&self) -> std::option::Option<&str> {
        self.language_code.as_deref()
    }
}
/// See [`DataSourceSummary`](crate::model::DataSourceSummary).
pub mod data_source_summary {

    /// A builder for [`DataSourceSummary`](crate::model::DataSourceSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::DataSourceType>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status: std::option::Option<crate::model::DataSourceStatus>,
        pub(crate) language_code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the data source.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data source.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The identifier for the data source.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier for the data source.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The type of the data source.</p>
        pub fn r#type(mut self, input: crate::model::DataSourceType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the data source.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::DataSourceType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The UNIX datetime that the data source was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The UNIX datetime that the data source was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The UNIX datetime that the data source was lasted updated. </p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The UNIX datetime that the data source was lasted updated. </p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The status of the data source. When the status is <code>ACTIVE</code> the data source is ready to use.</p>
        pub fn status(mut self, input: crate::model::DataSourceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the data source. When the status is <code>ACTIVE</code> the data source is ready to use.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::DataSourceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The code for a language. This shows a supported language for all documents in the data source. English is supported by default. For more information on supported languages, including their codes, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/in-adding-languages.html">Adding documents in languages other than English</a>.</p>
        pub fn language_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.language_code = Some(input.into());
            self
        }
        /// <p>The code for a language. This shows a supported language for all documents in the data source. English is supported by default. For more information on supported languages, including their codes, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/in-adding-languages.html">Adding documents in languages other than English</a>.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSourceSummary`](crate::model::DataSourceSummary).
        pub fn build(self) -> crate::model::DataSourceSummary {
            crate::model::DataSourceSummary {
                name: self.name,
                id: self.id,
                r#type: self.r#type,
                created_at: self.created_at,
                updated_at: self.updated_at,
                status: self.status,
                language_code: self.language_code,
            }
        }
    }
}
impl DataSourceSummary {
    /// Creates a new builder-style object to manufacture [`DataSourceSummary`](crate::model::DataSourceSummary).
    pub fn builder() -> crate::model::data_source_summary::Builder {
        crate::model::data_source_summary::Builder::default()
    }
}

/// When writing a match expression against `DataSourceStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datasourcestatus = unimplemented!();
/// match datasourcestatus {
///     DataSourceStatus::Active => { /* ... */ },
///     DataSourceStatus::Creating => { /* ... */ },
///     DataSourceStatus::Deleting => { /* ... */ },
///     DataSourceStatus::Failed => { /* ... */ },
///     DataSourceStatus::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datasourcestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataSourceStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataSourceStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataSourceStatus::NewFeature` is defined.
/// Specifically, when `datasourcestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataSourceStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataSourceStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataSourceStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => DataSourceStatus::Active,
            "CREATING" => DataSourceStatus::Creating,
            "DELETING" => DataSourceStatus::Deleting,
            "FAILED" => DataSourceStatus::Failed,
            "UPDATING" => DataSourceStatus::Updating,
            other => DataSourceStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DataSourceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataSourceStatus::from(s))
    }
}
impl DataSourceStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataSourceStatus::Active => "ACTIVE",
            DataSourceStatus::Creating => "CREATING",
            DataSourceStatus::Deleting => "DELETING",
            DataSourceStatus::Failed => "FAILED",
            DataSourceStatus::Updating => "UPDATING",
            DataSourceStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "CREATING", "DELETING", "FAILED", "UPDATING"]
    }
}
impl AsRef<str> for DataSourceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DataSourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datasourcetype = unimplemented!();
/// match datasourcetype {
///     DataSourceType::Alfresco => { /* ... */ },
///     DataSourceType::Box => { /* ... */ },
///     DataSourceType::Confluence => { /* ... */ },
///     DataSourceType::Custom => { /* ... */ },
///     DataSourceType::Database => { /* ... */ },
///     DataSourceType::Fsx => { /* ... */ },
///     DataSourceType::Github => { /* ... */ },
///     DataSourceType::Googledrive => { /* ... */ },
///     DataSourceType::Jira => { /* ... */ },
///     DataSourceType::Onedrive => { /* ... */ },
///     DataSourceType::Quip => { /* ... */ },
///     DataSourceType::S3 => { /* ... */ },
///     DataSourceType::Salesforce => { /* ... */ },
///     DataSourceType::Servicenow => { /* ... */ },
///     DataSourceType::Sharepoint => { /* ... */ },
///     DataSourceType::Slack => { /* ... */ },
///     DataSourceType::Template => { /* ... */ },
///     DataSourceType::Webcrawler => { /* ... */ },
///     DataSourceType::Workdocs => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datasourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataSourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataSourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataSourceType::NewFeature` is defined.
/// Specifically, when `datasourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataSourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataSourceType {
    #[allow(missing_docs)] // documentation missing in model
    Alfresco,
    #[allow(missing_docs)] // documentation missing in model
    Box,
    #[allow(missing_docs)] // documentation missing in model
    Confluence,
    #[allow(missing_docs)] // documentation missing in model
    Custom,
    #[allow(missing_docs)] // documentation missing in model
    Database,
    #[allow(missing_docs)] // documentation missing in model
    Fsx,
    #[allow(missing_docs)] // documentation missing in model
    Github,
    #[allow(missing_docs)] // documentation missing in model
    Googledrive,
    #[allow(missing_docs)] // documentation missing in model
    Jira,
    #[allow(missing_docs)] // documentation missing in model
    Onedrive,
    #[allow(missing_docs)] // documentation missing in model
    Quip,
    #[allow(missing_docs)] // documentation missing in model
    S3,
    #[allow(missing_docs)] // documentation missing in model
    Salesforce,
    #[allow(missing_docs)] // documentation missing in model
    Servicenow,
    #[allow(missing_docs)] // documentation missing in model
    Sharepoint,
    #[allow(missing_docs)] // documentation missing in model
    Slack,
    #[allow(missing_docs)] // documentation missing in model
    Template,
    #[allow(missing_docs)] // documentation missing in model
    Webcrawler,
    #[allow(missing_docs)] // documentation missing in model
    Workdocs,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataSourceType {
    fn from(s: &str) -> Self {
        match s {
            "ALFRESCO" => DataSourceType::Alfresco,
            "BOX" => DataSourceType::Box,
            "CONFLUENCE" => DataSourceType::Confluence,
            "CUSTOM" => DataSourceType::Custom,
            "DATABASE" => DataSourceType::Database,
            "FSX" => DataSourceType::Fsx,
            "GITHUB" => DataSourceType::Github,
            "GOOGLEDRIVE" => DataSourceType::Googledrive,
            "JIRA" => DataSourceType::Jira,
            "ONEDRIVE" => DataSourceType::Onedrive,
            "QUIP" => DataSourceType::Quip,
            "S3" => DataSourceType::S3,
            "SALESFORCE" => DataSourceType::Salesforce,
            "SERVICENOW" => DataSourceType::Servicenow,
            "SHAREPOINT" => DataSourceType::Sharepoint,
            "SLACK" => DataSourceType::Slack,
            "TEMPLATE" => DataSourceType::Template,
            "WEBCRAWLER" => DataSourceType::Webcrawler,
            "WORKDOCS" => DataSourceType::Workdocs,
            other => DataSourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DataSourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataSourceType::from(s))
    }
}
impl DataSourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataSourceType::Alfresco => "ALFRESCO",
            DataSourceType::Box => "BOX",
            DataSourceType::Confluence => "CONFLUENCE",
            DataSourceType::Custom => "CUSTOM",
            DataSourceType::Database => "DATABASE",
            DataSourceType::Fsx => "FSX",
            DataSourceType::Github => "GITHUB",
            DataSourceType::Googledrive => "GOOGLEDRIVE",
            DataSourceType::Jira => "JIRA",
            DataSourceType::Onedrive => "ONEDRIVE",
            DataSourceType::Quip => "QUIP",
            DataSourceType::S3 => "S3",
            DataSourceType::Salesforce => "SALESFORCE",
            DataSourceType::Servicenow => "SERVICENOW",
            DataSourceType::Sharepoint => "SHAREPOINT",
            DataSourceType::Slack => "SLACK",
            DataSourceType::Template => "TEMPLATE",
            DataSourceType::Webcrawler => "WEBCRAWLER",
            DataSourceType::Workdocs => "WORKDOCS",
            DataSourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ALFRESCO",
            "BOX",
            "CONFLUENCE",
            "CUSTOM",
            "DATABASE",
            "FSX",
            "GITHUB",
            "GOOGLEDRIVE",
            "JIRA",
            "ONEDRIVE",
            "QUIP",
            "S3",
            "SALESFORCE",
            "SERVICENOW",
            "SHAREPOINT",
            "SLACK",
            "TEMPLATE",
            "WEBCRAWLER",
            "WORKDOCS",
        ]
    }
}
impl AsRef<str> for DataSourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary information on an access control configuration that you created for your documents in an index.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccessControlConfigurationSummary {
    /// <p>The identifier of the access control configuration.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl AccessControlConfigurationSummary {
    /// <p>The identifier of the access control configuration.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
}
/// See [`AccessControlConfigurationSummary`](crate::model::AccessControlConfigurationSummary).
pub mod access_control_configuration_summary {

    /// A builder for [`AccessControlConfigurationSummary`](crate::model::AccessControlConfigurationSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the access control configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the access control configuration.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessControlConfigurationSummary`](crate::model::AccessControlConfigurationSummary).
        pub fn build(self) -> crate::model::AccessControlConfigurationSummary {
            crate::model::AccessControlConfigurationSummary { id: self.id }
        }
    }
}
impl AccessControlConfigurationSummary {
    /// Creates a new builder-style object to manufacture [`AccessControlConfigurationSummary`](crate::model::AccessControlConfigurationSummary).
    pub fn builder() -> crate::model::access_control_configuration_summary::Builder {
        crate::model::access_control_configuration_summary::Builder::default()
    }
}

/// When writing a match expression against `MetricType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let metrictype = unimplemented!();
/// match metrictype {
///     MetricType::AggQueryDocMetrics => { /* ... */ },
///     MetricType::DocsByClickCount => { /* ... */ },
///     MetricType::QueriesByCount => { /* ... */ },
///     MetricType::QueriesByZeroClickRate => { /* ... */ },
///     MetricType::QueriesByZeroResultRate => { /* ... */ },
///     MetricType::TrendQueryDocMetrics => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `metrictype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MetricType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MetricType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MetricType::NewFeature` is defined.
/// Specifically, when `metrictype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MetricType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MetricType {
    #[allow(missing_docs)] // documentation missing in model
    AggQueryDocMetrics,
    #[allow(missing_docs)] // documentation missing in model
    DocsByClickCount,
    #[allow(missing_docs)] // documentation missing in model
    QueriesByCount,
    #[allow(missing_docs)] // documentation missing in model
    QueriesByZeroClickRate,
    #[allow(missing_docs)] // documentation missing in model
    QueriesByZeroResultRate,
    #[allow(missing_docs)] // documentation missing in model
    TrendQueryDocMetrics,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MetricType {
    fn from(s: &str) -> Self {
        match s {
            "AGG_QUERY_DOC_METRICS" => MetricType::AggQueryDocMetrics,
            "DOCS_BY_CLICK_COUNT" => MetricType::DocsByClickCount,
            "QUERIES_BY_COUNT" => MetricType::QueriesByCount,
            "QUERIES_BY_ZERO_CLICK_RATE" => MetricType::QueriesByZeroClickRate,
            "QUERIES_BY_ZERO_RESULT_RATE" => MetricType::QueriesByZeroResultRate,
            "TREND_QUERY_DOC_METRICS" => MetricType::TrendQueryDocMetrics,
            other => MetricType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for MetricType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MetricType::from(s))
    }
}
impl MetricType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MetricType::AggQueryDocMetrics => "AGG_QUERY_DOC_METRICS",
            MetricType::DocsByClickCount => "DOCS_BY_CLICK_COUNT",
            MetricType::QueriesByCount => "QUERIES_BY_COUNT",
            MetricType::QueriesByZeroClickRate => "QUERIES_BY_ZERO_CLICK_RATE",
            MetricType::QueriesByZeroResultRate => "QUERIES_BY_ZERO_RESULT_RATE",
            MetricType::TrendQueryDocMetrics => "TREND_QUERY_DOC_METRICS",
            MetricType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AGG_QUERY_DOC_METRICS",
            "DOCS_BY_CLICK_COUNT",
            "QUERIES_BY_COUNT",
            "QUERIES_BY_ZERO_CLICK_RATE",
            "QUERIES_BY_ZERO_RESULT_RATE",
            "TREND_QUERY_DOC_METRICS",
        ]
    }
}
impl AsRef<str> for MetricType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Interval`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let interval = unimplemented!();
/// match interval {
///     Interval::OneMonthAgo => { /* ... */ },
///     Interval::OneWeekAgo => { /* ... */ },
///     Interval::ThisMonth => { /* ... */ },
///     Interval::ThisWeek => { /* ... */ },
///     Interval::TwoMonthsAgo => { /* ... */ },
///     Interval::TwoWeeksAgo => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `interval` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Interval::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Interval::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Interval::NewFeature` is defined.
/// Specifically, when `interval` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Interval::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Interval {
    #[allow(missing_docs)] // documentation missing in model
    OneMonthAgo,
    #[allow(missing_docs)] // documentation missing in model
    OneWeekAgo,
    #[allow(missing_docs)] // documentation missing in model
    ThisMonth,
    #[allow(missing_docs)] // documentation missing in model
    ThisWeek,
    #[allow(missing_docs)] // documentation missing in model
    TwoMonthsAgo,
    #[allow(missing_docs)] // documentation missing in model
    TwoWeeksAgo,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Interval {
    fn from(s: &str) -> Self {
        match s {
            "ONE_MONTH_AGO" => Interval::OneMonthAgo,
            "ONE_WEEK_AGO" => Interval::OneWeekAgo,
            "THIS_MONTH" => Interval::ThisMonth,
            "THIS_WEEK" => Interval::ThisWeek,
            "TWO_MONTHS_AGO" => Interval::TwoMonthsAgo,
            "TWO_WEEKS_AGO" => Interval::TwoWeeksAgo,
            other => Interval::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Interval {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Interval::from(s))
    }
}
impl Interval {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Interval::OneMonthAgo => "ONE_MONTH_AGO",
            Interval::OneWeekAgo => "ONE_WEEK_AGO",
            Interval::ThisMonth => "THIS_MONTH",
            Interval::ThisWeek => "THIS_WEEK",
            Interval::TwoMonthsAgo => "TWO_MONTHS_AGO",
            Interval::TwoWeeksAgo => "TWO_WEEKS_AGO",
            Interval::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ONE_MONTH_AGO",
            "ONE_WEEK_AGO",
            "THIS_MONTH",
            "THIS_WEEK",
            "TWO_MONTHS_AGO",
            "TWO_WEEKS_AGO",
        ]
    }
}
impl AsRef<str> for Interval {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A single query suggestion.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Suggestion {
    /// <p>The UUID (universally unique identifier) of a single query suggestion.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The value for the UUID (universally unique identifier) of a single query suggestion.</p>
    /// <p>The value is the text string of a suggestion.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::SuggestionValue>,
}
impl Suggestion {
    /// <p>The UUID (universally unique identifier) of a single query suggestion.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The value for the UUID (universally unique identifier) of a single query suggestion.</p>
    /// <p>The value is the text string of a suggestion.</p>
    pub fn value(&self) -> std::option::Option<&crate::model::SuggestionValue> {
        self.value.as_ref()
    }
}
/// See [`Suggestion`](crate::model::Suggestion).
pub mod suggestion {

    /// A builder for [`Suggestion`](crate::model::Suggestion).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<crate::model::SuggestionValue>,
    }
    impl Builder {
        /// <p>The UUID (universally unique identifier) of a single query suggestion.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The UUID (universally unique identifier) of a single query suggestion.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The value for the UUID (universally unique identifier) of a single query suggestion.</p>
        /// <p>The value is the text string of a suggestion.</p>
        pub fn value(mut self, input: crate::model::SuggestionValue) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value for the UUID (universally unique identifier) of a single query suggestion.</p>
        /// <p>The value is the text string of a suggestion.</p>
        pub fn set_value(
            mut self,
            input: std::option::Option<crate::model::SuggestionValue>,
        ) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Suggestion`](crate::model::Suggestion).
        pub fn build(self) -> crate::model::Suggestion {
            crate::model::Suggestion {
                id: self.id,
                value: self.value,
            }
        }
    }
}
impl Suggestion {
    /// Creates a new builder-style object to manufacture [`Suggestion`](crate::model::Suggestion).
    pub fn builder() -> crate::model::suggestion::Builder {
        crate::model::suggestion::Builder::default()
    }
}

/// <p>The <code>SuggestionTextWithHighlights</code> structure information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SuggestionValue {
    /// <p>The <code>SuggestionTextWithHighlights</code> structure that contains the query suggestion text and highlights.</p>
    #[doc(hidden)]
    pub text: std::option::Option<crate::model::SuggestionTextWithHighlights>,
}
impl SuggestionValue {
    /// <p>The <code>SuggestionTextWithHighlights</code> structure that contains the query suggestion text and highlights.</p>
    pub fn text(&self) -> std::option::Option<&crate::model::SuggestionTextWithHighlights> {
        self.text.as_ref()
    }
}
/// See [`SuggestionValue`](crate::model::SuggestionValue).
pub mod suggestion_value {

    /// A builder for [`SuggestionValue`](crate::model::SuggestionValue).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) text: std::option::Option<crate::model::SuggestionTextWithHighlights>,
    }
    impl Builder {
        /// <p>The <code>SuggestionTextWithHighlights</code> structure that contains the query suggestion text and highlights.</p>
        pub fn text(mut self, input: crate::model::SuggestionTextWithHighlights) -> Self {
            self.text = Some(input);
            self
        }
        /// <p>The <code>SuggestionTextWithHighlights</code> structure that contains the query suggestion text and highlights.</p>
        pub fn set_text(
            mut self,
            input: std::option::Option<crate::model::SuggestionTextWithHighlights>,
        ) -> Self {
            self.text = input;
            self
        }
        /// Consumes the builder and constructs a [`SuggestionValue`](crate::model::SuggestionValue).
        pub fn build(self) -> crate::model::SuggestionValue {
            crate::model::SuggestionValue { text: self.text }
        }
    }
}
impl SuggestionValue {
    /// Creates a new builder-style object to manufacture [`SuggestionValue`](crate::model::SuggestionValue).
    pub fn builder() -> crate::model::suggestion_value::Builder {
        crate::model::suggestion_value::Builder::default()
    }
}

/// <p>Provides text and information about where to highlight the query suggestion text.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SuggestionTextWithHighlights {
    /// <p>The query suggestion text to display to the user.</p>
    #[doc(hidden)]
    pub text: std::option::Option<std::string::String>,
    /// <p>The beginning and end of the query suggestion text that should be highlighted.</p>
    #[doc(hidden)]
    pub highlights: std::option::Option<std::vec::Vec<crate::model::SuggestionHighlight>>,
}
impl SuggestionTextWithHighlights {
    /// <p>The query suggestion text to display to the user.</p>
    pub fn text(&self) -> std::option::Option<&str> {
        self.text.as_deref()
    }
    /// <p>The beginning and end of the query suggestion text that should be highlighted.</p>
    pub fn highlights(&self) -> std::option::Option<&[crate::model::SuggestionHighlight]> {
        self.highlights.as_deref()
    }
}
/// See [`SuggestionTextWithHighlights`](crate::model::SuggestionTextWithHighlights).
pub mod suggestion_text_with_highlights {

    /// A builder for [`SuggestionTextWithHighlights`](crate::model::SuggestionTextWithHighlights).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) text: std::option::Option<std::string::String>,
        pub(crate) highlights:
            std::option::Option<std::vec::Vec<crate::model::SuggestionHighlight>>,
    }
    impl Builder {
        /// <p>The query suggestion text to display to the user.</p>
        pub fn text(mut self, input: impl Into<std::string::String>) -> Self {
            self.text = Some(input.into());
            self
        }
        /// <p>The query suggestion text to display to the user.</p>
        pub fn set_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.text = input;
            self
        }
        /// Appends an item to `highlights`.
        ///
        /// To override the contents of this collection use [`set_highlights`](Self::set_highlights).
        ///
        /// <p>The beginning and end of the query suggestion text that should be highlighted.</p>
        pub fn highlights(mut self, input: crate::model::SuggestionHighlight) -> Self {
            let mut v = self.highlights.unwrap_or_default();
            v.push(input);
            self.highlights = Some(v);
            self
        }
        /// <p>The beginning and end of the query suggestion text that should be highlighted.</p>
        pub fn set_highlights(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SuggestionHighlight>>,
        ) -> Self {
            self.highlights = input;
            self
        }
        /// Consumes the builder and constructs a [`SuggestionTextWithHighlights`](crate::model::SuggestionTextWithHighlights).
        pub fn build(self) -> crate::model::SuggestionTextWithHighlights {
            crate::model::SuggestionTextWithHighlights {
                text: self.text,
                highlights: self.highlights,
            }
        }
    }
}
impl SuggestionTextWithHighlights {
    /// Creates a new builder-style object to manufacture [`SuggestionTextWithHighlights`](crate::model::SuggestionTextWithHighlights).
    pub fn builder() -> crate::model::suggestion_text_with_highlights::Builder {
        crate::model::suggestion_text_with_highlights::Builder::default()
    }
}

/// <p>The text highlights for a single query suggestion.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SuggestionHighlight {
    /// <p>The zero-based location in the response string where the highlight starts.</p>
    #[doc(hidden)]
    pub begin_offset: std::option::Option<i32>,
    /// <p>The zero-based location in the response string where the highlight ends.</p>
    #[doc(hidden)]
    pub end_offset: std::option::Option<i32>,
}
impl SuggestionHighlight {
    /// <p>The zero-based location in the response string where the highlight starts.</p>
    pub fn begin_offset(&self) -> std::option::Option<i32> {
        self.begin_offset
    }
    /// <p>The zero-based location in the response string where the highlight ends.</p>
    pub fn end_offset(&self) -> std::option::Option<i32> {
        self.end_offset
    }
}
/// See [`SuggestionHighlight`](crate::model::SuggestionHighlight).
pub mod suggestion_highlight {

    /// A builder for [`SuggestionHighlight`](crate::model::SuggestionHighlight).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) begin_offset: std::option::Option<i32>,
        pub(crate) end_offset: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The zero-based location in the response string where the highlight starts.</p>
        pub fn begin_offset(mut self, input: i32) -> Self {
            self.begin_offset = Some(input);
            self
        }
        /// <p>The zero-based location in the response string where the highlight starts.</p>
        pub fn set_begin_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.begin_offset = input;
            self
        }
        /// <p>The zero-based location in the response string where the highlight ends.</p>
        pub fn end_offset(mut self, input: i32) -> Self {
            self.end_offset = Some(input);
            self
        }
        /// <p>The zero-based location in the response string where the highlight ends.</p>
        pub fn set_end_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.end_offset = input;
            self
        }
        /// Consumes the builder and constructs a [`SuggestionHighlight`](crate::model::SuggestionHighlight).
        pub fn build(self) -> crate::model::SuggestionHighlight {
            crate::model::SuggestionHighlight {
                begin_offset: self.begin_offset,
                end_offset: self.end_offset,
            }
        }
    }
}
impl SuggestionHighlight {
    /// Creates a new builder-style object to manufacture [`SuggestionHighlight`](crate::model::SuggestionHighlight).
    pub fn builder() -> crate::model::suggestion_highlight::Builder {
        crate::model::suggestion_highlight::Builder::default()
    }
}

/// <p>Information on the users or groups in your IAM Identity Center identity source that failed to properly configure with your Amazon Kendra experience.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FailedEntity {
    /// <p>The identifier of the user or group in your IAM Identity Center identity source. For example, a user ID could be an email.</p>
    #[doc(hidden)]
    pub entity_id: std::option::Option<std::string::String>,
    /// <p>The reason the user or group in your IAM Identity Center identity source failed to properly configure with your Amazon Kendra experience.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl FailedEntity {
    /// <p>The identifier of the user or group in your IAM Identity Center identity source. For example, a user ID could be an email.</p>
    pub fn entity_id(&self) -> std::option::Option<&str> {
        self.entity_id.as_deref()
    }
    /// <p>The reason the user or group in your IAM Identity Center identity source failed to properly configure with your Amazon Kendra experience.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
/// See [`FailedEntity`](crate::model::FailedEntity).
pub mod failed_entity {

    /// A builder for [`FailedEntity`](crate::model::FailedEntity).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entity_id: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the user or group in your IAM Identity Center identity source. For example, a user ID could be an email.</p>
        pub fn entity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entity_id = Some(input.into());
            self
        }
        /// <p>The identifier of the user or group in your IAM Identity Center identity source. For example, a user ID could be an email.</p>
        pub fn set_entity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entity_id = input;
            self
        }
        /// <p>The reason the user or group in your IAM Identity Center identity source failed to properly configure with your Amazon Kendra experience.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The reason the user or group in your IAM Identity Center identity source failed to properly configure with your Amazon Kendra experience.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`FailedEntity`](crate::model::FailedEntity).
        pub fn build(self) -> crate::model::FailedEntity {
            crate::model::FailedEntity {
                entity_id: self.entity_id,
                error_message: self.error_message,
            }
        }
    }
}
impl FailedEntity {
    /// Creates a new builder-style object to manufacture [`FailedEntity`](crate::model::FailedEntity).
    pub fn builder() -> crate::model::failed_entity::Builder {
        crate::model::failed_entity::Builder::default()
    }
}

/// <p>Provides the configuration information for users or groups in your IAM Identity Center identity source to grant access your Amazon Kendra experience.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EntityConfiguration {
    /// <p>The identifier of a user or group in your IAM Identity Center identity source. For example, a user ID could be an email.</p>
    #[doc(hidden)]
    pub entity_id: std::option::Option<std::string::String>,
    /// <p>Specifies whether you are configuring a <code>User</code> or a <code>Group</code>.</p>
    #[doc(hidden)]
    pub entity_type: std::option::Option<crate::model::EntityType>,
}
impl EntityConfiguration {
    /// <p>The identifier of a user or group in your IAM Identity Center identity source. For example, a user ID could be an email.</p>
    pub fn entity_id(&self) -> std::option::Option<&str> {
        self.entity_id.as_deref()
    }
    /// <p>Specifies whether you are configuring a <code>User</code> or a <code>Group</code>.</p>
    pub fn entity_type(&self) -> std::option::Option<&crate::model::EntityType> {
        self.entity_type.as_ref()
    }
}
/// See [`EntityConfiguration`](crate::model::EntityConfiguration).
pub mod entity_configuration {

    /// A builder for [`EntityConfiguration`](crate::model::EntityConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entity_id: std::option::Option<std::string::String>,
        pub(crate) entity_type: std::option::Option<crate::model::EntityType>,
    }
    impl Builder {
        /// <p>The identifier of a user or group in your IAM Identity Center identity source. For example, a user ID could be an email.</p>
        pub fn entity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entity_id = Some(input.into());
            self
        }
        /// <p>The identifier of a user or group in your IAM Identity Center identity source. For example, a user ID could be an email.</p>
        pub fn set_entity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entity_id = input;
            self
        }
        /// <p>Specifies whether you are configuring a <code>User</code> or a <code>Group</code>.</p>
        pub fn entity_type(mut self, input: crate::model::EntityType) -> Self {
            self.entity_type = Some(input);
            self
        }
        /// <p>Specifies whether you are configuring a <code>User</code> or a <code>Group</code>.</p>
        pub fn set_entity_type(
            mut self,
            input: std::option::Option<crate::model::EntityType>,
        ) -> Self {
            self.entity_type = input;
            self
        }
        /// Consumes the builder and constructs a [`EntityConfiguration`](crate::model::EntityConfiguration).
        pub fn build(self) -> crate::model::EntityConfiguration {
            crate::model::EntityConfiguration {
                entity_id: self.entity_id,
                entity_type: self.entity_type,
            }
        }
    }
}
impl EntityConfiguration {
    /// Creates a new builder-style object to manufacture [`EntityConfiguration`](crate::model::EntityConfiguration).
    pub fn builder() -> crate::model::entity_configuration::Builder {
        crate::model::entity_configuration::Builder::default()
    }
}

/// When writing a match expression against `QuerySuggestionsStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let querysuggestionsstatus = unimplemented!();
/// match querysuggestionsstatus {
///     QuerySuggestionsStatus::Active => { /* ... */ },
///     QuerySuggestionsStatus::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `querysuggestionsstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `QuerySuggestionsStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `QuerySuggestionsStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `QuerySuggestionsStatus::NewFeature` is defined.
/// Specifically, when `querysuggestionsstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `QuerySuggestionsStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum QuerySuggestionsStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for QuerySuggestionsStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => QuerySuggestionsStatus::Active,
            "UPDATING" => QuerySuggestionsStatus::Updating,
            other => {
                QuerySuggestionsStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for QuerySuggestionsStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(QuerySuggestionsStatus::from(s))
    }
}
impl QuerySuggestionsStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            QuerySuggestionsStatus::Active => "ACTIVE",
            QuerySuggestionsStatus::Updating => "UPDATING",
            QuerySuggestionsStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "UPDATING"]
    }
}
impl AsRef<str> for QuerySuggestionsStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary information on the processing of <code>PUT</code> and <code>DELETE</code> actions for mapping users to their groups.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GroupOrderingIdSummary {
    /// <p>The current processing status of actions for mapping users to their groups. The status can be either <code>PROCESSING</code>, <code>SUCCEEDED</code>, <code>DELETING</code>, <code>DELETED</code>, or <code>FAILED</code>.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::PrincipalMappingStatus>,
    /// <p>The last date-time an action was updated. An action can be a <code>PUT</code> or <code>DELETE</code> action for mapping users to their groups.</p>
    #[doc(hidden)]
    pub last_updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date-time an action was received by Amazon Kendra. An action can be a <code>PUT</code> or <code>DELETE</code> action for mapping users to their groups.</p>
    #[doc(hidden)]
    pub received_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The order in which actions should complete processing. An action can be a <code>PUT</code> or <code>DELETE</code> action for mapping users to their groups.</p>
    #[doc(hidden)]
    pub ordering_id: std::option::Option<i64>,
    /// <p>The reason an action could not be processed. An action can be a <code>PUT</code> or <code>DELETE</code> action for mapping users to their groups.</p>
    #[doc(hidden)]
    pub failure_reason: std::option::Option<std::string::String>,
}
impl GroupOrderingIdSummary {
    /// <p>The current processing status of actions for mapping users to their groups. The status can be either <code>PROCESSING</code>, <code>SUCCEEDED</code>, <code>DELETING</code>, <code>DELETED</code>, or <code>FAILED</code>.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::PrincipalMappingStatus> {
        self.status.as_ref()
    }
    /// <p>The last date-time an action was updated. An action can be a <code>PUT</code> or <code>DELETE</code> action for mapping users to their groups.</p>
    pub fn last_updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_at.as_ref()
    }
    /// <p>The date-time an action was received by Amazon Kendra. An action can be a <code>PUT</code> or <code>DELETE</code> action for mapping users to their groups.</p>
    pub fn received_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.received_at.as_ref()
    }
    /// <p>The order in which actions should complete processing. An action can be a <code>PUT</code> or <code>DELETE</code> action for mapping users to their groups.</p>
    pub fn ordering_id(&self) -> std::option::Option<i64> {
        self.ordering_id
    }
    /// <p>The reason an action could not be processed. An action can be a <code>PUT</code> or <code>DELETE</code> action for mapping users to their groups.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
}
/// See [`GroupOrderingIdSummary`](crate::model::GroupOrderingIdSummary).
pub mod group_ordering_id_summary {

    /// A builder for [`GroupOrderingIdSummary`](crate::model::GroupOrderingIdSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::PrincipalMappingStatus>,
        pub(crate) last_updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) received_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) ordering_id: std::option::Option<i64>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The current processing status of actions for mapping users to their groups. The status can be either <code>PROCESSING</code>, <code>SUCCEEDED</code>, <code>DELETING</code>, <code>DELETED</code>, or <code>FAILED</code>.</p>
        pub fn status(mut self, input: crate::model::PrincipalMappingStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current processing status of actions for mapping users to their groups. The status can be either <code>PROCESSING</code>, <code>SUCCEEDED</code>, <code>DELETING</code>, <code>DELETED</code>, or <code>FAILED</code>.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::PrincipalMappingStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The last date-time an action was updated. An action can be a <code>PUT</code> or <code>DELETE</code> action for mapping users to their groups.</p>
        pub fn last_updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_at = Some(input);
            self
        }
        /// <p>The last date-time an action was updated. An action can be a <code>PUT</code> or <code>DELETE</code> action for mapping users to their groups.</p>
        pub fn set_last_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_at = input;
            self
        }
        /// <p>The date-time an action was received by Amazon Kendra. An action can be a <code>PUT</code> or <code>DELETE</code> action for mapping users to their groups.</p>
        pub fn received_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.received_at = Some(input);
            self
        }
        /// <p>The date-time an action was received by Amazon Kendra. An action can be a <code>PUT</code> or <code>DELETE</code> action for mapping users to their groups.</p>
        pub fn set_received_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.received_at = input;
            self
        }
        /// <p>The order in which actions should complete processing. An action can be a <code>PUT</code> or <code>DELETE</code> action for mapping users to their groups.</p>
        pub fn ordering_id(mut self, input: i64) -> Self {
            self.ordering_id = Some(input);
            self
        }
        /// <p>The order in which actions should complete processing. An action can be a <code>PUT</code> or <code>DELETE</code> action for mapping users to their groups.</p>
        pub fn set_ordering_id(mut self, input: std::option::Option<i64>) -> Self {
            self.ordering_id = input;
            self
        }
        /// <p>The reason an action could not be processed. An action can be a <code>PUT</code> or <code>DELETE</code> action for mapping users to their groups.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>The reason an action could not be processed. An action can be a <code>PUT</code> or <code>DELETE</code> action for mapping users to their groups.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`GroupOrderingIdSummary`](crate::model::GroupOrderingIdSummary).
        pub fn build(self) -> crate::model::GroupOrderingIdSummary {
            crate::model::GroupOrderingIdSummary {
                status: self.status,
                last_updated_at: self.last_updated_at,
                received_at: self.received_at,
                ordering_id: self.ordering_id,
                failure_reason: self.failure_reason,
            }
        }
    }
}
impl GroupOrderingIdSummary {
    /// Creates a new builder-style object to manufacture [`GroupOrderingIdSummary`](crate::model::GroupOrderingIdSummary).
    pub fn builder() -> crate::model::group_ordering_id_summary::Builder {
        crate::model::group_ordering_id_summary::Builder::default()
    }
}

/// When writing a match expression against `PrincipalMappingStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let principalmappingstatus = unimplemented!();
/// match principalmappingstatus {
///     PrincipalMappingStatus::Deleted => { /* ... */ },
///     PrincipalMappingStatus::Deleting => { /* ... */ },
///     PrincipalMappingStatus::Failed => { /* ... */ },
///     PrincipalMappingStatus::Processing => { /* ... */ },
///     PrincipalMappingStatus::Succeeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `principalmappingstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PrincipalMappingStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PrincipalMappingStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PrincipalMappingStatus::NewFeature` is defined.
/// Specifically, when `principalmappingstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PrincipalMappingStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PrincipalMappingStatus {
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Processing,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PrincipalMappingStatus {
    fn from(s: &str) -> Self {
        match s {
            "DELETED" => PrincipalMappingStatus::Deleted,
            "DELETING" => PrincipalMappingStatus::Deleting,
            "FAILED" => PrincipalMappingStatus::Failed,
            "PROCESSING" => PrincipalMappingStatus::Processing,
            "SUCCEEDED" => PrincipalMappingStatus::Succeeded,
            other => {
                PrincipalMappingStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for PrincipalMappingStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PrincipalMappingStatus::from(s))
    }
}
impl PrincipalMappingStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PrincipalMappingStatus::Deleted => "DELETED",
            PrincipalMappingStatus::Deleting => "DELETING",
            PrincipalMappingStatus::Failed => "FAILED",
            PrincipalMappingStatus::Processing => "PROCESSING",
            PrincipalMappingStatus::Succeeded => "SUCCEEDED",
            PrincipalMappingStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DELETED", "DELETING", "FAILED", "PROCESSING", "SUCCEEDED"]
    }
}
impl AsRef<str> for PrincipalMappingStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information about the number of documents and the number of questions and answers in an index.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IndexStatistics {
    /// <p>The number of question and answer topics in the index.</p>
    #[doc(hidden)]
    pub faq_statistics: std::option::Option<crate::model::FaqStatistics>,
    /// <p>The number of text documents indexed.</p>
    #[doc(hidden)]
    pub text_document_statistics: std::option::Option<crate::model::TextDocumentStatistics>,
}
impl IndexStatistics {
    /// <p>The number of question and answer topics in the index.</p>
    pub fn faq_statistics(&self) -> std::option::Option<&crate::model::FaqStatistics> {
        self.faq_statistics.as_ref()
    }
    /// <p>The number of text documents indexed.</p>
    pub fn text_document_statistics(
        &self,
    ) -> std::option::Option<&crate::model::TextDocumentStatistics> {
        self.text_document_statistics.as_ref()
    }
}
/// See [`IndexStatistics`](crate::model::IndexStatistics).
pub mod index_statistics {

    /// A builder for [`IndexStatistics`](crate::model::IndexStatistics).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) faq_statistics: std::option::Option<crate::model::FaqStatistics>,
        pub(crate) text_document_statistics:
            std::option::Option<crate::model::TextDocumentStatistics>,
    }
    impl Builder {
        /// <p>The number of question and answer topics in the index.</p>
        pub fn faq_statistics(mut self, input: crate::model::FaqStatistics) -> Self {
            self.faq_statistics = Some(input);
            self
        }
        /// <p>The number of question and answer topics in the index.</p>
        pub fn set_faq_statistics(
            mut self,
            input: std::option::Option<crate::model::FaqStatistics>,
        ) -> Self {
            self.faq_statistics = input;
            self
        }
        /// <p>The number of text documents indexed.</p>
        pub fn text_document_statistics(
            mut self,
            input: crate::model::TextDocumentStatistics,
        ) -> Self {
            self.text_document_statistics = Some(input);
            self
        }
        /// <p>The number of text documents indexed.</p>
        pub fn set_text_document_statistics(
            mut self,
            input: std::option::Option<crate::model::TextDocumentStatistics>,
        ) -> Self {
            self.text_document_statistics = input;
            self
        }
        /// Consumes the builder and constructs a [`IndexStatistics`](crate::model::IndexStatistics).
        pub fn build(self) -> crate::model::IndexStatistics {
            crate::model::IndexStatistics {
                faq_statistics: self.faq_statistics,
                text_document_statistics: self.text_document_statistics,
            }
        }
    }
}
impl IndexStatistics {
    /// Creates a new builder-style object to manufacture [`IndexStatistics`](crate::model::IndexStatistics).
    pub fn builder() -> crate::model::index_statistics::Builder {
        crate::model::index_statistics::Builder::default()
    }
}

/// <p>Provides information about text documents indexed in an index.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TextDocumentStatistics {
    /// <p>The number of text documents indexed.</p>
    #[doc(hidden)]
    pub indexed_text_documents_count: i32,
    /// <p>The total size, in bytes, of the indexed documents.</p>
    #[doc(hidden)]
    pub indexed_text_bytes: i64,
}
impl TextDocumentStatistics {
    /// <p>The number of text documents indexed.</p>
    pub fn indexed_text_documents_count(&self) -> i32 {
        self.indexed_text_documents_count
    }
    /// <p>The total size, in bytes, of the indexed documents.</p>
    pub fn indexed_text_bytes(&self) -> i64 {
        self.indexed_text_bytes
    }
}
/// See [`TextDocumentStatistics`](crate::model::TextDocumentStatistics).
pub mod text_document_statistics {

    /// A builder for [`TextDocumentStatistics`](crate::model::TextDocumentStatistics).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) indexed_text_documents_count: std::option::Option<i32>,
        pub(crate) indexed_text_bytes: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The number of text documents indexed.</p>
        pub fn indexed_text_documents_count(mut self, input: i32) -> Self {
            self.indexed_text_documents_count = Some(input);
            self
        }
        /// <p>The number of text documents indexed.</p>
        pub fn set_indexed_text_documents_count(mut self, input: std::option::Option<i32>) -> Self {
            self.indexed_text_documents_count = input;
            self
        }
        /// <p>The total size, in bytes, of the indexed documents.</p>
        pub fn indexed_text_bytes(mut self, input: i64) -> Self {
            self.indexed_text_bytes = Some(input);
            self
        }
        /// <p>The total size, in bytes, of the indexed documents.</p>
        pub fn set_indexed_text_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.indexed_text_bytes = input;
            self
        }
        /// Consumes the builder and constructs a [`TextDocumentStatistics`](crate::model::TextDocumentStatistics).
        pub fn build(self) -> crate::model::TextDocumentStatistics {
            crate::model::TextDocumentStatistics {
                indexed_text_documents_count: self.indexed_text_documents_count.unwrap_or_default(),
                indexed_text_bytes: self.indexed_text_bytes.unwrap_or_default(),
            }
        }
    }
}
impl TextDocumentStatistics {
    /// Creates a new builder-style object to manufacture [`TextDocumentStatistics`](crate::model::TextDocumentStatistics).
    pub fn builder() -> crate::model::text_document_statistics::Builder {
        crate::model::text_document_statistics::Builder::default()
    }
}

/// <p>Provides statistical information about the FAQ questions and answers contained in an index.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FaqStatistics {
    /// <p>The total number of FAQ questions and answers contained in the index.</p>
    #[doc(hidden)]
    pub indexed_question_answers_count: i32,
}
impl FaqStatistics {
    /// <p>The total number of FAQ questions and answers contained in the index.</p>
    pub fn indexed_question_answers_count(&self) -> i32 {
        self.indexed_question_answers_count
    }
}
/// See [`FaqStatistics`](crate::model::FaqStatistics).
pub mod faq_statistics {

    /// A builder for [`FaqStatistics`](crate::model::FaqStatistics).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) indexed_question_answers_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The total number of FAQ questions and answers contained in the index.</p>
        pub fn indexed_question_answers_count(mut self, input: i32) -> Self {
            self.indexed_question_answers_count = Some(input);
            self
        }
        /// <p>The total number of FAQ questions and answers contained in the index.</p>
        pub fn set_indexed_question_answers_count(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.indexed_question_answers_count = input;
            self
        }
        /// Consumes the builder and constructs a [`FaqStatistics`](crate::model::FaqStatistics).
        pub fn build(self) -> crate::model::FaqStatistics {
            crate::model::FaqStatistics {
                indexed_question_answers_count: self
                    .indexed_question_answers_count
                    .unwrap_or_default(),
            }
        }
    }
}
impl FaqStatistics {
    /// Creates a new builder-style object to manufacture [`FaqStatistics`](crate::model::FaqStatistics).
    pub fn builder() -> crate::model::faq_statistics::Builder {
        crate::model::faq_statistics::Builder::default()
    }
}

/// <p>Provides the identifier of the KMS key used to encrypt data indexed by Amazon Kendra. Amazon Kendra doesn't support asymmetric keys.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServerSideEncryptionConfiguration {
    /// <p>The identifier of the KMS key. Amazon Kendra doesn't support asymmetric keys.</p>
    #[doc(hidden)]
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl ServerSideEncryptionConfiguration {
    /// <p>The identifier of the KMS key. Amazon Kendra doesn't support asymmetric keys.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
}
impl std::fmt::Debug for ServerSideEncryptionConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServerSideEncryptionConfiguration");
        formatter.field("kms_key_id", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`ServerSideEncryptionConfiguration`](crate::model::ServerSideEncryptionConfiguration).
pub mod server_side_encryption_configuration {

    /// A builder for [`ServerSideEncryptionConfiguration`](crate::model::ServerSideEncryptionConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the KMS key. Amazon Kendra doesn't support asymmetric keys.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The identifier of the KMS key. Amazon Kendra doesn't support asymmetric keys.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ServerSideEncryptionConfiguration`](crate::model::ServerSideEncryptionConfiguration).
        pub fn build(self) -> crate::model::ServerSideEncryptionConfiguration {
            crate::model::ServerSideEncryptionConfiguration {
                kms_key_id: self.kms_key_id,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("kms_key_id", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl ServerSideEncryptionConfiguration {
    /// Creates a new builder-style object to manufacture [`ServerSideEncryptionConfiguration`](crate::model::ServerSideEncryptionConfiguration).
    pub fn builder() -> crate::model::server_side_encryption_configuration::Builder {
        crate::model::server_side_encryption_configuration::Builder::default()
    }
}

/// <p>Provides information about a document that could not be indexed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchPutDocumentResponseFailedDocument {
    /// <p>The identifier of the document.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The type of error that caused the document to fail to be indexed.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<crate::model::ErrorCode>,
    /// <p>A description of the reason why the document could not be indexed.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl BatchPutDocumentResponseFailedDocument {
    /// <p>The identifier of the document.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The type of error that caused the document to fail to be indexed.</p>
    pub fn error_code(&self) -> std::option::Option<&crate::model::ErrorCode> {
        self.error_code.as_ref()
    }
    /// <p>A description of the reason why the document could not be indexed.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
/// See [`BatchPutDocumentResponseFailedDocument`](crate::model::BatchPutDocumentResponseFailedDocument).
pub mod batch_put_document_response_failed_document {

    /// A builder for [`BatchPutDocumentResponseFailedDocument`](crate::model::BatchPutDocumentResponseFailedDocument).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the document.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the document.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The type of error that caused the document to fail to be indexed.</p>
        pub fn error_code(mut self, input: crate::model::ErrorCode) -> Self {
            self.error_code = Some(input);
            self
        }
        /// <p>The type of error that caused the document to fail to be indexed.</p>
        pub fn set_error_code(
            mut self,
            input: std::option::Option<crate::model::ErrorCode>,
        ) -> Self {
            self.error_code = input;
            self
        }
        /// <p>A description of the reason why the document could not be indexed.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>A description of the reason why the document could not be indexed.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchPutDocumentResponseFailedDocument`](crate::model::BatchPutDocumentResponseFailedDocument).
        pub fn build(self) -> crate::model::BatchPutDocumentResponseFailedDocument {
            crate::model::BatchPutDocumentResponseFailedDocument {
                id: self.id,
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}
impl BatchPutDocumentResponseFailedDocument {
    /// Creates a new builder-style object to manufacture [`BatchPutDocumentResponseFailedDocument`](crate::model::BatchPutDocumentResponseFailedDocument).
    pub fn builder() -> crate::model::batch_put_document_response_failed_document::Builder {
        crate::model::batch_put_document_response_failed_document::Builder::default()
    }
}

/// <p>A document in an index.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Document {
    /// <p>A identifier of the document in the index.</p>
    /// <p>Note, each document ID must be unique per index. You cannot create a data source to index your documents with their unique IDs and then use the <code>BatchPutDocument</code> API to index the same documents, or vice versa. You can delete a data source and then use the <code>BatchPutDocument</code> API to index the same documents, or vice versa.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The title of the document.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The contents of the document. </p>
    /// <p>Documents passed to the <code>Blob</code> parameter must be base64 encoded. Your code might not need to encode the document file bytes if you're using an Amazon Web Services SDK to call Amazon Kendra APIs. If you are calling the Amazon Kendra endpoint directly using REST, you must base64 encode the contents before sending.</p>
    #[doc(hidden)]
    pub blob: std::option::Option<aws_smithy_types::Blob>,
    /// <p>Information required to find a specific file in an Amazon S3 bucket.</p>
    #[doc(hidden)]
    pub s3_path: std::option::Option<crate::model::S3Path>,
    /// <p>Custom attributes to apply to the document. Use the custom attributes to provide additional information for searching, to provide facets for refining searches, and to provide additional information in the query response.</p>
    /// <p>For example, 'DataSourceId' and 'DataSourceSyncJobId' are custom attributes that provide information on the synchronization of documents running on a data source. Note, 'DataSourceSyncJobId' could be an optional custom attribute as Amazon Kendra will use the ID of a running sync job.</p>
    #[doc(hidden)]
    pub attributes: std::option::Option<std::vec::Vec<crate::model::DocumentAttribute>>,
    /// <p>Information on principals (users and/or groups) and which documents they should have access to. This is useful for user context filtering, where search results are filtered based on the user or their group access to documents.</p>
    #[doc(hidden)]
    pub access_control_list: std::option::Option<std::vec::Vec<crate::model::Principal>>,
    /// <p>The list of <a href="https://docs.aws.amazon.com/kendra/latest/dg/API_Principal.html">principal</a> lists that define the hierarchy for which documents users should have access to.</p>
    #[doc(hidden)]
    pub hierarchical_access_control_list:
        std::option::Option<std::vec::Vec<crate::model::HierarchicalPrincipal>>,
    /// <p>The file type of the document in the <code>Blob</code> field.</p>
    #[doc(hidden)]
    pub content_type: std::option::Option<crate::model::ContentType>,
    /// <p>The identifier of the access control configuration that you want to apply to the document.</p>
    #[doc(hidden)]
    pub access_control_configuration_id: std::option::Option<std::string::String>,
}
impl Document {
    /// <p>A identifier of the document in the index.</p>
    /// <p>Note, each document ID must be unique per index. You cannot create a data source to index your documents with their unique IDs and then use the <code>BatchPutDocument</code> API to index the same documents, or vice versa. You can delete a data source and then use the <code>BatchPutDocument</code> API to index the same documents, or vice versa.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The title of the document.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>The contents of the document. </p>
    /// <p>Documents passed to the <code>Blob</code> parameter must be base64 encoded. Your code might not need to encode the document file bytes if you're using an Amazon Web Services SDK to call Amazon Kendra APIs. If you are calling the Amazon Kendra endpoint directly using REST, you must base64 encode the contents before sending.</p>
    pub fn blob(&self) -> std::option::Option<&aws_smithy_types::Blob> {
        self.blob.as_ref()
    }
    /// <p>Information required to find a specific file in an Amazon S3 bucket.</p>
    pub fn s3_path(&self) -> std::option::Option<&crate::model::S3Path> {
        self.s3_path.as_ref()
    }
    /// <p>Custom attributes to apply to the document. Use the custom attributes to provide additional information for searching, to provide facets for refining searches, and to provide additional information in the query response.</p>
    /// <p>For example, 'DataSourceId' and 'DataSourceSyncJobId' are custom attributes that provide information on the synchronization of documents running on a data source. Note, 'DataSourceSyncJobId' could be an optional custom attribute as Amazon Kendra will use the ID of a running sync job.</p>
    pub fn attributes(&self) -> std::option::Option<&[crate::model::DocumentAttribute]> {
        self.attributes.as_deref()
    }
    /// <p>Information on principals (users and/or groups) and which documents they should have access to. This is useful for user context filtering, where search results are filtered based on the user or their group access to documents.</p>
    pub fn access_control_list(&self) -> std::option::Option<&[crate::model::Principal]> {
        self.access_control_list.as_deref()
    }
    /// <p>The list of <a href="https://docs.aws.amazon.com/kendra/latest/dg/API_Principal.html">principal</a> lists that define the hierarchy for which documents users should have access to.</p>
    pub fn hierarchical_access_control_list(
        &self,
    ) -> std::option::Option<&[crate::model::HierarchicalPrincipal]> {
        self.hierarchical_access_control_list.as_deref()
    }
    /// <p>The file type of the document in the <code>Blob</code> field.</p>
    pub fn content_type(&self) -> std::option::Option<&crate::model::ContentType> {
        self.content_type.as_ref()
    }
    /// <p>The identifier of the access control configuration that you want to apply to the document.</p>
    pub fn access_control_configuration_id(&self) -> std::option::Option<&str> {
        self.access_control_configuration_id.as_deref()
    }
}
/// See [`Document`](crate::model::Document).
pub mod document {

    /// A builder for [`Document`](crate::model::Document).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) blob: std::option::Option<aws_smithy_types::Blob>,
        pub(crate) s3_path: std::option::Option<crate::model::S3Path>,
        pub(crate) attributes: std::option::Option<std::vec::Vec<crate::model::DocumentAttribute>>,
        pub(crate) access_control_list: std::option::Option<std::vec::Vec<crate::model::Principal>>,
        pub(crate) hierarchical_access_control_list:
            std::option::Option<std::vec::Vec<crate::model::HierarchicalPrincipal>>,
        pub(crate) content_type: std::option::Option<crate::model::ContentType>,
        pub(crate) access_control_configuration_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A identifier of the document in the index.</p>
        /// <p>Note, each document ID must be unique per index. You cannot create a data source to index your documents with their unique IDs and then use the <code>BatchPutDocument</code> API to index the same documents, or vice versa. You can delete a data source and then use the <code>BatchPutDocument</code> API to index the same documents, or vice versa.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>A identifier of the document in the index.</p>
        /// <p>Note, each document ID must be unique per index. You cannot create a data source to index your documents with their unique IDs and then use the <code>BatchPutDocument</code> API to index the same documents, or vice versa. You can delete a data source and then use the <code>BatchPutDocument</code> API to index the same documents, or vice versa.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The title of the document.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title of the document.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The contents of the document. </p>
        /// <p>Documents passed to the <code>Blob</code> parameter must be base64 encoded. Your code might not need to encode the document file bytes if you're using an Amazon Web Services SDK to call Amazon Kendra APIs. If you are calling the Amazon Kendra endpoint directly using REST, you must base64 encode the contents before sending.</p>
        pub fn blob(mut self, input: aws_smithy_types::Blob) -> Self {
            self.blob = Some(input);
            self
        }
        /// <p>The contents of the document. </p>
        /// <p>Documents passed to the <code>Blob</code> parameter must be base64 encoded. Your code might not need to encode the document file bytes if you're using an Amazon Web Services SDK to call Amazon Kendra APIs. If you are calling the Amazon Kendra endpoint directly using REST, you must base64 encode the contents before sending.</p>
        pub fn set_blob(mut self, input: std::option::Option<aws_smithy_types::Blob>) -> Self {
            self.blob = input;
            self
        }
        /// <p>Information required to find a specific file in an Amazon S3 bucket.</p>
        pub fn s3_path(mut self, input: crate::model::S3Path) -> Self {
            self.s3_path = Some(input);
            self
        }
        /// <p>Information required to find a specific file in an Amazon S3 bucket.</p>
        pub fn set_s3_path(mut self, input: std::option::Option<crate::model::S3Path>) -> Self {
            self.s3_path = input;
            self
        }
        /// Appends an item to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>Custom attributes to apply to the document. Use the custom attributes to provide additional information for searching, to provide facets for refining searches, and to provide additional information in the query response.</p>
        /// <p>For example, 'DataSourceId' and 'DataSourceSyncJobId' are custom attributes that provide information on the synchronization of documents running on a data source. Note, 'DataSourceSyncJobId' could be an optional custom attribute as Amazon Kendra will use the ID of a running sync job.</p>
        pub fn attributes(mut self, input: crate::model::DocumentAttribute) -> Self {
            let mut v = self.attributes.unwrap_or_default();
            v.push(input);
            self.attributes = Some(v);
            self
        }
        /// <p>Custom attributes to apply to the document. Use the custom attributes to provide additional information for searching, to provide facets for refining searches, and to provide additional information in the query response.</p>
        /// <p>For example, 'DataSourceId' and 'DataSourceSyncJobId' are custom attributes that provide information on the synchronization of documents running on a data source. Note, 'DataSourceSyncJobId' could be an optional custom attribute as Amazon Kendra will use the ID of a running sync job.</p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DocumentAttribute>>,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// Appends an item to `access_control_list`.
        ///
        /// To override the contents of this collection use [`set_access_control_list`](Self::set_access_control_list).
        ///
        /// <p>Information on principals (users and/or groups) and which documents they should have access to. This is useful for user context filtering, where search results are filtered based on the user or their group access to documents.</p>
        pub fn access_control_list(mut self, input: crate::model::Principal) -> Self {
            let mut v = self.access_control_list.unwrap_or_default();
            v.push(input);
            self.access_control_list = Some(v);
            self
        }
        /// <p>Information on principals (users and/or groups) and which documents they should have access to. This is useful for user context filtering, where search results are filtered based on the user or their group access to documents.</p>
        pub fn set_access_control_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Principal>>,
        ) -> Self {
            self.access_control_list = input;
            self
        }
        /// Appends an item to `hierarchical_access_control_list`.
        ///
        /// To override the contents of this collection use [`set_hierarchical_access_control_list`](Self::set_hierarchical_access_control_list).
        ///
        /// <p>The list of <a href="https://docs.aws.amazon.com/kendra/latest/dg/API_Principal.html">principal</a> lists that define the hierarchy for which documents users should have access to.</p>
        pub fn hierarchical_access_control_list(
            mut self,
            input: crate::model::HierarchicalPrincipal,
        ) -> Self {
            let mut v = self.hierarchical_access_control_list.unwrap_or_default();
            v.push(input);
            self.hierarchical_access_control_list = Some(v);
            self
        }
        /// <p>The list of <a href="https://docs.aws.amazon.com/kendra/latest/dg/API_Principal.html">principal</a> lists that define the hierarchy for which documents users should have access to.</p>
        pub fn set_hierarchical_access_control_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HierarchicalPrincipal>>,
        ) -> Self {
            self.hierarchical_access_control_list = input;
            self
        }
        /// <p>The file type of the document in the <code>Blob</code> field.</p>
        pub fn content_type(mut self, input: crate::model::ContentType) -> Self {
            self.content_type = Some(input);
            self
        }
        /// <p>The file type of the document in the <code>Blob</code> field.</p>
        pub fn set_content_type(
            mut self,
            input: std::option::Option<crate::model::ContentType>,
        ) -> Self {
            self.content_type = input;
            self
        }
        /// <p>The identifier of the access control configuration that you want to apply to the document.</p>
        pub fn access_control_configuration_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.access_control_configuration_id = Some(input.into());
            self
        }
        /// <p>The identifier of the access control configuration that you want to apply to the document.</p>
        pub fn set_access_control_configuration_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.access_control_configuration_id = input;
            self
        }
        /// Consumes the builder and constructs a [`Document`](crate::model::Document).
        pub fn build(self) -> crate::model::Document {
            crate::model::Document {
                id: self.id,
                title: self.title,
                blob: self.blob,
                s3_path: self.s3_path,
                attributes: self.attributes,
                access_control_list: self.access_control_list,
                hierarchical_access_control_list: self.hierarchical_access_control_list,
                content_type: self.content_type,
                access_control_configuration_id: self.access_control_configuration_id,
            }
        }
    }
}
impl Document {
    /// Creates a new builder-style object to manufacture [`Document`](crate::model::Document).
    pub fn builder() -> crate::model::document::Builder {
        crate::model::document::Builder::default()
    }
}

/// When writing a match expression against `ContentType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let contenttype = unimplemented!();
/// match contenttype {
///     ContentType::Csv => { /* ... */ },
///     ContentType::Html => { /* ... */ },
///     ContentType::Json => { /* ... */ },
///     ContentType::Md => { /* ... */ },
///     ContentType::MsExcel => { /* ... */ },
///     ContentType::MsWord => { /* ... */ },
///     ContentType::Pdf => { /* ... */ },
///     ContentType::PlainText => { /* ... */ },
///     ContentType::Ppt => { /* ... */ },
///     ContentType::Rtf => { /* ... */ },
///     ContentType::Xml => { /* ... */ },
///     ContentType::Xslt => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `contenttype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ContentType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ContentType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ContentType::NewFeature` is defined.
/// Specifically, when `contenttype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ContentType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContentType {
    #[allow(missing_docs)] // documentation missing in model
    Csv,
    #[allow(missing_docs)] // documentation missing in model
    Html,
    #[allow(missing_docs)] // documentation missing in model
    Json,
    #[allow(missing_docs)] // documentation missing in model
    Md,
    #[allow(missing_docs)] // documentation missing in model
    MsExcel,
    #[allow(missing_docs)] // documentation missing in model
    MsWord,
    #[allow(missing_docs)] // documentation missing in model
    Pdf,
    #[allow(missing_docs)] // documentation missing in model
    PlainText,
    #[allow(missing_docs)] // documentation missing in model
    Ppt,
    #[allow(missing_docs)] // documentation missing in model
    Rtf,
    #[allow(missing_docs)] // documentation missing in model
    Xml,
    #[allow(missing_docs)] // documentation missing in model
    Xslt,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ContentType {
    fn from(s: &str) -> Self {
        match s {
            "CSV" => ContentType::Csv,
            "HTML" => ContentType::Html,
            "JSON" => ContentType::Json,
            "MD" => ContentType::Md,
            "MS_EXCEL" => ContentType::MsExcel,
            "MS_WORD" => ContentType::MsWord,
            "PDF" => ContentType::Pdf,
            "PLAIN_TEXT" => ContentType::PlainText,
            "PPT" => ContentType::Ppt,
            "RTF" => ContentType::Rtf,
            "XML" => ContentType::Xml,
            "XSLT" => ContentType::Xslt,
            other => ContentType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ContentType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ContentType::from(s))
    }
}
impl ContentType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ContentType::Csv => "CSV",
            ContentType::Html => "HTML",
            ContentType::Json => "JSON",
            ContentType::Md => "MD",
            ContentType::MsExcel => "MS_EXCEL",
            ContentType::MsWord => "MS_WORD",
            ContentType::Pdf => "PDF",
            ContentType::PlainText => "PLAIN_TEXT",
            ContentType::Ppt => "PPT",
            ContentType::Rtf => "RTF",
            ContentType::Xml => "XML",
            ContentType::Xslt => "XSLT",
            ContentType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CSV",
            "HTML",
            "JSON",
            "MD",
            "MS_EXCEL",
            "MS_WORD",
            "PDF",
            "PLAIN_TEXT",
            "PPT",
            "RTF",
            "XML",
            "XSLT",
        ]
    }
}
impl AsRef<str> for ContentType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information about the status of documents submitted for indexing.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Status {
    /// <p>The identifier of the document.</p>
    #[doc(hidden)]
    pub document_id: std::option::Option<std::string::String>,
    /// <p>The current status of a document.</p>
    /// <p>If the document was submitted for deletion, the status is <code>NOT_FOUND</code> after the document is deleted.</p>
    #[doc(hidden)]
    pub document_status: std::option::Option<crate::model::DocumentStatus>,
    /// <p>Indicates the source of the error.</p>
    #[doc(hidden)]
    pub failure_code: std::option::Option<std::string::String>,
    /// <p>Provides detailed information about why the document couldn't be indexed. Use this information to correct the error before you resubmit the document for indexing.</p>
    #[doc(hidden)]
    pub failure_reason: std::option::Option<std::string::String>,
}
impl Status {
    /// <p>The identifier of the document.</p>
    pub fn document_id(&self) -> std::option::Option<&str> {
        self.document_id.as_deref()
    }
    /// <p>The current status of a document.</p>
    /// <p>If the document was submitted for deletion, the status is <code>NOT_FOUND</code> after the document is deleted.</p>
    pub fn document_status(&self) -> std::option::Option<&crate::model::DocumentStatus> {
        self.document_status.as_ref()
    }
    /// <p>Indicates the source of the error.</p>
    pub fn failure_code(&self) -> std::option::Option<&str> {
        self.failure_code.as_deref()
    }
    /// <p>Provides detailed information about why the document couldn't be indexed. Use this information to correct the error before you resubmit the document for indexing.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
}
/// See [`Status`](crate::model::Status).
pub mod status {

    /// A builder for [`Status`](crate::model::Status).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_id: std::option::Option<std::string::String>,
        pub(crate) document_status: std::option::Option<crate::model::DocumentStatus>,
        pub(crate) failure_code: std::option::Option<std::string::String>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the document.</p>
        pub fn document_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_id = Some(input.into());
            self
        }
        /// <p>The identifier of the document.</p>
        pub fn set_document_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.document_id = input;
            self
        }
        /// <p>The current status of a document.</p>
        /// <p>If the document was submitted for deletion, the status is <code>NOT_FOUND</code> after the document is deleted.</p>
        pub fn document_status(mut self, input: crate::model::DocumentStatus) -> Self {
            self.document_status = Some(input);
            self
        }
        /// <p>The current status of a document.</p>
        /// <p>If the document was submitted for deletion, the status is <code>NOT_FOUND</code> after the document is deleted.</p>
        pub fn set_document_status(
            mut self,
            input: std::option::Option<crate::model::DocumentStatus>,
        ) -> Self {
            self.document_status = input;
            self
        }
        /// <p>Indicates the source of the error.</p>
        pub fn failure_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_code = Some(input.into());
            self
        }
        /// <p>Indicates the source of the error.</p>
        pub fn set_failure_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.failure_code = input;
            self
        }
        /// <p>Provides detailed information about why the document couldn't be indexed. Use this information to correct the error before you resubmit the document for indexing.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>Provides detailed information about why the document couldn't be indexed. Use this information to correct the error before you resubmit the document for indexing.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`Status`](crate::model::Status).
        pub fn build(self) -> crate::model::Status {
            crate::model::Status {
                document_id: self.document_id,
                document_status: self.document_status,
                failure_code: self.failure_code,
                failure_reason: self.failure_reason,
            }
        }
    }
}
impl Status {
    /// Creates a new builder-style object to manufacture [`Status`](crate::model::Status).
    pub fn builder() -> crate::model::status::Builder {
        crate::model::status::Builder::default()
    }
}

/// When writing a match expression against `DocumentStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let documentstatus = unimplemented!();
/// match documentstatus {
///     DocumentStatus::Failed => { /* ... */ },
///     DocumentStatus::Indexed => { /* ... */ },
///     DocumentStatus::NotFound => { /* ... */ },
///     DocumentStatus::Processing => { /* ... */ },
///     DocumentStatus::Updated => { /* ... */ },
///     DocumentStatus::UpdateFailed => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `documentstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DocumentStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DocumentStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DocumentStatus::NewFeature` is defined.
/// Specifically, when `documentstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DocumentStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DocumentStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Indexed,
    #[allow(missing_docs)] // documentation missing in model
    NotFound,
    #[allow(missing_docs)] // documentation missing in model
    Processing,
    #[allow(missing_docs)] // documentation missing in model
    Updated,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFailed,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DocumentStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => DocumentStatus::Failed,
            "INDEXED" => DocumentStatus::Indexed,
            "NOT_FOUND" => DocumentStatus::NotFound,
            "PROCESSING" => DocumentStatus::Processing,
            "UPDATED" => DocumentStatus::Updated,
            "UPDATE_FAILED" => DocumentStatus::UpdateFailed,
            other => DocumentStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DocumentStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DocumentStatus::from(s))
    }
}
impl DocumentStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DocumentStatus::Failed => "FAILED",
            DocumentStatus::Indexed => "INDEXED",
            DocumentStatus::NotFound => "NOT_FOUND",
            DocumentStatus::Processing => "PROCESSING",
            DocumentStatus::Updated => "UPDATED",
            DocumentStatus::UpdateFailed => "UPDATE_FAILED",
            DocumentStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "FAILED",
            "INDEXED",
            "NOT_FOUND",
            "PROCESSING",
            "UPDATED",
            "UPDATE_FAILED",
        ]
    }
}
impl AsRef<str> for DocumentStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides a response when the status of a document could not be retrieved.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchGetDocumentStatusResponseError {
    /// <p>The identifier of the document whose status could not be retrieved.</p>
    #[doc(hidden)]
    pub document_id: std::option::Option<std::string::String>,
    /// <p>Indicates the source of the error.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<crate::model::ErrorCode>,
    /// <p>States that the API could not get the status of a document. This could be because the request is not valid or there is a system error.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl BatchGetDocumentStatusResponseError {
    /// <p>The identifier of the document whose status could not be retrieved.</p>
    pub fn document_id(&self) -> std::option::Option<&str> {
        self.document_id.as_deref()
    }
    /// <p>Indicates the source of the error.</p>
    pub fn error_code(&self) -> std::option::Option<&crate::model::ErrorCode> {
        self.error_code.as_ref()
    }
    /// <p>States that the API could not get the status of a document. This could be because the request is not valid or there is a system error.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
/// See [`BatchGetDocumentStatusResponseError`](crate::model::BatchGetDocumentStatusResponseError).
pub mod batch_get_document_status_response_error {

    /// A builder for [`BatchGetDocumentStatusResponseError`](crate::model::BatchGetDocumentStatusResponseError).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_id: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the document whose status could not be retrieved.</p>
        pub fn document_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_id = Some(input.into());
            self
        }
        /// <p>The identifier of the document whose status could not be retrieved.</p>
        pub fn set_document_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.document_id = input;
            self
        }
        /// <p>Indicates the source of the error.</p>
        pub fn error_code(mut self, input: crate::model::ErrorCode) -> Self {
            self.error_code = Some(input);
            self
        }
        /// <p>Indicates the source of the error.</p>
        pub fn set_error_code(
            mut self,
            input: std::option::Option<crate::model::ErrorCode>,
        ) -> Self {
            self.error_code = input;
            self
        }
        /// <p>States that the API could not get the status of a document. This could be because the request is not valid or there is a system error.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>States that the API could not get the status of a document. This could be because the request is not valid or there is a system error.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchGetDocumentStatusResponseError`](crate::model::BatchGetDocumentStatusResponseError).
        pub fn build(self) -> crate::model::BatchGetDocumentStatusResponseError {
            crate::model::BatchGetDocumentStatusResponseError {
                document_id: self.document_id,
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}
impl BatchGetDocumentStatusResponseError {
    /// Creates a new builder-style object to manufacture [`BatchGetDocumentStatusResponseError`](crate::model::BatchGetDocumentStatusResponseError).
    pub fn builder() -> crate::model::batch_get_document_status_response_error::Builder {
        crate::model::batch_get_document_status_response_error::Builder::default()
    }
}

/// <p>Identifies a document for which to retrieve status information</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DocumentInfo {
    /// <p>The identifier of the document.</p>
    #[doc(hidden)]
    pub document_id: std::option::Option<std::string::String>,
    /// <p>Attributes that identify a specific version of a document to check.</p>
    /// <p>The only valid attributes are:</p>
    /// <ul>
    /// <li> <p>version</p> </li>
    /// <li> <p>datasourceId</p> </li>
    /// <li> <p>jobExecutionId</p> </li>
    /// </ul>
    /// <p>The attributes follow these rules:</p>
    /// <ul>
    /// <li> <p> <code>dataSourceId</code> and <code>jobExecutionId</code> must be used together.</p> </li>
    /// <li> <p> <code>version</code> is ignored if <code>dataSourceId</code> and <code>jobExecutionId</code> are not provided.</p> </li>
    /// <li> <p>If <code>dataSourceId</code> and <code>jobExecutionId</code> are provided, but <code>version</code> is not, the version defaults to "0".</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub attributes: std::option::Option<std::vec::Vec<crate::model::DocumentAttribute>>,
}
impl DocumentInfo {
    /// <p>The identifier of the document.</p>
    pub fn document_id(&self) -> std::option::Option<&str> {
        self.document_id.as_deref()
    }
    /// <p>Attributes that identify a specific version of a document to check.</p>
    /// <p>The only valid attributes are:</p>
    /// <ul>
    /// <li> <p>version</p> </li>
    /// <li> <p>datasourceId</p> </li>
    /// <li> <p>jobExecutionId</p> </li>
    /// </ul>
    /// <p>The attributes follow these rules:</p>
    /// <ul>
    /// <li> <p> <code>dataSourceId</code> and <code>jobExecutionId</code> must be used together.</p> </li>
    /// <li> <p> <code>version</code> is ignored if <code>dataSourceId</code> and <code>jobExecutionId</code> are not provided.</p> </li>
    /// <li> <p>If <code>dataSourceId</code> and <code>jobExecutionId</code> are provided, but <code>version</code> is not, the version defaults to "0".</p> </li>
    /// </ul>
    pub fn attributes(&self) -> std::option::Option<&[crate::model::DocumentAttribute]> {
        self.attributes.as_deref()
    }
}
/// See [`DocumentInfo`](crate::model::DocumentInfo).
pub mod document_info {

    /// A builder for [`DocumentInfo`](crate::model::DocumentInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_id: std::option::Option<std::string::String>,
        pub(crate) attributes: std::option::Option<std::vec::Vec<crate::model::DocumentAttribute>>,
    }
    impl Builder {
        /// <p>The identifier of the document.</p>
        pub fn document_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_id = Some(input.into());
            self
        }
        /// <p>The identifier of the document.</p>
        pub fn set_document_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.document_id = input;
            self
        }
        /// Appends an item to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>Attributes that identify a specific version of a document to check.</p>
        /// <p>The only valid attributes are:</p>
        /// <ul>
        /// <li> <p>version</p> </li>
        /// <li> <p>datasourceId</p> </li>
        /// <li> <p>jobExecutionId</p> </li>
        /// </ul>
        /// <p>The attributes follow these rules:</p>
        /// <ul>
        /// <li> <p> <code>dataSourceId</code> and <code>jobExecutionId</code> must be used together.</p> </li>
        /// <li> <p> <code>version</code> is ignored if <code>dataSourceId</code> and <code>jobExecutionId</code> are not provided.</p> </li>
        /// <li> <p>If <code>dataSourceId</code> and <code>jobExecutionId</code> are provided, but <code>version</code> is not, the version defaults to "0".</p> </li>
        /// </ul>
        pub fn attributes(mut self, input: crate::model::DocumentAttribute) -> Self {
            let mut v = self.attributes.unwrap_or_default();
            v.push(input);
            self.attributes = Some(v);
            self
        }
        /// <p>Attributes that identify a specific version of a document to check.</p>
        /// <p>The only valid attributes are:</p>
        /// <ul>
        /// <li> <p>version</p> </li>
        /// <li> <p>datasourceId</p> </li>
        /// <li> <p>jobExecutionId</p> </li>
        /// </ul>
        /// <p>The attributes follow these rules:</p>
        /// <ul>
        /// <li> <p> <code>dataSourceId</code> and <code>jobExecutionId</code> must be used together.</p> </li>
        /// <li> <p> <code>version</code> is ignored if <code>dataSourceId</code> and <code>jobExecutionId</code> are not provided.</p> </li>
        /// <li> <p>If <code>dataSourceId</code> and <code>jobExecutionId</code> are provided, but <code>version</code> is not, the version defaults to "0".</p> </li>
        /// </ul>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DocumentAttribute>>,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentInfo`](crate::model::DocumentInfo).
        pub fn build(self) -> crate::model::DocumentInfo {
            crate::model::DocumentInfo {
                document_id: self.document_id,
                attributes: self.attributes,
            }
        }
    }
}
impl DocumentInfo {
    /// Creates a new builder-style object to manufacture [`DocumentInfo`](crate::model::DocumentInfo).
    pub fn builder() -> crate::model::document_info::Builder {
        crate::model::document_info::Builder::default()
    }
}

/// <p>Provides information about documents that could not be removed from an index by the <code>BatchDeleteDocument</code> API.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchDeleteDocumentResponseFailedDocument {
    /// <p>The identifier of the document that couldn't be removed from the index.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The error code for why the document couldn't be removed from the index.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<crate::model::ErrorCode>,
    /// <p>An explanation for why the document couldn't be removed from the index.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl BatchDeleteDocumentResponseFailedDocument {
    /// <p>The identifier of the document that couldn't be removed from the index.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The error code for why the document couldn't be removed from the index.</p>
    pub fn error_code(&self) -> std::option::Option<&crate::model::ErrorCode> {
        self.error_code.as_ref()
    }
    /// <p>An explanation for why the document couldn't be removed from the index.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
/// See [`BatchDeleteDocumentResponseFailedDocument`](crate::model::BatchDeleteDocumentResponseFailedDocument).
pub mod batch_delete_document_response_failed_document {

    /// A builder for [`BatchDeleteDocumentResponseFailedDocument`](crate::model::BatchDeleteDocumentResponseFailedDocument).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the document that couldn't be removed from the index.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the document that couldn't be removed from the index.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The error code for why the document couldn't be removed from the index.</p>
        pub fn error_code(mut self, input: crate::model::ErrorCode) -> Self {
            self.error_code = Some(input);
            self
        }
        /// <p>The error code for why the document couldn't be removed from the index.</p>
        pub fn set_error_code(
            mut self,
            input: std::option::Option<crate::model::ErrorCode>,
        ) -> Self {
            self.error_code = input;
            self
        }
        /// <p>An explanation for why the document couldn't be removed from the index.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>An explanation for why the document couldn't be removed from the index.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchDeleteDocumentResponseFailedDocument`](crate::model::BatchDeleteDocumentResponseFailedDocument).
        pub fn build(self) -> crate::model::BatchDeleteDocumentResponseFailedDocument {
            crate::model::BatchDeleteDocumentResponseFailedDocument {
                id: self.id,
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}
impl BatchDeleteDocumentResponseFailedDocument {
    /// Creates a new builder-style object to manufacture [`BatchDeleteDocumentResponseFailedDocument`](crate::model::BatchDeleteDocumentResponseFailedDocument).
    pub fn builder() -> crate::model::batch_delete_document_response_failed_document::Builder {
        crate::model::batch_delete_document_response_failed_document::Builder::default()
    }
}

/// <p>Maps a particular data source sync job to a particular data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSourceSyncJobMetricTarget {
    /// <p>The ID of the data source that is running the sync job.</p>
    #[doc(hidden)]
    pub data_source_id: std::option::Option<std::string::String>,
    /// <p>The ID of the sync job that is running on the data source.</p>
    /// <p>If the ID of a sync job is not provided and there is a sync job running, then the ID of this sync job is used and metrics are generated for this sync job.</p>
    /// <p>If the ID of a sync job is not provided and there is no sync job running, then no metrics are generated and documents are indexed/deleted at the index level without sync job metrics included.</p>
    #[doc(hidden)]
    pub data_source_sync_job_id: std::option::Option<std::string::String>,
}
impl DataSourceSyncJobMetricTarget {
    /// <p>The ID of the data source that is running the sync job.</p>
    pub fn data_source_id(&self) -> std::option::Option<&str> {
        self.data_source_id.as_deref()
    }
    /// <p>The ID of the sync job that is running on the data source.</p>
    /// <p>If the ID of a sync job is not provided and there is a sync job running, then the ID of this sync job is used and metrics are generated for this sync job.</p>
    /// <p>If the ID of a sync job is not provided and there is no sync job running, then no metrics are generated and documents are indexed/deleted at the index level without sync job metrics included.</p>
    pub fn data_source_sync_job_id(&self) -> std::option::Option<&str> {
        self.data_source_sync_job_id.as_deref()
    }
}
/// See [`DataSourceSyncJobMetricTarget`](crate::model::DataSourceSyncJobMetricTarget).
pub mod data_source_sync_job_metric_target {

    /// A builder for [`DataSourceSyncJobMetricTarget`](crate::model::DataSourceSyncJobMetricTarget).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_source_id: std::option::Option<std::string::String>,
        pub(crate) data_source_sync_job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the data source that is running the sync job.</p>
        pub fn data_source_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_source_id = Some(input.into());
            self
        }
        /// <p>The ID of the data source that is running the sync job.</p>
        pub fn set_data_source_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_source_id = input;
            self
        }
        /// <p>The ID of the sync job that is running on the data source.</p>
        /// <p>If the ID of a sync job is not provided and there is a sync job running, then the ID of this sync job is used and metrics are generated for this sync job.</p>
        /// <p>If the ID of a sync job is not provided and there is no sync job running, then no metrics are generated and documents are indexed/deleted at the index level without sync job metrics included.</p>
        pub fn data_source_sync_job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_source_sync_job_id = Some(input.into());
            self
        }
        /// <p>The ID of the sync job that is running on the data source.</p>
        /// <p>If the ID of a sync job is not provided and there is a sync job running, then the ID of this sync job is used and metrics are generated for this sync job.</p>
        /// <p>If the ID of a sync job is not provided and there is no sync job running, then no metrics are generated and documents are indexed/deleted at the index level without sync job metrics included.</p>
        pub fn set_data_source_sync_job_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_source_sync_job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSourceSyncJobMetricTarget`](crate::model::DataSourceSyncJobMetricTarget).
        pub fn build(self) -> crate::model::DataSourceSyncJobMetricTarget {
            crate::model::DataSourceSyncJobMetricTarget {
                data_source_id: self.data_source_id,
                data_source_sync_job_id: self.data_source_sync_job_id,
            }
        }
    }
}
impl DataSourceSyncJobMetricTarget {
    /// Creates a new builder-style object to manufacture [`DataSourceSyncJobMetricTarget`](crate::model::DataSourceSyncJobMetricTarget).
    pub fn builder() -> crate::model::data_source_sync_job_metric_target::Builder {
        crate::model::data_source_sync_job_metric_target::Builder::default()
    }
}

/// <p>Provides the configuration information for users or groups in your IAM Identity Center identity source for access to your Amazon Kendra experience. Specific permissions are defined for each user or group once they are granted access to your Amazon Kendra experience.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EntityPersonaConfiguration {
    /// <p>The identifier of a user or group in your IAM Identity Center identity source. For example, a user ID could be an email.</p>
    #[doc(hidden)]
    pub entity_id: std::option::Option<std::string::String>,
    /// <p>The persona that defines the specific permissions of the user or group in your IAM Identity Center identity source. The available personas or access roles are <code>Owner</code> and <code>Viewer</code>. For more information on these personas, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/deploying-search-experience-no-code.html#access-search-experience">Providing access to your search page</a>.</p>
    #[doc(hidden)]
    pub persona: std::option::Option<crate::model::Persona>,
}
impl EntityPersonaConfiguration {
    /// <p>The identifier of a user or group in your IAM Identity Center identity source. For example, a user ID could be an email.</p>
    pub fn entity_id(&self) -> std::option::Option<&str> {
        self.entity_id.as_deref()
    }
    /// <p>The persona that defines the specific permissions of the user or group in your IAM Identity Center identity source. The available personas or access roles are <code>Owner</code> and <code>Viewer</code>. For more information on these personas, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/deploying-search-experience-no-code.html#access-search-experience">Providing access to your search page</a>.</p>
    pub fn persona(&self) -> std::option::Option<&crate::model::Persona> {
        self.persona.as_ref()
    }
}
/// See [`EntityPersonaConfiguration`](crate::model::EntityPersonaConfiguration).
pub mod entity_persona_configuration {

    /// A builder for [`EntityPersonaConfiguration`](crate::model::EntityPersonaConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entity_id: std::option::Option<std::string::String>,
        pub(crate) persona: std::option::Option<crate::model::Persona>,
    }
    impl Builder {
        /// <p>The identifier of a user or group in your IAM Identity Center identity source. For example, a user ID could be an email.</p>
        pub fn entity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entity_id = Some(input.into());
            self
        }
        /// <p>The identifier of a user or group in your IAM Identity Center identity source. For example, a user ID could be an email.</p>
        pub fn set_entity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entity_id = input;
            self
        }
        /// <p>The persona that defines the specific permissions of the user or group in your IAM Identity Center identity source. The available personas or access roles are <code>Owner</code> and <code>Viewer</code>. For more information on these personas, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/deploying-search-experience-no-code.html#access-search-experience">Providing access to your search page</a>.</p>
        pub fn persona(mut self, input: crate::model::Persona) -> Self {
            self.persona = Some(input);
            self
        }
        /// <p>The persona that defines the specific permissions of the user or group in your IAM Identity Center identity source. The available personas or access roles are <code>Owner</code> and <code>Viewer</code>. For more information on these personas, see <a href="https://docs.aws.amazon.com/kendra/latest/dg/deploying-search-experience-no-code.html#access-search-experience">Providing access to your search page</a>.</p>
        pub fn set_persona(mut self, input: std::option::Option<crate::model::Persona>) -> Self {
            self.persona = input;
            self
        }
        /// Consumes the builder and constructs a [`EntityPersonaConfiguration`](crate::model::EntityPersonaConfiguration).
        pub fn build(self) -> crate::model::EntityPersonaConfiguration {
            crate::model::EntityPersonaConfiguration {
                entity_id: self.entity_id,
                persona: self.persona,
            }
        }
    }
}
impl EntityPersonaConfiguration {
    /// Creates a new builder-style object to manufacture [`EntityPersonaConfiguration`](crate::model::EntityPersonaConfiguration).
    pub fn builder() -> crate::model::entity_persona_configuration::Builder {
        crate::model::entity_persona_configuration::Builder::default()
    }
}
