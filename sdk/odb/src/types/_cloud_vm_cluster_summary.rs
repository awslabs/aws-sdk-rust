// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Information about a VM cluster.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct CloudVmClusterSummary {
    /// <p>The unique identifier of the VM cluster.</p>
    pub cloud_vm_cluster_id: ::std::string::String,
    /// <p>The user-friendly name for the VM cluster.</p>
    pub display_name: ::std::option::Option<::std::string::String>,
    /// <p>The current status of the VM cluster.</p>
    pub status: ::std::option::Option<crate::types::ResourceStatus>,
    /// <p>Additional information about the status of the VM cluster.</p>
    pub status_reason: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the VM cluster.</p>
    pub cloud_vm_cluster_arn: ::std::option::Option<::std::string::String>,
    /// <p>The unique identifier of the Exadata infrastructure that this VM cluster belongs to.</p>
    pub cloud_exadata_infrastructure_id: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Exadata infrastructure that this VM cluster belongs to.</p>
    pub cloud_exadata_infrastructure_arn: ::std::option::Option<::std::string::String>,
    /// <p>The name of the Grid Infrastructure (GI) cluster.</p>
    pub cluster_name: ::std::option::Option<::std::string::String>,
    /// <p>The number of CPU cores enabled on the VM cluster.</p>
    pub cpu_core_count: ::std::option::Option<i32>,
    /// <p>Information about the data collection options enabled for a VM cluster.</p>
    pub data_collection_options: ::std::option::Option<crate::types::DataCollectionOptions>,
    /// <p>The size of the data disk group, in terabytes (TB), that's allocated for the VM cluster.</p>
    pub data_storage_size_in_tbs: ::std::option::Option<f64>,
    /// <p>The amount of local node storage, in gigabytes (GB), that's allocated for the VM cluster.</p>
    pub db_node_storage_size_in_gbs: ::std::option::Option<i32>,
    /// <p>The list of database servers for the VM cluster.</p>
    pub db_servers: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The type of redundancy configured for the VM cluster. <code>NORMAL</code> is 2-way redundancy. <code>HIGH</code> is 3-way redundancy.</p>
    pub disk_redundancy: ::std::option::Option<crate::types::DiskRedundancy>,
    /// <p>The software version of the Oracle Grid Infrastructure (GI) for the VM cluster.</p>
    pub gi_version: ::std::option::Option<::std::string::String>,
    /// <p>The host name for the VM cluster.</p>
    pub hostname: ::std::option::Option<::std::string::String>,
    /// <p>The IORM settings of the Exadata DB system.</p>
    pub iorm_config_cache: ::std::option::Option<crate::types::ExadataIormConfig>,
    /// <p>Indicates whether database backups to local Exadata storage is enabled for the VM cluster.</p>
    pub is_local_backup_enabled: ::std::option::Option<bool>,
    /// <p>Indicates whether the VM cluster is configured with a sparse disk group.</p>
    pub is_sparse_diskgroup_enabled: ::std::option::Option<bool>,
    /// <p>The Oracle Cloud ID (OCID) of the last maintenance update history entry.</p>
    pub last_update_history_entry_id: ::std::option::Option<::std::string::String>,
    /// <p>The Oracle license model applied to the VM cluster.</p>
    pub license_model: ::std::option::Option<crate::types::LicenseModel>,
    /// <p>The port number configured for the listener on the VM cluster.</p>
    pub listener_port: ::std::option::Option<i32>,
    /// <p>The amount of memory, in gigabytes (GB), that's allocated for the VM cluster.</p>
    pub memory_size_in_gbs: ::std::option::Option<i32>,
    /// <p>The number of nodes in the VM cluster.</p>
    pub node_count: ::std::option::Option<i32>,
    /// <p>The OCID of the VM cluster.</p>
    pub ocid: ::std::option::Option<::std::string::String>,
    /// <p>The name of the OCI resource anchor for the VM cluster.</p>
    pub oci_resource_anchor_name: ::std::option::Option<::std::string::String>,
    /// <p>The HTTPS link to the VM cluster in OCI.</p>
    pub oci_url: ::std::option::Option<::std::string::String>,
    /// <p>The domain of the VM cluster.</p>
    pub domain: ::std::option::Option<::std::string::String>,
    /// <p>The FQDN of the DNS record for the Single Client Access Name (SCAN) IP addresses that are associated with the VM cluster.</p>
    pub scan_dns_name: ::std::option::Option<::std::string::String>,
    /// <p>The OCID of the DNS record for the SCAN IP addresses that are associated with the VM cluster.</p>
    pub scan_dns_record_id: ::std::option::Option<::std::string::String>,
    /// <p>The OCID of the SCAN IP addresses that are associated with the VM cluster.</p>
    pub scan_ip_ids: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The hardware model name of the Exadata infrastructure that's running the VM cluster.</p>
    pub shape: ::std::option::Option<::std::string::String>,
    /// <p>The public key portion of one or more key pairs used for SSH access to the VM cluster.</p>
    pub ssh_public_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The amount of local node storage, in gigabytes (GB), that's allocated to the VM cluster.</p>
    pub storage_size_in_gbs: ::std::option::Option<i32>,
    /// <p>The operating system version of the image chosen for the VM cluster.</p>
    pub system_version: ::std::option::Option<::std::string::String>,
    /// <p>The date and time when the VM cluster was created.</p>
    pub created_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The time zone of the VM cluster.</p>
    pub time_zone: ::std::option::Option<::std::string::String>,
    /// <p>The virtual IP (VIP) addresses that are associated with the VM cluster. Oracle's Cluster Ready Services (CRS) creates and maintains one VIP address for each node in the VM cluster to enable failover. If one node fails, the VIP is reassigned to another active node in the cluster.</p>
    pub vip_ids: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The unique identifier of the ODB network for the VM cluster.</p>
    pub odb_network_id: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the ODB network associated with this VM cluster.</p>
    pub odb_network_arn: ::std::option::Option<::std::string::String>,
    /// <p>The amount of progress made on the current operation on the VM cluster, expressed as a percentage.</p>
    pub percent_progress: ::std::option::Option<f32>,
    /// <p>The OCI model compute model used when you create or clone an instance: ECPU or OCPU. An ECPU is an abstracted measure of compute resources. ECPUs are based on the number of cores elastically allocated from a pool of compute and storage servers. An OCPU is a legacy physical measure of compute resources. OCPUs are based on the physical core of a processor with hyper-threading enabled.</p>
    pub compute_model: ::std::option::Option<crate::types::ComputeModel>,
    /// <p>The Amazon Web Services Identity and Access Management (IAM) service roles associated with the VM cluster in the summary information.</p>
    pub iam_roles: ::std::option::Option<::std::vec::Vec<crate::types::IamRole>>,
}
impl CloudVmClusterSummary {
    /// <p>The unique identifier of the VM cluster.</p>
    pub fn cloud_vm_cluster_id(&self) -> &str {
        use std::ops::Deref;
        self.cloud_vm_cluster_id.deref()
    }
    /// <p>The user-friendly name for the VM cluster.</p>
    pub fn display_name(&self) -> ::std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>The current status of the VM cluster.</p>
    pub fn status(&self) -> ::std::option::Option<&crate::types::ResourceStatus> {
        self.status.as_ref()
    }
    /// <p>Additional information about the status of the VM cluster.</p>
    pub fn status_reason(&self) -> ::std::option::Option<&str> {
        self.status_reason.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the VM cluster.</p>
    pub fn cloud_vm_cluster_arn(&self) -> ::std::option::Option<&str> {
        self.cloud_vm_cluster_arn.as_deref()
    }
    /// <p>The unique identifier of the Exadata infrastructure that this VM cluster belongs to.</p>
    pub fn cloud_exadata_infrastructure_id(&self) -> ::std::option::Option<&str> {
        self.cloud_exadata_infrastructure_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Exadata infrastructure that this VM cluster belongs to.</p>
    pub fn cloud_exadata_infrastructure_arn(&self) -> ::std::option::Option<&str> {
        self.cloud_exadata_infrastructure_arn.as_deref()
    }
    /// <p>The name of the Grid Infrastructure (GI) cluster.</p>
    pub fn cluster_name(&self) -> ::std::option::Option<&str> {
        self.cluster_name.as_deref()
    }
    /// <p>The number of CPU cores enabled on the VM cluster.</p>
    pub fn cpu_core_count(&self) -> ::std::option::Option<i32> {
        self.cpu_core_count
    }
    /// <p>Information about the data collection options enabled for a VM cluster.</p>
    pub fn data_collection_options(&self) -> ::std::option::Option<&crate::types::DataCollectionOptions> {
        self.data_collection_options.as_ref()
    }
    /// <p>The size of the data disk group, in terabytes (TB), that's allocated for the VM cluster.</p>
    pub fn data_storage_size_in_tbs(&self) -> ::std::option::Option<f64> {
        self.data_storage_size_in_tbs
    }
    /// <p>The amount of local node storage, in gigabytes (GB), that's allocated for the VM cluster.</p>
    pub fn db_node_storage_size_in_gbs(&self) -> ::std::option::Option<i32> {
        self.db_node_storage_size_in_gbs
    }
    /// <p>The list of database servers for the VM cluster.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.db_servers.is_none()`.
    pub fn db_servers(&self) -> &[::std::string::String] {
        self.db_servers.as_deref().unwrap_or_default()
    }
    /// <p>The type of redundancy configured for the VM cluster. <code>NORMAL</code> is 2-way redundancy. <code>HIGH</code> is 3-way redundancy.</p>
    pub fn disk_redundancy(&self) -> ::std::option::Option<&crate::types::DiskRedundancy> {
        self.disk_redundancy.as_ref()
    }
    /// <p>The software version of the Oracle Grid Infrastructure (GI) for the VM cluster.</p>
    pub fn gi_version(&self) -> ::std::option::Option<&str> {
        self.gi_version.as_deref()
    }
    /// <p>The host name for the VM cluster.</p>
    pub fn hostname(&self) -> ::std::option::Option<&str> {
        self.hostname.as_deref()
    }
    /// <p>The IORM settings of the Exadata DB system.</p>
    pub fn iorm_config_cache(&self) -> ::std::option::Option<&crate::types::ExadataIormConfig> {
        self.iorm_config_cache.as_ref()
    }
    /// <p>Indicates whether database backups to local Exadata storage is enabled for the VM cluster.</p>
    pub fn is_local_backup_enabled(&self) -> ::std::option::Option<bool> {
        self.is_local_backup_enabled
    }
    /// <p>Indicates whether the VM cluster is configured with a sparse disk group.</p>
    pub fn is_sparse_diskgroup_enabled(&self) -> ::std::option::Option<bool> {
        self.is_sparse_diskgroup_enabled
    }
    /// <p>The Oracle Cloud ID (OCID) of the last maintenance update history entry.</p>
    pub fn last_update_history_entry_id(&self) -> ::std::option::Option<&str> {
        self.last_update_history_entry_id.as_deref()
    }
    /// <p>The Oracle license model applied to the VM cluster.</p>
    pub fn license_model(&self) -> ::std::option::Option<&crate::types::LicenseModel> {
        self.license_model.as_ref()
    }
    /// <p>The port number configured for the listener on the VM cluster.</p>
    pub fn listener_port(&self) -> ::std::option::Option<i32> {
        self.listener_port
    }
    /// <p>The amount of memory, in gigabytes (GB), that's allocated for the VM cluster.</p>
    pub fn memory_size_in_gbs(&self) -> ::std::option::Option<i32> {
        self.memory_size_in_gbs
    }
    /// <p>The number of nodes in the VM cluster.</p>
    pub fn node_count(&self) -> ::std::option::Option<i32> {
        self.node_count
    }
    /// <p>The OCID of the VM cluster.</p>
    pub fn ocid(&self) -> ::std::option::Option<&str> {
        self.ocid.as_deref()
    }
    /// <p>The name of the OCI resource anchor for the VM cluster.</p>
    pub fn oci_resource_anchor_name(&self) -> ::std::option::Option<&str> {
        self.oci_resource_anchor_name.as_deref()
    }
    /// <p>The HTTPS link to the VM cluster in OCI.</p>
    pub fn oci_url(&self) -> ::std::option::Option<&str> {
        self.oci_url.as_deref()
    }
    /// <p>The domain of the VM cluster.</p>
    pub fn domain(&self) -> ::std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p>The FQDN of the DNS record for the Single Client Access Name (SCAN) IP addresses that are associated with the VM cluster.</p>
    pub fn scan_dns_name(&self) -> ::std::option::Option<&str> {
        self.scan_dns_name.as_deref()
    }
    /// <p>The OCID of the DNS record for the SCAN IP addresses that are associated with the VM cluster.</p>
    pub fn scan_dns_record_id(&self) -> ::std::option::Option<&str> {
        self.scan_dns_record_id.as_deref()
    }
    /// <p>The OCID of the SCAN IP addresses that are associated with the VM cluster.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.scan_ip_ids.is_none()`.
    pub fn scan_ip_ids(&self) -> &[::std::string::String] {
        self.scan_ip_ids.as_deref().unwrap_or_default()
    }
    /// <p>The hardware model name of the Exadata infrastructure that's running the VM cluster.</p>
    pub fn shape(&self) -> ::std::option::Option<&str> {
        self.shape.as_deref()
    }
    /// <p>The public key portion of one or more key pairs used for SSH access to the VM cluster.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.ssh_public_keys.is_none()`.
    pub fn ssh_public_keys(&self) -> &[::std::string::String] {
        self.ssh_public_keys.as_deref().unwrap_or_default()
    }
    /// <p>The amount of local node storage, in gigabytes (GB), that's allocated to the VM cluster.</p>
    pub fn storage_size_in_gbs(&self) -> ::std::option::Option<i32> {
        self.storage_size_in_gbs
    }
    /// <p>The operating system version of the image chosen for the VM cluster.</p>
    pub fn system_version(&self) -> ::std::option::Option<&str> {
        self.system_version.as_deref()
    }
    /// <p>The date and time when the VM cluster was created.</p>
    pub fn created_at(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The time zone of the VM cluster.</p>
    pub fn time_zone(&self) -> ::std::option::Option<&str> {
        self.time_zone.as_deref()
    }
    /// <p>The virtual IP (VIP) addresses that are associated with the VM cluster. Oracle's Cluster Ready Services (CRS) creates and maintains one VIP address for each node in the VM cluster to enable failover. If one node fails, the VIP is reassigned to another active node in the cluster.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.vip_ids.is_none()`.
    pub fn vip_ids(&self) -> &[::std::string::String] {
        self.vip_ids.as_deref().unwrap_or_default()
    }
    /// <p>The unique identifier of the ODB network for the VM cluster.</p>
    pub fn odb_network_id(&self) -> ::std::option::Option<&str> {
        self.odb_network_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the ODB network associated with this VM cluster.</p>
    pub fn odb_network_arn(&self) -> ::std::option::Option<&str> {
        self.odb_network_arn.as_deref()
    }
    /// <p>The amount of progress made on the current operation on the VM cluster, expressed as a percentage.</p>
    pub fn percent_progress(&self) -> ::std::option::Option<f32> {
        self.percent_progress
    }
    /// <p>The OCI model compute model used when you create or clone an instance: ECPU or OCPU. An ECPU is an abstracted measure of compute resources. ECPUs are based on the number of cores elastically allocated from a pool of compute and storage servers. An OCPU is a legacy physical measure of compute resources. OCPUs are based on the physical core of a processor with hyper-threading enabled.</p>
    pub fn compute_model(&self) -> ::std::option::Option<&crate::types::ComputeModel> {
        self.compute_model.as_ref()
    }
    /// <p>The Amazon Web Services Identity and Access Management (IAM) service roles associated with the VM cluster in the summary information.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.iam_roles.is_none()`.
    pub fn iam_roles(&self) -> &[crate::types::IamRole] {
        self.iam_roles.as_deref().unwrap_or_default()
    }
}
impl CloudVmClusterSummary {
    /// Creates a new builder-style object to manufacture [`CloudVmClusterSummary`](crate::types::CloudVmClusterSummary).
    pub fn builder() -> crate::types::builders::CloudVmClusterSummaryBuilder {
        crate::types::builders::CloudVmClusterSummaryBuilder::default()
    }
}

/// A builder for [`CloudVmClusterSummary`](crate::types::CloudVmClusterSummary).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct CloudVmClusterSummaryBuilder {
    pub(crate) cloud_vm_cluster_id: ::std::option::Option<::std::string::String>,
    pub(crate) display_name: ::std::option::Option<::std::string::String>,
    pub(crate) status: ::std::option::Option<crate::types::ResourceStatus>,
    pub(crate) status_reason: ::std::option::Option<::std::string::String>,
    pub(crate) cloud_vm_cluster_arn: ::std::option::Option<::std::string::String>,
    pub(crate) cloud_exadata_infrastructure_id: ::std::option::Option<::std::string::String>,
    pub(crate) cloud_exadata_infrastructure_arn: ::std::option::Option<::std::string::String>,
    pub(crate) cluster_name: ::std::option::Option<::std::string::String>,
    pub(crate) cpu_core_count: ::std::option::Option<i32>,
    pub(crate) data_collection_options: ::std::option::Option<crate::types::DataCollectionOptions>,
    pub(crate) data_storage_size_in_tbs: ::std::option::Option<f64>,
    pub(crate) db_node_storage_size_in_gbs: ::std::option::Option<i32>,
    pub(crate) db_servers: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) disk_redundancy: ::std::option::Option<crate::types::DiskRedundancy>,
    pub(crate) gi_version: ::std::option::Option<::std::string::String>,
    pub(crate) hostname: ::std::option::Option<::std::string::String>,
    pub(crate) iorm_config_cache: ::std::option::Option<crate::types::ExadataIormConfig>,
    pub(crate) is_local_backup_enabled: ::std::option::Option<bool>,
    pub(crate) is_sparse_diskgroup_enabled: ::std::option::Option<bool>,
    pub(crate) last_update_history_entry_id: ::std::option::Option<::std::string::String>,
    pub(crate) license_model: ::std::option::Option<crate::types::LicenseModel>,
    pub(crate) listener_port: ::std::option::Option<i32>,
    pub(crate) memory_size_in_gbs: ::std::option::Option<i32>,
    pub(crate) node_count: ::std::option::Option<i32>,
    pub(crate) ocid: ::std::option::Option<::std::string::String>,
    pub(crate) oci_resource_anchor_name: ::std::option::Option<::std::string::String>,
    pub(crate) oci_url: ::std::option::Option<::std::string::String>,
    pub(crate) domain: ::std::option::Option<::std::string::String>,
    pub(crate) scan_dns_name: ::std::option::Option<::std::string::String>,
    pub(crate) scan_dns_record_id: ::std::option::Option<::std::string::String>,
    pub(crate) scan_ip_ids: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) shape: ::std::option::Option<::std::string::String>,
    pub(crate) ssh_public_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) storage_size_in_gbs: ::std::option::Option<i32>,
    pub(crate) system_version: ::std::option::Option<::std::string::String>,
    pub(crate) created_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) time_zone: ::std::option::Option<::std::string::String>,
    pub(crate) vip_ids: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) odb_network_id: ::std::option::Option<::std::string::String>,
    pub(crate) odb_network_arn: ::std::option::Option<::std::string::String>,
    pub(crate) percent_progress: ::std::option::Option<f32>,
    pub(crate) compute_model: ::std::option::Option<crate::types::ComputeModel>,
    pub(crate) iam_roles: ::std::option::Option<::std::vec::Vec<crate::types::IamRole>>,
}
impl CloudVmClusterSummaryBuilder {
    /// <p>The unique identifier of the VM cluster.</p>
    /// This field is required.
    pub fn cloud_vm_cluster_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cloud_vm_cluster_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier of the VM cluster.</p>
    pub fn set_cloud_vm_cluster_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cloud_vm_cluster_id = input;
        self
    }
    /// <p>The unique identifier of the VM cluster.</p>
    pub fn get_cloud_vm_cluster_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.cloud_vm_cluster_id
    }
    /// <p>The user-friendly name for the VM cluster.</p>
    pub fn display_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.display_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The user-friendly name for the VM cluster.</p>
    pub fn set_display_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.display_name = input;
        self
    }
    /// <p>The user-friendly name for the VM cluster.</p>
    pub fn get_display_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.display_name
    }
    /// <p>The current status of the VM cluster.</p>
    pub fn status(mut self, input: crate::types::ResourceStatus) -> Self {
        self.status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The current status of the VM cluster.</p>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::ResourceStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>The current status of the VM cluster.</p>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::ResourceStatus> {
        &self.status
    }
    /// <p>Additional information about the status of the VM cluster.</p>
    pub fn status_reason(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.status_reason = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Additional information about the status of the VM cluster.</p>
    pub fn set_status_reason(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.status_reason = input;
        self
    }
    /// <p>Additional information about the status of the VM cluster.</p>
    pub fn get_status_reason(&self) -> &::std::option::Option<::std::string::String> {
        &self.status_reason
    }
    /// <p>The Amazon Resource Name (ARN) of the VM cluster.</p>
    pub fn cloud_vm_cluster_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cloud_vm_cluster_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the VM cluster.</p>
    pub fn set_cloud_vm_cluster_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cloud_vm_cluster_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the VM cluster.</p>
    pub fn get_cloud_vm_cluster_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.cloud_vm_cluster_arn
    }
    /// <p>The unique identifier of the Exadata infrastructure that this VM cluster belongs to.</p>
    pub fn cloud_exadata_infrastructure_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cloud_exadata_infrastructure_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier of the Exadata infrastructure that this VM cluster belongs to.</p>
    pub fn set_cloud_exadata_infrastructure_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cloud_exadata_infrastructure_id = input;
        self
    }
    /// <p>The unique identifier of the Exadata infrastructure that this VM cluster belongs to.</p>
    pub fn get_cloud_exadata_infrastructure_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.cloud_exadata_infrastructure_id
    }
    /// <p>The Amazon Resource Name (ARN) of the Exadata infrastructure that this VM cluster belongs to.</p>
    pub fn cloud_exadata_infrastructure_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cloud_exadata_infrastructure_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Exadata infrastructure that this VM cluster belongs to.</p>
    pub fn set_cloud_exadata_infrastructure_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cloud_exadata_infrastructure_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Exadata infrastructure that this VM cluster belongs to.</p>
    pub fn get_cloud_exadata_infrastructure_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.cloud_exadata_infrastructure_arn
    }
    /// <p>The name of the Grid Infrastructure (GI) cluster.</p>
    pub fn cluster_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cluster_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the Grid Infrastructure (GI) cluster.</p>
    pub fn set_cluster_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cluster_name = input;
        self
    }
    /// <p>The name of the Grid Infrastructure (GI) cluster.</p>
    pub fn get_cluster_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.cluster_name
    }
    /// <p>The number of CPU cores enabled on the VM cluster.</p>
    pub fn cpu_core_count(mut self, input: i32) -> Self {
        self.cpu_core_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of CPU cores enabled on the VM cluster.</p>
    pub fn set_cpu_core_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.cpu_core_count = input;
        self
    }
    /// <p>The number of CPU cores enabled on the VM cluster.</p>
    pub fn get_cpu_core_count(&self) -> &::std::option::Option<i32> {
        &self.cpu_core_count
    }
    /// <p>Information about the data collection options enabled for a VM cluster.</p>
    pub fn data_collection_options(mut self, input: crate::types::DataCollectionOptions) -> Self {
        self.data_collection_options = ::std::option::Option::Some(input);
        self
    }
    /// <p>Information about the data collection options enabled for a VM cluster.</p>
    pub fn set_data_collection_options(mut self, input: ::std::option::Option<crate::types::DataCollectionOptions>) -> Self {
        self.data_collection_options = input;
        self
    }
    /// <p>Information about the data collection options enabled for a VM cluster.</p>
    pub fn get_data_collection_options(&self) -> &::std::option::Option<crate::types::DataCollectionOptions> {
        &self.data_collection_options
    }
    /// <p>The size of the data disk group, in terabytes (TB), that's allocated for the VM cluster.</p>
    pub fn data_storage_size_in_tbs(mut self, input: f64) -> Self {
        self.data_storage_size_in_tbs = ::std::option::Option::Some(input);
        self
    }
    /// <p>The size of the data disk group, in terabytes (TB), that's allocated for the VM cluster.</p>
    pub fn set_data_storage_size_in_tbs(mut self, input: ::std::option::Option<f64>) -> Self {
        self.data_storage_size_in_tbs = input;
        self
    }
    /// <p>The size of the data disk group, in terabytes (TB), that's allocated for the VM cluster.</p>
    pub fn get_data_storage_size_in_tbs(&self) -> &::std::option::Option<f64> {
        &self.data_storage_size_in_tbs
    }
    /// <p>The amount of local node storage, in gigabytes (GB), that's allocated for the VM cluster.</p>
    pub fn db_node_storage_size_in_gbs(mut self, input: i32) -> Self {
        self.db_node_storage_size_in_gbs = ::std::option::Option::Some(input);
        self
    }
    /// <p>The amount of local node storage, in gigabytes (GB), that's allocated for the VM cluster.</p>
    pub fn set_db_node_storage_size_in_gbs(mut self, input: ::std::option::Option<i32>) -> Self {
        self.db_node_storage_size_in_gbs = input;
        self
    }
    /// <p>The amount of local node storage, in gigabytes (GB), that's allocated for the VM cluster.</p>
    pub fn get_db_node_storage_size_in_gbs(&self) -> &::std::option::Option<i32> {
        &self.db_node_storage_size_in_gbs
    }
    /// Appends an item to `db_servers`.
    ///
    /// To override the contents of this collection use [`set_db_servers`](Self::set_db_servers).
    ///
    /// <p>The list of database servers for the VM cluster.</p>
    pub fn db_servers(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.db_servers.unwrap_or_default();
        v.push(input.into());
        self.db_servers = ::std::option::Option::Some(v);
        self
    }
    /// <p>The list of database servers for the VM cluster.</p>
    pub fn set_db_servers(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.db_servers = input;
        self
    }
    /// <p>The list of database servers for the VM cluster.</p>
    pub fn get_db_servers(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.db_servers
    }
    /// <p>The type of redundancy configured for the VM cluster. <code>NORMAL</code> is 2-way redundancy. <code>HIGH</code> is 3-way redundancy.</p>
    pub fn disk_redundancy(mut self, input: crate::types::DiskRedundancy) -> Self {
        self.disk_redundancy = ::std::option::Option::Some(input);
        self
    }
    /// <p>The type of redundancy configured for the VM cluster. <code>NORMAL</code> is 2-way redundancy. <code>HIGH</code> is 3-way redundancy.</p>
    pub fn set_disk_redundancy(mut self, input: ::std::option::Option<crate::types::DiskRedundancy>) -> Self {
        self.disk_redundancy = input;
        self
    }
    /// <p>The type of redundancy configured for the VM cluster. <code>NORMAL</code> is 2-way redundancy. <code>HIGH</code> is 3-way redundancy.</p>
    pub fn get_disk_redundancy(&self) -> &::std::option::Option<crate::types::DiskRedundancy> {
        &self.disk_redundancy
    }
    /// <p>The software version of the Oracle Grid Infrastructure (GI) for the VM cluster.</p>
    pub fn gi_version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.gi_version = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The software version of the Oracle Grid Infrastructure (GI) for the VM cluster.</p>
    pub fn set_gi_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.gi_version = input;
        self
    }
    /// <p>The software version of the Oracle Grid Infrastructure (GI) for the VM cluster.</p>
    pub fn get_gi_version(&self) -> &::std::option::Option<::std::string::String> {
        &self.gi_version
    }
    /// <p>The host name for the VM cluster.</p>
    pub fn hostname(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.hostname = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The host name for the VM cluster.</p>
    pub fn set_hostname(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.hostname = input;
        self
    }
    /// <p>The host name for the VM cluster.</p>
    pub fn get_hostname(&self) -> &::std::option::Option<::std::string::String> {
        &self.hostname
    }
    /// <p>The IORM settings of the Exadata DB system.</p>
    pub fn iorm_config_cache(mut self, input: crate::types::ExadataIormConfig) -> Self {
        self.iorm_config_cache = ::std::option::Option::Some(input);
        self
    }
    /// <p>The IORM settings of the Exadata DB system.</p>
    pub fn set_iorm_config_cache(mut self, input: ::std::option::Option<crate::types::ExadataIormConfig>) -> Self {
        self.iorm_config_cache = input;
        self
    }
    /// <p>The IORM settings of the Exadata DB system.</p>
    pub fn get_iorm_config_cache(&self) -> &::std::option::Option<crate::types::ExadataIormConfig> {
        &self.iorm_config_cache
    }
    /// <p>Indicates whether database backups to local Exadata storage is enabled for the VM cluster.</p>
    pub fn is_local_backup_enabled(mut self, input: bool) -> Self {
        self.is_local_backup_enabled = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether database backups to local Exadata storage is enabled for the VM cluster.</p>
    pub fn set_is_local_backup_enabled(mut self, input: ::std::option::Option<bool>) -> Self {
        self.is_local_backup_enabled = input;
        self
    }
    /// <p>Indicates whether database backups to local Exadata storage is enabled for the VM cluster.</p>
    pub fn get_is_local_backup_enabled(&self) -> &::std::option::Option<bool> {
        &self.is_local_backup_enabled
    }
    /// <p>Indicates whether the VM cluster is configured with a sparse disk group.</p>
    pub fn is_sparse_diskgroup_enabled(mut self, input: bool) -> Self {
        self.is_sparse_diskgroup_enabled = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether the VM cluster is configured with a sparse disk group.</p>
    pub fn set_is_sparse_diskgroup_enabled(mut self, input: ::std::option::Option<bool>) -> Self {
        self.is_sparse_diskgroup_enabled = input;
        self
    }
    /// <p>Indicates whether the VM cluster is configured with a sparse disk group.</p>
    pub fn get_is_sparse_diskgroup_enabled(&self) -> &::std::option::Option<bool> {
        &self.is_sparse_diskgroup_enabled
    }
    /// <p>The Oracle Cloud ID (OCID) of the last maintenance update history entry.</p>
    pub fn last_update_history_entry_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.last_update_history_entry_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Oracle Cloud ID (OCID) of the last maintenance update history entry.</p>
    pub fn set_last_update_history_entry_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.last_update_history_entry_id = input;
        self
    }
    /// <p>The Oracle Cloud ID (OCID) of the last maintenance update history entry.</p>
    pub fn get_last_update_history_entry_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.last_update_history_entry_id
    }
    /// <p>The Oracle license model applied to the VM cluster.</p>
    pub fn license_model(mut self, input: crate::types::LicenseModel) -> Self {
        self.license_model = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Oracle license model applied to the VM cluster.</p>
    pub fn set_license_model(mut self, input: ::std::option::Option<crate::types::LicenseModel>) -> Self {
        self.license_model = input;
        self
    }
    /// <p>The Oracle license model applied to the VM cluster.</p>
    pub fn get_license_model(&self) -> &::std::option::Option<crate::types::LicenseModel> {
        &self.license_model
    }
    /// <p>The port number configured for the listener on the VM cluster.</p>
    pub fn listener_port(mut self, input: i32) -> Self {
        self.listener_port = ::std::option::Option::Some(input);
        self
    }
    /// <p>The port number configured for the listener on the VM cluster.</p>
    pub fn set_listener_port(mut self, input: ::std::option::Option<i32>) -> Self {
        self.listener_port = input;
        self
    }
    /// <p>The port number configured for the listener on the VM cluster.</p>
    pub fn get_listener_port(&self) -> &::std::option::Option<i32> {
        &self.listener_port
    }
    /// <p>The amount of memory, in gigabytes (GB), that's allocated for the VM cluster.</p>
    pub fn memory_size_in_gbs(mut self, input: i32) -> Self {
        self.memory_size_in_gbs = ::std::option::Option::Some(input);
        self
    }
    /// <p>The amount of memory, in gigabytes (GB), that's allocated for the VM cluster.</p>
    pub fn set_memory_size_in_gbs(mut self, input: ::std::option::Option<i32>) -> Self {
        self.memory_size_in_gbs = input;
        self
    }
    /// <p>The amount of memory, in gigabytes (GB), that's allocated for the VM cluster.</p>
    pub fn get_memory_size_in_gbs(&self) -> &::std::option::Option<i32> {
        &self.memory_size_in_gbs
    }
    /// <p>The number of nodes in the VM cluster.</p>
    pub fn node_count(mut self, input: i32) -> Self {
        self.node_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of nodes in the VM cluster.</p>
    pub fn set_node_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.node_count = input;
        self
    }
    /// <p>The number of nodes in the VM cluster.</p>
    pub fn get_node_count(&self) -> &::std::option::Option<i32> {
        &self.node_count
    }
    /// <p>The OCID of the VM cluster.</p>
    pub fn ocid(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.ocid = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The OCID of the VM cluster.</p>
    pub fn set_ocid(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.ocid = input;
        self
    }
    /// <p>The OCID of the VM cluster.</p>
    pub fn get_ocid(&self) -> &::std::option::Option<::std::string::String> {
        &self.ocid
    }
    /// <p>The name of the OCI resource anchor for the VM cluster.</p>
    pub fn oci_resource_anchor_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.oci_resource_anchor_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the OCI resource anchor for the VM cluster.</p>
    pub fn set_oci_resource_anchor_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.oci_resource_anchor_name = input;
        self
    }
    /// <p>The name of the OCI resource anchor for the VM cluster.</p>
    pub fn get_oci_resource_anchor_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.oci_resource_anchor_name
    }
    /// <p>The HTTPS link to the VM cluster in OCI.</p>
    pub fn oci_url(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.oci_url = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The HTTPS link to the VM cluster in OCI.</p>
    pub fn set_oci_url(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.oci_url = input;
        self
    }
    /// <p>The HTTPS link to the VM cluster in OCI.</p>
    pub fn get_oci_url(&self) -> &::std::option::Option<::std::string::String> {
        &self.oci_url
    }
    /// <p>The domain of the VM cluster.</p>
    pub fn domain(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.domain = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The domain of the VM cluster.</p>
    pub fn set_domain(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.domain = input;
        self
    }
    /// <p>The domain of the VM cluster.</p>
    pub fn get_domain(&self) -> &::std::option::Option<::std::string::String> {
        &self.domain
    }
    /// <p>The FQDN of the DNS record for the Single Client Access Name (SCAN) IP addresses that are associated with the VM cluster.</p>
    pub fn scan_dns_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.scan_dns_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The FQDN of the DNS record for the Single Client Access Name (SCAN) IP addresses that are associated with the VM cluster.</p>
    pub fn set_scan_dns_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.scan_dns_name = input;
        self
    }
    /// <p>The FQDN of the DNS record for the Single Client Access Name (SCAN) IP addresses that are associated with the VM cluster.</p>
    pub fn get_scan_dns_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.scan_dns_name
    }
    /// <p>The OCID of the DNS record for the SCAN IP addresses that are associated with the VM cluster.</p>
    pub fn scan_dns_record_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.scan_dns_record_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The OCID of the DNS record for the SCAN IP addresses that are associated with the VM cluster.</p>
    pub fn set_scan_dns_record_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.scan_dns_record_id = input;
        self
    }
    /// <p>The OCID of the DNS record for the SCAN IP addresses that are associated with the VM cluster.</p>
    pub fn get_scan_dns_record_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.scan_dns_record_id
    }
    /// Appends an item to `scan_ip_ids`.
    ///
    /// To override the contents of this collection use [`set_scan_ip_ids`](Self::set_scan_ip_ids).
    ///
    /// <p>The OCID of the SCAN IP addresses that are associated with the VM cluster.</p>
    pub fn scan_ip_ids(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.scan_ip_ids.unwrap_or_default();
        v.push(input.into());
        self.scan_ip_ids = ::std::option::Option::Some(v);
        self
    }
    /// <p>The OCID of the SCAN IP addresses that are associated with the VM cluster.</p>
    pub fn set_scan_ip_ids(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.scan_ip_ids = input;
        self
    }
    /// <p>The OCID of the SCAN IP addresses that are associated with the VM cluster.</p>
    pub fn get_scan_ip_ids(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.scan_ip_ids
    }
    /// <p>The hardware model name of the Exadata infrastructure that's running the VM cluster.</p>
    pub fn shape(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.shape = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The hardware model name of the Exadata infrastructure that's running the VM cluster.</p>
    pub fn set_shape(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.shape = input;
        self
    }
    /// <p>The hardware model name of the Exadata infrastructure that's running the VM cluster.</p>
    pub fn get_shape(&self) -> &::std::option::Option<::std::string::String> {
        &self.shape
    }
    /// Appends an item to `ssh_public_keys`.
    ///
    /// To override the contents of this collection use [`set_ssh_public_keys`](Self::set_ssh_public_keys).
    ///
    /// <p>The public key portion of one or more key pairs used for SSH access to the VM cluster.</p>
    pub fn ssh_public_keys(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.ssh_public_keys.unwrap_or_default();
        v.push(input.into());
        self.ssh_public_keys = ::std::option::Option::Some(v);
        self
    }
    /// <p>The public key portion of one or more key pairs used for SSH access to the VM cluster.</p>
    pub fn set_ssh_public_keys(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.ssh_public_keys = input;
        self
    }
    /// <p>The public key portion of one or more key pairs used for SSH access to the VM cluster.</p>
    pub fn get_ssh_public_keys(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.ssh_public_keys
    }
    /// <p>The amount of local node storage, in gigabytes (GB), that's allocated to the VM cluster.</p>
    pub fn storage_size_in_gbs(mut self, input: i32) -> Self {
        self.storage_size_in_gbs = ::std::option::Option::Some(input);
        self
    }
    /// <p>The amount of local node storage, in gigabytes (GB), that's allocated to the VM cluster.</p>
    pub fn set_storage_size_in_gbs(mut self, input: ::std::option::Option<i32>) -> Self {
        self.storage_size_in_gbs = input;
        self
    }
    /// <p>The amount of local node storage, in gigabytes (GB), that's allocated to the VM cluster.</p>
    pub fn get_storage_size_in_gbs(&self) -> &::std::option::Option<i32> {
        &self.storage_size_in_gbs
    }
    /// <p>The operating system version of the image chosen for the VM cluster.</p>
    pub fn system_version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.system_version = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The operating system version of the image chosen for the VM cluster.</p>
    pub fn set_system_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.system_version = input;
        self
    }
    /// <p>The operating system version of the image chosen for the VM cluster.</p>
    pub fn get_system_version(&self) -> &::std::option::Option<::std::string::String> {
        &self.system_version
    }
    /// <p>The date and time when the VM cluster was created.</p>
    pub fn created_at(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.created_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date and time when the VM cluster was created.</p>
    pub fn set_created_at(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.created_at = input;
        self
    }
    /// <p>The date and time when the VM cluster was created.</p>
    pub fn get_created_at(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.created_at
    }
    /// <p>The time zone of the VM cluster.</p>
    pub fn time_zone(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.time_zone = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The time zone of the VM cluster.</p>
    pub fn set_time_zone(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.time_zone = input;
        self
    }
    /// <p>The time zone of the VM cluster.</p>
    pub fn get_time_zone(&self) -> &::std::option::Option<::std::string::String> {
        &self.time_zone
    }
    /// Appends an item to `vip_ids`.
    ///
    /// To override the contents of this collection use [`set_vip_ids`](Self::set_vip_ids).
    ///
    /// <p>The virtual IP (VIP) addresses that are associated with the VM cluster. Oracle's Cluster Ready Services (CRS) creates and maintains one VIP address for each node in the VM cluster to enable failover. If one node fails, the VIP is reassigned to another active node in the cluster.</p>
    pub fn vip_ids(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.vip_ids.unwrap_or_default();
        v.push(input.into());
        self.vip_ids = ::std::option::Option::Some(v);
        self
    }
    /// <p>The virtual IP (VIP) addresses that are associated with the VM cluster. Oracle's Cluster Ready Services (CRS) creates and maintains one VIP address for each node in the VM cluster to enable failover. If one node fails, the VIP is reassigned to another active node in the cluster.</p>
    pub fn set_vip_ids(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.vip_ids = input;
        self
    }
    /// <p>The virtual IP (VIP) addresses that are associated with the VM cluster. Oracle's Cluster Ready Services (CRS) creates and maintains one VIP address for each node in the VM cluster to enable failover. If one node fails, the VIP is reassigned to another active node in the cluster.</p>
    pub fn get_vip_ids(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.vip_ids
    }
    /// <p>The unique identifier of the ODB network for the VM cluster.</p>
    pub fn odb_network_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.odb_network_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier of the ODB network for the VM cluster.</p>
    pub fn set_odb_network_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.odb_network_id = input;
        self
    }
    /// <p>The unique identifier of the ODB network for the VM cluster.</p>
    pub fn get_odb_network_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.odb_network_id
    }
    /// <p>The Amazon Resource Name (ARN) of the ODB network associated with this VM cluster.</p>
    pub fn odb_network_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.odb_network_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the ODB network associated with this VM cluster.</p>
    pub fn set_odb_network_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.odb_network_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the ODB network associated with this VM cluster.</p>
    pub fn get_odb_network_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.odb_network_arn
    }
    /// <p>The amount of progress made on the current operation on the VM cluster, expressed as a percentage.</p>
    pub fn percent_progress(mut self, input: f32) -> Self {
        self.percent_progress = ::std::option::Option::Some(input);
        self
    }
    /// <p>The amount of progress made on the current operation on the VM cluster, expressed as a percentage.</p>
    pub fn set_percent_progress(mut self, input: ::std::option::Option<f32>) -> Self {
        self.percent_progress = input;
        self
    }
    /// <p>The amount of progress made on the current operation on the VM cluster, expressed as a percentage.</p>
    pub fn get_percent_progress(&self) -> &::std::option::Option<f32> {
        &self.percent_progress
    }
    /// <p>The OCI model compute model used when you create or clone an instance: ECPU or OCPU. An ECPU is an abstracted measure of compute resources. ECPUs are based on the number of cores elastically allocated from a pool of compute and storage servers. An OCPU is a legacy physical measure of compute resources. OCPUs are based on the physical core of a processor with hyper-threading enabled.</p>
    pub fn compute_model(mut self, input: crate::types::ComputeModel) -> Self {
        self.compute_model = ::std::option::Option::Some(input);
        self
    }
    /// <p>The OCI model compute model used when you create or clone an instance: ECPU or OCPU. An ECPU is an abstracted measure of compute resources. ECPUs are based on the number of cores elastically allocated from a pool of compute and storage servers. An OCPU is a legacy physical measure of compute resources. OCPUs are based on the physical core of a processor with hyper-threading enabled.</p>
    pub fn set_compute_model(mut self, input: ::std::option::Option<crate::types::ComputeModel>) -> Self {
        self.compute_model = input;
        self
    }
    /// <p>The OCI model compute model used when you create or clone an instance: ECPU or OCPU. An ECPU is an abstracted measure of compute resources. ECPUs are based on the number of cores elastically allocated from a pool of compute and storage servers. An OCPU is a legacy physical measure of compute resources. OCPUs are based on the physical core of a processor with hyper-threading enabled.</p>
    pub fn get_compute_model(&self) -> &::std::option::Option<crate::types::ComputeModel> {
        &self.compute_model
    }
    /// Appends an item to `iam_roles`.
    ///
    /// To override the contents of this collection use [`set_iam_roles`](Self::set_iam_roles).
    ///
    /// <p>The Amazon Web Services Identity and Access Management (IAM) service roles associated with the VM cluster in the summary information.</p>
    pub fn iam_roles(mut self, input: crate::types::IamRole) -> Self {
        let mut v = self.iam_roles.unwrap_or_default();
        v.push(input);
        self.iam_roles = ::std::option::Option::Some(v);
        self
    }
    /// <p>The Amazon Web Services Identity and Access Management (IAM) service roles associated with the VM cluster in the summary information.</p>
    pub fn set_iam_roles(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::IamRole>>) -> Self {
        self.iam_roles = input;
        self
    }
    /// <p>The Amazon Web Services Identity and Access Management (IAM) service roles associated with the VM cluster in the summary information.</p>
    pub fn get_iam_roles(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::IamRole>> {
        &self.iam_roles
    }
    /// Consumes the builder and constructs a [`CloudVmClusterSummary`](crate::types::CloudVmClusterSummary).
    /// This method will fail if any of the following fields are not set:
    /// - [`cloud_vm_cluster_id`](crate::types::builders::CloudVmClusterSummaryBuilder::cloud_vm_cluster_id)
    pub fn build(self) -> ::std::result::Result<crate::types::CloudVmClusterSummary, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::CloudVmClusterSummary {
            cloud_vm_cluster_id: self.cloud_vm_cluster_id.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "cloud_vm_cluster_id",
                    "cloud_vm_cluster_id was not specified but it is required when building CloudVmClusterSummary",
                )
            })?,
            display_name: self.display_name,
            status: self.status,
            status_reason: self.status_reason,
            cloud_vm_cluster_arn: self.cloud_vm_cluster_arn,
            cloud_exadata_infrastructure_id: self.cloud_exadata_infrastructure_id,
            cloud_exadata_infrastructure_arn: self.cloud_exadata_infrastructure_arn,
            cluster_name: self.cluster_name,
            cpu_core_count: self.cpu_core_count,
            data_collection_options: self.data_collection_options,
            data_storage_size_in_tbs: self.data_storage_size_in_tbs,
            db_node_storage_size_in_gbs: self.db_node_storage_size_in_gbs,
            db_servers: self.db_servers,
            disk_redundancy: self.disk_redundancy,
            gi_version: self.gi_version,
            hostname: self.hostname,
            iorm_config_cache: self.iorm_config_cache,
            is_local_backup_enabled: self.is_local_backup_enabled,
            is_sparse_diskgroup_enabled: self.is_sparse_diskgroup_enabled,
            last_update_history_entry_id: self.last_update_history_entry_id,
            license_model: self.license_model,
            listener_port: self.listener_port,
            memory_size_in_gbs: self.memory_size_in_gbs,
            node_count: self.node_count,
            ocid: self.ocid,
            oci_resource_anchor_name: self.oci_resource_anchor_name,
            oci_url: self.oci_url,
            domain: self.domain,
            scan_dns_name: self.scan_dns_name,
            scan_dns_record_id: self.scan_dns_record_id,
            scan_ip_ids: self.scan_ip_ids,
            shape: self.shape,
            ssh_public_keys: self.ssh_public_keys,
            storage_size_in_gbs: self.storage_size_in_gbs,
            system_version: self.system_version,
            created_at: self.created_at,
            time_zone: self.time_zone,
            vip_ids: self.vip_ids,
            odb_network_id: self.odb_network_id,
            odb_network_arn: self.odb_network_arn,
            percent_progress: self.percent_progress,
            compute_model: self.compute_model,
            iam_roles: self.iam_roles,
        })
    }
}
