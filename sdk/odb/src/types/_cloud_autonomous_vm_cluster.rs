// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Information about an Autonomous VM cluster resource.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct CloudAutonomousVmCluster {
    /// <p>The unique identifier of the Autonomous VM cluster.</p>
    pub cloud_autonomous_vm_cluster_id: ::std::string::String,
    /// <p>The Amazon Resource Name (ARN) for the Autonomous VM cluster.</p>
    pub cloud_autonomous_vm_cluster_arn: ::std::option::Option<::std::string::String>,
    /// <p>The unique identifier of the ODB network associated with this Autonomous VM cluster.</p>
    pub odb_network_id: ::std::option::Option<::std::string::String>,
    /// <p>The name of the OCI resource anchor associated with this Autonomous VM cluster.</p>
    pub oci_resource_anchor_name: ::std::option::Option<::std::string::String>,
    /// <p>The progress of the current operation on the Autonomous VM cluster, as a percentage.</p>
    pub percent_progress: ::std::option::Option<f32>,
    /// <p>The display name of the Autonomous VM cluster.</p>
    pub display_name: ::std::option::Option<::std::string::String>,
    /// <p>The current state of the Autonomous VM cluster. Possible values include <code>CREATING</code>, <code>AVAILABLE</code>, <code>UPDATING</code>, <code>DELETING</code>, <code>DELETED</code>, <code>FAILED</code>.</p>
    pub status: ::std::option::Option<crate::types::ResourceStatus>,
    /// <p>Additional information about the current status of the Autonomous VM cluster.</p>
    pub status_reason: ::std::option::Option<::std::string::String>,
    /// <p>The unique identifier of the Cloud Exadata Infrastructure containing this Autonomous VM cluster.</p>
    pub cloud_exadata_infrastructure_id: ::std::option::Option<::std::string::String>,
    /// <p>The percentage of data storage currently in use for Autonomous Databases in the Autonomous VM cluster.</p>
    pub autonomous_data_storage_percentage: ::std::option::Option<f32>,
    /// <p>The data storage size allocated for Autonomous Databases in the Autonomous VM cluster, in TB.</p>
    pub autonomous_data_storage_size_in_tbs: ::std::option::Option<f64>,
    /// <p>The available data storage space for Autonomous Databases in the Autonomous VM cluster, in TB.</p>
    pub available_autonomous_data_storage_size_in_tbs: ::std::option::Option<f64>,
    /// <p>The number of Autonomous CDBs that you can create with the currently available storage.</p>
    pub available_container_databases: ::std::option::Option<i32>,
    /// <p>The number of CPU cores available for allocation to Autonomous Databases.</p>
    pub available_cpus: ::std::option::Option<f32>,
    /// <p>The compute model of the Autonomous VM cluster: ECPU or OCPU.</p>
    pub compute_model: ::std::option::Option<crate::types::ComputeModel>,
    /// <p>The total number of CPU cores in the Autonomous VM cluster.</p>
    pub cpu_core_count: ::std::option::Option<i32>,
    /// <p>The number of CPU cores enabled per node in the Autonomous VM cluster.</p>
    pub cpu_core_count_per_node: ::std::option::Option<i32>,
    /// <p>The percentage of total CPU cores currently in use in the Autonomous VM cluster.</p>
    pub cpu_percentage: ::std::option::Option<f32>,
    /// <p>The total data storage allocated to the Autonomous VM cluster, in GB.</p>
    pub data_storage_size_in_gbs: ::std::option::Option<f64>,
    /// <p>The total data storage allocated to the Autonomous VM cluster, in TB.</p>
    pub data_storage_size_in_tbs: ::std::option::Option<f64>,
    /// <p>The local node storage allocated to the Autonomous VM cluster, in gigabytes (GB).</p>
    pub db_node_storage_size_in_gbs: ::std::option::Option<i32>,
    /// <p>The list of database servers associated with the Autonomous VM cluster.</p>
    pub db_servers: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The user-provided description of the Autonomous VM cluster.</p>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>The domain name for the Autonomous VM cluster.</p>
    pub domain: ::std::option::Option<::std::string::String>,
    /// <p>The minimum value to which you can scale down the Exadata storage, in TB.</p>
    pub exadata_storage_in_tbs_lowest_scaled_value: ::std::option::Option<f64>,
    /// <p>The hostname for the Autonomous VM cluster.</p>
    pub hostname: ::std::option::Option<::std::string::String>,
    /// <p>The Oracle Cloud Identifier (OCID) of the Autonomous VM cluster.</p>
    pub ocid: ::std::option::Option<::std::string::String>,
    /// <p>The URL for accessing the OCI console page for this Autonomous VM cluster.</p>
    pub oci_url: ::std::option::Option<::std::string::String>,
    /// <p>Indicates whether mutual TLS (mTLS) authentication is enabled for the Autonomous VM cluster.</p>
    pub is_mtls_enabled_vm_cluster: ::std::option::Option<bool>,
    /// <p>The Oracle license model that applies to the Autonomous VM cluster.</p>
    pub license_model: ::std::option::Option<crate::types::LicenseModel>,
    /// <p>The scheduling details for the maintenance window. Patching and system updates take place during the maintenance window.</p>
    pub maintenance_window: ::std::option::Option<crate::types::MaintenanceWindow>,
    /// <p>The minimum value to which you can scale down the maximum number of Autonomous CDBs.</p>
    pub max_acds_lowest_scaled_value: ::std::option::Option<i32>,
    /// <p>The amount of memory allocated per Oracle Compute Unit, in GB.</p>
    pub memory_per_oracle_compute_unit_in_gbs: ::std::option::Option<i32>,
    /// <p>The total amount of memory allocated to the Autonomous VM cluster, in gigabytes (GB).</p>
    pub memory_size_in_gbs: ::std::option::Option<i32>,
    /// <p>The number of database server nodes in the Autonomous VM cluster.</p>
    pub node_count: ::std::option::Option<i32>,
    /// <p>The number of Autonomous CDBs that can't be provisioned because of resource constraints.</p>
    pub non_provisionable_autonomous_container_databases: ::std::option::Option<i32>,
    /// <p>The number of Autonomous CDBs that can be provisioned in the Autonomous VM cluster.</p>
    pub provisionable_autonomous_container_databases: ::std::option::Option<i32>,
    /// <p>The number of Autonomous CDBs currently provisioned in the Autonomous VM cluster.</p>
    pub provisioned_autonomous_container_databases: ::std::option::Option<i32>,
    /// <p>The number of CPU cores currently provisioned in the Autonomous VM cluster.</p>
    pub provisioned_cpus: ::std::option::Option<f32>,
    /// <p>The number of CPU cores that can be reclaimed from terminated or scaled-down Autonomous Databases.</p>
    pub reclaimable_cpus: ::std::option::Option<f32>,
    /// <p>The number of CPU cores reserved for system operations and redundancy.</p>
    pub reserved_cpus: ::std::option::Option<f32>,
    /// <p>The SCAN listener port for non-TLS (TCP) protocol. The default is 1521.</p>
    pub scan_listener_port_non_tls: ::std::option::Option<i32>,
    /// <p>The SCAN listener port for TLS (TCP) protocol. The default is 2484.</p>
    pub scan_listener_port_tls: ::std::option::Option<i32>,
    /// <p>The shape of the Exadata infrastructure for the Autonomous VM cluster.</p>
    pub shape: ::std::option::Option<::std::string::String>,
    /// <p>The date and time when the Autonomous VM cluster was created.</p>
    pub created_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The expiration date and time of the database SSL certificate.</p>
    pub time_database_ssl_certificate_expires: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The expiration date and time of the Oracle REST Data Services (ORDS) certificate.</p>
    pub time_ords_certificate_expires: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The time zone of the Autonomous VM cluster.</p>
    pub time_zone: ::std::option::Option<::std::string::String>,
    /// <p>The total number of Autonomous Container Databases that can be created with the allocated local storage.</p>
    pub total_container_databases: ::std::option::Option<i32>,
}
impl CloudAutonomousVmCluster {
    /// <p>The unique identifier of the Autonomous VM cluster.</p>
    pub fn cloud_autonomous_vm_cluster_id(&self) -> &str {
        use std::ops::Deref;
        self.cloud_autonomous_vm_cluster_id.deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the Autonomous VM cluster.</p>
    pub fn cloud_autonomous_vm_cluster_arn(&self) -> ::std::option::Option<&str> {
        self.cloud_autonomous_vm_cluster_arn.as_deref()
    }
    /// <p>The unique identifier of the ODB network associated with this Autonomous VM cluster.</p>
    pub fn odb_network_id(&self) -> ::std::option::Option<&str> {
        self.odb_network_id.as_deref()
    }
    /// <p>The name of the OCI resource anchor associated with this Autonomous VM cluster.</p>
    pub fn oci_resource_anchor_name(&self) -> ::std::option::Option<&str> {
        self.oci_resource_anchor_name.as_deref()
    }
    /// <p>The progress of the current operation on the Autonomous VM cluster, as a percentage.</p>
    pub fn percent_progress(&self) -> ::std::option::Option<f32> {
        self.percent_progress
    }
    /// <p>The display name of the Autonomous VM cluster.</p>
    pub fn display_name(&self) -> ::std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>The current state of the Autonomous VM cluster. Possible values include <code>CREATING</code>, <code>AVAILABLE</code>, <code>UPDATING</code>, <code>DELETING</code>, <code>DELETED</code>, <code>FAILED</code>.</p>
    pub fn status(&self) -> ::std::option::Option<&crate::types::ResourceStatus> {
        self.status.as_ref()
    }
    /// <p>Additional information about the current status of the Autonomous VM cluster.</p>
    pub fn status_reason(&self) -> ::std::option::Option<&str> {
        self.status_reason.as_deref()
    }
    /// <p>The unique identifier of the Cloud Exadata Infrastructure containing this Autonomous VM cluster.</p>
    pub fn cloud_exadata_infrastructure_id(&self) -> ::std::option::Option<&str> {
        self.cloud_exadata_infrastructure_id.as_deref()
    }
    /// <p>The percentage of data storage currently in use for Autonomous Databases in the Autonomous VM cluster.</p>
    pub fn autonomous_data_storage_percentage(&self) -> ::std::option::Option<f32> {
        self.autonomous_data_storage_percentage
    }
    /// <p>The data storage size allocated for Autonomous Databases in the Autonomous VM cluster, in TB.</p>
    pub fn autonomous_data_storage_size_in_tbs(&self) -> ::std::option::Option<f64> {
        self.autonomous_data_storage_size_in_tbs
    }
    /// <p>The available data storage space for Autonomous Databases in the Autonomous VM cluster, in TB.</p>
    pub fn available_autonomous_data_storage_size_in_tbs(&self) -> ::std::option::Option<f64> {
        self.available_autonomous_data_storage_size_in_tbs
    }
    /// <p>The number of Autonomous CDBs that you can create with the currently available storage.</p>
    pub fn available_container_databases(&self) -> ::std::option::Option<i32> {
        self.available_container_databases
    }
    /// <p>The number of CPU cores available for allocation to Autonomous Databases.</p>
    pub fn available_cpus(&self) -> ::std::option::Option<f32> {
        self.available_cpus
    }
    /// <p>The compute model of the Autonomous VM cluster: ECPU or OCPU.</p>
    pub fn compute_model(&self) -> ::std::option::Option<&crate::types::ComputeModel> {
        self.compute_model.as_ref()
    }
    /// <p>The total number of CPU cores in the Autonomous VM cluster.</p>
    pub fn cpu_core_count(&self) -> ::std::option::Option<i32> {
        self.cpu_core_count
    }
    /// <p>The number of CPU cores enabled per node in the Autonomous VM cluster.</p>
    pub fn cpu_core_count_per_node(&self) -> ::std::option::Option<i32> {
        self.cpu_core_count_per_node
    }
    /// <p>The percentage of total CPU cores currently in use in the Autonomous VM cluster.</p>
    pub fn cpu_percentage(&self) -> ::std::option::Option<f32> {
        self.cpu_percentage
    }
    /// <p>The total data storage allocated to the Autonomous VM cluster, in GB.</p>
    pub fn data_storage_size_in_gbs(&self) -> ::std::option::Option<f64> {
        self.data_storage_size_in_gbs
    }
    /// <p>The total data storage allocated to the Autonomous VM cluster, in TB.</p>
    pub fn data_storage_size_in_tbs(&self) -> ::std::option::Option<f64> {
        self.data_storage_size_in_tbs
    }
    /// <p>The local node storage allocated to the Autonomous VM cluster, in gigabytes (GB).</p>
    pub fn db_node_storage_size_in_gbs(&self) -> ::std::option::Option<i32> {
        self.db_node_storage_size_in_gbs
    }
    /// <p>The list of database servers associated with the Autonomous VM cluster.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.db_servers.is_none()`.
    pub fn db_servers(&self) -> &[::std::string::String] {
        self.db_servers.as_deref().unwrap_or_default()
    }
    /// <p>The user-provided description of the Autonomous VM cluster.</p>
    pub fn description(&self) -> ::std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The domain name for the Autonomous VM cluster.</p>
    pub fn domain(&self) -> ::std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p>The minimum value to which you can scale down the Exadata storage, in TB.</p>
    pub fn exadata_storage_in_tbs_lowest_scaled_value(&self) -> ::std::option::Option<f64> {
        self.exadata_storage_in_tbs_lowest_scaled_value
    }
    /// <p>The hostname for the Autonomous VM cluster.</p>
    pub fn hostname(&self) -> ::std::option::Option<&str> {
        self.hostname.as_deref()
    }
    /// <p>The Oracle Cloud Identifier (OCID) of the Autonomous VM cluster.</p>
    pub fn ocid(&self) -> ::std::option::Option<&str> {
        self.ocid.as_deref()
    }
    /// <p>The URL for accessing the OCI console page for this Autonomous VM cluster.</p>
    pub fn oci_url(&self) -> ::std::option::Option<&str> {
        self.oci_url.as_deref()
    }
    /// <p>Indicates whether mutual TLS (mTLS) authentication is enabled for the Autonomous VM cluster.</p>
    pub fn is_mtls_enabled_vm_cluster(&self) -> ::std::option::Option<bool> {
        self.is_mtls_enabled_vm_cluster
    }
    /// <p>The Oracle license model that applies to the Autonomous VM cluster.</p>
    pub fn license_model(&self) -> ::std::option::Option<&crate::types::LicenseModel> {
        self.license_model.as_ref()
    }
    /// <p>The scheduling details for the maintenance window. Patching and system updates take place during the maintenance window.</p>
    pub fn maintenance_window(&self) -> ::std::option::Option<&crate::types::MaintenanceWindow> {
        self.maintenance_window.as_ref()
    }
    /// <p>The minimum value to which you can scale down the maximum number of Autonomous CDBs.</p>
    pub fn max_acds_lowest_scaled_value(&self) -> ::std::option::Option<i32> {
        self.max_acds_lowest_scaled_value
    }
    /// <p>The amount of memory allocated per Oracle Compute Unit, in GB.</p>
    pub fn memory_per_oracle_compute_unit_in_gbs(&self) -> ::std::option::Option<i32> {
        self.memory_per_oracle_compute_unit_in_gbs
    }
    /// <p>The total amount of memory allocated to the Autonomous VM cluster, in gigabytes (GB).</p>
    pub fn memory_size_in_gbs(&self) -> ::std::option::Option<i32> {
        self.memory_size_in_gbs
    }
    /// <p>The number of database server nodes in the Autonomous VM cluster.</p>
    pub fn node_count(&self) -> ::std::option::Option<i32> {
        self.node_count
    }
    /// <p>The number of Autonomous CDBs that can't be provisioned because of resource constraints.</p>
    pub fn non_provisionable_autonomous_container_databases(&self) -> ::std::option::Option<i32> {
        self.non_provisionable_autonomous_container_databases
    }
    /// <p>The number of Autonomous CDBs that can be provisioned in the Autonomous VM cluster.</p>
    pub fn provisionable_autonomous_container_databases(&self) -> ::std::option::Option<i32> {
        self.provisionable_autonomous_container_databases
    }
    /// <p>The number of Autonomous CDBs currently provisioned in the Autonomous VM cluster.</p>
    pub fn provisioned_autonomous_container_databases(&self) -> ::std::option::Option<i32> {
        self.provisioned_autonomous_container_databases
    }
    /// <p>The number of CPU cores currently provisioned in the Autonomous VM cluster.</p>
    pub fn provisioned_cpus(&self) -> ::std::option::Option<f32> {
        self.provisioned_cpus
    }
    /// <p>The number of CPU cores that can be reclaimed from terminated or scaled-down Autonomous Databases.</p>
    pub fn reclaimable_cpus(&self) -> ::std::option::Option<f32> {
        self.reclaimable_cpus
    }
    /// <p>The number of CPU cores reserved for system operations and redundancy.</p>
    pub fn reserved_cpus(&self) -> ::std::option::Option<f32> {
        self.reserved_cpus
    }
    /// <p>The SCAN listener port for non-TLS (TCP) protocol. The default is 1521.</p>
    pub fn scan_listener_port_non_tls(&self) -> ::std::option::Option<i32> {
        self.scan_listener_port_non_tls
    }
    /// <p>The SCAN listener port for TLS (TCP) protocol. The default is 2484.</p>
    pub fn scan_listener_port_tls(&self) -> ::std::option::Option<i32> {
        self.scan_listener_port_tls
    }
    /// <p>The shape of the Exadata infrastructure for the Autonomous VM cluster.</p>
    pub fn shape(&self) -> ::std::option::Option<&str> {
        self.shape.as_deref()
    }
    /// <p>The date and time when the Autonomous VM cluster was created.</p>
    pub fn created_at(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The expiration date and time of the database SSL certificate.</p>
    pub fn time_database_ssl_certificate_expires(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.time_database_ssl_certificate_expires.as_ref()
    }
    /// <p>The expiration date and time of the Oracle REST Data Services (ORDS) certificate.</p>
    pub fn time_ords_certificate_expires(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.time_ords_certificate_expires.as_ref()
    }
    /// <p>The time zone of the Autonomous VM cluster.</p>
    pub fn time_zone(&self) -> ::std::option::Option<&str> {
        self.time_zone.as_deref()
    }
    /// <p>The total number of Autonomous Container Databases that can be created with the allocated local storage.</p>
    pub fn total_container_databases(&self) -> ::std::option::Option<i32> {
        self.total_container_databases
    }
}
impl CloudAutonomousVmCluster {
    /// Creates a new builder-style object to manufacture [`CloudAutonomousVmCluster`](crate::types::CloudAutonomousVmCluster).
    pub fn builder() -> crate::types::builders::CloudAutonomousVmClusterBuilder {
        crate::types::builders::CloudAutonomousVmClusterBuilder::default()
    }
}

/// A builder for [`CloudAutonomousVmCluster`](crate::types::CloudAutonomousVmCluster).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct CloudAutonomousVmClusterBuilder {
    pub(crate) cloud_autonomous_vm_cluster_id: ::std::option::Option<::std::string::String>,
    pub(crate) cloud_autonomous_vm_cluster_arn: ::std::option::Option<::std::string::String>,
    pub(crate) odb_network_id: ::std::option::Option<::std::string::String>,
    pub(crate) oci_resource_anchor_name: ::std::option::Option<::std::string::String>,
    pub(crate) percent_progress: ::std::option::Option<f32>,
    pub(crate) display_name: ::std::option::Option<::std::string::String>,
    pub(crate) status: ::std::option::Option<crate::types::ResourceStatus>,
    pub(crate) status_reason: ::std::option::Option<::std::string::String>,
    pub(crate) cloud_exadata_infrastructure_id: ::std::option::Option<::std::string::String>,
    pub(crate) autonomous_data_storage_percentage: ::std::option::Option<f32>,
    pub(crate) autonomous_data_storage_size_in_tbs: ::std::option::Option<f64>,
    pub(crate) available_autonomous_data_storage_size_in_tbs: ::std::option::Option<f64>,
    pub(crate) available_container_databases: ::std::option::Option<i32>,
    pub(crate) available_cpus: ::std::option::Option<f32>,
    pub(crate) compute_model: ::std::option::Option<crate::types::ComputeModel>,
    pub(crate) cpu_core_count: ::std::option::Option<i32>,
    pub(crate) cpu_core_count_per_node: ::std::option::Option<i32>,
    pub(crate) cpu_percentage: ::std::option::Option<f32>,
    pub(crate) data_storage_size_in_gbs: ::std::option::Option<f64>,
    pub(crate) data_storage_size_in_tbs: ::std::option::Option<f64>,
    pub(crate) db_node_storage_size_in_gbs: ::std::option::Option<i32>,
    pub(crate) db_servers: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) domain: ::std::option::Option<::std::string::String>,
    pub(crate) exadata_storage_in_tbs_lowest_scaled_value: ::std::option::Option<f64>,
    pub(crate) hostname: ::std::option::Option<::std::string::String>,
    pub(crate) ocid: ::std::option::Option<::std::string::String>,
    pub(crate) oci_url: ::std::option::Option<::std::string::String>,
    pub(crate) is_mtls_enabled_vm_cluster: ::std::option::Option<bool>,
    pub(crate) license_model: ::std::option::Option<crate::types::LicenseModel>,
    pub(crate) maintenance_window: ::std::option::Option<crate::types::MaintenanceWindow>,
    pub(crate) max_acds_lowest_scaled_value: ::std::option::Option<i32>,
    pub(crate) memory_per_oracle_compute_unit_in_gbs: ::std::option::Option<i32>,
    pub(crate) memory_size_in_gbs: ::std::option::Option<i32>,
    pub(crate) node_count: ::std::option::Option<i32>,
    pub(crate) non_provisionable_autonomous_container_databases: ::std::option::Option<i32>,
    pub(crate) provisionable_autonomous_container_databases: ::std::option::Option<i32>,
    pub(crate) provisioned_autonomous_container_databases: ::std::option::Option<i32>,
    pub(crate) provisioned_cpus: ::std::option::Option<f32>,
    pub(crate) reclaimable_cpus: ::std::option::Option<f32>,
    pub(crate) reserved_cpus: ::std::option::Option<f32>,
    pub(crate) scan_listener_port_non_tls: ::std::option::Option<i32>,
    pub(crate) scan_listener_port_tls: ::std::option::Option<i32>,
    pub(crate) shape: ::std::option::Option<::std::string::String>,
    pub(crate) created_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) time_database_ssl_certificate_expires: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) time_ords_certificate_expires: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) time_zone: ::std::option::Option<::std::string::String>,
    pub(crate) total_container_databases: ::std::option::Option<i32>,
}
impl CloudAutonomousVmClusterBuilder {
    /// <p>The unique identifier of the Autonomous VM cluster.</p>
    /// This field is required.
    pub fn cloud_autonomous_vm_cluster_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cloud_autonomous_vm_cluster_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier of the Autonomous VM cluster.</p>
    pub fn set_cloud_autonomous_vm_cluster_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cloud_autonomous_vm_cluster_id = input;
        self
    }
    /// <p>The unique identifier of the Autonomous VM cluster.</p>
    pub fn get_cloud_autonomous_vm_cluster_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.cloud_autonomous_vm_cluster_id
    }
    /// <p>The Amazon Resource Name (ARN) for the Autonomous VM cluster.</p>
    pub fn cloud_autonomous_vm_cluster_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cloud_autonomous_vm_cluster_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) for the Autonomous VM cluster.</p>
    pub fn set_cloud_autonomous_vm_cluster_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cloud_autonomous_vm_cluster_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) for the Autonomous VM cluster.</p>
    pub fn get_cloud_autonomous_vm_cluster_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.cloud_autonomous_vm_cluster_arn
    }
    /// <p>The unique identifier of the ODB network associated with this Autonomous VM cluster.</p>
    pub fn odb_network_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.odb_network_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier of the ODB network associated with this Autonomous VM cluster.</p>
    pub fn set_odb_network_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.odb_network_id = input;
        self
    }
    /// <p>The unique identifier of the ODB network associated with this Autonomous VM cluster.</p>
    pub fn get_odb_network_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.odb_network_id
    }
    /// <p>The name of the OCI resource anchor associated with this Autonomous VM cluster.</p>
    pub fn oci_resource_anchor_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.oci_resource_anchor_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the OCI resource anchor associated with this Autonomous VM cluster.</p>
    pub fn set_oci_resource_anchor_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.oci_resource_anchor_name = input;
        self
    }
    /// <p>The name of the OCI resource anchor associated with this Autonomous VM cluster.</p>
    pub fn get_oci_resource_anchor_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.oci_resource_anchor_name
    }
    /// <p>The progress of the current operation on the Autonomous VM cluster, as a percentage.</p>
    pub fn percent_progress(mut self, input: f32) -> Self {
        self.percent_progress = ::std::option::Option::Some(input);
        self
    }
    /// <p>The progress of the current operation on the Autonomous VM cluster, as a percentage.</p>
    pub fn set_percent_progress(mut self, input: ::std::option::Option<f32>) -> Self {
        self.percent_progress = input;
        self
    }
    /// <p>The progress of the current operation on the Autonomous VM cluster, as a percentage.</p>
    pub fn get_percent_progress(&self) -> &::std::option::Option<f32> {
        &self.percent_progress
    }
    /// <p>The display name of the Autonomous VM cluster.</p>
    pub fn display_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.display_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The display name of the Autonomous VM cluster.</p>
    pub fn set_display_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.display_name = input;
        self
    }
    /// <p>The display name of the Autonomous VM cluster.</p>
    pub fn get_display_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.display_name
    }
    /// <p>The current state of the Autonomous VM cluster. Possible values include <code>CREATING</code>, <code>AVAILABLE</code>, <code>UPDATING</code>, <code>DELETING</code>, <code>DELETED</code>, <code>FAILED</code>.</p>
    pub fn status(mut self, input: crate::types::ResourceStatus) -> Self {
        self.status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The current state of the Autonomous VM cluster. Possible values include <code>CREATING</code>, <code>AVAILABLE</code>, <code>UPDATING</code>, <code>DELETING</code>, <code>DELETED</code>, <code>FAILED</code>.</p>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::ResourceStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>The current state of the Autonomous VM cluster. Possible values include <code>CREATING</code>, <code>AVAILABLE</code>, <code>UPDATING</code>, <code>DELETING</code>, <code>DELETED</code>, <code>FAILED</code>.</p>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::ResourceStatus> {
        &self.status
    }
    /// <p>Additional information about the current status of the Autonomous VM cluster.</p>
    pub fn status_reason(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.status_reason = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Additional information about the current status of the Autonomous VM cluster.</p>
    pub fn set_status_reason(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.status_reason = input;
        self
    }
    /// <p>Additional information about the current status of the Autonomous VM cluster.</p>
    pub fn get_status_reason(&self) -> &::std::option::Option<::std::string::String> {
        &self.status_reason
    }
    /// <p>The unique identifier of the Cloud Exadata Infrastructure containing this Autonomous VM cluster.</p>
    pub fn cloud_exadata_infrastructure_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cloud_exadata_infrastructure_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier of the Cloud Exadata Infrastructure containing this Autonomous VM cluster.</p>
    pub fn set_cloud_exadata_infrastructure_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cloud_exadata_infrastructure_id = input;
        self
    }
    /// <p>The unique identifier of the Cloud Exadata Infrastructure containing this Autonomous VM cluster.</p>
    pub fn get_cloud_exadata_infrastructure_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.cloud_exadata_infrastructure_id
    }
    /// <p>The percentage of data storage currently in use for Autonomous Databases in the Autonomous VM cluster.</p>
    pub fn autonomous_data_storage_percentage(mut self, input: f32) -> Self {
        self.autonomous_data_storage_percentage = ::std::option::Option::Some(input);
        self
    }
    /// <p>The percentage of data storage currently in use for Autonomous Databases in the Autonomous VM cluster.</p>
    pub fn set_autonomous_data_storage_percentage(mut self, input: ::std::option::Option<f32>) -> Self {
        self.autonomous_data_storage_percentage = input;
        self
    }
    /// <p>The percentage of data storage currently in use for Autonomous Databases in the Autonomous VM cluster.</p>
    pub fn get_autonomous_data_storage_percentage(&self) -> &::std::option::Option<f32> {
        &self.autonomous_data_storage_percentage
    }
    /// <p>The data storage size allocated for Autonomous Databases in the Autonomous VM cluster, in TB.</p>
    pub fn autonomous_data_storage_size_in_tbs(mut self, input: f64) -> Self {
        self.autonomous_data_storage_size_in_tbs = ::std::option::Option::Some(input);
        self
    }
    /// <p>The data storage size allocated for Autonomous Databases in the Autonomous VM cluster, in TB.</p>
    pub fn set_autonomous_data_storage_size_in_tbs(mut self, input: ::std::option::Option<f64>) -> Self {
        self.autonomous_data_storage_size_in_tbs = input;
        self
    }
    /// <p>The data storage size allocated for Autonomous Databases in the Autonomous VM cluster, in TB.</p>
    pub fn get_autonomous_data_storage_size_in_tbs(&self) -> &::std::option::Option<f64> {
        &self.autonomous_data_storage_size_in_tbs
    }
    /// <p>The available data storage space for Autonomous Databases in the Autonomous VM cluster, in TB.</p>
    pub fn available_autonomous_data_storage_size_in_tbs(mut self, input: f64) -> Self {
        self.available_autonomous_data_storage_size_in_tbs = ::std::option::Option::Some(input);
        self
    }
    /// <p>The available data storage space for Autonomous Databases in the Autonomous VM cluster, in TB.</p>
    pub fn set_available_autonomous_data_storage_size_in_tbs(mut self, input: ::std::option::Option<f64>) -> Self {
        self.available_autonomous_data_storage_size_in_tbs = input;
        self
    }
    /// <p>The available data storage space for Autonomous Databases in the Autonomous VM cluster, in TB.</p>
    pub fn get_available_autonomous_data_storage_size_in_tbs(&self) -> &::std::option::Option<f64> {
        &self.available_autonomous_data_storage_size_in_tbs
    }
    /// <p>The number of Autonomous CDBs that you can create with the currently available storage.</p>
    pub fn available_container_databases(mut self, input: i32) -> Self {
        self.available_container_databases = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of Autonomous CDBs that you can create with the currently available storage.</p>
    pub fn set_available_container_databases(mut self, input: ::std::option::Option<i32>) -> Self {
        self.available_container_databases = input;
        self
    }
    /// <p>The number of Autonomous CDBs that you can create with the currently available storage.</p>
    pub fn get_available_container_databases(&self) -> &::std::option::Option<i32> {
        &self.available_container_databases
    }
    /// <p>The number of CPU cores available for allocation to Autonomous Databases.</p>
    pub fn available_cpus(mut self, input: f32) -> Self {
        self.available_cpus = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of CPU cores available for allocation to Autonomous Databases.</p>
    pub fn set_available_cpus(mut self, input: ::std::option::Option<f32>) -> Self {
        self.available_cpus = input;
        self
    }
    /// <p>The number of CPU cores available for allocation to Autonomous Databases.</p>
    pub fn get_available_cpus(&self) -> &::std::option::Option<f32> {
        &self.available_cpus
    }
    /// <p>The compute model of the Autonomous VM cluster: ECPU or OCPU.</p>
    pub fn compute_model(mut self, input: crate::types::ComputeModel) -> Self {
        self.compute_model = ::std::option::Option::Some(input);
        self
    }
    /// <p>The compute model of the Autonomous VM cluster: ECPU or OCPU.</p>
    pub fn set_compute_model(mut self, input: ::std::option::Option<crate::types::ComputeModel>) -> Self {
        self.compute_model = input;
        self
    }
    /// <p>The compute model of the Autonomous VM cluster: ECPU or OCPU.</p>
    pub fn get_compute_model(&self) -> &::std::option::Option<crate::types::ComputeModel> {
        &self.compute_model
    }
    /// <p>The total number of CPU cores in the Autonomous VM cluster.</p>
    pub fn cpu_core_count(mut self, input: i32) -> Self {
        self.cpu_core_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total number of CPU cores in the Autonomous VM cluster.</p>
    pub fn set_cpu_core_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.cpu_core_count = input;
        self
    }
    /// <p>The total number of CPU cores in the Autonomous VM cluster.</p>
    pub fn get_cpu_core_count(&self) -> &::std::option::Option<i32> {
        &self.cpu_core_count
    }
    /// <p>The number of CPU cores enabled per node in the Autonomous VM cluster.</p>
    pub fn cpu_core_count_per_node(mut self, input: i32) -> Self {
        self.cpu_core_count_per_node = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of CPU cores enabled per node in the Autonomous VM cluster.</p>
    pub fn set_cpu_core_count_per_node(mut self, input: ::std::option::Option<i32>) -> Self {
        self.cpu_core_count_per_node = input;
        self
    }
    /// <p>The number of CPU cores enabled per node in the Autonomous VM cluster.</p>
    pub fn get_cpu_core_count_per_node(&self) -> &::std::option::Option<i32> {
        &self.cpu_core_count_per_node
    }
    /// <p>The percentage of total CPU cores currently in use in the Autonomous VM cluster.</p>
    pub fn cpu_percentage(mut self, input: f32) -> Self {
        self.cpu_percentage = ::std::option::Option::Some(input);
        self
    }
    /// <p>The percentage of total CPU cores currently in use in the Autonomous VM cluster.</p>
    pub fn set_cpu_percentage(mut self, input: ::std::option::Option<f32>) -> Self {
        self.cpu_percentage = input;
        self
    }
    /// <p>The percentage of total CPU cores currently in use in the Autonomous VM cluster.</p>
    pub fn get_cpu_percentage(&self) -> &::std::option::Option<f32> {
        &self.cpu_percentage
    }
    /// <p>The total data storage allocated to the Autonomous VM cluster, in GB.</p>
    pub fn data_storage_size_in_gbs(mut self, input: f64) -> Self {
        self.data_storage_size_in_gbs = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total data storage allocated to the Autonomous VM cluster, in GB.</p>
    pub fn set_data_storage_size_in_gbs(mut self, input: ::std::option::Option<f64>) -> Self {
        self.data_storage_size_in_gbs = input;
        self
    }
    /// <p>The total data storage allocated to the Autonomous VM cluster, in GB.</p>
    pub fn get_data_storage_size_in_gbs(&self) -> &::std::option::Option<f64> {
        &self.data_storage_size_in_gbs
    }
    /// <p>The total data storage allocated to the Autonomous VM cluster, in TB.</p>
    pub fn data_storage_size_in_tbs(mut self, input: f64) -> Self {
        self.data_storage_size_in_tbs = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total data storage allocated to the Autonomous VM cluster, in TB.</p>
    pub fn set_data_storage_size_in_tbs(mut self, input: ::std::option::Option<f64>) -> Self {
        self.data_storage_size_in_tbs = input;
        self
    }
    /// <p>The total data storage allocated to the Autonomous VM cluster, in TB.</p>
    pub fn get_data_storage_size_in_tbs(&self) -> &::std::option::Option<f64> {
        &self.data_storage_size_in_tbs
    }
    /// <p>The local node storage allocated to the Autonomous VM cluster, in gigabytes (GB).</p>
    pub fn db_node_storage_size_in_gbs(mut self, input: i32) -> Self {
        self.db_node_storage_size_in_gbs = ::std::option::Option::Some(input);
        self
    }
    /// <p>The local node storage allocated to the Autonomous VM cluster, in gigabytes (GB).</p>
    pub fn set_db_node_storage_size_in_gbs(mut self, input: ::std::option::Option<i32>) -> Self {
        self.db_node_storage_size_in_gbs = input;
        self
    }
    /// <p>The local node storage allocated to the Autonomous VM cluster, in gigabytes (GB).</p>
    pub fn get_db_node_storage_size_in_gbs(&self) -> &::std::option::Option<i32> {
        &self.db_node_storage_size_in_gbs
    }
    /// Appends an item to `db_servers`.
    ///
    /// To override the contents of this collection use [`set_db_servers`](Self::set_db_servers).
    ///
    /// <p>The list of database servers associated with the Autonomous VM cluster.</p>
    pub fn db_servers(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.db_servers.unwrap_or_default();
        v.push(input.into());
        self.db_servers = ::std::option::Option::Some(v);
        self
    }
    /// <p>The list of database servers associated with the Autonomous VM cluster.</p>
    pub fn set_db_servers(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.db_servers = input;
        self
    }
    /// <p>The list of database servers associated with the Autonomous VM cluster.</p>
    pub fn get_db_servers(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.db_servers
    }
    /// <p>The user-provided description of the Autonomous VM cluster.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The user-provided description of the Autonomous VM cluster.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>The user-provided description of the Autonomous VM cluster.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// <p>The domain name for the Autonomous VM cluster.</p>
    pub fn domain(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.domain = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The domain name for the Autonomous VM cluster.</p>
    pub fn set_domain(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.domain = input;
        self
    }
    /// <p>The domain name for the Autonomous VM cluster.</p>
    pub fn get_domain(&self) -> &::std::option::Option<::std::string::String> {
        &self.domain
    }
    /// <p>The minimum value to which you can scale down the Exadata storage, in TB.</p>
    pub fn exadata_storage_in_tbs_lowest_scaled_value(mut self, input: f64) -> Self {
        self.exadata_storage_in_tbs_lowest_scaled_value = ::std::option::Option::Some(input);
        self
    }
    /// <p>The minimum value to which you can scale down the Exadata storage, in TB.</p>
    pub fn set_exadata_storage_in_tbs_lowest_scaled_value(mut self, input: ::std::option::Option<f64>) -> Self {
        self.exadata_storage_in_tbs_lowest_scaled_value = input;
        self
    }
    /// <p>The minimum value to which you can scale down the Exadata storage, in TB.</p>
    pub fn get_exadata_storage_in_tbs_lowest_scaled_value(&self) -> &::std::option::Option<f64> {
        &self.exadata_storage_in_tbs_lowest_scaled_value
    }
    /// <p>The hostname for the Autonomous VM cluster.</p>
    pub fn hostname(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.hostname = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The hostname for the Autonomous VM cluster.</p>
    pub fn set_hostname(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.hostname = input;
        self
    }
    /// <p>The hostname for the Autonomous VM cluster.</p>
    pub fn get_hostname(&self) -> &::std::option::Option<::std::string::String> {
        &self.hostname
    }
    /// <p>The Oracle Cloud Identifier (OCID) of the Autonomous VM cluster.</p>
    pub fn ocid(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.ocid = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Oracle Cloud Identifier (OCID) of the Autonomous VM cluster.</p>
    pub fn set_ocid(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.ocid = input;
        self
    }
    /// <p>The Oracle Cloud Identifier (OCID) of the Autonomous VM cluster.</p>
    pub fn get_ocid(&self) -> &::std::option::Option<::std::string::String> {
        &self.ocid
    }
    /// <p>The URL for accessing the OCI console page for this Autonomous VM cluster.</p>
    pub fn oci_url(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.oci_url = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The URL for accessing the OCI console page for this Autonomous VM cluster.</p>
    pub fn set_oci_url(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.oci_url = input;
        self
    }
    /// <p>The URL for accessing the OCI console page for this Autonomous VM cluster.</p>
    pub fn get_oci_url(&self) -> &::std::option::Option<::std::string::String> {
        &self.oci_url
    }
    /// <p>Indicates whether mutual TLS (mTLS) authentication is enabled for the Autonomous VM cluster.</p>
    pub fn is_mtls_enabled_vm_cluster(mut self, input: bool) -> Self {
        self.is_mtls_enabled_vm_cluster = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether mutual TLS (mTLS) authentication is enabled for the Autonomous VM cluster.</p>
    pub fn set_is_mtls_enabled_vm_cluster(mut self, input: ::std::option::Option<bool>) -> Self {
        self.is_mtls_enabled_vm_cluster = input;
        self
    }
    /// <p>Indicates whether mutual TLS (mTLS) authentication is enabled for the Autonomous VM cluster.</p>
    pub fn get_is_mtls_enabled_vm_cluster(&self) -> &::std::option::Option<bool> {
        &self.is_mtls_enabled_vm_cluster
    }
    /// <p>The Oracle license model that applies to the Autonomous VM cluster.</p>
    pub fn license_model(mut self, input: crate::types::LicenseModel) -> Self {
        self.license_model = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Oracle license model that applies to the Autonomous VM cluster.</p>
    pub fn set_license_model(mut self, input: ::std::option::Option<crate::types::LicenseModel>) -> Self {
        self.license_model = input;
        self
    }
    /// <p>The Oracle license model that applies to the Autonomous VM cluster.</p>
    pub fn get_license_model(&self) -> &::std::option::Option<crate::types::LicenseModel> {
        &self.license_model
    }
    /// <p>The scheduling details for the maintenance window. Patching and system updates take place during the maintenance window.</p>
    pub fn maintenance_window(mut self, input: crate::types::MaintenanceWindow) -> Self {
        self.maintenance_window = ::std::option::Option::Some(input);
        self
    }
    /// <p>The scheduling details for the maintenance window. Patching and system updates take place during the maintenance window.</p>
    pub fn set_maintenance_window(mut self, input: ::std::option::Option<crate::types::MaintenanceWindow>) -> Self {
        self.maintenance_window = input;
        self
    }
    /// <p>The scheduling details for the maintenance window. Patching and system updates take place during the maintenance window.</p>
    pub fn get_maintenance_window(&self) -> &::std::option::Option<crate::types::MaintenanceWindow> {
        &self.maintenance_window
    }
    /// <p>The minimum value to which you can scale down the maximum number of Autonomous CDBs.</p>
    pub fn max_acds_lowest_scaled_value(mut self, input: i32) -> Self {
        self.max_acds_lowest_scaled_value = ::std::option::Option::Some(input);
        self
    }
    /// <p>The minimum value to which you can scale down the maximum number of Autonomous CDBs.</p>
    pub fn set_max_acds_lowest_scaled_value(mut self, input: ::std::option::Option<i32>) -> Self {
        self.max_acds_lowest_scaled_value = input;
        self
    }
    /// <p>The minimum value to which you can scale down the maximum number of Autonomous CDBs.</p>
    pub fn get_max_acds_lowest_scaled_value(&self) -> &::std::option::Option<i32> {
        &self.max_acds_lowest_scaled_value
    }
    /// <p>The amount of memory allocated per Oracle Compute Unit, in GB.</p>
    pub fn memory_per_oracle_compute_unit_in_gbs(mut self, input: i32) -> Self {
        self.memory_per_oracle_compute_unit_in_gbs = ::std::option::Option::Some(input);
        self
    }
    /// <p>The amount of memory allocated per Oracle Compute Unit, in GB.</p>
    pub fn set_memory_per_oracle_compute_unit_in_gbs(mut self, input: ::std::option::Option<i32>) -> Self {
        self.memory_per_oracle_compute_unit_in_gbs = input;
        self
    }
    /// <p>The amount of memory allocated per Oracle Compute Unit, in GB.</p>
    pub fn get_memory_per_oracle_compute_unit_in_gbs(&self) -> &::std::option::Option<i32> {
        &self.memory_per_oracle_compute_unit_in_gbs
    }
    /// <p>The total amount of memory allocated to the Autonomous VM cluster, in gigabytes (GB).</p>
    pub fn memory_size_in_gbs(mut self, input: i32) -> Self {
        self.memory_size_in_gbs = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total amount of memory allocated to the Autonomous VM cluster, in gigabytes (GB).</p>
    pub fn set_memory_size_in_gbs(mut self, input: ::std::option::Option<i32>) -> Self {
        self.memory_size_in_gbs = input;
        self
    }
    /// <p>The total amount of memory allocated to the Autonomous VM cluster, in gigabytes (GB).</p>
    pub fn get_memory_size_in_gbs(&self) -> &::std::option::Option<i32> {
        &self.memory_size_in_gbs
    }
    /// <p>The number of database server nodes in the Autonomous VM cluster.</p>
    pub fn node_count(mut self, input: i32) -> Self {
        self.node_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of database server nodes in the Autonomous VM cluster.</p>
    pub fn set_node_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.node_count = input;
        self
    }
    /// <p>The number of database server nodes in the Autonomous VM cluster.</p>
    pub fn get_node_count(&self) -> &::std::option::Option<i32> {
        &self.node_count
    }
    /// <p>The number of Autonomous CDBs that can't be provisioned because of resource constraints.</p>
    pub fn non_provisionable_autonomous_container_databases(mut self, input: i32) -> Self {
        self.non_provisionable_autonomous_container_databases = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of Autonomous CDBs that can't be provisioned because of resource constraints.</p>
    pub fn set_non_provisionable_autonomous_container_databases(mut self, input: ::std::option::Option<i32>) -> Self {
        self.non_provisionable_autonomous_container_databases = input;
        self
    }
    /// <p>The number of Autonomous CDBs that can't be provisioned because of resource constraints.</p>
    pub fn get_non_provisionable_autonomous_container_databases(&self) -> &::std::option::Option<i32> {
        &self.non_provisionable_autonomous_container_databases
    }
    /// <p>The number of Autonomous CDBs that can be provisioned in the Autonomous VM cluster.</p>
    pub fn provisionable_autonomous_container_databases(mut self, input: i32) -> Self {
        self.provisionable_autonomous_container_databases = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of Autonomous CDBs that can be provisioned in the Autonomous VM cluster.</p>
    pub fn set_provisionable_autonomous_container_databases(mut self, input: ::std::option::Option<i32>) -> Self {
        self.provisionable_autonomous_container_databases = input;
        self
    }
    /// <p>The number of Autonomous CDBs that can be provisioned in the Autonomous VM cluster.</p>
    pub fn get_provisionable_autonomous_container_databases(&self) -> &::std::option::Option<i32> {
        &self.provisionable_autonomous_container_databases
    }
    /// <p>The number of Autonomous CDBs currently provisioned in the Autonomous VM cluster.</p>
    pub fn provisioned_autonomous_container_databases(mut self, input: i32) -> Self {
        self.provisioned_autonomous_container_databases = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of Autonomous CDBs currently provisioned in the Autonomous VM cluster.</p>
    pub fn set_provisioned_autonomous_container_databases(mut self, input: ::std::option::Option<i32>) -> Self {
        self.provisioned_autonomous_container_databases = input;
        self
    }
    /// <p>The number of Autonomous CDBs currently provisioned in the Autonomous VM cluster.</p>
    pub fn get_provisioned_autonomous_container_databases(&self) -> &::std::option::Option<i32> {
        &self.provisioned_autonomous_container_databases
    }
    /// <p>The number of CPU cores currently provisioned in the Autonomous VM cluster.</p>
    pub fn provisioned_cpus(mut self, input: f32) -> Self {
        self.provisioned_cpus = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of CPU cores currently provisioned in the Autonomous VM cluster.</p>
    pub fn set_provisioned_cpus(mut self, input: ::std::option::Option<f32>) -> Self {
        self.provisioned_cpus = input;
        self
    }
    /// <p>The number of CPU cores currently provisioned in the Autonomous VM cluster.</p>
    pub fn get_provisioned_cpus(&self) -> &::std::option::Option<f32> {
        &self.provisioned_cpus
    }
    /// <p>The number of CPU cores that can be reclaimed from terminated or scaled-down Autonomous Databases.</p>
    pub fn reclaimable_cpus(mut self, input: f32) -> Self {
        self.reclaimable_cpus = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of CPU cores that can be reclaimed from terminated or scaled-down Autonomous Databases.</p>
    pub fn set_reclaimable_cpus(mut self, input: ::std::option::Option<f32>) -> Self {
        self.reclaimable_cpus = input;
        self
    }
    /// <p>The number of CPU cores that can be reclaimed from terminated or scaled-down Autonomous Databases.</p>
    pub fn get_reclaimable_cpus(&self) -> &::std::option::Option<f32> {
        &self.reclaimable_cpus
    }
    /// <p>The number of CPU cores reserved for system operations and redundancy.</p>
    pub fn reserved_cpus(mut self, input: f32) -> Self {
        self.reserved_cpus = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of CPU cores reserved for system operations and redundancy.</p>
    pub fn set_reserved_cpus(mut self, input: ::std::option::Option<f32>) -> Self {
        self.reserved_cpus = input;
        self
    }
    /// <p>The number of CPU cores reserved for system operations and redundancy.</p>
    pub fn get_reserved_cpus(&self) -> &::std::option::Option<f32> {
        &self.reserved_cpus
    }
    /// <p>The SCAN listener port for non-TLS (TCP) protocol. The default is 1521.</p>
    pub fn scan_listener_port_non_tls(mut self, input: i32) -> Self {
        self.scan_listener_port_non_tls = ::std::option::Option::Some(input);
        self
    }
    /// <p>The SCAN listener port for non-TLS (TCP) protocol. The default is 1521.</p>
    pub fn set_scan_listener_port_non_tls(mut self, input: ::std::option::Option<i32>) -> Self {
        self.scan_listener_port_non_tls = input;
        self
    }
    /// <p>The SCAN listener port for non-TLS (TCP) protocol. The default is 1521.</p>
    pub fn get_scan_listener_port_non_tls(&self) -> &::std::option::Option<i32> {
        &self.scan_listener_port_non_tls
    }
    /// <p>The SCAN listener port for TLS (TCP) protocol. The default is 2484.</p>
    pub fn scan_listener_port_tls(mut self, input: i32) -> Self {
        self.scan_listener_port_tls = ::std::option::Option::Some(input);
        self
    }
    /// <p>The SCAN listener port for TLS (TCP) protocol. The default is 2484.</p>
    pub fn set_scan_listener_port_tls(mut self, input: ::std::option::Option<i32>) -> Self {
        self.scan_listener_port_tls = input;
        self
    }
    /// <p>The SCAN listener port for TLS (TCP) protocol. The default is 2484.</p>
    pub fn get_scan_listener_port_tls(&self) -> &::std::option::Option<i32> {
        &self.scan_listener_port_tls
    }
    /// <p>The shape of the Exadata infrastructure for the Autonomous VM cluster.</p>
    pub fn shape(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.shape = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The shape of the Exadata infrastructure for the Autonomous VM cluster.</p>
    pub fn set_shape(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.shape = input;
        self
    }
    /// <p>The shape of the Exadata infrastructure for the Autonomous VM cluster.</p>
    pub fn get_shape(&self) -> &::std::option::Option<::std::string::String> {
        &self.shape
    }
    /// <p>The date and time when the Autonomous VM cluster was created.</p>
    pub fn created_at(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.created_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date and time when the Autonomous VM cluster was created.</p>
    pub fn set_created_at(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.created_at = input;
        self
    }
    /// <p>The date and time when the Autonomous VM cluster was created.</p>
    pub fn get_created_at(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.created_at
    }
    /// <p>The expiration date and time of the database SSL certificate.</p>
    pub fn time_database_ssl_certificate_expires(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.time_database_ssl_certificate_expires = ::std::option::Option::Some(input);
        self
    }
    /// <p>The expiration date and time of the database SSL certificate.</p>
    pub fn set_time_database_ssl_certificate_expires(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.time_database_ssl_certificate_expires = input;
        self
    }
    /// <p>The expiration date and time of the database SSL certificate.</p>
    pub fn get_time_database_ssl_certificate_expires(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.time_database_ssl_certificate_expires
    }
    /// <p>The expiration date and time of the Oracle REST Data Services (ORDS) certificate.</p>
    pub fn time_ords_certificate_expires(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.time_ords_certificate_expires = ::std::option::Option::Some(input);
        self
    }
    /// <p>The expiration date and time of the Oracle REST Data Services (ORDS) certificate.</p>
    pub fn set_time_ords_certificate_expires(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.time_ords_certificate_expires = input;
        self
    }
    /// <p>The expiration date and time of the Oracle REST Data Services (ORDS) certificate.</p>
    pub fn get_time_ords_certificate_expires(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.time_ords_certificate_expires
    }
    /// <p>The time zone of the Autonomous VM cluster.</p>
    pub fn time_zone(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.time_zone = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The time zone of the Autonomous VM cluster.</p>
    pub fn set_time_zone(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.time_zone = input;
        self
    }
    /// <p>The time zone of the Autonomous VM cluster.</p>
    pub fn get_time_zone(&self) -> &::std::option::Option<::std::string::String> {
        &self.time_zone
    }
    /// <p>The total number of Autonomous Container Databases that can be created with the allocated local storage.</p>
    pub fn total_container_databases(mut self, input: i32) -> Self {
        self.total_container_databases = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total number of Autonomous Container Databases that can be created with the allocated local storage.</p>
    pub fn set_total_container_databases(mut self, input: ::std::option::Option<i32>) -> Self {
        self.total_container_databases = input;
        self
    }
    /// <p>The total number of Autonomous Container Databases that can be created with the allocated local storage.</p>
    pub fn get_total_container_databases(&self) -> &::std::option::Option<i32> {
        &self.total_container_databases
    }
    /// Consumes the builder and constructs a [`CloudAutonomousVmCluster`](crate::types::CloudAutonomousVmCluster).
    /// This method will fail if any of the following fields are not set:
    /// - [`cloud_autonomous_vm_cluster_id`](crate::types::builders::CloudAutonomousVmClusterBuilder::cloud_autonomous_vm_cluster_id)
    pub fn build(self) -> ::std::result::Result<crate::types::CloudAutonomousVmCluster, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::CloudAutonomousVmCluster {
            cloud_autonomous_vm_cluster_id: self.cloud_autonomous_vm_cluster_id.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "cloud_autonomous_vm_cluster_id",
                    "cloud_autonomous_vm_cluster_id was not specified but it is required when building CloudAutonomousVmCluster",
                )
            })?,
            cloud_autonomous_vm_cluster_arn: self.cloud_autonomous_vm_cluster_arn,
            odb_network_id: self.odb_network_id,
            oci_resource_anchor_name: self.oci_resource_anchor_name,
            percent_progress: self.percent_progress,
            display_name: self.display_name,
            status: self.status,
            status_reason: self.status_reason,
            cloud_exadata_infrastructure_id: self.cloud_exadata_infrastructure_id,
            autonomous_data_storage_percentage: self.autonomous_data_storage_percentage,
            autonomous_data_storage_size_in_tbs: self.autonomous_data_storage_size_in_tbs,
            available_autonomous_data_storage_size_in_tbs: self.available_autonomous_data_storage_size_in_tbs,
            available_container_databases: self.available_container_databases,
            available_cpus: self.available_cpus,
            compute_model: self.compute_model,
            cpu_core_count: self.cpu_core_count,
            cpu_core_count_per_node: self.cpu_core_count_per_node,
            cpu_percentage: self.cpu_percentage,
            data_storage_size_in_gbs: self.data_storage_size_in_gbs,
            data_storage_size_in_tbs: self.data_storage_size_in_tbs,
            db_node_storage_size_in_gbs: self.db_node_storage_size_in_gbs,
            db_servers: self.db_servers,
            description: self.description,
            domain: self.domain,
            exadata_storage_in_tbs_lowest_scaled_value: self.exadata_storage_in_tbs_lowest_scaled_value,
            hostname: self.hostname,
            ocid: self.ocid,
            oci_url: self.oci_url,
            is_mtls_enabled_vm_cluster: self.is_mtls_enabled_vm_cluster,
            license_model: self.license_model,
            maintenance_window: self.maintenance_window,
            max_acds_lowest_scaled_value: self.max_acds_lowest_scaled_value,
            memory_per_oracle_compute_unit_in_gbs: self.memory_per_oracle_compute_unit_in_gbs,
            memory_size_in_gbs: self.memory_size_in_gbs,
            node_count: self.node_count,
            non_provisionable_autonomous_container_databases: self.non_provisionable_autonomous_container_databases,
            provisionable_autonomous_container_databases: self.provisionable_autonomous_container_databases,
            provisioned_autonomous_container_databases: self.provisioned_autonomous_container_databases,
            provisioned_cpus: self.provisioned_cpus,
            reclaimable_cpus: self.reclaimable_cpus,
            reserved_cpus: self.reserved_cpus,
            scan_listener_port_non_tls: self.scan_listener_port_non_tls,
            scan_listener_port_tls: self.scan_listener_port_tls,
            shape: self.shape,
            created_at: self.created_at,
            time_database_ssl_certificate_expires: self.time_database_ssl_certificate_expires,
            time_ords_certificate_expires: self.time_ords_certificate_expires,
            time_zone: self.time_zone,
            total_container_databases: self.total_container_databases,
        })
    }
}
