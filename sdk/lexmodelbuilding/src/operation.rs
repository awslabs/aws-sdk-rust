// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Creates a new version of the bot based on the <code>$LATEST</code>
/// version. If the <code>$LATEST</code> version of this resource hasn't
/// changed since you created the last version, Amazon Lex doesn't create a new
/// version. It returns the last created version.</p>
/// <note>
/// <p>You can update only the <code>$LATEST</code> version of the bot.
/// You can't update the numbered versions that you create with the
/// <code>CreateBotVersion</code> operation.</p>
/// </note>
/// <p> When you create the first version of a bot, Amazon Lex sets the version
/// to 1. Subsequent versions increment by 1. For more information, see <a>versioning-intro</a>. </p>
/// <p> This operation requires permission for the
/// <code>lex:CreateBotVersion</code> action. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateBotVersion {
    _private: (),
}
impl CreateBotVersion {
    /// Creates a new builder-style object to manufacture [`CreateBotVersionInput`](crate::input::CreateBotVersionInput)
    pub fn builder() -> crate::input::create_bot_version_input::Builder {
        crate::input::create_bot_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateBotVersion {
    type Output = std::result::Result<
        crate::output::CreateBotVersionOutput,
        crate::error::CreateBotVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_bot_version_error(response)
        } else {
            crate::operation_deser::parse_create_bot_version_response(response)
        }
    }
}

/// <p>Creates a new version of an intent based on the
/// <code>$LATEST</code> version of the intent. If the <code>$LATEST</code>
/// version of this intent hasn't changed since you last updated it, Amazon Lex
/// doesn't create a new version. It returns the last version you
/// created.</p>
/// <note>
/// <p>You can update only the <code>$LATEST</code> version of the
/// intent. You can't update the numbered versions that you create with the
/// <code>CreateIntentVersion</code> operation.</p>
/// </note>
/// <p> When you create a version of an intent, Amazon Lex sets the version to
/// 1. Subsequent versions increment by 1. For more information, see <a>versioning-intro</a>. </p>
/// <p>This operation requires permissions to perform the
/// <code>lex:CreateIntentVersion</code> action. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateIntentVersion {
    _private: (),
}
impl CreateIntentVersion {
    /// Creates a new builder-style object to manufacture [`CreateIntentVersionInput`](crate::input::CreateIntentVersionInput)
    pub fn builder() -> crate::input::create_intent_version_input::Builder {
        crate::input::create_intent_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateIntentVersion {
    type Output = std::result::Result<
        crate::output::CreateIntentVersionOutput,
        crate::error::CreateIntentVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_intent_version_error(response)
        } else {
            crate::operation_deser::parse_create_intent_version_response(response)
        }
    }
}

/// <p>Creates a new version of a slot type based on the
/// <code>$LATEST</code> version of the specified slot type. If the
/// <code>$LATEST</code> version of this resource has not changed since the
/// last version that you created, Amazon Lex doesn't create a new version. It
/// returns the last version that you created. </p>
/// <note>
/// <p>You can update only the <code>$LATEST</code> version of a slot
/// type. You can't update the numbered versions that you create with the
/// <code>CreateSlotTypeVersion</code> operation.</p>
/// </note>
/// <p>When you create a version of a slot type, Amazon Lex sets the version to
/// 1. Subsequent versions increment by 1. For more information, see <a>versioning-intro</a>. </p>
/// <p>This operation requires permissions for the
/// <code>lex:CreateSlotTypeVersion</code> action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateSlotTypeVersion {
    _private: (),
}
impl CreateSlotTypeVersion {
    /// Creates a new builder-style object to manufacture [`CreateSlotTypeVersionInput`](crate::input::CreateSlotTypeVersionInput)
    pub fn builder() -> crate::input::create_slot_type_version_input::Builder {
        crate::input::create_slot_type_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateSlotTypeVersion {
    type Output = std::result::Result<
        crate::output::CreateSlotTypeVersionOutput,
        crate::error::CreateSlotTypeVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_slot_type_version_error(response)
        } else {
            crate::operation_deser::parse_create_slot_type_version_response(response)
        }
    }
}

/// <p>Deletes all versions of the bot, including the <code>$LATEST</code>
/// version. To delete a specific version of the bot, use the <a>DeleteBotVersion</a> operation. The <code>DeleteBot</code>
/// operation doesn't immediately remove the bot schema. Instead, it is marked
/// for deletion and removed later.</p>
/// <p>Amazon Lex stores utterances indefinitely for improving the ability of
/// your bot to respond to user inputs. These utterances are not removed when
/// the bot is deleted. To remove the utterances, use the <a>DeleteUtterances</a> operation.</p>
/// <p>If a bot has an alias, you can't delete it. Instead, the
/// <code>DeleteBot</code> operation returns a
/// <code>ResourceInUseException</code> exception that includes a reference
/// to the alias that refers to the bot. To remove the reference to the bot,
/// delete the alias. If you get the same exception again, delete the
/// referring alias until the <code>DeleteBot</code> operation is
/// successful.</p>
/// <p>This operation requires permissions for the
/// <code>lex:DeleteBot</code> action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteBot {
    _private: (),
}
impl DeleteBot {
    /// Creates a new builder-style object to manufacture [`DeleteBotInput`](crate::input::DeleteBotInput)
    pub fn builder() -> crate::input::delete_bot_input::Builder {
        crate::input::delete_bot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteBot {
    type Output = std::result::Result<crate::output::DeleteBotOutput, crate::error::DeleteBotError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_bot_error(response)
        } else {
            crate::operation_deser::parse_delete_bot_response(response)
        }
    }
}

/// <p>Deletes an alias for the specified bot. </p>
/// <p>You can't delete an alias that is used in the association between a
/// bot and a messaging channel. If an alias is used in a channel association,
/// the <code>DeleteBot</code> operation returns a
/// <code>ResourceInUseException</code> exception that includes a reference
/// to the channel association that refers to the bot. You can remove the
/// reference to the alias by deleting the channel association. If you get the
/// same exception again, delete the referring association until the
/// <code>DeleteBotAlias</code> operation is successful.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteBotAlias {
    _private: (),
}
impl DeleteBotAlias {
    /// Creates a new builder-style object to manufacture [`DeleteBotAliasInput`](crate::input::DeleteBotAliasInput)
    pub fn builder() -> crate::input::delete_bot_alias_input::Builder {
        crate::input::delete_bot_alias_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteBotAlias {
    type Output =
        std::result::Result<crate::output::DeleteBotAliasOutput, crate::error::DeleteBotAliasError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_bot_alias_error(response)
        } else {
            crate::operation_deser::parse_delete_bot_alias_response(response)
        }
    }
}

/// <p>Deletes the association between an Amazon Lex bot and a messaging
/// platform.</p>
/// <p>This operation requires permission for the
/// <code>lex:DeleteBotChannelAssociation</code> action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteBotChannelAssociation {
    _private: (),
}
impl DeleteBotChannelAssociation {
    /// Creates a new builder-style object to manufacture [`DeleteBotChannelAssociationInput`](crate::input::DeleteBotChannelAssociationInput)
    pub fn builder() -> crate::input::delete_bot_channel_association_input::Builder {
        crate::input::delete_bot_channel_association_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteBotChannelAssociation {
    type Output = std::result::Result<
        crate::output::DeleteBotChannelAssociationOutput,
        crate::error::DeleteBotChannelAssociationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_bot_channel_association_error(response)
        } else {
            crate::operation_deser::parse_delete_bot_channel_association_response(response)
        }
    }
}

/// <p>Deletes a specific version of a bot. To delete all versions of a
/// bot, use the <a>DeleteBot</a> operation. </p>
/// <p>This operation requires permissions for the
/// <code>lex:DeleteBotVersion</code> action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteBotVersion {
    _private: (),
}
impl DeleteBotVersion {
    /// Creates a new builder-style object to manufacture [`DeleteBotVersionInput`](crate::input::DeleteBotVersionInput)
    pub fn builder() -> crate::input::delete_bot_version_input::Builder {
        crate::input::delete_bot_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteBotVersion {
    type Output = std::result::Result<
        crate::output::DeleteBotVersionOutput,
        crate::error::DeleteBotVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_bot_version_error(response)
        } else {
            crate::operation_deser::parse_delete_bot_version_response(response)
        }
    }
}

/// <p>Deletes all versions of the intent, including the
/// <code>$LATEST</code> version. To delete a specific version of the
/// intent, use the <a>DeleteIntentVersion</a> operation.</p>
/// <p> You can delete a version of an intent only if it is not
/// referenced. To delete an intent that is referred to in one or more bots
/// (see <a>how-it-works</a>), you must remove those references
/// first. </p>
/// <note>
/// <p> If you get the <code>ResourceInUseException</code> exception, it
/// provides an example reference that shows where the intent is referenced.
/// To remove the reference to the intent, either update the bot or delete
/// it. If you get the same exception when you attempt to delete the intent
/// again, repeat until the intent has no references and the call to
/// <code>DeleteIntent</code> is successful. </p>
/// </note>
/// <p> This operation requires permission for the
/// <code>lex:DeleteIntent</code> action. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteIntent {
    _private: (),
}
impl DeleteIntent {
    /// Creates a new builder-style object to manufacture [`DeleteIntentInput`](crate::input::DeleteIntentInput)
    pub fn builder() -> crate::input::delete_intent_input::Builder {
        crate::input::delete_intent_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteIntent {
    type Output =
        std::result::Result<crate::output::DeleteIntentOutput, crate::error::DeleteIntentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_intent_error(response)
        } else {
            crate::operation_deser::parse_delete_intent_response(response)
        }
    }
}

/// <p>Deletes a specific version of an intent. To delete all versions of
/// a intent, use the <a>DeleteIntent</a> operation. </p>
/// <p>This operation requires permissions for the
/// <code>lex:DeleteIntentVersion</code> action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteIntentVersion {
    _private: (),
}
impl DeleteIntentVersion {
    /// Creates a new builder-style object to manufacture [`DeleteIntentVersionInput`](crate::input::DeleteIntentVersionInput)
    pub fn builder() -> crate::input::delete_intent_version_input::Builder {
        crate::input::delete_intent_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteIntentVersion {
    type Output = std::result::Result<
        crate::output::DeleteIntentVersionOutput,
        crate::error::DeleteIntentVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_intent_version_error(response)
        } else {
            crate::operation_deser::parse_delete_intent_version_response(response)
        }
    }
}

/// <p>Deletes all versions of the slot type, including the
/// <code>$LATEST</code> version. To delete a specific version of the slot
/// type, use the <a>DeleteSlotTypeVersion</a> operation.</p>
/// <p> You can delete a version of a slot type only if it is not
/// referenced. To delete a slot type that is referred to in one or more
/// intents, you must remove those references first. </p>
/// <note>
/// <p> If you get the <code>ResourceInUseException</code> exception,
/// the exception provides an example reference that shows the intent where
/// the slot type is referenced. To remove the reference to the slot type,
/// either update the intent or delete it. If you get the same exception
/// when you attempt to delete the slot type again, repeat until the slot
/// type has no references and the <code>DeleteSlotType</code> call is
/// successful. </p>
/// </note>
/// <p>This operation requires permission for the
/// <code>lex:DeleteSlotType</code> action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteSlotType {
    _private: (),
}
impl DeleteSlotType {
    /// Creates a new builder-style object to manufacture [`DeleteSlotTypeInput`](crate::input::DeleteSlotTypeInput)
    pub fn builder() -> crate::input::delete_slot_type_input::Builder {
        crate::input::delete_slot_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteSlotType {
    type Output =
        std::result::Result<crate::output::DeleteSlotTypeOutput, crate::error::DeleteSlotTypeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_slot_type_error(response)
        } else {
            crate::operation_deser::parse_delete_slot_type_response(response)
        }
    }
}

/// <p>Deletes a specific version of a slot type. To delete all versions
/// of a slot type, use the <a>DeleteSlotType</a> operation. </p>
/// <p>This operation requires permissions for the
/// <code>lex:DeleteSlotTypeVersion</code> action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteSlotTypeVersion {
    _private: (),
}
impl DeleteSlotTypeVersion {
    /// Creates a new builder-style object to manufacture [`DeleteSlotTypeVersionInput`](crate::input::DeleteSlotTypeVersionInput)
    pub fn builder() -> crate::input::delete_slot_type_version_input::Builder {
        crate::input::delete_slot_type_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteSlotTypeVersion {
    type Output = std::result::Result<
        crate::output::DeleteSlotTypeVersionOutput,
        crate::error::DeleteSlotTypeVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_slot_type_version_error(response)
        } else {
            crate::operation_deser::parse_delete_slot_type_version_response(response)
        }
    }
}

/// <p>Deletes stored utterances.</p>
/// <p>Amazon Lex stores the utterances that users send to your bot. Utterances
/// are stored for 15 days for use with the <a>GetUtterancesView</a> operation, and then stored indefinitely for use in improving the
/// ability of your bot to respond to user input.</p>
/// <p>Use the <code>DeleteUtterances</code> operation to manually delete
/// stored utterances for a specific user. When you use the
/// <code>DeleteUtterances</code> operation, utterances stored for improving
/// your bot's ability to respond to user input are deleted immediately.
/// Utterances stored for use with the <code>GetUtterancesView</code>
/// operation are deleted after 15 days.</p>
/// <p>This operation requires permissions for the
/// <code>lex:DeleteUtterances</code> action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteUtterances {
    _private: (),
}
impl DeleteUtterances {
    /// Creates a new builder-style object to manufacture [`DeleteUtterancesInput`](crate::input::DeleteUtterancesInput)
    pub fn builder() -> crate::input::delete_utterances_input::Builder {
        crate::input::delete_utterances_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteUtterances {
    type Output = std::result::Result<
        crate::output::DeleteUtterancesOutput,
        crate::error::DeleteUtterancesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_utterances_error(response)
        } else {
            crate::operation_deser::parse_delete_utterances_response(response)
        }
    }
}

/// <p>Returns metadata information for a specific bot. You must provide
/// the bot name and the bot version or alias. </p>
/// <p> This operation requires permissions for the
/// <code>lex:GetBot</code> action. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBot {
    _private: (),
}
impl GetBot {
    /// Creates a new builder-style object to manufacture [`GetBotInput`](crate::input::GetBotInput)
    pub fn builder() -> crate::input::get_bot_input::Builder {
        crate::input::get_bot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBot {
    type Output = std::result::Result<crate::output::GetBotOutput, crate::error::GetBotError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_bot_error(response)
        } else {
            crate::operation_deser::parse_get_bot_response(response)
        }
    }
}

/// <p>Returns information about an Amazon Lex bot alias. For more information
/// about aliases, see <a>versioning-aliases</a>.</p>
/// <p>This operation requires permissions for the
/// <code>lex:GetBotAlias</code> action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBotAlias {
    _private: (),
}
impl GetBotAlias {
    /// Creates a new builder-style object to manufacture [`GetBotAliasInput`](crate::input::GetBotAliasInput)
    pub fn builder() -> crate::input::get_bot_alias_input::Builder {
        crate::input::get_bot_alias_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBotAlias {
    type Output =
        std::result::Result<crate::output::GetBotAliasOutput, crate::error::GetBotAliasError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_bot_alias_error(response)
        } else {
            crate::operation_deser::parse_get_bot_alias_response(response)
        }
    }
}

/// <p>Returns a list of aliases for a specified Amazon Lex bot.</p>
/// <p>This operation requires permissions for the
/// <code>lex:GetBotAliases</code> action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBotAliases {
    _private: (),
}
impl GetBotAliases {
    /// Creates a new builder-style object to manufacture [`GetBotAliasesInput`](crate::input::GetBotAliasesInput)
    pub fn builder() -> crate::input::get_bot_aliases_input::Builder {
        crate::input::get_bot_aliases_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBotAliases {
    type Output =
        std::result::Result<crate::output::GetBotAliasesOutput, crate::error::GetBotAliasesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_bot_aliases_error(response)
        } else {
            crate::operation_deser::parse_get_bot_aliases_response(response)
        }
    }
}

/// <p>Returns information about the association between an Amazon Lex bot and
/// a messaging platform.</p>
/// <p>This operation requires permissions for the
/// <code>lex:GetBotChannelAssociation</code> action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBotChannelAssociation {
    _private: (),
}
impl GetBotChannelAssociation {
    /// Creates a new builder-style object to manufacture [`GetBotChannelAssociationInput`](crate::input::GetBotChannelAssociationInput)
    pub fn builder() -> crate::input::get_bot_channel_association_input::Builder {
        crate::input::get_bot_channel_association_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBotChannelAssociation {
    type Output = std::result::Result<
        crate::output::GetBotChannelAssociationOutput,
        crate::error::GetBotChannelAssociationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_bot_channel_association_error(response)
        } else {
            crate::operation_deser::parse_get_bot_channel_association_response(response)
        }
    }
}

/// <p> Returns a list of all of the channels associated with the
/// specified bot. </p>
/// <p>The <code>GetBotChannelAssociations</code> operation requires
/// permissions for the <code>lex:GetBotChannelAssociations</code>
/// action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBotChannelAssociations {
    _private: (),
}
impl GetBotChannelAssociations {
    /// Creates a new builder-style object to manufacture [`GetBotChannelAssociationsInput`](crate::input::GetBotChannelAssociationsInput)
    pub fn builder() -> crate::input::get_bot_channel_associations_input::Builder {
        crate::input::get_bot_channel_associations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBotChannelAssociations {
    type Output = std::result::Result<
        crate::output::GetBotChannelAssociationsOutput,
        crate::error::GetBotChannelAssociationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_bot_channel_associations_error(response)
        } else {
            crate::operation_deser::parse_get_bot_channel_associations_response(response)
        }
    }
}

/// <p>Returns bot information as follows: </p>
/// <ul>
/// <li>
/// <p>If you provide the <code>nameContains</code> field, the
/// response includes information for the <code>$LATEST</code> version of
/// all bots whose name contains the specified string.</p>
/// </li>
/// <li>
/// <p>If you don't specify the <code>nameContains</code> field, the
/// operation returns information about the <code>$LATEST</code> version
/// of all of your bots.</p>
/// </li>
/// </ul>
/// <p>This operation requires permission for the <code>lex:GetBots</code>
/// action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBots {
    _private: (),
}
impl GetBots {
    /// Creates a new builder-style object to manufacture [`GetBotsInput`](crate::input::GetBotsInput)
    pub fn builder() -> crate::input::get_bots_input::Builder {
        crate::input::get_bots_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBots {
    type Output = std::result::Result<crate::output::GetBotsOutput, crate::error::GetBotsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_bots_error(response)
        } else {
            crate::operation_deser::parse_get_bots_response(response)
        }
    }
}

/// <p>Gets information about all of the versions of a bot.</p>
/// <p>The <code>GetBotVersions</code> operation returns a
/// <code>BotMetadata</code> object for each version of a bot. For example,
/// if a bot has three numbered versions, the <code>GetBotVersions</code>
/// operation returns four <code>BotMetadata</code> objects in the response,
/// one for each numbered version and one for the <code>$LATEST</code>
/// version. </p>
/// <p>The <code>GetBotVersions</code> operation always returns at least
/// one version, the <code>$LATEST</code> version.</p>
/// <p>This operation requires permissions for the
/// <code>lex:GetBotVersions</code> action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBotVersions {
    _private: (),
}
impl GetBotVersions {
    /// Creates a new builder-style object to manufacture [`GetBotVersionsInput`](crate::input::GetBotVersionsInput)
    pub fn builder() -> crate::input::get_bot_versions_input::Builder {
        crate::input::get_bot_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBotVersions {
    type Output =
        std::result::Result<crate::output::GetBotVersionsOutput, crate::error::GetBotVersionsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_bot_versions_error(response)
        } else {
            crate::operation_deser::parse_get_bot_versions_response(response)
        }
    }
}

/// <p>Returns information about a built-in intent.</p>
/// <p>This operation requires permission for the
/// <code>lex:GetBuiltinIntent</code> action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBuiltinIntent {
    _private: (),
}
impl GetBuiltinIntent {
    /// Creates a new builder-style object to manufacture [`GetBuiltinIntentInput`](crate::input::GetBuiltinIntentInput)
    pub fn builder() -> crate::input::get_builtin_intent_input::Builder {
        crate::input::get_builtin_intent_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBuiltinIntent {
    type Output = std::result::Result<
        crate::output::GetBuiltinIntentOutput,
        crate::error::GetBuiltinIntentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_builtin_intent_error(response)
        } else {
            crate::operation_deser::parse_get_builtin_intent_response(response)
        }
    }
}

/// <p>Gets a list of built-in intents that meet the specified
/// criteria.</p>
/// <p>This operation requires permission for the
/// <code>lex:GetBuiltinIntents</code> action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBuiltinIntents {
    _private: (),
}
impl GetBuiltinIntents {
    /// Creates a new builder-style object to manufacture [`GetBuiltinIntentsInput`](crate::input::GetBuiltinIntentsInput)
    pub fn builder() -> crate::input::get_builtin_intents_input::Builder {
        crate::input::get_builtin_intents_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBuiltinIntents {
    type Output = std::result::Result<
        crate::output::GetBuiltinIntentsOutput,
        crate::error::GetBuiltinIntentsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_builtin_intents_error(response)
        } else {
            crate::operation_deser::parse_get_builtin_intents_response(response)
        }
    }
}

/// <p>Gets a list of built-in slot types that meet the specified
/// criteria.</p>
/// <p>For a list of built-in slot types, see <a href="https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/docs/built-in-intent-ref/slot-type-reference">Slot Type Reference</a> in the <i>Alexa Skills
/// Kit</i>.</p>
/// <p>This operation requires permission for the
/// <code>lex:GetBuiltInSlotTypes</code> action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBuiltinSlotTypes {
    _private: (),
}
impl GetBuiltinSlotTypes {
    /// Creates a new builder-style object to manufacture [`GetBuiltinSlotTypesInput`](crate::input::GetBuiltinSlotTypesInput)
    pub fn builder() -> crate::input::get_builtin_slot_types_input::Builder {
        crate::input::get_builtin_slot_types_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBuiltinSlotTypes {
    type Output = std::result::Result<
        crate::output::GetBuiltinSlotTypesOutput,
        crate::error::GetBuiltinSlotTypesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_builtin_slot_types_error(response)
        } else {
            crate::operation_deser::parse_get_builtin_slot_types_response(response)
        }
    }
}

/// <p>Exports the contents of a Amazon Lex resource in a specified format.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetExport {
    _private: (),
}
impl GetExport {
    /// Creates a new builder-style object to manufacture [`GetExportInput`](crate::input::GetExportInput)
    pub fn builder() -> crate::input::get_export_input::Builder {
        crate::input::get_export_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetExport {
    type Output = std::result::Result<crate::output::GetExportOutput, crate::error::GetExportError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_export_error(response)
        } else {
            crate::operation_deser::parse_get_export_response(response)
        }
    }
}

/// <p>Gets information about an import job started with the
/// <code>StartImport</code> operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetImport {
    _private: (),
}
impl GetImport {
    /// Creates a new builder-style object to manufacture [`GetImportInput`](crate::input::GetImportInput)
    pub fn builder() -> crate::input::get_import_input::Builder {
        crate::input::get_import_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetImport {
    type Output = std::result::Result<crate::output::GetImportOutput, crate::error::GetImportError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_import_error(response)
        } else {
            crate::operation_deser::parse_get_import_response(response)
        }
    }
}

/// <p> Returns information about an intent. In addition to the intent
/// name, you must specify the intent version. </p>
/// <p> This operation requires permissions to perform the
/// <code>lex:GetIntent</code> action. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetIntent {
    _private: (),
}
impl GetIntent {
    /// Creates a new builder-style object to manufacture [`GetIntentInput`](crate::input::GetIntentInput)
    pub fn builder() -> crate::input::get_intent_input::Builder {
        crate::input::get_intent_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetIntent {
    type Output = std::result::Result<crate::output::GetIntentOutput, crate::error::GetIntentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_intent_error(response)
        } else {
            crate::operation_deser::parse_get_intent_response(response)
        }
    }
}

/// <p>Returns intent information as follows: </p>
/// <ul>
/// <li>
/// <p>If you specify the <code>nameContains</code> field, returns the
/// <code>$LATEST</code> version of all intents that contain the
/// specified string.</p>
/// </li>
/// <li>
/// <p> If you don't specify the <code>nameContains</code> field,
/// returns information about the <code>$LATEST</code> version of all
/// intents. </p>
/// </li>
/// </ul>
/// <p> The operation requires permission for the
/// <code>lex:GetIntents</code> action. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetIntents {
    _private: (),
}
impl GetIntents {
    /// Creates a new builder-style object to manufacture [`GetIntentsInput`](crate::input::GetIntentsInput)
    pub fn builder() -> crate::input::get_intents_input::Builder {
        crate::input::get_intents_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetIntents {
    type Output =
        std::result::Result<crate::output::GetIntentsOutput, crate::error::GetIntentsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_intents_error(response)
        } else {
            crate::operation_deser::parse_get_intents_response(response)
        }
    }
}

/// <p>Gets information about all of the versions of an intent.</p>
/// <p>The <code>GetIntentVersions</code> operation returns an
/// <code>IntentMetadata</code> object for each version of an intent. For
/// example, if an intent has three numbered versions, the
/// <code>GetIntentVersions</code> operation returns four
/// <code>IntentMetadata</code> objects in the response, one for each
/// numbered version and one for the <code>$LATEST</code> version. </p>
/// <p>The <code>GetIntentVersions</code> operation always returns at
/// least one version, the <code>$LATEST</code> version.</p>
/// <p>This operation requires permissions for the
/// <code>lex:GetIntentVersions</code> action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetIntentVersions {
    _private: (),
}
impl GetIntentVersions {
    /// Creates a new builder-style object to manufacture [`GetIntentVersionsInput`](crate::input::GetIntentVersionsInput)
    pub fn builder() -> crate::input::get_intent_versions_input::Builder {
        crate::input::get_intent_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetIntentVersions {
    type Output = std::result::Result<
        crate::output::GetIntentVersionsOutput,
        crate::error::GetIntentVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_intent_versions_error(response)
        } else {
            crate::operation_deser::parse_get_intent_versions_response(response)
        }
    }
}

/// <p>Returns information about a specific version of a slot type. In
/// addition to specifying the slot type name, you must specify the slot type
/// version.</p>
/// <p>This operation requires permissions for the
/// <code>lex:GetSlotType</code> action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetSlotType {
    _private: (),
}
impl GetSlotType {
    /// Creates a new builder-style object to manufacture [`GetSlotTypeInput`](crate::input::GetSlotTypeInput)
    pub fn builder() -> crate::input::get_slot_type_input::Builder {
        crate::input::get_slot_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetSlotType {
    type Output =
        std::result::Result<crate::output::GetSlotTypeOutput, crate::error::GetSlotTypeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_slot_type_error(response)
        } else {
            crate::operation_deser::parse_get_slot_type_response(response)
        }
    }
}

/// <p>Returns slot type information as follows: </p>
/// <ul>
/// <li>
/// <p>If you specify the <code>nameContains</code> field, returns the
/// <code>$LATEST</code> version of all slot types that contain the
/// specified string.</p>
/// </li>
/// <li>
/// <p> If you don't specify the <code>nameContains</code> field,
/// returns information about the <code>$LATEST</code> version of all slot
/// types. </p>
/// </li>
/// </ul>
/// <p> The operation requires permission for the
/// <code>lex:GetSlotTypes</code> action. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetSlotTypes {
    _private: (),
}
impl GetSlotTypes {
    /// Creates a new builder-style object to manufacture [`GetSlotTypesInput`](crate::input::GetSlotTypesInput)
    pub fn builder() -> crate::input::get_slot_types_input::Builder {
        crate::input::get_slot_types_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetSlotTypes {
    type Output =
        std::result::Result<crate::output::GetSlotTypesOutput, crate::error::GetSlotTypesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_slot_types_error(response)
        } else {
            crate::operation_deser::parse_get_slot_types_response(response)
        }
    }
}

/// <p>Gets information about all versions of a slot type.</p>
/// <p>The <code>GetSlotTypeVersions</code> operation returns a
/// <code>SlotTypeMetadata</code> object for each version of a slot type.
/// For example, if a slot type has three numbered versions, the
/// <code>GetSlotTypeVersions</code> operation returns four
/// <code>SlotTypeMetadata</code> objects in the response, one for each
/// numbered version and one for the <code>$LATEST</code> version. </p>
/// <p>The <code>GetSlotTypeVersions</code> operation always returns at
/// least one version, the <code>$LATEST</code> version.</p>
/// <p>This operation requires permissions for the
/// <code>lex:GetSlotTypeVersions</code> action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetSlotTypeVersions {
    _private: (),
}
impl GetSlotTypeVersions {
    /// Creates a new builder-style object to manufacture [`GetSlotTypeVersionsInput`](crate::input::GetSlotTypeVersionsInput)
    pub fn builder() -> crate::input::get_slot_type_versions_input::Builder {
        crate::input::get_slot_type_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetSlotTypeVersions {
    type Output = std::result::Result<
        crate::output::GetSlotTypeVersionsOutput,
        crate::error::GetSlotTypeVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_slot_type_versions_error(response)
        } else {
            crate::operation_deser::parse_get_slot_type_versions_response(response)
        }
    }
}

/// <p>Use the <code>GetUtterancesView</code> operation to get information
/// about the utterances that your users have made to your bot. You can use
/// this list to tune the utterances that your bot responds to.</p>
/// <p>For example, say that you have created a bot to order flowers.
/// After your users have used your bot for a while, use the
/// <code>GetUtterancesView</code> operation to see the requests that they
/// have made and whether they have been successful. You might find that the
/// utterance "I want flowers" is not being recognized. You could add this
/// utterance to the <code>OrderFlowers</code> intent so that your bot
/// recognizes that utterance.</p>
/// <p>After you publish a new version of a bot, you can get information
/// about the old version and the new so that you can compare the performance
/// across the two versions. </p>
/// <p>Utterance statistics are generated once a day. Data is available
/// for the last 15 days. You can request information for up to 5 versions of
/// your bot in each request. Amazon Lex returns the most frequent utterances
/// received by the bot in the last 15 days. The response contains information
/// about a maximum of 100 utterances for each version.</p>
/// <p>If you set <code>childDirected</code> field to true when you
/// created your bot, or if you opted out of participating in improving Amazon Lex,
/// utterances are not available.</p>
/// <p>This operation requires permissions for the
/// <code>lex:GetUtterancesView</code> action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetUtterancesView {
    _private: (),
}
impl GetUtterancesView {
    /// Creates a new builder-style object to manufacture [`GetUtterancesViewInput`](crate::input::GetUtterancesViewInput)
    pub fn builder() -> crate::input::get_utterances_view_input::Builder {
        crate::input::get_utterances_view_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetUtterancesView {
    type Output = std::result::Result<
        crate::output::GetUtterancesViewOutput,
        crate::error::GetUtterancesViewError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_utterances_view_error(response)
        } else {
            crate::operation_deser::parse_get_utterances_view_response(response)
        }
    }
}

/// <p>Gets a list of tags associated with the specified resource. Only bots,
/// bot aliases, and bot channels can have tags associated with them.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Creates an Amazon Lex conversational bot or replaces an existing bot.
/// When you create or update a bot you are only required to specify a name, a
/// locale, and whether the bot is directed toward children under age 13. You
/// can use this to add intents later, or to remove intents from an existing
/// bot. When you create a bot with the minimum information, the bot is
/// created or updated but Amazon Lex returns the <code></code> response
/// <code>FAILED</code>. You can build the bot after you add one or more
/// intents. For more information about Amazon Lex bots, see <a>how-it-works</a>. </p>
/// <p>If you specify the name of an existing bot, the fields in the
/// request replace the existing values in the <code>$LATEST</code> version of
/// the bot. Amazon Lex removes any fields that you don't provide values for in the
/// request, except for the <code>idleTTLInSeconds</code> and
/// <code>privacySettings</code> fields, which are set to their default
/// values. If you don't specify values for required fields, Amazon Lex throws an
/// exception.</p>
/// <p>This operation requires permissions for the <code>lex:PutBot</code>
/// action. For more information, see <a>security-iam</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutBot {
    _private: (),
}
impl PutBot {
    /// Creates a new builder-style object to manufacture [`PutBotInput`](crate::input::PutBotInput)
    pub fn builder() -> crate::input::put_bot_input::Builder {
        crate::input::put_bot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutBot {
    type Output = std::result::Result<crate::output::PutBotOutput, crate::error::PutBotError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_bot_error(response)
        } else {
            crate::operation_deser::parse_put_bot_response(response)
        }
    }
}

/// <p>Creates an alias for the specified version of the bot or replaces
/// an alias for the specified bot. To change the version of the bot that the
/// alias points to, replace the alias. For more information about aliases,
/// see <a>versioning-aliases</a>.</p>
/// <p>This operation requires permissions for the
/// <code>lex:PutBotAlias</code> action. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutBotAlias {
    _private: (),
}
impl PutBotAlias {
    /// Creates a new builder-style object to manufacture [`PutBotAliasInput`](crate::input::PutBotAliasInput)
    pub fn builder() -> crate::input::put_bot_alias_input::Builder {
        crate::input::put_bot_alias_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutBotAlias {
    type Output =
        std::result::Result<crate::output::PutBotAliasOutput, crate::error::PutBotAliasError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_bot_alias_error(response)
        } else {
            crate::operation_deser::parse_put_bot_alias_response(response)
        }
    }
}

/// <p>Creates an intent or replaces an existing intent.</p>
/// <p>To define the interaction between the user and your bot, you use
/// one or more intents. For a pizza ordering bot, for example, you would
/// create an <code>OrderPizza</code> intent. </p>
/// <p>To create an intent or replace an existing intent, you must provide
/// the following:</p>
/// <ul>
/// <li>
/// <p>Intent name. For example, <code>OrderPizza</code>.</p>
/// </li>
/// <li>
/// <p>Sample utterances. For example, "Can I order a pizza, please."
/// and "I want to order a pizza."</p>
/// </li>
/// <li>
/// <p>Information to be gathered. You specify slot types for the
/// information that your bot will request from the user. You can specify
/// standard slot types, such as a date or a time, or custom slot types
/// such as the size and crust of a pizza.</p>
/// </li>
/// <li>
/// <p>How the intent will be fulfilled. You can provide a Lambda
/// function or configure the intent to return the intent information to
/// the client application. If you use a Lambda function, when all of the
/// intent information is available, Amazon Lex invokes your Lambda function.
/// If you configure your intent to return the intent information to the
/// client application. </p>
/// </li>
/// </ul>
/// <p>You can specify other optional information in the request, such
/// as:</p>
/// <ul>
/// <li>
/// <p>A confirmation prompt to ask the user to confirm an intent. For
/// example, "Shall I order your pizza?"</p>
/// </li>
/// <li>
/// <p>A conclusion statement to send to the user after the intent has
/// been fulfilled. For example, "I placed your pizza order."</p>
/// </li>
/// <li>
/// <p>A follow-up prompt that asks the user for additional activity.
/// For example, asking "Do you want to order a drink with your
/// pizza?"</p>
/// </li>
/// </ul>
/// <p>If you specify an existing intent name to update the intent, Amazon Lex
/// replaces the values in the <code>$LATEST</code> version of the intent with
/// the values in the request. Amazon Lex removes fields that you don't provide in
/// the request. If you don't specify the required fields, Amazon Lex throws an
/// exception. When you update the <code>$LATEST</code> version of an intent,
/// the <code>status</code> field of any bot that uses the
/// <code>$LATEST</code> version of the intent is set to
/// <code>NOT_BUILT</code>.</p>
/// <p>For more information, see <a>how-it-works</a>.</p>
/// <p>This operation requires permissions for the
/// <code>lex:PutIntent</code> action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutIntent {
    _private: (),
}
impl PutIntent {
    /// Creates a new builder-style object to manufacture [`PutIntentInput`](crate::input::PutIntentInput)
    pub fn builder() -> crate::input::put_intent_input::Builder {
        crate::input::put_intent_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutIntent {
    type Output = std::result::Result<crate::output::PutIntentOutput, crate::error::PutIntentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_intent_error(response)
        } else {
            crate::operation_deser::parse_put_intent_response(response)
        }
    }
}

/// <p>Creates a custom slot type or replaces an existing custom slot
/// type.</p>
/// <p>To create a custom slot type, specify a name for the slot type and
/// a set of enumeration values, which are the values that a slot of this type
/// can assume. For more information, see <a>how-it-works</a>.</p>
/// <p>If you specify the name of an existing slot type, the fields in the
/// request replace the existing values in the <code>$LATEST</code> version of
/// the slot type. Amazon Lex removes the fields that you don't provide in the
/// request. If you don't specify required fields, Amazon Lex throws an exception.
/// When you update the <code>$LATEST</code> version of a slot type, if a bot
/// uses the <code>$LATEST</code> version of an intent that contains the slot
/// type, the bot's <code>status</code> field is set to
/// <code>NOT_BUILT</code>.</p>
/// <p>This operation requires permissions for the
/// <code>lex:PutSlotType</code> action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutSlotType {
    _private: (),
}
impl PutSlotType {
    /// Creates a new builder-style object to manufacture [`PutSlotTypeInput`](crate::input::PutSlotTypeInput)
    pub fn builder() -> crate::input::put_slot_type_input::Builder {
        crate::input::put_slot_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutSlotType {
    type Output =
        std::result::Result<crate::output::PutSlotTypeOutput, crate::error::PutSlotTypeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_slot_type_error(response)
        } else {
            crate::operation_deser::parse_put_slot_type_response(response)
        }
    }
}

/// <p>Starts a job to import a resource to Amazon Lex.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartImport {
    _private: (),
}
impl StartImport {
    /// Creates a new builder-style object to manufacture [`StartImportInput`](crate::input::StartImportInput)
    pub fn builder() -> crate::input::start_import_input::Builder {
        crate::input::start_import_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartImport {
    type Output =
        std::result::Result<crate::output::StartImportOutput, crate::error::StartImportError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_start_import_error(response)
        } else {
            crate::operation_deser::parse_start_import_response(response)
        }
    }
}

/// <p>Adds the specified tags to the specified resource. If a tag key
/// already exists, the existing value is replaced with the new value.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Removes tags from a bot, bot alias or bot channel.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}
