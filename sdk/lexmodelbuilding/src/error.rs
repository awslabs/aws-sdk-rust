// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateBotVersionError {
    pub kind: CreateBotVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateBotVersionErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateBotVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateBotVersionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateBotVersionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateBotVersionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateBotVersionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateBotVersionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateBotVersionErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            CreateBotVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateBotVersionError {
    fn code(&self) -> Option<&str> {
        CreateBotVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateBotVersionError {
    pub fn new(kind: CreateBotVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateBotVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateBotVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBotVersionErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateBotVersionErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBotVersionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBotVersionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateBotVersionErrorKind::NotFoundException(_))
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBotVersionErrorKind::PreconditionFailedException(_)
        )
    }
}
impl std::error::Error for CreateBotVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateBotVersionErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateBotVersionErrorKind::ConflictException(_inner) => Some(_inner),
            CreateBotVersionErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateBotVersionErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateBotVersionErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateBotVersionErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            CreateBotVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateIntentVersionError {
    pub kind: CreateIntentVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateIntentVersionErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateIntentVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateIntentVersionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateIntentVersionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateIntentVersionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateIntentVersionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateIntentVersionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateIntentVersionErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            CreateIntentVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateIntentVersionError {
    fn code(&self) -> Option<&str> {
        CreateIntentVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateIntentVersionError {
    pub fn new(kind: CreateIntentVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateIntentVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateIntentVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIntentVersionErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIntentVersionErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIntentVersionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIntentVersionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIntentVersionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIntentVersionErrorKind::PreconditionFailedException(_)
        )
    }
}
impl std::error::Error for CreateIntentVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateIntentVersionErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateIntentVersionErrorKind::ConflictException(_inner) => Some(_inner),
            CreateIntentVersionErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateIntentVersionErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateIntentVersionErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateIntentVersionErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            CreateIntentVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSlotTypeVersionError {
    pub kind: CreateSlotTypeVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSlotTypeVersionErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateSlotTypeVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSlotTypeVersionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateSlotTypeVersionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateSlotTypeVersionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateSlotTypeVersionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateSlotTypeVersionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateSlotTypeVersionErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            CreateSlotTypeVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateSlotTypeVersionError {
    fn code(&self) -> Option<&str> {
        CreateSlotTypeVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSlotTypeVersionError {
    pub fn new(kind: CreateSlotTypeVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSlotTypeVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSlotTypeVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSlotTypeVersionErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSlotTypeVersionErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSlotTypeVersionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSlotTypeVersionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSlotTypeVersionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSlotTypeVersionErrorKind::PreconditionFailedException(_)
        )
    }
}
impl std::error::Error for CreateSlotTypeVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSlotTypeVersionErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateSlotTypeVersionErrorKind::ConflictException(_inner) => Some(_inner),
            CreateSlotTypeVersionErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateSlotTypeVersionErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateSlotTypeVersionErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateSlotTypeVersionErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            CreateSlotTypeVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBotError {
    pub kind: DeleteBotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBotErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ResourceInUseException(crate::error::ResourceInUseException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBotErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteBotErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteBotErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteBotErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteBotErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteBotErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteBotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteBotError {
    fn code(&self) -> Option<&str> {
        DeleteBotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBotError {
    pub fn new(kind: DeleteBotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteBotErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteBotErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(&self.kind, DeleteBotErrorKind::InternalFailureException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, DeleteBotErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteBotErrorKind::NotFoundException(_))
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(&self.kind, DeleteBotErrorKind::ResourceInUseException(_))
    }
}
impl std::error::Error for DeleteBotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBotErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteBotErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteBotErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteBotErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteBotErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteBotErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteBotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBotAliasError {
    pub kind: DeleteBotAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBotAliasErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ResourceInUseException(crate::error::ResourceInUseException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBotAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBotAliasErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteBotAliasErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteBotAliasErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteBotAliasErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteBotAliasErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteBotAliasErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteBotAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteBotAliasError {
    fn code(&self) -> Option<&str> {
        DeleteBotAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBotAliasError {
    pub fn new(kind: DeleteBotAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBotAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBotAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteBotAliasErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteBotAliasErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBotAliasErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBotAliasErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteBotAliasErrorKind::NotFoundException(_))
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBotAliasErrorKind::ResourceInUseException(_)
        )
    }
}
impl std::error::Error for DeleteBotAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBotAliasErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteBotAliasErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteBotAliasErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteBotAliasErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteBotAliasErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteBotAliasErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteBotAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBotChannelAssociationError {
    pub kind: DeleteBotChannelAssociationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBotChannelAssociationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBotChannelAssociationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBotChannelAssociationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteBotChannelAssociationErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteBotChannelAssociationErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteBotChannelAssociationErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteBotChannelAssociationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteBotChannelAssociationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteBotChannelAssociationError {
    fn code(&self) -> Option<&str> {
        DeleteBotChannelAssociationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBotChannelAssociationError {
    pub fn new(kind: DeleteBotChannelAssociationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBotChannelAssociationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBotChannelAssociationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBotChannelAssociationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBotChannelAssociationErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBotChannelAssociationErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBotChannelAssociationErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBotChannelAssociationErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteBotChannelAssociationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBotChannelAssociationErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteBotChannelAssociationErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteBotChannelAssociationErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteBotChannelAssociationErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteBotChannelAssociationErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteBotChannelAssociationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBotVersionError {
    pub kind: DeleteBotVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBotVersionErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ResourceInUseException(crate::error::ResourceInUseException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBotVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBotVersionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteBotVersionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteBotVersionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteBotVersionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteBotVersionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteBotVersionErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteBotVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteBotVersionError {
    fn code(&self) -> Option<&str> {
        DeleteBotVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBotVersionError {
    pub fn new(kind: DeleteBotVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBotVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBotVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBotVersionErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteBotVersionErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBotVersionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBotVersionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteBotVersionErrorKind::NotFoundException(_))
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBotVersionErrorKind::ResourceInUseException(_)
        )
    }
}
impl std::error::Error for DeleteBotVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBotVersionErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteBotVersionErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteBotVersionErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteBotVersionErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteBotVersionErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteBotVersionErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteBotVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteIntentError {
    pub kind: DeleteIntentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteIntentErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ResourceInUseException(crate::error::ResourceInUseException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteIntentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteIntentErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteIntentErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteIntentErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteIntentErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteIntentErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteIntentErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteIntentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteIntentError {
    fn code(&self) -> Option<&str> {
        DeleteIntentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteIntentError {
    pub fn new(kind: DeleteIntentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteIntentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteIntentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteIntentErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteIntentErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIntentErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, DeleteIntentErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteIntentErrorKind::NotFoundException(_))
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(&self.kind, DeleteIntentErrorKind::ResourceInUseException(_))
    }
}
impl std::error::Error for DeleteIntentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteIntentErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteIntentErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteIntentErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteIntentErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteIntentErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteIntentErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteIntentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteIntentVersionError {
    pub kind: DeleteIntentVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteIntentVersionErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ResourceInUseException(crate::error::ResourceInUseException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteIntentVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteIntentVersionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteIntentVersionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteIntentVersionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteIntentVersionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteIntentVersionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteIntentVersionErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteIntentVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteIntentVersionError {
    fn code(&self) -> Option<&str> {
        DeleteIntentVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteIntentVersionError {
    pub fn new(kind: DeleteIntentVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteIntentVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteIntentVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIntentVersionErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIntentVersionErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIntentVersionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIntentVersionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIntentVersionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIntentVersionErrorKind::ResourceInUseException(_)
        )
    }
}
impl std::error::Error for DeleteIntentVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteIntentVersionErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteIntentVersionErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteIntentVersionErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteIntentVersionErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteIntentVersionErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteIntentVersionErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteIntentVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSlotTypeError {
    pub kind: DeleteSlotTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSlotTypeErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ResourceInUseException(crate::error::ResourceInUseException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSlotTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSlotTypeErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteSlotTypeErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteSlotTypeErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteSlotTypeErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteSlotTypeErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteSlotTypeErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteSlotTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSlotTypeError {
    fn code(&self) -> Option<&str> {
        DeleteSlotTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSlotTypeError {
    pub fn new(kind: DeleteSlotTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSlotTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSlotTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteSlotTypeErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteSlotTypeErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSlotTypeErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSlotTypeErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteSlotTypeErrorKind::NotFoundException(_))
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSlotTypeErrorKind::ResourceInUseException(_)
        )
    }
}
impl std::error::Error for DeleteSlotTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSlotTypeErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteSlotTypeErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteSlotTypeErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteSlotTypeErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteSlotTypeErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteSlotTypeErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteSlotTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSlotTypeVersionError {
    pub kind: DeleteSlotTypeVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSlotTypeVersionErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ResourceInUseException(crate::error::ResourceInUseException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSlotTypeVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSlotTypeVersionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteSlotTypeVersionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteSlotTypeVersionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteSlotTypeVersionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteSlotTypeVersionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteSlotTypeVersionErrorKind::ResourceInUseException(_inner) => _inner.fmt(f),
            DeleteSlotTypeVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSlotTypeVersionError {
    fn code(&self) -> Option<&str> {
        DeleteSlotTypeVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSlotTypeVersionError {
    pub fn new(kind: DeleteSlotTypeVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSlotTypeVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSlotTypeVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSlotTypeVersionErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSlotTypeVersionErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSlotTypeVersionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSlotTypeVersionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSlotTypeVersionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_resource_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSlotTypeVersionErrorKind::ResourceInUseException(_)
        )
    }
}
impl std::error::Error for DeleteSlotTypeVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSlotTypeVersionErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteSlotTypeVersionErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteSlotTypeVersionErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteSlotTypeVersionErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteSlotTypeVersionErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteSlotTypeVersionErrorKind::ResourceInUseException(_inner) => Some(_inner),
            DeleteSlotTypeVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUtterancesError {
    pub kind: DeleteUtterancesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUtterancesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUtterancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUtterancesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteUtterancesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteUtterancesErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteUtterancesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteUtterancesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUtterancesError {
    fn code(&self) -> Option<&str> {
        DeleteUtterancesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUtterancesError {
    pub fn new(kind: DeleteUtterancesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUtterancesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUtterancesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUtterancesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUtterancesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUtterancesErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteUtterancesErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for DeleteUtterancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUtterancesErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteUtterancesErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteUtterancesErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteUtterancesErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteUtterancesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBotError {
    pub kind: GetBotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBotErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBotErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetBotErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetBotErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetBotErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetBotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBotError {
    fn code(&self) -> Option<&str> {
        GetBotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBotError {
    pub fn new(kind: GetBotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetBotErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(&self.kind, GetBotErrorKind::InternalFailureException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetBotErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetBotErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for GetBotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBotErrorKind::BadRequestException(_inner) => Some(_inner),
            GetBotErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetBotErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetBotErrorKind::NotFoundException(_inner) => Some(_inner),
            GetBotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBotAliasError {
    pub kind: GetBotAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBotAliasErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBotAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBotAliasErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetBotAliasErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetBotAliasErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetBotAliasErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetBotAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBotAliasError {
    fn code(&self) -> Option<&str> {
        GetBotAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBotAliasError {
    pub fn new(kind: GetBotAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBotAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBotAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetBotAliasErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBotAliasErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetBotAliasErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetBotAliasErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for GetBotAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBotAliasErrorKind::BadRequestException(_inner) => Some(_inner),
            GetBotAliasErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetBotAliasErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetBotAliasErrorKind::NotFoundException(_inner) => Some(_inner),
            GetBotAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBotAliasesError {
    pub kind: GetBotAliasesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBotAliasesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBotAliasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBotAliasesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetBotAliasesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetBotAliasesErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetBotAliasesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBotAliasesError {
    fn code(&self) -> Option<&str> {
        GetBotAliasesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBotAliasesError {
    pub fn new(kind: GetBotAliasesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBotAliasesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBotAliasesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetBotAliasesErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBotAliasesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBotAliasesErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for GetBotAliasesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBotAliasesErrorKind::BadRequestException(_inner) => Some(_inner),
            GetBotAliasesErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetBotAliasesErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetBotAliasesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBotChannelAssociationError {
    pub kind: GetBotChannelAssociationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBotChannelAssociationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBotChannelAssociationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBotChannelAssociationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetBotChannelAssociationErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetBotChannelAssociationErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetBotChannelAssociationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetBotChannelAssociationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBotChannelAssociationError {
    fn code(&self) -> Option<&str> {
        GetBotChannelAssociationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBotChannelAssociationError {
    pub fn new(kind: GetBotChannelAssociationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBotChannelAssociationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBotChannelAssociationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBotChannelAssociationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBotChannelAssociationErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBotChannelAssociationErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBotChannelAssociationErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for GetBotChannelAssociationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBotChannelAssociationErrorKind::BadRequestException(_inner) => Some(_inner),
            GetBotChannelAssociationErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetBotChannelAssociationErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetBotChannelAssociationErrorKind::NotFoundException(_inner) => Some(_inner),
            GetBotChannelAssociationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBotChannelAssociationsError {
    pub kind: GetBotChannelAssociationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBotChannelAssociationsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBotChannelAssociationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBotChannelAssociationsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetBotChannelAssociationsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetBotChannelAssociationsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetBotChannelAssociationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBotChannelAssociationsError {
    fn code(&self) -> Option<&str> {
        GetBotChannelAssociationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBotChannelAssociationsError {
    pub fn new(kind: GetBotChannelAssociationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBotChannelAssociationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBotChannelAssociationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBotChannelAssociationsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBotChannelAssociationsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBotChannelAssociationsErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for GetBotChannelAssociationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBotChannelAssociationsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetBotChannelAssociationsErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetBotChannelAssociationsErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetBotChannelAssociationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBotsError {
    pub kind: GetBotsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBotsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBotsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBotsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetBotsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetBotsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetBotsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetBotsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBotsError {
    fn code(&self) -> Option<&str> {
        GetBotsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBotsError {
    pub fn new(kind: GetBotsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBotsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBotsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetBotsErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(&self.kind, GetBotsErrorKind::InternalFailureException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetBotsErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetBotsErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for GetBotsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBotsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetBotsErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetBotsErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetBotsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetBotsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBotVersionsError {
    pub kind: GetBotVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBotVersionsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBotVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBotVersionsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetBotVersionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetBotVersionsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetBotVersionsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetBotVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBotVersionsError {
    fn code(&self) -> Option<&str> {
        GetBotVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBotVersionsError {
    pub fn new(kind: GetBotVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBotVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBotVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetBotVersionsErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBotVersionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBotVersionsErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetBotVersionsErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for GetBotVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBotVersionsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetBotVersionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetBotVersionsErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetBotVersionsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetBotVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBuiltinIntentError {
    pub kind: GetBuiltinIntentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBuiltinIntentErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBuiltinIntentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBuiltinIntentErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetBuiltinIntentErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetBuiltinIntentErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetBuiltinIntentErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetBuiltinIntentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBuiltinIntentError {
    fn code(&self) -> Option<&str> {
        GetBuiltinIntentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBuiltinIntentError {
    pub fn new(kind: GetBuiltinIntentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBuiltinIntentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBuiltinIntentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBuiltinIntentErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBuiltinIntentErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBuiltinIntentErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetBuiltinIntentErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for GetBuiltinIntentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBuiltinIntentErrorKind::BadRequestException(_inner) => Some(_inner),
            GetBuiltinIntentErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetBuiltinIntentErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetBuiltinIntentErrorKind::NotFoundException(_inner) => Some(_inner),
            GetBuiltinIntentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBuiltinIntentsError {
    pub kind: GetBuiltinIntentsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBuiltinIntentsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBuiltinIntentsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBuiltinIntentsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetBuiltinIntentsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetBuiltinIntentsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetBuiltinIntentsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBuiltinIntentsError {
    fn code(&self) -> Option<&str> {
        GetBuiltinIntentsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBuiltinIntentsError {
    pub fn new(kind: GetBuiltinIntentsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBuiltinIntentsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBuiltinIntentsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBuiltinIntentsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBuiltinIntentsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBuiltinIntentsErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for GetBuiltinIntentsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBuiltinIntentsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetBuiltinIntentsErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetBuiltinIntentsErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetBuiltinIntentsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBuiltinSlotTypesError {
    pub kind: GetBuiltinSlotTypesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBuiltinSlotTypesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBuiltinSlotTypesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBuiltinSlotTypesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetBuiltinSlotTypesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetBuiltinSlotTypesErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetBuiltinSlotTypesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBuiltinSlotTypesError {
    fn code(&self) -> Option<&str> {
        GetBuiltinSlotTypesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBuiltinSlotTypesError {
    pub fn new(kind: GetBuiltinSlotTypesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBuiltinSlotTypesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBuiltinSlotTypesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBuiltinSlotTypesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBuiltinSlotTypesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBuiltinSlotTypesErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for GetBuiltinSlotTypesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBuiltinSlotTypesErrorKind::BadRequestException(_inner) => Some(_inner),
            GetBuiltinSlotTypesErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetBuiltinSlotTypesErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetBuiltinSlotTypesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetExportError {
    pub kind: GetExportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetExportErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetExportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetExportErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetExportErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetExportErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetExportErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetExportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetExportError {
    fn code(&self) -> Option<&str> {
        GetExportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetExportError {
    pub fn new(kind: GetExportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetExportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetExportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetExportErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(&self.kind, GetExportErrorKind::InternalFailureException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetExportErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetExportErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for GetExportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetExportErrorKind::BadRequestException(_inner) => Some(_inner),
            GetExportErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetExportErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetExportErrorKind::NotFoundException(_inner) => Some(_inner),
            GetExportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetImportError {
    pub kind: GetImportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetImportErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetImportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetImportErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetImportErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetImportErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetImportErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetImportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetImportError {
    fn code(&self) -> Option<&str> {
        GetImportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetImportError {
    pub fn new(kind: GetImportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetImportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetImportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetImportErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(&self.kind, GetImportErrorKind::InternalFailureException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetImportErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetImportErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for GetImportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetImportErrorKind::BadRequestException(_inner) => Some(_inner),
            GetImportErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetImportErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetImportErrorKind::NotFoundException(_inner) => Some(_inner),
            GetImportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetIntentError {
    pub kind: GetIntentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetIntentErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetIntentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetIntentErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetIntentErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetIntentErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetIntentErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetIntentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetIntentError {
    fn code(&self) -> Option<&str> {
        GetIntentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetIntentError {
    pub fn new(kind: GetIntentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetIntentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetIntentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetIntentErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(&self.kind, GetIntentErrorKind::InternalFailureException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetIntentErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetIntentErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for GetIntentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetIntentErrorKind::BadRequestException(_inner) => Some(_inner),
            GetIntentErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetIntentErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetIntentErrorKind::NotFoundException(_inner) => Some(_inner),
            GetIntentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetIntentsError {
    pub kind: GetIntentsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetIntentsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetIntentsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetIntentsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetIntentsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetIntentsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetIntentsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetIntentsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetIntentsError {
    fn code(&self) -> Option<&str> {
        GetIntentsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetIntentsError {
    pub fn new(kind: GetIntentsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetIntentsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetIntentsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetIntentsErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(&self.kind, GetIntentsErrorKind::InternalFailureException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetIntentsErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetIntentsErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for GetIntentsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetIntentsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetIntentsErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetIntentsErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetIntentsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetIntentsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetIntentVersionsError {
    pub kind: GetIntentVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetIntentVersionsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetIntentVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetIntentVersionsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetIntentVersionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetIntentVersionsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetIntentVersionsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetIntentVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetIntentVersionsError {
    fn code(&self) -> Option<&str> {
        GetIntentVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetIntentVersionsError {
    pub fn new(kind: GetIntentVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetIntentVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetIntentVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIntentVersionsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIntentVersionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIntentVersionsErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetIntentVersionsErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for GetIntentVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetIntentVersionsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetIntentVersionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetIntentVersionsErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetIntentVersionsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetIntentVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMigrationError {
    pub kind: GetMigrationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMigrationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMigrationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMigrationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetMigrationErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetMigrationErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetMigrationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetMigrationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMigrationError {
    fn code(&self) -> Option<&str> {
        GetMigrationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMigrationError {
    pub fn new(kind: GetMigrationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMigrationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMigrationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetMigrationErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMigrationErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetMigrationErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetMigrationErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for GetMigrationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMigrationErrorKind::BadRequestException(_inner) => Some(_inner),
            GetMigrationErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetMigrationErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetMigrationErrorKind::NotFoundException(_inner) => Some(_inner),
            GetMigrationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMigrationsError {
    pub kind: GetMigrationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMigrationsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMigrationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMigrationsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetMigrationsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetMigrationsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetMigrationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMigrationsError {
    fn code(&self) -> Option<&str> {
        GetMigrationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMigrationsError {
    pub fn new(kind: GetMigrationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMigrationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMigrationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetMigrationsErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMigrationsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMigrationsErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for GetMigrationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMigrationsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetMigrationsErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetMigrationsErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetMigrationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSlotTypeError {
    pub kind: GetSlotTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSlotTypeErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSlotTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSlotTypeErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetSlotTypeErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetSlotTypeErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetSlotTypeErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetSlotTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSlotTypeError {
    fn code(&self) -> Option<&str> {
        GetSlotTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSlotTypeError {
    pub fn new(kind: GetSlotTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSlotTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSlotTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetSlotTypeErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSlotTypeErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetSlotTypeErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetSlotTypeErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for GetSlotTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSlotTypeErrorKind::BadRequestException(_inner) => Some(_inner),
            GetSlotTypeErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetSlotTypeErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetSlotTypeErrorKind::NotFoundException(_inner) => Some(_inner),
            GetSlotTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSlotTypesError {
    pub kind: GetSlotTypesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSlotTypesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSlotTypesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSlotTypesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetSlotTypesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetSlotTypesErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetSlotTypesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetSlotTypesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSlotTypesError {
    fn code(&self) -> Option<&str> {
        GetSlotTypesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSlotTypesError {
    pub fn new(kind: GetSlotTypesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSlotTypesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSlotTypesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetSlotTypesErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSlotTypesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetSlotTypesErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetSlotTypesErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for GetSlotTypesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSlotTypesErrorKind::BadRequestException(_inner) => Some(_inner),
            GetSlotTypesErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetSlotTypesErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetSlotTypesErrorKind::NotFoundException(_inner) => Some(_inner),
            GetSlotTypesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSlotTypeVersionsError {
    pub kind: GetSlotTypeVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSlotTypeVersionsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSlotTypeVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSlotTypeVersionsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetSlotTypeVersionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetSlotTypeVersionsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetSlotTypeVersionsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetSlotTypeVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSlotTypeVersionsError {
    fn code(&self) -> Option<&str> {
        GetSlotTypeVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSlotTypeVersionsError {
    pub fn new(kind: GetSlotTypeVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSlotTypeVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSlotTypeVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSlotTypeVersionsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSlotTypeVersionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSlotTypeVersionsErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSlotTypeVersionsErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for GetSlotTypeVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSlotTypeVersionsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetSlotTypeVersionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetSlotTypeVersionsErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetSlotTypeVersionsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetSlotTypeVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetUtterancesViewError {
    pub kind: GetUtterancesViewErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUtterancesViewErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetUtterancesViewError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetUtterancesViewErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetUtterancesViewErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetUtterancesViewErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetUtterancesViewErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetUtterancesViewError {
    fn code(&self) -> Option<&str> {
        GetUtterancesViewError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetUtterancesViewError {
    pub fn new(kind: GetUtterancesViewErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetUtterancesViewErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetUtterancesViewErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUtterancesViewErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUtterancesViewErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUtterancesViewErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for GetUtterancesViewError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetUtterancesViewErrorKind::BadRequestException(_inner) => Some(_inner),
            GetUtterancesViewErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetUtterancesViewErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetUtterancesViewErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutBotError {
    pub kind: PutBotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutBotErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutBotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutBotErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutBotErrorKind::ConflictException(_inner) => _inner.fmt(f),
            PutBotErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            PutBotErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            PutBotErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            PutBotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutBotError {
    fn code(&self) -> Option<&str> {
        PutBotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutBotError {
    pub fn new(kind: PutBotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutBotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutBotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, PutBotErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, PutBotErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(&self.kind, PutBotErrorKind::InternalFailureException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, PutBotErrorKind::LimitExceededException(_))
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(&self.kind, PutBotErrorKind::PreconditionFailedException(_))
    }
}
impl std::error::Error for PutBotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutBotErrorKind::BadRequestException(_inner) => Some(_inner),
            PutBotErrorKind::ConflictException(_inner) => Some(_inner),
            PutBotErrorKind::InternalFailureException(_inner) => Some(_inner),
            PutBotErrorKind::LimitExceededException(_inner) => Some(_inner),
            PutBotErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            PutBotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutBotAliasError {
    pub kind: PutBotAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutBotAliasErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutBotAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutBotAliasErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutBotAliasErrorKind::ConflictException(_inner) => _inner.fmt(f),
            PutBotAliasErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            PutBotAliasErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            PutBotAliasErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            PutBotAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutBotAliasError {
    fn code(&self) -> Option<&str> {
        PutBotAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutBotAliasError {
    pub fn new(kind: PutBotAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutBotAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutBotAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, PutBotAliasErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, PutBotAliasErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutBotAliasErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, PutBotAliasErrorKind::LimitExceededException(_))
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutBotAliasErrorKind::PreconditionFailedException(_)
        )
    }
}
impl std::error::Error for PutBotAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutBotAliasErrorKind::BadRequestException(_inner) => Some(_inner),
            PutBotAliasErrorKind::ConflictException(_inner) => Some(_inner),
            PutBotAliasErrorKind::InternalFailureException(_inner) => Some(_inner),
            PutBotAliasErrorKind::LimitExceededException(_inner) => Some(_inner),
            PutBotAliasErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            PutBotAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutIntentError {
    pub kind: PutIntentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutIntentErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutIntentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutIntentErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutIntentErrorKind::ConflictException(_inner) => _inner.fmt(f),
            PutIntentErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            PutIntentErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            PutIntentErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            PutIntentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutIntentError {
    fn code(&self) -> Option<&str> {
        PutIntentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutIntentError {
    pub fn new(kind: PutIntentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutIntentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutIntentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, PutIntentErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, PutIntentErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(&self.kind, PutIntentErrorKind::InternalFailureException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, PutIntentErrorKind::LimitExceededException(_))
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutIntentErrorKind::PreconditionFailedException(_)
        )
    }
}
impl std::error::Error for PutIntentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutIntentErrorKind::BadRequestException(_inner) => Some(_inner),
            PutIntentErrorKind::ConflictException(_inner) => Some(_inner),
            PutIntentErrorKind::InternalFailureException(_inner) => Some(_inner),
            PutIntentErrorKind::LimitExceededException(_inner) => Some(_inner),
            PutIntentErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            PutIntentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutSlotTypeError {
    pub kind: PutSlotTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutSlotTypeErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    PreconditionFailedException(crate::error::PreconditionFailedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutSlotTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutSlotTypeErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutSlotTypeErrorKind::ConflictException(_inner) => _inner.fmt(f),
            PutSlotTypeErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            PutSlotTypeErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            PutSlotTypeErrorKind::PreconditionFailedException(_inner) => _inner.fmt(f),
            PutSlotTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutSlotTypeError {
    fn code(&self) -> Option<&str> {
        PutSlotTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutSlotTypeError {
    pub fn new(kind: PutSlotTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutSlotTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutSlotTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, PutSlotTypeErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, PutSlotTypeErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSlotTypeErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, PutSlotTypeErrorKind::LimitExceededException(_))
    }
    pub fn is_precondition_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSlotTypeErrorKind::PreconditionFailedException(_)
        )
    }
}
impl std::error::Error for PutSlotTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutSlotTypeErrorKind::BadRequestException(_inner) => Some(_inner),
            PutSlotTypeErrorKind::ConflictException(_inner) => Some(_inner),
            PutSlotTypeErrorKind::InternalFailureException(_inner) => Some(_inner),
            PutSlotTypeErrorKind::LimitExceededException(_inner) => Some(_inner),
            PutSlotTypeErrorKind::PreconditionFailedException(_inner) => Some(_inner),
            PutSlotTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartImportError {
    pub kind: StartImportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartImportErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartImportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartImportErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            StartImportErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            StartImportErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartImportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartImportError {
    fn code(&self) -> Option<&str> {
        StartImportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartImportError {
    pub fn new(kind: StartImportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartImportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartImportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, StartImportErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartImportErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, StartImportErrorKind::LimitExceededException(_))
    }
}
impl std::error::Error for StartImportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartImportErrorKind::BadRequestException(_inner) => Some(_inner),
            StartImportErrorKind::InternalFailureException(_inner) => Some(_inner),
            StartImportErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartImportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartMigrationError {
    pub kind: StartMigrationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartMigrationErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartMigrationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartMigrationErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartMigrationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            StartMigrationErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            StartMigrationErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartMigrationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            StartMigrationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartMigrationError {
    fn code(&self) -> Option<&str> {
        StartMigrationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartMigrationError {
    pub fn new(kind: StartMigrationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartMigrationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartMigrationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMigrationErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, StartMigrationErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMigrationErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMigrationErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, StartMigrationErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for StartMigrationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartMigrationErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartMigrationErrorKind::BadRequestException(_inner) => Some(_inner),
            StartMigrationErrorKind::InternalFailureException(_inner) => Some(_inner),
            StartMigrationErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartMigrationErrorKind::NotFoundException(_inner) => Some(_inner),
            StartMigrationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            TagResourceErrorKind::ConflictException(_inner) => Some(_inner),
            TagResourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            TagResourceErrorKind::LimitExceededException(_inner) => Some(_inner),
            TagResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            UntagResourceErrorKind::ConflictException(_inner) => Some(_inner),
            UntagResourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            UntagResourceErrorKind::LimitExceededException(_inner) => Some(_inner),
            UntagResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The resource specified in the request was not found. Check the
/// resource and try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotFoundException {}
/// See [`NotFoundException`](crate::error::NotFoundException)
pub mod not_found_exception {
    /// A builder for [`NotFoundException`](crate::error::NotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotFoundException`](crate::error::NotFoundException)
        pub fn build(self) -> crate::error::NotFoundException {
            crate::error::NotFoundException {
                message: self.message,
            }
        }
    }
}
impl NotFoundException {
    /// Creates a new builder-style object to manufacture [`NotFoundException`](crate::error::NotFoundException)
    pub fn builder() -> crate::error::not_found_exception::Builder {
        crate::error::not_found_exception::Builder::default()
    }
}

/// <p>The request exceeded a limit. Try your request again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    pub retry_after_seconds: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("retry_after_seconds", &self.retry_after_seconds);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) retry_after_seconds: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn retry_after_seconds(mut self, input: impl Into<std::string::String>) -> Self {
            self.retry_after_seconds = Some(input.into());
            self
        }
        pub fn set_retry_after_seconds(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.retry_after_seconds = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                retry_after_seconds: self.retry_after_seconds,
                message: self.message,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>An internal Amazon Lex error occurred. Try your request again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalFailureException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalFailureException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalFailureException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalFailureException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalFailureException {}
/// See [`InternalFailureException`](crate::error::InternalFailureException)
pub mod internal_failure_exception {
    /// A builder for [`InternalFailureException`](crate::error::InternalFailureException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalFailureException`](crate::error::InternalFailureException)
        pub fn build(self) -> crate::error::InternalFailureException {
            crate::error::InternalFailureException {
                message: self.message,
            }
        }
    }
}
impl InternalFailureException {
    /// Creates a new builder-style object to manufacture [`InternalFailureException`](crate::error::InternalFailureException)
    pub fn builder() -> crate::error::internal_failure_exception::Builder {
        crate::error::internal_failure_exception::Builder::default()
    }
}

/// <p> There was a conflict processing the request. Try your request
/// again. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// <p>The request is not well formed. For example, a value is invalid or
/// a required field is missing. Check the field values, and try
/// again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BadRequestException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BadRequestException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BadRequestException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BadRequestException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for BadRequestException {}
/// See [`BadRequestException`](crate::error::BadRequestException)
pub mod bad_request_exception {
    /// A builder for [`BadRequestException`](crate::error::BadRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BadRequestException`](crate::error::BadRequestException)
        pub fn build(self) -> crate::error::BadRequestException {
            crate::error::BadRequestException {
                message: self.message,
            }
        }
    }
}
impl BadRequestException {
    /// Creates a new builder-style object to manufacture [`BadRequestException`](crate::error::BadRequestException)
    pub fn builder() -> crate::error::bad_request_exception::Builder {
        crate::error::bad_request_exception::Builder::default()
    }
}

/// <p>Your IAM user or role does not have permission to call the Amazon Lex V2 APIs
/// required to migrate your bot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccessDeniedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccessDeniedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AccessDeniedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException)
pub mod access_denied_exception {
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException)
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message,
            }
        }
    }
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException)
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}

/// <p> The checksum of the resource that you are trying to change does
/// not match the checksum in the request. Check the resource's checksum and
/// try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PreconditionFailedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PreconditionFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PreconditionFailedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PreconditionFailedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PreconditionFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PreconditionFailedException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for PreconditionFailedException {}
/// See [`PreconditionFailedException`](crate::error::PreconditionFailedException)
pub mod precondition_failed_exception {
    /// A builder for [`PreconditionFailedException`](crate::error::PreconditionFailedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PreconditionFailedException`](crate::error::PreconditionFailedException)
        pub fn build(self) -> crate::error::PreconditionFailedException {
            crate::error::PreconditionFailedException {
                message: self.message,
            }
        }
    }
}
impl PreconditionFailedException {
    /// Creates a new builder-style object to manufacture [`PreconditionFailedException`](crate::error::PreconditionFailedException)
    pub fn builder() -> crate::error::precondition_failed_exception::Builder {
        crate::error::precondition_failed_exception::Builder::default()
    }
}

/// <p>The resource that you are attempting to delete is referred to by
/// another resource. Use this information to remove references to the
/// resource that you are trying to delete.</p>
/// <p>The body of the exception contains a JSON object that describes the
/// resource.</p>
/// <p>
/// <code>{ "resourceType": BOT | BOTALIAS | BOTCHANNEL |
/// INTENT,</code>
/// </p>
/// <p>
/// <code>"resourceReference": {</code>
/// </p>
/// <p>
/// <code>"name": <i>string</i>, "version":
/// <i>string</i> } }</code>
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceInUseException {
    pub reference_type: std::option::Option<crate::model::ReferenceType>,
    /// <p>Describes the resource that refers to the resource that you are
    /// attempting to delete. This object is returned as part of the
    /// <code>ResourceInUseException</code> exception. </p>
    pub example_reference: std::option::Option<crate::model::ResourceReference>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceInUseException");
        formatter.field("reference_type", &self.reference_type);
        formatter.field("example_reference", &self.example_reference);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceInUseException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceInUseException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceInUseException {}
/// See [`ResourceInUseException`](crate::error::ResourceInUseException)
pub mod resource_in_use_exception {
    /// A builder for [`ResourceInUseException`](crate::error::ResourceInUseException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reference_type: std::option::Option<crate::model::ReferenceType>,
        pub(crate) example_reference: std::option::Option<crate::model::ResourceReference>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn reference_type(mut self, input: crate::model::ReferenceType) -> Self {
            self.reference_type = Some(input);
            self
        }
        pub fn set_reference_type(
            mut self,
            input: std::option::Option<crate::model::ReferenceType>,
        ) -> Self {
            self.reference_type = input;
            self
        }
        /// <p>Describes the resource that refers to the resource that you are
        /// attempting to delete. This object is returned as part of the
        /// <code>ResourceInUseException</code> exception. </p>
        pub fn example_reference(mut self, input: crate::model::ResourceReference) -> Self {
            self.example_reference = Some(input);
            self
        }
        pub fn set_example_reference(
            mut self,
            input: std::option::Option<crate::model::ResourceReference>,
        ) -> Self {
            self.example_reference = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceInUseException`](crate::error::ResourceInUseException)
        pub fn build(self) -> crate::error::ResourceInUseException {
            crate::error::ResourceInUseException {
                reference_type: self.reference_type,
                example_reference: self.example_reference,
                message: self.message,
            }
        }
    }
}
impl ResourceInUseException {
    /// Creates a new builder-style object to manufacture [`ResourceInUseException`](crate::error::ResourceInUseException)
    pub fn builder() -> crate::error::resource_in_use_exception::Builder {
        crate::error::resource_in_use_exception::Builder::default()
    }
}
