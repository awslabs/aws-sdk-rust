// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Options that apply when the app starts. These optiAons override default behavior.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LaunchOverrides {
    /// <p>App launch commands and command line parameters that override the launch command configured in the simulation schema.</p>
    #[doc(hidden)]
    pub launch_commands: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl LaunchOverrides {
    /// <p>App launch commands and command line parameters that override the launch command configured in the simulation schema.</p>
    pub fn launch_commands(&self) -> std::option::Option<&[std::string::String]> {
        self.launch_commands.as_deref()
    }
}
impl LaunchOverrides {
    /// Creates a new builder-style object to manufacture [`LaunchOverrides`](crate::model::LaunchOverrides).
    pub fn builder() -> crate::model::launch_overrides::Builder {
        crate::model::launch_overrides::Builder::default()
    }
}

/// See [`LaunchOverrides`](crate::model::LaunchOverrides).
pub mod launch_overrides {

    /// A builder for [`LaunchOverrides`](crate::model::LaunchOverrides).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_commands: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `launch_commands`.
        ///
        /// To override the contents of this collection use [`set_launch_commands`](Self::set_launch_commands).
        ///
        /// <p>App launch commands and command line parameters that override the launch command configured in the simulation schema.</p>
        pub fn launch_commands(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.launch_commands.unwrap_or_default();
            v.push(input.into());
            self.launch_commands = Some(v);
            self
        }
        /// <p>App launch commands and command line parameters that override the launch command configured in the simulation schema.</p>
        pub fn set_launch_commands(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.launch_commands = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchOverrides`](crate::model::LaunchOverrides).
        pub fn build(self) -> crate::model::LaunchOverrides {
            crate::model::LaunchOverrides {
                launch_commands: self.launch_commands,
            }
        }
    }
}

/// <p>A collection of metadata about an app.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SimulationAppMetadata {
    /// <p>The name of the app.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the simulation of the app.</p>
    #[doc(hidden)]
    pub simulation: std::option::Option<std::string::String>,
    /// <p>The domain of the app. For more information about domains, see <a href="https://docs.aws.amazon.com/simspaceweaver/latest/userguide/what-is_key-concepts.html">Key concepts</a> in the <i>Amazon Web Services SimSpace Weaver User Guide</i>.</p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p>The current status of the app.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::SimulationAppStatus>,
    /// <p>The desired status of the app.</p>
    #[doc(hidden)]
    pub target_status: std::option::Option<crate::model::SimulationAppTargetStatus>,
}
impl SimulationAppMetadata {
    /// <p>The name of the app.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the simulation of the app.</p>
    pub fn simulation(&self) -> std::option::Option<&str> {
        self.simulation.as_deref()
    }
    /// <p>The domain of the app. For more information about domains, see <a href="https://docs.aws.amazon.com/simspaceweaver/latest/userguide/what-is_key-concepts.html">Key concepts</a> in the <i>Amazon Web Services SimSpace Weaver User Guide</i>.</p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p>The current status of the app.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::SimulationAppStatus> {
        self.status.as_ref()
    }
    /// <p>The desired status of the app.</p>
    pub fn target_status(&self) -> std::option::Option<&crate::model::SimulationAppTargetStatus> {
        self.target_status.as_ref()
    }
}
impl SimulationAppMetadata {
    /// Creates a new builder-style object to manufacture [`SimulationAppMetadata`](crate::model::SimulationAppMetadata).
    pub fn builder() -> crate::model::simulation_app_metadata::Builder {
        crate::model::simulation_app_metadata::Builder::default()
    }
}

/// See [`SimulationAppMetadata`](crate::model::SimulationAppMetadata).
pub mod simulation_app_metadata {

    /// A builder for [`SimulationAppMetadata`](crate::model::SimulationAppMetadata).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) simulation: std::option::Option<std::string::String>,
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::SimulationAppStatus>,
        pub(crate) target_status: std::option::Option<crate::model::SimulationAppTargetStatus>,
    }
    impl Builder {
        /// <p>The name of the app.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the app.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the simulation of the app.</p>
        pub fn simulation(mut self, input: impl Into<std::string::String>) -> Self {
            self.simulation = Some(input.into());
            self
        }
        /// <p>The name of the simulation of the app.</p>
        pub fn set_simulation(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.simulation = input;
            self
        }
        /// <p>The domain of the app. For more information about domains, see <a href="https://docs.aws.amazon.com/simspaceweaver/latest/userguide/what-is_key-concepts.html">Key concepts</a> in the <i>Amazon Web Services SimSpace Weaver User Guide</i>.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p>The domain of the app. For more information about domains, see <a href="https://docs.aws.amazon.com/simspaceweaver/latest/userguide/what-is_key-concepts.html">Key concepts</a> in the <i>Amazon Web Services SimSpace Weaver User Guide</i>.</p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p>The current status of the app.</p>
        pub fn status(mut self, input: crate::model::SimulationAppStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the app.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::SimulationAppStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The desired status of the app.</p>
        pub fn target_status(mut self, input: crate::model::SimulationAppTargetStatus) -> Self {
            self.target_status = Some(input);
            self
        }
        /// <p>The desired status of the app.</p>
        pub fn set_target_status(
            mut self,
            input: std::option::Option<crate::model::SimulationAppTargetStatus>,
        ) -> Self {
            self.target_status = input;
            self
        }
        /// Consumes the builder and constructs a [`SimulationAppMetadata`](crate::model::SimulationAppMetadata).
        pub fn build(self) -> crate::model::SimulationAppMetadata {
            crate::model::SimulationAppMetadata {
                name: self.name,
                simulation: self.simulation,
                domain: self.domain,
                status: self.status,
                target_status: self.target_status,
            }
        }
    }
}

/// When writing a match expression against `SimulationAppTargetStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let simulationapptargetstatus = unimplemented!();
/// match simulationapptargetstatus {
///     SimulationAppTargetStatus::Started => { /* ... */ },
///     SimulationAppTargetStatus::Stopped => { /* ... */ },
///     SimulationAppTargetStatus::UnknownValue => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `simulationapptargetstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SimulationAppTargetStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SimulationAppTargetStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SimulationAppTargetStatus::NewFeature` is defined.
/// Specifically, when `simulationapptargetstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SimulationAppTargetStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// _Note: `SimulationAppTargetStatus::Unknown` has been renamed to `::UnknownValue`._
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SimulationAppTargetStatus {
    #[allow(missing_docs)] // documentation missing in model
    Started,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    /// _Note: `::Unknown` has been renamed to `::UnknownValue`._
    UnknownValue,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SimulationAppTargetStatus {
    fn from(s: &str) -> Self {
        match s {
            "STARTED" => SimulationAppTargetStatus::Started,
            "STOPPED" => SimulationAppTargetStatus::Stopped,
            "UNKNOWN" => SimulationAppTargetStatus::UnknownValue,
            other => SimulationAppTargetStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for SimulationAppTargetStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SimulationAppTargetStatus::from(s))
    }
}
impl SimulationAppTargetStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SimulationAppTargetStatus::Started => "STARTED",
            SimulationAppTargetStatus::Stopped => "STOPPED",
            SimulationAppTargetStatus::UnknownValue => "UNKNOWN",
            SimulationAppTargetStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["STARTED", "STOPPED", "UNKNOWN"]
    }
}
impl AsRef<str> for SimulationAppTargetStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SimulationAppStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let simulationappstatus = unimplemented!();
/// match simulationappstatus {
///     SimulationAppStatus::Error => { /* ... */ },
///     SimulationAppStatus::Started => { /* ... */ },
///     SimulationAppStatus::Starting => { /* ... */ },
///     SimulationAppStatus::Stopped => { /* ... */ },
///     SimulationAppStatus::Stopping => { /* ... */ },
///     SimulationAppStatus::UnknownValue => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `simulationappstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SimulationAppStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SimulationAppStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SimulationAppStatus::NewFeature` is defined.
/// Specifically, when `simulationappstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SimulationAppStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// _Note: `SimulationAppStatus::Unknown` has been renamed to `::UnknownValue`._
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SimulationAppStatus {
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Started,
    #[allow(missing_docs)] // documentation missing in model
    Starting,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// _Note: `::Unknown` has been renamed to `::UnknownValue`._
    UnknownValue,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SimulationAppStatus {
    fn from(s: &str) -> Self {
        match s {
            "ERROR" => SimulationAppStatus::Error,
            "STARTED" => SimulationAppStatus::Started,
            "STARTING" => SimulationAppStatus::Starting,
            "STOPPED" => SimulationAppStatus::Stopped,
            "STOPPING" => SimulationAppStatus::Stopping,
            "UNKNOWN" => SimulationAppStatus::UnknownValue,
            other => {
                SimulationAppStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for SimulationAppStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SimulationAppStatus::from(s))
    }
}
impl SimulationAppStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SimulationAppStatus::Error => "ERROR",
            SimulationAppStatus::Started => "STARTED",
            SimulationAppStatus::Starting => "STARTING",
            SimulationAppStatus::Stopped => "STOPPED",
            SimulationAppStatus::Stopping => "STOPPING",
            SimulationAppStatus::UnknownValue => "UNKNOWN",
            SimulationAppStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ERROR", "STARTED", "STARTING", "STOPPED", "STOPPING", "UNKNOWN",
        ]
    }
}
impl AsRef<str> for SimulationAppStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the network endpoint that you can use to connect to your custom or service app.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SimulationAppEndpointInfo {
    /// <p>The IP address of the app. SimSpace Weaver dynamically assigns this IP address when the app starts.</p>
    #[doc(hidden)]
    pub address: std::option::Option<std::string::String>,
    /// <p>The inbound TCP/UDP port numbers of the app. The combination of an IP address and a port number form a network endpoint.</p>
    #[doc(hidden)]
    pub ingress_port_mappings:
        std::option::Option<std::vec::Vec<crate::model::SimulationAppPortMapping>>,
}
impl SimulationAppEndpointInfo {
    /// <p>The IP address of the app. SimSpace Weaver dynamically assigns this IP address when the app starts.</p>
    pub fn address(&self) -> std::option::Option<&str> {
        self.address.as_deref()
    }
    /// <p>The inbound TCP/UDP port numbers of the app. The combination of an IP address and a port number form a network endpoint.</p>
    pub fn ingress_port_mappings(
        &self,
    ) -> std::option::Option<&[crate::model::SimulationAppPortMapping]> {
        self.ingress_port_mappings.as_deref()
    }
}
impl SimulationAppEndpointInfo {
    /// Creates a new builder-style object to manufacture [`SimulationAppEndpointInfo`](crate::model::SimulationAppEndpointInfo).
    pub fn builder() -> crate::model::simulation_app_endpoint_info::Builder {
        crate::model::simulation_app_endpoint_info::Builder::default()
    }
}

/// See [`SimulationAppEndpointInfo`](crate::model::SimulationAppEndpointInfo).
pub mod simulation_app_endpoint_info {

    /// A builder for [`SimulationAppEndpointInfo`](crate::model::SimulationAppEndpointInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) address: std::option::Option<std::string::String>,
        pub(crate) ingress_port_mappings:
            std::option::Option<std::vec::Vec<crate::model::SimulationAppPortMapping>>,
    }
    impl Builder {
        /// <p>The IP address of the app. SimSpace Weaver dynamically assigns this IP address when the app starts.</p>
        pub fn address(mut self, input: impl Into<std::string::String>) -> Self {
            self.address = Some(input.into());
            self
        }
        /// <p>The IP address of the app. SimSpace Weaver dynamically assigns this IP address when the app starts.</p>
        pub fn set_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.address = input;
            self
        }
        /// Appends an item to `ingress_port_mappings`.
        ///
        /// To override the contents of this collection use [`set_ingress_port_mappings`](Self::set_ingress_port_mappings).
        ///
        /// <p>The inbound TCP/UDP port numbers of the app. The combination of an IP address and a port number form a network endpoint.</p>
        pub fn ingress_port_mappings(
            mut self,
            input: crate::model::SimulationAppPortMapping,
        ) -> Self {
            let mut v = self.ingress_port_mappings.unwrap_or_default();
            v.push(input);
            self.ingress_port_mappings = Some(v);
            self
        }
        /// <p>The inbound TCP/UDP port numbers of the app. The combination of an IP address and a port number form a network endpoint.</p>
        pub fn set_ingress_port_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SimulationAppPortMapping>>,
        ) -> Self {
            self.ingress_port_mappings = input;
            self
        }
        /// Consumes the builder and constructs a [`SimulationAppEndpointInfo`](crate::model::SimulationAppEndpointInfo).
        pub fn build(self) -> crate::model::SimulationAppEndpointInfo {
            crate::model::SimulationAppEndpointInfo {
                address: self.address,
                ingress_port_mappings: self.ingress_port_mappings,
            }
        }
    }
}

/// <p>A collection of TCP/UDP ports for a custom or service app.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SimulationAppPortMapping {
    /// <p>The TCP/UDP port number of the app, declared in the simulation schema. SimSpace Weaver maps the <code>Declared</code> port to the <code>Actual</code> port. The source code for the app should bind to the <code>Declared</code> port.</p>
    #[doc(hidden)]
    pub declared: std::option::Option<i32>,
    /// <p>The TCP/UDP port number of the running app. SimSpace Weaver dynamically assigns this port number when the app starts. SimSpace Weaver maps the <code>Declared</code> port to the <code>Actual</code> port. Clients connect to the app using the app's IP address and the <code>Actual</code> port number.</p>
    #[doc(hidden)]
    pub actual: std::option::Option<i32>,
}
impl SimulationAppPortMapping {
    /// <p>The TCP/UDP port number of the app, declared in the simulation schema. SimSpace Weaver maps the <code>Declared</code> port to the <code>Actual</code> port. The source code for the app should bind to the <code>Declared</code> port.</p>
    pub fn declared(&self) -> std::option::Option<i32> {
        self.declared
    }
    /// <p>The TCP/UDP port number of the running app. SimSpace Weaver dynamically assigns this port number when the app starts. SimSpace Weaver maps the <code>Declared</code> port to the <code>Actual</code> port. Clients connect to the app using the app's IP address and the <code>Actual</code> port number.</p>
    pub fn actual(&self) -> std::option::Option<i32> {
        self.actual
    }
}
impl SimulationAppPortMapping {
    /// Creates a new builder-style object to manufacture [`SimulationAppPortMapping`](crate::model::SimulationAppPortMapping).
    pub fn builder() -> crate::model::simulation_app_port_mapping::Builder {
        crate::model::simulation_app_port_mapping::Builder::default()
    }
}

/// See [`SimulationAppPortMapping`](crate::model::SimulationAppPortMapping).
pub mod simulation_app_port_mapping {

    /// A builder for [`SimulationAppPortMapping`](crate::model::SimulationAppPortMapping).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) declared: std::option::Option<i32>,
        pub(crate) actual: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The TCP/UDP port number of the app, declared in the simulation schema. SimSpace Weaver maps the <code>Declared</code> port to the <code>Actual</code> port. The source code for the app should bind to the <code>Declared</code> port.</p>
        pub fn declared(mut self, input: i32) -> Self {
            self.declared = Some(input);
            self
        }
        /// <p>The TCP/UDP port number of the app, declared in the simulation schema. SimSpace Weaver maps the <code>Declared</code> port to the <code>Actual</code> port. The source code for the app should bind to the <code>Declared</code> port.</p>
        pub fn set_declared(mut self, input: std::option::Option<i32>) -> Self {
            self.declared = input;
            self
        }
        /// <p>The TCP/UDP port number of the running app. SimSpace Weaver dynamically assigns this port number when the app starts. SimSpace Weaver maps the <code>Declared</code> port to the <code>Actual</code> port. Clients connect to the app using the app's IP address and the <code>Actual</code> port number.</p>
        pub fn actual(mut self, input: i32) -> Self {
            self.actual = Some(input);
            self
        }
        /// <p>The TCP/UDP port number of the running app. SimSpace Weaver dynamically assigns this port number when the app starts. SimSpace Weaver maps the <code>Declared</code> port to the <code>Actual</code> port. Clients connect to the app using the app's IP address and the <code>Actual</code> port number.</p>
        pub fn set_actual(mut self, input: std::option::Option<i32>) -> Self {
            self.actual = input;
            self
        }
        /// Consumes the builder and constructs a [`SimulationAppPortMapping`](crate::model::SimulationAppPortMapping).
        pub fn build(self) -> crate::model::SimulationAppPortMapping {
            crate::model::SimulationAppPortMapping {
                declared: self.declared,
                actual: self.actual,
            }
        }
    }
}

/// <p>A collection of data about the simulation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SimulationMetadata {
    /// <p>The name of the simulation.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the simulation. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>Amazon Web Services General Reference</i>.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The time when the simulation was created, expressed as the number of seconds and milliseconds in UTC since the Unix epoch (0:0:0.000, January 1, 1970).</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The current status of the simulation.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::SimulationStatus>,
    /// <p>The desired status of the simulation.</p>
    #[doc(hidden)]
    pub target_status: std::option::Option<crate::model::SimulationTargetStatus>,
}
impl SimulationMetadata {
    /// <p>The name of the simulation.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the simulation. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>Amazon Web Services General Reference</i>.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The time when the simulation was created, expressed as the number of seconds and milliseconds in UTC since the Unix epoch (0:0:0.000, January 1, 1970).</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The current status of the simulation.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::SimulationStatus> {
        self.status.as_ref()
    }
    /// <p>The desired status of the simulation.</p>
    pub fn target_status(&self) -> std::option::Option<&crate::model::SimulationTargetStatus> {
        self.target_status.as_ref()
    }
}
impl SimulationMetadata {
    /// Creates a new builder-style object to manufacture [`SimulationMetadata`](crate::model::SimulationMetadata).
    pub fn builder() -> crate::model::simulation_metadata::Builder {
        crate::model::simulation_metadata::Builder::default()
    }
}

/// See [`SimulationMetadata`](crate::model::SimulationMetadata).
pub mod simulation_metadata {

    /// A builder for [`SimulationMetadata`](crate::model::SimulationMetadata).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status: std::option::Option<crate::model::SimulationStatus>,
        pub(crate) target_status: std::option::Option<crate::model::SimulationTargetStatus>,
    }
    impl Builder {
        /// <p>The name of the simulation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the simulation.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the simulation. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>Amazon Web Services General Reference</i>.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the simulation. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>Amazon Web Services General Reference</i>.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The time when the simulation was created, expressed as the number of seconds and milliseconds in UTC since the Unix epoch (0:0:0.000, January 1, 1970).</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time when the simulation was created, expressed as the number of seconds and milliseconds in UTC since the Unix epoch (0:0:0.000, January 1, 1970).</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The current status of the simulation.</p>
        pub fn status(mut self, input: crate::model::SimulationStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the simulation.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::SimulationStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The desired status of the simulation.</p>
        pub fn target_status(mut self, input: crate::model::SimulationTargetStatus) -> Self {
            self.target_status = Some(input);
            self
        }
        /// <p>The desired status of the simulation.</p>
        pub fn set_target_status(
            mut self,
            input: std::option::Option<crate::model::SimulationTargetStatus>,
        ) -> Self {
            self.target_status = input;
            self
        }
        /// Consumes the builder and constructs a [`SimulationMetadata`](crate::model::SimulationMetadata).
        pub fn build(self) -> crate::model::SimulationMetadata {
            crate::model::SimulationMetadata {
                name: self.name,
                arn: self.arn,
                creation_time: self.creation_time,
                status: self.status,
                target_status: self.target_status,
            }
        }
    }
}

/// When writing a match expression against `SimulationTargetStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let simulationtargetstatus = unimplemented!();
/// match simulationtargetstatus {
///     SimulationTargetStatus::Deleted => { /* ... */ },
///     SimulationTargetStatus::Started => { /* ... */ },
///     SimulationTargetStatus::Stopped => { /* ... */ },
///     SimulationTargetStatus::UnknownValue => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `simulationtargetstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SimulationTargetStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SimulationTargetStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SimulationTargetStatus::NewFeature` is defined.
/// Specifically, when `simulationtargetstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SimulationTargetStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// _Note: `SimulationTargetStatus::Unknown` has been renamed to `::UnknownValue`._
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SimulationTargetStatus {
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Started,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    /// _Note: `::Unknown` has been renamed to `::UnknownValue`._
    UnknownValue,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SimulationTargetStatus {
    fn from(s: &str) -> Self {
        match s {
            "DELETED" => SimulationTargetStatus::Deleted,
            "STARTED" => SimulationTargetStatus::Started,
            "STOPPED" => SimulationTargetStatus::Stopped,
            "UNKNOWN" => SimulationTargetStatus::UnknownValue,
            other => {
                SimulationTargetStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for SimulationTargetStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SimulationTargetStatus::from(s))
    }
}
impl SimulationTargetStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SimulationTargetStatus::Deleted => "DELETED",
            SimulationTargetStatus::Started => "STARTED",
            SimulationTargetStatus::Stopped => "STOPPED",
            SimulationTargetStatus::UnknownValue => "UNKNOWN",
            SimulationTargetStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DELETED", "STARTED", "STOPPED", "UNKNOWN"]
    }
}
impl AsRef<str> for SimulationTargetStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SimulationStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let simulationstatus = unimplemented!();
/// match simulationstatus {
///     SimulationStatus::Deleted => { /* ... */ },
///     SimulationStatus::Deleting => { /* ... */ },
///     SimulationStatus::Failed => { /* ... */ },
///     SimulationStatus::Started => { /* ... */ },
///     SimulationStatus::Starting => { /* ... */ },
///     SimulationStatus::Stopped => { /* ... */ },
///     SimulationStatus::Stopping => { /* ... */ },
///     SimulationStatus::UnknownValue => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `simulationstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SimulationStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SimulationStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SimulationStatus::NewFeature` is defined.
/// Specifically, when `simulationstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SimulationStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// _Note: `SimulationStatus::Unknown` has been renamed to `::UnknownValue`._
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SimulationStatus {
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Started,
    #[allow(missing_docs)] // documentation missing in model
    Starting,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// _Note: `::Unknown` has been renamed to `::UnknownValue`._
    UnknownValue,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SimulationStatus {
    fn from(s: &str) -> Self {
        match s {
            "DELETED" => SimulationStatus::Deleted,
            "DELETING" => SimulationStatus::Deleting,
            "FAILED" => SimulationStatus::Failed,
            "STARTED" => SimulationStatus::Started,
            "STARTING" => SimulationStatus::Starting,
            "STOPPED" => SimulationStatus::Stopped,
            "STOPPING" => SimulationStatus::Stopping,
            "UNKNOWN" => SimulationStatus::UnknownValue,
            other => SimulationStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SimulationStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SimulationStatus::from(s))
    }
}
impl SimulationStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SimulationStatus::Deleted => "DELETED",
            SimulationStatus::Deleting => "DELETING",
            SimulationStatus::Failed => "FAILED",
            SimulationStatus::Started => "STARTED",
            SimulationStatus::Starting => "STARTING",
            SimulationStatus::Stopped => "STOPPED",
            SimulationStatus::Stopping => "STOPPING",
            SimulationStatus::UnknownValue => "UNKNOWN",
            SimulationStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DELETED", "DELETING", "FAILED", "STARTED", "STARTING", "STOPPED", "STOPPING",
            "UNKNOWN",
        ]
    }
}
impl AsRef<str> for SimulationStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A location in Amazon Simple Storage Service (Amazon S3) where SimSpace Weaver stores simulation data, such as your app zip files and schema file. For more information about Amazon S3, see the <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/Welcome.html"> <i>Amazon Simple Storage Service User Guide</i> </a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3Location {
    /// <p>The name of an Amazon S3 bucket. For more information about buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-buckets-s3.html">Creating, configuring, and working with Amazon S3 buckets</a> in the <i>Amazon Simple Storage Service User Guide</i>.</p>
    #[doc(hidden)]
    pub bucket_name: std::option::Option<std::string::String>,
    /// <p>The key name of an object in Amazon S3. For more information about Amazon S3 objects and object keys, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/uploading-downloading-objects.html">Uploading, downloading, and working with objects in Amazon S3</a> in the <i>Amazon Simple Storage Service User Guide</i>.</p>
    #[doc(hidden)]
    pub object_key: std::option::Option<std::string::String>,
}
impl S3Location {
    /// <p>The name of an Amazon S3 bucket. For more information about buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-buckets-s3.html">Creating, configuring, and working with Amazon S3 buckets</a> in the <i>Amazon Simple Storage Service User Guide</i>.</p>
    pub fn bucket_name(&self) -> std::option::Option<&str> {
        self.bucket_name.as_deref()
    }
    /// <p>The key name of an object in Amazon S3. For more information about Amazon S3 objects and object keys, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/uploading-downloading-objects.html">Uploading, downloading, and working with objects in Amazon S3</a> in the <i>Amazon Simple Storage Service User Guide</i>.</p>
    pub fn object_key(&self) -> std::option::Option<&str> {
        self.object_key.as_deref()
    }
}
impl S3Location {
    /// Creates a new builder-style object to manufacture [`S3Location`](crate::model::S3Location).
    pub fn builder() -> crate::model::s3_location::Builder {
        crate::model::s3_location::Builder::default()
    }
}

/// See [`S3Location`](crate::model::S3Location).
pub mod s3_location {

    /// A builder for [`S3Location`](crate::model::S3Location).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_name: std::option::Option<std::string::String>,
        pub(crate) object_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of an Amazon S3 bucket. For more information about buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-buckets-s3.html">Creating, configuring, and working with Amazon S3 buckets</a> in the <i>Amazon Simple Storage Service User Guide</i>.</p>
        pub fn bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_name = Some(input.into());
            self
        }
        /// <p>The name of an Amazon S3 bucket. For more information about buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-buckets-s3.html">Creating, configuring, and working with Amazon S3 buckets</a> in the <i>Amazon Simple Storage Service User Guide</i>.</p>
        pub fn set_bucket_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_name = input;
            self
        }
        /// <p>The key name of an object in Amazon S3. For more information about Amazon S3 objects and object keys, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/uploading-downloading-objects.html">Uploading, downloading, and working with objects in Amazon S3</a> in the <i>Amazon Simple Storage Service User Guide</i>.</p>
        pub fn object_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.object_key = Some(input.into());
            self
        }
        /// <p>The key name of an object in Amazon S3. For more information about Amazon S3 objects and object keys, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/uploading-downloading-objects.html">Uploading, downloading, and working with objects in Amazon S3</a> in the <i>Amazon Simple Storage Service User Guide</i>.</p>
        pub fn set_object_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.object_key = input;
            self
        }
        /// Consumes the builder and constructs a [`S3Location`](crate::model::S3Location).
        pub fn build(self) -> crate::model::S3Location {
            crate::model::S3Location {
                bucket_name: self.bucket_name,
                object_key: self.object_key,
            }
        }
    }
}

/// <p>A collection of additional state information, such as domain and clock configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LiveSimulationState {
    /// <p>A list of domains for the simulation. For more information about domains, see <a href="https://docs.aws.amazon.com/simspaceweaver/latest/userguide/what-is_key-concepts.html">Key concepts</a> in the <i>Amazon Web Services SimSpace Weaver User Guide</i>.</p>
    #[doc(hidden)]
    pub domains: std::option::Option<std::vec::Vec<crate::model::Domain>>,
    /// <p>A list of simulation clocks.</p> <note>
    /// <p>At this time, a simulation has only one clock.</p>
    /// </note>
    #[doc(hidden)]
    pub clocks: std::option::Option<std::vec::Vec<crate::model::SimulationClock>>,
}
impl LiveSimulationState {
    /// <p>A list of domains for the simulation. For more information about domains, see <a href="https://docs.aws.amazon.com/simspaceweaver/latest/userguide/what-is_key-concepts.html">Key concepts</a> in the <i>Amazon Web Services SimSpace Weaver User Guide</i>.</p>
    pub fn domains(&self) -> std::option::Option<&[crate::model::Domain]> {
        self.domains.as_deref()
    }
    /// <p>A list of simulation clocks.</p> <note>
    /// <p>At this time, a simulation has only one clock.</p>
    /// </note>
    pub fn clocks(&self) -> std::option::Option<&[crate::model::SimulationClock]> {
        self.clocks.as_deref()
    }
}
impl LiveSimulationState {
    /// Creates a new builder-style object to manufacture [`LiveSimulationState`](crate::model::LiveSimulationState).
    pub fn builder() -> crate::model::live_simulation_state::Builder {
        crate::model::live_simulation_state::Builder::default()
    }
}

/// See [`LiveSimulationState`](crate::model::LiveSimulationState).
pub mod live_simulation_state {

    /// A builder for [`LiveSimulationState`](crate::model::LiveSimulationState).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domains: std::option::Option<std::vec::Vec<crate::model::Domain>>,
        pub(crate) clocks: std::option::Option<std::vec::Vec<crate::model::SimulationClock>>,
    }
    impl Builder {
        /// Appends an item to `domains`.
        ///
        /// To override the contents of this collection use [`set_domains`](Self::set_domains).
        ///
        /// <p>A list of domains for the simulation. For more information about domains, see <a href="https://docs.aws.amazon.com/simspaceweaver/latest/userguide/what-is_key-concepts.html">Key concepts</a> in the <i>Amazon Web Services SimSpace Weaver User Guide</i>.</p>
        pub fn domains(mut self, input: crate::model::Domain) -> Self {
            let mut v = self.domains.unwrap_or_default();
            v.push(input);
            self.domains = Some(v);
            self
        }
        /// <p>A list of domains for the simulation. For more information about domains, see <a href="https://docs.aws.amazon.com/simspaceweaver/latest/userguide/what-is_key-concepts.html">Key concepts</a> in the <i>Amazon Web Services SimSpace Weaver User Guide</i>.</p>
        pub fn set_domains(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Domain>>,
        ) -> Self {
            self.domains = input;
            self
        }
        /// Appends an item to `clocks`.
        ///
        /// To override the contents of this collection use [`set_clocks`](Self::set_clocks).
        ///
        /// <p>A list of simulation clocks.</p> <note>
        /// <p>At this time, a simulation has only one clock.</p>
        /// </note>
        pub fn clocks(mut self, input: crate::model::SimulationClock) -> Self {
            let mut v = self.clocks.unwrap_or_default();
            v.push(input);
            self.clocks = Some(v);
            self
        }
        /// <p>A list of simulation clocks.</p> <note>
        /// <p>At this time, a simulation has only one clock.</p>
        /// </note>
        pub fn set_clocks(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SimulationClock>>,
        ) -> Self {
            self.clocks = input;
            self
        }
        /// Consumes the builder and constructs a [`LiveSimulationState`](crate::model::LiveSimulationState).
        pub fn build(self) -> crate::model::LiveSimulationState {
            crate::model::LiveSimulationState {
                domains: self.domains,
                clocks: self.clocks,
            }
        }
    }
}

/// <p>Status information about the simulation clock.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SimulationClock {
    /// <p>The current status of the simulation clock.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ClockStatus>,
    /// <p>The desired status of the simulation clock.</p>
    #[doc(hidden)]
    pub target_status: std::option::Option<crate::model::ClockTargetStatus>,
}
impl SimulationClock {
    /// <p>The current status of the simulation clock.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ClockStatus> {
        self.status.as_ref()
    }
    /// <p>The desired status of the simulation clock.</p>
    pub fn target_status(&self) -> std::option::Option<&crate::model::ClockTargetStatus> {
        self.target_status.as_ref()
    }
}
impl SimulationClock {
    /// Creates a new builder-style object to manufacture [`SimulationClock`](crate::model::SimulationClock).
    pub fn builder() -> crate::model::simulation_clock::Builder {
        crate::model::simulation_clock::Builder::default()
    }
}

/// See [`SimulationClock`](crate::model::SimulationClock).
pub mod simulation_clock {

    /// A builder for [`SimulationClock`](crate::model::SimulationClock).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::ClockStatus>,
        pub(crate) target_status: std::option::Option<crate::model::ClockTargetStatus>,
    }
    impl Builder {
        /// <p>The current status of the simulation clock.</p>
        pub fn status(mut self, input: crate::model::ClockStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the simulation clock.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::ClockStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>The desired status of the simulation clock.</p>
        pub fn target_status(mut self, input: crate::model::ClockTargetStatus) -> Self {
            self.target_status = Some(input);
            self
        }
        /// <p>The desired status of the simulation clock.</p>
        pub fn set_target_status(
            mut self,
            input: std::option::Option<crate::model::ClockTargetStatus>,
        ) -> Self {
            self.target_status = input;
            self
        }
        /// Consumes the builder and constructs a [`SimulationClock`](crate::model::SimulationClock).
        pub fn build(self) -> crate::model::SimulationClock {
            crate::model::SimulationClock {
                status: self.status,
                target_status: self.target_status,
            }
        }
    }
}

/// When writing a match expression against `ClockTargetStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let clocktargetstatus = unimplemented!();
/// match clocktargetstatus {
///     ClockTargetStatus::Started => { /* ... */ },
///     ClockTargetStatus::Stopped => { /* ... */ },
///     ClockTargetStatus::UnknownValue => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `clocktargetstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ClockTargetStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ClockTargetStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ClockTargetStatus::NewFeature` is defined.
/// Specifically, when `clocktargetstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ClockTargetStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// _Note: `ClockTargetStatus::Unknown` has been renamed to `::UnknownValue`._
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ClockTargetStatus {
    #[allow(missing_docs)] // documentation missing in model
    Started,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    /// _Note: `::Unknown` has been renamed to `::UnknownValue`._
    UnknownValue,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ClockTargetStatus {
    fn from(s: &str) -> Self {
        match s {
            "STARTED" => ClockTargetStatus::Started,
            "STOPPED" => ClockTargetStatus::Stopped,
            "UNKNOWN" => ClockTargetStatus::UnknownValue,
            other => {
                ClockTargetStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ClockTargetStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ClockTargetStatus::from(s))
    }
}
impl ClockTargetStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ClockTargetStatus::Started => "STARTED",
            ClockTargetStatus::Stopped => "STOPPED",
            ClockTargetStatus::UnknownValue => "UNKNOWN",
            ClockTargetStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["STARTED", "STOPPED", "UNKNOWN"]
    }
}
impl AsRef<str> for ClockTargetStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ClockStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let clockstatus = unimplemented!();
/// match clockstatus {
///     ClockStatus::Started => { /* ... */ },
///     ClockStatus::Starting => { /* ... */ },
///     ClockStatus::Stopped => { /* ... */ },
///     ClockStatus::Stopping => { /* ... */ },
///     ClockStatus::UnknownValue => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `clockstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ClockStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ClockStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ClockStatus::NewFeature` is defined.
/// Specifically, when `clockstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ClockStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// _Note: `ClockStatus::Unknown` has been renamed to `::UnknownValue`._
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ClockStatus {
    #[allow(missing_docs)] // documentation missing in model
    Started,
    #[allow(missing_docs)] // documentation missing in model
    Starting,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// _Note: `::Unknown` has been renamed to `::UnknownValue`._
    UnknownValue,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ClockStatus {
    fn from(s: &str) -> Self {
        match s {
            "STARTED" => ClockStatus::Started,
            "STARTING" => ClockStatus::Starting,
            "STOPPED" => ClockStatus::Stopped,
            "STOPPING" => ClockStatus::Stopping,
            "UNKNOWN" => ClockStatus::UnknownValue,
            other => ClockStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ClockStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ClockStatus::from(s))
    }
}
impl ClockStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ClockStatus::Started => "STARTED",
            ClockStatus::Starting => "STARTING",
            ClockStatus::Stopped => "STOPPED",
            ClockStatus::Stopping => "STOPPING",
            ClockStatus::UnknownValue => "UNKNOWN",
            ClockStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["STARTED", "STARTING", "STOPPED", "STOPPING", "UNKNOWN"]
    }
}
impl AsRef<str> for ClockStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A collection of app instances that run the same executable app code and have the same launch options and commands.</p>
/// <p>For more information about domains, see <a href="https://docs.aws.amazon.com/simspaceweaver/latest/userguide/what-is_key-concepts.html">Key concepts</a> in the <i>Amazon Web Services SimSpace Weaver User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Domain {
    /// <p>The name of the domain.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of lifecycle management for apps in the domain. This value indicates whether apps in this domain are <i>managed</i> (SimSpace Weaver starts and stops the apps) or <i>unmanaged</i> (you must start and stop the apps).</p>
    /// <p class="title"> <b>Lifecycle types</b> </p>
    /// <ul>
    /// <li> <p> <code>PerWorker</code> – Managed: SimSpace Weaver starts 1 app on each worker</p> </li>
    /// <li> <p> <code>BySpatialSubdivision</code> – Managed: SimSpace Weaver starts 1 app for each spatial partition</p> </li>
    /// <li> <p> <code>ByRequest</code> – Unmanaged: You use the <b>StartApp</b> API to start the apps and use the <b>StopApp</b> API to stop the apps.</p> </li>
    /// </ul> <note>
    /// <p>The lifecycle types will change when the service is released for general availability (GA).</p>
    /// </note>
    #[doc(hidden)]
    pub lifecycle: std::option::Option<crate::model::LifecycleManagementStrategy>,
}
impl Domain {
    /// <p>The name of the domain.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of lifecycle management for apps in the domain. This value indicates whether apps in this domain are <i>managed</i> (SimSpace Weaver starts and stops the apps) or <i>unmanaged</i> (you must start and stop the apps).</p>
    /// <p class="title"> <b>Lifecycle types</b> </p>
    /// <ul>
    /// <li> <p> <code>PerWorker</code> – Managed: SimSpace Weaver starts 1 app on each worker</p> </li>
    /// <li> <p> <code>BySpatialSubdivision</code> – Managed: SimSpace Weaver starts 1 app for each spatial partition</p> </li>
    /// <li> <p> <code>ByRequest</code> – Unmanaged: You use the <b>StartApp</b> API to start the apps and use the <b>StopApp</b> API to stop the apps.</p> </li>
    /// </ul> <note>
    /// <p>The lifecycle types will change when the service is released for general availability (GA).</p>
    /// </note>
    pub fn lifecycle(&self) -> std::option::Option<&crate::model::LifecycleManagementStrategy> {
        self.lifecycle.as_ref()
    }
}
impl Domain {
    /// Creates a new builder-style object to manufacture [`Domain`](crate::model::Domain).
    pub fn builder() -> crate::model::domain::Builder {
        crate::model::domain::Builder::default()
    }
}

/// See [`Domain`](crate::model::Domain).
pub mod domain {

    /// A builder for [`Domain`](crate::model::Domain).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) lifecycle: std::option::Option<crate::model::LifecycleManagementStrategy>,
    }
    impl Builder {
        /// <p>The name of the domain.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the domain.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of lifecycle management for apps in the domain. This value indicates whether apps in this domain are <i>managed</i> (SimSpace Weaver starts and stops the apps) or <i>unmanaged</i> (you must start and stop the apps).</p>
        /// <p class="title"> <b>Lifecycle types</b> </p>
        /// <ul>
        /// <li> <p> <code>PerWorker</code> – Managed: SimSpace Weaver starts 1 app on each worker</p> </li>
        /// <li> <p> <code>BySpatialSubdivision</code> – Managed: SimSpace Weaver starts 1 app for each spatial partition</p> </li>
        /// <li> <p> <code>ByRequest</code> – Unmanaged: You use the <b>StartApp</b> API to start the apps and use the <b>StopApp</b> API to stop the apps.</p> </li>
        /// </ul> <note>
        /// <p>The lifecycle types will change when the service is released for general availability (GA).</p>
        /// </note>
        pub fn lifecycle(mut self, input: crate::model::LifecycleManagementStrategy) -> Self {
            self.lifecycle = Some(input);
            self
        }
        /// <p>The type of lifecycle management for apps in the domain. This value indicates whether apps in this domain are <i>managed</i> (SimSpace Weaver starts and stops the apps) or <i>unmanaged</i> (you must start and stop the apps).</p>
        /// <p class="title"> <b>Lifecycle types</b> </p>
        /// <ul>
        /// <li> <p> <code>PerWorker</code> – Managed: SimSpace Weaver starts 1 app on each worker</p> </li>
        /// <li> <p> <code>BySpatialSubdivision</code> – Managed: SimSpace Weaver starts 1 app for each spatial partition</p> </li>
        /// <li> <p> <code>ByRequest</code> – Unmanaged: You use the <b>StartApp</b> API to start the apps and use the <b>StopApp</b> API to stop the apps.</p> </li>
        /// </ul> <note>
        /// <p>The lifecycle types will change when the service is released for general availability (GA).</p>
        /// </note>
        pub fn set_lifecycle(
            mut self,
            input: std::option::Option<crate::model::LifecycleManagementStrategy>,
        ) -> Self {
            self.lifecycle = input;
            self
        }
        /// Consumes the builder and constructs a [`Domain`](crate::model::Domain).
        pub fn build(self) -> crate::model::Domain {
            crate::model::Domain {
                name: self.name,
                lifecycle: self.lifecycle,
            }
        }
    }
}

/// When writing a match expression against `LifecycleManagementStrategy`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let lifecyclemanagementstrategy = unimplemented!();
/// match lifecyclemanagementstrategy {
///     LifecycleManagementStrategy::ByRequest => { /* ... */ },
///     LifecycleManagementStrategy::BySpatialSubdivision => { /* ... */ },
///     LifecycleManagementStrategy::PerWorker => { /* ... */ },
///     LifecycleManagementStrategy::UnknownValue => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `lifecyclemanagementstrategy` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LifecycleManagementStrategy::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LifecycleManagementStrategy::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LifecycleManagementStrategy::NewFeature` is defined.
/// Specifically, when `lifecyclemanagementstrategy` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LifecycleManagementStrategy::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// _Note: `LifecycleManagementStrategy::Unknown` has been renamed to `::UnknownValue`._
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LifecycleManagementStrategy {
    #[allow(missing_docs)] // documentation missing in model
    ByRequest,
    #[allow(missing_docs)] // documentation missing in model
    BySpatialSubdivision,
    #[allow(missing_docs)] // documentation missing in model
    PerWorker,
    /// _Note: `::Unknown` has been renamed to `::UnknownValue`._
    UnknownValue,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LifecycleManagementStrategy {
    fn from(s: &str) -> Self {
        match s {
            "ByRequest" => LifecycleManagementStrategy::ByRequest,
            "BySpatialSubdivision" => LifecycleManagementStrategy::BySpatialSubdivision,
            "PerWorker" => LifecycleManagementStrategy::PerWorker,
            "Unknown" => LifecycleManagementStrategy::UnknownValue,
            other => LifecycleManagementStrategy::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for LifecycleManagementStrategy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LifecycleManagementStrategy::from(s))
    }
}
impl LifecycleManagementStrategy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LifecycleManagementStrategy::ByRequest => "ByRequest",
            LifecycleManagementStrategy::BySpatialSubdivision => "BySpatialSubdivision",
            LifecycleManagementStrategy::PerWorker => "PerWorker",
            LifecycleManagementStrategy::UnknownValue => "Unknown",
            LifecycleManagementStrategy::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ByRequest", "BySpatialSubdivision", "PerWorker", "Unknown"]
    }
}
impl AsRef<str> for LifecycleManagementStrategy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The logging configuration for a simulation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoggingConfiguration {
    /// <p>A list of the locations where SimSpace Weaver sends simulation log data.</p>
    #[doc(hidden)]
    pub destinations: std::option::Option<std::vec::Vec<crate::model::LogDestination>>,
}
impl LoggingConfiguration {
    /// <p>A list of the locations where SimSpace Weaver sends simulation log data.</p>
    pub fn destinations(&self) -> std::option::Option<&[crate::model::LogDestination]> {
        self.destinations.as_deref()
    }
}
impl LoggingConfiguration {
    /// Creates a new builder-style object to manufacture [`LoggingConfiguration`](crate::model::LoggingConfiguration).
    pub fn builder() -> crate::model::logging_configuration::Builder {
        crate::model::logging_configuration::Builder::default()
    }
}

/// See [`LoggingConfiguration`](crate::model::LoggingConfiguration).
pub mod logging_configuration {

    /// A builder for [`LoggingConfiguration`](crate::model::LoggingConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destinations: std::option::Option<std::vec::Vec<crate::model::LogDestination>>,
    }
    impl Builder {
        /// Appends an item to `destinations`.
        ///
        /// To override the contents of this collection use [`set_destinations`](Self::set_destinations).
        ///
        /// <p>A list of the locations where SimSpace Weaver sends simulation log data.</p>
        pub fn destinations(mut self, input: crate::model::LogDestination) -> Self {
            let mut v = self.destinations.unwrap_or_default();
            v.push(input);
            self.destinations = Some(v);
            self
        }
        /// <p>A list of the locations where SimSpace Weaver sends simulation log data.</p>
        pub fn set_destinations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LogDestination>>,
        ) -> Self {
            self.destinations = input;
            self
        }
        /// Consumes the builder and constructs a [`LoggingConfiguration`](crate::model::LoggingConfiguration).
        pub fn build(self) -> crate::model::LoggingConfiguration {
            crate::model::LoggingConfiguration {
                destinations: self.destinations,
            }
        }
    }
}

/// <p>The location where SimSpace Weaver sends simulation log data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LogDestination {
    /// <p>An Amazon CloudWatch Logs log group that stores simulation log data. For more information about log groups, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html">Working with log groups and log streams</a> in the <i>Amazon CloudWatch Logs User Guide</i>.</p>
    #[doc(hidden)]
    pub cloud_watch_logs_log_group: std::option::Option<crate::model::CloudWatchLogsLogGroup>,
}
impl LogDestination {
    /// <p>An Amazon CloudWatch Logs log group that stores simulation log data. For more information about log groups, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html">Working with log groups and log streams</a> in the <i>Amazon CloudWatch Logs User Guide</i>.</p>
    pub fn cloud_watch_logs_log_group(
        &self,
    ) -> std::option::Option<&crate::model::CloudWatchLogsLogGroup> {
        self.cloud_watch_logs_log_group.as_ref()
    }
}
impl LogDestination {
    /// Creates a new builder-style object to manufacture [`LogDestination`](crate::model::LogDestination).
    pub fn builder() -> crate::model::log_destination::Builder {
        crate::model::log_destination::Builder::default()
    }
}

/// See [`LogDestination`](crate::model::LogDestination).
pub mod log_destination {

    /// A builder for [`LogDestination`](crate::model::LogDestination).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cloud_watch_logs_log_group:
            std::option::Option<crate::model::CloudWatchLogsLogGroup>,
    }
    impl Builder {
        /// <p>An Amazon CloudWatch Logs log group that stores simulation log data. For more information about log groups, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html">Working with log groups and log streams</a> in the <i>Amazon CloudWatch Logs User Guide</i>.</p>
        pub fn cloud_watch_logs_log_group(
            mut self,
            input: crate::model::CloudWatchLogsLogGroup,
        ) -> Self {
            self.cloud_watch_logs_log_group = Some(input);
            self
        }
        /// <p>An Amazon CloudWatch Logs log group that stores simulation log data. For more information about log groups, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html">Working with log groups and log streams</a> in the <i>Amazon CloudWatch Logs User Guide</i>.</p>
        pub fn set_cloud_watch_logs_log_group(
            mut self,
            input: std::option::Option<crate::model::CloudWatchLogsLogGroup>,
        ) -> Self {
            self.cloud_watch_logs_log_group = input;
            self
        }
        /// Consumes the builder and constructs a [`LogDestination`](crate::model::LogDestination).
        pub fn build(self) -> crate::model::LogDestination {
            crate::model::LogDestination {
                cloud_watch_logs_log_group: self.cloud_watch_logs_log_group,
            }
        }
    }
}

/// <p>The Amazon CloudWatch Logs log group for the simulation. For more information about log groups, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html">Working with log groups and log streams</a> in the <i>Amazon CloudWatch Logs User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CloudWatchLogsLogGroup {
    /// <p>The Amazon Resource Name (ARN) of the Amazon CloudWatch Logs log group for the simulation. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>Amazon Web Services General Reference</i>. For more information about log groups, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html">Working with log groups and log streams</a> in the <i>Amazon CloudWatch Logs User Guide</i>.</p>
    #[doc(hidden)]
    pub log_group_arn: std::option::Option<std::string::String>,
}
impl CloudWatchLogsLogGroup {
    /// <p>The Amazon Resource Name (ARN) of the Amazon CloudWatch Logs log group for the simulation. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>Amazon Web Services General Reference</i>. For more information about log groups, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html">Working with log groups and log streams</a> in the <i>Amazon CloudWatch Logs User Guide</i>.</p>
    pub fn log_group_arn(&self) -> std::option::Option<&str> {
        self.log_group_arn.as_deref()
    }
}
impl CloudWatchLogsLogGroup {
    /// Creates a new builder-style object to manufacture [`CloudWatchLogsLogGroup`](crate::model::CloudWatchLogsLogGroup).
    pub fn builder() -> crate::model::cloud_watch_logs_log_group::Builder {
        crate::model::cloud_watch_logs_log_group::Builder::default()
    }
}

/// See [`CloudWatchLogsLogGroup`](crate::model::CloudWatchLogsLogGroup).
pub mod cloud_watch_logs_log_group {

    /// A builder for [`CloudWatchLogsLogGroup`](crate::model::CloudWatchLogsLogGroup).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the Amazon CloudWatch Logs log group for the simulation. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>Amazon Web Services General Reference</i>. For more information about log groups, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html">Working with log groups and log streams</a> in the <i>Amazon CloudWatch Logs User Guide</i>.</p>
        pub fn log_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon CloudWatch Logs log group for the simulation. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> in the <i>Amazon Web Services General Reference</i>. For more information about log groups, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html">Working with log groups and log streams</a> in the <i>Amazon CloudWatch Logs User Guide</i>.</p>
        pub fn set_log_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CloudWatchLogsLogGroup`](crate::model::CloudWatchLogsLogGroup).
        pub fn build(self) -> crate::model::CloudWatchLogsLogGroup {
            crate::model::CloudWatchLogsLogGroup {
                log_group_arn: self.log_group_arn,
            }
        }
    }
}
