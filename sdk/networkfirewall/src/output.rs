// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateSubnetChangeProtectionOutput {
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    #[doc(hidden)]
    pub update_token: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    #[doc(hidden)]
    pub firewall_arn: std::option::Option<std::string::String>,
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    #[doc(hidden)]
    pub firewall_name: std::option::Option<std::string::String>,
    /// <p>A setting indicating whether the firewall is protected against changes to the subnet associations. Use this setting to protect against accidentally modifying the subnet associations for a firewall that is in use. When you create a firewall, the operation initializes this setting to <code>TRUE</code>.</p>
    #[doc(hidden)]
    pub subnet_change_protection: bool,
    _request_id: Option<String>,
}
impl UpdateSubnetChangeProtectionOutput {
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    pub fn update_token(&self) -> std::option::Option<&str> {
        self.update_token.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    pub fn firewall_arn(&self) -> std::option::Option<&str> {
        self.firewall_arn.as_deref()
    }
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    pub fn firewall_name(&self) -> std::option::Option<&str> {
        self.firewall_name.as_deref()
    }
    /// <p>A setting indicating whether the firewall is protected against changes to the subnet associations. Use this setting to protect against accidentally modifying the subnet associations for a firewall that is in use. When you create a firewall, the operation initializes this setting to <code>TRUE</code>.</p>
    pub fn subnet_change_protection(&self) -> bool {
        self.subnet_change_protection
    }
}
impl aws_http::request_id::RequestId for UpdateSubnetChangeProtectionOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`UpdateSubnetChangeProtectionOutput`](crate::output::UpdateSubnetChangeProtectionOutput).
pub mod update_subnet_change_protection_output {

    /// A builder for [`UpdateSubnetChangeProtectionOutput`](crate::output::UpdateSubnetChangeProtectionOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) update_token: std::option::Option<std::string::String>,
        pub(crate) firewall_arn: std::option::Option<std::string::String>,
        pub(crate) firewall_name: std::option::Option<std::string::String>,
        pub(crate) subnet_change_protection: std::option::Option<bool>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
        /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
        /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.update_token = Some(input.into());
            self
        }
        /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
        /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
        /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn set_update_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.update_token = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        pub fn firewall_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        pub fn set_firewall_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.firewall_arn = input;
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        pub fn firewall_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_name = Some(input.into());
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        pub fn set_firewall_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.firewall_name = input;
            self
        }
        /// <p>A setting indicating whether the firewall is protected against changes to the subnet associations. Use this setting to protect against accidentally modifying the subnet associations for a firewall that is in use. When you create a firewall, the operation initializes this setting to <code>TRUE</code>.</p>
        pub fn subnet_change_protection(mut self, input: bool) -> Self {
            self.subnet_change_protection = Some(input);
            self
        }
        /// <p>A setting indicating whether the firewall is protected against changes to the subnet associations. Use this setting to protect against accidentally modifying the subnet associations for a firewall that is in use. When you create a firewall, the operation initializes this setting to <code>TRUE</code>.</p>
        pub fn set_subnet_change_protection(mut self, input: std::option::Option<bool>) -> Self {
            self.subnet_change_protection = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`UpdateSubnetChangeProtectionOutput`](crate::output::UpdateSubnetChangeProtectionOutput).
        pub fn build(self) -> crate::output::UpdateSubnetChangeProtectionOutput {
            crate::output::UpdateSubnetChangeProtectionOutput {
                update_token: self.update_token,
                firewall_arn: self.firewall_arn,
                firewall_name: self.firewall_name,
                subnet_change_protection: self.subnet_change_protection.unwrap_or_default(),
                _request_id: self._request_id,
            }
        }
    }
}
impl UpdateSubnetChangeProtectionOutput {
    /// Creates a new builder-style object to manufacture [`UpdateSubnetChangeProtectionOutput`](crate::output::UpdateSubnetChangeProtectionOutput).
    pub fn builder() -> crate::output::update_subnet_change_protection_output::Builder {
        crate::output::update_subnet_change_protection_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateRuleGroupOutput {
    /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the rule group. The token marks the state of the rule group resource at the time of the request. </p>
    /// <p>To make changes to the rule group, you provide the token in your request. Network Firewall uses the token to ensure that the rule group hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the rule group again to get a current copy of it with a current token. Reapply your changes as needed, then try the operation again using the new token. </p>
    #[doc(hidden)]
    pub update_token: std::option::Option<std::string::String>,
    /// <p>The high-level properties of a rule group. This, along with the <code>RuleGroup</code>, define the rule group. You can retrieve all objects for a rule group by calling <code>DescribeRuleGroup</code>. </p>
    #[doc(hidden)]
    pub rule_group_response: std::option::Option<crate::model::RuleGroupResponse>,
    _request_id: Option<String>,
}
impl UpdateRuleGroupOutput {
    /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the rule group. The token marks the state of the rule group resource at the time of the request. </p>
    /// <p>To make changes to the rule group, you provide the token in your request. Network Firewall uses the token to ensure that the rule group hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the rule group again to get a current copy of it with a current token. Reapply your changes as needed, then try the operation again using the new token. </p>
    pub fn update_token(&self) -> std::option::Option<&str> {
        self.update_token.as_deref()
    }
    /// <p>The high-level properties of a rule group. This, along with the <code>RuleGroup</code>, define the rule group. You can retrieve all objects for a rule group by calling <code>DescribeRuleGroup</code>. </p>
    pub fn rule_group_response(&self) -> std::option::Option<&crate::model::RuleGroupResponse> {
        self.rule_group_response.as_ref()
    }
}
impl aws_http::request_id::RequestId for UpdateRuleGroupOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`UpdateRuleGroupOutput`](crate::output::UpdateRuleGroupOutput).
pub mod update_rule_group_output {

    /// A builder for [`UpdateRuleGroupOutput`](crate::output::UpdateRuleGroupOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) update_token: std::option::Option<std::string::String>,
        pub(crate) rule_group_response: std::option::Option<crate::model::RuleGroupResponse>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the rule group. The token marks the state of the rule group resource at the time of the request. </p>
        /// <p>To make changes to the rule group, you provide the token in your request. Network Firewall uses the token to ensure that the rule group hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the rule group again to get a current copy of it with a current token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.update_token = Some(input.into());
            self
        }
        /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the rule group. The token marks the state of the rule group resource at the time of the request. </p>
        /// <p>To make changes to the rule group, you provide the token in your request. Network Firewall uses the token to ensure that the rule group hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the rule group again to get a current copy of it with a current token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn set_update_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.update_token = input;
            self
        }
        /// <p>The high-level properties of a rule group. This, along with the <code>RuleGroup</code>, define the rule group. You can retrieve all objects for a rule group by calling <code>DescribeRuleGroup</code>. </p>
        pub fn rule_group_response(mut self, input: crate::model::RuleGroupResponse) -> Self {
            self.rule_group_response = Some(input);
            self
        }
        /// <p>The high-level properties of a rule group. This, along with the <code>RuleGroup</code>, define the rule group. You can retrieve all objects for a rule group by calling <code>DescribeRuleGroup</code>. </p>
        pub fn set_rule_group_response(
            mut self,
            input: std::option::Option<crate::model::RuleGroupResponse>,
        ) -> Self {
            self.rule_group_response = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`UpdateRuleGroupOutput`](crate::output::UpdateRuleGroupOutput).
        pub fn build(self) -> crate::output::UpdateRuleGroupOutput {
            crate::output::UpdateRuleGroupOutput {
                update_token: self.update_token,
                rule_group_response: self.rule_group_response,
                _request_id: self._request_id,
            }
        }
    }
}
impl UpdateRuleGroupOutput {
    /// Creates a new builder-style object to manufacture [`UpdateRuleGroupOutput`](crate::output::UpdateRuleGroupOutput).
    pub fn builder() -> crate::output::update_rule_group_output::Builder {
        crate::output::update_rule_group_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateLoggingConfigurationOutput {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    #[doc(hidden)]
    pub firewall_arn: std::option::Option<std::string::String>,
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    #[doc(hidden)]
    pub firewall_name: std::option::Option<std::string::String>,
    /// <p>Defines how Network Firewall performs logging for a <code>Firewall</code>. </p>
    #[doc(hidden)]
    pub logging_configuration: std::option::Option<crate::model::LoggingConfiguration>,
    _request_id: Option<String>,
}
impl UpdateLoggingConfigurationOutput {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    pub fn firewall_arn(&self) -> std::option::Option<&str> {
        self.firewall_arn.as_deref()
    }
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    pub fn firewall_name(&self) -> std::option::Option<&str> {
        self.firewall_name.as_deref()
    }
    /// <p>Defines how Network Firewall performs logging for a <code>Firewall</code>. </p>
    pub fn logging_configuration(
        &self,
    ) -> std::option::Option<&crate::model::LoggingConfiguration> {
        self.logging_configuration.as_ref()
    }
}
impl aws_http::request_id::RequestId for UpdateLoggingConfigurationOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`UpdateLoggingConfigurationOutput`](crate::output::UpdateLoggingConfigurationOutput).
pub mod update_logging_configuration_output {

    /// A builder for [`UpdateLoggingConfigurationOutput`](crate::output::UpdateLoggingConfigurationOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) firewall_arn: std::option::Option<std::string::String>,
        pub(crate) firewall_name: std::option::Option<std::string::String>,
        pub(crate) logging_configuration: std::option::Option<crate::model::LoggingConfiguration>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        pub fn firewall_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        pub fn set_firewall_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.firewall_arn = input;
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        pub fn firewall_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_name = Some(input.into());
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        pub fn set_firewall_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.firewall_name = input;
            self
        }
        /// <p>Defines how Network Firewall performs logging for a <code>Firewall</code>. </p>
        pub fn logging_configuration(mut self, input: crate::model::LoggingConfiguration) -> Self {
            self.logging_configuration = Some(input);
            self
        }
        /// <p>Defines how Network Firewall performs logging for a <code>Firewall</code>. </p>
        pub fn set_logging_configuration(
            mut self,
            input: std::option::Option<crate::model::LoggingConfiguration>,
        ) -> Self {
            self.logging_configuration = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`UpdateLoggingConfigurationOutput`](crate::output::UpdateLoggingConfigurationOutput).
        pub fn build(self) -> crate::output::UpdateLoggingConfigurationOutput {
            crate::output::UpdateLoggingConfigurationOutput {
                firewall_arn: self.firewall_arn,
                firewall_name: self.firewall_name,
                logging_configuration: self.logging_configuration,
                _request_id: self._request_id,
            }
        }
    }
}
impl UpdateLoggingConfigurationOutput {
    /// Creates a new builder-style object to manufacture [`UpdateLoggingConfigurationOutput`](crate::output::UpdateLoggingConfigurationOutput).
    pub fn builder() -> crate::output::update_logging_configuration_output::Builder {
        crate::output::update_logging_configuration_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateFirewallPolicyChangeProtectionOutput {
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    #[doc(hidden)]
    pub update_token: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    #[doc(hidden)]
    pub firewall_arn: std::option::Option<std::string::String>,
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    #[doc(hidden)]
    pub firewall_name: std::option::Option<std::string::String>,
    /// <p>A setting indicating whether the firewall is protected against a change to the firewall policy association. Use this setting to protect against accidentally modifying the firewall policy for a firewall that is in use. When you create a firewall, the operation initializes this setting to <code>TRUE</code>.</p>
    #[doc(hidden)]
    pub firewall_policy_change_protection: bool,
    _request_id: Option<String>,
}
impl UpdateFirewallPolicyChangeProtectionOutput {
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    pub fn update_token(&self) -> std::option::Option<&str> {
        self.update_token.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    pub fn firewall_arn(&self) -> std::option::Option<&str> {
        self.firewall_arn.as_deref()
    }
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    pub fn firewall_name(&self) -> std::option::Option<&str> {
        self.firewall_name.as_deref()
    }
    /// <p>A setting indicating whether the firewall is protected against a change to the firewall policy association. Use this setting to protect against accidentally modifying the firewall policy for a firewall that is in use. When you create a firewall, the operation initializes this setting to <code>TRUE</code>.</p>
    pub fn firewall_policy_change_protection(&self) -> bool {
        self.firewall_policy_change_protection
    }
}
impl aws_http::request_id::RequestId for UpdateFirewallPolicyChangeProtectionOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`UpdateFirewallPolicyChangeProtectionOutput`](crate::output::UpdateFirewallPolicyChangeProtectionOutput).
pub mod update_firewall_policy_change_protection_output {

    /// A builder for [`UpdateFirewallPolicyChangeProtectionOutput`](crate::output::UpdateFirewallPolicyChangeProtectionOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) update_token: std::option::Option<std::string::String>,
        pub(crate) firewall_arn: std::option::Option<std::string::String>,
        pub(crate) firewall_name: std::option::Option<std::string::String>,
        pub(crate) firewall_policy_change_protection: std::option::Option<bool>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
        /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
        /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.update_token = Some(input.into());
            self
        }
        /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
        /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
        /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn set_update_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.update_token = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        pub fn firewall_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        pub fn set_firewall_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.firewall_arn = input;
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        pub fn firewall_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_name = Some(input.into());
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        pub fn set_firewall_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.firewall_name = input;
            self
        }
        /// <p>A setting indicating whether the firewall is protected against a change to the firewall policy association. Use this setting to protect against accidentally modifying the firewall policy for a firewall that is in use. When you create a firewall, the operation initializes this setting to <code>TRUE</code>.</p>
        pub fn firewall_policy_change_protection(mut self, input: bool) -> Self {
            self.firewall_policy_change_protection = Some(input);
            self
        }
        /// <p>A setting indicating whether the firewall is protected against a change to the firewall policy association. Use this setting to protect against accidentally modifying the firewall policy for a firewall that is in use. When you create a firewall, the operation initializes this setting to <code>TRUE</code>.</p>
        pub fn set_firewall_policy_change_protection(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.firewall_policy_change_protection = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`UpdateFirewallPolicyChangeProtectionOutput`](crate::output::UpdateFirewallPolicyChangeProtectionOutput).
        pub fn build(self) -> crate::output::UpdateFirewallPolicyChangeProtectionOutput {
            crate::output::UpdateFirewallPolicyChangeProtectionOutput {
                update_token: self.update_token,
                firewall_arn: self.firewall_arn,
                firewall_name: self.firewall_name,
                firewall_policy_change_protection: self
                    .firewall_policy_change_protection
                    .unwrap_or_default(),
                _request_id: self._request_id,
            }
        }
    }
}
impl UpdateFirewallPolicyChangeProtectionOutput {
    /// Creates a new builder-style object to manufacture [`UpdateFirewallPolicyChangeProtectionOutput`](crate::output::UpdateFirewallPolicyChangeProtectionOutput).
    pub fn builder() -> crate::output::update_firewall_policy_change_protection_output::Builder {
        crate::output::update_firewall_policy_change_protection_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateFirewallPolicyOutput {
    /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the firewall policy. The token marks the state of the policy resource at the time of the request. </p>
    /// <p>To make changes to the policy, you provide the token in your request. Network Firewall uses the token to ensure that the policy hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall policy again to get a current copy of it with current token. Reapply your changes as needed, then try the operation again using the new token. </p>
    #[doc(hidden)]
    pub update_token: std::option::Option<std::string::String>,
    /// <p>The high-level properties of a firewall policy. This, along with the <code>FirewallPolicy</code>, define the policy. You can retrieve all objects for a firewall policy by calling <code>DescribeFirewallPolicy</code>. </p>
    #[doc(hidden)]
    pub firewall_policy_response: std::option::Option<crate::model::FirewallPolicyResponse>,
    _request_id: Option<String>,
}
impl UpdateFirewallPolicyOutput {
    /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the firewall policy. The token marks the state of the policy resource at the time of the request. </p>
    /// <p>To make changes to the policy, you provide the token in your request. Network Firewall uses the token to ensure that the policy hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall policy again to get a current copy of it with current token. Reapply your changes as needed, then try the operation again using the new token. </p>
    pub fn update_token(&self) -> std::option::Option<&str> {
        self.update_token.as_deref()
    }
    /// <p>The high-level properties of a firewall policy. This, along with the <code>FirewallPolicy</code>, define the policy. You can retrieve all objects for a firewall policy by calling <code>DescribeFirewallPolicy</code>. </p>
    pub fn firewall_policy_response(
        &self,
    ) -> std::option::Option<&crate::model::FirewallPolicyResponse> {
        self.firewall_policy_response.as_ref()
    }
}
impl aws_http::request_id::RequestId for UpdateFirewallPolicyOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`UpdateFirewallPolicyOutput`](crate::output::UpdateFirewallPolicyOutput).
pub mod update_firewall_policy_output {

    /// A builder for [`UpdateFirewallPolicyOutput`](crate::output::UpdateFirewallPolicyOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) update_token: std::option::Option<std::string::String>,
        pub(crate) firewall_policy_response:
            std::option::Option<crate::model::FirewallPolicyResponse>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the firewall policy. The token marks the state of the policy resource at the time of the request. </p>
        /// <p>To make changes to the policy, you provide the token in your request. Network Firewall uses the token to ensure that the policy hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall policy again to get a current copy of it with current token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.update_token = Some(input.into());
            self
        }
        /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the firewall policy. The token marks the state of the policy resource at the time of the request. </p>
        /// <p>To make changes to the policy, you provide the token in your request. Network Firewall uses the token to ensure that the policy hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall policy again to get a current copy of it with current token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn set_update_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.update_token = input;
            self
        }
        /// <p>The high-level properties of a firewall policy. This, along with the <code>FirewallPolicy</code>, define the policy. You can retrieve all objects for a firewall policy by calling <code>DescribeFirewallPolicy</code>. </p>
        pub fn firewall_policy_response(
            mut self,
            input: crate::model::FirewallPolicyResponse,
        ) -> Self {
            self.firewall_policy_response = Some(input);
            self
        }
        /// <p>The high-level properties of a firewall policy. This, along with the <code>FirewallPolicy</code>, define the policy. You can retrieve all objects for a firewall policy by calling <code>DescribeFirewallPolicy</code>. </p>
        pub fn set_firewall_policy_response(
            mut self,
            input: std::option::Option<crate::model::FirewallPolicyResponse>,
        ) -> Self {
            self.firewall_policy_response = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`UpdateFirewallPolicyOutput`](crate::output::UpdateFirewallPolicyOutput).
        pub fn build(self) -> crate::output::UpdateFirewallPolicyOutput {
            crate::output::UpdateFirewallPolicyOutput {
                update_token: self.update_token,
                firewall_policy_response: self.firewall_policy_response,
                _request_id: self._request_id,
            }
        }
    }
}
impl UpdateFirewallPolicyOutput {
    /// Creates a new builder-style object to manufacture [`UpdateFirewallPolicyOutput`](crate::output::UpdateFirewallPolicyOutput).
    pub fn builder() -> crate::output::update_firewall_policy_output::Builder {
        crate::output::update_firewall_policy_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateFirewallEncryptionConfigurationOutput {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    #[doc(hidden)]
    pub firewall_arn: std::option::Option<std::string::String>,
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    #[doc(hidden)]
    pub firewall_name: std::option::Option<std::string::String>,
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    #[doc(hidden)]
    pub update_token: std::option::Option<std::string::String>,
    /// <p>A complex type that contains optional Amazon Web Services Key Management Service (KMS) encryption settings for your Network Firewall resources. Your data is encrypted by default with an Amazon Web Services owned key that Amazon Web Services owns and manages for you. You can use either the Amazon Web Services owned key, or provide your own customer managed key. To learn more about KMS encryption of your Network Firewall resources, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/kms-encryption-at-rest.html">Encryption at rest with Amazon Web Services Key Managment Service</a> in the <i>Network Firewall Developer Guide</i>.</p>
    #[doc(hidden)]
    pub encryption_configuration: std::option::Option<crate::model::EncryptionConfiguration>,
    _request_id: Option<String>,
}
impl UpdateFirewallEncryptionConfigurationOutput {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    pub fn firewall_arn(&self) -> std::option::Option<&str> {
        self.firewall_arn.as_deref()
    }
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    pub fn firewall_name(&self) -> std::option::Option<&str> {
        self.firewall_name.as_deref()
    }
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    pub fn update_token(&self) -> std::option::Option<&str> {
        self.update_token.as_deref()
    }
    /// <p>A complex type that contains optional Amazon Web Services Key Management Service (KMS) encryption settings for your Network Firewall resources. Your data is encrypted by default with an Amazon Web Services owned key that Amazon Web Services owns and manages for you. You can use either the Amazon Web Services owned key, or provide your own customer managed key. To learn more about KMS encryption of your Network Firewall resources, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/kms-encryption-at-rest.html">Encryption at rest with Amazon Web Services Key Managment Service</a> in the <i>Network Firewall Developer Guide</i>.</p>
    pub fn encryption_configuration(
        &self,
    ) -> std::option::Option<&crate::model::EncryptionConfiguration> {
        self.encryption_configuration.as_ref()
    }
}
impl aws_http::request_id::RequestId for UpdateFirewallEncryptionConfigurationOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`UpdateFirewallEncryptionConfigurationOutput`](crate::output::UpdateFirewallEncryptionConfigurationOutput).
pub mod update_firewall_encryption_configuration_output {

    /// A builder for [`UpdateFirewallEncryptionConfigurationOutput`](crate::output::UpdateFirewallEncryptionConfigurationOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) firewall_arn: std::option::Option<std::string::String>,
        pub(crate) firewall_name: std::option::Option<std::string::String>,
        pub(crate) update_token: std::option::Option<std::string::String>,
        pub(crate) encryption_configuration:
            std::option::Option<crate::model::EncryptionConfiguration>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        pub fn firewall_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        pub fn set_firewall_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.firewall_arn = input;
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        pub fn firewall_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_name = Some(input.into());
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        pub fn set_firewall_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.firewall_name = input;
            self
        }
        /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
        /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
        /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.update_token = Some(input.into());
            self
        }
        /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
        /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
        /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn set_update_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.update_token = input;
            self
        }
        /// <p>A complex type that contains optional Amazon Web Services Key Management Service (KMS) encryption settings for your Network Firewall resources. Your data is encrypted by default with an Amazon Web Services owned key that Amazon Web Services owns and manages for you. You can use either the Amazon Web Services owned key, or provide your own customer managed key. To learn more about KMS encryption of your Network Firewall resources, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/kms-encryption-at-rest.html">Encryption at rest with Amazon Web Services Key Managment Service</a> in the <i>Network Firewall Developer Guide</i>.</p>
        pub fn encryption_configuration(
            mut self,
            input: crate::model::EncryptionConfiguration,
        ) -> Self {
            self.encryption_configuration = Some(input);
            self
        }
        /// <p>A complex type that contains optional Amazon Web Services Key Management Service (KMS) encryption settings for your Network Firewall resources. Your data is encrypted by default with an Amazon Web Services owned key that Amazon Web Services owns and manages for you. You can use either the Amazon Web Services owned key, or provide your own customer managed key. To learn more about KMS encryption of your Network Firewall resources, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/kms-encryption-at-rest.html">Encryption at rest with Amazon Web Services Key Managment Service</a> in the <i>Network Firewall Developer Guide</i>.</p>
        pub fn set_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::EncryptionConfiguration>,
        ) -> Self {
            self.encryption_configuration = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`UpdateFirewallEncryptionConfigurationOutput`](crate::output::UpdateFirewallEncryptionConfigurationOutput).
        pub fn build(self) -> crate::output::UpdateFirewallEncryptionConfigurationOutput {
            crate::output::UpdateFirewallEncryptionConfigurationOutput {
                firewall_arn: self.firewall_arn,
                firewall_name: self.firewall_name,
                update_token: self.update_token,
                encryption_configuration: self.encryption_configuration,
                _request_id: self._request_id,
            }
        }
    }
}
impl UpdateFirewallEncryptionConfigurationOutput {
    /// Creates a new builder-style object to manufacture [`UpdateFirewallEncryptionConfigurationOutput`](crate::output::UpdateFirewallEncryptionConfigurationOutput).
    pub fn builder() -> crate::output::update_firewall_encryption_configuration_output::Builder {
        crate::output::update_firewall_encryption_configuration_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateFirewallDescriptionOutput {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    #[doc(hidden)]
    pub firewall_arn: std::option::Option<std::string::String>,
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    #[doc(hidden)]
    pub firewall_name: std::option::Option<std::string::String>,
    /// <p>A description of the firewall.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    #[doc(hidden)]
    pub update_token: std::option::Option<std::string::String>,
    _request_id: Option<String>,
}
impl UpdateFirewallDescriptionOutput {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    pub fn firewall_arn(&self) -> std::option::Option<&str> {
        self.firewall_arn.as_deref()
    }
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    pub fn firewall_name(&self) -> std::option::Option<&str> {
        self.firewall_name.as_deref()
    }
    /// <p>A description of the firewall.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    pub fn update_token(&self) -> std::option::Option<&str> {
        self.update_token.as_deref()
    }
}
impl aws_http::request_id::RequestId for UpdateFirewallDescriptionOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`UpdateFirewallDescriptionOutput`](crate::output::UpdateFirewallDescriptionOutput).
pub mod update_firewall_description_output {

    /// A builder for [`UpdateFirewallDescriptionOutput`](crate::output::UpdateFirewallDescriptionOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) firewall_arn: std::option::Option<std::string::String>,
        pub(crate) firewall_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) update_token: std::option::Option<std::string::String>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        pub fn firewall_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        pub fn set_firewall_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.firewall_arn = input;
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        pub fn firewall_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_name = Some(input.into());
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        pub fn set_firewall_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.firewall_name = input;
            self
        }
        /// <p>A description of the firewall.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the firewall.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
        /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
        /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.update_token = Some(input.into());
            self
        }
        /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
        /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
        /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn set_update_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.update_token = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`UpdateFirewallDescriptionOutput`](crate::output::UpdateFirewallDescriptionOutput).
        pub fn build(self) -> crate::output::UpdateFirewallDescriptionOutput {
            crate::output::UpdateFirewallDescriptionOutput {
                firewall_arn: self.firewall_arn,
                firewall_name: self.firewall_name,
                description: self.description,
                update_token: self.update_token,
                _request_id: self._request_id,
            }
        }
    }
}
impl UpdateFirewallDescriptionOutput {
    /// Creates a new builder-style object to manufacture [`UpdateFirewallDescriptionOutput`](crate::output::UpdateFirewallDescriptionOutput).
    pub fn builder() -> crate::output::update_firewall_description_output::Builder {
        crate::output::update_firewall_description_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateFirewallDeleteProtectionOutput {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    #[doc(hidden)]
    pub firewall_arn: std::option::Option<std::string::String>,
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    #[doc(hidden)]
    pub firewall_name: std::option::Option<std::string::String>,
    /// <p>A flag indicating whether it is possible to delete the firewall. A setting of <code>TRUE</code> indicates that the firewall is protected against deletion. Use this setting to protect against accidentally deleting a firewall that is in use. When you create a firewall, the operation initializes this flag to <code>TRUE</code>.</p>
    #[doc(hidden)]
    pub delete_protection: bool,
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    #[doc(hidden)]
    pub update_token: std::option::Option<std::string::String>,
    _request_id: Option<String>,
}
impl UpdateFirewallDeleteProtectionOutput {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    pub fn firewall_arn(&self) -> std::option::Option<&str> {
        self.firewall_arn.as_deref()
    }
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    pub fn firewall_name(&self) -> std::option::Option<&str> {
        self.firewall_name.as_deref()
    }
    /// <p>A flag indicating whether it is possible to delete the firewall. A setting of <code>TRUE</code> indicates that the firewall is protected against deletion. Use this setting to protect against accidentally deleting a firewall that is in use. When you create a firewall, the operation initializes this flag to <code>TRUE</code>.</p>
    pub fn delete_protection(&self) -> bool {
        self.delete_protection
    }
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    pub fn update_token(&self) -> std::option::Option<&str> {
        self.update_token.as_deref()
    }
}
impl aws_http::request_id::RequestId for UpdateFirewallDeleteProtectionOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`UpdateFirewallDeleteProtectionOutput`](crate::output::UpdateFirewallDeleteProtectionOutput).
pub mod update_firewall_delete_protection_output {

    /// A builder for [`UpdateFirewallDeleteProtectionOutput`](crate::output::UpdateFirewallDeleteProtectionOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) firewall_arn: std::option::Option<std::string::String>,
        pub(crate) firewall_name: std::option::Option<std::string::String>,
        pub(crate) delete_protection: std::option::Option<bool>,
        pub(crate) update_token: std::option::Option<std::string::String>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        pub fn firewall_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        pub fn set_firewall_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.firewall_arn = input;
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        pub fn firewall_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_name = Some(input.into());
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        pub fn set_firewall_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.firewall_name = input;
            self
        }
        /// <p>A flag indicating whether it is possible to delete the firewall. A setting of <code>TRUE</code> indicates that the firewall is protected against deletion. Use this setting to protect against accidentally deleting a firewall that is in use. When you create a firewall, the operation initializes this flag to <code>TRUE</code>.</p>
        pub fn delete_protection(mut self, input: bool) -> Self {
            self.delete_protection = Some(input);
            self
        }
        /// <p>A flag indicating whether it is possible to delete the firewall. A setting of <code>TRUE</code> indicates that the firewall is protected against deletion. Use this setting to protect against accidentally deleting a firewall that is in use. When you create a firewall, the operation initializes this flag to <code>TRUE</code>.</p>
        pub fn set_delete_protection(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_protection = input;
            self
        }
        /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
        /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
        /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.update_token = Some(input.into());
            self
        }
        /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
        /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
        /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn set_update_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.update_token = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`UpdateFirewallDeleteProtectionOutput`](crate::output::UpdateFirewallDeleteProtectionOutput).
        pub fn build(self) -> crate::output::UpdateFirewallDeleteProtectionOutput {
            crate::output::UpdateFirewallDeleteProtectionOutput {
                firewall_arn: self.firewall_arn,
                firewall_name: self.firewall_name,
                delete_protection: self.delete_protection.unwrap_or_default(),
                update_token: self.update_token,
                _request_id: self._request_id,
            }
        }
    }
}
impl UpdateFirewallDeleteProtectionOutput {
    /// Creates a new builder-style object to manufacture [`UpdateFirewallDeleteProtectionOutput`](crate::output::UpdateFirewallDeleteProtectionOutput).
    pub fn builder() -> crate::output::update_firewall_delete_protection_output::Builder {
        crate::output::update_firewall_delete_protection_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UntagResourceOutput {
    _request_id: Option<String>,
}
impl aws_http::request_id::RequestId for UntagResourceOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`UntagResourceOutput`](crate::output::UntagResourceOutput).
pub mod untag_resource_output {

    /// A builder for [`UntagResourceOutput`](crate::output::UntagResourceOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        _request_id: Option<String>,
    }
    impl Builder {
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceOutput`](crate::output::UntagResourceOutput).
        pub fn build(self) -> crate::output::UntagResourceOutput {
            crate::output::UntagResourceOutput {
                _request_id: self._request_id,
            }
        }
    }
}
impl UntagResourceOutput {
    /// Creates a new builder-style object to manufacture [`UntagResourceOutput`](crate::output::UntagResourceOutput).
    pub fn builder() -> crate::output::untag_resource_output::Builder {
        crate::output::untag_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagResourceOutput {
    _request_id: Option<String>,
}
impl aws_http::request_id::RequestId for TagResourceOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`TagResourceOutput`](crate::output::TagResourceOutput).
pub mod tag_resource_output {

    /// A builder for [`TagResourceOutput`](crate::output::TagResourceOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        _request_id: Option<String>,
    }
    impl Builder {
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceOutput`](crate::output::TagResourceOutput).
        pub fn build(self) -> crate::output::TagResourceOutput {
            crate::output::TagResourceOutput {
                _request_id: self._request_id,
            }
        }
    }
}
impl TagResourceOutput {
    /// Creates a new builder-style object to manufacture [`TagResourceOutput`](crate::output::TagResourceOutput).
    pub fn builder() -> crate::output::tag_resource_output::Builder {
        crate::output::tag_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PutResourcePolicyOutput {
    _request_id: Option<String>,
}
impl aws_http::request_id::RequestId for PutResourcePolicyOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`PutResourcePolicyOutput`](crate::output::PutResourcePolicyOutput).
pub mod put_resource_policy_output {

    /// A builder for [`PutResourcePolicyOutput`](crate::output::PutResourcePolicyOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        _request_id: Option<String>,
    }
    impl Builder {
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`PutResourcePolicyOutput`](crate::output::PutResourcePolicyOutput).
        pub fn build(self) -> crate::output::PutResourcePolicyOutput {
            crate::output::PutResourcePolicyOutput {
                _request_id: self._request_id,
            }
        }
    }
}
impl PutResourcePolicyOutput {
    /// Creates a new builder-style object to manufacture [`PutResourcePolicyOutput`](crate::output::PutResourcePolicyOutput).
    pub fn builder() -> crate::output::put_resource_policy_output::Builder {
        crate::output::put_resource_policy_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListTagsForResourceOutput {
    /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code> value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The tags that are associated with the resource. </p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    _request_id: Option<String>,
}
impl ListTagsForResourceOutput {
    /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code> value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The tags that are associated with the resource. </p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl aws_http::request_id::RequestId for ListTagsForResourceOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput).
pub mod list_tags_for_resource_output {

    /// A builder for [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code> value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code> value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags that are associated with the resource. </p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tags that are associated with the resource. </p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput).
        pub fn build(self) -> crate::output::ListTagsForResourceOutput {
            crate::output::ListTagsForResourceOutput {
                next_token: self.next_token,
                tags: self.tags,
                _request_id: self._request_id,
            }
        }
    }
}
impl ListTagsForResourceOutput {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput).
    pub fn builder() -> crate::output::list_tags_for_resource_output::Builder {
        crate::output::list_tags_for_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListRuleGroupsOutput {
    /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code> value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The rule group metadata objects that you've defined. Depending on your setting for max results and the number of rule groups, this might not be the full list. </p>
    #[doc(hidden)]
    pub rule_groups: std::option::Option<std::vec::Vec<crate::model::RuleGroupMetadata>>,
    _request_id: Option<String>,
}
impl ListRuleGroupsOutput {
    /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code> value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The rule group metadata objects that you've defined. Depending on your setting for max results and the number of rule groups, this might not be the full list. </p>
    pub fn rule_groups(&self) -> std::option::Option<&[crate::model::RuleGroupMetadata]> {
        self.rule_groups.as_deref()
    }
}
impl aws_http::request_id::RequestId for ListRuleGroupsOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`ListRuleGroupsOutput`](crate::output::ListRuleGroupsOutput).
pub mod list_rule_groups_output {

    /// A builder for [`ListRuleGroupsOutput`](crate::output::ListRuleGroupsOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) rule_groups: std::option::Option<std::vec::Vec<crate::model::RuleGroupMetadata>>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code> value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code> value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Appends an item to `rule_groups`.
        ///
        /// To override the contents of this collection use [`set_rule_groups`](Self::set_rule_groups).
        ///
        /// <p>The rule group metadata objects that you've defined. Depending on your setting for max results and the number of rule groups, this might not be the full list. </p>
        pub fn rule_groups(mut self, input: crate::model::RuleGroupMetadata) -> Self {
            let mut v = self.rule_groups.unwrap_or_default();
            v.push(input);
            self.rule_groups = Some(v);
            self
        }
        /// <p>The rule group metadata objects that you've defined. Depending on your setting for max results and the number of rule groups, this might not be the full list. </p>
        pub fn set_rule_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RuleGroupMetadata>>,
        ) -> Self {
            self.rule_groups = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`ListRuleGroupsOutput`](crate::output::ListRuleGroupsOutput).
        pub fn build(self) -> crate::output::ListRuleGroupsOutput {
            crate::output::ListRuleGroupsOutput {
                next_token: self.next_token,
                rule_groups: self.rule_groups,
                _request_id: self._request_id,
            }
        }
    }
}
impl ListRuleGroupsOutput {
    /// Creates a new builder-style object to manufacture [`ListRuleGroupsOutput`](crate::output::ListRuleGroupsOutput).
    pub fn builder() -> crate::output::list_rule_groups_output::Builder {
        crate::output::list_rule_groups_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListFirewallsOutput {
    /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code> value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The firewall metadata objects for the VPCs that you specified. Depending on your setting for max results and the number of firewalls you have, a single call might not be the full list. </p>
    #[doc(hidden)]
    pub firewalls: std::option::Option<std::vec::Vec<crate::model::FirewallMetadata>>,
    _request_id: Option<String>,
}
impl ListFirewallsOutput {
    /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code> value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The firewall metadata objects for the VPCs that you specified. Depending on your setting for max results and the number of firewalls you have, a single call might not be the full list. </p>
    pub fn firewalls(&self) -> std::option::Option<&[crate::model::FirewallMetadata]> {
        self.firewalls.as_deref()
    }
}
impl aws_http::request_id::RequestId for ListFirewallsOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`ListFirewallsOutput`](crate::output::ListFirewallsOutput).
pub mod list_firewalls_output {

    /// A builder for [`ListFirewallsOutput`](crate::output::ListFirewallsOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) firewalls: std::option::Option<std::vec::Vec<crate::model::FirewallMetadata>>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code> value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code> value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Appends an item to `firewalls`.
        ///
        /// To override the contents of this collection use [`set_firewalls`](Self::set_firewalls).
        ///
        /// <p>The firewall metadata objects for the VPCs that you specified. Depending on your setting for max results and the number of firewalls you have, a single call might not be the full list. </p>
        pub fn firewalls(mut self, input: crate::model::FirewallMetadata) -> Self {
            let mut v = self.firewalls.unwrap_or_default();
            v.push(input);
            self.firewalls = Some(v);
            self
        }
        /// <p>The firewall metadata objects for the VPCs that you specified. Depending on your setting for max results and the number of firewalls you have, a single call might not be the full list. </p>
        pub fn set_firewalls(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FirewallMetadata>>,
        ) -> Self {
            self.firewalls = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`ListFirewallsOutput`](crate::output::ListFirewallsOutput).
        pub fn build(self) -> crate::output::ListFirewallsOutput {
            crate::output::ListFirewallsOutput {
                next_token: self.next_token,
                firewalls: self.firewalls,
                _request_id: self._request_id,
            }
        }
    }
}
impl ListFirewallsOutput {
    /// Creates a new builder-style object to manufacture [`ListFirewallsOutput`](crate::output::ListFirewallsOutput).
    pub fn builder() -> crate::output::list_firewalls_output::Builder {
        crate::output::list_firewalls_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListFirewallPoliciesOutput {
    /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code> value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The metadata for the firewall policies. Depending on your setting for max results and the number of firewall policies that you have, this might not be the full list. </p>
    #[doc(hidden)]
    pub firewall_policies: std::option::Option<std::vec::Vec<crate::model::FirewallPolicyMetadata>>,
    _request_id: Option<String>,
}
impl ListFirewallPoliciesOutput {
    /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code> value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The metadata for the firewall policies. Depending on your setting for max results and the number of firewall policies that you have, this might not be the full list. </p>
    pub fn firewall_policies(
        &self,
    ) -> std::option::Option<&[crate::model::FirewallPolicyMetadata]> {
        self.firewall_policies.as_deref()
    }
}
impl aws_http::request_id::RequestId for ListFirewallPoliciesOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`ListFirewallPoliciesOutput`](crate::output::ListFirewallPoliciesOutput).
pub mod list_firewall_policies_output {

    /// A builder for [`ListFirewallPoliciesOutput`](crate::output::ListFirewallPoliciesOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) firewall_policies:
            std::option::Option<std::vec::Vec<crate::model::FirewallPolicyMetadata>>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code> value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code> value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Appends an item to `firewall_policies`.
        ///
        /// To override the contents of this collection use [`set_firewall_policies`](Self::set_firewall_policies).
        ///
        /// <p>The metadata for the firewall policies. Depending on your setting for max results and the number of firewall policies that you have, this might not be the full list. </p>
        pub fn firewall_policies(mut self, input: crate::model::FirewallPolicyMetadata) -> Self {
            let mut v = self.firewall_policies.unwrap_or_default();
            v.push(input);
            self.firewall_policies = Some(v);
            self
        }
        /// <p>The metadata for the firewall policies. Depending on your setting for max results and the number of firewall policies that you have, this might not be the full list. </p>
        pub fn set_firewall_policies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FirewallPolicyMetadata>>,
        ) -> Self {
            self.firewall_policies = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`ListFirewallPoliciesOutput`](crate::output::ListFirewallPoliciesOutput).
        pub fn build(self) -> crate::output::ListFirewallPoliciesOutput {
            crate::output::ListFirewallPoliciesOutput {
                next_token: self.next_token,
                firewall_policies: self.firewall_policies,
                _request_id: self._request_id,
            }
        }
    }
}
impl ListFirewallPoliciesOutput {
    /// Creates a new builder-style object to manufacture [`ListFirewallPoliciesOutput`](crate::output::ListFirewallPoliciesOutput).
    pub fn builder() -> crate::output::list_firewall_policies_output::Builder {
        crate::output::list_firewall_policies_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociateSubnetsOutput {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    #[doc(hidden)]
    pub firewall_arn: std::option::Option<std::string::String>,
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    #[doc(hidden)]
    pub firewall_name: std::option::Option<std::string::String>,
    /// <p>The IDs of the subnets that are associated with the firewall. </p>
    #[doc(hidden)]
    pub subnet_mappings: std::option::Option<std::vec::Vec<crate::model::SubnetMapping>>,
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    #[doc(hidden)]
    pub update_token: std::option::Option<std::string::String>,
    _request_id: Option<String>,
}
impl DisassociateSubnetsOutput {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    pub fn firewall_arn(&self) -> std::option::Option<&str> {
        self.firewall_arn.as_deref()
    }
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    pub fn firewall_name(&self) -> std::option::Option<&str> {
        self.firewall_name.as_deref()
    }
    /// <p>The IDs of the subnets that are associated with the firewall. </p>
    pub fn subnet_mappings(&self) -> std::option::Option<&[crate::model::SubnetMapping]> {
        self.subnet_mappings.as_deref()
    }
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    pub fn update_token(&self) -> std::option::Option<&str> {
        self.update_token.as_deref()
    }
}
impl aws_http::request_id::RequestId for DisassociateSubnetsOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`DisassociateSubnetsOutput`](crate::output::DisassociateSubnetsOutput).
pub mod disassociate_subnets_output {

    /// A builder for [`DisassociateSubnetsOutput`](crate::output::DisassociateSubnetsOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) firewall_arn: std::option::Option<std::string::String>,
        pub(crate) firewall_name: std::option::Option<std::string::String>,
        pub(crate) subnet_mappings: std::option::Option<std::vec::Vec<crate::model::SubnetMapping>>,
        pub(crate) update_token: std::option::Option<std::string::String>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        pub fn firewall_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        pub fn set_firewall_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.firewall_arn = input;
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        pub fn firewall_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_name = Some(input.into());
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        pub fn set_firewall_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.firewall_name = input;
            self
        }
        /// Appends an item to `subnet_mappings`.
        ///
        /// To override the contents of this collection use [`set_subnet_mappings`](Self::set_subnet_mappings).
        ///
        /// <p>The IDs of the subnets that are associated with the firewall. </p>
        pub fn subnet_mappings(mut self, input: crate::model::SubnetMapping) -> Self {
            let mut v = self.subnet_mappings.unwrap_or_default();
            v.push(input);
            self.subnet_mappings = Some(v);
            self
        }
        /// <p>The IDs of the subnets that are associated with the firewall. </p>
        pub fn set_subnet_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SubnetMapping>>,
        ) -> Self {
            self.subnet_mappings = input;
            self
        }
        /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
        /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
        /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.update_token = Some(input.into());
            self
        }
        /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
        /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
        /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn set_update_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.update_token = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateSubnetsOutput`](crate::output::DisassociateSubnetsOutput).
        pub fn build(self) -> crate::output::DisassociateSubnetsOutput {
            crate::output::DisassociateSubnetsOutput {
                firewall_arn: self.firewall_arn,
                firewall_name: self.firewall_name,
                subnet_mappings: self.subnet_mappings,
                update_token: self.update_token,
                _request_id: self._request_id,
            }
        }
    }
}
impl DisassociateSubnetsOutput {
    /// Creates a new builder-style object to manufacture [`DisassociateSubnetsOutput`](crate::output::DisassociateSubnetsOutput).
    pub fn builder() -> crate::output::disassociate_subnets_output::Builder {
        crate::output::disassociate_subnets_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeRuleGroupMetadataOutput {
    /// <p>The descriptive name of the rule group. You can't change the name of a rule group after you create it.</p>
    /// <p>You must specify the ARN or the name, and you can specify both. </p>
    #[doc(hidden)]
    pub rule_group_arn: std::option::Option<std::string::String>,
    /// <p>The descriptive name of the rule group. You can't change the name of a rule group after you create it.</p>
    /// <p>You must specify the ARN or the name, and you can specify both. </p>
    #[doc(hidden)]
    pub rule_group_name: std::option::Option<std::string::String>,
    /// <p>Returns the metadata objects for the specified rule group. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Indicates whether the rule group is stateless or stateful. If the rule group is stateless, it contains stateless rules. If it is stateful, it contains stateful rules. </p> <note>
    /// <p>This setting is required for requests that do not include the <code>RuleGroupARN</code>.</p>
    /// </note>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::RuleGroupType>,
    /// <p>The maximum operating resources that this rule group can use. Rule group capacity is fixed at creation. When you update a rule group, you are limited to this capacity. When you reference a rule group from a firewall policy, Network Firewall reserves this capacity for the rule group. </p>
    /// <p>You can retrieve the capacity that would be required for a rule group before you create the rule group by calling <code>CreateRuleGroup</code> with <code>DryRun</code> set to <code>TRUE</code>. </p>
    #[doc(hidden)]
    pub capacity: std::option::Option<i32>,
    /// <p>Additional options governing how Network Firewall handles the rule group. You can only use these for stateful rule groups.</p>
    #[doc(hidden)]
    pub stateful_rule_options: std::option::Option<crate::model::StatefulRuleOptions>,
    /// <p>The last time that the rule group was changed.</p>
    #[doc(hidden)]
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    _request_id: Option<String>,
}
impl DescribeRuleGroupMetadataOutput {
    /// <p>The descriptive name of the rule group. You can't change the name of a rule group after you create it.</p>
    /// <p>You must specify the ARN or the name, and you can specify both. </p>
    pub fn rule_group_arn(&self) -> std::option::Option<&str> {
        self.rule_group_arn.as_deref()
    }
    /// <p>The descriptive name of the rule group. You can't change the name of a rule group after you create it.</p>
    /// <p>You must specify the ARN or the name, and you can specify both. </p>
    pub fn rule_group_name(&self) -> std::option::Option<&str> {
        self.rule_group_name.as_deref()
    }
    /// <p>Returns the metadata objects for the specified rule group. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Indicates whether the rule group is stateless or stateful. If the rule group is stateless, it contains stateless rules. If it is stateful, it contains stateful rules. </p> <note>
    /// <p>This setting is required for requests that do not include the <code>RuleGroupARN</code>.</p>
    /// </note>
    pub fn r#type(&self) -> std::option::Option<&crate::model::RuleGroupType> {
        self.r#type.as_ref()
    }
    /// <p>The maximum operating resources that this rule group can use. Rule group capacity is fixed at creation. When you update a rule group, you are limited to this capacity. When you reference a rule group from a firewall policy, Network Firewall reserves this capacity for the rule group. </p>
    /// <p>You can retrieve the capacity that would be required for a rule group before you create the rule group by calling <code>CreateRuleGroup</code> with <code>DryRun</code> set to <code>TRUE</code>. </p>
    pub fn capacity(&self) -> std::option::Option<i32> {
        self.capacity
    }
    /// <p>Additional options governing how Network Firewall handles the rule group. You can only use these for stateful rule groups.</p>
    pub fn stateful_rule_options(&self) -> std::option::Option<&crate::model::StatefulRuleOptions> {
        self.stateful_rule_options.as_ref()
    }
    /// <p>The last time that the rule group was changed.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
}
impl aws_http::request_id::RequestId for DescribeRuleGroupMetadataOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`DescribeRuleGroupMetadataOutput`](crate::output::DescribeRuleGroupMetadataOutput).
pub mod describe_rule_group_metadata_output {

    /// A builder for [`DescribeRuleGroupMetadataOutput`](crate::output::DescribeRuleGroupMetadataOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_group_arn: std::option::Option<std::string::String>,
        pub(crate) rule_group_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::RuleGroupType>,
        pub(crate) capacity: std::option::Option<i32>,
        pub(crate) stateful_rule_options: std::option::Option<crate::model::StatefulRuleOptions>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>The descriptive name of the rule group. You can't change the name of a rule group after you create it.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn rule_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_group_arn = Some(input.into());
            self
        }
        /// <p>The descriptive name of the rule group. You can't change the name of a rule group after you create it.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn set_rule_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_group_arn = input;
            self
        }
        /// <p>The descriptive name of the rule group. You can't change the name of a rule group after you create it.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn rule_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_group_name = Some(input.into());
            self
        }
        /// <p>The descriptive name of the rule group. You can't change the name of a rule group after you create it.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn set_rule_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_group_name = input;
            self
        }
        /// <p>Returns the metadata objects for the specified rule group. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>Returns the metadata objects for the specified rule group. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Indicates whether the rule group is stateless or stateful. If the rule group is stateless, it contains stateless rules. If it is stateful, it contains stateful rules. </p> <note>
        /// <p>This setting is required for requests that do not include the <code>RuleGroupARN</code>.</p>
        /// </note>
        pub fn r#type(mut self, input: crate::model::RuleGroupType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Indicates whether the rule group is stateless or stateful. If the rule group is stateless, it contains stateless rules. If it is stateful, it contains stateful rules. </p> <note>
        /// <p>This setting is required for requests that do not include the <code>RuleGroupARN</code>.</p>
        /// </note>
        pub fn set_type(mut self, input: std::option::Option<crate::model::RuleGroupType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The maximum operating resources that this rule group can use. Rule group capacity is fixed at creation. When you update a rule group, you are limited to this capacity. When you reference a rule group from a firewall policy, Network Firewall reserves this capacity for the rule group. </p>
        /// <p>You can retrieve the capacity that would be required for a rule group before you create the rule group by calling <code>CreateRuleGroup</code> with <code>DryRun</code> set to <code>TRUE</code>. </p>
        pub fn capacity(mut self, input: i32) -> Self {
            self.capacity = Some(input);
            self
        }
        /// <p>The maximum operating resources that this rule group can use. Rule group capacity is fixed at creation. When you update a rule group, you are limited to this capacity. When you reference a rule group from a firewall policy, Network Firewall reserves this capacity for the rule group. </p>
        /// <p>You can retrieve the capacity that would be required for a rule group before you create the rule group by calling <code>CreateRuleGroup</code> with <code>DryRun</code> set to <code>TRUE</code>. </p>
        pub fn set_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.capacity = input;
            self
        }
        /// <p>Additional options governing how Network Firewall handles the rule group. You can only use these for stateful rule groups.</p>
        pub fn stateful_rule_options(mut self, input: crate::model::StatefulRuleOptions) -> Self {
            self.stateful_rule_options = Some(input);
            self
        }
        /// <p>Additional options governing how Network Firewall handles the rule group. You can only use these for stateful rule groups.</p>
        pub fn set_stateful_rule_options(
            mut self,
            input: std::option::Option<crate::model::StatefulRuleOptions>,
        ) -> Self {
            self.stateful_rule_options = input;
            self
        }
        /// <p>The last time that the rule group was changed.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The last time that the rule group was changed.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`DescribeRuleGroupMetadataOutput`](crate::output::DescribeRuleGroupMetadataOutput).
        pub fn build(self) -> crate::output::DescribeRuleGroupMetadataOutput {
            crate::output::DescribeRuleGroupMetadataOutput {
                rule_group_arn: self.rule_group_arn,
                rule_group_name: self.rule_group_name,
                description: self.description,
                r#type: self.r#type,
                capacity: self.capacity,
                stateful_rule_options: self.stateful_rule_options,
                last_modified_time: self.last_modified_time,
                _request_id: self._request_id,
            }
        }
    }
}
impl DescribeRuleGroupMetadataOutput {
    /// Creates a new builder-style object to manufacture [`DescribeRuleGroupMetadataOutput`](crate::output::DescribeRuleGroupMetadataOutput).
    pub fn builder() -> crate::output::describe_rule_group_metadata_output::Builder {
        crate::output::describe_rule_group_metadata_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeRuleGroupOutput {
    /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the rule group. The token marks the state of the rule group resource at the time of the request. </p>
    /// <p>To make changes to the rule group, you provide the token in your request. Network Firewall uses the token to ensure that the rule group hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the rule group again to get a current copy of it with a current token. Reapply your changes as needed, then try the operation again using the new token. </p>
    #[doc(hidden)]
    pub update_token: std::option::Option<std::string::String>,
    /// <p>The object that defines the rules in a rule group. This, along with <code>RuleGroupResponse</code>, define the rule group. You can retrieve all objects for a rule group by calling <code>DescribeRuleGroup</code>. </p>
    /// <p>Network Firewall uses a rule group to inspect and control network traffic. You define stateless rule groups to inspect individual packets and you define stateful rule groups to inspect packets in the context of their traffic flow. </p>
    /// <p>To use a rule group, you include it by reference in an Network Firewall firewall policy, then you use the policy in a firewall. You can reference a rule group from more than one firewall policy, and you can use a firewall policy in more than one firewall. </p>
    #[doc(hidden)]
    pub rule_group: std::option::Option<crate::model::RuleGroup>,
    /// <p>The high-level properties of a rule group. This, along with the <code>RuleGroup</code>, define the rule group. You can retrieve all objects for a rule group by calling <code>DescribeRuleGroup</code>. </p>
    #[doc(hidden)]
    pub rule_group_response: std::option::Option<crate::model::RuleGroupResponse>,
    _request_id: Option<String>,
}
impl DescribeRuleGroupOutput {
    /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the rule group. The token marks the state of the rule group resource at the time of the request. </p>
    /// <p>To make changes to the rule group, you provide the token in your request. Network Firewall uses the token to ensure that the rule group hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the rule group again to get a current copy of it with a current token. Reapply your changes as needed, then try the operation again using the new token. </p>
    pub fn update_token(&self) -> std::option::Option<&str> {
        self.update_token.as_deref()
    }
    /// <p>The object that defines the rules in a rule group. This, along with <code>RuleGroupResponse</code>, define the rule group. You can retrieve all objects for a rule group by calling <code>DescribeRuleGroup</code>. </p>
    /// <p>Network Firewall uses a rule group to inspect and control network traffic. You define stateless rule groups to inspect individual packets and you define stateful rule groups to inspect packets in the context of their traffic flow. </p>
    /// <p>To use a rule group, you include it by reference in an Network Firewall firewall policy, then you use the policy in a firewall. You can reference a rule group from more than one firewall policy, and you can use a firewall policy in more than one firewall. </p>
    pub fn rule_group(&self) -> std::option::Option<&crate::model::RuleGroup> {
        self.rule_group.as_ref()
    }
    /// <p>The high-level properties of a rule group. This, along with the <code>RuleGroup</code>, define the rule group. You can retrieve all objects for a rule group by calling <code>DescribeRuleGroup</code>. </p>
    pub fn rule_group_response(&self) -> std::option::Option<&crate::model::RuleGroupResponse> {
        self.rule_group_response.as_ref()
    }
}
impl aws_http::request_id::RequestId for DescribeRuleGroupOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`DescribeRuleGroupOutput`](crate::output::DescribeRuleGroupOutput).
pub mod describe_rule_group_output {

    /// A builder for [`DescribeRuleGroupOutput`](crate::output::DescribeRuleGroupOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) update_token: std::option::Option<std::string::String>,
        pub(crate) rule_group: std::option::Option<crate::model::RuleGroup>,
        pub(crate) rule_group_response: std::option::Option<crate::model::RuleGroupResponse>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the rule group. The token marks the state of the rule group resource at the time of the request. </p>
        /// <p>To make changes to the rule group, you provide the token in your request. Network Firewall uses the token to ensure that the rule group hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the rule group again to get a current copy of it with a current token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.update_token = Some(input.into());
            self
        }
        /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the rule group. The token marks the state of the rule group resource at the time of the request. </p>
        /// <p>To make changes to the rule group, you provide the token in your request. Network Firewall uses the token to ensure that the rule group hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the rule group again to get a current copy of it with a current token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn set_update_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.update_token = input;
            self
        }
        /// <p>The object that defines the rules in a rule group. This, along with <code>RuleGroupResponse</code>, define the rule group. You can retrieve all objects for a rule group by calling <code>DescribeRuleGroup</code>. </p>
        /// <p>Network Firewall uses a rule group to inspect and control network traffic. You define stateless rule groups to inspect individual packets and you define stateful rule groups to inspect packets in the context of their traffic flow. </p>
        /// <p>To use a rule group, you include it by reference in an Network Firewall firewall policy, then you use the policy in a firewall. You can reference a rule group from more than one firewall policy, and you can use a firewall policy in more than one firewall. </p>
        pub fn rule_group(mut self, input: crate::model::RuleGroup) -> Self {
            self.rule_group = Some(input);
            self
        }
        /// <p>The object that defines the rules in a rule group. This, along with <code>RuleGroupResponse</code>, define the rule group. You can retrieve all objects for a rule group by calling <code>DescribeRuleGroup</code>. </p>
        /// <p>Network Firewall uses a rule group to inspect and control network traffic. You define stateless rule groups to inspect individual packets and you define stateful rule groups to inspect packets in the context of their traffic flow. </p>
        /// <p>To use a rule group, you include it by reference in an Network Firewall firewall policy, then you use the policy in a firewall. You can reference a rule group from more than one firewall policy, and you can use a firewall policy in more than one firewall. </p>
        pub fn set_rule_group(
            mut self,
            input: std::option::Option<crate::model::RuleGroup>,
        ) -> Self {
            self.rule_group = input;
            self
        }
        /// <p>The high-level properties of a rule group. This, along with the <code>RuleGroup</code>, define the rule group. You can retrieve all objects for a rule group by calling <code>DescribeRuleGroup</code>. </p>
        pub fn rule_group_response(mut self, input: crate::model::RuleGroupResponse) -> Self {
            self.rule_group_response = Some(input);
            self
        }
        /// <p>The high-level properties of a rule group. This, along with the <code>RuleGroup</code>, define the rule group. You can retrieve all objects for a rule group by calling <code>DescribeRuleGroup</code>. </p>
        pub fn set_rule_group_response(
            mut self,
            input: std::option::Option<crate::model::RuleGroupResponse>,
        ) -> Self {
            self.rule_group_response = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`DescribeRuleGroupOutput`](crate::output::DescribeRuleGroupOutput).
        pub fn build(self) -> crate::output::DescribeRuleGroupOutput {
            crate::output::DescribeRuleGroupOutput {
                update_token: self.update_token,
                rule_group: self.rule_group,
                rule_group_response: self.rule_group_response,
                _request_id: self._request_id,
            }
        }
    }
}
impl DescribeRuleGroupOutput {
    /// Creates a new builder-style object to manufacture [`DescribeRuleGroupOutput`](crate::output::DescribeRuleGroupOutput).
    pub fn builder() -> crate::output::describe_rule_group_output::Builder {
        crate::output::describe_rule_group_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeResourcePolicyOutput {
    /// <p>The IAM policy for the resource. </p>
    #[doc(hidden)]
    pub policy: std::option::Option<std::string::String>,
    _request_id: Option<String>,
}
impl DescribeResourcePolicyOutput {
    /// <p>The IAM policy for the resource. </p>
    pub fn policy(&self) -> std::option::Option<&str> {
        self.policy.as_deref()
    }
}
impl aws_http::request_id::RequestId for DescribeResourcePolicyOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`DescribeResourcePolicyOutput`](crate::output::DescribeResourcePolicyOutput).
pub mod describe_resource_policy_output {

    /// A builder for [`DescribeResourcePolicyOutput`](crate::output::DescribeResourcePolicyOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy: std::option::Option<std::string::String>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>The IAM policy for the resource. </p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy = Some(input.into());
            self
        }
        /// <p>The IAM policy for the resource. </p>
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`DescribeResourcePolicyOutput`](crate::output::DescribeResourcePolicyOutput).
        pub fn build(self) -> crate::output::DescribeResourcePolicyOutput {
            crate::output::DescribeResourcePolicyOutput {
                policy: self.policy,
                _request_id: self._request_id,
            }
        }
    }
}
impl DescribeResourcePolicyOutput {
    /// Creates a new builder-style object to manufacture [`DescribeResourcePolicyOutput`](crate::output::DescribeResourcePolicyOutput).
    pub fn builder() -> crate::output::describe_resource_policy_output::Builder {
        crate::output::describe_resource_policy_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeLoggingConfigurationOutput {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    #[doc(hidden)]
    pub firewall_arn: std::option::Option<std::string::String>,
    /// <p>Defines how Network Firewall performs logging for a <code>Firewall</code>. </p>
    #[doc(hidden)]
    pub logging_configuration: std::option::Option<crate::model::LoggingConfiguration>,
    _request_id: Option<String>,
}
impl DescribeLoggingConfigurationOutput {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    pub fn firewall_arn(&self) -> std::option::Option<&str> {
        self.firewall_arn.as_deref()
    }
    /// <p>Defines how Network Firewall performs logging for a <code>Firewall</code>. </p>
    pub fn logging_configuration(
        &self,
    ) -> std::option::Option<&crate::model::LoggingConfiguration> {
        self.logging_configuration.as_ref()
    }
}
impl aws_http::request_id::RequestId for DescribeLoggingConfigurationOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`DescribeLoggingConfigurationOutput`](crate::output::DescribeLoggingConfigurationOutput).
pub mod describe_logging_configuration_output {

    /// A builder for [`DescribeLoggingConfigurationOutput`](crate::output::DescribeLoggingConfigurationOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) firewall_arn: std::option::Option<std::string::String>,
        pub(crate) logging_configuration: std::option::Option<crate::model::LoggingConfiguration>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        pub fn firewall_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        pub fn set_firewall_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.firewall_arn = input;
            self
        }
        /// <p>Defines how Network Firewall performs logging for a <code>Firewall</code>. </p>
        pub fn logging_configuration(mut self, input: crate::model::LoggingConfiguration) -> Self {
            self.logging_configuration = Some(input);
            self
        }
        /// <p>Defines how Network Firewall performs logging for a <code>Firewall</code>. </p>
        pub fn set_logging_configuration(
            mut self,
            input: std::option::Option<crate::model::LoggingConfiguration>,
        ) -> Self {
            self.logging_configuration = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`DescribeLoggingConfigurationOutput`](crate::output::DescribeLoggingConfigurationOutput).
        pub fn build(self) -> crate::output::DescribeLoggingConfigurationOutput {
            crate::output::DescribeLoggingConfigurationOutput {
                firewall_arn: self.firewall_arn,
                logging_configuration: self.logging_configuration,
                _request_id: self._request_id,
            }
        }
    }
}
impl DescribeLoggingConfigurationOutput {
    /// Creates a new builder-style object to manufacture [`DescribeLoggingConfigurationOutput`](crate::output::DescribeLoggingConfigurationOutput).
    pub fn builder() -> crate::output::describe_logging_configuration_output::Builder {
        crate::output::describe_logging_configuration_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeFirewallPolicyOutput {
    /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the firewall policy. The token marks the state of the policy resource at the time of the request. </p>
    /// <p>To make changes to the policy, you provide the token in your request. Network Firewall uses the token to ensure that the policy hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall policy again to get a current copy of it with current token. Reapply your changes as needed, then try the operation again using the new token. </p>
    #[doc(hidden)]
    pub update_token: std::option::Option<std::string::String>,
    /// <p>The high-level properties of a firewall policy. This, along with the <code>FirewallPolicy</code>, define the policy. You can retrieve all objects for a firewall policy by calling <code>DescribeFirewallPolicy</code>. </p>
    #[doc(hidden)]
    pub firewall_policy_response: std::option::Option<crate::model::FirewallPolicyResponse>,
    /// <p>The policy for the specified firewall policy. </p>
    #[doc(hidden)]
    pub firewall_policy: std::option::Option<crate::model::FirewallPolicy>,
    _request_id: Option<String>,
}
impl DescribeFirewallPolicyOutput {
    /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the firewall policy. The token marks the state of the policy resource at the time of the request. </p>
    /// <p>To make changes to the policy, you provide the token in your request. Network Firewall uses the token to ensure that the policy hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall policy again to get a current copy of it with current token. Reapply your changes as needed, then try the operation again using the new token. </p>
    pub fn update_token(&self) -> std::option::Option<&str> {
        self.update_token.as_deref()
    }
    /// <p>The high-level properties of a firewall policy. This, along with the <code>FirewallPolicy</code>, define the policy. You can retrieve all objects for a firewall policy by calling <code>DescribeFirewallPolicy</code>. </p>
    pub fn firewall_policy_response(
        &self,
    ) -> std::option::Option<&crate::model::FirewallPolicyResponse> {
        self.firewall_policy_response.as_ref()
    }
    /// <p>The policy for the specified firewall policy. </p>
    pub fn firewall_policy(&self) -> std::option::Option<&crate::model::FirewallPolicy> {
        self.firewall_policy.as_ref()
    }
}
impl aws_http::request_id::RequestId for DescribeFirewallPolicyOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`DescribeFirewallPolicyOutput`](crate::output::DescribeFirewallPolicyOutput).
pub mod describe_firewall_policy_output {

    /// A builder for [`DescribeFirewallPolicyOutput`](crate::output::DescribeFirewallPolicyOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) update_token: std::option::Option<std::string::String>,
        pub(crate) firewall_policy_response:
            std::option::Option<crate::model::FirewallPolicyResponse>,
        pub(crate) firewall_policy: std::option::Option<crate::model::FirewallPolicy>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the firewall policy. The token marks the state of the policy resource at the time of the request. </p>
        /// <p>To make changes to the policy, you provide the token in your request. Network Firewall uses the token to ensure that the policy hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall policy again to get a current copy of it with current token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.update_token = Some(input.into());
            self
        }
        /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the firewall policy. The token marks the state of the policy resource at the time of the request. </p>
        /// <p>To make changes to the policy, you provide the token in your request. Network Firewall uses the token to ensure that the policy hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall policy again to get a current copy of it with current token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn set_update_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.update_token = input;
            self
        }
        /// <p>The high-level properties of a firewall policy. This, along with the <code>FirewallPolicy</code>, define the policy. You can retrieve all objects for a firewall policy by calling <code>DescribeFirewallPolicy</code>. </p>
        pub fn firewall_policy_response(
            mut self,
            input: crate::model::FirewallPolicyResponse,
        ) -> Self {
            self.firewall_policy_response = Some(input);
            self
        }
        /// <p>The high-level properties of a firewall policy. This, along with the <code>FirewallPolicy</code>, define the policy. You can retrieve all objects for a firewall policy by calling <code>DescribeFirewallPolicy</code>. </p>
        pub fn set_firewall_policy_response(
            mut self,
            input: std::option::Option<crate::model::FirewallPolicyResponse>,
        ) -> Self {
            self.firewall_policy_response = input;
            self
        }
        /// <p>The policy for the specified firewall policy. </p>
        pub fn firewall_policy(mut self, input: crate::model::FirewallPolicy) -> Self {
            self.firewall_policy = Some(input);
            self
        }
        /// <p>The policy for the specified firewall policy. </p>
        pub fn set_firewall_policy(
            mut self,
            input: std::option::Option<crate::model::FirewallPolicy>,
        ) -> Self {
            self.firewall_policy = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`DescribeFirewallPolicyOutput`](crate::output::DescribeFirewallPolicyOutput).
        pub fn build(self) -> crate::output::DescribeFirewallPolicyOutput {
            crate::output::DescribeFirewallPolicyOutput {
                update_token: self.update_token,
                firewall_policy_response: self.firewall_policy_response,
                firewall_policy: self.firewall_policy,
                _request_id: self._request_id,
            }
        }
    }
}
impl DescribeFirewallPolicyOutput {
    /// Creates a new builder-style object to manufacture [`DescribeFirewallPolicyOutput`](crate::output::DescribeFirewallPolicyOutput).
    pub fn builder() -> crate::output::describe_firewall_policy_output::Builder {
        crate::output::describe_firewall_policy_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeFirewallOutput {
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    #[doc(hidden)]
    pub update_token: std::option::Option<std::string::String>,
    /// <p>The configuration settings for the firewall. These settings include the firewall policy and the subnets in your VPC to use for the firewall endpoints. </p>
    #[doc(hidden)]
    pub firewall: std::option::Option<crate::model::Firewall>,
    /// <p>Detailed information about the current status of a <code>Firewall</code>. You can retrieve this for a firewall by calling <code>DescribeFirewall</code> and providing the firewall name and ARN.</p>
    #[doc(hidden)]
    pub firewall_status: std::option::Option<crate::model::FirewallStatus>,
    _request_id: Option<String>,
}
impl DescribeFirewallOutput {
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    pub fn update_token(&self) -> std::option::Option<&str> {
        self.update_token.as_deref()
    }
    /// <p>The configuration settings for the firewall. These settings include the firewall policy and the subnets in your VPC to use for the firewall endpoints. </p>
    pub fn firewall(&self) -> std::option::Option<&crate::model::Firewall> {
        self.firewall.as_ref()
    }
    /// <p>Detailed information about the current status of a <code>Firewall</code>. You can retrieve this for a firewall by calling <code>DescribeFirewall</code> and providing the firewall name and ARN.</p>
    pub fn firewall_status(&self) -> std::option::Option<&crate::model::FirewallStatus> {
        self.firewall_status.as_ref()
    }
}
impl aws_http::request_id::RequestId for DescribeFirewallOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`DescribeFirewallOutput`](crate::output::DescribeFirewallOutput).
pub mod describe_firewall_output {

    /// A builder for [`DescribeFirewallOutput`](crate::output::DescribeFirewallOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) update_token: std::option::Option<std::string::String>,
        pub(crate) firewall: std::option::Option<crate::model::Firewall>,
        pub(crate) firewall_status: std::option::Option<crate::model::FirewallStatus>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
        /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
        /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.update_token = Some(input.into());
            self
        }
        /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
        /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
        /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn set_update_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.update_token = input;
            self
        }
        /// <p>The configuration settings for the firewall. These settings include the firewall policy and the subnets in your VPC to use for the firewall endpoints. </p>
        pub fn firewall(mut self, input: crate::model::Firewall) -> Self {
            self.firewall = Some(input);
            self
        }
        /// <p>The configuration settings for the firewall. These settings include the firewall policy and the subnets in your VPC to use for the firewall endpoints. </p>
        pub fn set_firewall(mut self, input: std::option::Option<crate::model::Firewall>) -> Self {
            self.firewall = input;
            self
        }
        /// <p>Detailed information about the current status of a <code>Firewall</code>. You can retrieve this for a firewall by calling <code>DescribeFirewall</code> and providing the firewall name and ARN.</p>
        pub fn firewall_status(mut self, input: crate::model::FirewallStatus) -> Self {
            self.firewall_status = Some(input);
            self
        }
        /// <p>Detailed information about the current status of a <code>Firewall</code>. You can retrieve this for a firewall by calling <code>DescribeFirewall</code> and providing the firewall name and ARN.</p>
        pub fn set_firewall_status(
            mut self,
            input: std::option::Option<crate::model::FirewallStatus>,
        ) -> Self {
            self.firewall_status = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`DescribeFirewallOutput`](crate::output::DescribeFirewallOutput).
        pub fn build(self) -> crate::output::DescribeFirewallOutput {
            crate::output::DescribeFirewallOutput {
                update_token: self.update_token,
                firewall: self.firewall,
                firewall_status: self.firewall_status,
                _request_id: self._request_id,
            }
        }
    }
}
impl DescribeFirewallOutput {
    /// Creates a new builder-style object to manufacture [`DescribeFirewallOutput`](crate::output::DescribeFirewallOutput).
    pub fn builder() -> crate::output::describe_firewall_output::Builder {
        crate::output::describe_firewall_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteRuleGroupOutput {
    /// <p>The high-level properties of a rule group. This, along with the <code>RuleGroup</code>, define the rule group. You can retrieve all objects for a rule group by calling <code>DescribeRuleGroup</code>. </p>
    #[doc(hidden)]
    pub rule_group_response: std::option::Option<crate::model::RuleGroupResponse>,
    _request_id: Option<String>,
}
impl DeleteRuleGroupOutput {
    /// <p>The high-level properties of a rule group. This, along with the <code>RuleGroup</code>, define the rule group. You can retrieve all objects for a rule group by calling <code>DescribeRuleGroup</code>. </p>
    pub fn rule_group_response(&self) -> std::option::Option<&crate::model::RuleGroupResponse> {
        self.rule_group_response.as_ref()
    }
}
impl aws_http::request_id::RequestId for DeleteRuleGroupOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`DeleteRuleGroupOutput`](crate::output::DeleteRuleGroupOutput).
pub mod delete_rule_group_output {

    /// A builder for [`DeleteRuleGroupOutput`](crate::output::DeleteRuleGroupOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_group_response: std::option::Option<crate::model::RuleGroupResponse>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>The high-level properties of a rule group. This, along with the <code>RuleGroup</code>, define the rule group. You can retrieve all objects for a rule group by calling <code>DescribeRuleGroup</code>. </p>
        pub fn rule_group_response(mut self, input: crate::model::RuleGroupResponse) -> Self {
            self.rule_group_response = Some(input);
            self
        }
        /// <p>The high-level properties of a rule group. This, along with the <code>RuleGroup</code>, define the rule group. You can retrieve all objects for a rule group by calling <code>DescribeRuleGroup</code>. </p>
        pub fn set_rule_group_response(
            mut self,
            input: std::option::Option<crate::model::RuleGroupResponse>,
        ) -> Self {
            self.rule_group_response = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`DeleteRuleGroupOutput`](crate::output::DeleteRuleGroupOutput).
        pub fn build(self) -> crate::output::DeleteRuleGroupOutput {
            crate::output::DeleteRuleGroupOutput {
                rule_group_response: self.rule_group_response,
                _request_id: self._request_id,
            }
        }
    }
}
impl DeleteRuleGroupOutput {
    /// Creates a new builder-style object to manufacture [`DeleteRuleGroupOutput`](crate::output::DeleteRuleGroupOutput).
    pub fn builder() -> crate::output::delete_rule_group_output::Builder {
        crate::output::delete_rule_group_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteResourcePolicyOutput {
    _request_id: Option<String>,
}
impl aws_http::request_id::RequestId for DeleteResourcePolicyOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`DeleteResourcePolicyOutput`](crate::output::DeleteResourcePolicyOutput).
pub mod delete_resource_policy_output {

    /// A builder for [`DeleteResourcePolicyOutput`](crate::output::DeleteResourcePolicyOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        _request_id: Option<String>,
    }
    impl Builder {
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`DeleteResourcePolicyOutput`](crate::output::DeleteResourcePolicyOutput).
        pub fn build(self) -> crate::output::DeleteResourcePolicyOutput {
            crate::output::DeleteResourcePolicyOutput {
                _request_id: self._request_id,
            }
        }
    }
}
impl DeleteResourcePolicyOutput {
    /// Creates a new builder-style object to manufacture [`DeleteResourcePolicyOutput`](crate::output::DeleteResourcePolicyOutput).
    pub fn builder() -> crate::output::delete_resource_policy_output::Builder {
        crate::output::delete_resource_policy_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteFirewallPolicyOutput {
    /// <p>The object containing the definition of the <code>FirewallPolicyResponse</code> that you asked to delete. </p>
    #[doc(hidden)]
    pub firewall_policy_response: std::option::Option<crate::model::FirewallPolicyResponse>,
    _request_id: Option<String>,
}
impl DeleteFirewallPolicyOutput {
    /// <p>The object containing the definition of the <code>FirewallPolicyResponse</code> that you asked to delete. </p>
    pub fn firewall_policy_response(
        &self,
    ) -> std::option::Option<&crate::model::FirewallPolicyResponse> {
        self.firewall_policy_response.as_ref()
    }
}
impl aws_http::request_id::RequestId for DeleteFirewallPolicyOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`DeleteFirewallPolicyOutput`](crate::output::DeleteFirewallPolicyOutput).
pub mod delete_firewall_policy_output {

    /// A builder for [`DeleteFirewallPolicyOutput`](crate::output::DeleteFirewallPolicyOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) firewall_policy_response:
            std::option::Option<crate::model::FirewallPolicyResponse>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>The object containing the definition of the <code>FirewallPolicyResponse</code> that you asked to delete. </p>
        pub fn firewall_policy_response(
            mut self,
            input: crate::model::FirewallPolicyResponse,
        ) -> Self {
            self.firewall_policy_response = Some(input);
            self
        }
        /// <p>The object containing the definition of the <code>FirewallPolicyResponse</code> that you asked to delete. </p>
        pub fn set_firewall_policy_response(
            mut self,
            input: std::option::Option<crate::model::FirewallPolicyResponse>,
        ) -> Self {
            self.firewall_policy_response = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`DeleteFirewallPolicyOutput`](crate::output::DeleteFirewallPolicyOutput).
        pub fn build(self) -> crate::output::DeleteFirewallPolicyOutput {
            crate::output::DeleteFirewallPolicyOutput {
                firewall_policy_response: self.firewall_policy_response,
                _request_id: self._request_id,
            }
        }
    }
}
impl DeleteFirewallPolicyOutput {
    /// Creates a new builder-style object to manufacture [`DeleteFirewallPolicyOutput`](crate::output::DeleteFirewallPolicyOutput).
    pub fn builder() -> crate::output::delete_firewall_policy_output::Builder {
        crate::output::delete_firewall_policy_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteFirewallOutput {
    /// <p>The firewall defines the configuration settings for an Network Firewall firewall. These settings include the firewall policy, the subnets in your VPC to use for the firewall endpoints, and any tags that are attached to the firewall Amazon Web Services resource. </p>
    /// <p>The status of the firewall, for example whether it's ready to filter network traffic, is provided in the corresponding <code>FirewallStatus</code>. You can retrieve both objects by calling <code>DescribeFirewall</code>.</p>
    #[doc(hidden)]
    pub firewall: std::option::Option<crate::model::Firewall>,
    /// <p>Detailed information about the current status of a <code>Firewall</code>. You can retrieve this for a firewall by calling <code>DescribeFirewall</code> and providing the firewall name and ARN.</p>
    #[doc(hidden)]
    pub firewall_status: std::option::Option<crate::model::FirewallStatus>,
    _request_id: Option<String>,
}
impl DeleteFirewallOutput {
    /// <p>The firewall defines the configuration settings for an Network Firewall firewall. These settings include the firewall policy, the subnets in your VPC to use for the firewall endpoints, and any tags that are attached to the firewall Amazon Web Services resource. </p>
    /// <p>The status of the firewall, for example whether it's ready to filter network traffic, is provided in the corresponding <code>FirewallStatus</code>. You can retrieve both objects by calling <code>DescribeFirewall</code>.</p>
    pub fn firewall(&self) -> std::option::Option<&crate::model::Firewall> {
        self.firewall.as_ref()
    }
    /// <p>Detailed information about the current status of a <code>Firewall</code>. You can retrieve this for a firewall by calling <code>DescribeFirewall</code> and providing the firewall name and ARN.</p>
    pub fn firewall_status(&self) -> std::option::Option<&crate::model::FirewallStatus> {
        self.firewall_status.as_ref()
    }
}
impl aws_http::request_id::RequestId for DeleteFirewallOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`DeleteFirewallOutput`](crate::output::DeleteFirewallOutput).
pub mod delete_firewall_output {

    /// A builder for [`DeleteFirewallOutput`](crate::output::DeleteFirewallOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) firewall: std::option::Option<crate::model::Firewall>,
        pub(crate) firewall_status: std::option::Option<crate::model::FirewallStatus>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>The firewall defines the configuration settings for an Network Firewall firewall. These settings include the firewall policy, the subnets in your VPC to use for the firewall endpoints, and any tags that are attached to the firewall Amazon Web Services resource. </p>
        /// <p>The status of the firewall, for example whether it's ready to filter network traffic, is provided in the corresponding <code>FirewallStatus</code>. You can retrieve both objects by calling <code>DescribeFirewall</code>.</p>
        pub fn firewall(mut self, input: crate::model::Firewall) -> Self {
            self.firewall = Some(input);
            self
        }
        /// <p>The firewall defines the configuration settings for an Network Firewall firewall. These settings include the firewall policy, the subnets in your VPC to use for the firewall endpoints, and any tags that are attached to the firewall Amazon Web Services resource. </p>
        /// <p>The status of the firewall, for example whether it's ready to filter network traffic, is provided in the corresponding <code>FirewallStatus</code>. You can retrieve both objects by calling <code>DescribeFirewall</code>.</p>
        pub fn set_firewall(mut self, input: std::option::Option<crate::model::Firewall>) -> Self {
            self.firewall = input;
            self
        }
        /// <p>Detailed information about the current status of a <code>Firewall</code>. You can retrieve this for a firewall by calling <code>DescribeFirewall</code> and providing the firewall name and ARN.</p>
        pub fn firewall_status(mut self, input: crate::model::FirewallStatus) -> Self {
            self.firewall_status = Some(input);
            self
        }
        /// <p>Detailed information about the current status of a <code>Firewall</code>. You can retrieve this for a firewall by calling <code>DescribeFirewall</code> and providing the firewall name and ARN.</p>
        pub fn set_firewall_status(
            mut self,
            input: std::option::Option<crate::model::FirewallStatus>,
        ) -> Self {
            self.firewall_status = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`DeleteFirewallOutput`](crate::output::DeleteFirewallOutput).
        pub fn build(self) -> crate::output::DeleteFirewallOutput {
            crate::output::DeleteFirewallOutput {
                firewall: self.firewall,
                firewall_status: self.firewall_status,
                _request_id: self._request_id,
            }
        }
    }
}
impl DeleteFirewallOutput {
    /// Creates a new builder-style object to manufacture [`DeleteFirewallOutput`](crate::output::DeleteFirewallOutput).
    pub fn builder() -> crate::output::delete_firewall_output::Builder {
        crate::output::delete_firewall_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateRuleGroupOutput {
    /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the rule group. The token marks the state of the rule group resource at the time of the request. </p>
    /// <p>To make changes to the rule group, you provide the token in your request. Network Firewall uses the token to ensure that the rule group hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the rule group again to get a current copy of it with a current token. Reapply your changes as needed, then try the operation again using the new token. </p>
    #[doc(hidden)]
    pub update_token: std::option::Option<std::string::String>,
    /// <p>The high-level properties of a rule group. This, along with the <code>RuleGroup</code>, define the rule group. You can retrieve all objects for a rule group by calling <code>DescribeRuleGroup</code>. </p>
    #[doc(hidden)]
    pub rule_group_response: std::option::Option<crate::model::RuleGroupResponse>,
    _request_id: Option<String>,
}
impl CreateRuleGroupOutput {
    /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the rule group. The token marks the state of the rule group resource at the time of the request. </p>
    /// <p>To make changes to the rule group, you provide the token in your request. Network Firewall uses the token to ensure that the rule group hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the rule group again to get a current copy of it with a current token. Reapply your changes as needed, then try the operation again using the new token. </p>
    pub fn update_token(&self) -> std::option::Option<&str> {
        self.update_token.as_deref()
    }
    /// <p>The high-level properties of a rule group. This, along with the <code>RuleGroup</code>, define the rule group. You can retrieve all objects for a rule group by calling <code>DescribeRuleGroup</code>. </p>
    pub fn rule_group_response(&self) -> std::option::Option<&crate::model::RuleGroupResponse> {
        self.rule_group_response.as_ref()
    }
}
impl aws_http::request_id::RequestId for CreateRuleGroupOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`CreateRuleGroupOutput`](crate::output::CreateRuleGroupOutput).
pub mod create_rule_group_output {

    /// A builder for [`CreateRuleGroupOutput`](crate::output::CreateRuleGroupOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) update_token: std::option::Option<std::string::String>,
        pub(crate) rule_group_response: std::option::Option<crate::model::RuleGroupResponse>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the rule group. The token marks the state of the rule group resource at the time of the request. </p>
        /// <p>To make changes to the rule group, you provide the token in your request. Network Firewall uses the token to ensure that the rule group hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the rule group again to get a current copy of it with a current token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.update_token = Some(input.into());
            self
        }
        /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the rule group. The token marks the state of the rule group resource at the time of the request. </p>
        /// <p>To make changes to the rule group, you provide the token in your request. Network Firewall uses the token to ensure that the rule group hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the rule group again to get a current copy of it with a current token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn set_update_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.update_token = input;
            self
        }
        /// <p>The high-level properties of a rule group. This, along with the <code>RuleGroup</code>, define the rule group. You can retrieve all objects for a rule group by calling <code>DescribeRuleGroup</code>. </p>
        pub fn rule_group_response(mut self, input: crate::model::RuleGroupResponse) -> Self {
            self.rule_group_response = Some(input);
            self
        }
        /// <p>The high-level properties of a rule group. This, along with the <code>RuleGroup</code>, define the rule group. You can retrieve all objects for a rule group by calling <code>DescribeRuleGroup</code>. </p>
        pub fn set_rule_group_response(
            mut self,
            input: std::option::Option<crate::model::RuleGroupResponse>,
        ) -> Self {
            self.rule_group_response = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`CreateRuleGroupOutput`](crate::output::CreateRuleGroupOutput).
        pub fn build(self) -> crate::output::CreateRuleGroupOutput {
            crate::output::CreateRuleGroupOutput {
                update_token: self.update_token,
                rule_group_response: self.rule_group_response,
                _request_id: self._request_id,
            }
        }
    }
}
impl CreateRuleGroupOutput {
    /// Creates a new builder-style object to manufacture [`CreateRuleGroupOutput`](crate::output::CreateRuleGroupOutput).
    pub fn builder() -> crate::output::create_rule_group_output::Builder {
        crate::output::create_rule_group_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateFirewallPolicyOutput {
    /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the firewall policy. The token marks the state of the policy resource at the time of the request. </p>
    /// <p>To make changes to the policy, you provide the token in your request. Network Firewall uses the token to ensure that the policy hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall policy again to get a current copy of it with current token. Reapply your changes as needed, then try the operation again using the new token. </p>
    #[doc(hidden)]
    pub update_token: std::option::Option<std::string::String>,
    /// <p>The high-level properties of a firewall policy. This, along with the <code>FirewallPolicy</code>, define the policy. You can retrieve all objects for a firewall policy by calling <code>DescribeFirewallPolicy</code>. </p>
    #[doc(hidden)]
    pub firewall_policy_response: std::option::Option<crate::model::FirewallPolicyResponse>,
    _request_id: Option<String>,
}
impl CreateFirewallPolicyOutput {
    /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the firewall policy. The token marks the state of the policy resource at the time of the request. </p>
    /// <p>To make changes to the policy, you provide the token in your request. Network Firewall uses the token to ensure that the policy hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall policy again to get a current copy of it with current token. Reapply your changes as needed, then try the operation again using the new token. </p>
    pub fn update_token(&self) -> std::option::Option<&str> {
        self.update_token.as_deref()
    }
    /// <p>The high-level properties of a firewall policy. This, along with the <code>FirewallPolicy</code>, define the policy. You can retrieve all objects for a firewall policy by calling <code>DescribeFirewallPolicy</code>. </p>
    pub fn firewall_policy_response(
        &self,
    ) -> std::option::Option<&crate::model::FirewallPolicyResponse> {
        self.firewall_policy_response.as_ref()
    }
}
impl aws_http::request_id::RequestId for CreateFirewallPolicyOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`CreateFirewallPolicyOutput`](crate::output::CreateFirewallPolicyOutput).
pub mod create_firewall_policy_output {

    /// A builder for [`CreateFirewallPolicyOutput`](crate::output::CreateFirewallPolicyOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) update_token: std::option::Option<std::string::String>,
        pub(crate) firewall_policy_response:
            std::option::Option<crate::model::FirewallPolicyResponse>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the firewall policy. The token marks the state of the policy resource at the time of the request. </p>
        /// <p>To make changes to the policy, you provide the token in your request. Network Firewall uses the token to ensure that the policy hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall policy again to get a current copy of it with current token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.update_token = Some(input.into());
            self
        }
        /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the firewall policy. The token marks the state of the policy resource at the time of the request. </p>
        /// <p>To make changes to the policy, you provide the token in your request. Network Firewall uses the token to ensure that the policy hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall policy again to get a current copy of it with current token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn set_update_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.update_token = input;
            self
        }
        /// <p>The high-level properties of a firewall policy. This, along with the <code>FirewallPolicy</code>, define the policy. You can retrieve all objects for a firewall policy by calling <code>DescribeFirewallPolicy</code>. </p>
        pub fn firewall_policy_response(
            mut self,
            input: crate::model::FirewallPolicyResponse,
        ) -> Self {
            self.firewall_policy_response = Some(input);
            self
        }
        /// <p>The high-level properties of a firewall policy. This, along with the <code>FirewallPolicy</code>, define the policy. You can retrieve all objects for a firewall policy by calling <code>DescribeFirewallPolicy</code>. </p>
        pub fn set_firewall_policy_response(
            mut self,
            input: std::option::Option<crate::model::FirewallPolicyResponse>,
        ) -> Self {
            self.firewall_policy_response = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`CreateFirewallPolicyOutput`](crate::output::CreateFirewallPolicyOutput).
        pub fn build(self) -> crate::output::CreateFirewallPolicyOutput {
            crate::output::CreateFirewallPolicyOutput {
                update_token: self.update_token,
                firewall_policy_response: self.firewall_policy_response,
                _request_id: self._request_id,
            }
        }
    }
}
impl CreateFirewallPolicyOutput {
    /// Creates a new builder-style object to manufacture [`CreateFirewallPolicyOutput`](crate::output::CreateFirewallPolicyOutput).
    pub fn builder() -> crate::output::create_firewall_policy_output::Builder {
        crate::output::create_firewall_policy_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateFirewallOutput {
    /// <p>The configuration settings for the firewall. These settings include the firewall policy and the subnets in your VPC to use for the firewall endpoints. </p>
    #[doc(hidden)]
    pub firewall: std::option::Option<crate::model::Firewall>,
    /// <p>Detailed information about the current status of a <code>Firewall</code>. You can retrieve this for a firewall by calling <code>DescribeFirewall</code> and providing the firewall name and ARN.</p>
    #[doc(hidden)]
    pub firewall_status: std::option::Option<crate::model::FirewallStatus>,
    _request_id: Option<String>,
}
impl CreateFirewallOutput {
    /// <p>The configuration settings for the firewall. These settings include the firewall policy and the subnets in your VPC to use for the firewall endpoints. </p>
    pub fn firewall(&self) -> std::option::Option<&crate::model::Firewall> {
        self.firewall.as_ref()
    }
    /// <p>Detailed information about the current status of a <code>Firewall</code>. You can retrieve this for a firewall by calling <code>DescribeFirewall</code> and providing the firewall name and ARN.</p>
    pub fn firewall_status(&self) -> std::option::Option<&crate::model::FirewallStatus> {
        self.firewall_status.as_ref()
    }
}
impl aws_http::request_id::RequestId for CreateFirewallOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`CreateFirewallOutput`](crate::output::CreateFirewallOutput).
pub mod create_firewall_output {

    /// A builder for [`CreateFirewallOutput`](crate::output::CreateFirewallOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) firewall: std::option::Option<crate::model::Firewall>,
        pub(crate) firewall_status: std::option::Option<crate::model::FirewallStatus>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>The configuration settings for the firewall. These settings include the firewall policy and the subnets in your VPC to use for the firewall endpoints. </p>
        pub fn firewall(mut self, input: crate::model::Firewall) -> Self {
            self.firewall = Some(input);
            self
        }
        /// <p>The configuration settings for the firewall. These settings include the firewall policy and the subnets in your VPC to use for the firewall endpoints. </p>
        pub fn set_firewall(mut self, input: std::option::Option<crate::model::Firewall>) -> Self {
            self.firewall = input;
            self
        }
        /// <p>Detailed information about the current status of a <code>Firewall</code>. You can retrieve this for a firewall by calling <code>DescribeFirewall</code> and providing the firewall name and ARN.</p>
        pub fn firewall_status(mut self, input: crate::model::FirewallStatus) -> Self {
            self.firewall_status = Some(input);
            self
        }
        /// <p>Detailed information about the current status of a <code>Firewall</code>. You can retrieve this for a firewall by calling <code>DescribeFirewall</code> and providing the firewall name and ARN.</p>
        pub fn set_firewall_status(
            mut self,
            input: std::option::Option<crate::model::FirewallStatus>,
        ) -> Self {
            self.firewall_status = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`CreateFirewallOutput`](crate::output::CreateFirewallOutput).
        pub fn build(self) -> crate::output::CreateFirewallOutput {
            crate::output::CreateFirewallOutput {
                firewall: self.firewall,
                firewall_status: self.firewall_status,
                _request_id: self._request_id,
            }
        }
    }
}
impl CreateFirewallOutput {
    /// Creates a new builder-style object to manufacture [`CreateFirewallOutput`](crate::output::CreateFirewallOutput).
    pub fn builder() -> crate::output::create_firewall_output::Builder {
        crate::output::create_firewall_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateSubnetsOutput {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    #[doc(hidden)]
    pub firewall_arn: std::option::Option<std::string::String>,
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    #[doc(hidden)]
    pub firewall_name: std::option::Option<std::string::String>,
    /// <p>The IDs of the subnets that are associated with the firewall. </p>
    #[doc(hidden)]
    pub subnet_mappings: std::option::Option<std::vec::Vec<crate::model::SubnetMapping>>,
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    #[doc(hidden)]
    pub update_token: std::option::Option<std::string::String>,
    _request_id: Option<String>,
}
impl AssociateSubnetsOutput {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    pub fn firewall_arn(&self) -> std::option::Option<&str> {
        self.firewall_arn.as_deref()
    }
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    pub fn firewall_name(&self) -> std::option::Option<&str> {
        self.firewall_name.as_deref()
    }
    /// <p>The IDs of the subnets that are associated with the firewall. </p>
    pub fn subnet_mappings(&self) -> std::option::Option<&[crate::model::SubnetMapping]> {
        self.subnet_mappings.as_deref()
    }
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    pub fn update_token(&self) -> std::option::Option<&str> {
        self.update_token.as_deref()
    }
}
impl aws_http::request_id::RequestId for AssociateSubnetsOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`AssociateSubnetsOutput`](crate::output::AssociateSubnetsOutput).
pub mod associate_subnets_output {

    /// A builder for [`AssociateSubnetsOutput`](crate::output::AssociateSubnetsOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) firewall_arn: std::option::Option<std::string::String>,
        pub(crate) firewall_name: std::option::Option<std::string::String>,
        pub(crate) subnet_mappings: std::option::Option<std::vec::Vec<crate::model::SubnetMapping>>,
        pub(crate) update_token: std::option::Option<std::string::String>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        pub fn firewall_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        pub fn set_firewall_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.firewall_arn = input;
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        pub fn firewall_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_name = Some(input.into());
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        pub fn set_firewall_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.firewall_name = input;
            self
        }
        /// Appends an item to `subnet_mappings`.
        ///
        /// To override the contents of this collection use [`set_subnet_mappings`](Self::set_subnet_mappings).
        ///
        /// <p>The IDs of the subnets that are associated with the firewall. </p>
        pub fn subnet_mappings(mut self, input: crate::model::SubnetMapping) -> Self {
            let mut v = self.subnet_mappings.unwrap_or_default();
            v.push(input);
            self.subnet_mappings = Some(v);
            self
        }
        /// <p>The IDs of the subnets that are associated with the firewall. </p>
        pub fn set_subnet_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SubnetMapping>>,
        ) -> Self {
            self.subnet_mappings = input;
            self
        }
        /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
        /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
        /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.update_token = Some(input.into());
            self
        }
        /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
        /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
        /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn set_update_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.update_token = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`AssociateSubnetsOutput`](crate::output::AssociateSubnetsOutput).
        pub fn build(self) -> crate::output::AssociateSubnetsOutput {
            crate::output::AssociateSubnetsOutput {
                firewall_arn: self.firewall_arn,
                firewall_name: self.firewall_name,
                subnet_mappings: self.subnet_mappings,
                update_token: self.update_token,
                _request_id: self._request_id,
            }
        }
    }
}
impl AssociateSubnetsOutput {
    /// Creates a new builder-style object to manufacture [`AssociateSubnetsOutput`](crate::output::AssociateSubnetsOutput).
    pub fn builder() -> crate::output::associate_subnets_output::Builder {
        crate::output::associate_subnets_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateFirewallPolicyOutput {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    #[doc(hidden)]
    pub firewall_arn: std::option::Option<std::string::String>,
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    #[doc(hidden)]
    pub firewall_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the firewall policy.</p>
    #[doc(hidden)]
    pub firewall_policy_arn: std::option::Option<std::string::String>,
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    #[doc(hidden)]
    pub update_token: std::option::Option<std::string::String>,
    _request_id: Option<String>,
}
impl AssociateFirewallPolicyOutput {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    pub fn firewall_arn(&self) -> std::option::Option<&str> {
        self.firewall_arn.as_deref()
    }
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    pub fn firewall_name(&self) -> std::option::Option<&str> {
        self.firewall_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the firewall policy.</p>
    pub fn firewall_policy_arn(&self) -> std::option::Option<&str> {
        self.firewall_policy_arn.as_deref()
    }
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    pub fn update_token(&self) -> std::option::Option<&str> {
        self.update_token.as_deref()
    }
}
impl aws_http::request_id::RequestId for AssociateFirewallPolicyOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
/// See [`AssociateFirewallPolicyOutput`](crate::output::AssociateFirewallPolicyOutput).
pub mod associate_firewall_policy_output {

    /// A builder for [`AssociateFirewallPolicyOutput`](crate::output::AssociateFirewallPolicyOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) firewall_arn: std::option::Option<std::string::String>,
        pub(crate) firewall_name: std::option::Option<std::string::String>,
        pub(crate) firewall_policy_arn: std::option::Option<std::string::String>,
        pub(crate) update_token: std::option::Option<std::string::String>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        pub fn firewall_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        pub fn set_firewall_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.firewall_arn = input;
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        pub fn firewall_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_name = Some(input.into());
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        pub fn set_firewall_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.firewall_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall policy.</p>
        pub fn firewall_policy_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.firewall_policy_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall policy.</p>
        pub fn set_firewall_policy_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.firewall_policy_arn = input;
            self
        }
        /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
        /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
        /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.update_token = Some(input.into());
            self
        }
        /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
        /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
        /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn set_update_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.update_token = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`AssociateFirewallPolicyOutput`](crate::output::AssociateFirewallPolicyOutput).
        pub fn build(self) -> crate::output::AssociateFirewallPolicyOutput {
            crate::output::AssociateFirewallPolicyOutput {
                firewall_arn: self.firewall_arn,
                firewall_name: self.firewall_name,
                firewall_policy_arn: self.firewall_policy_arn,
                update_token: self.update_token,
                _request_id: self._request_id,
            }
        }
    }
}
impl AssociateFirewallPolicyOutput {
    /// Creates a new builder-style object to manufacture [`AssociateFirewallPolicyOutput`](crate::output::AssociateFirewallPolicyOutput).
    pub fn builder() -> crate::output::associate_firewall_policy_output::Builder {
        crate::output::associate_firewall_policy_output::Builder::default()
    }
}
