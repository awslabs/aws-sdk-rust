// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The analysis result for Network Firewall's stateless rule group analyzer. Every time you call <code>CreateRuleGroup</code>, <code>UpdateRuleGroup</code>, or <code>DescribeRuleGroup</code> on a stateless rule group, Network Firewall analyzes the stateless rule groups in your account and identifies the rules that might adversely effect your firewall's functionality. For example, if Network Firewall detects a rule that's routing traffic asymmetrically, which impacts the service's ability to properly process traffic, the service includes the rule in a list of analysis results.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct AnalysisResult {
    /// <p>The priority number of the stateless rules identified in the analysis.</p>
    pub identified_rule_ids: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The types of rule configurations that Network Firewall analyzes your rule groups for. Network Firewall analyzes stateless rule groups for the following types of rule configurations:</p>
    /// <ul>
    /// <li>
    /// <p><code>STATELESS_RULE_FORWARDING_ASYMMETRICALLY</code></p>
    /// <p>Cause: One or more stateless rules with the action <code>pass</code> or <code>forward</code> are forwarding traffic asymmetrically. Specifically, the rule's set of source IP addresses or their associated port numbers, don't match the set of destination IP addresses or their associated port numbers.</p>
    /// <p>To mitigate: Make sure that there's an existing return path. For example, if the rule allows traffic from source 10.1.0.0/24 to destination 20.1.0.0/24, you should allow return traffic from source 20.1.0.0/24 to destination 10.1.0.0/24.</p></li>
    /// <li>
    /// <p><code>STATELESS_RULE_CONTAINS_TCP_FLAGS</code></p>
    /// <p>Cause: At least one stateless rule with the action <code>pass</code> or<code>forward</code> contains TCP flags that are inconsistent in the forward and return directions.</p>
    /// <p>To mitigate: Prevent asymmetric routing issues caused by TCP flags by following these actions:</p>
    /// <ul>
    /// <li>
    /// <p>Remove unnecessary TCP flag inspections from the rules.</p></li>
    /// <li>
    /// <p>If you need to inspect TCP flags, check that the rules correctly account for changes in TCP flags throughout the TCP connection cycle, for example <code>SYN</code> and <code>ACK</code> flags used in a 3-way TCP handshake.</p></li>
    /// </ul></li>
    /// </ul>
    pub identified_type: ::std::option::Option<crate::types::IdentifiedType>,
    /// <p>Provides analysis details for the identified rule.</p>
    pub analysis_detail: ::std::option::Option<::std::string::String>,
}
impl AnalysisResult {
    /// <p>The priority number of the stateless rules identified in the analysis.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.identified_rule_ids.is_none()`.
    pub fn identified_rule_ids(&self) -> &[::std::string::String] {
        self.identified_rule_ids.as_deref().unwrap_or_default()
    }
    /// <p>The types of rule configurations that Network Firewall analyzes your rule groups for. Network Firewall analyzes stateless rule groups for the following types of rule configurations:</p>
    /// <ul>
    /// <li>
    /// <p><code>STATELESS_RULE_FORWARDING_ASYMMETRICALLY</code></p>
    /// <p>Cause: One or more stateless rules with the action <code>pass</code> or <code>forward</code> are forwarding traffic asymmetrically. Specifically, the rule's set of source IP addresses or their associated port numbers, don't match the set of destination IP addresses or their associated port numbers.</p>
    /// <p>To mitigate: Make sure that there's an existing return path. For example, if the rule allows traffic from source 10.1.0.0/24 to destination 20.1.0.0/24, you should allow return traffic from source 20.1.0.0/24 to destination 10.1.0.0/24.</p></li>
    /// <li>
    /// <p><code>STATELESS_RULE_CONTAINS_TCP_FLAGS</code></p>
    /// <p>Cause: At least one stateless rule with the action <code>pass</code> or<code>forward</code> contains TCP flags that are inconsistent in the forward and return directions.</p>
    /// <p>To mitigate: Prevent asymmetric routing issues caused by TCP flags by following these actions:</p>
    /// <ul>
    /// <li>
    /// <p>Remove unnecessary TCP flag inspections from the rules.</p></li>
    /// <li>
    /// <p>If you need to inspect TCP flags, check that the rules correctly account for changes in TCP flags throughout the TCP connection cycle, for example <code>SYN</code> and <code>ACK</code> flags used in a 3-way TCP handshake.</p></li>
    /// </ul></li>
    /// </ul>
    pub fn identified_type(&self) -> ::std::option::Option<&crate::types::IdentifiedType> {
        self.identified_type.as_ref()
    }
    /// <p>Provides analysis details for the identified rule.</p>
    pub fn analysis_detail(&self) -> ::std::option::Option<&str> {
        self.analysis_detail.as_deref()
    }
}
impl AnalysisResult {
    /// Creates a new builder-style object to manufacture [`AnalysisResult`](crate::types::AnalysisResult).
    pub fn builder() -> crate::types::builders::AnalysisResultBuilder {
        crate::types::builders::AnalysisResultBuilder::default()
    }
}

/// A builder for [`AnalysisResult`](crate::types::AnalysisResult).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct AnalysisResultBuilder {
    pub(crate) identified_rule_ids: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) identified_type: ::std::option::Option<crate::types::IdentifiedType>,
    pub(crate) analysis_detail: ::std::option::Option<::std::string::String>,
}
impl AnalysisResultBuilder {
    /// Appends an item to `identified_rule_ids`.
    ///
    /// To override the contents of this collection use [`set_identified_rule_ids`](Self::set_identified_rule_ids).
    ///
    /// <p>The priority number of the stateless rules identified in the analysis.</p>
    pub fn identified_rule_ids(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.identified_rule_ids.unwrap_or_default();
        v.push(input.into());
        self.identified_rule_ids = ::std::option::Option::Some(v);
        self
    }
    /// <p>The priority number of the stateless rules identified in the analysis.</p>
    pub fn set_identified_rule_ids(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.identified_rule_ids = input;
        self
    }
    /// <p>The priority number of the stateless rules identified in the analysis.</p>
    pub fn get_identified_rule_ids(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.identified_rule_ids
    }
    /// <p>The types of rule configurations that Network Firewall analyzes your rule groups for. Network Firewall analyzes stateless rule groups for the following types of rule configurations:</p>
    /// <ul>
    /// <li>
    /// <p><code>STATELESS_RULE_FORWARDING_ASYMMETRICALLY</code></p>
    /// <p>Cause: One or more stateless rules with the action <code>pass</code> or <code>forward</code> are forwarding traffic asymmetrically. Specifically, the rule's set of source IP addresses or their associated port numbers, don't match the set of destination IP addresses or their associated port numbers.</p>
    /// <p>To mitigate: Make sure that there's an existing return path. For example, if the rule allows traffic from source 10.1.0.0/24 to destination 20.1.0.0/24, you should allow return traffic from source 20.1.0.0/24 to destination 10.1.0.0/24.</p></li>
    /// <li>
    /// <p><code>STATELESS_RULE_CONTAINS_TCP_FLAGS</code></p>
    /// <p>Cause: At least one stateless rule with the action <code>pass</code> or<code>forward</code> contains TCP flags that are inconsistent in the forward and return directions.</p>
    /// <p>To mitigate: Prevent asymmetric routing issues caused by TCP flags by following these actions:</p>
    /// <ul>
    /// <li>
    /// <p>Remove unnecessary TCP flag inspections from the rules.</p></li>
    /// <li>
    /// <p>If you need to inspect TCP flags, check that the rules correctly account for changes in TCP flags throughout the TCP connection cycle, for example <code>SYN</code> and <code>ACK</code> flags used in a 3-way TCP handshake.</p></li>
    /// </ul></li>
    /// </ul>
    pub fn identified_type(mut self, input: crate::types::IdentifiedType) -> Self {
        self.identified_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The types of rule configurations that Network Firewall analyzes your rule groups for. Network Firewall analyzes stateless rule groups for the following types of rule configurations:</p>
    /// <ul>
    /// <li>
    /// <p><code>STATELESS_RULE_FORWARDING_ASYMMETRICALLY</code></p>
    /// <p>Cause: One or more stateless rules with the action <code>pass</code> or <code>forward</code> are forwarding traffic asymmetrically. Specifically, the rule's set of source IP addresses or their associated port numbers, don't match the set of destination IP addresses or their associated port numbers.</p>
    /// <p>To mitigate: Make sure that there's an existing return path. For example, if the rule allows traffic from source 10.1.0.0/24 to destination 20.1.0.0/24, you should allow return traffic from source 20.1.0.0/24 to destination 10.1.0.0/24.</p></li>
    /// <li>
    /// <p><code>STATELESS_RULE_CONTAINS_TCP_FLAGS</code></p>
    /// <p>Cause: At least one stateless rule with the action <code>pass</code> or<code>forward</code> contains TCP flags that are inconsistent in the forward and return directions.</p>
    /// <p>To mitigate: Prevent asymmetric routing issues caused by TCP flags by following these actions:</p>
    /// <ul>
    /// <li>
    /// <p>Remove unnecessary TCP flag inspections from the rules.</p></li>
    /// <li>
    /// <p>If you need to inspect TCP flags, check that the rules correctly account for changes in TCP flags throughout the TCP connection cycle, for example <code>SYN</code> and <code>ACK</code> flags used in a 3-way TCP handshake.</p></li>
    /// </ul></li>
    /// </ul>
    pub fn set_identified_type(mut self, input: ::std::option::Option<crate::types::IdentifiedType>) -> Self {
        self.identified_type = input;
        self
    }
    /// <p>The types of rule configurations that Network Firewall analyzes your rule groups for. Network Firewall analyzes stateless rule groups for the following types of rule configurations:</p>
    /// <ul>
    /// <li>
    /// <p><code>STATELESS_RULE_FORWARDING_ASYMMETRICALLY</code></p>
    /// <p>Cause: One or more stateless rules with the action <code>pass</code> or <code>forward</code> are forwarding traffic asymmetrically. Specifically, the rule's set of source IP addresses or their associated port numbers, don't match the set of destination IP addresses or their associated port numbers.</p>
    /// <p>To mitigate: Make sure that there's an existing return path. For example, if the rule allows traffic from source 10.1.0.0/24 to destination 20.1.0.0/24, you should allow return traffic from source 20.1.0.0/24 to destination 10.1.0.0/24.</p></li>
    /// <li>
    /// <p><code>STATELESS_RULE_CONTAINS_TCP_FLAGS</code></p>
    /// <p>Cause: At least one stateless rule with the action <code>pass</code> or<code>forward</code> contains TCP flags that are inconsistent in the forward and return directions.</p>
    /// <p>To mitigate: Prevent asymmetric routing issues caused by TCP flags by following these actions:</p>
    /// <ul>
    /// <li>
    /// <p>Remove unnecessary TCP flag inspections from the rules.</p></li>
    /// <li>
    /// <p>If you need to inspect TCP flags, check that the rules correctly account for changes in TCP flags throughout the TCP connection cycle, for example <code>SYN</code> and <code>ACK</code> flags used in a 3-way TCP handshake.</p></li>
    /// </ul></li>
    /// </ul>
    pub fn get_identified_type(&self) -> &::std::option::Option<crate::types::IdentifiedType> {
        &self.identified_type
    }
    /// <p>Provides analysis details for the identified rule.</p>
    pub fn analysis_detail(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.analysis_detail = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Provides analysis details for the identified rule.</p>
    pub fn set_analysis_detail(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.analysis_detail = input;
        self
    }
    /// <p>Provides analysis details for the identified rule.</p>
    pub fn get_analysis_detail(&self) -> &::std::option::Option<::std::string::String> {
        &self.analysis_detail
    }
    /// Consumes the builder and constructs a [`AnalysisResult`](crate::types::AnalysisResult).
    pub fn build(self) -> crate::types::AnalysisResult {
        crate::types::AnalysisResult {
            identified_rule_ids: self.identified_rule_ids,
            identified_type: self.identified_type,
            analysis_detail: self.analysis_detail,
        }
    }
}
