// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn associate_firewall_policy(&self) -> fluent_builders::AssociateFirewallPolicy<C> {
        fluent_builders::AssociateFirewallPolicy::new(self.handle.clone())
    }
    pub fn associate_subnets(&self) -> fluent_builders::AssociateSubnets<C> {
        fluent_builders::AssociateSubnets::new(self.handle.clone())
    }
    pub fn create_firewall(&self) -> fluent_builders::CreateFirewall<C> {
        fluent_builders::CreateFirewall::new(self.handle.clone())
    }
    pub fn create_firewall_policy(&self) -> fluent_builders::CreateFirewallPolicy<C> {
        fluent_builders::CreateFirewallPolicy::new(self.handle.clone())
    }
    pub fn create_rule_group(&self) -> fluent_builders::CreateRuleGroup<C> {
        fluent_builders::CreateRuleGroup::new(self.handle.clone())
    }
    pub fn delete_firewall(&self) -> fluent_builders::DeleteFirewall<C> {
        fluent_builders::DeleteFirewall::new(self.handle.clone())
    }
    pub fn delete_firewall_policy(&self) -> fluent_builders::DeleteFirewallPolicy<C> {
        fluent_builders::DeleteFirewallPolicy::new(self.handle.clone())
    }
    pub fn delete_resource_policy(&self) -> fluent_builders::DeleteResourcePolicy<C> {
        fluent_builders::DeleteResourcePolicy::new(self.handle.clone())
    }
    pub fn delete_rule_group(&self) -> fluent_builders::DeleteRuleGroup<C> {
        fluent_builders::DeleteRuleGroup::new(self.handle.clone())
    }
    pub fn describe_firewall(&self) -> fluent_builders::DescribeFirewall<C> {
        fluent_builders::DescribeFirewall::new(self.handle.clone())
    }
    pub fn describe_firewall_policy(&self) -> fluent_builders::DescribeFirewallPolicy<C> {
        fluent_builders::DescribeFirewallPolicy::new(self.handle.clone())
    }
    pub fn describe_logging_configuration(
        &self,
    ) -> fluent_builders::DescribeLoggingConfiguration<C> {
        fluent_builders::DescribeLoggingConfiguration::new(self.handle.clone())
    }
    pub fn describe_resource_policy(&self) -> fluent_builders::DescribeResourcePolicy<C> {
        fluent_builders::DescribeResourcePolicy::new(self.handle.clone())
    }
    pub fn describe_rule_group(&self) -> fluent_builders::DescribeRuleGroup<C> {
        fluent_builders::DescribeRuleGroup::new(self.handle.clone())
    }
    pub fn disassociate_subnets(&self) -> fluent_builders::DisassociateSubnets<C> {
        fluent_builders::DisassociateSubnets::new(self.handle.clone())
    }
    pub fn list_firewall_policies(&self) -> fluent_builders::ListFirewallPolicies<C> {
        fluent_builders::ListFirewallPolicies::new(self.handle.clone())
    }
    pub fn list_firewalls(&self) -> fluent_builders::ListFirewalls<C> {
        fluent_builders::ListFirewalls::new(self.handle.clone())
    }
    pub fn list_rule_groups(&self) -> fluent_builders::ListRuleGroups<C> {
        fluent_builders::ListRuleGroups::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn put_resource_policy(&self) -> fluent_builders::PutResourcePolicy<C> {
        fluent_builders::PutResourcePolicy::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_firewall_delete_protection(
        &self,
    ) -> fluent_builders::UpdateFirewallDeleteProtection<C> {
        fluent_builders::UpdateFirewallDeleteProtection::new(self.handle.clone())
    }
    pub fn update_firewall_description(&self) -> fluent_builders::UpdateFirewallDescription<C> {
        fluent_builders::UpdateFirewallDescription::new(self.handle.clone())
    }
    pub fn update_firewall_policy(&self) -> fluent_builders::UpdateFirewallPolicy<C> {
        fluent_builders::UpdateFirewallPolicy::new(self.handle.clone())
    }
    pub fn update_firewall_policy_change_protection(
        &self,
    ) -> fluent_builders::UpdateFirewallPolicyChangeProtection<C> {
        fluent_builders::UpdateFirewallPolicyChangeProtection::new(self.handle.clone())
    }
    pub fn update_logging_configuration(&self) -> fluent_builders::UpdateLoggingConfiguration<C> {
        fluent_builders::UpdateLoggingConfiguration::new(self.handle.clone())
    }
    pub fn update_rule_group(&self) -> fluent_builders::UpdateRuleGroup<C> {
        fluent_builders::UpdateRuleGroup::new(self.handle.clone())
    }
    pub fn update_subnet_change_protection(
        &self,
    ) -> fluent_builders::UpdateSubnetChangeProtection<C> {
        fluent_builders::UpdateSubnetChangeProtection::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AssociateFirewallPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_firewall_policy_input::Builder,
    }
    impl<C> AssociateFirewallPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateFirewallPolicyOutput,
            smithy_http::result::SdkError<crate::error::AssociateFirewallPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
        /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
        /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.update_token(input);
            self
        }
        pub fn set_update_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_update_token(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_arn(input);
            self
        }
        pub fn set_firewall_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_firewall_arn(input);
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_name(input);
            self
        }
        pub fn set_firewall_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall policy.</p>
        pub fn firewall_policy_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_policy_arn(input);
            self
        }
        pub fn set_firewall_policy_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_policy_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AssociateSubnets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_subnets_input::Builder,
    }
    impl<C> AssociateSubnets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateSubnetsOutput,
            smithy_http::result::SdkError<crate::error::AssociateSubnetsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
        /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
        /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.update_token(input);
            self
        }
        pub fn set_update_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_update_token(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_arn(input);
            self
        }
        pub fn set_firewall_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_firewall_arn(input);
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_name(input);
            self
        }
        pub fn set_firewall_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_name(input);
            self
        }
        /// <p>The IDs of the subnets that you want to associate with the firewall. </p>
        pub fn subnet_mappings(mut self, inp: impl Into<crate::model::SubnetMapping>) -> Self {
            self.inner = self.inner.subnet_mappings(inp);
            self
        }
        pub fn set_subnet_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SubnetMapping>>,
        ) -> Self {
            self.inner = self.inner.set_subnet_mappings(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateFirewall<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_firewall_input::Builder,
    }
    impl<C> CreateFirewall<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateFirewallOutput,
            smithy_http::result::SdkError<crate::error::CreateFirewallError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        pub fn firewall_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_name(input);
            self
        }
        pub fn set_firewall_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the <a>FirewallPolicy</a> that you want to
        /// use for the firewall.</p>
        pub fn firewall_policy_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_policy_arn(input);
            self
        }
        pub fn set_firewall_policy_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_policy_arn(input);
            self
        }
        /// <p>The unique identifier of the VPC where Network Firewall should create the firewall. </p>
        /// <p>You can't change this setting after you create the firewall. </p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>The public subnets to use for your Network Firewall firewalls. Each subnet must belong to a
        /// different Availability Zone in the VPC. Network Firewall creates a firewall endpoint in each
        /// subnet. </p>
        pub fn subnet_mappings(mut self, inp: impl Into<crate::model::SubnetMapping>) -> Self {
            self.inner = self.inner.subnet_mappings(inp);
            self
        }
        pub fn set_subnet_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SubnetMapping>>,
        ) -> Self {
            self.inner = self.inner.set_subnet_mappings(input);
            self
        }
        /// <p>A flag indicating whether it is possible to delete the firewall. A setting of <code>TRUE</code> indicates
        /// that the firewall is protected against deletion. Use this setting to protect against
        /// accidentally deleting a firewall that is in use. When you create a firewall, the operation initializes this flag to <code>TRUE</code>.</p>
        pub fn delete_protection(mut self, input: bool) -> Self {
            self.inner = self.inner.delete_protection(input);
            self
        }
        pub fn set_delete_protection(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_delete_protection(input);
            self
        }
        /// <p>A setting indicating whether the firewall is protected against changes to the subnet associations.
        /// Use this setting to protect against
        /// accidentally modifying the subnet associations for a firewall that is in use. When you create a firewall, the operation initializes this setting to <code>TRUE</code>.</p>
        pub fn subnet_change_protection(mut self, input: bool) -> Self {
            self.inner = self.inner.subnet_change_protection(input);
            self
        }
        pub fn set_subnet_change_protection(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_subnet_change_protection(input);
            self
        }
        /// <p>A setting indicating whether the firewall is protected against a change to the firewall policy association.
        /// Use this setting to protect against
        /// accidentally modifying the firewall policy for a firewall that is in use. When you create a firewall, the operation initializes this setting to <code>TRUE</code>.</p>
        pub fn firewall_policy_change_protection(mut self, input: bool) -> Self {
            self.inner = self.inner.firewall_policy_change_protection(input);
            self
        }
        pub fn set_firewall_policy_change_protection(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_firewall_policy_change_protection(input);
            self
        }
        /// <p>A description of the firewall.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The key:value pairs to associate with the resource.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateFirewallPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_firewall_policy_input::Builder,
    }
    impl<C> CreateFirewallPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateFirewallPolicyOutput,
            smithy_http::result::SdkError<crate::error::CreateFirewallPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The descriptive name of the firewall policy. You can't change the name of a firewall policy after you create it.</p>
        pub fn firewall_policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_policy_name(input);
            self
        }
        pub fn set_firewall_policy_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_policy_name(input);
            self
        }
        /// <p>The rule groups and policy actions to use in the firewall policy.</p>
        pub fn firewall_policy(mut self, input: crate::model::FirewallPolicy) -> Self {
            self.inner = self.inner.firewall_policy(input);
            self
        }
        pub fn set_firewall_policy(
            mut self,
            input: std::option::Option<crate::model::FirewallPolicy>,
        ) -> Self {
            self.inner = self.inner.set_firewall_policy(input);
            self
        }
        /// <p>A description of the firewall policy.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The key:value pairs to associate with the resource.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>Indicates whether you want Network Firewall to just check the validity of the request, rather than run the request. </p>
        /// <p>If set to <code>TRUE</code>, Network Firewall checks whether the request can run successfully,
        /// but doesn't actually make the requested changes. The call returns the value that the request would return if you ran it with
        /// dry run set to <code>FALSE</code>, but doesn't make additions or changes to your resources. This option allows you to make sure that you have
        /// the required permissions to run the request and that your request parameters are valid. </p>
        /// <p>If set to <code>FALSE</code>, Network Firewall makes the requested changes to your resources. </p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateRuleGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_rule_group_input::Builder,
    }
    impl<C> CreateRuleGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateRuleGroupOutput,
            smithy_http::result::SdkError<crate::error::CreateRuleGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The descriptive name of the rule group. You can't change the name of a rule group after you create it.</p>
        pub fn rule_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_group_name(input);
            self
        }
        pub fn set_rule_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rule_group_name(input);
            self
        }
        /// <p>An object that defines the rule group rules. </p>
        /// <note>
        /// <p>You must provide either this rule group setting or a <code>Rules</code> setting, but not both. </p>
        /// </note>
        pub fn rule_group(mut self, input: crate::model::RuleGroup) -> Self {
            self.inner = self.inner.rule_group(input);
            self
        }
        pub fn set_rule_group(
            mut self,
            input: std::option::Option<crate::model::RuleGroup>,
        ) -> Self {
            self.inner = self.inner.set_rule_group(input);
            self
        }
        /// <p>A string containing stateful rule group rules specifications in Suricata flat format, with one rule
        /// per line. Use this to import your existing Suricata compatible rule groups. </p>
        /// <note>
        /// <p>You must provide either this rules setting or a populated <code>RuleGroup</code> setting, but not both. </p>
        /// </note>  
        /// <p>You can provide your rule group specification in Suricata flat format through this setting when you create or update your rule group. The call
        /// response returns a <a>RuleGroup</a> object that Network Firewall has populated from your string. </p>
        pub fn rules(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rules(input);
            self
        }
        pub fn set_rules(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_rules(input);
            self
        }
        /// <p>Indicates whether the rule group is stateless or stateful. If the rule group is stateless, it contains
        /// stateless rules. If it is stateful, it contains stateful rules. </p>
        pub fn r#type(mut self, input: crate::model::RuleGroupType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::RuleGroupType>) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>A description of the rule group. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The maximum operating resources that this rule group can use. Rule group capacity is fixed at creation.
        /// When you update a rule group, you are limited to this capacity. When you reference a rule group
        /// from a firewall policy, Network Firewall reserves this capacity for the rule group. </p>
        /// <p>You can retrieve the capacity that would be required for a rule group before you create the rule group by calling
        /// <a>CreateRuleGroup</a> with <code>DryRun</code> set to <code>TRUE</code>. </p>
        /// <note>
        /// <p>You can't change or exceed this capacity when you update the rule group, so leave
        /// room for your rule group to grow. </p>
        /// </note>
        /// <p>
        /// <b>Capacity for a stateless rule group</b>
        /// </p>
        /// <p>For a stateless rule group, the capacity required is the sum of the capacity
        /// requirements of the individual rules that you expect to have in the rule group. </p>
        /// <p>To calculate the capacity requirement of a single rule, multiply the capacity
        /// requirement values of each of the rule's match settings:</p>
        /// <ul>
        /// <li>
        /// <p>A match setting with no criteria specified has a value of 1. </p>
        /// </li>
        /// <li>
        /// <p>A match setting with <code>Any</code> specified has a value of 1. </p>
        /// </li>
        /// <li>
        /// <p>All other match settings have a value equal to the number of elements provided in
        /// the setting. For example, a protocol setting ["UDP"] and a source setting
        /// ["10.0.0.0/24"] each have a value of 1. A protocol setting ["UDP","TCP"] has a value
        /// of 2. A source setting ["10.0.0.0/24","10.0.0.1/24","10.0.0.2/24"] has a value of 3.
        /// </p>
        /// </li>
        /// </ul>
        /// <p>A rule with no criteria specified in any of its match settings has a capacity
        /// requirement of 1. A rule with protocol setting ["UDP","TCP"], source setting
        /// ["10.0.0.0/24","10.0.0.1/24","10.0.0.2/24"], and a single specification or no specification
        /// for each of the other match settings has a capacity requirement of 6. </p>
        /// <p>
        /// <b>Capacity for a stateful rule group</b>
        /// </p>
        /// <p>For
        /// a stateful rule group, the minimum capacity required is the number of individual rules that
        /// you expect to have in the rule group. </p>
        pub fn capacity(mut self, input: i32) -> Self {
            self.inner = self.inner.capacity(input);
            self
        }
        pub fn set_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_capacity(input);
            self
        }
        /// <p>The key:value pairs to associate with the resource.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>Indicates whether you want Network Firewall to just check the validity of the request, rather than run the request. </p>
        /// <p>If set to <code>TRUE</code>, Network Firewall checks whether the request can run successfully,
        /// but doesn't actually make the requested changes. The call returns the value that the request would return if you ran it with
        /// dry run set to <code>FALSE</code>, but doesn't make additions or changes to your resources. This option allows you to make sure that you have
        /// the required permissions to run the request and that your request parameters are valid. </p>
        /// <p>If set to <code>FALSE</code>, Network Firewall makes the requested changes to your resources. </p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFirewall<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_firewall_input::Builder,
    }
    impl<C> DeleteFirewall<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFirewallOutput,
            smithy_http::result::SdkError<crate::error::DeleteFirewallError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_name(input);
            self
        }
        pub fn set_firewall_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_arn(input);
            self
        }
        pub fn set_firewall_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_firewall_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFirewallPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_firewall_policy_input::Builder,
    }
    impl<C> DeleteFirewallPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFirewallPolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteFirewallPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The descriptive name of the firewall policy. You can't change the name of a firewall policy after you create it.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_policy_name(input);
            self
        }
        pub fn set_firewall_policy_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_policy_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall policy.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_policy_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_policy_arn(input);
            self
        }
        pub fn set_firewall_policy_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_policy_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteResourcePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_resource_policy_input::Builder,
    }
    impl<C> DeleteResourcePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteResourcePolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteResourcePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the rule group or firewall policy whose resource policy you want to delete. </p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRuleGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_rule_group_input::Builder,
    }
    impl<C> DeleteRuleGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteRuleGroupOutput,
            smithy_http::result::SdkError<crate::error::DeleteRuleGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The descriptive name of the rule group. You can't change the name of a rule group after you create it.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn rule_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_group_name(input);
            self
        }
        pub fn set_rule_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rule_group_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the rule group.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn rule_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_group_arn(input);
            self
        }
        pub fn set_rule_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rule_group_arn(input);
            self
        }
        /// <p>Indicates whether the rule group is stateless or stateful. If the rule group is stateless, it contains
        /// stateless rules. If it is stateful, it contains stateful rules. </p>
        /// <note>
        /// <p>This setting is required for requests that do not include the <code>RuleGroupARN</code>.</p>
        /// </note>
        pub fn r#type(mut self, input: crate::model::RuleGroupType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::RuleGroupType>) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFirewall<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_firewall_input::Builder,
    }
    impl<C> DescribeFirewall<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFirewallOutput,
            smithy_http::result::SdkError<crate::error::DescribeFirewallError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_name(input);
            self
        }
        pub fn set_firewall_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_arn(input);
            self
        }
        pub fn set_firewall_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_firewall_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFirewallPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_firewall_policy_input::Builder,
    }
    impl<C> DescribeFirewallPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFirewallPolicyOutput,
            smithy_http::result::SdkError<crate::error::DescribeFirewallPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The descriptive name of the firewall policy. You can't change the name of a firewall policy after you create it.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_policy_name(input);
            self
        }
        pub fn set_firewall_policy_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_policy_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall policy.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_policy_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_policy_arn(input);
            self
        }
        pub fn set_firewall_policy_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_policy_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLoggingConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_logging_configuration_input::Builder,
    }
    impl<C> DescribeLoggingConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLoggingConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DescribeLoggingConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_arn(input);
            self
        }
        pub fn set_firewall_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_firewall_arn(input);
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_name(input);
            self
        }
        pub fn set_firewall_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeResourcePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_resource_policy_input::Builder,
    }
    impl<C> DescribeResourcePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeResourcePolicyOutput,
            smithy_http::result::SdkError<crate::error::DescribeResourcePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the rule group or firewall policy whose resource policy you want to retrieve. </p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeRuleGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_rule_group_input::Builder,
    }
    impl<C> DescribeRuleGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeRuleGroupOutput,
            smithy_http::result::SdkError<crate::error::DescribeRuleGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The descriptive name of the rule group. You can't change the name of a rule group after you create it.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn rule_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_group_name(input);
            self
        }
        pub fn set_rule_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rule_group_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the rule group.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn rule_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_group_arn(input);
            self
        }
        pub fn set_rule_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rule_group_arn(input);
            self
        }
        /// <p>Indicates whether the rule group is stateless or stateful. If the rule group is stateless, it contains
        /// stateless rules. If it is stateful, it contains stateful rules. </p>
        /// <note>
        /// <p>This setting is required for requests that do not include the <code>RuleGroupARN</code>.</p>
        /// </note>
        pub fn r#type(mut self, input: crate::model::RuleGroupType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::RuleGroupType>) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateSubnets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disassociate_subnets_input::Builder,
    }
    impl<C> DisassociateSubnets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateSubnetsOutput,
            smithy_http::result::SdkError<crate::error::DisassociateSubnetsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
        /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
        /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.update_token(input);
            self
        }
        pub fn set_update_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_update_token(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_arn(input);
            self
        }
        pub fn set_firewall_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_firewall_arn(input);
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_name(input);
            self
        }
        pub fn set_firewall_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_name(input);
            self
        }
        /// <p>The unique identifiers for the subnets that you want to disassociate. </p>
        pub fn subnet_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_ids(inp);
            self
        }
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subnet_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFirewallPolicies<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_firewall_policies_input::Builder,
    }
    impl<C> ListFirewallPolicies<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFirewallPoliciesOutput,
            smithy_http::result::SdkError<crate::error::ListFirewallPoliciesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available
        /// for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code>
        /// value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of objects that you want Network Firewall to return for this request. If more
        /// objects are available, in the response, Network Firewall provides a
        /// <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFirewalls<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_firewalls_input::Builder,
    }
    impl<C> ListFirewalls<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFirewallsOutput,
            smithy_http::result::SdkError<crate::error::ListFirewallsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available
        /// for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code>
        /// value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The unique identifiers of the VPCs that you want Network Firewall to retrieve the firewalls
        /// for. Leave this blank to retrieve all firewalls that you have defined.</p>
        pub fn vpc_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_ids(inp);
            self
        }
        pub fn set_vpc_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_vpc_ids(input);
            self
        }
        /// <p>The maximum number of objects that you want Network Firewall to return for this request. If more
        /// objects are available, in the response, Network Firewall provides a
        /// <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListRuleGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_rule_groups_input::Builder,
    }
    impl<C> ListRuleGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListRuleGroupsOutput,
            smithy_http::result::SdkError<crate::error::ListRuleGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available
        /// for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code>
        /// value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of objects that you want Network Firewall to return for this request. If more
        /// objects are available, in the response, Network Firewall provides a
        /// <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available
        /// for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code>
        /// value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of objects that you want Network Firewall to return for this request. If more
        /// objects are available, in the response, Network Firewall provides a
        /// <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutResourcePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_resource_policy_input::Builder,
    }
    impl<C> PutResourcePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutResourcePolicyOutput,
            smithy_http::result::SdkError<crate::error::PutResourcePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the account that you want to share rule groups and firewall policies with.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The AWS Identity and Access Management policy statement that lists the accounts that you want to share your rule group or firewall policy with
        /// and the operations that you want the accounts to be able to perform. </p>
        /// <p>For a rule group resource, you can specify the following operations in the Actions section of the statement:</p>
        /// <ul>
        /// <li>
        /// <p>network-firewall:CreateFirewallPolicy</p>
        /// </li>
        /// <li>
        /// <p>network-firewall:UpdateFirewallPolicy</p>
        /// </li>
        /// <li>
        /// <p>network-firewall:ListRuleGroups</p>
        /// </li>
        /// </ul>
        /// <p>For a firewall policy resource, you can specify the following operations in the Actions section of the statement:</p>
        /// <ul>
        /// <li>
        /// <p>network-firewall:CreateFirewall</p>
        /// </li>
        /// <li>
        /// <p>network-firewall:UpdateFirewall</p>
        /// </li>
        /// <li>
        /// <p>network-firewall:AssociateFirewallPolicy</p>
        /// </li>
        /// <li>
        /// <p>network-firewall:ListFirewallPolicies</p>
        /// </li>
        /// </ul>
        /// <p>In the Resource section of the statement, you specify the ARNs for the rule groups and firewall policies that you want to share with the account that you specified in <code>Arn</code>.</p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(input);
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p></p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p></p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFirewallDeleteProtection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_firewall_delete_protection_input::Builder,
    }
    impl<C> UpdateFirewallDeleteProtection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateFirewallDeleteProtectionOutput,
            smithy_http::result::SdkError<crate::error::UpdateFirewallDeleteProtectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
        /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
        /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.update_token(input);
            self
        }
        pub fn set_update_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_update_token(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_arn(input);
            self
        }
        pub fn set_firewall_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_firewall_arn(input);
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_name(input);
            self
        }
        pub fn set_firewall_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_name(input);
            self
        }
        /// <p>A flag indicating whether it is possible to delete the firewall. A setting of <code>TRUE</code> indicates
        /// that the firewall is protected against deletion. Use this setting to protect against
        /// accidentally deleting a firewall that is in use. When you create a firewall, the operation initializes this flag to <code>TRUE</code>.</p>
        pub fn delete_protection(mut self, input: bool) -> Self {
            self.inner = self.inner.delete_protection(input);
            self
        }
        pub fn set_delete_protection(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_delete_protection(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFirewallDescription<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_firewall_description_input::Builder,
    }
    impl<C> UpdateFirewallDescription<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateFirewallDescriptionOutput,
            smithy_http::result::SdkError<crate::error::UpdateFirewallDescriptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
        /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
        /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.update_token(input);
            self
        }
        pub fn set_update_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_update_token(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_arn(input);
            self
        }
        pub fn set_firewall_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_firewall_arn(input);
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_name(input);
            self
        }
        pub fn set_firewall_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_name(input);
            self
        }
        /// <p>The new description for the firewall. If you omit this setting, Network Firewall removes
        /// the description for the firewall.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFirewallPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_firewall_policy_input::Builder,
    }
    impl<C> UpdateFirewallPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateFirewallPolicyOutput,
            smithy_http::result::SdkError<crate::error::UpdateFirewallPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the firewall policy. The token marks the state of the policy resource at the time of the request. </p>
        /// <p>To make changes to the policy, you provide the token in your request. Network Firewall uses the token to ensure that the policy hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall policy again to get a current copy of it with current token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.update_token(input);
            self
        }
        pub fn set_update_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_update_token(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall policy.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_policy_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_policy_arn(input);
            self
        }
        pub fn set_firewall_policy_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_policy_arn(input);
            self
        }
        /// <p>The descriptive name of the firewall policy. You can't change the name of a firewall policy after you create it.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_policy_name(input);
            self
        }
        pub fn set_firewall_policy_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_policy_name(input);
            self
        }
        /// <p>The updated firewall policy to use for the firewall. </p>
        pub fn firewall_policy(mut self, input: crate::model::FirewallPolicy) -> Self {
            self.inner = self.inner.firewall_policy(input);
            self
        }
        pub fn set_firewall_policy(
            mut self,
            input: std::option::Option<crate::model::FirewallPolicy>,
        ) -> Self {
            self.inner = self.inner.set_firewall_policy(input);
            self
        }
        /// <p>A description of the firewall policy.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Indicates whether you want Network Firewall to just check the validity of the request, rather than run the request. </p>
        /// <p>If set to <code>TRUE</code>, Network Firewall checks whether the request can run successfully,
        /// but doesn't actually make the requested changes. The call returns the value that the request would return if you ran it with
        /// dry run set to <code>FALSE</code>, but doesn't make additions or changes to your resources. This option allows you to make sure that you have
        /// the required permissions to run the request and that your request parameters are valid. </p>
        /// <p>If set to <code>FALSE</code>, Network Firewall makes the requested changes to your resources. </p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFirewallPolicyChangeProtection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_firewall_policy_change_protection_input::Builder,
    }
    impl<C> UpdateFirewallPolicyChangeProtection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateFirewallPolicyChangeProtectionOutput,
            smithy_http::result::SdkError<crate::error::UpdateFirewallPolicyChangeProtectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
        /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
        /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.update_token(input);
            self
        }
        pub fn set_update_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_update_token(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_arn(input);
            self
        }
        pub fn set_firewall_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_firewall_arn(input);
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_name(input);
            self
        }
        pub fn set_firewall_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_name(input);
            self
        }
        /// <p>A setting indicating whether the firewall is protected against a change to the firewall policy association.
        /// Use this setting to protect against
        /// accidentally modifying the firewall policy for a firewall that is in use. When you create a firewall, the operation initializes this setting to <code>TRUE</code>.</p>
        pub fn firewall_policy_change_protection(mut self, input: bool) -> Self {
            self.inner = self.inner.firewall_policy_change_protection(input);
            self
        }
        pub fn set_firewall_policy_change_protection(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_firewall_policy_change_protection(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateLoggingConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_logging_configuration_input::Builder,
    }
    impl<C> UpdateLoggingConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateLoggingConfigurationOutput,
            smithy_http::result::SdkError<crate::error::UpdateLoggingConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_arn(input);
            self
        }
        pub fn set_firewall_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_firewall_arn(input);
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_name(input);
            self
        }
        pub fn set_firewall_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_name(input);
            self
        }
        /// <p>Defines how Network Firewall performs logging for a firewall. If you omit this setting,
        /// Network Firewall disables logging for the firewall.</p>
        pub fn logging_configuration(mut self, input: crate::model::LoggingConfiguration) -> Self {
            self.inner = self.inner.logging_configuration(input);
            self
        }
        pub fn set_logging_configuration(
            mut self,
            input: std::option::Option<crate::model::LoggingConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_logging_configuration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateRuleGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_rule_group_input::Builder,
    }
    impl<C> UpdateRuleGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateRuleGroupOutput,
            smithy_http::result::SdkError<crate::error::UpdateRuleGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the rule group. The token marks the state of the rule group resource at the time of the request. </p>
        /// <p>To make changes to the rule group, you provide the token in your request. Network Firewall uses the token to ensure that the rule group hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the rule group again to get a current copy of it with a current token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.update_token(input);
            self
        }
        pub fn set_update_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_update_token(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the rule group.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn rule_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_group_arn(input);
            self
        }
        pub fn set_rule_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rule_group_arn(input);
            self
        }
        /// <p>The descriptive name of the rule group. You can't change the name of a rule group after you create it.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn rule_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_group_name(input);
            self
        }
        pub fn set_rule_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rule_group_name(input);
            self
        }
        /// <p>An object that defines the rule group rules. </p>
        /// <note>
        /// <p>You must provide either this rule group setting or a <code>Rules</code> setting, but not both. </p>
        /// </note>
        pub fn rule_group(mut self, input: crate::model::RuleGroup) -> Self {
            self.inner = self.inner.rule_group(input);
            self
        }
        pub fn set_rule_group(
            mut self,
            input: std::option::Option<crate::model::RuleGroup>,
        ) -> Self {
            self.inner = self.inner.set_rule_group(input);
            self
        }
        /// <p>A string containing stateful rule group rules specifications in Suricata flat format, with one rule
        /// per line. Use this to import your existing Suricata compatible rule groups. </p>
        /// <note>
        /// <p>You must provide either this rules setting or a populated <code>RuleGroup</code> setting, but not both. </p>
        /// </note>  
        /// <p>You can provide your rule group specification in Suricata flat format through this setting when you create or update your rule group. The call
        /// response returns a <a>RuleGroup</a> object that Network Firewall has populated from your string. </p>
        pub fn rules(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rules(input);
            self
        }
        pub fn set_rules(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_rules(input);
            self
        }
        /// <p>Indicates whether the rule group is stateless or stateful. If the rule group is stateless, it contains
        /// stateless rules. If it is stateful, it contains stateful rules. </p>
        /// <note>
        /// <p>This setting is required for requests that do not include the <code>RuleGroupARN</code>.</p>
        /// </note>
        pub fn r#type(mut self, input: crate::model::RuleGroupType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::RuleGroupType>) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>A description of the rule group. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Indicates whether you want Network Firewall to just check the validity of the request, rather than run the request. </p>
        /// <p>If set to <code>TRUE</code>, Network Firewall checks whether the request can run successfully,
        /// but doesn't actually make the requested changes. The call returns the value that the request would return if you ran it with
        /// dry run set to <code>FALSE</code>, but doesn't make additions or changes to your resources. This option allows you to make sure that you have
        /// the required permissions to run the request and that your request parameters are valid. </p>
        /// <p>If set to <code>FALSE</code>, Network Firewall makes the requested changes to your resources. </p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateSubnetChangeProtection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_subnet_change_protection_input::Builder,
    }
    impl<C> UpdateSubnetChangeProtection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateSubnetChangeProtectionOutput,
            smithy_http::result::SdkError<crate::error::UpdateSubnetChangeProtectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
        /// <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
        /// <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
        pub fn update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.update_token(input);
            self
        }
        pub fn set_update_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_update_token(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_arn(input);
            self
        }
        pub fn set_firewall_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_firewall_arn(input);
            self
        }
        /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
        /// <p>You must specify the ARN or the name, and you can specify both. </p>
        pub fn firewall_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firewall_name(input);
            self
        }
        pub fn set_firewall_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_firewall_name(input);
            self
        }
        /// <p>A setting indicating whether the firewall is protected against changes to the subnet associations.
        /// Use this setting to protect against
        /// accidentally modifying the subnet associations for a firewall that is in use. When you create a firewall, the operation initializes this setting to <code>TRUE</code>.</p>
        pub fn subnet_change_protection(mut self, input: bool) -> Self {
            self.inner = self.inner.subnet_change_protection(input);
            self
        }
        pub fn set_subnet_change_protection(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_subnet_change_protection(input);
            self
        }
    }
}
