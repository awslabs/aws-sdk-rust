// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub fn parse_generic_error(
    response: &http::Response<bytes::Bytes>,
) -> Result<smithy_types::Error, serde_json::Error> {
    let body =
        serde_json::from_slice(response.body().as_ref()).unwrap_or_else(|_| serde_json::json!({}));
    Ok(crate::aws_json_errors::parse_generic_error(
        &response, &body,
    ))
}

pub fn internal_server_exception(
    input: &[u8],
    mut builder: crate::error::internal_server_error::Builder,
) -> std::result::Result<crate::error::internal_server_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::InternalServerError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn resource_not_found_exception(
    input: &[u8],
    mut builder: crate::error::resource_not_found_error::Builder,
) -> std::result::Result<crate::error::resource_not_found_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::ResourceNotFoundError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn throttling_exception(
    input: &[u8],
    mut builder: crate::error::throttling_error::Builder,
) -> std::result::Result<crate::error::throttling_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::ThrottlingError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn validation_exception(
    input: &[u8],
    mut builder: crate::error::validation_error::Builder,
) -> std::result::Result<crate::error::validation_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::ValidationError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn describe_human_loop_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_human_loop_output::Builder,
) -> std::result::Result<crate::output::describe_human_loop_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeHumanLoopOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_creation_time(parsed_body.creation_time);
    builder = builder.set_failure_reason(parsed_body.failure_reason);
    builder = builder.set_failure_code(parsed_body.failure_code);
    builder = builder.set_human_loop_status(parsed_body.human_loop_status);
    builder = builder.set_human_loop_name(parsed_body.human_loop_name);
    builder = builder.set_human_loop_arn(parsed_body.human_loop_arn);
    builder = builder.set_flow_definition_arn(parsed_body.flow_definition_arn);
    builder = builder.set_human_loop_output(parsed_body.human_loop_output);
    Ok(builder)
}

pub fn list_human_loops_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_human_loops_output::Builder,
) -> std::result::Result<crate::output::list_human_loops_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListHumanLoopsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_human_loop_summaries(parsed_body.human_loop_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn conflict_exception(
    input: &[u8],
    mut builder: crate::error::conflict_error::Builder,
) -> std::result::Result<crate::error::conflict_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::ConflictError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn service_quota_exceeded_exception(
    input: &[u8],
    mut builder: crate::error::service_quota_exceeded_error::Builder,
) -> std::result::Result<crate::error::service_quota_exceeded_error::Builder, serde_json::Error> {
    let parsed_body: crate::error::ServiceQuotaExceededError = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_message(parsed_body.message);
    Ok(builder)
}

pub fn start_human_loop_deser_operation(
    input: &[u8],
    mut builder: crate::output::start_human_loop_output::Builder,
) -> std::result::Result<crate::output::start_human_loop_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::StartHumanLoopOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_human_loop_arn(parsed_body.human_loop_arn);
    Ok(builder)
}
