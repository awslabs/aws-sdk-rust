// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn add_notification_channels(&self) -> fluent_builders::AddNotificationChannels<C> {
        fluent_builders::AddNotificationChannels::new(self.handle.clone())
    }
    pub fn batch_get_frame_metric_data(&self) -> fluent_builders::BatchGetFrameMetricData<C> {
        fluent_builders::BatchGetFrameMetricData::new(self.handle.clone())
    }
    pub fn configure_agent(&self) -> fluent_builders::ConfigureAgent<C> {
        fluent_builders::ConfigureAgent::new(self.handle.clone())
    }
    pub fn create_profiling_group(&self) -> fluent_builders::CreateProfilingGroup<C> {
        fluent_builders::CreateProfilingGroup::new(self.handle.clone())
    }
    pub fn delete_profiling_group(&self) -> fluent_builders::DeleteProfilingGroup<C> {
        fluent_builders::DeleteProfilingGroup::new(self.handle.clone())
    }
    pub fn describe_profiling_group(&self) -> fluent_builders::DescribeProfilingGroup<C> {
        fluent_builders::DescribeProfilingGroup::new(self.handle.clone())
    }
    pub fn get_findings_report_account_summary(
        &self,
    ) -> fluent_builders::GetFindingsReportAccountSummary<C> {
        fluent_builders::GetFindingsReportAccountSummary::new(self.handle.clone())
    }
    pub fn get_notification_configuration(
        &self,
    ) -> fluent_builders::GetNotificationConfiguration<C> {
        fluent_builders::GetNotificationConfiguration::new(self.handle.clone())
    }
    pub fn get_policy(&self) -> fluent_builders::GetPolicy<C> {
        fluent_builders::GetPolicy::new(self.handle.clone())
    }
    pub fn get_profile(&self) -> fluent_builders::GetProfile<C> {
        fluent_builders::GetProfile::new(self.handle.clone())
    }
    pub fn get_recommendations(&self) -> fluent_builders::GetRecommendations<C> {
        fluent_builders::GetRecommendations::new(self.handle.clone())
    }
    pub fn list_findings_reports(&self) -> fluent_builders::ListFindingsReports<C> {
        fluent_builders::ListFindingsReports::new(self.handle.clone())
    }
    pub fn list_profile_times(&self) -> fluent_builders::ListProfileTimes<C> {
        fluent_builders::ListProfileTimes::new(self.handle.clone())
    }
    pub fn list_profiling_groups(&self) -> fluent_builders::ListProfilingGroups<C> {
        fluent_builders::ListProfilingGroups::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn post_agent_profile(&self) -> fluent_builders::PostAgentProfile<C> {
        fluent_builders::PostAgentProfile::new(self.handle.clone())
    }
    pub fn put_permission(&self) -> fluent_builders::PutPermission<C> {
        fluent_builders::PutPermission::new(self.handle.clone())
    }
    pub fn remove_notification_channel(&self) -> fluent_builders::RemoveNotificationChannel<C> {
        fluent_builders::RemoveNotificationChannel::new(self.handle.clone())
    }
    pub fn remove_permission(&self) -> fluent_builders::RemovePermission<C> {
        fluent_builders::RemovePermission::new(self.handle.clone())
    }
    pub fn submit_feedback(&self) -> fluent_builders::SubmitFeedback<C> {
        fluent_builders::SubmitFeedback::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_profiling_group(&self) -> fluent_builders::UpdateProfilingGroup<C> {
        fluent_builders::UpdateProfilingGroup::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AddNotificationChannels<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_notification_channels_input::Builder,
    }
    impl<C> AddNotificationChannels<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddNotificationChannelsOutput,
            smithy_http::result::SdkError<crate::error::AddNotificationChannelsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the profiling group that we are setting up notifications for.</p>
        pub fn profiling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.profiling_group_name(input);
            self
        }
        pub fn set_profiling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_profiling_group_name(input);
            self
        }
        /// <p>One or 2 channels to report to when anomalies are detected.</p>
        pub fn channels(mut self, inp: impl Into<crate::model::Channel>) -> Self {
            self.inner = self.inner.channels(inp);
            self
        }
        pub fn set_channels(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Channel>>,
        ) -> Self {
            self.inner = self.inner.set_channels(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchGetFrameMetricData<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_get_frame_metric_data_input::Builder,
    }
    impl<C> BatchGetFrameMetricData<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchGetFrameMetricDataOutput,
            smithy_http::result::SdkError<crate::error::BatchGetFrameMetricDataError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the profiling group associated with the
        /// the frame metrics used to return the time series values.
        /// </p>
        pub fn profiling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.profiling_group_name(input);
            self
        }
        pub fn set_profiling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_profiling_group_name(input);
            self
        }
        /// <p>
        /// The start time of the time period for the frame metrics used to return the time series values.
        /// This is specified
        /// using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
        /// millisecond past June 1, 2020 1:15:02 PM UTC.
        /// </p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>
        /// The end time of the time period for the returned time series values.
        /// This is specified
        /// using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
        /// millisecond past June 1, 2020 1:15:02 PM UTC.
        /// </p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>
        /// The duration of the frame metrics used to return the time series values.
        /// Specify using the ISO 8601 format. The maximum period duration
        /// is one day (<code>PT24H</code> or <code>P1D</code>).
        /// </p>
        pub fn period(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.period(input);
            self
        }
        pub fn set_period(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_period(input);
            self
        }
        /// <p>The requested resolution of time steps for the returned time series of values.
        /// If the requested target resolution is not available due to data not being retained we provide a best effort
        /// result by falling back to the most granular available resolution after the target resolution.
        /// There are 3 valid values.
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>P1D</code> — 1 day
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PT1H</code> — 1 hour
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PT5M</code> — 5 minutes
        /// </p>
        /// </li>
        /// </ul>
        pub fn target_resolution(mut self, input: crate::model::AggregationPeriod) -> Self {
            self.inner = self.inner.target_resolution(input);
            self
        }
        pub fn set_target_resolution(
            mut self,
            input: std::option::Option<crate::model::AggregationPeriod>,
        ) -> Self {
            self.inner = self.inner.set_target_resolution(input);
            self
        }
        /// <p>
        /// The details of the metrics that are used to request a time series of values. The metric includes
        /// the name of the frame, the aggregation type to calculate the metric value for the
        /// frame, and the thread states to use to get the count for the metric value of the frame.</p>
        pub fn frame_metrics(mut self, inp: impl Into<crate::model::FrameMetric>) -> Self {
            self.inner = self.inner.frame_metrics(inp);
            self
        }
        pub fn set_frame_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FrameMetric>>,
        ) -> Self {
            self.inner = self.inner.set_frame_metrics(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ConfigureAgent<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::configure_agent_input::Builder,
    }
    impl<C> ConfigureAgent<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ConfigureAgentOutput,
            smithy_http::result::SdkError<crate::error::ConfigureAgentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the profiling group for which the configured agent is collecting profiling data.
        /// </p>
        pub fn profiling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.profiling_group_name(input);
            self
        }
        pub fn set_profiling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_profiling_group_name(input);
            self
        }
        /// <p> A universally unique identifier (UUID) for a profiling instance. For example, if the
        /// profiling instance is an Amazon EC2 instance, it is the instance ID. If it is an AWS
        /// Fargate container, it is the container's task ID. </p>
        pub fn fleet_instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_instance_id(input);
            self
        }
        pub fn set_fleet_instance_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_fleet_instance_id(input);
            self
        }
        /// <p> Metadata captured about the compute platform the agent is running on. It includes
        /// information about sampling and reporting. The valid fields are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>COMPUTE_PLATFORM</code> - The compute platform on which the agent is running
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AGENT_ID</code> - The ID for an agent instance.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AWS_REQUEST_ID</code> - The AWS request ID of a Lambda invocation.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EXECUTION_ENVIRONMENT</code> - The execution environment a Lambda function is running on.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LAMBDA_FUNCTION_ARN</code> - The Amazon Resource Name (ARN) that is used to invoke a Lambda function.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LAMBDA_MEMORY_LIMIT_IN_MB</code> - The memory allocated to a Lambda function.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LAMBDA_REMAINING_TIME_IN_MILLISECONDS</code> - The time in milliseconds before execution of a Lambda function times out.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LAMBDA_TIME_GAP_BETWEEN_INVOKES_IN_MILLISECONDS</code> - The time in milliseconds between two invocations of a Lambda function.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LAMBDA_PREVIOUS_EXECUTION_TIME_IN_MILLISECONDS</code> - The time in milliseconds for the previous Lambda invocation.
        /// </p>
        /// </li>
        /// </ul>
        pub fn metadata(
            mut self,
            k: impl Into<crate::model::MetadataField>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.metadata(k, v);
            self
        }
        pub fn set_metadata(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<crate::model::MetadataField, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_metadata(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateProfilingGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_profiling_group_input::Builder,
    }
    impl<C> CreateProfilingGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateProfilingGroupOutput,
            smithy_http::result::SdkError<crate::error::CreateProfilingGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the profiling group to create.</p>
        pub fn profiling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.profiling_group_name(input);
            self
        }
        pub fn set_profiling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_profiling_group_name(input);
            self
        }
        /// <p>
        /// The compute platform of the profiling group. Use <code>AWSLambda</code> if your application
        /// runs on AWS Lambda. Use <code>Default</code> if your application runs on a compute platform that
        /// is not AWS Lambda, such an Amazon EC2 instance, an on-premises server, or a different platform.
        /// If not specified, <code>Default</code> is used.         
        /// </p>
        pub fn compute_platform(mut self, input: crate::model::ComputePlatform) -> Self {
            self.inner = self.inner.compute_platform(input);
            self
        }
        pub fn set_compute_platform(
            mut self,
            input: std::option::Option<crate::model::ComputePlatform>,
        ) -> Self {
            self.inner = self.inner.set_compute_platform(input);
            self
        }
        /// <p> Amazon CodeGuru Profiler uses this universally unique identifier (UUID) to prevent the
        /// accidental creation of duplicate profiling groups if there are failures and retries. </p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>
        /// Specifies whether profiling is enabled or disabled for the created profiling group.
        /// </p>
        pub fn agent_orchestration_config(
            mut self,
            input: crate::model::AgentOrchestrationConfig,
        ) -> Self {
            self.inner = self.inner.agent_orchestration_config(input);
            self
        }
        pub fn set_agent_orchestration_config(
            mut self,
            input: std::option::Option<crate::model::AgentOrchestrationConfig>,
        ) -> Self {
            self.inner = self.inner.set_agent_orchestration_config(input);
            self
        }
        /// <p>
        /// A list of tags to add to the created profiling group.
        /// </p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteProfilingGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_profiling_group_input::Builder,
    }
    impl<C> DeleteProfilingGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteProfilingGroupOutput,
            smithy_http::result::SdkError<crate::error::DeleteProfilingGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the profiling group to delete.</p>
        pub fn profiling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.profiling_group_name(input);
            self
        }
        pub fn set_profiling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_profiling_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeProfilingGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_profiling_group_input::Builder,
    }
    impl<C> DescribeProfilingGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeProfilingGroupOutput,
            smithy_http::result::SdkError<crate::error::DescribeProfilingGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the profiling group to get information about.
        /// </p>
        pub fn profiling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.profiling_group_name(input);
            self
        }
        pub fn set_profiling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_profiling_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFindingsReportAccountSummary<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_findings_report_account_summary_input::Builder,
    }
    impl<C> GetFindingsReportAccountSummary<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetFindingsReportAccountSummaryOutput,
            smithy_http::result::SdkError<crate::error::GetFindingsReportAccountSummaryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The <code>nextToken</code> value returned from a previous paginated <code>GetFindingsReportAccountSummary</code>
        /// request where <code>maxResults</code> was used and the results exceeded the value of that parameter.
        /// Pagination continues from the end of the previous results that returned the <code>nextToken</code> value.
        /// </p>
        /// <note>
        /// <p>This token should be treated as an opaque identifier that is only used to retrieve
        /// the next items in a list and not for other programmatic purposes.</p>
        /// </note>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results returned by <code> GetFindingsReportAccountSummary</code> in paginated output.
        /// When this parameter is used, <code>GetFindingsReportAccountSummary</code> only returns <code>maxResults</code>
        /// results in a single page along with a <code>nextToken</code> response element. The remaining results of the initial
        /// request can be seen by sending another <code>GetFindingsReportAccountSummary</code> request with the returned
        /// <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A <code>Boolean</code> value indicating whether to only return reports from daily profiles. If set
        /// to <code>True</code>, only analysis data from daily profiles is returned. If set to <code>False</code>,
        /// analysis data is returned from smaller time windows (for example, one hour).</p>
        pub fn daily_reports_only(mut self, input: bool) -> Self {
            self.inner = self.inner.daily_reports_only(input);
            self
        }
        pub fn set_daily_reports_only(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_daily_reports_only(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetNotificationConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_notification_configuration_input::Builder,
    }
    impl<C> GetNotificationConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetNotificationConfigurationOutput,
            smithy_http::result::SdkError<crate::error::GetNotificationConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the profiling group we want to get the notification configuration for.</p>
        pub fn profiling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.profiling_group_name(input);
            self
        }
        pub fn set_profiling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_profiling_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_policy_input::Builder,
    }
    impl<C> GetPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPolicyOutput,
            smithy_http::result::SdkError<crate::error::GetPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the profiling group.</p>
        pub fn profiling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.profiling_group_name(input);
            self
        }
        pub fn set_profiling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_profiling_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_profile_input::Builder,
    }
    impl<C> GetProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetProfileOutput,
            smithy_http::result::SdkError<crate::error::GetProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the profiling group to get.</p>
        pub fn profiling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.profiling_group_name(input);
            self
        }
        pub fn set_profiling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_profiling_group_name(input);
            self
        }
        /// <p>The start time of the profile to get. Specify using
        /// the ISO 8601 format. For example,
        /// 2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.</p>
        /// <p>
        /// If you specify <code>startTime</code>, then you must also specify <code>period</code>
        /// or <code>endTime</code>, but not both.
        /// </p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>
        /// Used with <code>startTime</code> or <code>endTime</code> to specify
        /// the time range for the returned aggregated profile. Specify using
        /// the ISO 8601 format. For example, <code>P1DT1H1M1S</code>.
        /// </p>
        /// <p>
        /// To get the latest aggregated profile, specify only <code>period</code>.
        /// </p>
        pub fn period(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.period(input);
            self
        }
        pub fn set_period(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_period(input);
            self
        }
        /// <p>
        /// The end time of the requested profile. Specify using
        /// the ISO 8601 format. For example,
        /// 2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        /// </p>
        /// <p>
        /// If you specify <code>endTime</code>, then you must also specify <code>period</code>
        /// or <code>startTime</code>, but not both.
        /// </p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>
        /// The maximum depth of the stacks in the code that is represented in
        /// the aggregated profile. For example, if CodeGuru Profiler finds a method <code>A</code>,
        /// which calls method <code>B</code>, which calls method <code>C</code>, which
        /// calls method <code>D</code>, then the depth is 4. If the <code>maxDepth</code> is
        /// set to 2, then the aggregated profile contains representations of methods <code>A</code>
        /// and <code>B</code>.
        /// </p>
        pub fn max_depth(mut self, input: i32) -> Self {
            self.inner = self.inner.max_depth(input);
            self
        }
        pub fn set_max_depth(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_depth(input);
            self
        }
        /// <p>
        /// The format of the returned profiling data. The format maps to the
        /// <code>Accept</code> and <code>Content-Type</code> headers of the
        /// HTTP request. You can specify one of the following:
        /// or the default .
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>application/json</code> — standard JSON format
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>application/x-amzn-ion</code> — the Amazon Ion data format. For more information,
        /// see <a href="http://amzn.github.io/ion-docs/">Amazon Ion</a>.
        /// </p>
        /// </li>
        /// </ul>
        pub fn accept(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.accept(input);
            self
        }
        pub fn set_accept(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_accept(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRecommendations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_recommendations_input::Builder,
    }
    impl<C> GetRecommendations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRecommendationsOutput,
            smithy_http::result::SdkError<crate::error::GetRecommendationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the profiling group to get analysis data about.
        /// </p>
        pub fn profiling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.profiling_group_name(input);
            self
        }
        pub fn set_profiling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_profiling_group_name(input);
            self
        }
        /// <p>
        /// The end time of the profile to get analysis data about. You must specify <code>startTime</code> and <code>endTime</code>.
        /// This is specified
        /// using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
        /// millisecond past June 1, 2020 1:15:02 PM UTC.
        /// </p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>
        /// The start time of the profile to get analysis data about. You must specify <code>startTime</code> and <code>endTime</code>.
        /// This is specified
        /// using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
        /// millisecond past June 1, 2020 1:15:02 PM UTC.
        /// </p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>
        /// The language used to provide analysis. Specify using a string that is one
        /// of the following <code>BCP 47</code> language codes.
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>de-DE</code> - German, Germany
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>en-GB</code> - English, United Kingdom
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>en-US</code> - English, United States
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>es-ES</code> - Spanish, Spain
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>fr-FR</code> - French, France
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>it-IT</code> - Italian, Italy
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ja-JP</code> - Japanese, Japan
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ko-KR</code> - Korean, Republic of Korea
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>pt-BR</code> - Portugese, Brazil
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>zh-CN</code> - Chinese, China
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>zh-TW</code> - Chinese, Taiwan
        /// </p>
        /// </li>
        /// </ul>
        pub fn locale(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.locale(input);
            self
        }
        pub fn set_locale(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_locale(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFindingsReports<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_findings_reports_input::Builder,
    }
    impl<C> ListFindingsReports<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFindingsReportsOutput,
            smithy_http::result::SdkError<crate::error::ListFindingsReportsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the profiling group from which to search for analysis data.</p>
        pub fn profiling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.profiling_group_name(input);
            self
        }
        pub fn set_profiling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_profiling_group_name(input);
            self
        }
        /// <p>
        /// The start time of the profile to get analysis data about. You must specify <code>startTime</code> and <code>endTime</code>.
        /// This is specified
        /// using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
        /// millisecond past June 1, 2020 1:15:02 PM UTC.
        /// </p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>
        /// The end time of the profile to get analysis data about. You must specify <code>startTime</code> and <code>endTime</code>.
        /// This is specified
        /// using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
        /// millisecond past June 1, 2020 1:15:02 PM UTC.
        /// </p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>The <code>nextToken</code> value returned from a previous paginated <code>ListFindingsReportsRequest</code>
        /// request where <code>maxResults</code> was used and the results exceeded the value of that parameter.
        /// Pagination continues from the end of the previous results that returned the <code>nextToken</code> value.
        /// </p>
        /// <note>
        /// <p>This token should be treated as an opaque identifier that is only used to retrieve
        /// the next items in a list and not for other programmatic purposes.</p>
        /// </note>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of report results returned by <code>ListFindingsReports</code>
        /// in paginated output. When this parameter is used, <code>ListFindingsReports</code> only returns
        /// <code>maxResults</code> results in a single page along with a <code>nextToken</code> response
        /// element. The remaining results of the initial request
        /// can be seen by sending another <code>ListFindingsReports</code> request with the returned
        /// <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A <code>Boolean</code> value indicating whether to only return reports from daily profiles. If set
        /// to <code>True</code>, only analysis data from daily profiles is returned. If set to <code>False</code>,
        /// analysis data is returned from smaller time windows (for example, one hour).</p>
        pub fn daily_reports_only(mut self, input: bool) -> Self {
            self.inner = self.inner.daily_reports_only(input);
            self
        }
        pub fn set_daily_reports_only(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_daily_reports_only(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListProfileTimes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_profile_times_input::Builder,
    }
    impl<C> ListProfileTimes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListProfileTimesOutput,
            smithy_http::result::SdkError<crate::error::ListProfileTimesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the profiling group.</p>
        pub fn profiling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.profiling_group_name(input);
            self
        }
        pub fn set_profiling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_profiling_group_name(input);
            self
        }
        /// <p>The start time of the time range from which to list the profiles.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The end time of the time range from which to list the profiles.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>
        /// The aggregation period. This specifies the period during which an aggregation profile
        /// collects posted agent profiles for a profiling group. There are 3 valid values.
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>P1D</code> — 1 day
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PT1H</code> — 1 hour
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PT5M</code> — 5 minutes
        /// </p>
        /// </li>
        /// </ul>
        pub fn period(mut self, input: crate::model::AggregationPeriod) -> Self {
            self.inner = self.inner.period(input);
            self
        }
        pub fn set_period(
            mut self,
            input: std::option::Option<crate::model::AggregationPeriod>,
        ) -> Self {
            self.inner = self.inner.set_period(input);
            self
        }
        /// <p>The order (ascending or descending by start time of the profile) to
        /// use when listing profiles. Defaults to <code>TIMESTAMP_DESCENDING</code>.
        /// </p>
        pub fn order_by(mut self, input: crate::model::OrderBy) -> Self {
            self.inner = self.inner.order_by(input);
            self
        }
        pub fn set_order_by(mut self, input: std::option::Option<crate::model::OrderBy>) -> Self {
            self.inner = self.inner.set_order_by(input);
            self
        }
        /// <p>The maximum number of profile time results returned by <code>ListProfileTimes</code>
        /// in paginated output. When this parameter is used, <code>ListProfileTimes</code> only returns
        /// <code>maxResults</code> results in a single page with a <code>nextToken</code> response
        /// element. The remaining results of the initial request
        /// can be seen by sending another <code>ListProfileTimes</code> request with the returned
        /// <code>nextToken</code> value.
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The <code>nextToken</code> value returned from a previous paginated
        /// <code>ListProfileTimes</code> request where <code>maxResults</code> was used and the results
        /// exceeded the value of that parameter. Pagination continues from the end of the previous results
        /// that returned the <code>nextToken</code> value.
        /// </p>
        /// <note>
        /// <p>This token should be treated as an opaque identifier that is only used to retrieve
        /// the next items in a list and not for other programmatic purposes.</p>
        /// </note>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListProfilingGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_profiling_groups_input::Builder,
    }
    impl<C> ListProfilingGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListProfilingGroupsOutput,
            smithy_http::result::SdkError<crate::error::ListProfilingGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The <code>nextToken</code> value returned from a previous paginated
        /// <code>ListProfilingGroups</code> request where <code>maxResults</code> was used and the results
        /// exceeded the value of that parameter. Pagination continues from the end of the previous results
        /// that returned the <code>nextToken</code> value.
        /// </p>
        /// <note>
        /// <p>This token should be treated as an opaque identifier that is only used to retrieve
        /// the next items in a list and not for other programmatic purposes.</p>
        /// </note>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of profiling groups results returned by <code>ListProfilingGroups</code>
        /// in paginated output. When this parameter is used, <code>ListProfilingGroups</code> only returns
        /// <code>maxResults</code> results in a single page along with a <code>nextToken</code> response
        /// element. The remaining results of the initial request
        /// can be seen by sending another <code>ListProfilingGroups</code> request with the returned
        /// <code>nextToken</code> value.
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A <code>Boolean</code> value indicating whether to include a description. If <code>true</code>,
        /// then a list of
        /// <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingGroupDescription.html">
        /// <code>ProfilingGroupDescription</code>
        /// </a> objects
        /// that contain detailed information about profiling groups is returned. If <code>false</code>, then
        /// a list of profiling group names is returned.</p>
        pub fn include_description(mut self, input: bool) -> Self {
            self.inner = self.inner.include_description(input);
            self
        }
        pub fn set_include_description(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_description(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The Amazon Resource Name (ARN) of the resource that contains the tags to return.
        /// </p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PostAgentProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::post_agent_profile_input::Builder,
    }
    impl<C> PostAgentProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PostAgentProfileOutput,
            smithy_http::result::SdkError<crate::error::PostAgentProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the profiling group with the aggregated profile that receives the
        /// submitted profiling data.
        /// </p>
        pub fn profiling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.profiling_group_name(input);
            self
        }
        pub fn set_profiling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_profiling_group_name(input);
            self
        }
        /// <p>
        /// The submitted profiling data.
        /// </p>
        pub fn agent_profile(mut self, input: smithy_types::Blob) -> Self {
            self.inner = self.inner.agent_profile(input);
            self
        }
        pub fn set_agent_profile(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_agent_profile(input);
            self
        }
        /// <p> Amazon CodeGuru Profiler uses this universally unique identifier (UUID) to prevent the
        /// accidental submission of duplicate profiling data if there are failures and retries. </p>
        pub fn profile_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.profile_token(input);
            self
        }
        pub fn set_profile_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_profile_token(input);
            self
        }
        /// <p>
        /// The format of the submitted profiling data. The format maps to the
        /// <code>Accept</code> and <code>Content-Type</code> headers of the
        /// HTTP request. You can specify one of the following:
        /// or the default .
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>application/json</code> — standard JSON format
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>application/x-amzn-ion</code> — the Amazon Ion data format. For more information,
        /// see <a href="http://amzn.github.io/ion-docs/">Amazon Ion</a>.
        /// </p>
        /// </li>
        /// </ul>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_type(input);
            self
        }
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutPermission<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_permission_input::Builder,
    }
    impl<C> PutPermission<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutPermissionOutput,
            smithy_http::result::SdkError<crate::error::PutPermissionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the profiling group to grant access to.</p>
        pub fn profiling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.profiling_group_name(input);
            self
        }
        pub fn set_profiling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_profiling_group_name(input);
            self
        }
        /// <p>
        /// Specifies an action group that contains permissions to add to
        /// a profiling group resource. One action group is supported, <code>agentPermissions</code>, which
        /// grants permission to perform actions required by the profiling agent, <code>ConfigureAgent</code>
        /// and <code>PostAgentProfile</code> permissions.
        /// </p>
        pub fn action_group(mut self, input: crate::model::ActionGroup) -> Self {
            self.inner = self.inner.action_group(input);
            self
        }
        pub fn set_action_group(
            mut self,
            input: std::option::Option<crate::model::ActionGroup>,
        ) -> Self {
            self.inner = self.inner.set_action_group(input);
            self
        }
        /// <p>
        /// A list ARNs for the roles and users you want to grant access to the profiling group.
        /// Wildcards are not are supported in the ARNs.
        /// </p>
        pub fn principals(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principals(inp);
            self
        }
        pub fn set_principals(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_principals(input);
            self
        }
        /// <p>
        /// A universally unique identifier (UUID) for the revision of the policy you
        /// are adding to the profiling group. Do not specify
        /// this when you add permissions to a profiling group for the first time. If a policy already exists on the
        /// profiling group, you must specify the <code>revisionId</code>.
        /// </p>
        pub fn revision_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.revision_id(input);
            self
        }
        pub fn set_revision_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_revision_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveNotificationChannel<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::remove_notification_channel_input::Builder,
    }
    impl<C> RemoveNotificationChannel<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemoveNotificationChannelOutput,
            smithy_http::result::SdkError<crate::error::RemoveNotificationChannelError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the profiling group we want to change notification configuration for.</p>
        pub fn profiling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.profiling_group_name(input);
            self
        }
        pub fn set_profiling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_profiling_group_name(input);
            self
        }
        /// <p>The id of the channel that we want to stop receiving notifications.</p>
        pub fn channel_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.channel_id(input);
            self
        }
        pub fn set_channel_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_channel_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemovePermission<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::remove_permission_input::Builder,
    }
    impl<C> RemovePermission<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemovePermissionOutput,
            smithy_http::result::SdkError<crate::error::RemovePermissionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the profiling group.</p>
        pub fn profiling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.profiling_group_name(input);
            self
        }
        pub fn set_profiling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_profiling_group_name(input);
            self
        }
        /// <p>
        /// Specifies an action group that contains the permissions to remove from
        /// a profiling group's resource-based policy. One action group is supported, <code>agentPermissions</code>, which
        /// grants <code>ConfigureAgent</code> and <code>PostAgentProfile</code> permissions.
        /// </p>
        pub fn action_group(mut self, input: crate::model::ActionGroup) -> Self {
            self.inner = self.inner.action_group(input);
            self
        }
        pub fn set_action_group(
            mut self,
            input: std::option::Option<crate::model::ActionGroup>,
        ) -> Self {
            self.inner = self.inner.set_action_group(input);
            self
        }
        /// <p>
        /// A universally unique identifier (UUID) for the revision of the resource-based policy from which
        /// you want to remove permissions.
        /// </p>
        pub fn revision_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.revision_id(input);
            self
        }
        pub fn set_revision_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_revision_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SubmitFeedback<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::submit_feedback_input::Builder,
    }
    impl<C> SubmitFeedback<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SubmitFeedbackOutput,
            smithy_http::result::SdkError<crate::error::SubmitFeedbackError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the profiling group that is associated with the analysis data.</p>
        pub fn profiling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.profiling_group_name(input);
            self
        }
        pub fn set_profiling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_profiling_group_name(input);
            self
        }
        /// <p>The universally unique identifier (UUID) of the
        /// <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_AnomalyInstance.html">
        /// <code>AnomalyInstance</code>
        /// </a> object
        /// that is included in the analysis data.</p>
        pub fn anomaly_instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.anomaly_instance_id(input);
            self
        }
        pub fn set_anomaly_instance_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_anomaly_instance_id(input);
            self
        }
        /// <p>
        /// The feedback tpye. Thee are two valid values, <code>Positive</code> and <code>Negative</code>.
        /// </p>
        pub fn r#type(mut self, input: crate::model::FeedbackType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::FeedbackType>) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>Optional feedback about this anomaly.</p>
        pub fn comment(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.comment(input);
            self
        }
        pub fn set_comment(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_comment(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The Amazon Resource Name (ARN) of the resource that the tags are added to.
        /// </p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>
        /// The list of tags that are added to the specified resource.
        /// </p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The Amazon Resource Name (ARN) of the resource that contains the tags to remove.
        /// </p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>
        /// A list of tag keys. Existing tags of resources with keys in this list are removed from
        /// the specified resource.
        /// </p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateProfilingGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_profiling_group_input::Builder,
    }
    impl<C> UpdateProfilingGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateProfilingGroupOutput,
            smithy_http::result::SdkError<crate::error::UpdateProfilingGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the profiling group to update.</p>
        pub fn profiling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.profiling_group_name(input);
            self
        }
        pub fn set_profiling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_profiling_group_name(input);
            self
        }
        /// <p>
        /// Specifies whether profiling is enabled or disabled for a profiling group.
        /// </p>
        pub fn agent_orchestration_config(
            mut self,
            input: crate::model::AgentOrchestrationConfig,
        ) -> Self {
            self.inner = self.inner.agent_orchestration_config(input);
            self
        }
        pub fn set_agent_orchestration_config(
            mut self,
            input: std::option::Option<crate::model::AgentOrchestrationConfig>,
        ) -> Self {
            self.inner = self.inner.set_agent_orchestration_config(input);
            self
        }
    }
}
