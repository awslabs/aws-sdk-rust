// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (&gt;) or less than (&lt;). For example, you can use a size constraint statement to look for query strings that are longer than 100 bytes. </p>
/// <p>If you configure WAF to inspect the request body, WAF inspects only the number of bytes of the body up to the limit for the web ACL. By default, for regional web ACLs, this limit is 8 KB (8,192 bytes) and for CloudFront web ACLs, this limit is 16 KB (16,384 bytes). For CloudFront web ACLs, you can increase the limit in the web ACL <code>AssociationConfig</code>, for additional fees. If you know that the request body for your web requests should never exceed the inspection limit, you could use a size constraint statement to block requests that have a larger request body size.</p>
/// <p>If you choose URI for the value of Part of the request to filter on, the slash (/) in the URI counts as one character. For example, the URI <code>/logo.jpg</code> is nine characters long.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct SizeConstraintStatement {
    /// <p>The part of the web request that you want WAF to inspect. </p>
    pub field_to_match: ::std::option::Option<crate::types::FieldToMatch>,
    /// <p>The operator to use to compare the request part to the size setting. </p>
    pub comparison_operator: crate::types::ComparisonOperator,
    /// <p>The size, in byte, to compare to the request part, after any transformations.</p>
    pub size: i64,
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the <code>FieldToMatch</code> request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents. </p>
    pub text_transformations: ::std::vec::Vec<crate::types::TextTransformation>,
}
impl SizeConstraintStatement {
    /// <p>The part of the web request that you want WAF to inspect. </p>
    pub fn field_to_match(&self) -> ::std::option::Option<&crate::types::FieldToMatch> {
        self.field_to_match.as_ref()
    }
    /// <p>The operator to use to compare the request part to the size setting. </p>
    pub fn comparison_operator(&self) -> &crate::types::ComparisonOperator {
        &self.comparison_operator
    }
    /// <p>The size, in byte, to compare to the request part, after any transformations.</p>
    pub fn size(&self) -> i64 {
        self.size
    }
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the <code>FieldToMatch</code> request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents. </p>
    pub fn text_transformations(&self) -> &[crate::types::TextTransformation] {
        use std::ops::Deref;
        self.text_transformations.deref()
    }
}
impl SizeConstraintStatement {
    /// Creates a new builder-style object to manufacture [`SizeConstraintStatement`](crate::types::SizeConstraintStatement).
    pub fn builder() -> crate::types::builders::SizeConstraintStatementBuilder {
        crate::types::builders::SizeConstraintStatementBuilder::default()
    }
}

/// A builder for [`SizeConstraintStatement`](crate::types::SizeConstraintStatement).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct SizeConstraintStatementBuilder {
    pub(crate) field_to_match: ::std::option::Option<crate::types::FieldToMatch>,
    pub(crate) comparison_operator: ::std::option::Option<crate::types::ComparisonOperator>,
    pub(crate) size: ::std::option::Option<i64>,
    pub(crate) text_transformations: ::std::option::Option<::std::vec::Vec<crate::types::TextTransformation>>,
}
impl SizeConstraintStatementBuilder {
    /// <p>The part of the web request that you want WAF to inspect. </p>
    /// This field is required.
    pub fn field_to_match(mut self, input: crate::types::FieldToMatch) -> Self {
        self.field_to_match = ::std::option::Option::Some(input);
        self
    }
    /// <p>The part of the web request that you want WAF to inspect. </p>
    pub fn set_field_to_match(mut self, input: ::std::option::Option<crate::types::FieldToMatch>) -> Self {
        self.field_to_match = input;
        self
    }
    /// <p>The part of the web request that you want WAF to inspect. </p>
    pub fn get_field_to_match(&self) -> &::std::option::Option<crate::types::FieldToMatch> {
        &self.field_to_match
    }
    /// <p>The operator to use to compare the request part to the size setting. </p>
    /// This field is required.
    pub fn comparison_operator(mut self, input: crate::types::ComparisonOperator) -> Self {
        self.comparison_operator = ::std::option::Option::Some(input);
        self
    }
    /// <p>The operator to use to compare the request part to the size setting. </p>
    pub fn set_comparison_operator(mut self, input: ::std::option::Option<crate::types::ComparisonOperator>) -> Self {
        self.comparison_operator = input;
        self
    }
    /// <p>The operator to use to compare the request part to the size setting. </p>
    pub fn get_comparison_operator(&self) -> &::std::option::Option<crate::types::ComparisonOperator> {
        &self.comparison_operator
    }
    /// <p>The size, in byte, to compare to the request part, after any transformations.</p>
    /// This field is required.
    pub fn size(mut self, input: i64) -> Self {
        self.size = ::std::option::Option::Some(input);
        self
    }
    /// <p>The size, in byte, to compare to the request part, after any transformations.</p>
    pub fn set_size(mut self, input: ::std::option::Option<i64>) -> Self {
        self.size = input;
        self
    }
    /// <p>The size, in byte, to compare to the request part, after any transformations.</p>
    pub fn get_size(&self) -> &::std::option::Option<i64> {
        &self.size
    }
    /// Appends an item to `text_transformations`.
    ///
    /// To override the contents of this collection use [`set_text_transformations`](Self::set_text_transformations).
    ///
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the <code>FieldToMatch</code> request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents. </p>
    pub fn text_transformations(mut self, input: crate::types::TextTransformation) -> Self {
        let mut v = self.text_transformations.unwrap_or_default();
        v.push(input);
        self.text_transformations = ::std::option::Option::Some(v);
        self
    }
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the <code>FieldToMatch</code> request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents. </p>
    pub fn set_text_transformations(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::TextTransformation>>) -> Self {
        self.text_transformations = input;
        self
    }
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the <code>FieldToMatch</code> request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents. </p>
    pub fn get_text_transformations(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::TextTransformation>> {
        &self.text_transformations
    }
    /// Consumes the builder and constructs a [`SizeConstraintStatement`](crate::types::SizeConstraintStatement).
    /// This method will fail if any of the following fields are not set:
    /// - [`comparison_operator`](crate::types::builders::SizeConstraintStatementBuilder::comparison_operator)
    /// - [`text_transformations`](crate::types::builders::SizeConstraintStatementBuilder::text_transformations)
    pub fn build(self) -> ::std::result::Result<crate::types::SizeConstraintStatement, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::SizeConstraintStatement {
            field_to_match: self.field_to_match,
            comparison_operator: self.comparison_operator.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "comparison_operator",
                    "comparison_operator was not specified but it is required when building SizeConstraintStatement",
                )
            })?,
            size: self.size.unwrap_or_default(),
            text_transformations: self.text_transformations.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "text_transformations",
                    "text_transformations was not specified but it is required when building SizeConstraintStatement",
                )
            })?,
        })
    }
}
