// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Defines an association between logging destinations and a web ACL resource, for logging from WAF. As part of the association, you can specify parts of the standard logging fields to keep out of the logs and you can specify filters so that you log only a subset of the logging records. </p> <note>
/// <p>You can define one logging destination per web ACL.</p>
/// </note>
/// <p>You can access information about the traffic that WAF inspects using the following steps:</p>
/// <ol>
/// <li> <p>Create your logging destination. You can use an Amazon CloudWatch Logs log group, an Amazon Simple Storage Service (Amazon S3) bucket, or an Amazon Kinesis Data Firehose. </p> <p>The name that you give the destination must start with <code>aws-waf-logs-</code>. Depending on the type of destination, you might need to configure additional settings or permissions. </p> <p>For configuration requirements and pricing information for each destination type, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/logging.html">Logging web ACL traffic</a> in the <i>WAF Developer Guide</i>.</p> </li>
/// <li> <p>Associate your logging destination to your web ACL using a <code>PutLoggingConfiguration</code> request.</p> </li>
/// </ol>
/// <p>When you successfully enable logging using a <code>PutLoggingConfiguration</code> request, WAF creates an additional role or policy that is required to write logs to the logging destination. For an Amazon CloudWatch Logs log group, WAF creates a resource policy on the log group. For an Amazon S3 bucket, WAF creates a bucket policy. For an Amazon Kinesis Data Firehose, WAF creates a service-linked role.</p>
/// <p>For additional information about web ACL logging, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/logging.html">Logging web ACL traffic information</a> in the <i>WAF Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct LoggingConfiguration {
    /// <p>The Amazon Resource Name (ARN) of the web ACL that you want to associate with <code>LogDestinationConfigs</code>.</p>
    pub resource_arn: ::std::string::String,
    /// <p>The logging destination configuration that you want to associate with the web ACL.</p> <note>
    /// <p>You can associate one logging destination to a web ACL.</p>
    /// </note>
    pub log_destination_configs: ::std::vec::Vec<::std::string::String>,
    /// <p>The parts of the request that you want to keep out of the logs.</p>
    /// <p>For example, if you redact the <code>SingleHeader</code> field, the <code>HEADER</code> field in the logs will be <code>REDACTED</code> for all rules that use the <code>SingleHeader</code> <code>FieldToMatch</code> setting. </p>
    /// <p>Redaction applies only to the component that's specified in the rule's <code>FieldToMatch</code> setting, so the <code>SingleHeader</code> redaction doesn't apply to rules that use the <code>Headers</code> <code>FieldToMatch</code>.</p> <note>
    /// <p>You can specify only the following fields for redaction: <code>UriPath</code>, <code>QueryString</code>, <code>SingleHeader</code>, and <code>Method</code>.</p>
    /// </note>
    pub redacted_fields: ::std::option::Option<::std::vec::Vec<crate::types::FieldToMatch>>,
    /// <p>Indicates whether the logging configuration was created by Firewall Manager, as part of an WAF policy configuration. If true, only Firewall Manager can modify or delete the configuration. </p>
    pub managed_by_firewall_manager: bool,
    /// <p>Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation. </p>
    pub logging_filter: ::std::option::Option<crate::types::LoggingFilter>,
}
impl LoggingConfiguration {
    /// <p>The Amazon Resource Name (ARN) of the web ACL that you want to associate with <code>LogDestinationConfigs</code>.</p>
    pub fn resource_arn(&self) -> &str {
        use std::ops::Deref;
        self.resource_arn.deref()
    }
    /// <p>The logging destination configuration that you want to associate with the web ACL.</p> <note>
    /// <p>You can associate one logging destination to a web ACL.</p>
    /// </note>
    pub fn log_destination_configs(&self) -> &[::std::string::String] {
        use std::ops::Deref;
        self.log_destination_configs.deref()
    }
    /// <p>The parts of the request that you want to keep out of the logs.</p>
    /// <p>For example, if you redact the <code>SingleHeader</code> field, the <code>HEADER</code> field in the logs will be <code>REDACTED</code> for all rules that use the <code>SingleHeader</code> <code>FieldToMatch</code> setting. </p>
    /// <p>Redaction applies only to the component that's specified in the rule's <code>FieldToMatch</code> setting, so the <code>SingleHeader</code> redaction doesn't apply to rules that use the <code>Headers</code> <code>FieldToMatch</code>.</p> <note>
    /// <p>You can specify only the following fields for redaction: <code>UriPath</code>, <code>QueryString</code>, <code>SingleHeader</code>, and <code>Method</code>.</p>
    /// </note>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.redacted_fields.is_none()`.
    pub fn redacted_fields(&self) -> &[crate::types::FieldToMatch] {
        self.redacted_fields.as_deref().unwrap_or_default()
    }
    /// <p>Indicates whether the logging configuration was created by Firewall Manager, as part of an WAF policy configuration. If true, only Firewall Manager can modify or delete the configuration. </p>
    pub fn managed_by_firewall_manager(&self) -> bool {
        self.managed_by_firewall_manager
    }
    /// <p>Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation. </p>
    pub fn logging_filter(&self) -> ::std::option::Option<&crate::types::LoggingFilter> {
        self.logging_filter.as_ref()
    }
}
impl LoggingConfiguration {
    /// Creates a new builder-style object to manufacture [`LoggingConfiguration`](crate::types::LoggingConfiguration).
    pub fn builder() -> crate::types::builders::LoggingConfigurationBuilder {
        crate::types::builders::LoggingConfigurationBuilder::default()
    }
}

/// A builder for [`LoggingConfiguration`](crate::types::LoggingConfiguration).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct LoggingConfigurationBuilder {
    pub(crate) resource_arn: ::std::option::Option<::std::string::String>,
    pub(crate) log_destination_configs: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) redacted_fields: ::std::option::Option<::std::vec::Vec<crate::types::FieldToMatch>>,
    pub(crate) managed_by_firewall_manager: ::std::option::Option<bool>,
    pub(crate) logging_filter: ::std::option::Option<crate::types::LoggingFilter>,
}
impl LoggingConfigurationBuilder {
    /// <p>The Amazon Resource Name (ARN) of the web ACL that you want to associate with <code>LogDestinationConfigs</code>.</p>
    /// This field is required.
    pub fn resource_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.resource_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the web ACL that you want to associate with <code>LogDestinationConfigs</code>.</p>
    pub fn set_resource_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.resource_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the web ACL that you want to associate with <code>LogDestinationConfigs</code>.</p>
    pub fn get_resource_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.resource_arn
    }
    /// Appends an item to `log_destination_configs`.
    ///
    /// To override the contents of this collection use [`set_log_destination_configs`](Self::set_log_destination_configs).
    ///
    /// <p>The logging destination configuration that you want to associate with the web ACL.</p> <note>
    /// <p>You can associate one logging destination to a web ACL.</p>
    /// </note>
    pub fn log_destination_configs(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.log_destination_configs.unwrap_or_default();
        v.push(input.into());
        self.log_destination_configs = ::std::option::Option::Some(v);
        self
    }
    /// <p>The logging destination configuration that you want to associate with the web ACL.</p> <note>
    /// <p>You can associate one logging destination to a web ACL.</p>
    /// </note>
    pub fn set_log_destination_configs(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.log_destination_configs = input;
        self
    }
    /// <p>The logging destination configuration that you want to associate with the web ACL.</p> <note>
    /// <p>You can associate one logging destination to a web ACL.</p>
    /// </note>
    pub fn get_log_destination_configs(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.log_destination_configs
    }
    /// Appends an item to `redacted_fields`.
    ///
    /// To override the contents of this collection use [`set_redacted_fields`](Self::set_redacted_fields).
    ///
    /// <p>The parts of the request that you want to keep out of the logs.</p>
    /// <p>For example, if you redact the <code>SingleHeader</code> field, the <code>HEADER</code> field in the logs will be <code>REDACTED</code> for all rules that use the <code>SingleHeader</code> <code>FieldToMatch</code> setting. </p>
    /// <p>Redaction applies only to the component that's specified in the rule's <code>FieldToMatch</code> setting, so the <code>SingleHeader</code> redaction doesn't apply to rules that use the <code>Headers</code> <code>FieldToMatch</code>.</p> <note>
    /// <p>You can specify only the following fields for redaction: <code>UriPath</code>, <code>QueryString</code>, <code>SingleHeader</code>, and <code>Method</code>.</p>
    /// </note>
    pub fn redacted_fields(mut self, input: crate::types::FieldToMatch) -> Self {
        let mut v = self.redacted_fields.unwrap_or_default();
        v.push(input);
        self.redacted_fields = ::std::option::Option::Some(v);
        self
    }
    /// <p>The parts of the request that you want to keep out of the logs.</p>
    /// <p>For example, if you redact the <code>SingleHeader</code> field, the <code>HEADER</code> field in the logs will be <code>REDACTED</code> for all rules that use the <code>SingleHeader</code> <code>FieldToMatch</code> setting. </p>
    /// <p>Redaction applies only to the component that's specified in the rule's <code>FieldToMatch</code> setting, so the <code>SingleHeader</code> redaction doesn't apply to rules that use the <code>Headers</code> <code>FieldToMatch</code>.</p> <note>
    /// <p>You can specify only the following fields for redaction: <code>UriPath</code>, <code>QueryString</code>, <code>SingleHeader</code>, and <code>Method</code>.</p>
    /// </note>
    pub fn set_redacted_fields(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::FieldToMatch>>) -> Self {
        self.redacted_fields = input;
        self
    }
    /// <p>The parts of the request that you want to keep out of the logs.</p>
    /// <p>For example, if you redact the <code>SingleHeader</code> field, the <code>HEADER</code> field in the logs will be <code>REDACTED</code> for all rules that use the <code>SingleHeader</code> <code>FieldToMatch</code> setting. </p>
    /// <p>Redaction applies only to the component that's specified in the rule's <code>FieldToMatch</code> setting, so the <code>SingleHeader</code> redaction doesn't apply to rules that use the <code>Headers</code> <code>FieldToMatch</code>.</p> <note>
    /// <p>You can specify only the following fields for redaction: <code>UriPath</code>, <code>QueryString</code>, <code>SingleHeader</code>, and <code>Method</code>.</p>
    /// </note>
    pub fn get_redacted_fields(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::FieldToMatch>> {
        &self.redacted_fields
    }
    /// <p>Indicates whether the logging configuration was created by Firewall Manager, as part of an WAF policy configuration. If true, only Firewall Manager can modify or delete the configuration. </p>
    pub fn managed_by_firewall_manager(mut self, input: bool) -> Self {
        self.managed_by_firewall_manager = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether the logging configuration was created by Firewall Manager, as part of an WAF policy configuration. If true, only Firewall Manager can modify or delete the configuration. </p>
    pub fn set_managed_by_firewall_manager(mut self, input: ::std::option::Option<bool>) -> Self {
        self.managed_by_firewall_manager = input;
        self
    }
    /// <p>Indicates whether the logging configuration was created by Firewall Manager, as part of an WAF policy configuration. If true, only Firewall Manager can modify or delete the configuration. </p>
    pub fn get_managed_by_firewall_manager(&self) -> &::std::option::Option<bool> {
        &self.managed_by_firewall_manager
    }
    /// <p>Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation. </p>
    pub fn logging_filter(mut self, input: crate::types::LoggingFilter) -> Self {
        self.logging_filter = ::std::option::Option::Some(input);
        self
    }
    /// <p>Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation. </p>
    pub fn set_logging_filter(mut self, input: ::std::option::Option<crate::types::LoggingFilter>) -> Self {
        self.logging_filter = input;
        self
    }
    /// <p>Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation. </p>
    pub fn get_logging_filter(&self) -> &::std::option::Option<crate::types::LoggingFilter> {
        &self.logging_filter
    }
    /// Consumes the builder and constructs a [`LoggingConfiguration`](crate::types::LoggingConfiguration).
    /// This method will fail if any of the following fields are not set:
    /// - [`resource_arn`](crate::types::builders::LoggingConfigurationBuilder::resource_arn)
    /// - [`log_destination_configs`](crate::types::builders::LoggingConfigurationBuilder::log_destination_configs)
    pub fn build(self) -> ::std::result::Result<crate::types::LoggingConfiguration, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::LoggingConfiguration {
            resource_arn: self.resource_arn.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "resource_arn",
                    "resource_arn was not specified but it is required when building LoggingConfiguration",
                )
            })?,
            log_destination_configs: self.log_destination_configs.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "log_destination_configs",
                    "log_destination_configs was not specified but it is required when building LoggingConfiguration",
                )
            })?,
            redacted_fields: self.redacted_fields,
            managed_by_firewall_manager: self.managed_by_firewall_manager.unwrap_or_default(),
            logging_filter: self.logging_filter,
        })
    }
}
