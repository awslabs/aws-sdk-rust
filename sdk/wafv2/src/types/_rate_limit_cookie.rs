// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Specifies a cookie as an aggregate key for a rate-based rule. Each distinct value in the cookie contributes to the aggregation instance. If you use a single cookie as your custom key, then each value fully defines an aggregation instance. </p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct RateLimitCookie {
    /// <p>The name of the cookie to use. </p>
    pub name: ::std::string::String,
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the <code>FieldToMatch</code> request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents. </p>
    pub text_transformations: ::std::vec::Vec<crate::types::TextTransformation>,
}
impl RateLimitCookie {
    /// <p>The name of the cookie to use. </p>
    pub fn name(&self) -> &str {
        use std::ops::Deref;
        self.name.deref()
    }
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the <code>FieldToMatch</code> request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents. </p>
    pub fn text_transformations(&self) -> &[crate::types::TextTransformation] {
        use std::ops::Deref;
        self.text_transformations.deref()
    }
}
impl RateLimitCookie {
    /// Creates a new builder-style object to manufacture [`RateLimitCookie`](crate::types::RateLimitCookie).
    pub fn builder() -> crate::types::builders::RateLimitCookieBuilder {
        crate::types::builders::RateLimitCookieBuilder::default()
    }
}

/// A builder for [`RateLimitCookie`](crate::types::RateLimitCookie).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct RateLimitCookieBuilder {
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) text_transformations: ::std::option::Option<::std::vec::Vec<crate::types::TextTransformation>>,
}
impl RateLimitCookieBuilder {
    /// <p>The name of the cookie to use. </p>
    /// This field is required.
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the cookie to use. </p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The name of the cookie to use. </p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// Appends an item to `text_transformations`.
    ///
    /// To override the contents of this collection use [`set_text_transformations`](Self::set_text_transformations).
    ///
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the <code>FieldToMatch</code> request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents. </p>
    pub fn text_transformations(mut self, input: crate::types::TextTransformation) -> Self {
        let mut v = self.text_transformations.unwrap_or_default();
        v.push(input);
        self.text_transformations = ::std::option::Option::Some(v);
        self
    }
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the <code>FieldToMatch</code> request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents. </p>
    pub fn set_text_transformations(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::TextTransformation>>) -> Self {
        self.text_transformations = input;
        self
    }
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the <code>FieldToMatch</code> request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents. </p>
    pub fn get_text_transformations(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::TextTransformation>> {
        &self.text_transformations
    }
    /// Consumes the builder and constructs a [`RateLimitCookie`](crate::types::RateLimitCookie).
    /// This method will fail if any of the following fields are not set:
    /// - [`name`](crate::types::builders::RateLimitCookieBuilder::name)
    /// - [`text_transformations`](crate::types::builders::RateLimitCookieBuilder::text_transformations)
    pub fn build(self) -> ::std::result::Result<crate::types::RateLimitCookie, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::RateLimitCookie {
            name: self.name.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "name",
                    "name was not specified but it is required when building RateLimitCookie",
                )
            })?,
            text_transformations: self.text_transformations.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "text_transformations",
                    "text_transformations was not specified but it is required when building RateLimitCookie",
                )
            })?,
        })
    }
}
