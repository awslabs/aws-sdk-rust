// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A rule group that's defined for an Firewall Manager WAF policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FirewallManagerRuleGroup {
    /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>If you define more than one rule group in the first or last Firewall Manager rule groups, WAF evaluates each request against the rule groups in order, starting from the lowest priority setting. The priorities don't need to be consecutive, but they must all be different.</p>
    #[doc(hidden)]
    pub priority: i32,
    /// <p>The processing guidance for an Firewall Manager rule. This is like a regular rule <code>Statement</code>, but it can only contain a rule group reference.</p>
    #[doc(hidden)]
    pub firewall_manager_statement: std::option::Option<crate::types::FirewallManagerStatement>,
    /// <p>The action to use in the place of the action that results from the rule group evaluation. Set the override action to none to leave the result of the rule group alone. Set it to count to override the result to count only. </p>
    /// <p>You can only use this for rule statements that reference a rule group, like <code>RuleGroupReferenceStatement</code> and <code>ManagedRuleGroupStatement</code>. </p> <note>
    /// <p>This option is usually set to none. It does not affect how the rules in the rule group are evaluated. If you want the rules in the rule group to only count matches, do not use this and instead use the rule action override option, with <code>Count</code> action, in your rule group reference statement settings. </p>
    /// </note>
    #[doc(hidden)]
    pub override_action: std::option::Option<crate::types::OverrideAction>,
    /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection. </p>
    #[doc(hidden)]
    pub visibility_config: std::option::Option<crate::types::VisibilityConfig>,
}
impl FirewallManagerRuleGroup {
    /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>If you define more than one rule group in the first or last Firewall Manager rule groups, WAF evaluates each request against the rule groups in order, starting from the lowest priority setting. The priorities don't need to be consecutive, but they must all be different.</p>
    pub fn priority(&self) -> i32 {
        self.priority
    }
    /// <p>The processing guidance for an Firewall Manager rule. This is like a regular rule <code>Statement</code>, but it can only contain a rule group reference.</p>
    pub fn firewall_manager_statement(
        &self,
    ) -> std::option::Option<&crate::types::FirewallManagerStatement> {
        self.firewall_manager_statement.as_ref()
    }
    /// <p>The action to use in the place of the action that results from the rule group evaluation. Set the override action to none to leave the result of the rule group alone. Set it to count to override the result to count only. </p>
    /// <p>You can only use this for rule statements that reference a rule group, like <code>RuleGroupReferenceStatement</code> and <code>ManagedRuleGroupStatement</code>. </p> <note>
    /// <p>This option is usually set to none. It does not affect how the rules in the rule group are evaluated. If you want the rules in the rule group to only count matches, do not use this and instead use the rule action override option, with <code>Count</code> action, in your rule group reference statement settings. </p>
    /// </note>
    pub fn override_action(&self) -> std::option::Option<&crate::types::OverrideAction> {
        self.override_action.as_ref()
    }
    /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection. </p>
    pub fn visibility_config(&self) -> std::option::Option<&crate::types::VisibilityConfig> {
        self.visibility_config.as_ref()
    }
}
impl FirewallManagerRuleGroup {
    /// Creates a new builder-style object to manufacture [`FirewallManagerRuleGroup`](crate::types::FirewallManagerRuleGroup).
    pub fn builder() -> crate::types::builders::FirewallManagerRuleGroupBuilder {
        crate::types::builders::FirewallManagerRuleGroupBuilder::default()
    }
}

/// A builder for [`FirewallManagerRuleGroup`](crate::types::FirewallManagerRuleGroup).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct FirewallManagerRuleGroupBuilder {
    pub(crate) name: std::option::Option<std::string::String>,
    pub(crate) priority: std::option::Option<i32>,
    pub(crate) firewall_manager_statement:
        std::option::Option<crate::types::FirewallManagerStatement>,
    pub(crate) override_action: std::option::Option<crate::types::OverrideAction>,
    pub(crate) visibility_config: std::option::Option<crate::types::VisibilityConfig>,
}
impl FirewallManagerRuleGroupBuilder {
    /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
    pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
        self.name = Some(input.into());
        self
    }
    /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
    pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>If you define more than one rule group in the first or last Firewall Manager rule groups, WAF evaluates each request against the rule groups in order, starting from the lowest priority setting. The priorities don't need to be consecutive, but they must all be different.</p>
    pub fn priority(mut self, input: i32) -> Self {
        self.priority = Some(input);
        self
    }
    /// <p>If you define more than one rule group in the first or last Firewall Manager rule groups, WAF evaluates each request against the rule groups in order, starting from the lowest priority setting. The priorities don't need to be consecutive, but they must all be different.</p>
    pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
        self.priority = input;
        self
    }
    /// <p>The processing guidance for an Firewall Manager rule. This is like a regular rule <code>Statement</code>, but it can only contain a rule group reference.</p>
    pub fn firewall_manager_statement(
        mut self,
        input: crate::types::FirewallManagerStatement,
    ) -> Self {
        self.firewall_manager_statement = Some(input);
        self
    }
    /// <p>The processing guidance for an Firewall Manager rule. This is like a regular rule <code>Statement</code>, but it can only contain a rule group reference.</p>
    pub fn set_firewall_manager_statement(
        mut self,
        input: std::option::Option<crate::types::FirewallManagerStatement>,
    ) -> Self {
        self.firewall_manager_statement = input;
        self
    }
    /// <p>The action to use in the place of the action that results from the rule group evaluation. Set the override action to none to leave the result of the rule group alone. Set it to count to override the result to count only. </p>
    /// <p>You can only use this for rule statements that reference a rule group, like <code>RuleGroupReferenceStatement</code> and <code>ManagedRuleGroupStatement</code>. </p> <note>
    /// <p>This option is usually set to none. It does not affect how the rules in the rule group are evaluated. If you want the rules in the rule group to only count matches, do not use this and instead use the rule action override option, with <code>Count</code> action, in your rule group reference statement settings. </p>
    /// </note>
    pub fn override_action(mut self, input: crate::types::OverrideAction) -> Self {
        self.override_action = Some(input);
        self
    }
    /// <p>The action to use in the place of the action that results from the rule group evaluation. Set the override action to none to leave the result of the rule group alone. Set it to count to override the result to count only. </p>
    /// <p>You can only use this for rule statements that reference a rule group, like <code>RuleGroupReferenceStatement</code> and <code>ManagedRuleGroupStatement</code>. </p> <note>
    /// <p>This option is usually set to none. It does not affect how the rules in the rule group are evaluated. If you want the rules in the rule group to only count matches, do not use this and instead use the rule action override option, with <code>Count</code> action, in your rule group reference statement settings. </p>
    /// </note>
    pub fn set_override_action(
        mut self,
        input: std::option::Option<crate::types::OverrideAction>,
    ) -> Self {
        self.override_action = input;
        self
    }
    /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection. </p>
    pub fn visibility_config(mut self, input: crate::types::VisibilityConfig) -> Self {
        self.visibility_config = Some(input);
        self
    }
    /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection. </p>
    pub fn set_visibility_config(
        mut self,
        input: std::option::Option<crate::types::VisibilityConfig>,
    ) -> Self {
        self.visibility_config = input;
        self
    }
    /// Consumes the builder and constructs a [`FirewallManagerRuleGroup`](crate::types::FirewallManagerRuleGroup).
    pub fn build(self) -> crate::types::FirewallManagerRuleGroup {
        crate::types::FirewallManagerRuleGroup {
            name: self.name,
            priority: self.priority.unwrap_or_default(),
            firewall_manager_statement: self.firewall_manager_statement,
            override_action: self.override_action,
            visibility_config: self.visibility_config,
        }
    }
}
