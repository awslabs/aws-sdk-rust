// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The part of the web request that you want WAF to inspect. Include the single <code>FieldToMatch</code> type that you want to inspect, with additional specifications as needed, according to the type. You specify a single request component in <code>FieldToMatch</code> for each rule statement that requires it. To inspect more than one component of the web request, create a separate rule statement for each component.</p>
/// <p>Example JSON for a <code>QueryString</code> field to match: </p>
/// <p> <code> "FieldToMatch": { "QueryString": {} }</code> </p>
/// <p>Example JSON for a <code>Method</code> field to match specification:</p>
/// <p> <code> "FieldToMatch": { "Method": { "Name": "DELETE" } }</code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldToMatch {
    /// <p>Inspect a single header. Provide the name of the header to inspect, for example, <code>User-Agent</code> or <code>Referer</code>. This setting isn't case sensitive.</p>
    /// <p>Example JSON: <code>"SingleHeader": { "Name": "haystack" }</code> </p>
    /// <p>Alternately, you can filter and inspect all headers with the <code>Headers</code> <code>FieldToMatch</code> setting. </p>
    #[doc(hidden)]
    pub single_header: std::option::Option<crate::types::SingleHeader>,
    /// <p>Inspect a single query argument. Provide the name of the query argument to inspect, such as <i>UserName</i> or <i>SalesRegion</i>. The name can be up to 30 characters long and isn't case sensitive. </p>
    /// <p>Example JSON: <code>"SingleQueryArgument": { "Name": "myArgument" }</code> </p>
    #[doc(hidden)]
    pub single_query_argument: std::option::Option<crate::types::SingleQueryArgument>,
    /// <p>Inspect all query arguments. </p>
    #[doc(hidden)]
    pub all_query_arguments: std::option::Option<crate::types::AllQueryArguments>,
    /// <p>Inspect the request URI path. This is the part of the web request that identifies a resource, for example, <code>/images/daily-ad.jpg</code>.</p>
    #[doc(hidden)]
    pub uri_path: std::option::Option<crate::types::UriPath>,
    /// <p>Inspect the query string. This is the part of a URL that appears after a <code>?</code> character, if any.</p>
    #[doc(hidden)]
    pub query_string: std::option::Option<crate::types::QueryString>,
    /// <p>Inspect the request body as plain text. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. </p>
    /// <p>Only the first 8 KB (8192 bytes) of the request body are forwarded to WAF for inspection by the underlying host service. For information about how to handle oversized request bodies, see the <code>Body</code> object configuration. </p>
    #[doc(hidden)]
    pub body: std::option::Option<crate::types::Body>,
    /// <p>Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform. </p>
    #[doc(hidden)]
    pub method: std::option::Option<crate::types::Method>,
    /// <p>Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. </p>
    /// <p>Only the first 8 KB (8192 bytes) of the request body are forwarded to WAF for inspection by the underlying host service. For information about how to handle oversized request bodies, see the <code>JsonBody</code> object configuration. </p>
    #[doc(hidden)]
    pub json_body: std::option::Option<crate::types::JsonBody>,
    /// <p>Inspect the request headers. You must configure scope and pattern matching filters in the <code>Headers</code> object, to define the set of headers to and the parts of the headers that WAF inspects. </p>
    /// <p>Only the first 8 KB (8192 bytes) of a request's headers and only the first 200 headers are forwarded to WAF for inspection by the underlying host service. You must configure how to handle any oversize header content in the <code>Headers</code> object. WAF applies the pattern matching filters to the headers that it receives from the underlying host service. </p>
    #[doc(hidden)]
    pub headers: std::option::Option<crate::types::Headers>,
    /// <p>Inspect the request cookies. You must configure scope and pattern matching filters in the <code>Cookies</code> object, to define the set of cookies and the parts of the cookies that WAF inspects. </p>
    /// <p>Only the first 8 KB (8192 bytes) of a request's cookies and only the first 200 cookies are forwarded to WAF for inspection by the underlying host service. You must configure how to handle any oversize cookie content in the <code>Cookies</code> object. WAF applies the pattern matching filters to the cookies that it receives from the underlying host service. </p>
    #[doc(hidden)]
    pub cookies: std::option::Option<crate::types::Cookies>,
}
impl FieldToMatch {
    /// <p>Inspect a single header. Provide the name of the header to inspect, for example, <code>User-Agent</code> or <code>Referer</code>. This setting isn't case sensitive.</p>
    /// <p>Example JSON: <code>"SingleHeader": { "Name": "haystack" }</code> </p>
    /// <p>Alternately, you can filter and inspect all headers with the <code>Headers</code> <code>FieldToMatch</code> setting. </p>
    pub fn single_header(&self) -> std::option::Option<&crate::types::SingleHeader> {
        self.single_header.as_ref()
    }
    /// <p>Inspect a single query argument. Provide the name of the query argument to inspect, such as <i>UserName</i> or <i>SalesRegion</i>. The name can be up to 30 characters long and isn't case sensitive. </p>
    /// <p>Example JSON: <code>"SingleQueryArgument": { "Name": "myArgument" }</code> </p>
    pub fn single_query_argument(&self) -> std::option::Option<&crate::types::SingleQueryArgument> {
        self.single_query_argument.as_ref()
    }
    /// <p>Inspect all query arguments. </p>
    pub fn all_query_arguments(&self) -> std::option::Option<&crate::types::AllQueryArguments> {
        self.all_query_arguments.as_ref()
    }
    /// <p>Inspect the request URI path. This is the part of the web request that identifies a resource, for example, <code>/images/daily-ad.jpg</code>.</p>
    pub fn uri_path(&self) -> std::option::Option<&crate::types::UriPath> {
        self.uri_path.as_ref()
    }
    /// <p>Inspect the query string. This is the part of a URL that appears after a <code>?</code> character, if any.</p>
    pub fn query_string(&self) -> std::option::Option<&crate::types::QueryString> {
        self.query_string.as_ref()
    }
    /// <p>Inspect the request body as plain text. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. </p>
    /// <p>Only the first 8 KB (8192 bytes) of the request body are forwarded to WAF for inspection by the underlying host service. For information about how to handle oversized request bodies, see the <code>Body</code> object configuration. </p>
    pub fn body(&self) -> std::option::Option<&crate::types::Body> {
        self.body.as_ref()
    }
    /// <p>Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform. </p>
    pub fn method(&self) -> std::option::Option<&crate::types::Method> {
        self.method.as_ref()
    }
    /// <p>Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. </p>
    /// <p>Only the first 8 KB (8192 bytes) of the request body are forwarded to WAF for inspection by the underlying host service. For information about how to handle oversized request bodies, see the <code>JsonBody</code> object configuration. </p>
    pub fn json_body(&self) -> std::option::Option<&crate::types::JsonBody> {
        self.json_body.as_ref()
    }
    /// <p>Inspect the request headers. You must configure scope and pattern matching filters in the <code>Headers</code> object, to define the set of headers to and the parts of the headers that WAF inspects. </p>
    /// <p>Only the first 8 KB (8192 bytes) of a request's headers and only the first 200 headers are forwarded to WAF for inspection by the underlying host service. You must configure how to handle any oversize header content in the <code>Headers</code> object. WAF applies the pattern matching filters to the headers that it receives from the underlying host service. </p>
    pub fn headers(&self) -> std::option::Option<&crate::types::Headers> {
        self.headers.as_ref()
    }
    /// <p>Inspect the request cookies. You must configure scope and pattern matching filters in the <code>Cookies</code> object, to define the set of cookies and the parts of the cookies that WAF inspects. </p>
    /// <p>Only the first 8 KB (8192 bytes) of a request's cookies and only the first 200 cookies are forwarded to WAF for inspection by the underlying host service. You must configure how to handle any oversize cookie content in the <code>Cookies</code> object. WAF applies the pattern matching filters to the cookies that it receives from the underlying host service. </p>
    pub fn cookies(&self) -> std::option::Option<&crate::types::Cookies> {
        self.cookies.as_ref()
    }
}
impl FieldToMatch {
    /// Creates a new builder-style object to manufacture [`FieldToMatch`](crate::types::FieldToMatch).
    pub fn builder() -> crate::types::builders::FieldToMatchBuilder {
        crate::types::builders::FieldToMatchBuilder::default()
    }
}

/// A builder for [`FieldToMatch`](crate::types::FieldToMatch).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct FieldToMatchBuilder {
    pub(crate) single_header: std::option::Option<crate::types::SingleHeader>,
    pub(crate) single_query_argument: std::option::Option<crate::types::SingleQueryArgument>,
    pub(crate) all_query_arguments: std::option::Option<crate::types::AllQueryArguments>,
    pub(crate) uri_path: std::option::Option<crate::types::UriPath>,
    pub(crate) query_string: std::option::Option<crate::types::QueryString>,
    pub(crate) body: std::option::Option<crate::types::Body>,
    pub(crate) method: std::option::Option<crate::types::Method>,
    pub(crate) json_body: std::option::Option<crate::types::JsonBody>,
    pub(crate) headers: std::option::Option<crate::types::Headers>,
    pub(crate) cookies: std::option::Option<crate::types::Cookies>,
}
impl FieldToMatchBuilder {
    /// <p>Inspect a single header. Provide the name of the header to inspect, for example, <code>User-Agent</code> or <code>Referer</code>. This setting isn't case sensitive.</p>
    /// <p>Example JSON: <code>"SingleHeader": { "Name": "haystack" }</code> </p>
    /// <p>Alternately, you can filter and inspect all headers with the <code>Headers</code> <code>FieldToMatch</code> setting. </p>
    pub fn single_header(mut self, input: crate::types::SingleHeader) -> Self {
        self.single_header = Some(input);
        self
    }
    /// <p>Inspect a single header. Provide the name of the header to inspect, for example, <code>User-Agent</code> or <code>Referer</code>. This setting isn't case sensitive.</p>
    /// <p>Example JSON: <code>"SingleHeader": { "Name": "haystack" }</code> </p>
    /// <p>Alternately, you can filter and inspect all headers with the <code>Headers</code> <code>FieldToMatch</code> setting. </p>
    pub fn set_single_header(
        mut self,
        input: std::option::Option<crate::types::SingleHeader>,
    ) -> Self {
        self.single_header = input;
        self
    }
    /// <p>Inspect a single query argument. Provide the name of the query argument to inspect, such as <i>UserName</i> or <i>SalesRegion</i>. The name can be up to 30 characters long and isn't case sensitive. </p>
    /// <p>Example JSON: <code>"SingleQueryArgument": { "Name": "myArgument" }</code> </p>
    pub fn single_query_argument(mut self, input: crate::types::SingleQueryArgument) -> Self {
        self.single_query_argument = Some(input);
        self
    }
    /// <p>Inspect a single query argument. Provide the name of the query argument to inspect, such as <i>UserName</i> or <i>SalesRegion</i>. The name can be up to 30 characters long and isn't case sensitive. </p>
    /// <p>Example JSON: <code>"SingleQueryArgument": { "Name": "myArgument" }</code> </p>
    pub fn set_single_query_argument(
        mut self,
        input: std::option::Option<crate::types::SingleQueryArgument>,
    ) -> Self {
        self.single_query_argument = input;
        self
    }
    /// <p>Inspect all query arguments. </p>
    pub fn all_query_arguments(mut self, input: crate::types::AllQueryArguments) -> Self {
        self.all_query_arguments = Some(input);
        self
    }
    /// <p>Inspect all query arguments. </p>
    pub fn set_all_query_arguments(
        mut self,
        input: std::option::Option<crate::types::AllQueryArguments>,
    ) -> Self {
        self.all_query_arguments = input;
        self
    }
    /// <p>Inspect the request URI path. This is the part of the web request that identifies a resource, for example, <code>/images/daily-ad.jpg</code>.</p>
    pub fn uri_path(mut self, input: crate::types::UriPath) -> Self {
        self.uri_path = Some(input);
        self
    }
    /// <p>Inspect the request URI path. This is the part of the web request that identifies a resource, for example, <code>/images/daily-ad.jpg</code>.</p>
    pub fn set_uri_path(mut self, input: std::option::Option<crate::types::UriPath>) -> Self {
        self.uri_path = input;
        self
    }
    /// <p>Inspect the query string. This is the part of a URL that appears after a <code>?</code> character, if any.</p>
    pub fn query_string(mut self, input: crate::types::QueryString) -> Self {
        self.query_string = Some(input);
        self
    }
    /// <p>Inspect the query string. This is the part of a URL that appears after a <code>?</code> character, if any.</p>
    pub fn set_query_string(
        mut self,
        input: std::option::Option<crate::types::QueryString>,
    ) -> Self {
        self.query_string = input;
        self
    }
    /// <p>Inspect the request body as plain text. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. </p>
    /// <p>Only the first 8 KB (8192 bytes) of the request body are forwarded to WAF for inspection by the underlying host service. For information about how to handle oversized request bodies, see the <code>Body</code> object configuration. </p>
    pub fn body(mut self, input: crate::types::Body) -> Self {
        self.body = Some(input);
        self
    }
    /// <p>Inspect the request body as plain text. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. </p>
    /// <p>Only the first 8 KB (8192 bytes) of the request body are forwarded to WAF for inspection by the underlying host service. For information about how to handle oversized request bodies, see the <code>Body</code> object configuration. </p>
    pub fn set_body(mut self, input: std::option::Option<crate::types::Body>) -> Self {
        self.body = input;
        self
    }
    /// <p>Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform. </p>
    pub fn method(mut self, input: crate::types::Method) -> Self {
        self.method = Some(input);
        self
    }
    /// <p>Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform. </p>
    pub fn set_method(mut self, input: std::option::Option<crate::types::Method>) -> Self {
        self.method = input;
        self
    }
    /// <p>Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. </p>
    /// <p>Only the first 8 KB (8192 bytes) of the request body are forwarded to WAF for inspection by the underlying host service. For information about how to handle oversized request bodies, see the <code>JsonBody</code> object configuration. </p>
    pub fn json_body(mut self, input: crate::types::JsonBody) -> Self {
        self.json_body = Some(input);
        self
    }
    /// <p>Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. </p>
    /// <p>Only the first 8 KB (8192 bytes) of the request body are forwarded to WAF for inspection by the underlying host service. For information about how to handle oversized request bodies, see the <code>JsonBody</code> object configuration. </p>
    pub fn set_json_body(mut self, input: std::option::Option<crate::types::JsonBody>) -> Self {
        self.json_body = input;
        self
    }
    /// <p>Inspect the request headers. You must configure scope and pattern matching filters in the <code>Headers</code> object, to define the set of headers to and the parts of the headers that WAF inspects. </p>
    /// <p>Only the first 8 KB (8192 bytes) of a request's headers and only the first 200 headers are forwarded to WAF for inspection by the underlying host service. You must configure how to handle any oversize header content in the <code>Headers</code> object. WAF applies the pattern matching filters to the headers that it receives from the underlying host service. </p>
    pub fn headers(mut self, input: crate::types::Headers) -> Self {
        self.headers = Some(input);
        self
    }
    /// <p>Inspect the request headers. You must configure scope and pattern matching filters in the <code>Headers</code> object, to define the set of headers to and the parts of the headers that WAF inspects. </p>
    /// <p>Only the first 8 KB (8192 bytes) of a request's headers and only the first 200 headers are forwarded to WAF for inspection by the underlying host service. You must configure how to handle any oversize header content in the <code>Headers</code> object. WAF applies the pattern matching filters to the headers that it receives from the underlying host service. </p>
    pub fn set_headers(mut self, input: std::option::Option<crate::types::Headers>) -> Self {
        self.headers = input;
        self
    }
    /// <p>Inspect the request cookies. You must configure scope and pattern matching filters in the <code>Cookies</code> object, to define the set of cookies and the parts of the cookies that WAF inspects. </p>
    /// <p>Only the first 8 KB (8192 bytes) of a request's cookies and only the first 200 cookies are forwarded to WAF for inspection by the underlying host service. You must configure how to handle any oversize cookie content in the <code>Cookies</code> object. WAF applies the pattern matching filters to the cookies that it receives from the underlying host service. </p>
    pub fn cookies(mut self, input: crate::types::Cookies) -> Self {
        self.cookies = Some(input);
        self
    }
    /// <p>Inspect the request cookies. You must configure scope and pattern matching filters in the <code>Cookies</code> object, to define the set of cookies and the parts of the cookies that WAF inspects. </p>
    /// <p>Only the first 8 KB (8192 bytes) of a request's cookies and only the first 200 cookies are forwarded to WAF for inspection by the underlying host service. You must configure how to handle any oversize cookie content in the <code>Cookies</code> object. WAF applies the pattern matching filters to the cookies that it receives from the underlying host service. </p>
    pub fn set_cookies(mut self, input: std::option::Option<crate::types::Cookies>) -> Self {
        self.cookies = input;
        self
    }
    /// Consumes the builder and constructs a [`FieldToMatch`](crate::types::FieldToMatch).
    pub fn build(self) -> crate::types::FieldToMatch {
        crate::types::FieldToMatch {
            single_header: self.single_header,
            single_query_argument: self.single_query_argument,
            all_query_arguments: self.all_query_arguments,
            uri_path: self.uri_path,
            query_string: self.query_string,
            body: self.body,
            method: self.method,
            json_body: self.json_body,
            headers: self.headers,
            cookies: self.cookies,
        }
    }
}
