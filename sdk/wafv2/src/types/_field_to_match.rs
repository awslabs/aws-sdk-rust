// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The part of the web request that you want WAF to inspect. Include the single <code>FieldToMatch</code> type that you want to inspect, with additional specifications as needed, according to the type. You specify a single request component in <code>FieldToMatch</code> for each rule statement that requires it. To inspect more than one component of the web request, create a separate rule statement for each component.</p>
/// <p>Example JSON for a <code>QueryString</code> field to match:</p>
/// <p><code> "FieldToMatch": { "QueryString": {} }</code></p>
/// <p>Example JSON for a <code>Method</code> field to match specification:</p>
/// <p><code> "FieldToMatch": { "Method": { "Name": "DELETE" } }</code></p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct FieldToMatch {
    /// <p>Inspect a single header. Provide the name of the header to inspect, for example, <code>User-Agent</code> or <code>Referer</code>. This setting isn't case sensitive.</p>
    /// <p>Example JSON: <code>"SingleHeader": { "Name": "haystack" }</code></p>
    /// <p>Alternately, you can filter and inspect all headers with the <code>Headers</code> <code>FieldToMatch</code> setting.</p>
    pub single_header: ::std::option::Option<crate::types::SingleHeader>,
    /// <p>Inspect a single query argument. Provide the name of the query argument to inspect, such as <i>UserName</i> or <i>SalesRegion</i>. The name can be up to 30 characters long and isn't case sensitive.</p>
    /// <p>Example JSON: <code>"SingleQueryArgument": { "Name": "myArgument" }</code></p>
    pub single_query_argument: ::std::option::Option<crate::types::SingleQueryArgument>,
    /// <p>Inspect all query arguments.</p>
    pub all_query_arguments: ::std::option::Option<crate::types::AllQueryArguments>,
    /// <p>Inspect the request URI path. This is the part of the web request that identifies a resource, for example, <code>/images/daily-ad.jpg</code>.</p>
    pub uri_path: ::std::option::Option<crate::types::UriPath>,
    /// <p>Inspect the query string. This is the part of a URL that appears after a <code>?</code> character, if any.</p>
    pub query_string: ::std::option::Option<crate::types::QueryString>,
    /// <p>Inspect the request body as plain text. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.</p>
    /// <p>A limited amount of the request body is forwarded to WAF for inspection by the underlying host service. For regional resources, the limit is 8 KB (8,192 bytes) and for CloudFront distributions, the limit is 16 KB (16,384 bytes). For CloudFront distributions, you can increase the limit in the web ACL's <code>AssociationConfig</code>, for additional processing fees.</p>
    /// <p>For information about how to handle oversized request bodies, see the <code>Body</code> object configuration.</p>
    pub body: ::std::option::Option<crate::types::Body>,
    /// <p>Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.</p>
    pub method: ::std::option::Option<crate::types::Method>,
    /// <p>Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.</p>
    /// <p>A limited amount of the request body is forwarded to WAF for inspection by the underlying host service. For regional resources, the limit is 8 KB (8,192 bytes) and for CloudFront distributions, the limit is 16 KB (16,384 bytes). For CloudFront distributions, you can increase the limit in the web ACL's <code>AssociationConfig</code>, for additional processing fees.</p>
    /// <p>For information about how to handle oversized request bodies, see the <code>JsonBody</code> object configuration.</p>
    pub json_body: ::std::option::Option<crate::types::JsonBody>,
    /// <p>Inspect the request headers. You must configure scope and pattern matching filters in the <code>Headers</code> object, to define the set of headers to and the parts of the headers that WAF inspects.</p>
    /// <p>Only the first 8 KB (8192 bytes) of a request's headers and only the first 200 headers are forwarded to WAF for inspection by the underlying host service. You must configure how to handle any oversize header content in the <code>Headers</code> object. WAF applies the pattern matching filters to the headers that it receives from the underlying host service.</p>
    pub headers: ::std::option::Option<crate::types::Headers>,
    /// <p>Inspect the request cookies. You must configure scope and pattern matching filters in the <code>Cookies</code> object, to define the set of cookies and the parts of the cookies that WAF inspects.</p>
    /// <p>Only the first 8 KB (8192 bytes) of a request's cookies and only the first 200 cookies are forwarded to WAF for inspection by the underlying host service. You must configure how to handle any oversize cookie content in the <code>Cookies</code> object. WAF applies the pattern matching filters to the cookies that it receives from the underlying host service.</p>
    pub cookies: ::std::option::Option<crate::types::Cookies>,
    /// <p>Inspect a string containing the list of the request's header names, ordered as they appear in the web request that WAF receives for inspection. WAF generates the string and then uses that as the field to match component in its inspection. WAF separates the header names in the string using colons and no added spaces, for example <code>host:user-agent:accept:authorization:referer</code>.</p>
    pub header_order: ::std::option::Option<crate::types::HeaderOrder>,
    /// <p>Match against the request's JA3 fingerprint. The JA3 fingerprint is a 32-character hash derived from the TLS Client Hello of an incoming request. This fingerprint serves as a unique identifier for the client's TLS configuration. WAF calculates and logs this fingerprint for each request that has enough TLS Client Hello information for the calculation. Almost all web requests include this information.</p><note>
    /// <p>You can use this choice only with a string match <code>ByteMatchStatement</code> with the <code>PositionalConstraint</code> set to <code>EXACTLY</code>.</p>
    /// </note>
    /// <p>You can obtain the JA3 fingerprint for client requests from the web ACL logs. If WAF is able to calculate the fingerprint, it includes it in the logs. For information about the logging fields, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/logging-fields.html">Log fields</a> in the <i>WAF Developer Guide</i>.</p>
    /// <p>Provide the JA3 fingerprint string from the logs in your string match statement specification, to match with any future requests that have the same TLS configuration.</p>
    pub ja3_fingerprint: ::std::option::Option<crate::types::Ja3Fingerprint>,
}
impl FieldToMatch {
    /// <p>Inspect a single header. Provide the name of the header to inspect, for example, <code>User-Agent</code> or <code>Referer</code>. This setting isn't case sensitive.</p>
    /// <p>Example JSON: <code>"SingleHeader": { "Name": "haystack" }</code></p>
    /// <p>Alternately, you can filter and inspect all headers with the <code>Headers</code> <code>FieldToMatch</code> setting.</p>
    pub fn single_header(&self) -> ::std::option::Option<&crate::types::SingleHeader> {
        self.single_header.as_ref()
    }
    /// <p>Inspect a single query argument. Provide the name of the query argument to inspect, such as <i>UserName</i> or <i>SalesRegion</i>. The name can be up to 30 characters long and isn't case sensitive.</p>
    /// <p>Example JSON: <code>"SingleQueryArgument": { "Name": "myArgument" }</code></p>
    pub fn single_query_argument(&self) -> ::std::option::Option<&crate::types::SingleQueryArgument> {
        self.single_query_argument.as_ref()
    }
    /// <p>Inspect all query arguments.</p>
    pub fn all_query_arguments(&self) -> ::std::option::Option<&crate::types::AllQueryArguments> {
        self.all_query_arguments.as_ref()
    }
    /// <p>Inspect the request URI path. This is the part of the web request that identifies a resource, for example, <code>/images/daily-ad.jpg</code>.</p>
    pub fn uri_path(&self) -> ::std::option::Option<&crate::types::UriPath> {
        self.uri_path.as_ref()
    }
    /// <p>Inspect the query string. This is the part of a URL that appears after a <code>?</code> character, if any.</p>
    pub fn query_string(&self) -> ::std::option::Option<&crate::types::QueryString> {
        self.query_string.as_ref()
    }
    /// <p>Inspect the request body as plain text. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.</p>
    /// <p>A limited amount of the request body is forwarded to WAF for inspection by the underlying host service. For regional resources, the limit is 8 KB (8,192 bytes) and for CloudFront distributions, the limit is 16 KB (16,384 bytes). For CloudFront distributions, you can increase the limit in the web ACL's <code>AssociationConfig</code>, for additional processing fees.</p>
    /// <p>For information about how to handle oversized request bodies, see the <code>Body</code> object configuration.</p>
    pub fn body(&self) -> ::std::option::Option<&crate::types::Body> {
        self.body.as_ref()
    }
    /// <p>Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.</p>
    pub fn method(&self) -> ::std::option::Option<&crate::types::Method> {
        self.method.as_ref()
    }
    /// <p>Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.</p>
    /// <p>A limited amount of the request body is forwarded to WAF for inspection by the underlying host service. For regional resources, the limit is 8 KB (8,192 bytes) and for CloudFront distributions, the limit is 16 KB (16,384 bytes). For CloudFront distributions, you can increase the limit in the web ACL's <code>AssociationConfig</code>, for additional processing fees.</p>
    /// <p>For information about how to handle oversized request bodies, see the <code>JsonBody</code> object configuration.</p>
    pub fn json_body(&self) -> ::std::option::Option<&crate::types::JsonBody> {
        self.json_body.as_ref()
    }
    /// <p>Inspect the request headers. You must configure scope and pattern matching filters in the <code>Headers</code> object, to define the set of headers to and the parts of the headers that WAF inspects.</p>
    /// <p>Only the first 8 KB (8192 bytes) of a request's headers and only the first 200 headers are forwarded to WAF for inspection by the underlying host service. You must configure how to handle any oversize header content in the <code>Headers</code> object. WAF applies the pattern matching filters to the headers that it receives from the underlying host service.</p>
    pub fn headers(&self) -> ::std::option::Option<&crate::types::Headers> {
        self.headers.as_ref()
    }
    /// <p>Inspect the request cookies. You must configure scope and pattern matching filters in the <code>Cookies</code> object, to define the set of cookies and the parts of the cookies that WAF inspects.</p>
    /// <p>Only the first 8 KB (8192 bytes) of a request's cookies and only the first 200 cookies are forwarded to WAF for inspection by the underlying host service. You must configure how to handle any oversize cookie content in the <code>Cookies</code> object. WAF applies the pattern matching filters to the cookies that it receives from the underlying host service.</p>
    pub fn cookies(&self) -> ::std::option::Option<&crate::types::Cookies> {
        self.cookies.as_ref()
    }
    /// <p>Inspect a string containing the list of the request's header names, ordered as they appear in the web request that WAF receives for inspection. WAF generates the string and then uses that as the field to match component in its inspection. WAF separates the header names in the string using colons and no added spaces, for example <code>host:user-agent:accept:authorization:referer</code>.</p>
    pub fn header_order(&self) -> ::std::option::Option<&crate::types::HeaderOrder> {
        self.header_order.as_ref()
    }
    /// <p>Match against the request's JA3 fingerprint. The JA3 fingerprint is a 32-character hash derived from the TLS Client Hello of an incoming request. This fingerprint serves as a unique identifier for the client's TLS configuration. WAF calculates and logs this fingerprint for each request that has enough TLS Client Hello information for the calculation. Almost all web requests include this information.</p><note>
    /// <p>You can use this choice only with a string match <code>ByteMatchStatement</code> with the <code>PositionalConstraint</code> set to <code>EXACTLY</code>.</p>
    /// </note>
    /// <p>You can obtain the JA3 fingerprint for client requests from the web ACL logs. If WAF is able to calculate the fingerprint, it includes it in the logs. For information about the logging fields, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/logging-fields.html">Log fields</a> in the <i>WAF Developer Guide</i>.</p>
    /// <p>Provide the JA3 fingerprint string from the logs in your string match statement specification, to match with any future requests that have the same TLS configuration.</p>
    pub fn ja3_fingerprint(&self) -> ::std::option::Option<&crate::types::Ja3Fingerprint> {
        self.ja3_fingerprint.as_ref()
    }
}
impl FieldToMatch {
    /// Creates a new builder-style object to manufacture [`FieldToMatch`](crate::types::FieldToMatch).
    pub fn builder() -> crate::types::builders::FieldToMatchBuilder {
        crate::types::builders::FieldToMatchBuilder::default()
    }
}

/// A builder for [`FieldToMatch`](crate::types::FieldToMatch).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct FieldToMatchBuilder {
    pub(crate) single_header: ::std::option::Option<crate::types::SingleHeader>,
    pub(crate) single_query_argument: ::std::option::Option<crate::types::SingleQueryArgument>,
    pub(crate) all_query_arguments: ::std::option::Option<crate::types::AllQueryArguments>,
    pub(crate) uri_path: ::std::option::Option<crate::types::UriPath>,
    pub(crate) query_string: ::std::option::Option<crate::types::QueryString>,
    pub(crate) body: ::std::option::Option<crate::types::Body>,
    pub(crate) method: ::std::option::Option<crate::types::Method>,
    pub(crate) json_body: ::std::option::Option<crate::types::JsonBody>,
    pub(crate) headers: ::std::option::Option<crate::types::Headers>,
    pub(crate) cookies: ::std::option::Option<crate::types::Cookies>,
    pub(crate) header_order: ::std::option::Option<crate::types::HeaderOrder>,
    pub(crate) ja3_fingerprint: ::std::option::Option<crate::types::Ja3Fingerprint>,
}
impl FieldToMatchBuilder {
    /// <p>Inspect a single header. Provide the name of the header to inspect, for example, <code>User-Agent</code> or <code>Referer</code>. This setting isn't case sensitive.</p>
    /// <p>Example JSON: <code>"SingleHeader": { "Name": "haystack" }</code></p>
    /// <p>Alternately, you can filter and inspect all headers with the <code>Headers</code> <code>FieldToMatch</code> setting.</p>
    pub fn single_header(mut self, input: crate::types::SingleHeader) -> Self {
        self.single_header = ::std::option::Option::Some(input);
        self
    }
    /// <p>Inspect a single header. Provide the name of the header to inspect, for example, <code>User-Agent</code> or <code>Referer</code>. This setting isn't case sensitive.</p>
    /// <p>Example JSON: <code>"SingleHeader": { "Name": "haystack" }</code></p>
    /// <p>Alternately, you can filter and inspect all headers with the <code>Headers</code> <code>FieldToMatch</code> setting.</p>
    pub fn set_single_header(mut self, input: ::std::option::Option<crate::types::SingleHeader>) -> Self {
        self.single_header = input;
        self
    }
    /// <p>Inspect a single header. Provide the name of the header to inspect, for example, <code>User-Agent</code> or <code>Referer</code>. This setting isn't case sensitive.</p>
    /// <p>Example JSON: <code>"SingleHeader": { "Name": "haystack" }</code></p>
    /// <p>Alternately, you can filter and inspect all headers with the <code>Headers</code> <code>FieldToMatch</code> setting.</p>
    pub fn get_single_header(&self) -> &::std::option::Option<crate::types::SingleHeader> {
        &self.single_header
    }
    /// <p>Inspect a single query argument. Provide the name of the query argument to inspect, such as <i>UserName</i> or <i>SalesRegion</i>. The name can be up to 30 characters long and isn't case sensitive.</p>
    /// <p>Example JSON: <code>"SingleQueryArgument": { "Name": "myArgument" }</code></p>
    pub fn single_query_argument(mut self, input: crate::types::SingleQueryArgument) -> Self {
        self.single_query_argument = ::std::option::Option::Some(input);
        self
    }
    /// <p>Inspect a single query argument. Provide the name of the query argument to inspect, such as <i>UserName</i> or <i>SalesRegion</i>. The name can be up to 30 characters long and isn't case sensitive.</p>
    /// <p>Example JSON: <code>"SingleQueryArgument": { "Name": "myArgument" }</code></p>
    pub fn set_single_query_argument(mut self, input: ::std::option::Option<crate::types::SingleQueryArgument>) -> Self {
        self.single_query_argument = input;
        self
    }
    /// <p>Inspect a single query argument. Provide the name of the query argument to inspect, such as <i>UserName</i> or <i>SalesRegion</i>. The name can be up to 30 characters long and isn't case sensitive.</p>
    /// <p>Example JSON: <code>"SingleQueryArgument": { "Name": "myArgument" }</code></p>
    pub fn get_single_query_argument(&self) -> &::std::option::Option<crate::types::SingleQueryArgument> {
        &self.single_query_argument
    }
    /// <p>Inspect all query arguments.</p>
    pub fn all_query_arguments(mut self, input: crate::types::AllQueryArguments) -> Self {
        self.all_query_arguments = ::std::option::Option::Some(input);
        self
    }
    /// <p>Inspect all query arguments.</p>
    pub fn set_all_query_arguments(mut self, input: ::std::option::Option<crate::types::AllQueryArguments>) -> Self {
        self.all_query_arguments = input;
        self
    }
    /// <p>Inspect all query arguments.</p>
    pub fn get_all_query_arguments(&self) -> &::std::option::Option<crate::types::AllQueryArguments> {
        &self.all_query_arguments
    }
    /// <p>Inspect the request URI path. This is the part of the web request that identifies a resource, for example, <code>/images/daily-ad.jpg</code>.</p>
    pub fn uri_path(mut self, input: crate::types::UriPath) -> Self {
        self.uri_path = ::std::option::Option::Some(input);
        self
    }
    /// <p>Inspect the request URI path. This is the part of the web request that identifies a resource, for example, <code>/images/daily-ad.jpg</code>.</p>
    pub fn set_uri_path(mut self, input: ::std::option::Option<crate::types::UriPath>) -> Self {
        self.uri_path = input;
        self
    }
    /// <p>Inspect the request URI path. This is the part of the web request that identifies a resource, for example, <code>/images/daily-ad.jpg</code>.</p>
    pub fn get_uri_path(&self) -> &::std::option::Option<crate::types::UriPath> {
        &self.uri_path
    }
    /// <p>Inspect the query string. This is the part of a URL that appears after a <code>?</code> character, if any.</p>
    pub fn query_string(mut self, input: crate::types::QueryString) -> Self {
        self.query_string = ::std::option::Option::Some(input);
        self
    }
    /// <p>Inspect the query string. This is the part of a URL that appears after a <code>?</code> character, if any.</p>
    pub fn set_query_string(mut self, input: ::std::option::Option<crate::types::QueryString>) -> Self {
        self.query_string = input;
        self
    }
    /// <p>Inspect the query string. This is the part of a URL that appears after a <code>?</code> character, if any.</p>
    pub fn get_query_string(&self) -> &::std::option::Option<crate::types::QueryString> {
        &self.query_string
    }
    /// <p>Inspect the request body as plain text. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.</p>
    /// <p>A limited amount of the request body is forwarded to WAF for inspection by the underlying host service. For regional resources, the limit is 8 KB (8,192 bytes) and for CloudFront distributions, the limit is 16 KB (16,384 bytes). For CloudFront distributions, you can increase the limit in the web ACL's <code>AssociationConfig</code>, for additional processing fees.</p>
    /// <p>For information about how to handle oversized request bodies, see the <code>Body</code> object configuration.</p>
    pub fn body(mut self, input: crate::types::Body) -> Self {
        self.body = ::std::option::Option::Some(input);
        self
    }
    /// <p>Inspect the request body as plain text. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.</p>
    /// <p>A limited amount of the request body is forwarded to WAF for inspection by the underlying host service. For regional resources, the limit is 8 KB (8,192 bytes) and for CloudFront distributions, the limit is 16 KB (16,384 bytes). For CloudFront distributions, you can increase the limit in the web ACL's <code>AssociationConfig</code>, for additional processing fees.</p>
    /// <p>For information about how to handle oversized request bodies, see the <code>Body</code> object configuration.</p>
    pub fn set_body(mut self, input: ::std::option::Option<crate::types::Body>) -> Self {
        self.body = input;
        self
    }
    /// <p>Inspect the request body as plain text. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.</p>
    /// <p>A limited amount of the request body is forwarded to WAF for inspection by the underlying host service. For regional resources, the limit is 8 KB (8,192 bytes) and for CloudFront distributions, the limit is 16 KB (16,384 bytes). For CloudFront distributions, you can increase the limit in the web ACL's <code>AssociationConfig</code>, for additional processing fees.</p>
    /// <p>For information about how to handle oversized request bodies, see the <code>Body</code> object configuration.</p>
    pub fn get_body(&self) -> &::std::option::Option<crate::types::Body> {
        &self.body
    }
    /// <p>Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.</p>
    pub fn method(mut self, input: crate::types::Method) -> Self {
        self.method = ::std::option::Option::Some(input);
        self
    }
    /// <p>Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.</p>
    pub fn set_method(mut self, input: ::std::option::Option<crate::types::Method>) -> Self {
        self.method = input;
        self
    }
    /// <p>Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.</p>
    pub fn get_method(&self) -> &::std::option::Option<crate::types::Method> {
        &self.method
    }
    /// <p>Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.</p>
    /// <p>A limited amount of the request body is forwarded to WAF for inspection by the underlying host service. For regional resources, the limit is 8 KB (8,192 bytes) and for CloudFront distributions, the limit is 16 KB (16,384 bytes). For CloudFront distributions, you can increase the limit in the web ACL's <code>AssociationConfig</code>, for additional processing fees.</p>
    /// <p>For information about how to handle oversized request bodies, see the <code>JsonBody</code> object configuration.</p>
    pub fn json_body(mut self, input: crate::types::JsonBody) -> Self {
        self.json_body = ::std::option::Option::Some(input);
        self
    }
    /// <p>Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.</p>
    /// <p>A limited amount of the request body is forwarded to WAF for inspection by the underlying host service. For regional resources, the limit is 8 KB (8,192 bytes) and for CloudFront distributions, the limit is 16 KB (16,384 bytes). For CloudFront distributions, you can increase the limit in the web ACL's <code>AssociationConfig</code>, for additional processing fees.</p>
    /// <p>For information about how to handle oversized request bodies, see the <code>JsonBody</code> object configuration.</p>
    pub fn set_json_body(mut self, input: ::std::option::Option<crate::types::JsonBody>) -> Self {
        self.json_body = input;
        self
    }
    /// <p>Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.</p>
    /// <p>A limited amount of the request body is forwarded to WAF for inspection by the underlying host service. For regional resources, the limit is 8 KB (8,192 bytes) and for CloudFront distributions, the limit is 16 KB (16,384 bytes). For CloudFront distributions, you can increase the limit in the web ACL's <code>AssociationConfig</code>, for additional processing fees.</p>
    /// <p>For information about how to handle oversized request bodies, see the <code>JsonBody</code> object configuration.</p>
    pub fn get_json_body(&self) -> &::std::option::Option<crate::types::JsonBody> {
        &self.json_body
    }
    /// <p>Inspect the request headers. You must configure scope and pattern matching filters in the <code>Headers</code> object, to define the set of headers to and the parts of the headers that WAF inspects.</p>
    /// <p>Only the first 8 KB (8192 bytes) of a request's headers and only the first 200 headers are forwarded to WAF for inspection by the underlying host service. You must configure how to handle any oversize header content in the <code>Headers</code> object. WAF applies the pattern matching filters to the headers that it receives from the underlying host service.</p>
    pub fn headers(mut self, input: crate::types::Headers) -> Self {
        self.headers = ::std::option::Option::Some(input);
        self
    }
    /// <p>Inspect the request headers. You must configure scope and pattern matching filters in the <code>Headers</code> object, to define the set of headers to and the parts of the headers that WAF inspects.</p>
    /// <p>Only the first 8 KB (8192 bytes) of a request's headers and only the first 200 headers are forwarded to WAF for inspection by the underlying host service. You must configure how to handle any oversize header content in the <code>Headers</code> object. WAF applies the pattern matching filters to the headers that it receives from the underlying host service.</p>
    pub fn set_headers(mut self, input: ::std::option::Option<crate::types::Headers>) -> Self {
        self.headers = input;
        self
    }
    /// <p>Inspect the request headers. You must configure scope and pattern matching filters in the <code>Headers</code> object, to define the set of headers to and the parts of the headers that WAF inspects.</p>
    /// <p>Only the first 8 KB (8192 bytes) of a request's headers and only the first 200 headers are forwarded to WAF for inspection by the underlying host service. You must configure how to handle any oversize header content in the <code>Headers</code> object. WAF applies the pattern matching filters to the headers that it receives from the underlying host service.</p>
    pub fn get_headers(&self) -> &::std::option::Option<crate::types::Headers> {
        &self.headers
    }
    /// <p>Inspect the request cookies. You must configure scope and pattern matching filters in the <code>Cookies</code> object, to define the set of cookies and the parts of the cookies that WAF inspects.</p>
    /// <p>Only the first 8 KB (8192 bytes) of a request's cookies and only the first 200 cookies are forwarded to WAF for inspection by the underlying host service. You must configure how to handle any oversize cookie content in the <code>Cookies</code> object. WAF applies the pattern matching filters to the cookies that it receives from the underlying host service.</p>
    pub fn cookies(mut self, input: crate::types::Cookies) -> Self {
        self.cookies = ::std::option::Option::Some(input);
        self
    }
    /// <p>Inspect the request cookies. You must configure scope and pattern matching filters in the <code>Cookies</code> object, to define the set of cookies and the parts of the cookies that WAF inspects.</p>
    /// <p>Only the first 8 KB (8192 bytes) of a request's cookies and only the first 200 cookies are forwarded to WAF for inspection by the underlying host service. You must configure how to handle any oversize cookie content in the <code>Cookies</code> object. WAF applies the pattern matching filters to the cookies that it receives from the underlying host service.</p>
    pub fn set_cookies(mut self, input: ::std::option::Option<crate::types::Cookies>) -> Self {
        self.cookies = input;
        self
    }
    /// <p>Inspect the request cookies. You must configure scope and pattern matching filters in the <code>Cookies</code> object, to define the set of cookies and the parts of the cookies that WAF inspects.</p>
    /// <p>Only the first 8 KB (8192 bytes) of a request's cookies and only the first 200 cookies are forwarded to WAF for inspection by the underlying host service. You must configure how to handle any oversize cookie content in the <code>Cookies</code> object. WAF applies the pattern matching filters to the cookies that it receives from the underlying host service.</p>
    pub fn get_cookies(&self) -> &::std::option::Option<crate::types::Cookies> {
        &self.cookies
    }
    /// <p>Inspect a string containing the list of the request's header names, ordered as they appear in the web request that WAF receives for inspection. WAF generates the string and then uses that as the field to match component in its inspection. WAF separates the header names in the string using colons and no added spaces, for example <code>host:user-agent:accept:authorization:referer</code>.</p>
    pub fn header_order(mut self, input: crate::types::HeaderOrder) -> Self {
        self.header_order = ::std::option::Option::Some(input);
        self
    }
    /// <p>Inspect a string containing the list of the request's header names, ordered as they appear in the web request that WAF receives for inspection. WAF generates the string and then uses that as the field to match component in its inspection. WAF separates the header names in the string using colons and no added spaces, for example <code>host:user-agent:accept:authorization:referer</code>.</p>
    pub fn set_header_order(mut self, input: ::std::option::Option<crate::types::HeaderOrder>) -> Self {
        self.header_order = input;
        self
    }
    /// <p>Inspect a string containing the list of the request's header names, ordered as they appear in the web request that WAF receives for inspection. WAF generates the string and then uses that as the field to match component in its inspection. WAF separates the header names in the string using colons and no added spaces, for example <code>host:user-agent:accept:authorization:referer</code>.</p>
    pub fn get_header_order(&self) -> &::std::option::Option<crate::types::HeaderOrder> {
        &self.header_order
    }
    /// <p>Match against the request's JA3 fingerprint. The JA3 fingerprint is a 32-character hash derived from the TLS Client Hello of an incoming request. This fingerprint serves as a unique identifier for the client's TLS configuration. WAF calculates and logs this fingerprint for each request that has enough TLS Client Hello information for the calculation. Almost all web requests include this information.</p><note>
    /// <p>You can use this choice only with a string match <code>ByteMatchStatement</code> with the <code>PositionalConstraint</code> set to <code>EXACTLY</code>.</p>
    /// </note>
    /// <p>You can obtain the JA3 fingerprint for client requests from the web ACL logs. If WAF is able to calculate the fingerprint, it includes it in the logs. For information about the logging fields, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/logging-fields.html">Log fields</a> in the <i>WAF Developer Guide</i>.</p>
    /// <p>Provide the JA3 fingerprint string from the logs in your string match statement specification, to match with any future requests that have the same TLS configuration.</p>
    pub fn ja3_fingerprint(mut self, input: crate::types::Ja3Fingerprint) -> Self {
        self.ja3_fingerprint = ::std::option::Option::Some(input);
        self
    }
    /// <p>Match against the request's JA3 fingerprint. The JA3 fingerprint is a 32-character hash derived from the TLS Client Hello of an incoming request. This fingerprint serves as a unique identifier for the client's TLS configuration. WAF calculates and logs this fingerprint for each request that has enough TLS Client Hello information for the calculation. Almost all web requests include this information.</p><note>
    /// <p>You can use this choice only with a string match <code>ByteMatchStatement</code> with the <code>PositionalConstraint</code> set to <code>EXACTLY</code>.</p>
    /// </note>
    /// <p>You can obtain the JA3 fingerprint for client requests from the web ACL logs. If WAF is able to calculate the fingerprint, it includes it in the logs. For information about the logging fields, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/logging-fields.html">Log fields</a> in the <i>WAF Developer Guide</i>.</p>
    /// <p>Provide the JA3 fingerprint string from the logs in your string match statement specification, to match with any future requests that have the same TLS configuration.</p>
    pub fn set_ja3_fingerprint(mut self, input: ::std::option::Option<crate::types::Ja3Fingerprint>) -> Self {
        self.ja3_fingerprint = input;
        self
    }
    /// <p>Match against the request's JA3 fingerprint. The JA3 fingerprint is a 32-character hash derived from the TLS Client Hello of an incoming request. This fingerprint serves as a unique identifier for the client's TLS configuration. WAF calculates and logs this fingerprint for each request that has enough TLS Client Hello information for the calculation. Almost all web requests include this information.</p><note>
    /// <p>You can use this choice only with a string match <code>ByteMatchStatement</code> with the <code>PositionalConstraint</code> set to <code>EXACTLY</code>.</p>
    /// </note>
    /// <p>You can obtain the JA3 fingerprint for client requests from the web ACL logs. If WAF is able to calculate the fingerprint, it includes it in the logs. For information about the logging fields, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/logging-fields.html">Log fields</a> in the <i>WAF Developer Guide</i>.</p>
    /// <p>Provide the JA3 fingerprint string from the logs in your string match statement specification, to match with any future requests that have the same TLS configuration.</p>
    pub fn get_ja3_fingerprint(&self) -> &::std::option::Option<crate::types::Ja3Fingerprint> {
        &self.ja3_fingerprint
    }
    /// Consumes the builder and constructs a [`FieldToMatch`](crate::types::FieldToMatch).
    pub fn build(self) -> crate::types::FieldToMatch {
        crate::types::FieldToMatch {
            single_header: self.single_header,
            single_query_argument: self.single_query_argument,
            all_query_arguments: self.all_query_arguments,
            uri_path: self.uri_path,
            query_string: self.query_string,
            body: self.body,
            method: self.method,
            json_body: self.json_body,
            headers: self.headers,
            cookies: self.cookies,
            header_order: self.header_order,
            ja3_fingerprint: self.ja3_fingerprint,
        }
    }
}
