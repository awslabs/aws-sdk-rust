// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A rule statement used to run the rules that are defined in a managed rule group. To use this, provide the vendor name and the name of the rule group in this statement. You can retrieve the required names by calling <code>ListAvailableManagedRuleGroups</code>.</p>
/// <p>You cannot nest a <code>ManagedRuleGroupStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. It can only be referenced as a top-level statement within a rule.</p> <note>
/// <p>You are charged additional fees when you use the WAF Bot Control managed rule group <code>AWSManagedRulesBotControlRuleSet</code> or the WAF Fraud Control account takeover prevention (ATP) managed rule group <code>AWSManagedRulesATPRuleSet</code>. For more information, see <a href="http://aws.amazon.com/waf/pricing/">WAF Pricing</a>.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ManagedRuleGroupStatement {
    /// <p>The name of the managed rule group vendor. You use this, along with the rule group name, to identify the rule group.</p>
    #[doc(hidden)]
    pub vendor_name: std::option::Option<std::string::String>,
    /// <p>The name of the managed rule group. You use this, along with the vendor name, to identify the rule group.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The version of the managed rule group to use. If you specify this, the version setting is fixed until you change it. If you don't specify this, WAF uses the vendor's default version, and then keeps the version at the vendor's default when the vendor updates the managed rule group settings. </p>
    #[doc(hidden)]
    pub version: std::option::Option<std::string::String>,
    /// <p>Rules in the referenced rule group whose actions are set to <code>Count</code>. </p> <note>
    /// <p>Instead of this option, use <code>RuleActionOverrides</code>. It accepts any valid action setting, including <code>Count</code>.</p>
    /// </note>
    #[doc(hidden)]
    pub excluded_rules: std::option::Option<std::vec::Vec<crate::types::ExcludedRule>>,
    /// <p>An optional nested statement that narrows the scope of the web requests that are evaluated by the managed rule group. Requests are only evaluated by the rule group if they match the scope-down statement. You can use any nestable <code>Statement</code> in the scope-down statement, and you can nest statements at any level, the same as you can for a rule statement. </p>
    #[doc(hidden)]
    pub scope_down_statement: std::option::Option<std::boxed::Box<crate::types::Statement>>,
    /// <p>Additional information that's used by a managed rule group. Many managed rule groups don't require this.</p>
    /// <p>Use the <code>AWSManagedRulesBotControlRuleSet</code> configuration object to configure the protection level that you want the Bot Control rule group to use. </p>
    #[doc(hidden)]
    pub managed_rule_group_configs:
        std::option::Option<std::vec::Vec<crate::types::ManagedRuleGroupConfig>>,
    /// <p>Action settings to use in the place of the rule actions that are configured inside the rule group. You specify one override for each rule whose action you want to change. </p>
    /// <p>You can use overrides for testing, for example you can override all of rule actions to <code>Count</code> and then monitor the resulting count metrics to understand how the rule group would handle your web traffic. You can also permanently override some or all actions, to modify how the rule group manages your web traffic.</p>
    #[doc(hidden)]
    pub rule_action_overrides: std::option::Option<std::vec::Vec<crate::types::RuleActionOverride>>,
}
impl ManagedRuleGroupStatement {
    /// <p>The name of the managed rule group vendor. You use this, along with the rule group name, to identify the rule group.</p>
    pub fn vendor_name(&self) -> std::option::Option<&str> {
        self.vendor_name.as_deref()
    }
    /// <p>The name of the managed rule group. You use this, along with the vendor name, to identify the rule group.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The version of the managed rule group to use. If you specify this, the version setting is fixed until you change it. If you don't specify this, WAF uses the vendor's default version, and then keeps the version at the vendor's default when the vendor updates the managed rule group settings. </p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
    /// <p>Rules in the referenced rule group whose actions are set to <code>Count</code>. </p> <note>
    /// <p>Instead of this option, use <code>RuleActionOverrides</code>. It accepts any valid action setting, including <code>Count</code>.</p>
    /// </note>
    pub fn excluded_rules(&self) -> std::option::Option<&[crate::types::ExcludedRule]> {
        self.excluded_rules.as_deref()
    }
    /// <p>An optional nested statement that narrows the scope of the web requests that are evaluated by the managed rule group. Requests are only evaluated by the rule group if they match the scope-down statement. You can use any nestable <code>Statement</code> in the scope-down statement, and you can nest statements at any level, the same as you can for a rule statement. </p>
    pub fn scope_down_statement(&self) -> std::option::Option<&crate::types::Statement> {
        self.scope_down_statement.as_deref()
    }
    /// <p>Additional information that's used by a managed rule group. Many managed rule groups don't require this.</p>
    /// <p>Use the <code>AWSManagedRulesBotControlRuleSet</code> configuration object to configure the protection level that you want the Bot Control rule group to use. </p>
    pub fn managed_rule_group_configs(
        &self,
    ) -> std::option::Option<&[crate::types::ManagedRuleGroupConfig]> {
        self.managed_rule_group_configs.as_deref()
    }
    /// <p>Action settings to use in the place of the rule actions that are configured inside the rule group. You specify one override for each rule whose action you want to change. </p>
    /// <p>You can use overrides for testing, for example you can override all of rule actions to <code>Count</code> and then monitor the resulting count metrics to understand how the rule group would handle your web traffic. You can also permanently override some or all actions, to modify how the rule group manages your web traffic.</p>
    pub fn rule_action_overrides(
        &self,
    ) -> std::option::Option<&[crate::types::RuleActionOverride]> {
        self.rule_action_overrides.as_deref()
    }
}
impl ManagedRuleGroupStatement {
    /// Creates a new builder-style object to manufacture [`ManagedRuleGroupStatement`](crate::types::ManagedRuleGroupStatement).
    pub fn builder() -> crate::types::builders::ManagedRuleGroupStatementBuilder {
        crate::types::builders::ManagedRuleGroupStatementBuilder::default()
    }
}

/// A builder for [`ManagedRuleGroupStatement`](crate::types::ManagedRuleGroupStatement).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct ManagedRuleGroupStatementBuilder {
    pub(crate) vendor_name: std::option::Option<std::string::String>,
    pub(crate) name: std::option::Option<std::string::String>,
    pub(crate) version: std::option::Option<std::string::String>,
    pub(crate) excluded_rules: std::option::Option<std::vec::Vec<crate::types::ExcludedRule>>,
    pub(crate) scope_down_statement: std::option::Option<std::boxed::Box<crate::types::Statement>>,
    pub(crate) managed_rule_group_configs:
        std::option::Option<std::vec::Vec<crate::types::ManagedRuleGroupConfig>>,
    pub(crate) rule_action_overrides:
        std::option::Option<std::vec::Vec<crate::types::RuleActionOverride>>,
}
impl ManagedRuleGroupStatementBuilder {
    /// <p>The name of the managed rule group vendor. You use this, along with the rule group name, to identify the rule group.</p>
    pub fn vendor_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.vendor_name = Some(input.into());
        self
    }
    /// <p>The name of the managed rule group vendor. You use this, along with the rule group name, to identify the rule group.</p>
    pub fn set_vendor_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.vendor_name = input;
        self
    }
    /// <p>The name of the managed rule group. You use this, along with the vendor name, to identify the rule group.</p>
    pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
        self.name = Some(input.into());
        self
    }
    /// <p>The name of the managed rule group. You use this, along with the vendor name, to identify the rule group.</p>
    pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The version of the managed rule group to use. If you specify this, the version setting is fixed until you change it. If you don't specify this, WAF uses the vendor's default version, and then keeps the version at the vendor's default when the vendor updates the managed rule group settings. </p>
    pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
        self.version = Some(input.into());
        self
    }
    /// <p>The version of the managed rule group to use. If you specify this, the version setting is fixed until you change it. If you don't specify this, WAF uses the vendor's default version, and then keeps the version at the vendor's default when the vendor updates the managed rule group settings. </p>
    pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.version = input;
        self
    }
    /// Appends an item to `excluded_rules`.
    ///
    /// To override the contents of this collection use [`set_excluded_rules`](Self::set_excluded_rules).
    ///
    /// <p>Rules in the referenced rule group whose actions are set to <code>Count</code>. </p> <note>
    /// <p>Instead of this option, use <code>RuleActionOverrides</code>. It accepts any valid action setting, including <code>Count</code>.</p>
    /// </note>
    pub fn excluded_rules(mut self, input: crate::types::ExcludedRule) -> Self {
        let mut v = self.excluded_rules.unwrap_or_default();
        v.push(input);
        self.excluded_rules = Some(v);
        self
    }
    /// <p>Rules in the referenced rule group whose actions are set to <code>Count</code>. </p> <note>
    /// <p>Instead of this option, use <code>RuleActionOverrides</code>. It accepts any valid action setting, including <code>Count</code>.</p>
    /// </note>
    pub fn set_excluded_rules(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::ExcludedRule>>,
    ) -> Self {
        self.excluded_rules = input;
        self
    }
    /// <p>An optional nested statement that narrows the scope of the web requests that are evaluated by the managed rule group. Requests are only evaluated by the rule group if they match the scope-down statement. You can use any nestable <code>Statement</code> in the scope-down statement, and you can nest statements at any level, the same as you can for a rule statement. </p>
    pub fn scope_down_statement(
        mut self,
        input: impl Into<std::boxed::Box<crate::types::Statement>>,
    ) -> Self {
        self.scope_down_statement = Some(input.into());
        self
    }
    /// <p>An optional nested statement that narrows the scope of the web requests that are evaluated by the managed rule group. Requests are only evaluated by the rule group if they match the scope-down statement. You can use any nestable <code>Statement</code> in the scope-down statement, and you can nest statements at any level, the same as you can for a rule statement. </p>
    pub fn set_scope_down_statement(
        mut self,
        input: std::option::Option<std::boxed::Box<crate::types::Statement>>,
    ) -> Self {
        self.scope_down_statement = input;
        self
    }
    /// Appends an item to `managed_rule_group_configs`.
    ///
    /// To override the contents of this collection use [`set_managed_rule_group_configs`](Self::set_managed_rule_group_configs).
    ///
    /// <p>Additional information that's used by a managed rule group. Many managed rule groups don't require this.</p>
    /// <p>Use the <code>AWSManagedRulesBotControlRuleSet</code> configuration object to configure the protection level that you want the Bot Control rule group to use. </p>
    pub fn managed_rule_group_configs(
        mut self,
        input: crate::types::ManagedRuleGroupConfig,
    ) -> Self {
        let mut v = self.managed_rule_group_configs.unwrap_or_default();
        v.push(input);
        self.managed_rule_group_configs = Some(v);
        self
    }
    /// <p>Additional information that's used by a managed rule group. Many managed rule groups don't require this.</p>
    /// <p>Use the <code>AWSManagedRulesBotControlRuleSet</code> configuration object to configure the protection level that you want the Bot Control rule group to use. </p>
    pub fn set_managed_rule_group_configs(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::ManagedRuleGroupConfig>>,
    ) -> Self {
        self.managed_rule_group_configs = input;
        self
    }
    /// Appends an item to `rule_action_overrides`.
    ///
    /// To override the contents of this collection use [`set_rule_action_overrides`](Self::set_rule_action_overrides).
    ///
    /// <p>Action settings to use in the place of the rule actions that are configured inside the rule group. You specify one override for each rule whose action you want to change. </p>
    /// <p>You can use overrides for testing, for example you can override all of rule actions to <code>Count</code> and then monitor the resulting count metrics to understand how the rule group would handle your web traffic. You can also permanently override some or all actions, to modify how the rule group manages your web traffic.</p>
    pub fn rule_action_overrides(mut self, input: crate::types::RuleActionOverride) -> Self {
        let mut v = self.rule_action_overrides.unwrap_or_default();
        v.push(input);
        self.rule_action_overrides = Some(v);
        self
    }
    /// <p>Action settings to use in the place of the rule actions that are configured inside the rule group. You specify one override for each rule whose action you want to change. </p>
    /// <p>You can use overrides for testing, for example you can override all of rule actions to <code>Count</code> and then monitor the resulting count metrics to understand how the rule group would handle your web traffic. You can also permanently override some or all actions, to modify how the rule group manages your web traffic.</p>
    pub fn set_rule_action_overrides(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::RuleActionOverride>>,
    ) -> Self {
        self.rule_action_overrides = input;
        self
    }
    /// Consumes the builder and constructs a [`ManagedRuleGroupStatement`](crate::types::ManagedRuleGroupStatement).
    pub fn build(self) -> crate::types::ManagedRuleGroupStatement {
        crate::types::ManagedRuleGroupStatement {
            vendor_name: self.vendor_name,
            name: self.name,
            version: self.version,
            excluded_rules: self.excluded_rules,
            scope_down_statement: self.scope_down_statement,
            managed_rule_group_configs: self.managed_rule_group_configs,
            rule_action_overrides: self.rule_action_overrides,
        }
    }
}
