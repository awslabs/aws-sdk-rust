// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Inspect the body of the web request as JSON. The body immediately follows the request headers. </p>
/// <p>This is used to indicate the web request component to inspect, in the <code>FieldToMatch</code> specification. </p>
/// <p>Use the specifications in this object to indicate which parts of the JSON body to inspect using the rule's inspection criteria. WAF inspects only the parts of the JSON that result from the matches that you indicate. </p>
/// <p>Example JSON: <code>"JsonBody": { "MatchPattern": { "All": {} }, "MatchScope": "ALL" }</code> </p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonBody {
    /// <p>The patterns to look for in the JSON body. WAF inspects the results of these pattern matches against the rule inspection criteria. </p>
    pub match_pattern: ::std::option::Option<crate::types::JsonMatchPattern>,
    /// <p>The parts of the JSON to match against using the <code>MatchPattern</code>. If you specify <code>ALL</code>, WAF matches against keys and values. </p>
    /// <p> <code>All</code> does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical <code>AND</code> statement to combine two match rules, one that inspects the keys and another that inspects the values. </p>
    pub match_scope: crate::types::JsonMatchScope,
    /// <p>What WAF should do if it fails to completely parse the JSON body. The options are the following:</p>
    /// <ul>
    /// <li> <p> <code>EVALUATE_AS_STRING</code> - Inspect the body as plain text. WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.</p> </li>
    /// <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li>
    /// <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li>
    /// </ul>
    /// <p>If you don't provide this setting, WAF parses and evaluates the content only up to the first parsing failure that it encounters. </p>
    /// <p>WAF does its best to parse the entire JSON body, but might be forced to stop for reasons such as invalid characters, duplicate keys, truncation, and any content whose root node isn't an object or an array. </p>
    /// <p>WAF parses the JSON in the following examples as two valid key, value pairs: </p>
    /// <ul>
    /// <li> <p>Missing comma: <code>{"key1":"value1""key2":"value2"}</code> </p> </li>
    /// <li> <p>Missing colon: <code>{"key1":"value1","key2""value2"}</code> </p> </li>
    /// <li> <p>Extra colons: <code>{"key1"::"value1","key2""value2"}</code> </p> </li>
    /// </ul>
    pub invalid_fallback_behavior: ::std::option::Option<crate::types::BodyParsingFallbackBehavior>,
    /// <p>What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. If the body is larger than the limit, the underlying host service only forwards the contents that are below the limit to WAF for inspection. </p>
    /// <p>The default limit is 8 KB (8,192 bytes) for regional resources and 16 KB (16,384 bytes) for CloudFront distributions. For CloudFront distributions, you can increase the limit in the web ACL <code>AssociationConfig</code>, for additional processing fees. </p>
    /// <p>The options for oversize handling are the following:</p>
    /// <ul>
    /// <li> <p> <code>CONTINUE</code> - Inspect the available body contents normally, according to the rule inspection criteria. </p> </li>
    /// <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li>
    /// <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li>
    /// </ul>
    /// <p>You can combine the <code>MATCH</code> or <code>NO_MATCH</code> settings for oversize handling with your rule and web ACL action settings, so that you block any request whose body is over the limit. </p>
    /// <p>Default: <code>CONTINUE</code> </p>
    pub oversize_handling: ::std::option::Option<crate::types::OversizeHandling>,
}
impl JsonBody {
    /// <p>The patterns to look for in the JSON body. WAF inspects the results of these pattern matches against the rule inspection criteria. </p>
    pub fn match_pattern(&self) -> ::std::option::Option<&crate::types::JsonMatchPattern> {
        self.match_pattern.as_ref()
    }
    /// <p>The parts of the JSON to match against using the <code>MatchPattern</code>. If you specify <code>ALL</code>, WAF matches against keys and values. </p>
    /// <p> <code>All</code> does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical <code>AND</code> statement to combine two match rules, one that inspects the keys and another that inspects the values. </p>
    pub fn match_scope(&self) -> &crate::types::JsonMatchScope {
        &self.match_scope
    }
    /// <p>What WAF should do if it fails to completely parse the JSON body. The options are the following:</p>
    /// <ul>
    /// <li> <p> <code>EVALUATE_AS_STRING</code> - Inspect the body as plain text. WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.</p> </li>
    /// <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li>
    /// <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li>
    /// </ul>
    /// <p>If you don't provide this setting, WAF parses and evaluates the content only up to the first parsing failure that it encounters. </p>
    /// <p>WAF does its best to parse the entire JSON body, but might be forced to stop for reasons such as invalid characters, duplicate keys, truncation, and any content whose root node isn't an object or an array. </p>
    /// <p>WAF parses the JSON in the following examples as two valid key, value pairs: </p>
    /// <ul>
    /// <li> <p>Missing comma: <code>{"key1":"value1""key2":"value2"}</code> </p> </li>
    /// <li> <p>Missing colon: <code>{"key1":"value1","key2""value2"}</code> </p> </li>
    /// <li> <p>Extra colons: <code>{"key1"::"value1","key2""value2"}</code> </p> </li>
    /// </ul>
    pub fn invalid_fallback_behavior(&self) -> ::std::option::Option<&crate::types::BodyParsingFallbackBehavior> {
        self.invalid_fallback_behavior.as_ref()
    }
    /// <p>What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. If the body is larger than the limit, the underlying host service only forwards the contents that are below the limit to WAF for inspection. </p>
    /// <p>The default limit is 8 KB (8,192 bytes) for regional resources and 16 KB (16,384 bytes) for CloudFront distributions. For CloudFront distributions, you can increase the limit in the web ACL <code>AssociationConfig</code>, for additional processing fees. </p>
    /// <p>The options for oversize handling are the following:</p>
    /// <ul>
    /// <li> <p> <code>CONTINUE</code> - Inspect the available body contents normally, according to the rule inspection criteria. </p> </li>
    /// <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li>
    /// <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li>
    /// </ul>
    /// <p>You can combine the <code>MATCH</code> or <code>NO_MATCH</code> settings for oversize handling with your rule and web ACL action settings, so that you block any request whose body is over the limit. </p>
    /// <p>Default: <code>CONTINUE</code> </p>
    pub fn oversize_handling(&self) -> ::std::option::Option<&crate::types::OversizeHandling> {
        self.oversize_handling.as_ref()
    }
}
impl JsonBody {
    /// Creates a new builder-style object to manufacture [`JsonBody`](crate::types::JsonBody).
    pub fn builder() -> crate::types::builders::JsonBodyBuilder {
        crate::types::builders::JsonBodyBuilder::default()
    }
}

/// A builder for [`JsonBody`](crate::types::JsonBody).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct JsonBodyBuilder {
    pub(crate) match_pattern: ::std::option::Option<crate::types::JsonMatchPattern>,
    pub(crate) match_scope: ::std::option::Option<crate::types::JsonMatchScope>,
    pub(crate) invalid_fallback_behavior: ::std::option::Option<crate::types::BodyParsingFallbackBehavior>,
    pub(crate) oversize_handling: ::std::option::Option<crate::types::OversizeHandling>,
}
impl JsonBodyBuilder {
    /// <p>The patterns to look for in the JSON body. WAF inspects the results of these pattern matches against the rule inspection criteria. </p>
    /// This field is required.
    pub fn match_pattern(mut self, input: crate::types::JsonMatchPattern) -> Self {
        self.match_pattern = ::std::option::Option::Some(input);
        self
    }
    /// <p>The patterns to look for in the JSON body. WAF inspects the results of these pattern matches against the rule inspection criteria. </p>
    pub fn set_match_pattern(mut self, input: ::std::option::Option<crate::types::JsonMatchPattern>) -> Self {
        self.match_pattern = input;
        self
    }
    /// <p>The patterns to look for in the JSON body. WAF inspects the results of these pattern matches against the rule inspection criteria. </p>
    pub fn get_match_pattern(&self) -> &::std::option::Option<crate::types::JsonMatchPattern> {
        &self.match_pattern
    }
    /// <p>The parts of the JSON to match against using the <code>MatchPattern</code>. If you specify <code>ALL</code>, WAF matches against keys and values. </p>
    /// <p> <code>All</code> does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical <code>AND</code> statement to combine two match rules, one that inspects the keys and another that inspects the values. </p>
    /// This field is required.
    pub fn match_scope(mut self, input: crate::types::JsonMatchScope) -> Self {
        self.match_scope = ::std::option::Option::Some(input);
        self
    }
    /// <p>The parts of the JSON to match against using the <code>MatchPattern</code>. If you specify <code>ALL</code>, WAF matches against keys and values. </p>
    /// <p> <code>All</code> does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical <code>AND</code> statement to combine two match rules, one that inspects the keys and another that inspects the values. </p>
    pub fn set_match_scope(mut self, input: ::std::option::Option<crate::types::JsonMatchScope>) -> Self {
        self.match_scope = input;
        self
    }
    /// <p>The parts of the JSON to match against using the <code>MatchPattern</code>. If you specify <code>ALL</code>, WAF matches against keys and values. </p>
    /// <p> <code>All</code> does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical <code>AND</code> statement to combine two match rules, one that inspects the keys and another that inspects the values. </p>
    pub fn get_match_scope(&self) -> &::std::option::Option<crate::types::JsonMatchScope> {
        &self.match_scope
    }
    /// <p>What WAF should do if it fails to completely parse the JSON body. The options are the following:</p>
    /// <ul>
    /// <li> <p> <code>EVALUATE_AS_STRING</code> - Inspect the body as plain text. WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.</p> </li>
    /// <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li>
    /// <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li>
    /// </ul>
    /// <p>If you don't provide this setting, WAF parses and evaluates the content only up to the first parsing failure that it encounters. </p>
    /// <p>WAF does its best to parse the entire JSON body, but might be forced to stop for reasons such as invalid characters, duplicate keys, truncation, and any content whose root node isn't an object or an array. </p>
    /// <p>WAF parses the JSON in the following examples as two valid key, value pairs: </p>
    /// <ul>
    /// <li> <p>Missing comma: <code>{"key1":"value1""key2":"value2"}</code> </p> </li>
    /// <li> <p>Missing colon: <code>{"key1":"value1","key2""value2"}</code> </p> </li>
    /// <li> <p>Extra colons: <code>{"key1"::"value1","key2""value2"}</code> </p> </li>
    /// </ul>
    pub fn invalid_fallback_behavior(mut self, input: crate::types::BodyParsingFallbackBehavior) -> Self {
        self.invalid_fallback_behavior = ::std::option::Option::Some(input);
        self
    }
    /// <p>What WAF should do if it fails to completely parse the JSON body. The options are the following:</p>
    /// <ul>
    /// <li> <p> <code>EVALUATE_AS_STRING</code> - Inspect the body as plain text. WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.</p> </li>
    /// <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li>
    /// <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li>
    /// </ul>
    /// <p>If you don't provide this setting, WAF parses and evaluates the content only up to the first parsing failure that it encounters. </p>
    /// <p>WAF does its best to parse the entire JSON body, but might be forced to stop for reasons such as invalid characters, duplicate keys, truncation, and any content whose root node isn't an object or an array. </p>
    /// <p>WAF parses the JSON in the following examples as two valid key, value pairs: </p>
    /// <ul>
    /// <li> <p>Missing comma: <code>{"key1":"value1""key2":"value2"}</code> </p> </li>
    /// <li> <p>Missing colon: <code>{"key1":"value1","key2""value2"}</code> </p> </li>
    /// <li> <p>Extra colons: <code>{"key1"::"value1","key2""value2"}</code> </p> </li>
    /// </ul>
    pub fn set_invalid_fallback_behavior(mut self, input: ::std::option::Option<crate::types::BodyParsingFallbackBehavior>) -> Self {
        self.invalid_fallback_behavior = input;
        self
    }
    /// <p>What WAF should do if it fails to completely parse the JSON body. The options are the following:</p>
    /// <ul>
    /// <li> <p> <code>EVALUATE_AS_STRING</code> - Inspect the body as plain text. WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.</p> </li>
    /// <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li>
    /// <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li>
    /// </ul>
    /// <p>If you don't provide this setting, WAF parses and evaluates the content only up to the first parsing failure that it encounters. </p>
    /// <p>WAF does its best to parse the entire JSON body, but might be forced to stop for reasons such as invalid characters, duplicate keys, truncation, and any content whose root node isn't an object or an array. </p>
    /// <p>WAF parses the JSON in the following examples as two valid key, value pairs: </p>
    /// <ul>
    /// <li> <p>Missing comma: <code>{"key1":"value1""key2":"value2"}</code> </p> </li>
    /// <li> <p>Missing colon: <code>{"key1":"value1","key2""value2"}</code> </p> </li>
    /// <li> <p>Extra colons: <code>{"key1"::"value1","key2""value2"}</code> </p> </li>
    /// </ul>
    pub fn get_invalid_fallback_behavior(&self) -> &::std::option::Option<crate::types::BodyParsingFallbackBehavior> {
        &self.invalid_fallback_behavior
    }
    /// <p>What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. If the body is larger than the limit, the underlying host service only forwards the contents that are below the limit to WAF for inspection. </p>
    /// <p>The default limit is 8 KB (8,192 bytes) for regional resources and 16 KB (16,384 bytes) for CloudFront distributions. For CloudFront distributions, you can increase the limit in the web ACL <code>AssociationConfig</code>, for additional processing fees. </p>
    /// <p>The options for oversize handling are the following:</p>
    /// <ul>
    /// <li> <p> <code>CONTINUE</code> - Inspect the available body contents normally, according to the rule inspection criteria. </p> </li>
    /// <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li>
    /// <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li>
    /// </ul>
    /// <p>You can combine the <code>MATCH</code> or <code>NO_MATCH</code> settings for oversize handling with your rule and web ACL action settings, so that you block any request whose body is over the limit. </p>
    /// <p>Default: <code>CONTINUE</code> </p>
    pub fn oversize_handling(mut self, input: crate::types::OversizeHandling) -> Self {
        self.oversize_handling = ::std::option::Option::Some(input);
        self
    }
    /// <p>What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. If the body is larger than the limit, the underlying host service only forwards the contents that are below the limit to WAF for inspection. </p>
    /// <p>The default limit is 8 KB (8,192 bytes) for regional resources and 16 KB (16,384 bytes) for CloudFront distributions. For CloudFront distributions, you can increase the limit in the web ACL <code>AssociationConfig</code>, for additional processing fees. </p>
    /// <p>The options for oversize handling are the following:</p>
    /// <ul>
    /// <li> <p> <code>CONTINUE</code> - Inspect the available body contents normally, according to the rule inspection criteria. </p> </li>
    /// <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li>
    /// <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li>
    /// </ul>
    /// <p>You can combine the <code>MATCH</code> or <code>NO_MATCH</code> settings for oversize handling with your rule and web ACL action settings, so that you block any request whose body is over the limit. </p>
    /// <p>Default: <code>CONTINUE</code> </p>
    pub fn set_oversize_handling(mut self, input: ::std::option::Option<crate::types::OversizeHandling>) -> Self {
        self.oversize_handling = input;
        self
    }
    /// <p>What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. If the body is larger than the limit, the underlying host service only forwards the contents that are below the limit to WAF for inspection. </p>
    /// <p>The default limit is 8 KB (8,192 bytes) for regional resources and 16 KB (16,384 bytes) for CloudFront distributions. For CloudFront distributions, you can increase the limit in the web ACL <code>AssociationConfig</code>, for additional processing fees. </p>
    /// <p>The options for oversize handling are the following:</p>
    /// <ul>
    /// <li> <p> <code>CONTINUE</code> - Inspect the available body contents normally, according to the rule inspection criteria. </p> </li>
    /// <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li>
    /// <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li>
    /// </ul>
    /// <p>You can combine the <code>MATCH</code> or <code>NO_MATCH</code> settings for oversize handling with your rule and web ACL action settings, so that you block any request whose body is over the limit. </p>
    /// <p>Default: <code>CONTINUE</code> </p>
    pub fn get_oversize_handling(&self) -> &::std::option::Option<crate::types::OversizeHandling> {
        &self.oversize_handling
    }
    /// Consumes the builder and constructs a [`JsonBody`](crate::types::JsonBody).
    /// This method will fail if any of the following fields are not set:
    /// - [`match_scope`](crate::types::builders::JsonBodyBuilder::match_scope)
    pub fn build(self) -> ::std::result::Result<crate::types::JsonBody, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::JsonBody {
            match_pattern: self.match_pattern,
            match_scope: self.match_scope.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "match_scope",
                    "match_scope was not specified but it is required when building JsonBody",
                )
            })?,
            invalid_fallback_behavior: self.invalid_fallback_behavior,
            oversize_handling: self.oversize_handling,
        })
    }
}
