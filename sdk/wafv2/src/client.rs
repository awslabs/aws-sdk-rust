// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn associate_web_acl(&self) -> fluent_builders::AssociateWebACL<C> {
        fluent_builders::AssociateWebACL::new(self.handle.clone())
    }
    pub fn check_capacity(&self) -> fluent_builders::CheckCapacity<C> {
        fluent_builders::CheckCapacity::new(self.handle.clone())
    }
    pub fn create_ip_set(&self) -> fluent_builders::CreateIPSet<C> {
        fluent_builders::CreateIPSet::new(self.handle.clone())
    }
    pub fn create_regex_pattern_set(&self) -> fluent_builders::CreateRegexPatternSet<C> {
        fluent_builders::CreateRegexPatternSet::new(self.handle.clone())
    }
    pub fn create_rule_group(&self) -> fluent_builders::CreateRuleGroup<C> {
        fluent_builders::CreateRuleGroup::new(self.handle.clone())
    }
    pub fn create_web_acl(&self) -> fluent_builders::CreateWebACL<C> {
        fluent_builders::CreateWebACL::new(self.handle.clone())
    }
    pub fn delete_firewall_manager_rule_groups(
        &self,
    ) -> fluent_builders::DeleteFirewallManagerRuleGroups<C> {
        fluent_builders::DeleteFirewallManagerRuleGroups::new(self.handle.clone())
    }
    pub fn delete_ip_set(&self) -> fluent_builders::DeleteIPSet<C> {
        fluent_builders::DeleteIPSet::new(self.handle.clone())
    }
    pub fn delete_logging_configuration(&self) -> fluent_builders::DeleteLoggingConfiguration<C> {
        fluent_builders::DeleteLoggingConfiguration::new(self.handle.clone())
    }
    pub fn delete_permission_policy(&self) -> fluent_builders::DeletePermissionPolicy<C> {
        fluent_builders::DeletePermissionPolicy::new(self.handle.clone())
    }
    pub fn delete_regex_pattern_set(&self) -> fluent_builders::DeleteRegexPatternSet<C> {
        fluent_builders::DeleteRegexPatternSet::new(self.handle.clone())
    }
    pub fn delete_rule_group(&self) -> fluent_builders::DeleteRuleGroup<C> {
        fluent_builders::DeleteRuleGroup::new(self.handle.clone())
    }
    pub fn delete_web_acl(&self) -> fluent_builders::DeleteWebACL<C> {
        fluent_builders::DeleteWebACL::new(self.handle.clone())
    }
    pub fn describe_managed_rule_group(&self) -> fluent_builders::DescribeManagedRuleGroup<C> {
        fluent_builders::DescribeManagedRuleGroup::new(self.handle.clone())
    }
    pub fn disassociate_web_acl(&self) -> fluent_builders::DisassociateWebACL<C> {
        fluent_builders::DisassociateWebACL::new(self.handle.clone())
    }
    pub fn get_ip_set(&self) -> fluent_builders::GetIPSet<C> {
        fluent_builders::GetIPSet::new(self.handle.clone())
    }
    pub fn get_logging_configuration(&self) -> fluent_builders::GetLoggingConfiguration<C> {
        fluent_builders::GetLoggingConfiguration::new(self.handle.clone())
    }
    pub fn get_permission_policy(&self) -> fluent_builders::GetPermissionPolicy<C> {
        fluent_builders::GetPermissionPolicy::new(self.handle.clone())
    }
    pub fn get_rate_based_statement_managed_keys(
        &self,
    ) -> fluent_builders::GetRateBasedStatementManagedKeys<C> {
        fluent_builders::GetRateBasedStatementManagedKeys::new(self.handle.clone())
    }
    pub fn get_regex_pattern_set(&self) -> fluent_builders::GetRegexPatternSet<C> {
        fluent_builders::GetRegexPatternSet::new(self.handle.clone())
    }
    pub fn get_rule_group(&self) -> fluent_builders::GetRuleGroup<C> {
        fluent_builders::GetRuleGroup::new(self.handle.clone())
    }
    pub fn get_sampled_requests(&self) -> fluent_builders::GetSampledRequests<C> {
        fluent_builders::GetSampledRequests::new(self.handle.clone())
    }
    pub fn get_web_acl(&self) -> fluent_builders::GetWebACL<C> {
        fluent_builders::GetWebACL::new(self.handle.clone())
    }
    pub fn get_web_acl_for_resource(&self) -> fluent_builders::GetWebACLForResource<C> {
        fluent_builders::GetWebACLForResource::new(self.handle.clone())
    }
    pub fn list_available_managed_rule_groups(
        &self,
    ) -> fluent_builders::ListAvailableManagedRuleGroups<C> {
        fluent_builders::ListAvailableManagedRuleGroups::new(self.handle.clone())
    }
    pub fn list_ip_sets(&self) -> fluent_builders::ListIPSets<C> {
        fluent_builders::ListIPSets::new(self.handle.clone())
    }
    pub fn list_logging_configurations(&self) -> fluent_builders::ListLoggingConfigurations<C> {
        fluent_builders::ListLoggingConfigurations::new(self.handle.clone())
    }
    pub fn list_regex_pattern_sets(&self) -> fluent_builders::ListRegexPatternSets<C> {
        fluent_builders::ListRegexPatternSets::new(self.handle.clone())
    }
    pub fn list_resources_for_web_acl(&self) -> fluent_builders::ListResourcesForWebACL<C> {
        fluent_builders::ListResourcesForWebACL::new(self.handle.clone())
    }
    pub fn list_rule_groups(&self) -> fluent_builders::ListRuleGroups<C> {
        fluent_builders::ListRuleGroups::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn list_web_ac_ls(&self) -> fluent_builders::ListWebACLs<C> {
        fluent_builders::ListWebACLs::new(self.handle.clone())
    }
    pub fn put_logging_configuration(&self) -> fluent_builders::PutLoggingConfiguration<C> {
        fluent_builders::PutLoggingConfiguration::new(self.handle.clone())
    }
    pub fn put_permission_policy(&self) -> fluent_builders::PutPermissionPolicy<C> {
        fluent_builders::PutPermissionPolicy::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_ip_set(&self) -> fluent_builders::UpdateIPSet<C> {
        fluent_builders::UpdateIPSet::new(self.handle.clone())
    }
    pub fn update_regex_pattern_set(&self) -> fluent_builders::UpdateRegexPatternSet<C> {
        fluent_builders::UpdateRegexPatternSet::new(self.handle.clone())
    }
    pub fn update_rule_group(&self) -> fluent_builders::UpdateRuleGroup<C> {
        fluent_builders::UpdateRuleGroup::new(self.handle.clone())
    }
    pub fn update_web_acl(&self) -> fluent_builders::UpdateWebACL<C> {
        fluent_builders::UpdateWebACL::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AssociateWebACL<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_web_acl_input::Builder,
    }
    impl<C> AssociateWebACL<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateWebAclOutput,
            smithy_http::result::SdkError<crate::error::AssociateWebACLError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the web ACL that you want to associate with the resource.</p>
        pub fn web_acl_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.web_acl_arn(input);
            self
        }
        pub fn set_web_acl_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_web_acl_arn(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource to associate with the web ACL. </p>
        /// <p>The ARN must be in one of the following formats:</p>
        /// <ul>
        /// <li>
        /// <p>For an Application Load Balancer: <code>arn:aws:elasticloadbalancing:<i>region</i>:<i>account-id</i>:loadbalancer/app/<i>load-balancer-name</i>/<i>load-balancer-id</i>
        /// </code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>For an Amazon API Gateway REST API: <code>arn:aws:apigateway:<i>region</i>::/restapis/<i>api-id</i>/stages/<i>stage-name</i>
        /// </code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>For an AppSync GraphQL API: <code>arn:aws:appsync:<i>region</i>:<i>account-id</i>:apis/<i>GraphQLApiId</i>
        /// </code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CheckCapacity<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::check_capacity_input::Builder,
    }
    impl<C> CheckCapacity<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CheckCapacityOutput,
            smithy_http::result::SdkError<crate::error::CheckCapacityError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
        /// <p>An array of <a>Rule</a> that you're configuring to use in a rule group or web ACL. </p>
        pub fn rules(mut self, inp: impl Into<crate::model::Rule>) -> Self {
            self.inner = self.inner.rules(inp);
            self
        }
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Rule>>,
        ) -> Self {
            self.inner = self.inner.set_rules(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateIPSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_ip_set_input::Builder,
    }
    impl<C> CreateIPSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateIpSetOutput,
            smithy_http::result::SdkError<crate::error::CreateIPSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
        /// <p>A description of the IP set that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Specify IPV4 or IPV6. </p>
        pub fn ip_address_version(mut self, input: crate::model::IpAddressVersion) -> Self {
            self.inner = self.inner.ip_address_version(input);
            self
        }
        pub fn set_ip_address_version(
            mut self,
            input: std::option::Option<crate::model::IpAddressVersion>,
        ) -> Self {
            self.inner = self.inner.set_ip_address_version(input);
            self
        }
        /// <p>Contains an array of strings that specify one or more IP addresses or blocks of IP addresses in Classless Inter-Domain Routing (CIDR) notation. WAF supports all IPv4 and IPv6 CIDR ranges except for /0. </p>
        /// <p>Examples: </p>
        /// <ul>
        /// <li>
        /// <p>To configure WAF to allow, block, or count requests that originated from the IP address 192.0.2.44, specify <code>192.0.2.44/32</code>.</p>
        /// </li>
        /// <li>
        /// <p>To configure WAF to allow, block, or count requests that originated from IP addresses from 192.0.2.0 to 192.0.2.255, specify
        /// <code>192.0.2.0/24</code>.</p>
        /// </li>
        /// <li>
        /// <p>To configure WAF to allow, block, or count requests that originated from the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify <code>1111:0000:0000:0000:0000:0000:0000:0111/128</code>.</p>
        /// </li>
        /// <li>
        /// <p>To configure WAF to allow, block, or count requests that originated from IP addresses 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify <code>1111:0000:0000:0000:0000:0000:0000:0000/64</code>.</p>
        /// </li>
        /// </ul>
        /// <p>For more information about CIDR notation, see the Wikipedia entry <a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless
        /// Inter-Domain Routing</a>.</p>
        pub fn addresses(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.addresses(inp);
            self
        }
        pub fn set_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_addresses(input);
            self
        }
        /// <p>An array of key:value pairs to associate with the resource.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateRegexPatternSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_regex_pattern_set_input::Builder,
    }
    impl<C> CreateRegexPatternSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateRegexPatternSetOutput,
            smithy_http::result::SdkError<crate::error::CreateRegexPatternSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the set. You cannot change the name after you create the set.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
        /// <p>A description of the set that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Array of regular expression strings. </p>
        pub fn regular_expression_list(mut self, inp: impl Into<crate::model::Regex>) -> Self {
            self.inner = self.inner.regular_expression_list(inp);
            self
        }
        pub fn set_regular_expression_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Regex>>,
        ) -> Self {
            self.inner = self.inner.set_regular_expression_list(input);
            self
        }
        /// <p>An array of key:value pairs to associate with the resource.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateRuleGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_rule_group_input::Builder,
    }
    impl<C> CreateRuleGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateRuleGroupOutput,
            smithy_http::result::SdkError<crate::error::CreateRuleGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
        /// <p>The web ACL capacity units (WCUs) required for this rule group.</p>
        /// <p>When you create your own rule group, you define this, and you cannot change it after creation.
        /// When you add or modify the rules in a rule group, WAF enforces this limit. You can check the capacity
        /// for a set of rules using <a>CheckCapacity</a>.</p>
        /// <p>WAF uses WCUs to calculate and control the operating
        /// resources that are used to run your rules, rule groups, and web ACLs. WAF
        /// calculates capacity differently for each rule type, to reflect the relative cost of each rule.
        /// Simple rules that cost little to run use fewer WCUs than more complex rules
        /// that use more processing power.
        /// Rule group capacity is fixed at creation, which helps users plan their  
        /// web ACL WCU usage when they use a rule group.
        /// The WCU limit for web ACLs is 1,500.  </p>
        pub fn capacity(mut self, input: i64) -> Self {
            self.inner = self.inner.capacity(input);
            self
        }
        pub fn set_capacity(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_capacity(input);
            self
        }
        /// <p>A description of the rule group that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The <a>Rule</a> statements used to identify the web requests that you
        /// want to allow, block, or count. Each rule includes one top-level statement that WAF uses to identify matching  
        /// web requests, and parameters that govern how WAF handles them.
        /// </p>
        pub fn rules(mut self, inp: impl Into<crate::model::Rule>) -> Self {
            self.inner = self.inner.rules(inp);
            self
        }
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Rule>>,
        ) -> Self {
            self.inner = self.inner.set_rules(input);
            self
        }
        /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection.  </p>
        pub fn visibility_config(mut self, input: crate::model::VisibilityConfig) -> Self {
            self.inner = self.inner.visibility_config(input);
            self
        }
        pub fn set_visibility_config(
            mut self,
            input: std::option::Option<crate::model::VisibilityConfig>,
        ) -> Self {
            self.inner = self.inner.set_visibility_config(input);
            self
        }
        /// <p>An array of key:value pairs to associate with the resource.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>A map of custom response keys and content bodies. When you create a rule with a block action, you can send a custom response to the web request. You define these for the rule group, and then use them in the rules that you define in the rule group. </p>
        /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the
        /// <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the
        /// <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        pub fn custom_response_bodies(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::CustomResponseBody>,
        ) -> Self {
            self.inner = self.inner.custom_response_bodies(k, v);
            self
        }
        pub fn set_custom_response_bodies(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::CustomResponseBody>,
            >,
        ) -> Self {
            self.inner = self.inner.set_custom_response_bodies(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateWebACL<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_web_acl_input::Builder,
    }
    impl<C> CreateWebACL<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateWebAclOutput,
            smithy_http::result::SdkError<crate::error::CreateWebACLError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the web ACL. You cannot change the name of a web ACL after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
        /// <p>The action to perform if none of the <code>Rules</code> contained in the <code>WebACL</code> match. </p>
        pub fn default_action(mut self, input: crate::model::DefaultAction) -> Self {
            self.inner = self.inner.default_action(input);
            self
        }
        pub fn set_default_action(
            mut self,
            input: std::option::Option<crate::model::DefaultAction>,
        ) -> Self {
            self.inner = self.inner.set_default_action(input);
            self
        }
        /// <p>A description of the web ACL that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The <a>Rule</a> statements used to identify the web requests that you
        /// want to allow, block, or count. Each rule includes one top-level statement that WAF uses to identify matching  
        /// web requests, and parameters that govern how WAF handles them.
        /// </p>
        pub fn rules(mut self, inp: impl Into<crate::model::Rule>) -> Self {
            self.inner = self.inner.rules(inp);
            self
        }
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Rule>>,
        ) -> Self {
            self.inner = self.inner.set_rules(input);
            self
        }
        /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection.  </p>
        pub fn visibility_config(mut self, input: crate::model::VisibilityConfig) -> Self {
            self.inner = self.inner.visibility_config(input);
            self
        }
        pub fn set_visibility_config(
            mut self,
            input: std::option::Option<crate::model::VisibilityConfig>,
        ) -> Self {
            self.inner = self.inner.set_visibility_config(input);
            self
        }
        /// <p>An array of key:value pairs to associate with the resource.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>A map of custom response keys and content bodies. When you create a rule with a block action, you can send a custom response to the web request. You define these for the web ACL, and then use them in the rules and default actions that you define in the web ACL. </p>
        /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the
        /// <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the
        /// <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        pub fn custom_response_bodies(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::CustomResponseBody>,
        ) -> Self {
            self.inner = self.inner.custom_response_bodies(k, v);
            self
        }
        pub fn set_custom_response_bodies(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::CustomResponseBody>,
            >,
        ) -> Self {
            self.inner = self.inner.set_custom_response_bodies(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFirewallManagerRuleGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_firewall_manager_rule_groups_input::Builder,
    }
    impl<C> DeleteFirewallManagerRuleGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFirewallManagerRuleGroupsOutput,
            smithy_http::result::SdkError<crate::error::DeleteFirewallManagerRuleGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the web ACL.</p>
        pub fn web_acl_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.web_acl_arn(input);
            self
        }
        pub fn set_web_acl_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_web_acl_arn(input);
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
        pub fn web_acl_lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.web_acl_lock_token(input);
            self
        }
        pub fn set_web_acl_lock_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_web_acl_lock_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteIPSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_ip_set_input::Builder,
    }
    impl<C> DeleteIPSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteIpSetOutput,
            smithy_http::result::SdkError<crate::error::DeleteIPSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
        /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.lock_token(input);
            self
        }
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_lock_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLoggingConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_logging_configuration_input::Builder,
    }
    impl<C> DeleteLoggingConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLoggingConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DeleteLoggingConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the web ACL from which you want to delete the <a>LoggingConfiguration</a>.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeletePermissionPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_permission_policy_input::Builder,
    }
    impl<C> DeletePermissionPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeletePermissionPolicyOutput,
            smithy_http::result::SdkError<crate::error::DeletePermissionPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the rule group from which you want to delete the policy.</p>
        /// <p>You must be the owner of the rule group to perform this operation.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRegexPatternSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_regex_pattern_set_input::Builder,
    }
    impl<C> DeleteRegexPatternSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteRegexPatternSetOutput,
            smithy_http::result::SdkError<crate::error::DeleteRegexPatternSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the set. You cannot change the name after you create the set.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
        /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.lock_token(input);
            self
        }
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_lock_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRuleGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_rule_group_input::Builder,
    }
    impl<C> DeleteRuleGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteRuleGroupOutput,
            smithy_http::result::SdkError<crate::error::DeleteRuleGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
        /// <p>A unique identifier for the rule group. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.lock_token(input);
            self
        }
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_lock_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteWebACL<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_web_acl_input::Builder,
    }
    impl<C> DeleteWebACL<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteWebAclOutput,
            smithy_http::result::SdkError<crate::error::DeleteWebACLError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the web ACL. You cannot change the name of a web ACL after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
        /// <p>The unique identifier for the web ACL. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.lock_token(input);
            self
        }
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_lock_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeManagedRuleGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_managed_rule_group_input::Builder,
    }
    impl<C> DescribeManagedRuleGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeManagedRuleGroupOutput,
            smithy_http::result::SdkError<crate::error::DescribeManagedRuleGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the managed rule group vendor. You use this, along with the rule group name, to identify the rule group.</p>
        pub fn vendor_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vendor_name(input);
            self
        }
        pub fn set_vendor_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vendor_name(input);
            self
        }
        /// <p>The name of the managed rule group. You use this, along with the vendor name, to identify the rule group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateWebACL<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disassociate_web_acl_input::Builder,
    }
    impl<C> DisassociateWebACL<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateWebAclOutput,
            smithy_http::result::SdkError<crate::error::DisassociateWebACLError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource to disassociate from the web ACL. </p>
        /// <p>The ARN must be in one of the following formats:</p>
        /// <ul>
        /// <li>
        /// <p>For an Application Load Balancer: <code>arn:aws:elasticloadbalancing:<i>region</i>:<i>account-id</i>:loadbalancer/app/<i>load-balancer-name</i>/<i>load-balancer-id</i>
        /// </code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>For an Amazon API Gateway REST API: <code>arn:aws:apigateway:<i>region</i>::/restapis/<i>api-id</i>/stages/<i>stage-name</i>
        /// </code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>For an AppSync GraphQL API: <code>arn:aws:appsync:<i>region</i>:<i>account-id</i>:apis/<i>GraphQLApiId</i>
        /// </code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetIPSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_ip_set_input::Builder,
    }
    impl<C> GetIPSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetIpSetOutput,
            smithy_http::result::SdkError<crate::error::GetIPSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
        /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLoggingConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_logging_configuration_input::Builder,
    }
    impl<C> GetLoggingConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLoggingConfigurationOutput,
            smithy_http::result::SdkError<crate::error::GetLoggingConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the web ACL for which you want to get the <a>LoggingConfiguration</a>.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPermissionPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_permission_policy_input::Builder,
    }
    impl<C> GetPermissionPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPermissionPolicyOutput,
            smithy_http::result::SdkError<crate::error::GetPermissionPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the rule group for which you want to get the policy.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRateBasedStatementManagedKeys<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_rate_based_statement_managed_keys_input::Builder,
    }
    impl<C> GetRateBasedStatementManagedKeys<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRateBasedStatementManagedKeysOutput,
            smithy_http::result::SdkError<crate::error::GetRateBasedStatementManagedKeysError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
        /// <p>The name of the web ACL. You cannot change the name of a web ACL after you create it.</p>
        pub fn web_acl_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.web_acl_name(input);
            self
        }
        pub fn set_web_acl_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_web_acl_name(input);
            self
        }
        /// <p>The unique identifier for the web ACL. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn web_acl_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.web_acl_id(input);
            self
        }
        pub fn set_web_acl_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_web_acl_id(input);
            self
        }
        /// <p>The name of the rate-based rule to get the keys for.</p>
        pub fn rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_name(input);
            self
        }
        pub fn set_rule_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_rule_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRegexPatternSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_regex_pattern_set_input::Builder,
    }
    impl<C> GetRegexPatternSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRegexPatternSetOutput,
            smithy_http::result::SdkError<crate::error::GetRegexPatternSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the set. You cannot change the name after you create the set.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
        /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRuleGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_rule_group_input::Builder,
    }
    impl<C> GetRuleGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRuleGroupOutput,
            smithy_http::result::SdkError<crate::error::GetRuleGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
        /// <p>A unique identifier for the rule group. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entity.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSampledRequests<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_sampled_requests_input::Builder,
    }
    impl<C> GetSampledRequests<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSampledRequestsOutput,
            smithy_http::result::SdkError<crate::error::GetSampledRequestsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon resource name (ARN) of the <code>WebACL</code> for which you want a sample of requests.</p>
        pub fn web_acl_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.web_acl_arn(input);
            self
        }
        pub fn set_web_acl_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_web_acl_arn(input);
            self
        }
        /// <p>The metric name assigned to the <code>Rule</code> or <code>RuleGroup</code> for which you want a sample of requests.</p>
        pub fn rule_metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_metric_name(input);
            self
        }
        pub fn set_rule_metric_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rule_metric_name(input);
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
        /// <p>The start date and time and the end date and time of the range for which you want <code>GetSampledRequests</code> to return a
        /// sample of requests. You must specify the times in Coordinated Universal Time (UTC) format. UTC format includes the special designator, <code>Z</code>. For example, <code>"2016-09-27T14:50Z"</code>. You can specify any time range in the previous three hours. If you specify a start time that's earlier than three hours ago, WAF sets it to three hours ago.</p>
        pub fn time_window(mut self, input: crate::model::TimeWindow) -> Self {
            self.inner = self.inner.time_window(input);
            self
        }
        pub fn set_time_window(
            mut self,
            input: std::option::Option<crate::model::TimeWindow>,
        ) -> Self {
            self.inner = self.inner.set_time_window(input);
            self
        }
        /// <p>The number of requests that you want WAF to return from among the first 5,000 requests that your Amazon Web Services resource received
        /// during the time range. If your resource received fewer requests than the value of <code>MaxItems</code>, <code>GetSampledRequests</code>
        /// returns information about all of them. </p>
        pub fn max_items(mut self, input: i64) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetWebACL<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_web_acl_input::Builder,
    }
    impl<C> GetWebACL<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetWebAclOutput,
            smithy_http::result::SdkError<crate::error::GetWebACLError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the web ACL. You cannot change the name of a web ACL after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
        /// <p>The unique identifier for the web ACL. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetWebACLForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_web_acl_for_resource_input::Builder,
    }
    impl<C> GetWebACLForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetWebAclForResourceOutput,
            smithy_http::result::SdkError<crate::error::GetWebACLForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN (Amazon Resource Name) of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAvailableManagedRuleGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_available_managed_rule_groups_input::Builder,
    }
    impl<C> ListAvailableManagedRuleGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListAvailableManagedRuleGroupsOutput,
            smithy_http::result::SdkError<crate::error::ListAvailableManagedRuleGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
        /// for retrieval exceeds the limit, WAF returns a <code>NextMarker</code>
        /// value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn next_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_marker(input);
            self
        }
        pub fn set_next_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_marker(input);
            self
        }
        /// <p>The maximum number of objects that you want WAF to return for this request. If more
        /// objects are available, in the response, WAF provides a
        /// <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListIPSets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_ip_sets_input::Builder,
    }
    impl<C> ListIPSets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListIpSetsOutput,
            smithy_http::result::SdkError<crate::error::ListIPSetsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
        /// for retrieval exceeds the limit, WAF returns a <code>NextMarker</code>
        /// value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn next_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_marker(input);
            self
        }
        pub fn set_next_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_marker(input);
            self
        }
        /// <p>The maximum number of objects that you want WAF to return for this request. If more
        /// objects are available, in the response, WAF provides a
        /// <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListLoggingConfigurations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_logging_configurations_input::Builder,
    }
    impl<C> ListLoggingConfigurations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListLoggingConfigurationsOutput,
            smithy_http::result::SdkError<crate::error::ListLoggingConfigurationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
        /// for retrieval exceeds the limit, WAF returns a <code>NextMarker</code>
        /// value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn next_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_marker(input);
            self
        }
        pub fn set_next_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_marker(input);
            self
        }
        /// <p>The maximum number of objects that you want WAF to return for this request. If more
        /// objects are available, in the response, WAF provides a
        /// <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListRegexPatternSets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_regex_pattern_sets_input::Builder,
    }
    impl<C> ListRegexPatternSets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListRegexPatternSetsOutput,
            smithy_http::result::SdkError<crate::error::ListRegexPatternSetsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
        /// for retrieval exceeds the limit, WAF returns a <code>NextMarker</code>
        /// value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn next_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_marker(input);
            self
        }
        pub fn set_next_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_marker(input);
            self
        }
        /// <p>The maximum number of objects that you want WAF to return for this request. If more
        /// objects are available, in the response, WAF provides a
        /// <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListResourcesForWebACL<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_resources_for_web_acl_input::Builder,
    }
    impl<C> ListResourcesForWebACL<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListResourcesForWebAclOutput,
            smithy_http::result::SdkError<crate::error::ListResourcesForWebACLError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the web ACL.</p>
        pub fn web_acl_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.web_acl_arn(input);
            self
        }
        pub fn set_web_acl_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_web_acl_arn(input);
            self
        }
        /// <p>Used for web ACLs that are scoped for regional applications. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API. </p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.inner = self.inner.resource_type(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.inner = self.inner.set_resource_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListRuleGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_rule_groups_input::Builder,
    }
    impl<C> ListRuleGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListRuleGroupsOutput,
            smithy_http::result::SdkError<crate::error::ListRuleGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
        /// for retrieval exceeds the limit, WAF returns a <code>NextMarker</code>
        /// value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn next_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_marker(input);
            self
        }
        pub fn set_next_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_marker(input);
            self
        }
        /// <p>The maximum number of objects that you want WAF to return for this request. If more
        /// objects are available, in the response, WAF provides a
        /// <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
        /// for retrieval exceeds the limit, WAF returns a <code>NextMarker</code>
        /// value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn next_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_marker(input);
            self
        }
        pub fn set_next_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_marker(input);
            self
        }
        /// <p>The maximum number of objects that you want WAF to return for this request. If more
        /// objects are available, in the response, WAF provides a
        /// <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListWebACLs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_web_ac_ls_input::Builder,
    }
    impl<C> ListWebACLs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListWebAcLsOutput,
            smithy_http::result::SdkError<crate::error::ListWebACLsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
        /// for retrieval exceeds the limit, WAF returns a <code>NextMarker</code>
        /// value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn next_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_marker(input);
            self
        }
        pub fn set_next_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_marker(input);
            self
        }
        /// <p>The maximum number of objects that you want WAF to return for this request. If more
        /// objects are available, in the response, WAF provides a
        /// <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutLoggingConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_logging_configuration_input::Builder,
    }
    impl<C> PutLoggingConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutLoggingConfigurationOutput,
            smithy_http::result::SdkError<crate::error::PutLoggingConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p></p>
        pub fn logging_configuration(mut self, input: crate::model::LoggingConfiguration) -> Self {
            self.inner = self.inner.logging_configuration(input);
            self
        }
        pub fn set_logging_configuration(
            mut self,
            input: std::option::Option<crate::model::LoggingConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_logging_configuration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutPermissionPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_permission_policy_input::Builder,
    }
    impl<C> PutPermissionPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutPermissionPolicyOutput,
            smithy_http::result::SdkError<crate::error::PutPermissionPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the <a>RuleGroup</a> to which you want to attach the policy.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The policy to attach to the specified rule group. </p>
        /// <p>The policy specifications must conform to the following:</p>
        /// <ul>
        /// <li>
        /// <p>The policy must be composed using IAM Policy version 2012-10-17 or version 2015-01-01.</p>
        /// </li>
        /// <li>
        /// <p>The policy must include specifications for <code>Effect</code>, <code>Action</code>, and <code>Principal</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Effect</code> must specify <code>Allow</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Action</code> must specify <code>wafv2:CreateWebACL</code>, <code>wafv2:UpdateWebACL</code>, and <code>wafv2:PutFirewallManagerRuleGroups</code>. WAF rejects any extra actions or wildcard actions in the policy.</p>
        /// </li>
        /// <li>
        /// <p>The policy must not include a <code>Resource</code> parameter.</p>
        /// </li>
        /// </ul>     
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html">IAM Policies</a>.  </p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(input);
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>An array of key:value pairs to associate with the resource.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>An array of keys identifying the tags to disassociate from the resource.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateIPSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_ip_set_input::Builder,
    }
    impl<C> UpdateIPSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateIpSetOutput,
            smithy_http::result::SdkError<crate::error::UpdateIPSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
        /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>A description of the IP set that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Contains an array of strings that specify one or more IP addresses or blocks of IP addresses in Classless Inter-Domain Routing (CIDR) notation. WAF supports all IPv4 and IPv6 CIDR ranges except for /0. </p>
        /// <p>Examples: </p>
        /// <ul>
        /// <li>
        /// <p>To configure WAF to allow, block, or count requests that originated from the IP address 192.0.2.44, specify <code>192.0.2.44/32</code>.</p>
        /// </li>
        /// <li>
        /// <p>To configure WAF to allow, block, or count requests that originated from IP addresses from 192.0.2.0 to 192.0.2.255, specify
        /// <code>192.0.2.0/24</code>.</p>
        /// </li>
        /// <li>
        /// <p>To configure WAF to allow, block, or count requests that originated from the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify <code>1111:0000:0000:0000:0000:0000:0000:0111/128</code>.</p>
        /// </li>
        /// <li>
        /// <p>To configure WAF to allow, block, or count requests that originated from IP addresses 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify <code>1111:0000:0000:0000:0000:0000:0000:0000/64</code>.</p>
        /// </li>
        /// </ul>
        /// <p>For more information about CIDR notation, see the Wikipedia entry <a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless
        /// Inter-Domain Routing</a>.</p>
        pub fn addresses(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.addresses(inp);
            self
        }
        pub fn set_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_addresses(input);
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.lock_token(input);
            self
        }
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_lock_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateRegexPatternSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_regex_pattern_set_input::Builder,
    }
    impl<C> UpdateRegexPatternSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateRegexPatternSetOutput,
            smithy_http::result::SdkError<crate::error::UpdateRegexPatternSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the set. You cannot change the name after you create the set.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
        /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>A description of the set that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p></p>
        pub fn regular_expression_list(mut self, inp: impl Into<crate::model::Regex>) -> Self {
            self.inner = self.inner.regular_expression_list(inp);
            self
        }
        pub fn set_regular_expression_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Regex>>,
        ) -> Self {
            self.inner = self.inner.set_regular_expression_list(input);
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.lock_token(input);
            self
        }
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_lock_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateRuleGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_rule_group_input::Builder,
    }
    impl<C> UpdateRuleGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateRuleGroupOutput,
            smithy_http::result::SdkError<crate::error::UpdateRuleGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
        /// <p>A unique identifier for the rule group. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>A description of the rule group that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The <a>Rule</a> statements used to identify the web requests that you
        /// want to allow, block, or count. Each rule includes one top-level statement that WAF uses to identify matching  
        /// web requests, and parameters that govern how WAF handles them.
        /// </p>
        pub fn rules(mut self, inp: impl Into<crate::model::Rule>) -> Self {
            self.inner = self.inner.rules(inp);
            self
        }
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Rule>>,
        ) -> Self {
            self.inner = self.inner.set_rules(input);
            self
        }
        /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection.  </p>
        pub fn visibility_config(mut self, input: crate::model::VisibilityConfig) -> Self {
            self.inner = self.inner.visibility_config(input);
            self
        }
        pub fn set_visibility_config(
            mut self,
            input: std::option::Option<crate::model::VisibilityConfig>,
        ) -> Self {
            self.inner = self.inner.set_visibility_config(input);
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.lock_token(input);
            self
        }
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_lock_token(input);
            self
        }
        /// <p>A map of custom response keys and content bodies. When you create a rule with a block action, you can send a custom response to the web request. You define these for the rule group, and then use them in the rules that you define in the rule group. </p>
        /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the
        /// <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the
        /// <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        pub fn custom_response_bodies(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::CustomResponseBody>,
        ) -> Self {
            self.inner = self.inner.custom_response_bodies(k, v);
            self
        }
        pub fn set_custom_response_bodies(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::CustomResponseBody>,
            >,
        ) -> Self {
            self.inner = self.inner.set_custom_response_bodies(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateWebACL<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_web_acl_input::Builder,
    }
    impl<C> UpdateWebACL<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateWebAclOutput,
            smithy_http::result::SdkError<crate::error::UpdateWebACLError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the web ACL. You cannot change the name of a web ACL after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.inner = self.inner.scope(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.inner = self.inner.set_scope(input);
            self
        }
        /// <p>The unique identifier for the web ACL. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The action to perform if none of the <code>Rules</code> contained in the <code>WebACL</code> match. </p>
        pub fn default_action(mut self, input: crate::model::DefaultAction) -> Self {
            self.inner = self.inner.default_action(input);
            self
        }
        pub fn set_default_action(
            mut self,
            input: std::option::Option<crate::model::DefaultAction>,
        ) -> Self {
            self.inner = self.inner.set_default_action(input);
            self
        }
        /// <p>A description of the web ACL that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The <a>Rule</a> statements used to identify the web requests that you
        /// want to allow, block, or count. Each rule includes one top-level statement that WAF uses to identify matching  
        /// web requests, and parameters that govern how WAF handles them.
        /// </p>
        pub fn rules(mut self, inp: impl Into<crate::model::Rule>) -> Self {
            self.inner = self.inner.rules(inp);
            self
        }
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Rule>>,
        ) -> Self {
            self.inner = self.inner.set_rules(input);
            self
        }
        /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection.  </p>
        pub fn visibility_config(mut self, input: crate::model::VisibilityConfig) -> Self {
            self.inner = self.inner.visibility_config(input);
            self
        }
        pub fn set_visibility_config(
            mut self,
            input: std::option::Option<crate::model::VisibilityConfig>,
        ) -> Self {
            self.inner = self.inner.set_visibility_config(input);
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.lock_token(input);
            self
        }
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_lock_token(input);
            self
        }
        /// <p>A map of custom response keys and content bodies. When you create a rule with a block action, you can send a custom response to the web request. You define these for the web ACL, and then use them in the rules and default actions that you define in the web ACL. </p>
        /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the
        /// <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the
        /// <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        pub fn custom_response_bodies(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::CustomResponseBody>,
        ) -> Self {
            self.inner = self.inner.custom_response_bodies(k, v);
            self
        }
        pub fn set_custom_response_bodies(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::CustomResponseBody>,
            >,
        ) -> Self {
            self.inner = self.inner.set_custom_response_bodies(input);
            self
        }
    }
}
