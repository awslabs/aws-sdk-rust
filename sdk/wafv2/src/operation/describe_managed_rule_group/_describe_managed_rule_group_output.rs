// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeManagedRuleGroupOutput {
    /// <p>The managed rule group's version. </p>
    #[doc(hidden)]
    pub version_name: std::option::Option<std::string::String>,
    /// <p>The Amazon resource name (ARN) of the Amazon Simple Notification Service SNS topic that's used to record changes to the managed rule group. You can subscribe to the SNS topic to receive notifications when the managed rule group is modified, such as for new versions and for version expiration. For more information, see the <a href="https://docs.aws.amazon.com/sns/latest/dg/welcome.html">Amazon Simple Notification Service Developer Guide</a>.</p>
    #[doc(hidden)]
    pub sns_topic_arn: std::option::Option<std::string::String>,
    /// <p>The web ACL capacity units (WCUs) required for this rule group. WAF uses web ACL capacity units (WCU) to calculate and control the operating resources that are used to run your rules, rule groups, and web ACLs. WAF calculates capacity differently for each rule type, to reflect each rule's relative cost. Rule group capacity is fixed at creation, so users can plan their web ACL WCU usage when they use a rule group. The WCU limit for web ACLs is 1,500. </p>
    #[doc(hidden)]
    pub capacity: i64,
    /// <p></p>
    #[doc(hidden)]
    pub rules: std::option::Option<std::vec::Vec<crate::types::RuleSummary>>,
    /// <p>The label namespace prefix for this rule group. All labels added by rules in this rule group have this prefix. </p>
    /// <ul>
    /// <li> <p>The syntax for the label namespace prefix for a managed rule group is the following: </p> <p> <code>awswaf:managed:
    /// <vendor>
    /// :
    /// <rule group name></rule>
    /// </vendor></code>:</p> </li>
    /// <li> <p>When a rule with a label matches a web request, WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p> <p> <code><label namespace>:<label from rule></label></label></code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub label_namespace: std::option::Option<std::string::String>,
    /// <p>The labels that one or more rules in this rule group add to matching web requests. These labels are defined in the <code>RuleLabels</code> for a <code>Rule</code>.</p>
    #[doc(hidden)]
    pub available_labels: std::option::Option<std::vec::Vec<crate::types::LabelSummary>>,
    /// <p>The labels that one or more rules in this rule group match against in label match statements. These labels are defined in a <code>LabelMatchStatement</code> specification, in the <code>Statement</code> definition of a rule. </p>
    #[doc(hidden)]
    pub consumed_labels: std::option::Option<std::vec::Vec<crate::types::LabelSummary>>,
    _request_id: Option<String>,
}
impl DescribeManagedRuleGroupOutput {
    /// <p>The managed rule group's version. </p>
    pub fn version_name(&self) -> std::option::Option<&str> {
        self.version_name.as_deref()
    }
    /// <p>The Amazon resource name (ARN) of the Amazon Simple Notification Service SNS topic that's used to record changes to the managed rule group. You can subscribe to the SNS topic to receive notifications when the managed rule group is modified, such as for new versions and for version expiration. For more information, see the <a href="https://docs.aws.amazon.com/sns/latest/dg/welcome.html">Amazon Simple Notification Service Developer Guide</a>.</p>
    pub fn sns_topic_arn(&self) -> std::option::Option<&str> {
        self.sns_topic_arn.as_deref()
    }
    /// <p>The web ACL capacity units (WCUs) required for this rule group. WAF uses web ACL capacity units (WCU) to calculate and control the operating resources that are used to run your rules, rule groups, and web ACLs. WAF calculates capacity differently for each rule type, to reflect each rule's relative cost. Rule group capacity is fixed at creation, so users can plan their web ACL WCU usage when they use a rule group. The WCU limit for web ACLs is 1,500. </p>
    pub fn capacity(&self) -> i64 {
        self.capacity
    }
    /// <p></p>
    pub fn rules(&self) -> std::option::Option<&[crate::types::RuleSummary]> {
        self.rules.as_deref()
    }
    /// <p>The label namespace prefix for this rule group. All labels added by rules in this rule group have this prefix. </p>
    /// <ul>
    /// <li> <p>The syntax for the label namespace prefix for a managed rule group is the following: </p> <p> <code>awswaf:managed:
    /// <vendor>
    /// :
    /// <rule group name></rule>
    /// </vendor></code>:</p> </li>
    /// <li> <p>When a rule with a label matches a web request, WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p> <p> <code><label namespace>:<label from rule></label></label></code> </p> </li>
    /// </ul>
    pub fn label_namespace(&self) -> std::option::Option<&str> {
        self.label_namespace.as_deref()
    }
    /// <p>The labels that one or more rules in this rule group add to matching web requests. These labels are defined in the <code>RuleLabels</code> for a <code>Rule</code>.</p>
    pub fn available_labels(&self) -> std::option::Option<&[crate::types::LabelSummary]> {
        self.available_labels.as_deref()
    }
    /// <p>The labels that one or more rules in this rule group match against in label match statements. These labels are defined in a <code>LabelMatchStatement</code> specification, in the <code>Statement</code> definition of a rule. </p>
    pub fn consumed_labels(&self) -> std::option::Option<&[crate::types::LabelSummary]> {
        self.consumed_labels.as_deref()
    }
}
impl aws_http::request_id::RequestId for DescribeManagedRuleGroupOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl DescribeManagedRuleGroupOutput {
    /// Creates a new builder-style object to manufacture [`DescribeManagedRuleGroupOutput`](crate::operation::describe_managed_rule_group::DescribeManagedRuleGroupOutput).
    pub fn builder() -> crate::operation::describe_managed_rule_group::builders::DescribeManagedRuleGroupOutputBuilder{
        crate::operation::describe_managed_rule_group::builders::DescribeManagedRuleGroupOutputBuilder::default()
    }
}

/// A builder for [`DescribeManagedRuleGroupOutput`](crate::operation::describe_managed_rule_group::DescribeManagedRuleGroupOutput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct DescribeManagedRuleGroupOutputBuilder {
    pub(crate) version_name: std::option::Option<std::string::String>,
    pub(crate) sns_topic_arn: std::option::Option<std::string::String>,
    pub(crate) capacity: std::option::Option<i64>,
    pub(crate) rules: std::option::Option<std::vec::Vec<crate::types::RuleSummary>>,
    pub(crate) label_namespace: std::option::Option<std::string::String>,
    pub(crate) available_labels: std::option::Option<std::vec::Vec<crate::types::LabelSummary>>,
    pub(crate) consumed_labels: std::option::Option<std::vec::Vec<crate::types::LabelSummary>>,
    _request_id: Option<String>,
}
impl DescribeManagedRuleGroupOutputBuilder {
    /// <p>The managed rule group's version. </p>
    pub fn version_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.version_name = Some(input.into());
        self
    }
    /// <p>The managed rule group's version. </p>
    pub fn set_version_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.version_name = input;
        self
    }
    /// <p>The Amazon resource name (ARN) of the Amazon Simple Notification Service SNS topic that's used to record changes to the managed rule group. You can subscribe to the SNS topic to receive notifications when the managed rule group is modified, such as for new versions and for version expiration. For more information, see the <a href="https://docs.aws.amazon.com/sns/latest/dg/welcome.html">Amazon Simple Notification Service Developer Guide</a>.</p>
    pub fn sns_topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.sns_topic_arn = Some(input.into());
        self
    }
    /// <p>The Amazon resource name (ARN) of the Amazon Simple Notification Service SNS topic that's used to record changes to the managed rule group. You can subscribe to the SNS topic to receive notifications when the managed rule group is modified, such as for new versions and for version expiration. For more information, see the <a href="https://docs.aws.amazon.com/sns/latest/dg/welcome.html">Amazon Simple Notification Service Developer Guide</a>.</p>
    pub fn set_sns_topic_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.sns_topic_arn = input;
        self
    }
    /// <p>The web ACL capacity units (WCUs) required for this rule group. WAF uses web ACL capacity units (WCU) to calculate and control the operating resources that are used to run your rules, rule groups, and web ACLs. WAF calculates capacity differently for each rule type, to reflect each rule's relative cost. Rule group capacity is fixed at creation, so users can plan their web ACL WCU usage when they use a rule group. The WCU limit for web ACLs is 1,500. </p>
    pub fn capacity(mut self, input: i64) -> Self {
        self.capacity = Some(input);
        self
    }
    /// <p>The web ACL capacity units (WCUs) required for this rule group. WAF uses web ACL capacity units (WCU) to calculate and control the operating resources that are used to run your rules, rule groups, and web ACLs. WAF calculates capacity differently for each rule type, to reflect each rule's relative cost. Rule group capacity is fixed at creation, so users can plan their web ACL WCU usage when they use a rule group. The WCU limit for web ACLs is 1,500. </p>
    pub fn set_capacity(mut self, input: std::option::Option<i64>) -> Self {
        self.capacity = input;
        self
    }
    /// Appends an item to `rules`.
    ///
    /// To override the contents of this collection use [`set_rules`](Self::set_rules).
    ///
    /// <p></p>
    pub fn rules(mut self, input: crate::types::RuleSummary) -> Self {
        let mut v = self.rules.unwrap_or_default();
        v.push(input);
        self.rules = Some(v);
        self
    }
    /// <p></p>
    pub fn set_rules(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::RuleSummary>>,
    ) -> Self {
        self.rules = input;
        self
    }
    /// <p>The label namespace prefix for this rule group. All labels added by rules in this rule group have this prefix. </p>
    /// <ul>
    /// <li> <p>The syntax for the label namespace prefix for a managed rule group is the following: </p> <p> <code>awswaf:managed:
    /// <vendor>
    /// :
    /// <rule group name></rule>
    /// </vendor></code>:</p> </li>
    /// <li> <p>When a rule with a label matches a web request, WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p> <p> <code><label namespace>:<label from rule></label></label></code> </p> </li>
    /// </ul>
    pub fn label_namespace(mut self, input: impl Into<std::string::String>) -> Self {
        self.label_namespace = Some(input.into());
        self
    }
    /// <p>The label namespace prefix for this rule group. All labels added by rules in this rule group have this prefix. </p>
    /// <ul>
    /// <li> <p>The syntax for the label namespace prefix for a managed rule group is the following: </p> <p> <code>awswaf:managed:
    /// <vendor>
    /// :
    /// <rule group name></rule>
    /// </vendor></code>:</p> </li>
    /// <li> <p>When a rule with a label matches a web request, WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p> <p> <code><label namespace>:<label from rule></label></label></code> </p> </li>
    /// </ul>
    pub fn set_label_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.label_namespace = input;
        self
    }
    /// Appends an item to `available_labels`.
    ///
    /// To override the contents of this collection use [`set_available_labels`](Self::set_available_labels).
    ///
    /// <p>The labels that one or more rules in this rule group add to matching web requests. These labels are defined in the <code>RuleLabels</code> for a <code>Rule</code>.</p>
    pub fn available_labels(mut self, input: crate::types::LabelSummary) -> Self {
        let mut v = self.available_labels.unwrap_or_default();
        v.push(input);
        self.available_labels = Some(v);
        self
    }
    /// <p>The labels that one or more rules in this rule group add to matching web requests. These labels are defined in the <code>RuleLabels</code> for a <code>Rule</code>.</p>
    pub fn set_available_labels(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::LabelSummary>>,
    ) -> Self {
        self.available_labels = input;
        self
    }
    /// Appends an item to `consumed_labels`.
    ///
    /// To override the contents of this collection use [`set_consumed_labels`](Self::set_consumed_labels).
    ///
    /// <p>The labels that one or more rules in this rule group match against in label match statements. These labels are defined in a <code>LabelMatchStatement</code> specification, in the <code>Statement</code> definition of a rule. </p>
    pub fn consumed_labels(mut self, input: crate::types::LabelSummary) -> Self {
        let mut v = self.consumed_labels.unwrap_or_default();
        v.push(input);
        self.consumed_labels = Some(v);
        self
    }
    /// <p>The labels that one or more rules in this rule group match against in label match statements. These labels are defined in a <code>LabelMatchStatement</code> specification, in the <code>Statement</code> definition of a rule. </p>
    pub fn set_consumed_labels(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::LabelSummary>>,
    ) -> Self {
        self.consumed_labels = input;
        self
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
        self._request_id = Some(request_id.into());
        self
    }

    pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
        self._request_id = request_id;
        self
    }
    /// Consumes the builder and constructs a [`DescribeManagedRuleGroupOutput`](crate::operation::describe_managed_rule_group::DescribeManagedRuleGroupOutput).
    pub fn build(
        self,
    ) -> crate::operation::describe_managed_rule_group::DescribeManagedRuleGroupOutput {
        crate::operation::describe_managed_rule_group::DescribeManagedRuleGroupOutput {
            version_name: self.version_name,
            sns_topic_arn: self.sns_topic_arn,
            capacity: self.capacity.unwrap_or_default(),
            rules: self.rules,
            label_namespace: self.label_namespace,
            available_labels: self.available_labels,
            consumed_labels: self.consumed_labels,
            _request_id: self._request_id,
        }
    }
}
