// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateWebAclOutput {
    /// <p>A token used for optimistic locking. WAF returns this token to your <code>update</code> requests. You use <code>NextLockToken</code> in the same manner as you use <code>LockToken</code>. </p>
    pub next_lock_token: std::option::Option<std::string::String>,
}
impl UpdateWebAclOutput {
    /// <p>A token used for optimistic locking. WAF returns this token to your <code>update</code> requests. You use <code>NextLockToken</code> in the same manner as you use <code>LockToken</code>. </p>
    pub fn next_lock_token(&self) -> std::option::Option<&str> {
        self.next_lock_token.as_deref()
    }
}
impl std::fmt::Debug for UpdateWebAclOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateWebAclOutput");
        formatter.field("next_lock_token", &self.next_lock_token);
        formatter.finish()
    }
}
/// See [`UpdateWebAclOutput`](crate::output::UpdateWebAclOutput)
pub mod update_web_acl_output {
    /// A builder for [`UpdateWebAclOutput`](crate::output::UpdateWebAclOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_lock_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A token used for optimistic locking. WAF returns this token to your <code>update</code> requests. You use <code>NextLockToken</code> in the same manner as you use <code>LockToken</code>. </p>
        pub fn next_lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_lock_token = Some(input.into());
            self
        }
        /// <p>A token used for optimistic locking. WAF returns this token to your <code>update</code> requests. You use <code>NextLockToken</code> in the same manner as you use <code>LockToken</code>. </p>
        pub fn set_next_lock_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_lock_token = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateWebAclOutput`](crate::output::UpdateWebAclOutput)
        pub fn build(self) -> crate::output::UpdateWebAclOutput {
            crate::output::UpdateWebAclOutput {
                next_lock_token: self.next_lock_token,
            }
        }
    }
}
impl UpdateWebAclOutput {
    /// Creates a new builder-style object to manufacture [`UpdateWebAclOutput`](crate::output::UpdateWebAclOutput)
    pub fn builder() -> crate::output::update_web_acl_output::Builder {
        crate::output::update_web_acl_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateRuleGroupOutput {
    /// <p>A token used for optimistic locking. WAF returns this token to your <code>update</code> requests. You use <code>NextLockToken</code> in the same manner as you use <code>LockToken</code>. </p>
    pub next_lock_token: std::option::Option<std::string::String>,
}
impl UpdateRuleGroupOutput {
    /// <p>A token used for optimistic locking. WAF returns this token to your <code>update</code> requests. You use <code>NextLockToken</code> in the same manner as you use <code>LockToken</code>. </p>
    pub fn next_lock_token(&self) -> std::option::Option<&str> {
        self.next_lock_token.as_deref()
    }
}
impl std::fmt::Debug for UpdateRuleGroupOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateRuleGroupOutput");
        formatter.field("next_lock_token", &self.next_lock_token);
        formatter.finish()
    }
}
/// See [`UpdateRuleGroupOutput`](crate::output::UpdateRuleGroupOutput)
pub mod update_rule_group_output {
    /// A builder for [`UpdateRuleGroupOutput`](crate::output::UpdateRuleGroupOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_lock_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A token used for optimistic locking. WAF returns this token to your <code>update</code> requests. You use <code>NextLockToken</code> in the same manner as you use <code>LockToken</code>. </p>
        pub fn next_lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_lock_token = Some(input.into());
            self
        }
        /// <p>A token used for optimistic locking. WAF returns this token to your <code>update</code> requests. You use <code>NextLockToken</code> in the same manner as you use <code>LockToken</code>. </p>
        pub fn set_next_lock_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_lock_token = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateRuleGroupOutput`](crate::output::UpdateRuleGroupOutput)
        pub fn build(self) -> crate::output::UpdateRuleGroupOutput {
            crate::output::UpdateRuleGroupOutput {
                next_lock_token: self.next_lock_token,
            }
        }
    }
}
impl UpdateRuleGroupOutput {
    /// Creates a new builder-style object to manufacture [`UpdateRuleGroupOutput`](crate::output::UpdateRuleGroupOutput)
    pub fn builder() -> crate::output::update_rule_group_output::Builder {
        crate::output::update_rule_group_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateRegexPatternSetOutput {
    /// <p>A token used for optimistic locking. WAF returns this token to your <code>update</code> requests. You use <code>NextLockToken</code> in the same manner as you use <code>LockToken</code>. </p>
    pub next_lock_token: std::option::Option<std::string::String>,
}
impl UpdateRegexPatternSetOutput {
    /// <p>A token used for optimistic locking. WAF returns this token to your <code>update</code> requests. You use <code>NextLockToken</code> in the same manner as you use <code>LockToken</code>. </p>
    pub fn next_lock_token(&self) -> std::option::Option<&str> {
        self.next_lock_token.as_deref()
    }
}
impl std::fmt::Debug for UpdateRegexPatternSetOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateRegexPatternSetOutput");
        formatter.field("next_lock_token", &self.next_lock_token);
        formatter.finish()
    }
}
/// See [`UpdateRegexPatternSetOutput`](crate::output::UpdateRegexPatternSetOutput)
pub mod update_regex_pattern_set_output {
    /// A builder for [`UpdateRegexPatternSetOutput`](crate::output::UpdateRegexPatternSetOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_lock_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A token used for optimistic locking. WAF returns this token to your <code>update</code> requests. You use <code>NextLockToken</code> in the same manner as you use <code>LockToken</code>. </p>
        pub fn next_lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_lock_token = Some(input.into());
            self
        }
        /// <p>A token used for optimistic locking. WAF returns this token to your <code>update</code> requests. You use <code>NextLockToken</code> in the same manner as you use <code>LockToken</code>. </p>
        pub fn set_next_lock_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_lock_token = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateRegexPatternSetOutput`](crate::output::UpdateRegexPatternSetOutput)
        pub fn build(self) -> crate::output::UpdateRegexPatternSetOutput {
            crate::output::UpdateRegexPatternSetOutput {
                next_lock_token: self.next_lock_token,
            }
        }
    }
}
impl UpdateRegexPatternSetOutput {
    /// Creates a new builder-style object to manufacture [`UpdateRegexPatternSetOutput`](crate::output::UpdateRegexPatternSetOutput)
    pub fn builder() -> crate::output::update_regex_pattern_set_output::Builder {
        crate::output::update_regex_pattern_set_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateManagedRuleSetVersionExpiryDateOutput {
    /// <p>The version that is set to expire. </p>
    pub expiring_version: std::option::Option<std::string::String>,
    /// <p>The time that the version will expire. </p>
    /// <p>Times are in Coordinated Universal Time (UTC) format. UTC format includes the special designator, Z. For example, "2016-09-27T14:50Z". </p>
    pub expiry_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub next_lock_token: std::option::Option<std::string::String>,
}
impl UpdateManagedRuleSetVersionExpiryDateOutput {
    /// <p>The version that is set to expire. </p>
    pub fn expiring_version(&self) -> std::option::Option<&str> {
        self.expiring_version.as_deref()
    }
    /// <p>The time that the version will expire. </p>
    /// <p>Times are in Coordinated Universal Time (UTC) format. UTC format includes the special designator, Z. For example, "2016-09-27T14:50Z". </p>
    pub fn expiry_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.expiry_timestamp.as_ref()
    }
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub fn next_lock_token(&self) -> std::option::Option<&str> {
        self.next_lock_token.as_deref()
    }
}
impl std::fmt::Debug for UpdateManagedRuleSetVersionExpiryDateOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateManagedRuleSetVersionExpiryDateOutput");
        formatter.field("expiring_version", &self.expiring_version);
        formatter.field("expiry_timestamp", &self.expiry_timestamp);
        formatter.field("next_lock_token", &self.next_lock_token);
        formatter.finish()
    }
}
/// See [`UpdateManagedRuleSetVersionExpiryDateOutput`](crate::output::UpdateManagedRuleSetVersionExpiryDateOutput)
pub mod update_managed_rule_set_version_expiry_date_output {
    /// A builder for [`UpdateManagedRuleSetVersionExpiryDateOutput`](crate::output::UpdateManagedRuleSetVersionExpiryDateOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) expiring_version: std::option::Option<std::string::String>,
        pub(crate) expiry_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) next_lock_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The version that is set to expire. </p>
        pub fn expiring_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.expiring_version = Some(input.into());
            self
        }
        /// <p>The version that is set to expire. </p>
        pub fn set_expiring_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expiring_version = input;
            self
        }
        /// <p>The time that the version will expire. </p>
        /// <p>Times are in Coordinated Universal Time (UTC) format. UTC format includes the special designator, Z. For example, "2016-09-27T14:50Z". </p>
        pub fn expiry_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.expiry_timestamp = Some(input);
            self
        }
        /// <p>The time that the version will expire. </p>
        /// <p>Times are in Coordinated Universal Time (UTC) format. UTC format includes the special designator, Z. For example, "2016-09-27T14:50Z". </p>
        pub fn set_expiry_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.expiry_timestamp = input;
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn next_lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_lock_token = Some(input.into());
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn set_next_lock_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_lock_token = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateManagedRuleSetVersionExpiryDateOutput`](crate::output::UpdateManagedRuleSetVersionExpiryDateOutput)
        pub fn build(self) -> crate::output::UpdateManagedRuleSetVersionExpiryDateOutput {
            crate::output::UpdateManagedRuleSetVersionExpiryDateOutput {
                expiring_version: self.expiring_version,
                expiry_timestamp: self.expiry_timestamp,
                next_lock_token: self.next_lock_token,
            }
        }
    }
}
impl UpdateManagedRuleSetVersionExpiryDateOutput {
    /// Creates a new builder-style object to manufacture [`UpdateManagedRuleSetVersionExpiryDateOutput`](crate::output::UpdateManagedRuleSetVersionExpiryDateOutput)
    pub fn builder() -> crate::output::update_managed_rule_set_version_expiry_date_output::Builder {
        crate::output::update_managed_rule_set_version_expiry_date_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateIpSetOutput {
    /// <p>A token used for optimistic locking. WAF returns this token to your <code>update</code> requests. You use <code>NextLockToken</code> in the same manner as you use <code>LockToken</code>. </p>
    pub next_lock_token: std::option::Option<std::string::String>,
}
impl UpdateIpSetOutput {
    /// <p>A token used for optimistic locking. WAF returns this token to your <code>update</code> requests. You use <code>NextLockToken</code> in the same manner as you use <code>LockToken</code>. </p>
    pub fn next_lock_token(&self) -> std::option::Option<&str> {
        self.next_lock_token.as_deref()
    }
}
impl std::fmt::Debug for UpdateIpSetOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateIpSetOutput");
        formatter.field("next_lock_token", &self.next_lock_token);
        formatter.finish()
    }
}
/// See [`UpdateIpSetOutput`](crate::output::UpdateIpSetOutput)
pub mod update_ip_set_output {
    /// A builder for [`UpdateIpSetOutput`](crate::output::UpdateIpSetOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_lock_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A token used for optimistic locking. WAF returns this token to your <code>update</code> requests. You use <code>NextLockToken</code> in the same manner as you use <code>LockToken</code>. </p>
        pub fn next_lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_lock_token = Some(input.into());
            self
        }
        /// <p>A token used for optimistic locking. WAF returns this token to your <code>update</code> requests. You use <code>NextLockToken</code> in the same manner as you use <code>LockToken</code>. </p>
        pub fn set_next_lock_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_lock_token = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateIpSetOutput`](crate::output::UpdateIpSetOutput)
        pub fn build(self) -> crate::output::UpdateIpSetOutput {
            crate::output::UpdateIpSetOutput {
                next_lock_token: self.next_lock_token,
            }
        }
    }
}
impl UpdateIpSetOutput {
    /// Creates a new builder-style object to manufacture [`UpdateIpSetOutput`](crate::output::UpdateIpSetOutput)
    pub fn builder() -> crate::output::update_ip_set_output::Builder {
        crate::output::update_ip_set_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourceOutput {}
impl std::fmt::Debug for UntagResourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourceOutput");
        formatter.finish()
    }
}
/// See [`UntagResourceOutput`](crate::output::UntagResourceOutput)
pub mod untag_resource_output {
    /// A builder for [`UntagResourceOutput`](crate::output::UntagResourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`UntagResourceOutput`](crate::output::UntagResourceOutput)
        pub fn build(self) -> crate::output::UntagResourceOutput {
            crate::output::UntagResourceOutput {}
        }
    }
}
impl UntagResourceOutput {
    /// Creates a new builder-style object to manufacture [`UntagResourceOutput`](crate::output::UntagResourceOutput)
    pub fn builder() -> crate::output::untag_resource_output::Builder {
        crate::output::untag_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceOutput {}
impl std::fmt::Debug for TagResourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceOutput");
        formatter.finish()
    }
}
/// See [`TagResourceOutput`](crate::output::TagResourceOutput)
pub mod tag_resource_output {
    /// A builder for [`TagResourceOutput`](crate::output::TagResourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`TagResourceOutput`](crate::output::TagResourceOutput)
        pub fn build(self) -> crate::output::TagResourceOutput {
            crate::output::TagResourceOutput {}
        }
    }
}
impl TagResourceOutput {
    /// Creates a new builder-style object to manufacture [`TagResourceOutput`](crate::output::TagResourceOutput)
    pub fn builder() -> crate::output::tag_resource_output::Builder {
        crate::output::tag_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutPermissionPolicyOutput {}
impl std::fmt::Debug for PutPermissionPolicyOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutPermissionPolicyOutput");
        formatter.finish()
    }
}
/// See [`PutPermissionPolicyOutput`](crate::output::PutPermissionPolicyOutput)
pub mod put_permission_policy_output {
    /// A builder for [`PutPermissionPolicyOutput`](crate::output::PutPermissionPolicyOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`PutPermissionPolicyOutput`](crate::output::PutPermissionPolicyOutput)
        pub fn build(self) -> crate::output::PutPermissionPolicyOutput {
            crate::output::PutPermissionPolicyOutput {}
        }
    }
}
impl PutPermissionPolicyOutput {
    /// Creates a new builder-style object to manufacture [`PutPermissionPolicyOutput`](crate::output::PutPermissionPolicyOutput)
    pub fn builder() -> crate::output::put_permission_policy_output::Builder {
        crate::output::put_permission_policy_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutManagedRuleSetVersionsOutput {
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub next_lock_token: std::option::Option<std::string::String>,
}
impl PutManagedRuleSetVersionsOutput {
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub fn next_lock_token(&self) -> std::option::Option<&str> {
        self.next_lock_token.as_deref()
    }
}
impl std::fmt::Debug for PutManagedRuleSetVersionsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutManagedRuleSetVersionsOutput");
        formatter.field("next_lock_token", &self.next_lock_token);
        formatter.finish()
    }
}
/// See [`PutManagedRuleSetVersionsOutput`](crate::output::PutManagedRuleSetVersionsOutput)
pub mod put_managed_rule_set_versions_output {
    /// A builder for [`PutManagedRuleSetVersionsOutput`](crate::output::PutManagedRuleSetVersionsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_lock_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn next_lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_lock_token = Some(input.into());
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn set_next_lock_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_lock_token = input;
            self
        }
        /// Consumes the builder and constructs a [`PutManagedRuleSetVersionsOutput`](crate::output::PutManagedRuleSetVersionsOutput)
        pub fn build(self) -> crate::output::PutManagedRuleSetVersionsOutput {
            crate::output::PutManagedRuleSetVersionsOutput {
                next_lock_token: self.next_lock_token,
            }
        }
    }
}
impl PutManagedRuleSetVersionsOutput {
    /// Creates a new builder-style object to manufacture [`PutManagedRuleSetVersionsOutput`](crate::output::PutManagedRuleSetVersionsOutput)
    pub fn builder() -> crate::output::put_managed_rule_set_versions_output::Builder {
        crate::output::put_managed_rule_set_versions_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutLoggingConfigurationOutput {
    /// <p></p>
    pub logging_configuration: std::option::Option<crate::model::LoggingConfiguration>,
}
impl PutLoggingConfigurationOutput {
    /// <p></p>
    pub fn logging_configuration(
        &self,
    ) -> std::option::Option<&crate::model::LoggingConfiguration> {
        self.logging_configuration.as_ref()
    }
}
impl std::fmt::Debug for PutLoggingConfigurationOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutLoggingConfigurationOutput");
        formatter.field("logging_configuration", &self.logging_configuration);
        formatter.finish()
    }
}
/// See [`PutLoggingConfigurationOutput`](crate::output::PutLoggingConfigurationOutput)
pub mod put_logging_configuration_output {
    /// A builder for [`PutLoggingConfigurationOutput`](crate::output::PutLoggingConfigurationOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) logging_configuration: std::option::Option<crate::model::LoggingConfiguration>,
    }
    impl Builder {
        /// <p></p>
        pub fn logging_configuration(mut self, input: crate::model::LoggingConfiguration) -> Self {
            self.logging_configuration = Some(input);
            self
        }
        /// <p></p>
        pub fn set_logging_configuration(
            mut self,
            input: std::option::Option<crate::model::LoggingConfiguration>,
        ) -> Self {
            self.logging_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PutLoggingConfigurationOutput`](crate::output::PutLoggingConfigurationOutput)
        pub fn build(self) -> crate::output::PutLoggingConfigurationOutput {
            crate::output::PutLoggingConfigurationOutput {
                logging_configuration: self.logging_configuration,
            }
        }
    }
}
impl PutLoggingConfigurationOutput {
    /// Creates a new builder-style object to manufacture [`PutLoggingConfigurationOutput`](crate::output::PutLoggingConfigurationOutput)
    pub fn builder() -> crate::output::put_logging_configuration_output::Builder {
        crate::output::put_logging_configuration_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListWebAcLsOutput {
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub next_marker: std::option::Option<std::string::String>,
    /// <p></p>
    pub web_ac_ls: std::option::Option<std::vec::Vec<crate::model::WebAclSummary>>,
}
impl ListWebAcLsOutput {
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub fn next_marker(&self) -> std::option::Option<&str> {
        self.next_marker.as_deref()
    }
    /// <p></p>
    pub fn web_ac_ls(&self) -> std::option::Option<&[crate::model::WebAclSummary]> {
        self.web_ac_ls.as_deref()
    }
}
impl std::fmt::Debug for ListWebAcLsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListWebAcLsOutput");
        formatter.field("next_marker", &self.next_marker);
        formatter.field("web_ac_ls", &self.web_ac_ls);
        formatter.finish()
    }
}
/// See [`ListWebAcLsOutput`](crate::output::ListWebAcLsOutput)
pub mod list_web_ac_ls_output {
    /// A builder for [`ListWebAcLsOutput`](crate::output::ListWebAcLsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_marker: std::option::Option<std::string::String>,
        pub(crate) web_ac_ls: std::option::Option<std::vec::Vec<crate::model::WebAclSummary>>,
    }
    impl Builder {
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn next_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_marker = Some(input.into());
            self
        }
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn set_next_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_marker = input;
            self
        }
        /// Appends an item to `web_ac_ls`.
        ///
        /// To override the contents of this collection use [`set_web_ac_ls`](Self::set_web_ac_ls).
        ///
        /// <p></p>
        pub fn web_ac_ls(mut self, input: crate::model::WebAclSummary) -> Self {
            let mut v = self.web_ac_ls.unwrap_or_default();
            v.push(input);
            self.web_ac_ls = Some(v);
            self
        }
        /// <p></p>
        pub fn set_web_ac_ls(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::WebAclSummary>>,
        ) -> Self {
            self.web_ac_ls = input;
            self
        }
        /// Consumes the builder and constructs a [`ListWebAcLsOutput`](crate::output::ListWebAcLsOutput)
        pub fn build(self) -> crate::output::ListWebAcLsOutput {
            crate::output::ListWebAcLsOutput {
                next_marker: self.next_marker,
                web_ac_ls: self.web_ac_ls,
            }
        }
    }
}
impl ListWebAcLsOutput {
    /// Creates a new builder-style object to manufacture [`ListWebAcLsOutput`](crate::output::ListWebAcLsOutput)
    pub fn builder() -> crate::output::list_web_ac_ls_output::Builder {
        crate::output::list_web_ac_ls_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceOutput {
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub next_marker: std::option::Option<std::string::String>,
    /// <p>The collection of tagging definitions for the resource. </p>
    pub tag_info_for_resource: std::option::Option<crate::model::TagInfoForResource>,
}
impl ListTagsForResourceOutput {
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub fn next_marker(&self) -> std::option::Option<&str> {
        self.next_marker.as_deref()
    }
    /// <p>The collection of tagging definitions for the resource. </p>
    pub fn tag_info_for_resource(&self) -> std::option::Option<&crate::model::TagInfoForResource> {
        self.tag_info_for_resource.as_ref()
    }
}
impl std::fmt::Debug for ListTagsForResourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceOutput");
        formatter.field("next_marker", &self.next_marker);
        formatter.field("tag_info_for_resource", &self.tag_info_for_resource);
        formatter.finish()
    }
}
/// See [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
pub mod list_tags_for_resource_output {
    /// A builder for [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_marker: std::option::Option<std::string::String>,
        pub(crate) tag_info_for_resource: std::option::Option<crate::model::TagInfoForResource>,
    }
    impl Builder {
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn next_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_marker = Some(input.into());
            self
        }
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn set_next_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_marker = input;
            self
        }
        /// <p>The collection of tagging definitions for the resource. </p>
        pub fn tag_info_for_resource(mut self, input: crate::model::TagInfoForResource) -> Self {
            self.tag_info_for_resource = Some(input);
            self
        }
        /// <p>The collection of tagging definitions for the resource. </p>
        pub fn set_tag_info_for_resource(
            mut self,
            input: std::option::Option<crate::model::TagInfoForResource>,
        ) -> Self {
            self.tag_info_for_resource = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
        pub fn build(self) -> crate::output::ListTagsForResourceOutput {
            crate::output::ListTagsForResourceOutput {
                next_marker: self.next_marker,
                tag_info_for_resource: self.tag_info_for_resource,
            }
        }
    }
}
impl ListTagsForResourceOutput {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
    pub fn builder() -> crate::output::list_tags_for_resource_output::Builder {
        crate::output::list_tags_for_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListRuleGroupsOutput {
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub next_marker: std::option::Option<std::string::String>,
    /// <p></p>
    pub rule_groups: std::option::Option<std::vec::Vec<crate::model::RuleGroupSummary>>,
}
impl ListRuleGroupsOutput {
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub fn next_marker(&self) -> std::option::Option<&str> {
        self.next_marker.as_deref()
    }
    /// <p></p>
    pub fn rule_groups(&self) -> std::option::Option<&[crate::model::RuleGroupSummary]> {
        self.rule_groups.as_deref()
    }
}
impl std::fmt::Debug for ListRuleGroupsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListRuleGroupsOutput");
        formatter.field("next_marker", &self.next_marker);
        formatter.field("rule_groups", &self.rule_groups);
        formatter.finish()
    }
}
/// See [`ListRuleGroupsOutput`](crate::output::ListRuleGroupsOutput)
pub mod list_rule_groups_output {
    /// A builder for [`ListRuleGroupsOutput`](crate::output::ListRuleGroupsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_marker: std::option::Option<std::string::String>,
        pub(crate) rule_groups: std::option::Option<std::vec::Vec<crate::model::RuleGroupSummary>>,
    }
    impl Builder {
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn next_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_marker = Some(input.into());
            self
        }
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn set_next_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_marker = input;
            self
        }
        /// Appends an item to `rule_groups`.
        ///
        /// To override the contents of this collection use [`set_rule_groups`](Self::set_rule_groups).
        ///
        /// <p></p>
        pub fn rule_groups(mut self, input: crate::model::RuleGroupSummary) -> Self {
            let mut v = self.rule_groups.unwrap_or_default();
            v.push(input);
            self.rule_groups = Some(v);
            self
        }
        /// <p></p>
        pub fn set_rule_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RuleGroupSummary>>,
        ) -> Self {
            self.rule_groups = input;
            self
        }
        /// Consumes the builder and constructs a [`ListRuleGroupsOutput`](crate::output::ListRuleGroupsOutput)
        pub fn build(self) -> crate::output::ListRuleGroupsOutput {
            crate::output::ListRuleGroupsOutput {
                next_marker: self.next_marker,
                rule_groups: self.rule_groups,
            }
        }
    }
}
impl ListRuleGroupsOutput {
    /// Creates a new builder-style object to manufacture [`ListRuleGroupsOutput`](crate::output::ListRuleGroupsOutput)
    pub fn builder() -> crate::output::list_rule_groups_output::Builder {
        crate::output::list_rule_groups_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListResourcesForWebAclOutput {
    /// <p>The array of Amazon Resource Names (ARNs) of the associated resources.</p>
    pub resource_arns: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ListResourcesForWebAclOutput {
    /// <p>The array of Amazon Resource Names (ARNs) of the associated resources.</p>
    pub fn resource_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.resource_arns.as_deref()
    }
}
impl std::fmt::Debug for ListResourcesForWebAclOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListResourcesForWebAclOutput");
        formatter.field("resource_arns", &self.resource_arns);
        formatter.finish()
    }
}
/// See [`ListResourcesForWebAclOutput`](crate::output::ListResourcesForWebAclOutput)
pub mod list_resources_for_web_acl_output {
    /// A builder for [`ListResourcesForWebAclOutput`](crate::output::ListResourcesForWebAclOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `resource_arns`.
        ///
        /// To override the contents of this collection use [`set_resource_arns`](Self::set_resource_arns).
        ///
        /// <p>The array of Amazon Resource Names (ARNs) of the associated resources.</p>
        pub fn resource_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.resource_arns.unwrap_or_default();
            v.push(input.into());
            self.resource_arns = Some(v);
            self
        }
        /// <p>The array of Amazon Resource Names (ARNs) of the associated resources.</p>
        pub fn set_resource_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.resource_arns = input;
            self
        }
        /// Consumes the builder and constructs a [`ListResourcesForWebAclOutput`](crate::output::ListResourcesForWebAclOutput)
        pub fn build(self) -> crate::output::ListResourcesForWebAclOutput {
            crate::output::ListResourcesForWebAclOutput {
                resource_arns: self.resource_arns,
            }
        }
    }
}
impl ListResourcesForWebAclOutput {
    /// Creates a new builder-style object to manufacture [`ListResourcesForWebAclOutput`](crate::output::ListResourcesForWebAclOutput)
    pub fn builder() -> crate::output::list_resources_for_web_acl_output::Builder {
        crate::output::list_resources_for_web_acl_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListRegexPatternSetsOutput {
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub next_marker: std::option::Option<std::string::String>,
    /// <p></p>
    pub regex_pattern_sets:
        std::option::Option<std::vec::Vec<crate::model::RegexPatternSetSummary>>,
}
impl ListRegexPatternSetsOutput {
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub fn next_marker(&self) -> std::option::Option<&str> {
        self.next_marker.as_deref()
    }
    /// <p></p>
    pub fn regex_pattern_sets(
        &self,
    ) -> std::option::Option<&[crate::model::RegexPatternSetSummary]> {
        self.regex_pattern_sets.as_deref()
    }
}
impl std::fmt::Debug for ListRegexPatternSetsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListRegexPatternSetsOutput");
        formatter.field("next_marker", &self.next_marker);
        formatter.field("regex_pattern_sets", &self.regex_pattern_sets);
        formatter.finish()
    }
}
/// See [`ListRegexPatternSetsOutput`](crate::output::ListRegexPatternSetsOutput)
pub mod list_regex_pattern_sets_output {
    /// A builder for [`ListRegexPatternSetsOutput`](crate::output::ListRegexPatternSetsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_marker: std::option::Option<std::string::String>,
        pub(crate) regex_pattern_sets:
            std::option::Option<std::vec::Vec<crate::model::RegexPatternSetSummary>>,
    }
    impl Builder {
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn next_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_marker = Some(input.into());
            self
        }
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn set_next_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_marker = input;
            self
        }
        /// Appends an item to `regex_pattern_sets`.
        ///
        /// To override the contents of this collection use [`set_regex_pattern_sets`](Self::set_regex_pattern_sets).
        ///
        /// <p></p>
        pub fn regex_pattern_sets(mut self, input: crate::model::RegexPatternSetSummary) -> Self {
            let mut v = self.regex_pattern_sets.unwrap_or_default();
            v.push(input);
            self.regex_pattern_sets = Some(v);
            self
        }
        /// <p></p>
        pub fn set_regex_pattern_sets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RegexPatternSetSummary>>,
        ) -> Self {
            self.regex_pattern_sets = input;
            self
        }
        /// Consumes the builder and constructs a [`ListRegexPatternSetsOutput`](crate::output::ListRegexPatternSetsOutput)
        pub fn build(self) -> crate::output::ListRegexPatternSetsOutput {
            crate::output::ListRegexPatternSetsOutput {
                next_marker: self.next_marker,
                regex_pattern_sets: self.regex_pattern_sets,
            }
        }
    }
}
impl ListRegexPatternSetsOutput {
    /// Creates a new builder-style object to manufacture [`ListRegexPatternSetsOutput`](crate::output::ListRegexPatternSetsOutput)
    pub fn builder() -> crate::output::list_regex_pattern_sets_output::Builder {
        crate::output::list_regex_pattern_sets_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListMobileSdkReleasesOutput {
    /// <p>High level information for the available SDK releases. </p>
    pub release_summaries: std::option::Option<std::vec::Vec<crate::model::ReleaseSummary>>,
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub next_marker: std::option::Option<std::string::String>,
}
impl ListMobileSdkReleasesOutput {
    /// <p>High level information for the available SDK releases. </p>
    pub fn release_summaries(&self) -> std::option::Option<&[crate::model::ReleaseSummary]> {
        self.release_summaries.as_deref()
    }
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub fn next_marker(&self) -> std::option::Option<&str> {
        self.next_marker.as_deref()
    }
}
impl std::fmt::Debug for ListMobileSdkReleasesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListMobileSdkReleasesOutput");
        formatter.field("release_summaries", &self.release_summaries);
        formatter.field("next_marker", &self.next_marker);
        formatter.finish()
    }
}
/// See [`ListMobileSdkReleasesOutput`](crate::output::ListMobileSdkReleasesOutput)
pub mod list_mobile_sdk_releases_output {
    /// A builder for [`ListMobileSdkReleasesOutput`](crate::output::ListMobileSdkReleasesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) release_summaries:
            std::option::Option<std::vec::Vec<crate::model::ReleaseSummary>>,
        pub(crate) next_marker: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `release_summaries`.
        ///
        /// To override the contents of this collection use [`set_release_summaries`](Self::set_release_summaries).
        ///
        /// <p>High level information for the available SDK releases. </p>
        pub fn release_summaries(mut self, input: crate::model::ReleaseSummary) -> Self {
            let mut v = self.release_summaries.unwrap_or_default();
            v.push(input);
            self.release_summaries = Some(v);
            self
        }
        /// <p>High level information for the available SDK releases. </p>
        pub fn set_release_summaries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReleaseSummary>>,
        ) -> Self {
            self.release_summaries = input;
            self
        }
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn next_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_marker = Some(input.into());
            self
        }
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn set_next_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_marker = input;
            self
        }
        /// Consumes the builder and constructs a [`ListMobileSdkReleasesOutput`](crate::output::ListMobileSdkReleasesOutput)
        pub fn build(self) -> crate::output::ListMobileSdkReleasesOutput {
            crate::output::ListMobileSdkReleasesOutput {
                release_summaries: self.release_summaries,
                next_marker: self.next_marker,
            }
        }
    }
}
impl ListMobileSdkReleasesOutput {
    /// Creates a new builder-style object to manufacture [`ListMobileSdkReleasesOutput`](crate::output::ListMobileSdkReleasesOutput)
    pub fn builder() -> crate::output::list_mobile_sdk_releases_output::Builder {
        crate::output::list_mobile_sdk_releases_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListManagedRuleSetsOutput {
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub next_marker: std::option::Option<std::string::String>,
    /// <p>Your managed rule sets. </p>
    pub managed_rule_sets: std::option::Option<std::vec::Vec<crate::model::ManagedRuleSetSummary>>,
}
impl ListManagedRuleSetsOutput {
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub fn next_marker(&self) -> std::option::Option<&str> {
        self.next_marker.as_deref()
    }
    /// <p>Your managed rule sets. </p>
    pub fn managed_rule_sets(&self) -> std::option::Option<&[crate::model::ManagedRuleSetSummary]> {
        self.managed_rule_sets.as_deref()
    }
}
impl std::fmt::Debug for ListManagedRuleSetsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListManagedRuleSetsOutput");
        formatter.field("next_marker", &self.next_marker);
        formatter.field("managed_rule_sets", &self.managed_rule_sets);
        formatter.finish()
    }
}
/// See [`ListManagedRuleSetsOutput`](crate::output::ListManagedRuleSetsOutput)
pub mod list_managed_rule_sets_output {
    /// A builder for [`ListManagedRuleSetsOutput`](crate::output::ListManagedRuleSetsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_marker: std::option::Option<std::string::String>,
        pub(crate) managed_rule_sets:
            std::option::Option<std::vec::Vec<crate::model::ManagedRuleSetSummary>>,
    }
    impl Builder {
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn next_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_marker = Some(input.into());
            self
        }
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn set_next_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_marker = input;
            self
        }
        /// Appends an item to `managed_rule_sets`.
        ///
        /// To override the contents of this collection use [`set_managed_rule_sets`](Self::set_managed_rule_sets).
        ///
        /// <p>Your managed rule sets. </p>
        pub fn managed_rule_sets(mut self, input: crate::model::ManagedRuleSetSummary) -> Self {
            let mut v = self.managed_rule_sets.unwrap_or_default();
            v.push(input);
            self.managed_rule_sets = Some(v);
            self
        }
        /// <p>Your managed rule sets. </p>
        pub fn set_managed_rule_sets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ManagedRuleSetSummary>>,
        ) -> Self {
            self.managed_rule_sets = input;
            self
        }
        /// Consumes the builder and constructs a [`ListManagedRuleSetsOutput`](crate::output::ListManagedRuleSetsOutput)
        pub fn build(self) -> crate::output::ListManagedRuleSetsOutput {
            crate::output::ListManagedRuleSetsOutput {
                next_marker: self.next_marker,
                managed_rule_sets: self.managed_rule_sets,
            }
        }
    }
}
impl ListManagedRuleSetsOutput {
    /// Creates a new builder-style object to manufacture [`ListManagedRuleSetsOutput`](crate::output::ListManagedRuleSetsOutput)
    pub fn builder() -> crate::output::list_managed_rule_sets_output::Builder {
        crate::output::list_managed_rule_sets_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListLoggingConfigurationsOutput {
    /// <p></p>
    pub logging_configurations:
        std::option::Option<std::vec::Vec<crate::model::LoggingConfiguration>>,
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub next_marker: std::option::Option<std::string::String>,
}
impl ListLoggingConfigurationsOutput {
    /// <p></p>
    pub fn logging_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::LoggingConfiguration]> {
        self.logging_configurations.as_deref()
    }
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub fn next_marker(&self) -> std::option::Option<&str> {
        self.next_marker.as_deref()
    }
}
impl std::fmt::Debug for ListLoggingConfigurationsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListLoggingConfigurationsOutput");
        formatter.field("logging_configurations", &self.logging_configurations);
        formatter.field("next_marker", &self.next_marker);
        formatter.finish()
    }
}
/// See [`ListLoggingConfigurationsOutput`](crate::output::ListLoggingConfigurationsOutput)
pub mod list_logging_configurations_output {
    /// A builder for [`ListLoggingConfigurationsOutput`](crate::output::ListLoggingConfigurationsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) logging_configurations:
            std::option::Option<std::vec::Vec<crate::model::LoggingConfiguration>>,
        pub(crate) next_marker: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `logging_configurations`.
        ///
        /// To override the contents of this collection use [`set_logging_configurations`](Self::set_logging_configurations).
        ///
        /// <p></p>
        pub fn logging_configurations(mut self, input: crate::model::LoggingConfiguration) -> Self {
            let mut v = self.logging_configurations.unwrap_or_default();
            v.push(input);
            self.logging_configurations = Some(v);
            self
        }
        /// <p></p>
        pub fn set_logging_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LoggingConfiguration>>,
        ) -> Self {
            self.logging_configurations = input;
            self
        }
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn next_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_marker = Some(input.into());
            self
        }
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn set_next_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_marker = input;
            self
        }
        /// Consumes the builder and constructs a [`ListLoggingConfigurationsOutput`](crate::output::ListLoggingConfigurationsOutput)
        pub fn build(self) -> crate::output::ListLoggingConfigurationsOutput {
            crate::output::ListLoggingConfigurationsOutput {
                logging_configurations: self.logging_configurations,
                next_marker: self.next_marker,
            }
        }
    }
}
impl ListLoggingConfigurationsOutput {
    /// Creates a new builder-style object to manufacture [`ListLoggingConfigurationsOutput`](crate::output::ListLoggingConfigurationsOutput)
    pub fn builder() -> crate::output::list_logging_configurations_output::Builder {
        crate::output::list_logging_configurations_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListIpSetsOutput {
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub next_marker: std::option::Option<std::string::String>,
    /// <p>Array of IPSets. This may not be the full list of IPSets that you have defined. See the <code>Limit</code> specification for this request.</p>
    pub ip_sets: std::option::Option<std::vec::Vec<crate::model::IpSetSummary>>,
}
impl ListIpSetsOutput {
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub fn next_marker(&self) -> std::option::Option<&str> {
        self.next_marker.as_deref()
    }
    /// <p>Array of IPSets. This may not be the full list of IPSets that you have defined. See the <code>Limit</code> specification for this request.</p>
    pub fn ip_sets(&self) -> std::option::Option<&[crate::model::IpSetSummary]> {
        self.ip_sets.as_deref()
    }
}
impl std::fmt::Debug for ListIpSetsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListIpSetsOutput");
        formatter.field("next_marker", &self.next_marker);
        formatter.field("ip_sets", &self.ip_sets);
        formatter.finish()
    }
}
/// See [`ListIpSetsOutput`](crate::output::ListIpSetsOutput)
pub mod list_ip_sets_output {
    /// A builder for [`ListIpSetsOutput`](crate::output::ListIpSetsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_marker: std::option::Option<std::string::String>,
        pub(crate) ip_sets: std::option::Option<std::vec::Vec<crate::model::IpSetSummary>>,
    }
    impl Builder {
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn next_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_marker = Some(input.into());
            self
        }
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn set_next_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_marker = input;
            self
        }
        /// Appends an item to `ip_sets`.
        ///
        /// To override the contents of this collection use [`set_ip_sets`](Self::set_ip_sets).
        ///
        /// <p>Array of IPSets. This may not be the full list of IPSets that you have defined. See the <code>Limit</code> specification for this request.</p>
        pub fn ip_sets(mut self, input: crate::model::IpSetSummary) -> Self {
            let mut v = self.ip_sets.unwrap_or_default();
            v.push(input);
            self.ip_sets = Some(v);
            self
        }
        /// <p>Array of IPSets. This may not be the full list of IPSets that you have defined. See the <code>Limit</code> specification for this request.</p>
        pub fn set_ip_sets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IpSetSummary>>,
        ) -> Self {
            self.ip_sets = input;
            self
        }
        /// Consumes the builder and constructs a [`ListIpSetsOutput`](crate::output::ListIpSetsOutput)
        pub fn build(self) -> crate::output::ListIpSetsOutput {
            crate::output::ListIpSetsOutput {
                next_marker: self.next_marker,
                ip_sets: self.ip_sets,
            }
        }
    }
}
impl ListIpSetsOutput {
    /// Creates a new builder-style object to manufacture [`ListIpSetsOutput`](crate::output::ListIpSetsOutput)
    pub fn builder() -> crate::output::list_ip_sets_output::Builder {
        crate::output::list_ip_sets_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAvailableManagedRuleGroupVersionsOutput {
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub next_marker: std::option::Option<std::string::String>,
    /// <p>The versions that are currently available for the specified managed rule group. </p>
    pub versions: std::option::Option<std::vec::Vec<crate::model::ManagedRuleGroupVersion>>,
}
impl ListAvailableManagedRuleGroupVersionsOutput {
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub fn next_marker(&self) -> std::option::Option<&str> {
        self.next_marker.as_deref()
    }
    /// <p>The versions that are currently available for the specified managed rule group. </p>
    pub fn versions(&self) -> std::option::Option<&[crate::model::ManagedRuleGroupVersion]> {
        self.versions.as_deref()
    }
}
impl std::fmt::Debug for ListAvailableManagedRuleGroupVersionsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAvailableManagedRuleGroupVersionsOutput");
        formatter.field("next_marker", &self.next_marker);
        formatter.field("versions", &self.versions);
        formatter.finish()
    }
}
/// See [`ListAvailableManagedRuleGroupVersionsOutput`](crate::output::ListAvailableManagedRuleGroupVersionsOutput)
pub mod list_available_managed_rule_group_versions_output {
    /// A builder for [`ListAvailableManagedRuleGroupVersionsOutput`](crate::output::ListAvailableManagedRuleGroupVersionsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_marker: std::option::Option<std::string::String>,
        pub(crate) versions:
            std::option::Option<std::vec::Vec<crate::model::ManagedRuleGroupVersion>>,
    }
    impl Builder {
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn next_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_marker = Some(input.into());
            self
        }
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn set_next_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_marker = input;
            self
        }
        /// Appends an item to `versions`.
        ///
        /// To override the contents of this collection use [`set_versions`](Self::set_versions).
        ///
        /// <p>The versions that are currently available for the specified managed rule group. </p>
        pub fn versions(mut self, input: crate::model::ManagedRuleGroupVersion) -> Self {
            let mut v = self.versions.unwrap_or_default();
            v.push(input);
            self.versions = Some(v);
            self
        }
        /// <p>The versions that are currently available for the specified managed rule group. </p>
        pub fn set_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ManagedRuleGroupVersion>>,
        ) -> Self {
            self.versions = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAvailableManagedRuleGroupVersionsOutput`](crate::output::ListAvailableManagedRuleGroupVersionsOutput)
        pub fn build(self) -> crate::output::ListAvailableManagedRuleGroupVersionsOutput {
            crate::output::ListAvailableManagedRuleGroupVersionsOutput {
                next_marker: self.next_marker,
                versions: self.versions,
            }
        }
    }
}
impl ListAvailableManagedRuleGroupVersionsOutput {
    /// Creates a new builder-style object to manufacture [`ListAvailableManagedRuleGroupVersionsOutput`](crate::output::ListAvailableManagedRuleGroupVersionsOutput)
    pub fn builder() -> crate::output::list_available_managed_rule_group_versions_output::Builder {
        crate::output::list_available_managed_rule_group_versions_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAvailableManagedRuleGroupsOutput {
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub next_marker: std::option::Option<std::string::String>,
    /// <p></p>
    pub managed_rule_groups:
        std::option::Option<std::vec::Vec<crate::model::ManagedRuleGroupSummary>>,
}
impl ListAvailableManagedRuleGroupsOutput {
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub fn next_marker(&self) -> std::option::Option<&str> {
        self.next_marker.as_deref()
    }
    /// <p></p>
    pub fn managed_rule_groups(
        &self,
    ) -> std::option::Option<&[crate::model::ManagedRuleGroupSummary]> {
        self.managed_rule_groups.as_deref()
    }
}
impl std::fmt::Debug for ListAvailableManagedRuleGroupsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAvailableManagedRuleGroupsOutput");
        formatter.field("next_marker", &self.next_marker);
        formatter.field("managed_rule_groups", &self.managed_rule_groups);
        formatter.finish()
    }
}
/// See [`ListAvailableManagedRuleGroupsOutput`](crate::output::ListAvailableManagedRuleGroupsOutput)
pub mod list_available_managed_rule_groups_output {
    /// A builder for [`ListAvailableManagedRuleGroupsOutput`](crate::output::ListAvailableManagedRuleGroupsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_marker: std::option::Option<std::string::String>,
        pub(crate) managed_rule_groups:
            std::option::Option<std::vec::Vec<crate::model::ManagedRuleGroupSummary>>,
    }
    impl Builder {
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn next_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_marker = Some(input.into());
            self
        }
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available for retrieval exceeds the limit, WAF returns a <code>NextMarker</code> value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn set_next_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_marker = input;
            self
        }
        /// Appends an item to `managed_rule_groups`.
        ///
        /// To override the contents of this collection use [`set_managed_rule_groups`](Self::set_managed_rule_groups).
        ///
        /// <p></p>
        pub fn managed_rule_groups(mut self, input: crate::model::ManagedRuleGroupSummary) -> Self {
            let mut v = self.managed_rule_groups.unwrap_or_default();
            v.push(input);
            self.managed_rule_groups = Some(v);
            self
        }
        /// <p></p>
        pub fn set_managed_rule_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ManagedRuleGroupSummary>>,
        ) -> Self {
            self.managed_rule_groups = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAvailableManagedRuleGroupsOutput`](crate::output::ListAvailableManagedRuleGroupsOutput)
        pub fn build(self) -> crate::output::ListAvailableManagedRuleGroupsOutput {
            crate::output::ListAvailableManagedRuleGroupsOutput {
                next_marker: self.next_marker,
                managed_rule_groups: self.managed_rule_groups,
            }
        }
    }
}
impl ListAvailableManagedRuleGroupsOutput {
    /// Creates a new builder-style object to manufacture [`ListAvailableManagedRuleGroupsOutput`](crate::output::ListAvailableManagedRuleGroupsOutput)
    pub fn builder() -> crate::output::list_available_managed_rule_groups_output::Builder {
        crate::output::list_available_managed_rule_groups_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetWebAclForResourceOutput {
    /// <p>The web ACL that is associated with the resource. If there is no associated resource, WAF returns a null web ACL.</p>
    pub web_acl: std::option::Option<crate::model::WebAcl>,
}
impl GetWebAclForResourceOutput {
    /// <p>The web ACL that is associated with the resource. If there is no associated resource, WAF returns a null web ACL.</p>
    pub fn web_acl(&self) -> std::option::Option<&crate::model::WebAcl> {
        self.web_acl.as_ref()
    }
}
impl std::fmt::Debug for GetWebAclForResourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetWebAclForResourceOutput");
        formatter.field("web_acl", &self.web_acl);
        formatter.finish()
    }
}
/// See [`GetWebAclForResourceOutput`](crate::output::GetWebAclForResourceOutput)
pub mod get_web_acl_for_resource_output {
    /// A builder for [`GetWebAclForResourceOutput`](crate::output::GetWebAclForResourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) web_acl: std::option::Option<crate::model::WebAcl>,
    }
    impl Builder {
        /// <p>The web ACL that is associated with the resource. If there is no associated resource, WAF returns a null web ACL.</p>
        pub fn web_acl(mut self, input: crate::model::WebAcl) -> Self {
            self.web_acl = Some(input);
            self
        }
        /// <p>The web ACL that is associated with the resource. If there is no associated resource, WAF returns a null web ACL.</p>
        pub fn set_web_acl(mut self, input: std::option::Option<crate::model::WebAcl>) -> Self {
            self.web_acl = input;
            self
        }
        /// Consumes the builder and constructs a [`GetWebAclForResourceOutput`](crate::output::GetWebAclForResourceOutput)
        pub fn build(self) -> crate::output::GetWebAclForResourceOutput {
            crate::output::GetWebAclForResourceOutput {
                web_acl: self.web_acl,
            }
        }
    }
}
impl GetWebAclForResourceOutput {
    /// Creates a new builder-style object to manufacture [`GetWebAclForResourceOutput`](crate::output::GetWebAclForResourceOutput)
    pub fn builder() -> crate::output::get_web_acl_for_resource_output::Builder {
        crate::output::get_web_acl_for_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetWebAclOutput {
    /// <p>The web ACL specification. You can modify the settings in this web ACL and use it to update this web ACL or create a new one.</p>
    pub web_acl: std::option::Option<crate::model::WebAcl>,
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub lock_token: std::option::Option<std::string::String>,
    /// <p>The URL to use in SDK integrations with Amazon Web Services managed rule groups. For example, you can use the integration SDKs with the account takeover prevention managed rule group <code>AWSManagedRulesATPRuleSet</code>. This is only populated if you are using a rule group in your web ACL that integrates with your applications in this way. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-application-integration.html">WAF client application integration</a> in the <i>WAF Developer Guide</i>.</p>
    pub application_integration_url: std::option::Option<std::string::String>,
}
impl GetWebAclOutput {
    /// <p>The web ACL specification. You can modify the settings in this web ACL and use it to update this web ACL or create a new one.</p>
    pub fn web_acl(&self) -> std::option::Option<&crate::model::WebAcl> {
        self.web_acl.as_ref()
    }
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub fn lock_token(&self) -> std::option::Option<&str> {
        self.lock_token.as_deref()
    }
    /// <p>The URL to use in SDK integrations with Amazon Web Services managed rule groups. For example, you can use the integration SDKs with the account takeover prevention managed rule group <code>AWSManagedRulesATPRuleSet</code>. This is only populated if you are using a rule group in your web ACL that integrates with your applications in this way. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-application-integration.html">WAF client application integration</a> in the <i>WAF Developer Guide</i>.</p>
    pub fn application_integration_url(&self) -> std::option::Option<&str> {
        self.application_integration_url.as_deref()
    }
}
impl std::fmt::Debug for GetWebAclOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetWebAclOutput");
        formatter.field("web_acl", &self.web_acl);
        formatter.field("lock_token", &self.lock_token);
        formatter.field(
            "application_integration_url",
            &self.application_integration_url,
        );
        formatter.finish()
    }
}
/// See [`GetWebAclOutput`](crate::output::GetWebAclOutput)
pub mod get_web_acl_output {
    /// A builder for [`GetWebAclOutput`](crate::output::GetWebAclOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) web_acl: std::option::Option<crate::model::WebAcl>,
        pub(crate) lock_token: std::option::Option<std::string::String>,
        pub(crate) application_integration_url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The web ACL specification. You can modify the settings in this web ACL and use it to update this web ACL or create a new one.</p>
        pub fn web_acl(mut self, input: crate::model::WebAcl) -> Self {
            self.web_acl = Some(input);
            self
        }
        /// <p>The web ACL specification. You can modify the settings in this web ACL and use it to update this web ACL or create a new one.</p>
        pub fn set_web_acl(mut self, input: std::option::Option<crate::model::WebAcl>) -> Self {
            self.web_acl = input;
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.lock_token = Some(input.into());
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lock_token = input;
            self
        }
        /// <p>The URL to use in SDK integrations with Amazon Web Services managed rule groups. For example, you can use the integration SDKs with the account takeover prevention managed rule group <code>AWSManagedRulesATPRuleSet</code>. This is only populated if you are using a rule group in your web ACL that integrates with your applications in this way. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-application-integration.html">WAF client application integration</a> in the <i>WAF Developer Guide</i>.</p>
        pub fn application_integration_url(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.application_integration_url = Some(input.into());
            self
        }
        /// <p>The URL to use in SDK integrations with Amazon Web Services managed rule groups. For example, you can use the integration SDKs with the account takeover prevention managed rule group <code>AWSManagedRulesATPRuleSet</code>. This is only populated if you are using a rule group in your web ACL that integrates with your applications in this way. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-application-integration.html">WAF client application integration</a> in the <i>WAF Developer Guide</i>.</p>
        pub fn set_application_integration_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_integration_url = input;
            self
        }
        /// Consumes the builder and constructs a [`GetWebAclOutput`](crate::output::GetWebAclOutput)
        pub fn build(self) -> crate::output::GetWebAclOutput {
            crate::output::GetWebAclOutput {
                web_acl: self.web_acl,
                lock_token: self.lock_token,
                application_integration_url: self.application_integration_url,
            }
        }
    }
}
impl GetWebAclOutput {
    /// Creates a new builder-style object to manufacture [`GetWebAclOutput`](crate::output::GetWebAclOutput)
    pub fn builder() -> crate::output::get_web_acl_output::Builder {
        crate::output::get_web_acl_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetSampledRequestsOutput {
    /// <p>A complex type that contains detailed information about each of the requests in the sample.</p>
    pub sampled_requests: std::option::Option<std::vec::Vec<crate::model::SampledHttpRequest>>,
    /// <p>The total number of requests from which <code>GetSampledRequests</code> got a sample of <code>MaxItems</code> requests. If <code>PopulationSize</code> is less than <code>MaxItems</code>, the sample includes every request that your Amazon Web Services resource received during the specified time range.</p>
    pub population_size: i64,
    /// <p>Usually, <code>TimeWindow</code> is the time range that you specified in the <code>GetSampledRequests</code> request. However, if your Amazon Web Services resource received more than 5,000 requests during the time range that you specified in the request, <code>GetSampledRequests</code> returns the time range for the first 5,000 requests. Times are in Coordinated Universal Time (UTC) format.</p>
    pub time_window: std::option::Option<crate::model::TimeWindow>,
}
impl GetSampledRequestsOutput {
    /// <p>A complex type that contains detailed information about each of the requests in the sample.</p>
    pub fn sampled_requests(&self) -> std::option::Option<&[crate::model::SampledHttpRequest]> {
        self.sampled_requests.as_deref()
    }
    /// <p>The total number of requests from which <code>GetSampledRequests</code> got a sample of <code>MaxItems</code> requests. If <code>PopulationSize</code> is less than <code>MaxItems</code>, the sample includes every request that your Amazon Web Services resource received during the specified time range.</p>
    pub fn population_size(&self) -> i64 {
        self.population_size
    }
    /// <p>Usually, <code>TimeWindow</code> is the time range that you specified in the <code>GetSampledRequests</code> request. However, if your Amazon Web Services resource received more than 5,000 requests during the time range that you specified in the request, <code>GetSampledRequests</code> returns the time range for the first 5,000 requests. Times are in Coordinated Universal Time (UTC) format.</p>
    pub fn time_window(&self) -> std::option::Option<&crate::model::TimeWindow> {
        self.time_window.as_ref()
    }
}
impl std::fmt::Debug for GetSampledRequestsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetSampledRequestsOutput");
        formatter.field("sampled_requests", &self.sampled_requests);
        formatter.field("population_size", &self.population_size);
        formatter.field("time_window", &self.time_window);
        formatter.finish()
    }
}
/// See [`GetSampledRequestsOutput`](crate::output::GetSampledRequestsOutput)
pub mod get_sampled_requests_output {
    /// A builder for [`GetSampledRequestsOutput`](crate::output::GetSampledRequestsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sampled_requests:
            std::option::Option<std::vec::Vec<crate::model::SampledHttpRequest>>,
        pub(crate) population_size: std::option::Option<i64>,
        pub(crate) time_window: std::option::Option<crate::model::TimeWindow>,
    }
    impl Builder {
        /// Appends an item to `sampled_requests`.
        ///
        /// To override the contents of this collection use [`set_sampled_requests`](Self::set_sampled_requests).
        ///
        /// <p>A complex type that contains detailed information about each of the requests in the sample.</p>
        pub fn sampled_requests(mut self, input: crate::model::SampledHttpRequest) -> Self {
            let mut v = self.sampled_requests.unwrap_or_default();
            v.push(input);
            self.sampled_requests = Some(v);
            self
        }
        /// <p>A complex type that contains detailed information about each of the requests in the sample.</p>
        pub fn set_sampled_requests(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SampledHttpRequest>>,
        ) -> Self {
            self.sampled_requests = input;
            self
        }
        /// <p>The total number of requests from which <code>GetSampledRequests</code> got a sample of <code>MaxItems</code> requests. If <code>PopulationSize</code> is less than <code>MaxItems</code>, the sample includes every request that your Amazon Web Services resource received during the specified time range.</p>
        pub fn population_size(mut self, input: i64) -> Self {
            self.population_size = Some(input);
            self
        }
        /// <p>The total number of requests from which <code>GetSampledRequests</code> got a sample of <code>MaxItems</code> requests. If <code>PopulationSize</code> is less than <code>MaxItems</code>, the sample includes every request that your Amazon Web Services resource received during the specified time range.</p>
        pub fn set_population_size(mut self, input: std::option::Option<i64>) -> Self {
            self.population_size = input;
            self
        }
        /// <p>Usually, <code>TimeWindow</code> is the time range that you specified in the <code>GetSampledRequests</code> request. However, if your Amazon Web Services resource received more than 5,000 requests during the time range that you specified in the request, <code>GetSampledRequests</code> returns the time range for the first 5,000 requests. Times are in Coordinated Universal Time (UTC) format.</p>
        pub fn time_window(mut self, input: crate::model::TimeWindow) -> Self {
            self.time_window = Some(input);
            self
        }
        /// <p>Usually, <code>TimeWindow</code> is the time range that you specified in the <code>GetSampledRequests</code> request. However, if your Amazon Web Services resource received more than 5,000 requests during the time range that you specified in the request, <code>GetSampledRequests</code> returns the time range for the first 5,000 requests. Times are in Coordinated Universal Time (UTC) format.</p>
        pub fn set_time_window(
            mut self,
            input: std::option::Option<crate::model::TimeWindow>,
        ) -> Self {
            self.time_window = input;
            self
        }
        /// Consumes the builder and constructs a [`GetSampledRequestsOutput`](crate::output::GetSampledRequestsOutput)
        pub fn build(self) -> crate::output::GetSampledRequestsOutput {
            crate::output::GetSampledRequestsOutput {
                sampled_requests: self.sampled_requests,
                population_size: self.population_size.unwrap_or_default(),
                time_window: self.time_window,
            }
        }
    }
}
impl GetSampledRequestsOutput {
    /// Creates a new builder-style object to manufacture [`GetSampledRequestsOutput`](crate::output::GetSampledRequestsOutput)
    pub fn builder() -> crate::output::get_sampled_requests_output::Builder {
        crate::output::get_sampled_requests_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRuleGroupOutput {
    /// <p></p>
    pub rule_group: std::option::Option<crate::model::RuleGroup>,
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub lock_token: std::option::Option<std::string::String>,
}
impl GetRuleGroupOutput {
    /// <p></p>
    pub fn rule_group(&self) -> std::option::Option<&crate::model::RuleGroup> {
        self.rule_group.as_ref()
    }
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub fn lock_token(&self) -> std::option::Option<&str> {
        self.lock_token.as_deref()
    }
}
impl std::fmt::Debug for GetRuleGroupOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRuleGroupOutput");
        formatter.field("rule_group", &self.rule_group);
        formatter.field("lock_token", &self.lock_token);
        formatter.finish()
    }
}
/// See [`GetRuleGroupOutput`](crate::output::GetRuleGroupOutput)
pub mod get_rule_group_output {
    /// A builder for [`GetRuleGroupOutput`](crate::output::GetRuleGroupOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_group: std::option::Option<crate::model::RuleGroup>,
        pub(crate) lock_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p></p>
        pub fn rule_group(mut self, input: crate::model::RuleGroup) -> Self {
            self.rule_group = Some(input);
            self
        }
        /// <p></p>
        pub fn set_rule_group(
            mut self,
            input: std::option::Option<crate::model::RuleGroup>,
        ) -> Self {
            self.rule_group = input;
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.lock_token = Some(input.into());
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lock_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRuleGroupOutput`](crate::output::GetRuleGroupOutput)
        pub fn build(self) -> crate::output::GetRuleGroupOutput {
            crate::output::GetRuleGroupOutput {
                rule_group: self.rule_group,
                lock_token: self.lock_token,
            }
        }
    }
}
impl GetRuleGroupOutput {
    /// Creates a new builder-style object to manufacture [`GetRuleGroupOutput`](crate::output::GetRuleGroupOutput)
    pub fn builder() -> crate::output::get_rule_group_output::Builder {
        crate::output::get_rule_group_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRegexPatternSetOutput {
    /// <p></p>
    pub regex_pattern_set: std::option::Option<crate::model::RegexPatternSet>,
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub lock_token: std::option::Option<std::string::String>,
}
impl GetRegexPatternSetOutput {
    /// <p></p>
    pub fn regex_pattern_set(&self) -> std::option::Option<&crate::model::RegexPatternSet> {
        self.regex_pattern_set.as_ref()
    }
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub fn lock_token(&self) -> std::option::Option<&str> {
        self.lock_token.as_deref()
    }
}
impl std::fmt::Debug for GetRegexPatternSetOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRegexPatternSetOutput");
        formatter.field("regex_pattern_set", &self.regex_pattern_set);
        formatter.field("lock_token", &self.lock_token);
        formatter.finish()
    }
}
/// See [`GetRegexPatternSetOutput`](crate::output::GetRegexPatternSetOutput)
pub mod get_regex_pattern_set_output {
    /// A builder for [`GetRegexPatternSetOutput`](crate::output::GetRegexPatternSetOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) regex_pattern_set: std::option::Option<crate::model::RegexPatternSet>,
        pub(crate) lock_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p></p>
        pub fn regex_pattern_set(mut self, input: crate::model::RegexPatternSet) -> Self {
            self.regex_pattern_set = Some(input);
            self
        }
        /// <p></p>
        pub fn set_regex_pattern_set(
            mut self,
            input: std::option::Option<crate::model::RegexPatternSet>,
        ) -> Self {
            self.regex_pattern_set = input;
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.lock_token = Some(input.into());
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lock_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRegexPatternSetOutput`](crate::output::GetRegexPatternSetOutput)
        pub fn build(self) -> crate::output::GetRegexPatternSetOutput {
            crate::output::GetRegexPatternSetOutput {
                regex_pattern_set: self.regex_pattern_set,
                lock_token: self.lock_token,
            }
        }
    }
}
impl GetRegexPatternSetOutput {
    /// Creates a new builder-style object to manufacture [`GetRegexPatternSetOutput`](crate::output::GetRegexPatternSetOutput)
    pub fn builder() -> crate::output::get_regex_pattern_set_output::Builder {
        crate::output::get_regex_pattern_set_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRateBasedStatementManagedKeysOutput {
    /// <p>The keys that are of Internet Protocol version 4 (IPv4). </p>
    pub managed_keys_ipv4: std::option::Option<crate::model::RateBasedStatementManagedKeysIpSet>,
    /// <p>The keys that are of Internet Protocol version 6 (IPv6). </p>
    pub managed_keys_ipv6: std::option::Option<crate::model::RateBasedStatementManagedKeysIpSet>,
}
impl GetRateBasedStatementManagedKeysOutput {
    /// <p>The keys that are of Internet Protocol version 4 (IPv4). </p>
    pub fn managed_keys_ipv4(
        &self,
    ) -> std::option::Option<&crate::model::RateBasedStatementManagedKeysIpSet> {
        self.managed_keys_ipv4.as_ref()
    }
    /// <p>The keys that are of Internet Protocol version 6 (IPv6). </p>
    pub fn managed_keys_ipv6(
        &self,
    ) -> std::option::Option<&crate::model::RateBasedStatementManagedKeysIpSet> {
        self.managed_keys_ipv6.as_ref()
    }
}
impl std::fmt::Debug for GetRateBasedStatementManagedKeysOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRateBasedStatementManagedKeysOutput");
        formatter.field("managed_keys_ipv4", &self.managed_keys_ipv4);
        formatter.field("managed_keys_ipv6", &self.managed_keys_ipv6);
        formatter.finish()
    }
}
/// See [`GetRateBasedStatementManagedKeysOutput`](crate::output::GetRateBasedStatementManagedKeysOutput)
pub mod get_rate_based_statement_managed_keys_output {
    /// A builder for [`GetRateBasedStatementManagedKeysOutput`](crate::output::GetRateBasedStatementManagedKeysOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) managed_keys_ipv4:
            std::option::Option<crate::model::RateBasedStatementManagedKeysIpSet>,
        pub(crate) managed_keys_ipv6:
            std::option::Option<crate::model::RateBasedStatementManagedKeysIpSet>,
    }
    impl Builder {
        /// <p>The keys that are of Internet Protocol version 4 (IPv4). </p>
        pub fn managed_keys_ipv4(
            mut self,
            input: crate::model::RateBasedStatementManagedKeysIpSet,
        ) -> Self {
            self.managed_keys_ipv4 = Some(input);
            self
        }
        /// <p>The keys that are of Internet Protocol version 4 (IPv4). </p>
        pub fn set_managed_keys_ipv4(
            mut self,
            input: std::option::Option<crate::model::RateBasedStatementManagedKeysIpSet>,
        ) -> Self {
            self.managed_keys_ipv4 = input;
            self
        }
        /// <p>The keys that are of Internet Protocol version 6 (IPv6). </p>
        pub fn managed_keys_ipv6(
            mut self,
            input: crate::model::RateBasedStatementManagedKeysIpSet,
        ) -> Self {
            self.managed_keys_ipv6 = Some(input);
            self
        }
        /// <p>The keys that are of Internet Protocol version 6 (IPv6). </p>
        pub fn set_managed_keys_ipv6(
            mut self,
            input: std::option::Option<crate::model::RateBasedStatementManagedKeysIpSet>,
        ) -> Self {
            self.managed_keys_ipv6 = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRateBasedStatementManagedKeysOutput`](crate::output::GetRateBasedStatementManagedKeysOutput)
        pub fn build(self) -> crate::output::GetRateBasedStatementManagedKeysOutput {
            crate::output::GetRateBasedStatementManagedKeysOutput {
                managed_keys_ipv4: self.managed_keys_ipv4,
                managed_keys_ipv6: self.managed_keys_ipv6,
            }
        }
    }
}
impl GetRateBasedStatementManagedKeysOutput {
    /// Creates a new builder-style object to manufacture [`GetRateBasedStatementManagedKeysOutput`](crate::output::GetRateBasedStatementManagedKeysOutput)
    pub fn builder() -> crate::output::get_rate_based_statement_managed_keys_output::Builder {
        crate::output::get_rate_based_statement_managed_keys_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPermissionPolicyOutput {
    /// <p>The IAM policy that is attached to the specified rule group.</p>
    pub policy: std::option::Option<std::string::String>,
}
impl GetPermissionPolicyOutput {
    /// <p>The IAM policy that is attached to the specified rule group.</p>
    pub fn policy(&self) -> std::option::Option<&str> {
        self.policy.as_deref()
    }
}
impl std::fmt::Debug for GetPermissionPolicyOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetPermissionPolicyOutput");
        formatter.field("policy", &self.policy);
        formatter.finish()
    }
}
/// See [`GetPermissionPolicyOutput`](crate::output::GetPermissionPolicyOutput)
pub mod get_permission_policy_output {
    /// A builder for [`GetPermissionPolicyOutput`](crate::output::GetPermissionPolicyOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IAM policy that is attached to the specified rule group.</p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy = Some(input.into());
            self
        }
        /// <p>The IAM policy that is attached to the specified rule group.</p>
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy = input;
            self
        }
        /// Consumes the builder and constructs a [`GetPermissionPolicyOutput`](crate::output::GetPermissionPolicyOutput)
        pub fn build(self) -> crate::output::GetPermissionPolicyOutput {
            crate::output::GetPermissionPolicyOutput {
                policy: self.policy,
            }
        }
    }
}
impl GetPermissionPolicyOutput {
    /// Creates a new builder-style object to manufacture [`GetPermissionPolicyOutput`](crate::output::GetPermissionPolicyOutput)
    pub fn builder() -> crate::output::get_permission_policy_output::Builder {
        crate::output::get_permission_policy_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetMobileSdkReleaseOutput {
    /// <p>Information for a specified SDK release, including release notes and tags.</p>
    pub mobile_sdk_release: std::option::Option<crate::model::MobileSdkRelease>,
}
impl GetMobileSdkReleaseOutput {
    /// <p>Information for a specified SDK release, including release notes and tags.</p>
    pub fn mobile_sdk_release(&self) -> std::option::Option<&crate::model::MobileSdkRelease> {
        self.mobile_sdk_release.as_ref()
    }
}
impl std::fmt::Debug for GetMobileSdkReleaseOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetMobileSdkReleaseOutput");
        formatter.field("mobile_sdk_release", &self.mobile_sdk_release);
        formatter.finish()
    }
}
/// See [`GetMobileSdkReleaseOutput`](crate::output::GetMobileSdkReleaseOutput)
pub mod get_mobile_sdk_release_output {
    /// A builder for [`GetMobileSdkReleaseOutput`](crate::output::GetMobileSdkReleaseOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mobile_sdk_release: std::option::Option<crate::model::MobileSdkRelease>,
    }
    impl Builder {
        /// <p>Information for a specified SDK release, including release notes and tags.</p>
        pub fn mobile_sdk_release(mut self, input: crate::model::MobileSdkRelease) -> Self {
            self.mobile_sdk_release = Some(input);
            self
        }
        /// <p>Information for a specified SDK release, including release notes and tags.</p>
        pub fn set_mobile_sdk_release(
            mut self,
            input: std::option::Option<crate::model::MobileSdkRelease>,
        ) -> Self {
            self.mobile_sdk_release = input;
            self
        }
        /// Consumes the builder and constructs a [`GetMobileSdkReleaseOutput`](crate::output::GetMobileSdkReleaseOutput)
        pub fn build(self) -> crate::output::GetMobileSdkReleaseOutput {
            crate::output::GetMobileSdkReleaseOutput {
                mobile_sdk_release: self.mobile_sdk_release,
            }
        }
    }
}
impl GetMobileSdkReleaseOutput {
    /// Creates a new builder-style object to manufacture [`GetMobileSdkReleaseOutput`](crate::output::GetMobileSdkReleaseOutput)
    pub fn builder() -> crate::output::get_mobile_sdk_release_output::Builder {
        crate::output::get_mobile_sdk_release_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetManagedRuleSetOutput {
    /// <p>The managed rule set that you requested. </p>
    pub managed_rule_set: std::option::Option<crate::model::ManagedRuleSet>,
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub lock_token: std::option::Option<std::string::String>,
}
impl GetManagedRuleSetOutput {
    /// <p>The managed rule set that you requested. </p>
    pub fn managed_rule_set(&self) -> std::option::Option<&crate::model::ManagedRuleSet> {
        self.managed_rule_set.as_ref()
    }
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub fn lock_token(&self) -> std::option::Option<&str> {
        self.lock_token.as_deref()
    }
}
impl std::fmt::Debug for GetManagedRuleSetOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetManagedRuleSetOutput");
        formatter.field("managed_rule_set", &self.managed_rule_set);
        formatter.field("lock_token", &self.lock_token);
        formatter.finish()
    }
}
/// See [`GetManagedRuleSetOutput`](crate::output::GetManagedRuleSetOutput)
pub mod get_managed_rule_set_output {
    /// A builder for [`GetManagedRuleSetOutput`](crate::output::GetManagedRuleSetOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) managed_rule_set: std::option::Option<crate::model::ManagedRuleSet>,
        pub(crate) lock_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The managed rule set that you requested. </p>
        pub fn managed_rule_set(mut self, input: crate::model::ManagedRuleSet) -> Self {
            self.managed_rule_set = Some(input);
            self
        }
        /// <p>The managed rule set that you requested. </p>
        pub fn set_managed_rule_set(
            mut self,
            input: std::option::Option<crate::model::ManagedRuleSet>,
        ) -> Self {
            self.managed_rule_set = input;
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.lock_token = Some(input.into());
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lock_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetManagedRuleSetOutput`](crate::output::GetManagedRuleSetOutput)
        pub fn build(self) -> crate::output::GetManagedRuleSetOutput {
            crate::output::GetManagedRuleSetOutput {
                managed_rule_set: self.managed_rule_set,
                lock_token: self.lock_token,
            }
        }
    }
}
impl GetManagedRuleSetOutput {
    /// Creates a new builder-style object to manufacture [`GetManagedRuleSetOutput`](crate::output::GetManagedRuleSetOutput)
    pub fn builder() -> crate::output::get_managed_rule_set_output::Builder {
        crate::output::get_managed_rule_set_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLoggingConfigurationOutput {
    /// <p>The <code>LoggingConfiguration</code> for the specified web ACL.</p>
    pub logging_configuration: std::option::Option<crate::model::LoggingConfiguration>,
}
impl GetLoggingConfigurationOutput {
    /// <p>The <code>LoggingConfiguration</code> for the specified web ACL.</p>
    pub fn logging_configuration(
        &self,
    ) -> std::option::Option<&crate::model::LoggingConfiguration> {
        self.logging_configuration.as_ref()
    }
}
impl std::fmt::Debug for GetLoggingConfigurationOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLoggingConfigurationOutput");
        formatter.field("logging_configuration", &self.logging_configuration);
        formatter.finish()
    }
}
/// See [`GetLoggingConfigurationOutput`](crate::output::GetLoggingConfigurationOutput)
pub mod get_logging_configuration_output {
    /// A builder for [`GetLoggingConfigurationOutput`](crate::output::GetLoggingConfigurationOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) logging_configuration: std::option::Option<crate::model::LoggingConfiguration>,
    }
    impl Builder {
        /// <p>The <code>LoggingConfiguration</code> for the specified web ACL.</p>
        pub fn logging_configuration(mut self, input: crate::model::LoggingConfiguration) -> Self {
            self.logging_configuration = Some(input);
            self
        }
        /// <p>The <code>LoggingConfiguration</code> for the specified web ACL.</p>
        pub fn set_logging_configuration(
            mut self,
            input: std::option::Option<crate::model::LoggingConfiguration>,
        ) -> Self {
            self.logging_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`GetLoggingConfigurationOutput`](crate::output::GetLoggingConfigurationOutput)
        pub fn build(self) -> crate::output::GetLoggingConfigurationOutput {
            crate::output::GetLoggingConfigurationOutput {
                logging_configuration: self.logging_configuration,
            }
        }
    }
}
impl GetLoggingConfigurationOutput {
    /// Creates a new builder-style object to manufacture [`GetLoggingConfigurationOutput`](crate::output::GetLoggingConfigurationOutput)
    pub fn builder() -> crate::output::get_logging_configuration_output::Builder {
        crate::output::get_logging_configuration_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetIpSetOutput {
    /// <p></p>
    pub ip_set: std::option::Option<crate::model::IpSet>,
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub lock_token: std::option::Option<std::string::String>,
}
impl GetIpSetOutput {
    /// <p></p>
    pub fn ip_set(&self) -> std::option::Option<&crate::model::IpSet> {
        self.ip_set.as_ref()
    }
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub fn lock_token(&self) -> std::option::Option<&str> {
        self.lock_token.as_deref()
    }
}
impl std::fmt::Debug for GetIpSetOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetIpSetOutput");
        formatter.field("ip_set", &self.ip_set);
        formatter.field("lock_token", &self.lock_token);
        formatter.finish()
    }
}
/// See [`GetIpSetOutput`](crate::output::GetIpSetOutput)
pub mod get_ip_set_output {
    /// A builder for [`GetIpSetOutput`](crate::output::GetIpSetOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ip_set: std::option::Option<crate::model::IpSet>,
        pub(crate) lock_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p></p>
        pub fn ip_set(mut self, input: crate::model::IpSet) -> Self {
            self.ip_set = Some(input);
            self
        }
        /// <p></p>
        pub fn set_ip_set(mut self, input: std::option::Option<crate::model::IpSet>) -> Self {
            self.ip_set = input;
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.lock_token = Some(input.into());
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lock_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetIpSetOutput`](crate::output::GetIpSetOutput)
        pub fn build(self) -> crate::output::GetIpSetOutput {
            crate::output::GetIpSetOutput {
                ip_set: self.ip_set,
                lock_token: self.lock_token,
            }
        }
    }
}
impl GetIpSetOutput {
    /// Creates a new builder-style object to manufacture [`GetIpSetOutput`](crate::output::GetIpSetOutput)
    pub fn builder() -> crate::output::get_ip_set_output::Builder {
        crate::output::get_ip_set_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GenerateMobileSdkReleaseUrlOutput {
    /// <p>The presigned download URL for the specified SDK release.</p>
    pub url: std::option::Option<std::string::String>,
}
impl GenerateMobileSdkReleaseUrlOutput {
    /// <p>The presigned download URL for the specified SDK release.</p>
    pub fn url(&self) -> std::option::Option<&str> {
        self.url.as_deref()
    }
}
impl std::fmt::Debug for GenerateMobileSdkReleaseUrlOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GenerateMobileSdkReleaseUrlOutput");
        formatter.field("url", &self.url);
        formatter.finish()
    }
}
/// See [`GenerateMobileSdkReleaseUrlOutput`](crate::output::GenerateMobileSdkReleaseUrlOutput)
pub mod generate_mobile_sdk_release_url_output {
    /// A builder for [`GenerateMobileSdkReleaseUrlOutput`](crate::output::GenerateMobileSdkReleaseUrlOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The presigned download URL for the specified SDK release.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        /// <p>The presigned download URL for the specified SDK release.</p>
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// Consumes the builder and constructs a [`GenerateMobileSdkReleaseUrlOutput`](crate::output::GenerateMobileSdkReleaseUrlOutput)
        pub fn build(self) -> crate::output::GenerateMobileSdkReleaseUrlOutput {
            crate::output::GenerateMobileSdkReleaseUrlOutput { url: self.url }
        }
    }
}
impl GenerateMobileSdkReleaseUrlOutput {
    /// Creates a new builder-style object to manufacture [`GenerateMobileSdkReleaseUrlOutput`](crate::output::GenerateMobileSdkReleaseUrlOutput)
    pub fn builder() -> crate::output::generate_mobile_sdk_release_url_output::Builder {
        crate::output::generate_mobile_sdk_release_url_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisassociateWebAclOutput {}
impl std::fmt::Debug for DisassociateWebAclOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisassociateWebAclOutput");
        formatter.finish()
    }
}
/// See [`DisassociateWebAclOutput`](crate::output::DisassociateWebAclOutput)
pub mod disassociate_web_acl_output {
    /// A builder for [`DisassociateWebAclOutput`](crate::output::DisassociateWebAclOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DisassociateWebAclOutput`](crate::output::DisassociateWebAclOutput)
        pub fn build(self) -> crate::output::DisassociateWebAclOutput {
            crate::output::DisassociateWebAclOutput {}
        }
    }
}
impl DisassociateWebAclOutput {
    /// Creates a new builder-style object to manufacture [`DisassociateWebAclOutput`](crate::output::DisassociateWebAclOutput)
    pub fn builder() -> crate::output::disassociate_web_acl_output::Builder {
        crate::output::disassociate_web_acl_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeManagedRuleGroupOutput {
    /// <p>The managed rule group's version. </p>
    pub version_name: std::option::Option<std::string::String>,
    /// <p>The Amazon resource name (ARN) of the Amazon Simple Notification Service SNS topic that's used to record changes to the managed rule group. You can subscribe to the SNS topic to receive notifications when the managed rule group is modified, such as for new versions and for version expiration. For more information, see the <a href="https://docs.aws.amazon.com/sns/latest/dg/welcome.html">Amazon Simple Notification Service Developer Guide</a>.</p>
    pub sns_topic_arn: std::option::Option<std::string::String>,
    /// <p>The web ACL capacity units (WCUs) required for this rule group. WAF uses web ACL capacity units (WCU) to calculate and control the operating resources that are used to run your rules, rule groups, and web ACLs. WAF calculates capacity differently for each rule type, to reflect each rule's relative cost. Rule group capacity is fixed at creation, so users can plan their web ACL WCU usage when they use a rule group. The WCU limit for web ACLs is 1,500. </p>
    pub capacity: i64,
    /// <p></p>
    pub rules: std::option::Option<std::vec::Vec<crate::model::RuleSummary>>,
    /// <p>The label namespace prefix for this rule group. All labels added by rules in this rule group have this prefix. </p>
    /// <ul>
    /// <li> <p>The syntax for the label namespace prefix for a managed rule group is the following: </p> <p> <code>awswaf:managed:
    /// <vendor>
    /// :
    /// <rule group name></rule>
    /// </vendor></code>:</p> </li>
    /// <li> <p>When a rule with a label matches a web request, WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p> <p> <code><label namespace>:<label from rule></label></label></code> </p> </li>
    /// </ul>
    pub label_namespace: std::option::Option<std::string::String>,
    /// <p>The labels that one or more rules in this rule group add to matching web requests. These labels are defined in the <code>RuleLabels</code> for a <code>Rule</code>.</p>
    pub available_labels: std::option::Option<std::vec::Vec<crate::model::LabelSummary>>,
    /// <p>The labels that one or more rules in this rule group match against in label match statements. These labels are defined in a <code>LabelMatchStatement</code> specification, in the <code>Statement</code> definition of a rule. </p>
    pub consumed_labels: std::option::Option<std::vec::Vec<crate::model::LabelSummary>>,
}
impl DescribeManagedRuleGroupOutput {
    /// <p>The managed rule group's version. </p>
    pub fn version_name(&self) -> std::option::Option<&str> {
        self.version_name.as_deref()
    }
    /// <p>The Amazon resource name (ARN) of the Amazon Simple Notification Service SNS topic that's used to record changes to the managed rule group. You can subscribe to the SNS topic to receive notifications when the managed rule group is modified, such as for new versions and for version expiration. For more information, see the <a href="https://docs.aws.amazon.com/sns/latest/dg/welcome.html">Amazon Simple Notification Service Developer Guide</a>.</p>
    pub fn sns_topic_arn(&self) -> std::option::Option<&str> {
        self.sns_topic_arn.as_deref()
    }
    /// <p>The web ACL capacity units (WCUs) required for this rule group. WAF uses web ACL capacity units (WCU) to calculate and control the operating resources that are used to run your rules, rule groups, and web ACLs. WAF calculates capacity differently for each rule type, to reflect each rule's relative cost. Rule group capacity is fixed at creation, so users can plan their web ACL WCU usage when they use a rule group. The WCU limit for web ACLs is 1,500. </p>
    pub fn capacity(&self) -> i64 {
        self.capacity
    }
    /// <p></p>
    pub fn rules(&self) -> std::option::Option<&[crate::model::RuleSummary]> {
        self.rules.as_deref()
    }
    /// <p>The label namespace prefix for this rule group. All labels added by rules in this rule group have this prefix. </p>
    /// <ul>
    /// <li> <p>The syntax for the label namespace prefix for a managed rule group is the following: </p> <p> <code>awswaf:managed:
    /// <vendor>
    /// :
    /// <rule group name></rule>
    /// </vendor></code>:</p> </li>
    /// <li> <p>When a rule with a label matches a web request, WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p> <p> <code><label namespace>:<label from rule></label></label></code> </p> </li>
    /// </ul>
    pub fn label_namespace(&self) -> std::option::Option<&str> {
        self.label_namespace.as_deref()
    }
    /// <p>The labels that one or more rules in this rule group add to matching web requests. These labels are defined in the <code>RuleLabels</code> for a <code>Rule</code>.</p>
    pub fn available_labels(&self) -> std::option::Option<&[crate::model::LabelSummary]> {
        self.available_labels.as_deref()
    }
    /// <p>The labels that one or more rules in this rule group match against in label match statements. These labels are defined in a <code>LabelMatchStatement</code> specification, in the <code>Statement</code> definition of a rule. </p>
    pub fn consumed_labels(&self) -> std::option::Option<&[crate::model::LabelSummary]> {
        self.consumed_labels.as_deref()
    }
}
impl std::fmt::Debug for DescribeManagedRuleGroupOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeManagedRuleGroupOutput");
        formatter.field("version_name", &self.version_name);
        formatter.field("sns_topic_arn", &self.sns_topic_arn);
        formatter.field("capacity", &self.capacity);
        formatter.field("rules", &self.rules);
        formatter.field("label_namespace", &self.label_namespace);
        formatter.field("available_labels", &self.available_labels);
        formatter.field("consumed_labels", &self.consumed_labels);
        formatter.finish()
    }
}
/// See [`DescribeManagedRuleGroupOutput`](crate::output::DescribeManagedRuleGroupOutput)
pub mod describe_managed_rule_group_output {
    /// A builder for [`DescribeManagedRuleGroupOutput`](crate::output::DescribeManagedRuleGroupOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) version_name: std::option::Option<std::string::String>,
        pub(crate) sns_topic_arn: std::option::Option<std::string::String>,
        pub(crate) capacity: std::option::Option<i64>,
        pub(crate) rules: std::option::Option<std::vec::Vec<crate::model::RuleSummary>>,
        pub(crate) label_namespace: std::option::Option<std::string::String>,
        pub(crate) available_labels: std::option::Option<std::vec::Vec<crate::model::LabelSummary>>,
        pub(crate) consumed_labels: std::option::Option<std::vec::Vec<crate::model::LabelSummary>>,
    }
    impl Builder {
        /// <p>The managed rule group's version. </p>
        pub fn version_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_name = Some(input.into());
            self
        }
        /// <p>The managed rule group's version. </p>
        pub fn set_version_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_name = input;
            self
        }
        /// <p>The Amazon resource name (ARN) of the Amazon Simple Notification Service SNS topic that's used to record changes to the managed rule group. You can subscribe to the SNS topic to receive notifications when the managed rule group is modified, such as for new versions and for version expiration. For more information, see the <a href="https://docs.aws.amazon.com/sns/latest/dg/welcome.html">Amazon Simple Notification Service Developer Guide</a>.</p>
        pub fn sns_topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.sns_topic_arn = Some(input.into());
            self
        }
        /// <p>The Amazon resource name (ARN) of the Amazon Simple Notification Service SNS topic that's used to record changes to the managed rule group. You can subscribe to the SNS topic to receive notifications when the managed rule group is modified, such as for new versions and for version expiration. For more information, see the <a href="https://docs.aws.amazon.com/sns/latest/dg/welcome.html">Amazon Simple Notification Service Developer Guide</a>.</p>
        pub fn set_sns_topic_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sns_topic_arn = input;
            self
        }
        /// <p>The web ACL capacity units (WCUs) required for this rule group. WAF uses web ACL capacity units (WCU) to calculate and control the operating resources that are used to run your rules, rule groups, and web ACLs. WAF calculates capacity differently for each rule type, to reflect each rule's relative cost. Rule group capacity is fixed at creation, so users can plan their web ACL WCU usage when they use a rule group. The WCU limit for web ACLs is 1,500. </p>
        pub fn capacity(mut self, input: i64) -> Self {
            self.capacity = Some(input);
            self
        }
        /// <p>The web ACL capacity units (WCUs) required for this rule group. WAF uses web ACL capacity units (WCU) to calculate and control the operating resources that are used to run your rules, rule groups, and web ACLs. WAF calculates capacity differently for each rule type, to reflect each rule's relative cost. Rule group capacity is fixed at creation, so users can plan their web ACL WCU usage when they use a rule group. The WCU limit for web ACLs is 1,500. </p>
        pub fn set_capacity(mut self, input: std::option::Option<i64>) -> Self {
            self.capacity = input;
            self
        }
        /// Appends an item to `rules`.
        ///
        /// To override the contents of this collection use [`set_rules`](Self::set_rules).
        ///
        /// <p></p>
        pub fn rules(mut self, input: crate::model::RuleSummary) -> Self {
            let mut v = self.rules.unwrap_or_default();
            v.push(input);
            self.rules = Some(v);
            self
        }
        /// <p></p>
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RuleSummary>>,
        ) -> Self {
            self.rules = input;
            self
        }
        /// <p>The label namespace prefix for this rule group. All labels added by rules in this rule group have this prefix. </p>
        /// <ul>
        /// <li> <p>The syntax for the label namespace prefix for a managed rule group is the following: </p> <p> <code>awswaf:managed:
        /// <vendor>
        /// :
        /// <rule group name></rule>
        /// </vendor></code>:</p> </li>
        /// <li> <p>When a rule with a label matches a web request, WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p> <p> <code><label namespace>:<label from rule></label></label></code> </p> </li>
        /// </ul>
        pub fn label_namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.label_namespace = Some(input.into());
            self
        }
        /// <p>The label namespace prefix for this rule group. All labels added by rules in this rule group have this prefix. </p>
        /// <ul>
        /// <li> <p>The syntax for the label namespace prefix for a managed rule group is the following: </p> <p> <code>awswaf:managed:
        /// <vendor>
        /// :
        /// <rule group name></rule>
        /// </vendor></code>:</p> </li>
        /// <li> <p>When a rule with a label matches a web request, WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p> <p> <code><label namespace>:<label from rule></label></label></code> </p> </li>
        /// </ul>
        pub fn set_label_namespace(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.label_namespace = input;
            self
        }
        /// Appends an item to `available_labels`.
        ///
        /// To override the contents of this collection use [`set_available_labels`](Self::set_available_labels).
        ///
        /// <p>The labels that one or more rules in this rule group add to matching web requests. These labels are defined in the <code>RuleLabels</code> for a <code>Rule</code>.</p>
        pub fn available_labels(mut self, input: crate::model::LabelSummary) -> Self {
            let mut v = self.available_labels.unwrap_or_default();
            v.push(input);
            self.available_labels = Some(v);
            self
        }
        /// <p>The labels that one or more rules in this rule group add to matching web requests. These labels are defined in the <code>RuleLabels</code> for a <code>Rule</code>.</p>
        pub fn set_available_labels(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LabelSummary>>,
        ) -> Self {
            self.available_labels = input;
            self
        }
        /// Appends an item to `consumed_labels`.
        ///
        /// To override the contents of this collection use [`set_consumed_labels`](Self::set_consumed_labels).
        ///
        /// <p>The labels that one or more rules in this rule group match against in label match statements. These labels are defined in a <code>LabelMatchStatement</code> specification, in the <code>Statement</code> definition of a rule. </p>
        pub fn consumed_labels(mut self, input: crate::model::LabelSummary) -> Self {
            let mut v = self.consumed_labels.unwrap_or_default();
            v.push(input);
            self.consumed_labels = Some(v);
            self
        }
        /// <p>The labels that one or more rules in this rule group match against in label match statements. These labels are defined in a <code>LabelMatchStatement</code> specification, in the <code>Statement</code> definition of a rule. </p>
        pub fn set_consumed_labels(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LabelSummary>>,
        ) -> Self {
            self.consumed_labels = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeManagedRuleGroupOutput`](crate::output::DescribeManagedRuleGroupOutput)
        pub fn build(self) -> crate::output::DescribeManagedRuleGroupOutput {
            crate::output::DescribeManagedRuleGroupOutput {
                version_name: self.version_name,
                sns_topic_arn: self.sns_topic_arn,
                capacity: self.capacity.unwrap_or_default(),
                rules: self.rules,
                label_namespace: self.label_namespace,
                available_labels: self.available_labels,
                consumed_labels: self.consumed_labels,
            }
        }
    }
}
impl DescribeManagedRuleGroupOutput {
    /// Creates a new builder-style object to manufacture [`DescribeManagedRuleGroupOutput`](crate::output::DescribeManagedRuleGroupOutput)
    pub fn builder() -> crate::output::describe_managed_rule_group_output::Builder {
        crate::output::describe_managed_rule_group_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteWebAclOutput {}
impl std::fmt::Debug for DeleteWebAclOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteWebAclOutput");
        formatter.finish()
    }
}
/// See [`DeleteWebAclOutput`](crate::output::DeleteWebAclOutput)
pub mod delete_web_acl_output {
    /// A builder for [`DeleteWebAclOutput`](crate::output::DeleteWebAclOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteWebAclOutput`](crate::output::DeleteWebAclOutput)
        pub fn build(self) -> crate::output::DeleteWebAclOutput {
            crate::output::DeleteWebAclOutput {}
        }
    }
}
impl DeleteWebAclOutput {
    /// Creates a new builder-style object to manufacture [`DeleteWebAclOutput`](crate::output::DeleteWebAclOutput)
    pub fn builder() -> crate::output::delete_web_acl_output::Builder {
        crate::output::delete_web_acl_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteRuleGroupOutput {}
impl std::fmt::Debug for DeleteRuleGroupOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteRuleGroupOutput");
        formatter.finish()
    }
}
/// See [`DeleteRuleGroupOutput`](crate::output::DeleteRuleGroupOutput)
pub mod delete_rule_group_output {
    /// A builder for [`DeleteRuleGroupOutput`](crate::output::DeleteRuleGroupOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteRuleGroupOutput`](crate::output::DeleteRuleGroupOutput)
        pub fn build(self) -> crate::output::DeleteRuleGroupOutput {
            crate::output::DeleteRuleGroupOutput {}
        }
    }
}
impl DeleteRuleGroupOutput {
    /// Creates a new builder-style object to manufacture [`DeleteRuleGroupOutput`](crate::output::DeleteRuleGroupOutput)
    pub fn builder() -> crate::output::delete_rule_group_output::Builder {
        crate::output::delete_rule_group_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteRegexPatternSetOutput {}
impl std::fmt::Debug for DeleteRegexPatternSetOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteRegexPatternSetOutput");
        formatter.finish()
    }
}
/// See [`DeleteRegexPatternSetOutput`](crate::output::DeleteRegexPatternSetOutput)
pub mod delete_regex_pattern_set_output {
    /// A builder for [`DeleteRegexPatternSetOutput`](crate::output::DeleteRegexPatternSetOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteRegexPatternSetOutput`](crate::output::DeleteRegexPatternSetOutput)
        pub fn build(self) -> crate::output::DeleteRegexPatternSetOutput {
            crate::output::DeleteRegexPatternSetOutput {}
        }
    }
}
impl DeleteRegexPatternSetOutput {
    /// Creates a new builder-style object to manufacture [`DeleteRegexPatternSetOutput`](crate::output::DeleteRegexPatternSetOutput)
    pub fn builder() -> crate::output::delete_regex_pattern_set_output::Builder {
        crate::output::delete_regex_pattern_set_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeletePermissionPolicyOutput {}
impl std::fmt::Debug for DeletePermissionPolicyOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeletePermissionPolicyOutput");
        formatter.finish()
    }
}
/// See [`DeletePermissionPolicyOutput`](crate::output::DeletePermissionPolicyOutput)
pub mod delete_permission_policy_output {
    /// A builder for [`DeletePermissionPolicyOutput`](crate::output::DeletePermissionPolicyOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeletePermissionPolicyOutput`](crate::output::DeletePermissionPolicyOutput)
        pub fn build(self) -> crate::output::DeletePermissionPolicyOutput {
            crate::output::DeletePermissionPolicyOutput {}
        }
    }
}
impl DeletePermissionPolicyOutput {
    /// Creates a new builder-style object to manufacture [`DeletePermissionPolicyOutput`](crate::output::DeletePermissionPolicyOutput)
    pub fn builder() -> crate::output::delete_permission_policy_output::Builder {
        crate::output::delete_permission_policy_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteLoggingConfigurationOutput {}
impl std::fmt::Debug for DeleteLoggingConfigurationOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteLoggingConfigurationOutput");
        formatter.finish()
    }
}
/// See [`DeleteLoggingConfigurationOutput`](crate::output::DeleteLoggingConfigurationOutput)
pub mod delete_logging_configuration_output {
    /// A builder for [`DeleteLoggingConfigurationOutput`](crate::output::DeleteLoggingConfigurationOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteLoggingConfigurationOutput`](crate::output::DeleteLoggingConfigurationOutput)
        pub fn build(self) -> crate::output::DeleteLoggingConfigurationOutput {
            crate::output::DeleteLoggingConfigurationOutput {}
        }
    }
}
impl DeleteLoggingConfigurationOutput {
    /// Creates a new builder-style object to manufacture [`DeleteLoggingConfigurationOutput`](crate::output::DeleteLoggingConfigurationOutput)
    pub fn builder() -> crate::output::delete_logging_configuration_output::Builder {
        crate::output::delete_logging_configuration_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteIpSetOutput {}
impl std::fmt::Debug for DeleteIpSetOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteIpSetOutput");
        formatter.finish()
    }
}
/// See [`DeleteIpSetOutput`](crate::output::DeleteIpSetOutput)
pub mod delete_ip_set_output {
    /// A builder for [`DeleteIpSetOutput`](crate::output::DeleteIpSetOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteIpSetOutput`](crate::output::DeleteIpSetOutput)
        pub fn build(self) -> crate::output::DeleteIpSetOutput {
            crate::output::DeleteIpSetOutput {}
        }
    }
}
impl DeleteIpSetOutput {
    /// Creates a new builder-style object to manufacture [`DeleteIpSetOutput`](crate::output::DeleteIpSetOutput)
    pub fn builder() -> crate::output::delete_ip_set_output::Builder {
        crate::output::delete_ip_set_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteFirewallManagerRuleGroupsOutput {
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub next_web_acl_lock_token: std::option::Option<std::string::String>,
}
impl DeleteFirewallManagerRuleGroupsOutput {
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub fn next_web_acl_lock_token(&self) -> std::option::Option<&str> {
        self.next_web_acl_lock_token.as_deref()
    }
}
impl std::fmt::Debug for DeleteFirewallManagerRuleGroupsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteFirewallManagerRuleGroupsOutput");
        formatter.field("next_web_acl_lock_token", &self.next_web_acl_lock_token);
        formatter.finish()
    }
}
/// See [`DeleteFirewallManagerRuleGroupsOutput`](crate::output::DeleteFirewallManagerRuleGroupsOutput)
pub mod delete_firewall_manager_rule_groups_output {
    /// A builder for [`DeleteFirewallManagerRuleGroupsOutput`](crate::output::DeleteFirewallManagerRuleGroupsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_web_acl_lock_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn next_web_acl_lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_web_acl_lock_token = Some(input.into());
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn set_next_web_acl_lock_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_web_acl_lock_token = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteFirewallManagerRuleGroupsOutput`](crate::output::DeleteFirewallManagerRuleGroupsOutput)
        pub fn build(self) -> crate::output::DeleteFirewallManagerRuleGroupsOutput {
            crate::output::DeleteFirewallManagerRuleGroupsOutput {
                next_web_acl_lock_token: self.next_web_acl_lock_token,
            }
        }
    }
}
impl DeleteFirewallManagerRuleGroupsOutput {
    /// Creates a new builder-style object to manufacture [`DeleteFirewallManagerRuleGroupsOutput`](crate::output::DeleteFirewallManagerRuleGroupsOutput)
    pub fn builder() -> crate::output::delete_firewall_manager_rule_groups_output::Builder {
        crate::output::delete_firewall_manager_rule_groups_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateWebAclOutput {
    /// <p>High-level information about a <code>WebACL</code>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage a <code>WebACL</code>, and the ARN, that you provide to operations like <code>AssociateWebACL</code>.</p>
    pub summary: std::option::Option<crate::model::WebAclSummary>,
}
impl CreateWebAclOutput {
    /// <p>High-level information about a <code>WebACL</code>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage a <code>WebACL</code>, and the ARN, that you provide to operations like <code>AssociateWebACL</code>.</p>
    pub fn summary(&self) -> std::option::Option<&crate::model::WebAclSummary> {
        self.summary.as_ref()
    }
}
impl std::fmt::Debug for CreateWebAclOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateWebAclOutput");
        formatter.field("summary", &self.summary);
        formatter.finish()
    }
}
/// See [`CreateWebAclOutput`](crate::output::CreateWebAclOutput)
pub mod create_web_acl_output {
    /// A builder for [`CreateWebAclOutput`](crate::output::CreateWebAclOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) summary: std::option::Option<crate::model::WebAclSummary>,
    }
    impl Builder {
        /// <p>High-level information about a <code>WebACL</code>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage a <code>WebACL</code>, and the ARN, that you provide to operations like <code>AssociateWebACL</code>.</p>
        pub fn summary(mut self, input: crate::model::WebAclSummary) -> Self {
            self.summary = Some(input);
            self
        }
        /// <p>High-level information about a <code>WebACL</code>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage a <code>WebACL</code>, and the ARN, that you provide to operations like <code>AssociateWebACL</code>.</p>
        pub fn set_summary(
            mut self,
            input: std::option::Option<crate::model::WebAclSummary>,
        ) -> Self {
            self.summary = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateWebAclOutput`](crate::output::CreateWebAclOutput)
        pub fn build(self) -> crate::output::CreateWebAclOutput {
            crate::output::CreateWebAclOutput {
                summary: self.summary,
            }
        }
    }
}
impl CreateWebAclOutput {
    /// Creates a new builder-style object to manufacture [`CreateWebAclOutput`](crate::output::CreateWebAclOutput)
    pub fn builder() -> crate::output::create_web_acl_output::Builder {
        crate::output::create_web_acl_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateRuleGroupOutput {
    /// <p>High-level information about a <code>RuleGroup</code>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage a <code>RuleGroup</code>, and the ARN, that you provide to the <code>RuleGroupReferenceStatement</code> to use the rule group in a <code>Rule</code>.</p>
    pub summary: std::option::Option<crate::model::RuleGroupSummary>,
}
impl CreateRuleGroupOutput {
    /// <p>High-level information about a <code>RuleGroup</code>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage a <code>RuleGroup</code>, and the ARN, that you provide to the <code>RuleGroupReferenceStatement</code> to use the rule group in a <code>Rule</code>.</p>
    pub fn summary(&self) -> std::option::Option<&crate::model::RuleGroupSummary> {
        self.summary.as_ref()
    }
}
impl std::fmt::Debug for CreateRuleGroupOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateRuleGroupOutput");
        formatter.field("summary", &self.summary);
        formatter.finish()
    }
}
/// See [`CreateRuleGroupOutput`](crate::output::CreateRuleGroupOutput)
pub mod create_rule_group_output {
    /// A builder for [`CreateRuleGroupOutput`](crate::output::CreateRuleGroupOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) summary: std::option::Option<crate::model::RuleGroupSummary>,
    }
    impl Builder {
        /// <p>High-level information about a <code>RuleGroup</code>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage a <code>RuleGroup</code>, and the ARN, that you provide to the <code>RuleGroupReferenceStatement</code> to use the rule group in a <code>Rule</code>.</p>
        pub fn summary(mut self, input: crate::model::RuleGroupSummary) -> Self {
            self.summary = Some(input);
            self
        }
        /// <p>High-level information about a <code>RuleGroup</code>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage a <code>RuleGroup</code>, and the ARN, that you provide to the <code>RuleGroupReferenceStatement</code> to use the rule group in a <code>Rule</code>.</p>
        pub fn set_summary(
            mut self,
            input: std::option::Option<crate::model::RuleGroupSummary>,
        ) -> Self {
            self.summary = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateRuleGroupOutput`](crate::output::CreateRuleGroupOutput)
        pub fn build(self) -> crate::output::CreateRuleGroupOutput {
            crate::output::CreateRuleGroupOutput {
                summary: self.summary,
            }
        }
    }
}
impl CreateRuleGroupOutput {
    /// Creates a new builder-style object to manufacture [`CreateRuleGroupOutput`](crate::output::CreateRuleGroupOutput)
    pub fn builder() -> crate::output::create_rule_group_output::Builder {
        crate::output::create_rule_group_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateRegexPatternSetOutput {
    /// <p>High-level information about a <code>RegexPatternSet</code>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage a <code>RegexPatternSet</code>, and the ARN, that you provide to the <code>RegexPatternSetReferenceStatement</code> to use the pattern set in a <code>Rule</code>.</p>
    pub summary: std::option::Option<crate::model::RegexPatternSetSummary>,
}
impl CreateRegexPatternSetOutput {
    /// <p>High-level information about a <code>RegexPatternSet</code>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage a <code>RegexPatternSet</code>, and the ARN, that you provide to the <code>RegexPatternSetReferenceStatement</code> to use the pattern set in a <code>Rule</code>.</p>
    pub fn summary(&self) -> std::option::Option<&crate::model::RegexPatternSetSummary> {
        self.summary.as_ref()
    }
}
impl std::fmt::Debug for CreateRegexPatternSetOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateRegexPatternSetOutput");
        formatter.field("summary", &self.summary);
        formatter.finish()
    }
}
/// See [`CreateRegexPatternSetOutput`](crate::output::CreateRegexPatternSetOutput)
pub mod create_regex_pattern_set_output {
    /// A builder for [`CreateRegexPatternSetOutput`](crate::output::CreateRegexPatternSetOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) summary: std::option::Option<crate::model::RegexPatternSetSummary>,
    }
    impl Builder {
        /// <p>High-level information about a <code>RegexPatternSet</code>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage a <code>RegexPatternSet</code>, and the ARN, that you provide to the <code>RegexPatternSetReferenceStatement</code> to use the pattern set in a <code>Rule</code>.</p>
        pub fn summary(mut self, input: crate::model::RegexPatternSetSummary) -> Self {
            self.summary = Some(input);
            self
        }
        /// <p>High-level information about a <code>RegexPatternSet</code>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage a <code>RegexPatternSet</code>, and the ARN, that you provide to the <code>RegexPatternSetReferenceStatement</code> to use the pattern set in a <code>Rule</code>.</p>
        pub fn set_summary(
            mut self,
            input: std::option::Option<crate::model::RegexPatternSetSummary>,
        ) -> Self {
            self.summary = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateRegexPatternSetOutput`](crate::output::CreateRegexPatternSetOutput)
        pub fn build(self) -> crate::output::CreateRegexPatternSetOutput {
            crate::output::CreateRegexPatternSetOutput {
                summary: self.summary,
            }
        }
    }
}
impl CreateRegexPatternSetOutput {
    /// Creates a new builder-style object to manufacture [`CreateRegexPatternSetOutput`](crate::output::CreateRegexPatternSetOutput)
    pub fn builder() -> crate::output::create_regex_pattern_set_output::Builder {
        crate::output::create_regex_pattern_set_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateIpSetOutput {
    /// <p>High-level information about an <code>IPSet</code>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage an <code>IPSet</code>, and the ARN, that you provide to the <code>IPSetReferenceStatement</code> to use the address set in a <code>Rule</code>.</p>
    pub summary: std::option::Option<crate::model::IpSetSummary>,
}
impl CreateIpSetOutput {
    /// <p>High-level information about an <code>IPSet</code>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage an <code>IPSet</code>, and the ARN, that you provide to the <code>IPSetReferenceStatement</code> to use the address set in a <code>Rule</code>.</p>
    pub fn summary(&self) -> std::option::Option<&crate::model::IpSetSummary> {
        self.summary.as_ref()
    }
}
impl std::fmt::Debug for CreateIpSetOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateIpSetOutput");
        formatter.field("summary", &self.summary);
        formatter.finish()
    }
}
/// See [`CreateIpSetOutput`](crate::output::CreateIpSetOutput)
pub mod create_ip_set_output {
    /// A builder for [`CreateIpSetOutput`](crate::output::CreateIpSetOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) summary: std::option::Option<crate::model::IpSetSummary>,
    }
    impl Builder {
        /// <p>High-level information about an <code>IPSet</code>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage an <code>IPSet</code>, and the ARN, that you provide to the <code>IPSetReferenceStatement</code> to use the address set in a <code>Rule</code>.</p>
        pub fn summary(mut self, input: crate::model::IpSetSummary) -> Self {
            self.summary = Some(input);
            self
        }
        /// <p>High-level information about an <code>IPSet</code>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage an <code>IPSet</code>, and the ARN, that you provide to the <code>IPSetReferenceStatement</code> to use the address set in a <code>Rule</code>.</p>
        pub fn set_summary(
            mut self,
            input: std::option::Option<crate::model::IpSetSummary>,
        ) -> Self {
            self.summary = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateIpSetOutput`](crate::output::CreateIpSetOutput)
        pub fn build(self) -> crate::output::CreateIpSetOutput {
            crate::output::CreateIpSetOutput {
                summary: self.summary,
            }
        }
    }
}
impl CreateIpSetOutput {
    /// Creates a new builder-style object to manufacture [`CreateIpSetOutput`](crate::output::CreateIpSetOutput)
    pub fn builder() -> crate::output::create_ip_set_output::Builder {
        crate::output::create_ip_set_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CheckCapacityOutput {
    /// <p>The capacity required by the rules and scope.</p>
    pub capacity: i64,
}
impl CheckCapacityOutput {
    /// <p>The capacity required by the rules and scope.</p>
    pub fn capacity(&self) -> i64 {
        self.capacity
    }
}
impl std::fmt::Debug for CheckCapacityOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CheckCapacityOutput");
        formatter.field("capacity", &self.capacity);
        formatter.finish()
    }
}
/// See [`CheckCapacityOutput`](crate::output::CheckCapacityOutput)
pub mod check_capacity_output {
    /// A builder for [`CheckCapacityOutput`](crate::output::CheckCapacityOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) capacity: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The capacity required by the rules and scope.</p>
        pub fn capacity(mut self, input: i64) -> Self {
            self.capacity = Some(input);
            self
        }
        /// <p>The capacity required by the rules and scope.</p>
        pub fn set_capacity(mut self, input: std::option::Option<i64>) -> Self {
            self.capacity = input;
            self
        }
        /// Consumes the builder and constructs a [`CheckCapacityOutput`](crate::output::CheckCapacityOutput)
        pub fn build(self) -> crate::output::CheckCapacityOutput {
            crate::output::CheckCapacityOutput {
                capacity: self.capacity.unwrap_or_default(),
            }
        }
    }
}
impl CheckCapacityOutput {
    /// Creates a new builder-style object to manufacture [`CheckCapacityOutput`](crate::output::CheckCapacityOutput)
    pub fn builder() -> crate::output::check_capacity_output::Builder {
        crate::output::check_capacity_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociateWebAclOutput {}
impl std::fmt::Debug for AssociateWebAclOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociateWebAclOutput");
        formatter.finish()
    }
}
/// See [`AssociateWebAclOutput`](crate::output::AssociateWebAclOutput)
pub mod associate_web_acl_output {
    /// A builder for [`AssociateWebAclOutput`](crate::output::AssociateWebAclOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`AssociateWebAclOutput`](crate::output::AssociateWebAclOutput)
        pub fn build(self) -> crate::output::AssociateWebAclOutput {
            crate::output::AssociateWebAclOutput {}
        }
    }
}
impl AssociateWebAclOutput {
    /// Creates a new builder-style object to manufacture [`AssociateWebAclOutput`](crate::output::AssociateWebAclOutput)
    pub fn builder() -> crate::output::associate_web_acl_output::Builder {
        crate::output::associate_web_acl_output::Builder::default()
    }
}
