// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`AssociateWebAclInput`](crate::input::AssociateWebAclInput)
pub mod associate_web_acl_input {
    /// A builder for [`AssociateWebAclInput`](crate::input::AssociateWebAclInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) web_acl_arn: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the web ACL that you want to associate with the resource.</p>
        pub fn web_acl_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.web_acl_arn = Some(input.into());
            self
        }
        pub fn set_web_acl_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.web_acl_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource to associate with the web ACL. </p>
        /// <p>The ARN must be in one of the following formats:</p>
        /// <ul>
        /// <li>
        /// <p>For an Application Load Balancer: <code>arn:aws:elasticloadbalancing:<i>region</i>:<i>account-id</i>:loadbalancer/app/<i>load-balancer-name</i>/<i>load-balancer-id</i>
        /// </code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>For an Amazon API Gateway REST API: <code>arn:aws:apigateway:<i>region</i>::/restapis/<i>api-id</i>/stages/<i>stage-name</i>
        /// </code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>For an AppSync GraphQL API: <code>arn:aws:appsync:<i>region</i>:<i>account-id</i>:apis/<i>GraphQLApiId</i>
        /// </code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateWebAclInput`](crate::input::AssociateWebAclInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AssociateWebAclInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AssociateWebAclInput {
                web_acl_arn: self.web_acl_arn,
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type AssociateWebACLInputOperationOutputAlias = crate::operation::AssociateWebACL;
#[doc(hidden)]
pub type AssociateWebACLInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AssociateWebAclInput {
    /// Consumes the builder and constructs an Operation<[`AssociateWebACL`](crate::operation::AssociateWebACL)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::AssociateWebACL,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_associate_web_acl(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::AssociateWebACL::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "AssociateWebACL",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.AssociateWebACL",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AssociateWebAclInput`](crate::input::AssociateWebAclInput)
    pub fn builder() -> crate::input::associate_web_acl_input::Builder {
        crate::input::associate_web_acl_input::Builder::default()
    }
}

/// See [`CheckCapacityInput`](crate::input::CheckCapacityInput)
pub mod check_capacity_input {
    /// A builder for [`CheckCapacityInput`](crate::input::CheckCapacityInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) rules: std::option::Option<std::vec::Vec<crate::model::Rule>>,
    }
    impl Builder {
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        pub fn rules(mut self, input: impl Into<crate::model::Rule>) -> Self {
            let mut v = self.rules.unwrap_or_default();
            v.push(input.into());
            self.rules = Some(v);
            self
        }
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Rule>>,
        ) -> Self {
            self.rules = input;
            self
        }
        /// Consumes the builder and constructs a [`CheckCapacityInput`](crate::input::CheckCapacityInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::CheckCapacityInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::CheckCapacityInput {
                scope: self.scope,
                rules: self.rules,
            })
        }
    }
}
#[doc(hidden)]
pub type CheckCapacityInputOperationOutputAlias = crate::operation::CheckCapacity;
#[doc(hidden)]
pub type CheckCapacityInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CheckCapacityInput {
    /// Consumes the builder and constructs an Operation<[`CheckCapacity`](crate::operation::CheckCapacity)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CheckCapacity,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_check_capacity(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CheckCapacity::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CheckCapacity",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.CheckCapacity",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CheckCapacityInput`](crate::input::CheckCapacityInput)
    pub fn builder() -> crate::input::check_capacity_input::Builder {
        crate::input::check_capacity_input::Builder::default()
    }
}

/// See [`CreateIpSetInput`](crate::input::CreateIpSetInput)
pub mod create_ip_set_input {
    /// A builder for [`CreateIpSetInput`](crate::input::CreateIpSetInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) ip_address_version: std::option::Option<crate::model::IpAddressVersion>,
        pub(crate) addresses: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>A description of the IP set that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Specify IPV4 or IPV6. </p>
        pub fn ip_address_version(mut self, input: crate::model::IpAddressVersion) -> Self {
            self.ip_address_version = Some(input);
            self
        }
        pub fn set_ip_address_version(
            mut self,
            input: std::option::Option<crate::model::IpAddressVersion>,
        ) -> Self {
            self.ip_address_version = input;
            self
        }
        pub fn addresses(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.addresses.unwrap_or_default();
            v.push(input.into());
            self.addresses = Some(v);
            self
        }
        pub fn set_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.addresses = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateIpSetInput`](crate::input::CreateIpSetInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::CreateIpSetInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::CreateIpSetInput {
                name: self.name,
                scope: self.scope,
                description: self.description,
                ip_address_version: self.ip_address_version,
                addresses: self.addresses,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateIPSetInputOperationOutputAlias = crate::operation::CreateIPSet;
#[doc(hidden)]
pub type CreateIPSetInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateIpSetInput {
    /// Consumes the builder and constructs an Operation<[`CreateIPSet`](crate::operation::CreateIPSet)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateIPSet,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_create_ip_set(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateIPSet::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateIPSet",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.CreateIPSet",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateIpSetInput`](crate::input::CreateIpSetInput)
    pub fn builder() -> crate::input::create_ip_set_input::Builder {
        crate::input::create_ip_set_input::Builder::default()
    }
}

/// See [`CreateRegexPatternSetInput`](crate::input::CreateRegexPatternSetInput)
pub mod create_regex_pattern_set_input {
    /// A builder for [`CreateRegexPatternSetInput`](crate::input::CreateRegexPatternSetInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) regular_expression_list: std::option::Option<std::vec::Vec<crate::model::Regex>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the set. You cannot change the name after you create the set.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>A description of the set that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        pub fn regular_expression_list(mut self, input: impl Into<crate::model::Regex>) -> Self {
            let mut v = self.regular_expression_list.unwrap_or_default();
            v.push(input.into());
            self.regular_expression_list = Some(v);
            self
        }
        pub fn set_regular_expression_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Regex>>,
        ) -> Self {
            self.regular_expression_list = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateRegexPatternSetInput`](crate::input::CreateRegexPatternSetInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateRegexPatternSetInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateRegexPatternSetInput {
                name: self.name,
                scope: self.scope,
                description: self.description,
                regular_expression_list: self.regular_expression_list,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateRegexPatternSetInputOperationOutputAlias = crate::operation::CreateRegexPatternSet;
#[doc(hidden)]
pub type CreateRegexPatternSetInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateRegexPatternSetInput {
    /// Consumes the builder and constructs an Operation<[`CreateRegexPatternSet`](crate::operation::CreateRegexPatternSet)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateRegexPatternSet,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_create_regex_pattern_set(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateRegexPatternSet::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateRegexPatternSet",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.CreateRegexPatternSet",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateRegexPatternSetInput`](crate::input::CreateRegexPatternSetInput)
    pub fn builder() -> crate::input::create_regex_pattern_set_input::Builder {
        crate::input::create_regex_pattern_set_input::Builder::default()
    }
}

/// See [`CreateRuleGroupInput`](crate::input::CreateRuleGroupInput)
pub mod create_rule_group_input {
    /// A builder for [`CreateRuleGroupInput`](crate::input::CreateRuleGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) capacity: std::option::Option<i64>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) rules: std::option::Option<std::vec::Vec<crate::model::Rule>>,
        pub(crate) visibility_config: std::option::Option<crate::model::VisibilityConfig>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) custom_response_bodies: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::CustomResponseBody>,
        >,
    }
    impl Builder {
        /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>The web ACL capacity units (WCUs) required for this rule group.</p>
        /// <p>When you create your own rule group, you define this, and you cannot change it after creation.
        /// When you add or modify the rules in a rule group, WAF enforces this limit. You can check the capacity
        /// for a set of rules using <a>CheckCapacity</a>.</p>
        /// <p>WAF uses WCUs to calculate and control the operating
        /// resources that are used to run your rules, rule groups, and web ACLs. WAF
        /// calculates capacity differently for each rule type, to reflect the relative cost of each rule.
        /// Simple rules that cost little to run use fewer WCUs than more complex rules
        /// that use more processing power.
        /// Rule group capacity is fixed at creation, which helps users plan their  
        /// web ACL WCU usage when they use a rule group.
        /// The WCU limit for web ACLs is 1,500.  </p>
        pub fn capacity(mut self, input: i64) -> Self {
            self.capacity = Some(input);
            self
        }
        pub fn set_capacity(mut self, input: std::option::Option<i64>) -> Self {
            self.capacity = input;
            self
        }
        /// <p>A description of the rule group that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        pub fn rules(mut self, input: impl Into<crate::model::Rule>) -> Self {
            let mut v = self.rules.unwrap_or_default();
            v.push(input.into());
            self.rules = Some(v);
            self
        }
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Rule>>,
        ) -> Self {
            self.rules = input;
            self
        }
        /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection.  </p>
        pub fn visibility_config(mut self, input: crate::model::VisibilityConfig) -> Self {
            self.visibility_config = Some(input);
            self
        }
        pub fn set_visibility_config(
            mut self,
            input: std::option::Option<crate::model::VisibilityConfig>,
        ) -> Self {
            self.visibility_config = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        pub fn custom_response_bodies(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::CustomResponseBody>,
        ) -> Self {
            let mut hash_map = self.custom_response_bodies.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.custom_response_bodies = Some(hash_map);
            self
        }
        pub fn set_custom_response_bodies(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::CustomResponseBody>,
            >,
        ) -> Self {
            self.custom_response_bodies = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateRuleGroupInput`](crate::input::CreateRuleGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateRuleGroupInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateRuleGroupInput {
                name: self.name,
                scope: self.scope,
                capacity: self.capacity.unwrap_or_default(),
                description: self.description,
                rules: self.rules,
                visibility_config: self.visibility_config,
                tags: self.tags,
                custom_response_bodies: self.custom_response_bodies,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateRuleGroupInputOperationOutputAlias = crate::operation::CreateRuleGroup;
#[doc(hidden)]
pub type CreateRuleGroupInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateRuleGroupInput {
    /// Consumes the builder and constructs an Operation<[`CreateRuleGroup`](crate::operation::CreateRuleGroup)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateRuleGroup,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_create_rule_group(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateRuleGroup::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateRuleGroup",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.CreateRuleGroup",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateRuleGroupInput`](crate::input::CreateRuleGroupInput)
    pub fn builder() -> crate::input::create_rule_group_input::Builder {
        crate::input::create_rule_group_input::Builder::default()
    }
}

/// See [`CreateWebAclInput`](crate::input::CreateWebAclInput)
pub mod create_web_acl_input {
    /// A builder for [`CreateWebAclInput`](crate::input::CreateWebAclInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) default_action: std::option::Option<crate::model::DefaultAction>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) rules: std::option::Option<std::vec::Vec<crate::model::Rule>>,
        pub(crate) visibility_config: std::option::Option<crate::model::VisibilityConfig>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) custom_response_bodies: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::CustomResponseBody>,
        >,
    }
    impl Builder {
        /// <p>The name of the web ACL. You cannot change the name of a web ACL after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>The action to perform if none of the <code>Rules</code> contained in the <code>WebACL</code> match. </p>
        pub fn default_action(mut self, input: crate::model::DefaultAction) -> Self {
            self.default_action = Some(input);
            self
        }
        pub fn set_default_action(
            mut self,
            input: std::option::Option<crate::model::DefaultAction>,
        ) -> Self {
            self.default_action = input;
            self
        }
        /// <p>A description of the web ACL that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        pub fn rules(mut self, input: impl Into<crate::model::Rule>) -> Self {
            let mut v = self.rules.unwrap_or_default();
            v.push(input.into());
            self.rules = Some(v);
            self
        }
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Rule>>,
        ) -> Self {
            self.rules = input;
            self
        }
        /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection.  </p>
        pub fn visibility_config(mut self, input: crate::model::VisibilityConfig) -> Self {
            self.visibility_config = Some(input);
            self
        }
        pub fn set_visibility_config(
            mut self,
            input: std::option::Option<crate::model::VisibilityConfig>,
        ) -> Self {
            self.visibility_config = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        pub fn custom_response_bodies(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::CustomResponseBody>,
        ) -> Self {
            let mut hash_map = self.custom_response_bodies.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.custom_response_bodies = Some(hash_map);
            self
        }
        pub fn set_custom_response_bodies(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::CustomResponseBody>,
            >,
        ) -> Self {
            self.custom_response_bodies = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateWebAclInput`](crate::input::CreateWebAclInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::CreateWebAclInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::CreateWebAclInput {
                name: self.name,
                scope: self.scope,
                default_action: self.default_action,
                description: self.description,
                rules: self.rules,
                visibility_config: self.visibility_config,
                tags: self.tags,
                custom_response_bodies: self.custom_response_bodies,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateWebACLInputOperationOutputAlias = crate::operation::CreateWebACL;
#[doc(hidden)]
pub type CreateWebACLInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateWebAclInput {
    /// Consumes the builder and constructs an Operation<[`CreateWebACL`](crate::operation::CreateWebACL)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateWebACL,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_create_web_acl(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateWebACL::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateWebACL",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.CreateWebACL",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateWebAclInput`](crate::input::CreateWebAclInput)
    pub fn builder() -> crate::input::create_web_acl_input::Builder {
        crate::input::create_web_acl_input::Builder::default()
    }
}

/// See [`DeleteFirewallManagerRuleGroupsInput`](crate::input::DeleteFirewallManagerRuleGroupsInput)
pub mod delete_firewall_manager_rule_groups_input {
    /// A builder for [`DeleteFirewallManagerRuleGroupsInput`](crate::input::DeleteFirewallManagerRuleGroupsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) web_acl_arn: std::option::Option<std::string::String>,
        pub(crate) web_acl_lock_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the web ACL.</p>
        pub fn web_acl_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.web_acl_arn = Some(input.into());
            self
        }
        pub fn set_web_acl_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.web_acl_arn = input;
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
        pub fn web_acl_lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.web_acl_lock_token = Some(input.into());
            self
        }
        pub fn set_web_acl_lock_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.web_acl_lock_token = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteFirewallManagerRuleGroupsInput`](crate::input::DeleteFirewallManagerRuleGroupsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteFirewallManagerRuleGroupsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteFirewallManagerRuleGroupsInput {
                web_acl_arn: self.web_acl_arn,
                web_acl_lock_token: self.web_acl_lock_token,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteFirewallManagerRuleGroupsInputOperationOutputAlias =
    crate::operation::DeleteFirewallManagerRuleGroups;
#[doc(hidden)]
pub type DeleteFirewallManagerRuleGroupsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteFirewallManagerRuleGroupsInput {
    /// Consumes the builder and constructs an Operation<[`DeleteFirewallManagerRuleGroups`](crate::operation::DeleteFirewallManagerRuleGroups)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteFirewallManagerRuleGroups,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_delete_firewall_manager_rule_groups(
                    &self,
                )
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteFirewallManagerRuleGroups::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteFirewallManagerRuleGroups",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.DeleteFirewallManagerRuleGroups",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteFirewallManagerRuleGroupsInput`](crate::input::DeleteFirewallManagerRuleGroupsInput)
    pub fn builder() -> crate::input::delete_firewall_manager_rule_groups_input::Builder {
        crate::input::delete_firewall_manager_rule_groups_input::Builder::default()
    }
}

/// See [`DeleteIpSetInput`](crate::input::DeleteIpSetInput)
pub mod delete_ip_set_input {
    /// A builder for [`DeleteIpSetInput`](crate::input::DeleteIpSetInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) lock_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.lock_token = Some(input.into());
            self
        }
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lock_token = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteIpSetInput`](crate::input::DeleteIpSetInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::DeleteIpSetInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteIpSetInput {
                name: self.name,
                scope: self.scope,
                id: self.id,
                lock_token: self.lock_token,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteIPSetInputOperationOutputAlias = crate::operation::DeleteIPSet;
#[doc(hidden)]
pub type DeleteIPSetInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteIpSetInput {
    /// Consumes the builder and constructs an Operation<[`DeleteIPSet`](crate::operation::DeleteIPSet)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteIPSet,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_delete_ip_set(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteIPSet::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteIPSet",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.DeleteIPSet",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteIpSetInput`](crate::input::DeleteIpSetInput)
    pub fn builder() -> crate::input::delete_ip_set_input::Builder {
        crate::input::delete_ip_set_input::Builder::default()
    }
}

/// See [`DeleteLoggingConfigurationInput`](crate::input::DeleteLoggingConfigurationInput)
pub mod delete_logging_configuration_input {
    /// A builder for [`DeleteLoggingConfigurationInput`](crate::input::DeleteLoggingConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the web ACL from which you want to delete the <a>LoggingConfiguration</a>.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteLoggingConfigurationInput`](crate::input::DeleteLoggingConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteLoggingConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteLoggingConfigurationInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteLoggingConfigurationInputOperationOutputAlias =
    crate::operation::DeleteLoggingConfiguration;
#[doc(hidden)]
pub type DeleteLoggingConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteLoggingConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteLoggingConfiguration`](crate::operation::DeleteLoggingConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteLoggingConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_delete_logging_configuration(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteLoggingConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteLoggingConfiguration",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.DeleteLoggingConfiguration",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteLoggingConfigurationInput`](crate::input::DeleteLoggingConfigurationInput)
    pub fn builder() -> crate::input::delete_logging_configuration_input::Builder {
        crate::input::delete_logging_configuration_input::Builder::default()
    }
}

/// See [`DeletePermissionPolicyInput`](crate::input::DeletePermissionPolicyInput)
pub mod delete_permission_policy_input {
    /// A builder for [`DeletePermissionPolicyInput`](crate::input::DeletePermissionPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the rule group from which you want to delete the policy.</p>
        /// <p>You must be the owner of the rule group to perform this operation.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DeletePermissionPolicyInput`](crate::input::DeletePermissionPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeletePermissionPolicyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeletePermissionPolicyInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DeletePermissionPolicyInputOperationOutputAlias = crate::operation::DeletePermissionPolicy;
#[doc(hidden)]
pub type DeletePermissionPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeletePermissionPolicyInput {
    /// Consumes the builder and constructs an Operation<[`DeletePermissionPolicy`](crate::operation::DeletePermissionPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeletePermissionPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_delete_permission_policy(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeletePermissionPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeletePermissionPolicy",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.DeletePermissionPolicy",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeletePermissionPolicyInput`](crate::input::DeletePermissionPolicyInput)
    pub fn builder() -> crate::input::delete_permission_policy_input::Builder {
        crate::input::delete_permission_policy_input::Builder::default()
    }
}

/// See [`DeleteRegexPatternSetInput`](crate::input::DeleteRegexPatternSetInput)
pub mod delete_regex_pattern_set_input {
    /// A builder for [`DeleteRegexPatternSetInput`](crate::input::DeleteRegexPatternSetInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) lock_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the set. You cannot change the name after you create the set.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.lock_token = Some(input.into());
            self
        }
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lock_token = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteRegexPatternSetInput`](crate::input::DeleteRegexPatternSetInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteRegexPatternSetInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteRegexPatternSetInput {
                name: self.name,
                scope: self.scope,
                id: self.id,
                lock_token: self.lock_token,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteRegexPatternSetInputOperationOutputAlias = crate::operation::DeleteRegexPatternSet;
#[doc(hidden)]
pub type DeleteRegexPatternSetInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteRegexPatternSetInput {
    /// Consumes the builder and constructs an Operation<[`DeleteRegexPatternSet`](crate::operation::DeleteRegexPatternSet)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteRegexPatternSet,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_delete_regex_pattern_set(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteRegexPatternSet::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteRegexPatternSet",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.DeleteRegexPatternSet",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteRegexPatternSetInput`](crate::input::DeleteRegexPatternSetInput)
    pub fn builder() -> crate::input::delete_regex_pattern_set_input::Builder {
        crate::input::delete_regex_pattern_set_input::Builder::default()
    }
}

/// See [`DeleteRuleGroupInput`](crate::input::DeleteRuleGroupInput)
pub mod delete_rule_group_input {
    /// A builder for [`DeleteRuleGroupInput`](crate::input::DeleteRuleGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) lock_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>A unique identifier for the rule group. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.lock_token = Some(input.into());
            self
        }
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lock_token = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteRuleGroupInput`](crate::input::DeleteRuleGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteRuleGroupInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteRuleGroupInput {
                name: self.name,
                scope: self.scope,
                id: self.id,
                lock_token: self.lock_token,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteRuleGroupInputOperationOutputAlias = crate::operation::DeleteRuleGroup;
#[doc(hidden)]
pub type DeleteRuleGroupInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteRuleGroupInput {
    /// Consumes the builder and constructs an Operation<[`DeleteRuleGroup`](crate::operation::DeleteRuleGroup)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteRuleGroup,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_delete_rule_group(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteRuleGroup::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteRuleGroup",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.DeleteRuleGroup",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteRuleGroupInput`](crate::input::DeleteRuleGroupInput)
    pub fn builder() -> crate::input::delete_rule_group_input::Builder {
        crate::input::delete_rule_group_input::Builder::default()
    }
}

/// See [`DeleteWebAclInput`](crate::input::DeleteWebAclInput)
pub mod delete_web_acl_input {
    /// A builder for [`DeleteWebAclInput`](crate::input::DeleteWebAclInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) lock_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the web ACL. You cannot change the name of a web ACL after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>The unique identifier for the web ACL. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.lock_token = Some(input.into());
            self
        }
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lock_token = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteWebAclInput`](crate::input::DeleteWebAclInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::DeleteWebAclInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteWebAclInput {
                name: self.name,
                scope: self.scope,
                id: self.id,
                lock_token: self.lock_token,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteWebACLInputOperationOutputAlias = crate::operation::DeleteWebACL;
#[doc(hidden)]
pub type DeleteWebACLInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteWebAclInput {
    /// Consumes the builder and constructs an Operation<[`DeleteWebACL`](crate::operation::DeleteWebACL)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteWebACL,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_delete_web_acl(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteWebACL::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteWebACL",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.DeleteWebACL",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteWebAclInput`](crate::input::DeleteWebAclInput)
    pub fn builder() -> crate::input::delete_web_acl_input::Builder {
        crate::input::delete_web_acl_input::Builder::default()
    }
}

/// See [`DescribeManagedRuleGroupInput`](crate::input::DescribeManagedRuleGroupInput)
pub mod describe_managed_rule_group_input {
    /// A builder for [`DescribeManagedRuleGroupInput`](crate::input::DescribeManagedRuleGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vendor_name: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
    }
    impl Builder {
        /// <p>The name of the managed rule group vendor. You use this, along with the rule group name, to identify the rule group.</p>
        pub fn vendor_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vendor_name = Some(input.into());
            self
        }
        pub fn set_vendor_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vendor_name = input;
            self
        }
        /// <p>The name of the managed rule group. You use this, along with the vendor name, to identify the rule group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeManagedRuleGroupInput`](crate::input::DescribeManagedRuleGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeManagedRuleGroupInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeManagedRuleGroupInput {
                vendor_name: self.vendor_name,
                name: self.name,
                scope: self.scope,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeManagedRuleGroupInputOperationOutputAlias =
    crate::operation::DescribeManagedRuleGroup;
#[doc(hidden)]
pub type DescribeManagedRuleGroupInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeManagedRuleGroupInput {
    /// Consumes the builder and constructs an Operation<[`DescribeManagedRuleGroup`](crate::operation::DescribeManagedRuleGroup)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeManagedRuleGroup,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_describe_managed_rule_group(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeManagedRuleGroup::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeManagedRuleGroup",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.DescribeManagedRuleGroup",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeManagedRuleGroupInput`](crate::input::DescribeManagedRuleGroupInput)
    pub fn builder() -> crate::input::describe_managed_rule_group_input::Builder {
        crate::input::describe_managed_rule_group_input::Builder::default()
    }
}

/// See [`DisassociateWebAclInput`](crate::input::DisassociateWebAclInput)
pub mod disassociate_web_acl_input {
    /// A builder for [`DisassociateWebAclInput`](crate::input::DisassociateWebAclInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource to disassociate from the web ACL. </p>
        /// <p>The ARN must be in one of the following formats:</p>
        /// <ul>
        /// <li>
        /// <p>For an Application Load Balancer: <code>arn:aws:elasticloadbalancing:<i>region</i>:<i>account-id</i>:loadbalancer/app/<i>load-balancer-name</i>/<i>load-balancer-id</i>
        /// </code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>For an Amazon API Gateway REST API: <code>arn:aws:apigateway:<i>region</i>::/restapis/<i>api-id</i>/stages/<i>stage-name</i>
        /// </code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>For an AppSync GraphQL API: <code>arn:aws:appsync:<i>region</i>:<i>account-id</i>:apis/<i>GraphQLApiId</i>
        /// </code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateWebAclInput`](crate::input::DisassociateWebAclInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DisassociateWebAclInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DisassociateWebAclInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DisassociateWebACLInputOperationOutputAlias = crate::operation::DisassociateWebACL;
#[doc(hidden)]
pub type DisassociateWebACLInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DisassociateWebAclInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateWebACL`](crate::operation::DisassociateWebACL)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DisassociateWebACL,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_disassociate_web_acl(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DisassociateWebACL::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DisassociateWebACL",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.DisassociateWebACL",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DisassociateWebAclInput`](crate::input::DisassociateWebAclInput)
    pub fn builder() -> crate::input::disassociate_web_acl_input::Builder {
        crate::input::disassociate_web_acl_input::Builder::default()
    }
}

/// See [`GetIpSetInput`](crate::input::GetIpSetInput)
pub mod get_ip_set_input {
    /// A builder for [`GetIpSetInput`](crate::input::GetIpSetInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetIpSetInput`](crate::input::GetIpSetInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetIpSetInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetIpSetInput {
                name: self.name,
                scope: self.scope,
                id: self.id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetIPSetInputOperationOutputAlias = crate::operation::GetIPSet;
#[doc(hidden)]
pub type GetIPSetInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetIpSetInput {
    /// Consumes the builder and constructs an Operation<[`GetIPSet`](crate::operation::GetIPSet)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetIPSet,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_get_ip_set(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op =
                smithy_http::operation::Operation::new(request, crate::operation::GetIPSet::new())
                    .with_metadata(smithy_http::operation::Metadata::new("GetIPSet", "wafv2"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.GetIPSet",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetIpSetInput`](crate::input::GetIpSetInput)
    pub fn builder() -> crate::input::get_ip_set_input::Builder {
        crate::input::get_ip_set_input::Builder::default()
    }
}

/// See [`GetLoggingConfigurationInput`](crate::input::GetLoggingConfigurationInput)
pub mod get_logging_configuration_input {
    /// A builder for [`GetLoggingConfigurationInput`](crate::input::GetLoggingConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the web ACL for which you want to get the <a>LoggingConfiguration</a>.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`GetLoggingConfigurationInput`](crate::input::GetLoggingConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetLoggingConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetLoggingConfigurationInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type GetLoggingConfigurationInputOperationOutputAlias =
    crate::operation::GetLoggingConfiguration;
#[doc(hidden)]
pub type GetLoggingConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetLoggingConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetLoggingConfiguration`](crate::operation::GetLoggingConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetLoggingConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_get_logging_configuration(&self)
                .map_err(|err| {
                smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetLoggingConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetLoggingConfiguration",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.GetLoggingConfiguration",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetLoggingConfigurationInput`](crate::input::GetLoggingConfigurationInput)
    pub fn builder() -> crate::input::get_logging_configuration_input::Builder {
        crate::input::get_logging_configuration_input::Builder::default()
    }
}

/// See [`GetPermissionPolicyInput`](crate::input::GetPermissionPolicyInput)
pub mod get_permission_policy_input {
    /// A builder for [`GetPermissionPolicyInput`](crate::input::GetPermissionPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the rule group for which you want to get the policy.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`GetPermissionPolicyInput`](crate::input::GetPermissionPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetPermissionPolicyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetPermissionPolicyInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type GetPermissionPolicyInputOperationOutputAlias = crate::operation::GetPermissionPolicy;
#[doc(hidden)]
pub type GetPermissionPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetPermissionPolicyInput {
    /// Consumes the builder and constructs an Operation<[`GetPermissionPolicy`](crate::operation::GetPermissionPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetPermissionPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_get_permission_policy(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetPermissionPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetPermissionPolicy",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.GetPermissionPolicy",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetPermissionPolicyInput`](crate::input::GetPermissionPolicyInput)
    pub fn builder() -> crate::input::get_permission_policy_input::Builder {
        crate::input::get_permission_policy_input::Builder::default()
    }
}

/// See [`GetRateBasedStatementManagedKeysInput`](crate::input::GetRateBasedStatementManagedKeysInput)
pub mod get_rate_based_statement_managed_keys_input {
    /// A builder for [`GetRateBasedStatementManagedKeysInput`](crate::input::GetRateBasedStatementManagedKeysInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) web_acl_name: std::option::Option<std::string::String>,
        pub(crate) web_acl_id: std::option::Option<std::string::String>,
        pub(crate) rule_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>The name of the web ACL. You cannot change the name of a web ACL after you create it.</p>
        pub fn web_acl_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.web_acl_name = Some(input.into());
            self
        }
        pub fn set_web_acl_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.web_acl_name = input;
            self
        }
        /// <p>The unique identifier for the web ACL. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn web_acl_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.web_acl_id = Some(input.into());
            self
        }
        pub fn set_web_acl_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.web_acl_id = input;
            self
        }
        /// <p>The name of the rate-based rule to get the keys for.</p>
        pub fn rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_name = Some(input.into());
            self
        }
        pub fn set_rule_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRateBasedStatementManagedKeysInput`](crate::input::GetRateBasedStatementManagedKeysInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetRateBasedStatementManagedKeysInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetRateBasedStatementManagedKeysInput {
                scope: self.scope,
                web_acl_name: self.web_acl_name,
                web_acl_id: self.web_acl_id,
                rule_name: self.rule_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetRateBasedStatementManagedKeysInputOperationOutputAlias =
    crate::operation::GetRateBasedStatementManagedKeys;
#[doc(hidden)]
pub type GetRateBasedStatementManagedKeysInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetRateBasedStatementManagedKeysInput {
    /// Consumes the builder and constructs an Operation<[`GetRateBasedStatementManagedKeys`](crate::operation::GetRateBasedStatementManagedKeys)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetRateBasedStatementManagedKeys,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_get_rate_based_statement_managed_keys(
                    &self,
                )
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetRateBasedStatementManagedKeys::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetRateBasedStatementManagedKeys",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.GetRateBasedStatementManagedKeys",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetRateBasedStatementManagedKeysInput`](crate::input::GetRateBasedStatementManagedKeysInput)
    pub fn builder() -> crate::input::get_rate_based_statement_managed_keys_input::Builder {
        crate::input::get_rate_based_statement_managed_keys_input::Builder::default()
    }
}

/// See [`GetRegexPatternSetInput`](crate::input::GetRegexPatternSetInput)
pub mod get_regex_pattern_set_input {
    /// A builder for [`GetRegexPatternSetInput`](crate::input::GetRegexPatternSetInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the set. You cannot change the name after you create the set.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRegexPatternSetInput`](crate::input::GetRegexPatternSetInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetRegexPatternSetInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetRegexPatternSetInput {
                name: self.name,
                scope: self.scope,
                id: self.id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetRegexPatternSetInputOperationOutputAlias = crate::operation::GetRegexPatternSet;
#[doc(hidden)]
pub type GetRegexPatternSetInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetRegexPatternSetInput {
    /// Consumes the builder and constructs an Operation<[`GetRegexPatternSet`](crate::operation::GetRegexPatternSet)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetRegexPatternSet,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_get_regex_pattern_set(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetRegexPatternSet::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetRegexPatternSet",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.GetRegexPatternSet",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetRegexPatternSetInput`](crate::input::GetRegexPatternSetInput)
    pub fn builder() -> crate::input::get_regex_pattern_set_input::Builder {
        crate::input::get_regex_pattern_set_input::Builder::default()
    }
}

/// See [`GetRuleGroupInput`](crate::input::GetRuleGroupInput)
pub mod get_rule_group_input {
    /// A builder for [`GetRuleGroupInput`](crate::input::GetRuleGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>A unique identifier for the rule group. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entity.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRuleGroupInput`](crate::input::GetRuleGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetRuleGroupInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetRuleGroupInput {
                name: self.name,
                scope: self.scope,
                id: self.id,
                arn: self.arn,
            })
        }
    }
}
#[doc(hidden)]
pub type GetRuleGroupInputOperationOutputAlias = crate::operation::GetRuleGroup;
#[doc(hidden)]
pub type GetRuleGroupInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetRuleGroupInput {
    /// Consumes the builder and constructs an Operation<[`GetRuleGroup`](crate::operation::GetRuleGroup)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetRuleGroup,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_get_rule_group(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetRuleGroup::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetRuleGroup",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.GetRuleGroup",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetRuleGroupInput`](crate::input::GetRuleGroupInput)
    pub fn builder() -> crate::input::get_rule_group_input::Builder {
        crate::input::get_rule_group_input::Builder::default()
    }
}

/// See [`GetSampledRequestsInput`](crate::input::GetSampledRequestsInput)
pub mod get_sampled_requests_input {
    /// A builder for [`GetSampledRequestsInput`](crate::input::GetSampledRequestsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) web_acl_arn: std::option::Option<std::string::String>,
        pub(crate) rule_metric_name: std::option::Option<std::string::String>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) time_window: std::option::Option<crate::model::TimeWindow>,
        pub(crate) max_items: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The Amazon resource name (ARN) of the <code>WebACL</code> for which you want a sample of requests.</p>
        pub fn web_acl_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.web_acl_arn = Some(input.into());
            self
        }
        pub fn set_web_acl_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.web_acl_arn = input;
            self
        }
        /// <p>The metric name assigned to the <code>Rule</code> or <code>RuleGroup</code> for which you want a sample of requests.</p>
        pub fn rule_metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_metric_name = Some(input.into());
            self
        }
        pub fn set_rule_metric_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_metric_name = input;
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>The start date and time and the end date and time of the range for which you want <code>GetSampledRequests</code> to return a
        /// sample of requests. You must specify the times in Coordinated Universal Time (UTC) format. UTC format includes the special designator, <code>Z</code>. For example, <code>"2016-09-27T14:50Z"</code>. You can specify any time range in the previous three hours. If you specify a start time that's earlier than three hours ago, WAF sets it to three hours ago.</p>
        pub fn time_window(mut self, input: crate::model::TimeWindow) -> Self {
            self.time_window = Some(input);
            self
        }
        pub fn set_time_window(
            mut self,
            input: std::option::Option<crate::model::TimeWindow>,
        ) -> Self {
            self.time_window = input;
            self
        }
        /// <p>The number of requests that you want WAF to return from among the first 5,000 requests that your Amazon Web Services resource received
        /// during the time range. If your resource received fewer requests than the value of <code>MaxItems</code>, <code>GetSampledRequests</code>
        /// returns information about all of them. </p>
        pub fn max_items(mut self, input: i64) -> Self {
            self.max_items = Some(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i64>) -> Self {
            self.max_items = input;
            self
        }
        /// Consumes the builder and constructs a [`GetSampledRequestsInput`](crate::input::GetSampledRequestsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetSampledRequestsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetSampledRequestsInput {
                web_acl_arn: self.web_acl_arn,
                rule_metric_name: self.rule_metric_name,
                scope: self.scope,
                time_window: self.time_window,
                max_items: self.max_items.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type GetSampledRequestsInputOperationOutputAlias = crate::operation::GetSampledRequests;
#[doc(hidden)]
pub type GetSampledRequestsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetSampledRequestsInput {
    /// Consumes the builder and constructs an Operation<[`GetSampledRequests`](crate::operation::GetSampledRequests)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetSampledRequests,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_get_sampled_requests(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetSampledRequests::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetSampledRequests",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.GetSampledRequests",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetSampledRequestsInput`](crate::input::GetSampledRequestsInput)
    pub fn builder() -> crate::input::get_sampled_requests_input::Builder {
        crate::input::get_sampled_requests_input::Builder::default()
    }
}

/// See [`GetWebAclInput`](crate::input::GetWebAclInput)
pub mod get_web_acl_input {
    /// A builder for [`GetWebAclInput`](crate::input::GetWebAclInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the web ACL. You cannot change the name of a web ACL after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>The unique identifier for the web ACL. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetWebAclInput`](crate::input::GetWebAclInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetWebAclInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetWebAclInput {
                name: self.name,
                scope: self.scope,
                id: self.id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetWebACLInputOperationOutputAlias = crate::operation::GetWebACL;
#[doc(hidden)]
pub type GetWebACLInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetWebAclInput {
    /// Consumes the builder and constructs an Operation<[`GetWebACL`](crate::operation::GetWebACL)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetWebACL,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_get_web_acl(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op =
                smithy_http::operation::Operation::new(request, crate::operation::GetWebACL::new())
                    .with_metadata(smithy_http::operation::Metadata::new("GetWebACL", "wafv2"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.GetWebACL",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetWebAclInput`](crate::input::GetWebAclInput)
    pub fn builder() -> crate::input::get_web_acl_input::Builder {
        crate::input::get_web_acl_input::Builder::default()
    }
}

/// See [`GetWebAclForResourceInput`](crate::input::GetWebAclForResourceInput)
pub mod get_web_acl_for_resource_input {
    /// A builder for [`GetWebAclForResourceInput`](crate::input::GetWebAclForResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN (Amazon Resource Name) of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`GetWebAclForResourceInput`](crate::input::GetWebAclForResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetWebAclForResourceInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetWebAclForResourceInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type GetWebACLForResourceInputOperationOutputAlias = crate::operation::GetWebACLForResource;
#[doc(hidden)]
pub type GetWebACLForResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetWebAclForResourceInput {
    /// Consumes the builder and constructs an Operation<[`GetWebACLForResource`](crate::operation::GetWebACLForResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetWebACLForResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_get_web_acl_for_resource(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetWebACLForResource::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetWebACLForResource",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.GetWebACLForResource",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetWebAclForResourceInput`](crate::input::GetWebAclForResourceInput)
    pub fn builder() -> crate::input::get_web_acl_for_resource_input::Builder {
        crate::input::get_web_acl_for_resource_input::Builder::default()
    }
}

/// See [`ListAvailableManagedRuleGroupsInput`](crate::input::ListAvailableManagedRuleGroupsInput)
pub mod list_available_managed_rule_groups_input {
    /// A builder for [`ListAvailableManagedRuleGroupsInput`](crate::input::ListAvailableManagedRuleGroupsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) next_marker: std::option::Option<std::string::String>,
        pub(crate) limit: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
        /// for retrieval exceeds the limit, WAF returns a <code>NextMarker</code>
        /// value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn next_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_marker = Some(input.into());
            self
        }
        pub fn set_next_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_marker = input;
            self
        }
        /// <p>The maximum number of objects that you want WAF to return for this request. If more
        /// objects are available, in the response, WAF provides a
        /// <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.limit = Some(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.limit = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAvailableManagedRuleGroupsInput`](crate::input::ListAvailableManagedRuleGroupsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListAvailableManagedRuleGroupsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListAvailableManagedRuleGroupsInput {
                scope: self.scope,
                next_marker: self.next_marker,
                limit: self.limit,
            })
        }
    }
}
#[doc(hidden)]
pub type ListAvailableManagedRuleGroupsInputOperationOutputAlias =
    crate::operation::ListAvailableManagedRuleGroups;
#[doc(hidden)]
pub type ListAvailableManagedRuleGroupsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListAvailableManagedRuleGroupsInput {
    /// Consumes the builder and constructs an Operation<[`ListAvailableManagedRuleGroups`](crate::operation::ListAvailableManagedRuleGroups)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListAvailableManagedRuleGroups,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_list_available_managed_rule_groups(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListAvailableManagedRuleGroups::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListAvailableManagedRuleGroups",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.ListAvailableManagedRuleGroups",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListAvailableManagedRuleGroupsInput`](crate::input::ListAvailableManagedRuleGroupsInput)
    pub fn builder() -> crate::input::list_available_managed_rule_groups_input::Builder {
        crate::input::list_available_managed_rule_groups_input::Builder::default()
    }
}

/// See [`ListIpSetsInput`](crate::input::ListIpSetsInput)
pub mod list_ip_sets_input {
    /// A builder for [`ListIpSetsInput`](crate::input::ListIpSetsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) next_marker: std::option::Option<std::string::String>,
        pub(crate) limit: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
        /// for retrieval exceeds the limit, WAF returns a <code>NextMarker</code>
        /// value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn next_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_marker = Some(input.into());
            self
        }
        pub fn set_next_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_marker = input;
            self
        }
        /// <p>The maximum number of objects that you want WAF to return for this request. If more
        /// objects are available, in the response, WAF provides a
        /// <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.limit = Some(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.limit = input;
            self
        }
        /// Consumes the builder and constructs a [`ListIpSetsInput`](crate::input::ListIpSetsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListIpSetsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListIpSetsInput {
                scope: self.scope,
                next_marker: self.next_marker,
                limit: self.limit,
            })
        }
    }
}
#[doc(hidden)]
pub type ListIPSetsInputOperationOutputAlias = crate::operation::ListIPSets;
#[doc(hidden)]
pub type ListIPSetsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListIpSetsInput {
    /// Consumes the builder and constructs an Operation<[`ListIPSets`](crate::operation::ListIPSets)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListIPSets,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_list_ip_sets(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListIPSets::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("ListIPSets", "wafv2"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.ListIPSets",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListIpSetsInput`](crate::input::ListIpSetsInput)
    pub fn builder() -> crate::input::list_ip_sets_input::Builder {
        crate::input::list_ip_sets_input::Builder::default()
    }
}

/// See [`ListLoggingConfigurationsInput`](crate::input::ListLoggingConfigurationsInput)
pub mod list_logging_configurations_input {
    /// A builder for [`ListLoggingConfigurationsInput`](crate::input::ListLoggingConfigurationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) next_marker: std::option::Option<std::string::String>,
        pub(crate) limit: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
        /// for retrieval exceeds the limit, WAF returns a <code>NextMarker</code>
        /// value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn next_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_marker = Some(input.into());
            self
        }
        pub fn set_next_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_marker = input;
            self
        }
        /// <p>The maximum number of objects that you want WAF to return for this request. If more
        /// objects are available, in the response, WAF provides a
        /// <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.limit = Some(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.limit = input;
            self
        }
        /// Consumes the builder and constructs a [`ListLoggingConfigurationsInput`](crate::input::ListLoggingConfigurationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListLoggingConfigurationsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListLoggingConfigurationsInput {
                scope: self.scope,
                next_marker: self.next_marker,
                limit: self.limit,
            })
        }
    }
}
#[doc(hidden)]
pub type ListLoggingConfigurationsInputOperationOutputAlias =
    crate::operation::ListLoggingConfigurations;
#[doc(hidden)]
pub type ListLoggingConfigurationsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListLoggingConfigurationsInput {
    /// Consumes the builder and constructs an Operation<[`ListLoggingConfigurations`](crate::operation::ListLoggingConfigurations)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListLoggingConfigurations,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_logging_configurations(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListLoggingConfigurations::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListLoggingConfigurations",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.ListLoggingConfigurations",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListLoggingConfigurationsInput`](crate::input::ListLoggingConfigurationsInput)
    pub fn builder() -> crate::input::list_logging_configurations_input::Builder {
        crate::input::list_logging_configurations_input::Builder::default()
    }
}

/// See [`ListRegexPatternSetsInput`](crate::input::ListRegexPatternSetsInput)
pub mod list_regex_pattern_sets_input {
    /// A builder for [`ListRegexPatternSetsInput`](crate::input::ListRegexPatternSetsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) next_marker: std::option::Option<std::string::String>,
        pub(crate) limit: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
        /// for retrieval exceeds the limit, WAF returns a <code>NextMarker</code>
        /// value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn next_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_marker = Some(input.into());
            self
        }
        pub fn set_next_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_marker = input;
            self
        }
        /// <p>The maximum number of objects that you want WAF to return for this request. If more
        /// objects are available, in the response, WAF provides a
        /// <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.limit = Some(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.limit = input;
            self
        }
        /// Consumes the builder and constructs a [`ListRegexPatternSetsInput`](crate::input::ListRegexPatternSetsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListRegexPatternSetsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListRegexPatternSetsInput {
                scope: self.scope,
                next_marker: self.next_marker,
                limit: self.limit,
            })
        }
    }
}
#[doc(hidden)]
pub type ListRegexPatternSetsInputOperationOutputAlias = crate::operation::ListRegexPatternSets;
#[doc(hidden)]
pub type ListRegexPatternSetsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListRegexPatternSetsInput {
    /// Consumes the builder and constructs an Operation<[`ListRegexPatternSets`](crate::operation::ListRegexPatternSets)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListRegexPatternSets,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_regex_pattern_sets(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListRegexPatternSets::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListRegexPatternSets",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.ListRegexPatternSets",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListRegexPatternSetsInput`](crate::input::ListRegexPatternSetsInput)
    pub fn builder() -> crate::input::list_regex_pattern_sets_input::Builder {
        crate::input::list_regex_pattern_sets_input::Builder::default()
    }
}

/// See [`ListResourcesForWebAclInput`](crate::input::ListResourcesForWebAclInput)
pub mod list_resources_for_web_acl_input {
    /// A builder for [`ListResourcesForWebAclInput`](crate::input::ListResourcesForWebAclInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) web_acl_arn: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the web ACL.</p>
        pub fn web_acl_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.web_acl_arn = Some(input.into());
            self
        }
        pub fn set_web_acl_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.web_acl_arn = input;
            self
        }
        /// <p>Used for web ACLs that are scoped for regional applications. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API. </p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ListResourcesForWebAclInput`](crate::input::ListResourcesForWebAclInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListResourcesForWebAclInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListResourcesForWebAclInput {
                web_acl_arn: self.web_acl_arn,
                resource_type: self.resource_type,
            })
        }
    }
}
#[doc(hidden)]
pub type ListResourcesForWebACLInputOperationOutputAlias = crate::operation::ListResourcesForWebACL;
#[doc(hidden)]
pub type ListResourcesForWebACLInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListResourcesForWebAclInput {
    /// Consumes the builder and constructs an Operation<[`ListResourcesForWebACL`](crate::operation::ListResourcesForWebACL)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListResourcesForWebACL,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_resources_for_web_acl(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListResourcesForWebACL::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListResourcesForWebACL",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.ListResourcesForWebACL",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListResourcesForWebAclInput`](crate::input::ListResourcesForWebAclInput)
    pub fn builder() -> crate::input::list_resources_for_web_acl_input::Builder {
        crate::input::list_resources_for_web_acl_input::Builder::default()
    }
}

/// See [`ListRuleGroupsInput`](crate::input::ListRuleGroupsInput)
pub mod list_rule_groups_input {
    /// A builder for [`ListRuleGroupsInput`](crate::input::ListRuleGroupsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) next_marker: std::option::Option<std::string::String>,
        pub(crate) limit: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
        /// for retrieval exceeds the limit, WAF returns a <code>NextMarker</code>
        /// value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn next_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_marker = Some(input.into());
            self
        }
        pub fn set_next_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_marker = input;
            self
        }
        /// <p>The maximum number of objects that you want WAF to return for this request. If more
        /// objects are available, in the response, WAF provides a
        /// <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.limit = Some(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.limit = input;
            self
        }
        /// Consumes the builder and constructs a [`ListRuleGroupsInput`](crate::input::ListRuleGroupsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListRuleGroupsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListRuleGroupsInput {
                scope: self.scope,
                next_marker: self.next_marker,
                limit: self.limit,
            })
        }
    }
}
#[doc(hidden)]
pub type ListRuleGroupsInputOperationOutputAlias = crate::operation::ListRuleGroups;
#[doc(hidden)]
pub type ListRuleGroupsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListRuleGroupsInput {
    /// Consumes the builder and constructs an Operation<[`ListRuleGroups`](crate::operation::ListRuleGroups)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListRuleGroups,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_rule_groups(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListRuleGroups::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListRuleGroups",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.ListRuleGroups",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListRuleGroupsInput`](crate::input::ListRuleGroupsInput)
    pub fn builder() -> crate::input::list_rule_groups_input::Builder {
        crate::input::list_rule_groups_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
pub mod list_tags_for_resource_input {
    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_marker: std::option::Option<std::string::String>,
        pub(crate) limit: std::option::Option<i32>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
        /// for retrieval exceeds the limit, WAF returns a <code>NextMarker</code>
        /// value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn next_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_marker = Some(input.into());
            self
        }
        pub fn set_next_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_marker = input;
            self
        }
        /// <p>The maximum number of objects that you want WAF to return for this request. If more
        /// objects are available, in the response, WAF provides a
        /// <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.limit = Some(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.limit = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListTagsForResourceInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListTagsForResourceInput {
                next_marker: self.next_marker,
                limit: self.limit,
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type ListTagsForResourceInputOperationOutputAlias = crate::operation::ListTagsForResource;
#[doc(hidden)]
pub type ListTagsForResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListTagsForResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_list_tags_for_resource(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListTagsForResource::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListTagsForResource",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.ListTagsForResource",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`ListWebAcLsInput`](crate::input::ListWebAcLsInput)
pub mod list_web_ac_ls_input {
    /// A builder for [`ListWebAcLsInput`](crate::input::ListWebAcLsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) next_marker: std::option::Option<std::string::String>,
        pub(crate) limit: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
        /// for retrieval exceeds the limit, WAF returns a <code>NextMarker</code>
        /// value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
        pub fn next_marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_marker = Some(input.into());
            self
        }
        pub fn set_next_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_marker = input;
            self
        }
        /// <p>The maximum number of objects that you want WAF to return for this request. If more
        /// objects are available, in the response, WAF provides a
        /// <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.limit = Some(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.limit = input;
            self
        }
        /// Consumes the builder and constructs a [`ListWebAcLsInput`](crate::input::ListWebAcLsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListWebAcLsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListWebAcLsInput {
                scope: self.scope,
                next_marker: self.next_marker,
                limit: self.limit,
            })
        }
    }
}
#[doc(hidden)]
pub type ListWebACLsInputOperationOutputAlias = crate::operation::ListWebACLs;
#[doc(hidden)]
pub type ListWebACLsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListWebAcLsInput {
    /// Consumes the builder and constructs an Operation<[`ListWebACLs`](crate::operation::ListWebACLs)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListWebACLs,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_list_web_ac_ls(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListWebACLs::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListWebACLs",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.ListWebACLs",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListWebAcLsInput`](crate::input::ListWebAcLsInput)
    pub fn builder() -> crate::input::list_web_ac_ls_input::Builder {
        crate::input::list_web_ac_ls_input::Builder::default()
    }
}

/// See [`PutLoggingConfigurationInput`](crate::input::PutLoggingConfigurationInput)
pub mod put_logging_configuration_input {
    /// A builder for [`PutLoggingConfigurationInput`](crate::input::PutLoggingConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) logging_configuration: std::option::Option<crate::model::LoggingConfiguration>,
    }
    impl Builder {
        /// <p></p>
        pub fn logging_configuration(mut self, input: crate::model::LoggingConfiguration) -> Self {
            self.logging_configuration = Some(input);
            self
        }
        pub fn set_logging_configuration(
            mut self,
            input: std::option::Option<crate::model::LoggingConfiguration>,
        ) -> Self {
            self.logging_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PutLoggingConfigurationInput`](crate::input::PutLoggingConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutLoggingConfigurationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutLoggingConfigurationInput {
                logging_configuration: self.logging_configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type PutLoggingConfigurationInputOperationOutputAlias =
    crate::operation::PutLoggingConfiguration;
#[doc(hidden)]
pub type PutLoggingConfigurationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutLoggingConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutLoggingConfiguration`](crate::operation::PutLoggingConfiguration)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutLoggingConfiguration,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_put_logging_configuration(&self)
                .map_err(|err| {
                smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutLoggingConfiguration::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutLoggingConfiguration",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.PutLoggingConfiguration",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutLoggingConfigurationInput`](crate::input::PutLoggingConfigurationInput)
    pub fn builder() -> crate::input::put_logging_configuration_input::Builder {
        crate::input::put_logging_configuration_input::Builder::default()
    }
}

/// See [`PutPermissionPolicyInput`](crate::input::PutPermissionPolicyInput)
pub mod put_permission_policy_input {
    /// A builder for [`PutPermissionPolicyInput`](crate::input::PutPermissionPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) policy: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the <a>RuleGroup</a> to which you want to attach the policy.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The policy to attach to the specified rule group. </p>
        /// <p>The policy specifications must conform to the following:</p>
        /// <ul>
        /// <li>
        /// <p>The policy must be composed using IAM Policy version 2012-10-17 or version 2015-01-01.</p>
        /// </li>
        /// <li>
        /// <p>The policy must include specifications for <code>Effect</code>, <code>Action</code>, and <code>Principal</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Effect</code> must specify <code>Allow</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Action</code> must specify <code>wafv2:CreateWebACL</code>, <code>wafv2:UpdateWebACL</code>, and <code>wafv2:PutFirewallManagerRuleGroups</code>. WAF rejects any extra actions or wildcard actions in the policy.</p>
        /// </li>
        /// <li>
        /// <p>The policy must not include a <code>Resource</code> parameter.</p>
        /// </li>
        /// </ul>     
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html">IAM Policies</a>.  </p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy = Some(input.into());
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy = input;
            self
        }
        /// Consumes the builder and constructs a [`PutPermissionPolicyInput`](crate::input::PutPermissionPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutPermissionPolicyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutPermissionPolicyInput {
                resource_arn: self.resource_arn,
                policy: self.policy,
            })
        }
    }
}
#[doc(hidden)]
pub type PutPermissionPolicyInputOperationOutputAlias = crate::operation::PutPermissionPolicy;
#[doc(hidden)]
pub type PutPermissionPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutPermissionPolicyInput {
    /// Consumes the builder and constructs an Operation<[`PutPermissionPolicy`](crate::operation::PutPermissionPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutPermissionPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_put_permission_policy(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutPermissionPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutPermissionPolicy",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.PutPermissionPolicy",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutPermissionPolicyInput`](crate::input::PutPermissionPolicyInput)
    pub fn builder() -> crate::input::put_permission_policy_input::Builder {
        crate::input::put_permission_policy_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput)
pub mod tag_resource_input {
    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::TagResourceInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::TagResourceInput {
                resource_arn: self.resource_arn,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagResourceInputOperationOutputAlias = crate::operation::TagResource;
#[doc(hidden)]
pub type TagResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::TagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_tag_resource(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::TagResource::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "TagResource",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.TagResource",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput)
pub mod untag_resource_input {
    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(input.into());
            self.tag_keys = Some(v);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::UntagResourceInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UntagResourceInput {
                resource_arn: self.resource_arn,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagResourceInputOperationOutputAlias = crate::operation::UntagResource;
#[doc(hidden)]
pub type UntagResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UntagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_untag_resource(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UntagResource::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UntagResource",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.UntagResource",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UpdateIpSetInput`](crate::input::UpdateIpSetInput)
pub mod update_ip_set_input {
    /// A builder for [`UpdateIpSetInput`](crate::input::UpdateIpSetInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) addresses: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) lock_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>A description of the IP set that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        pub fn addresses(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.addresses.unwrap_or_default();
            v.push(input.into());
            self.addresses = Some(v);
            self
        }
        pub fn set_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.addresses = input;
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.lock_token = Some(input.into());
            self
        }
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lock_token = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateIpSetInput`](crate::input::UpdateIpSetInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::UpdateIpSetInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UpdateIpSetInput {
                name: self.name,
                scope: self.scope,
                id: self.id,
                description: self.description,
                addresses: self.addresses,
                lock_token: self.lock_token,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateIPSetInputOperationOutputAlias = crate::operation::UpdateIPSet;
#[doc(hidden)]
pub type UpdateIPSetInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateIpSetInput {
    /// Consumes the builder and constructs an Operation<[`UpdateIPSet`](crate::operation::UpdateIPSet)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateIPSet,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_update_ip_set(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateIPSet::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateIPSet",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.UpdateIPSet",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateIpSetInput`](crate::input::UpdateIpSetInput)
    pub fn builder() -> crate::input::update_ip_set_input::Builder {
        crate::input::update_ip_set_input::Builder::default()
    }
}

/// See [`UpdateRegexPatternSetInput`](crate::input::UpdateRegexPatternSetInput)
pub mod update_regex_pattern_set_input {
    /// A builder for [`UpdateRegexPatternSetInput`](crate::input::UpdateRegexPatternSetInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) regular_expression_list: std::option::Option<std::vec::Vec<crate::model::Regex>>,
        pub(crate) lock_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the set. You cannot change the name after you create the set.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>A description of the set that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        pub fn regular_expression_list(mut self, input: impl Into<crate::model::Regex>) -> Self {
            let mut v = self.regular_expression_list.unwrap_or_default();
            v.push(input.into());
            self.regular_expression_list = Some(v);
            self
        }
        pub fn set_regular_expression_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Regex>>,
        ) -> Self {
            self.regular_expression_list = input;
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.lock_token = Some(input.into());
            self
        }
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lock_token = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateRegexPatternSetInput`](crate::input::UpdateRegexPatternSetInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateRegexPatternSetInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateRegexPatternSetInput {
                name: self.name,
                scope: self.scope,
                id: self.id,
                description: self.description,
                regular_expression_list: self.regular_expression_list,
                lock_token: self.lock_token,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateRegexPatternSetInputOperationOutputAlias = crate::operation::UpdateRegexPatternSet;
#[doc(hidden)]
pub type UpdateRegexPatternSetInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateRegexPatternSetInput {
    /// Consumes the builder and constructs an Operation<[`UpdateRegexPatternSet`](crate::operation::UpdateRegexPatternSet)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateRegexPatternSet,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_update_regex_pattern_set(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateRegexPatternSet::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateRegexPatternSet",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.UpdateRegexPatternSet",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateRegexPatternSetInput`](crate::input::UpdateRegexPatternSetInput)
    pub fn builder() -> crate::input::update_regex_pattern_set_input::Builder {
        crate::input::update_regex_pattern_set_input::Builder::default()
    }
}

/// See [`UpdateRuleGroupInput`](crate::input::UpdateRuleGroupInput)
pub mod update_rule_group_input {
    /// A builder for [`UpdateRuleGroupInput`](crate::input::UpdateRuleGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) rules: std::option::Option<std::vec::Vec<crate::model::Rule>>,
        pub(crate) visibility_config: std::option::Option<crate::model::VisibilityConfig>,
        pub(crate) lock_token: std::option::Option<std::string::String>,
        pub(crate) custom_response_bodies: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::CustomResponseBody>,
        >,
    }
    impl Builder {
        /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>A unique identifier for the rule group. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>A description of the rule group that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        pub fn rules(mut self, input: impl Into<crate::model::Rule>) -> Self {
            let mut v = self.rules.unwrap_or_default();
            v.push(input.into());
            self.rules = Some(v);
            self
        }
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Rule>>,
        ) -> Self {
            self.rules = input;
            self
        }
        /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection.  </p>
        pub fn visibility_config(mut self, input: crate::model::VisibilityConfig) -> Self {
            self.visibility_config = Some(input);
            self
        }
        pub fn set_visibility_config(
            mut self,
            input: std::option::Option<crate::model::VisibilityConfig>,
        ) -> Self {
            self.visibility_config = input;
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.lock_token = Some(input.into());
            self
        }
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lock_token = input;
            self
        }
        pub fn custom_response_bodies(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::CustomResponseBody>,
        ) -> Self {
            let mut hash_map = self.custom_response_bodies.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.custom_response_bodies = Some(hash_map);
            self
        }
        pub fn set_custom_response_bodies(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::CustomResponseBody>,
            >,
        ) -> Self {
            self.custom_response_bodies = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateRuleGroupInput`](crate::input::UpdateRuleGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateRuleGroupInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateRuleGroupInput {
                name: self.name,
                scope: self.scope,
                id: self.id,
                description: self.description,
                rules: self.rules,
                visibility_config: self.visibility_config,
                lock_token: self.lock_token,
                custom_response_bodies: self.custom_response_bodies,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateRuleGroupInputOperationOutputAlias = crate::operation::UpdateRuleGroup;
#[doc(hidden)]
pub type UpdateRuleGroupInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateRuleGroupInput {
    /// Consumes the builder and constructs an Operation<[`UpdateRuleGroup`](crate::operation::UpdateRuleGroup)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateRuleGroup,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_update_rule_group(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateRuleGroup::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateRuleGroup",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.UpdateRuleGroup",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateRuleGroupInput`](crate::input::UpdateRuleGroupInput)
    pub fn builder() -> crate::input::update_rule_group_input::Builder {
        crate::input::update_rule_group_input::Builder::default()
    }
}

/// See [`UpdateWebAclInput`](crate::input::UpdateWebAclInput)
pub mod update_web_acl_input {
    /// A builder for [`UpdateWebAclInput`](crate::input::UpdateWebAclInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) default_action: std::option::Option<crate::model::DefaultAction>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) rules: std::option::Option<std::vec::Vec<crate::model::Rule>>,
        pub(crate) visibility_config: std::option::Option<crate::model::VisibilityConfig>,
        pub(crate) lock_token: std::option::Option<std::string::String>,
        pub(crate) custom_response_bodies: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::CustomResponseBody>,
        >,
    }
    impl Builder {
        /// <p>The name of the web ACL. You cannot change the name of a web ACL after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
        /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
        /// <ul>
        /// <li>
        /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
        /// </li>
        /// <li>
        /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
        /// </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p>The unique identifier for the web ACL. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The action to perform if none of the <code>Rules</code> contained in the <code>WebACL</code> match. </p>
        pub fn default_action(mut self, input: crate::model::DefaultAction) -> Self {
            self.default_action = Some(input);
            self
        }
        pub fn set_default_action(
            mut self,
            input: std::option::Option<crate::model::DefaultAction>,
        ) -> Self {
            self.default_action = input;
            self
        }
        /// <p>A description of the web ACL that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        pub fn rules(mut self, input: impl Into<crate::model::Rule>) -> Self {
            let mut v = self.rules.unwrap_or_default();
            v.push(input.into());
            self.rules = Some(v);
            self
        }
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Rule>>,
        ) -> Self {
            self.rules = input;
            self
        }
        /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection.  </p>
        pub fn visibility_config(mut self, input: crate::model::VisibilityConfig) -> Self {
            self.visibility_config = Some(input);
            self
        }
        pub fn set_visibility_config(
            mut self,
            input: std::option::Option<crate::model::VisibilityConfig>,
        ) -> Self {
            self.visibility_config = input;
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.lock_token = Some(input.into());
            self
        }
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lock_token = input;
            self
        }
        pub fn custom_response_bodies(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::CustomResponseBody>,
        ) -> Self {
            let mut hash_map = self.custom_response_bodies.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.custom_response_bodies = Some(hash_map);
            self
        }
        pub fn set_custom_response_bodies(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::CustomResponseBody>,
            >,
        ) -> Self {
            self.custom_response_bodies = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateWebAclInput`](crate::input::UpdateWebAclInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::UpdateWebAclInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UpdateWebAclInput {
                name: self.name,
                scope: self.scope,
                id: self.id,
                default_action: self.default_action,
                description: self.description,
                rules: self.rules,
                visibility_config: self.visibility_config,
                lock_token: self.lock_token,
                custom_response_bodies: self.custom_response_bodies,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateWebACLInputOperationOutputAlias = crate::operation::UpdateWebACL;
#[doc(hidden)]
pub type UpdateWebACLInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateWebAclInput {
    /// Consumes the builder and constructs an Operation<[`UpdateWebACL`](crate::operation::UpdateWebACL)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateWebACL,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_update_web_acl(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateWebACL::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateWebACL",
                "wafv2",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "AWSWAF_20190729.UpdateWebACL",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateWebAclInput`](crate::input::UpdateWebAclInput)
    pub fn builder() -> crate::input::update_web_acl_input::Builder {
        crate::input::update_web_acl_input::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateWebAclInput {
    /// <p>The name of the web ACL. You cannot change the name of a web ACL after you create it.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>The unique identifier for the web ACL. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The action to perform if none of the <code>Rules</code> contained in the <code>WebACL</code> match. </p>
    pub default_action: std::option::Option<crate::model::DefaultAction>,
    /// <p>A description of the web ACL that helps with identification. </p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The <a>Rule</a> statements used to identify the web requests that you
    /// want to allow, block, or count. Each rule includes one top-level statement that WAF uses to identify matching  
    /// web requests, and parameters that govern how WAF handles them.
    /// </p>
    pub rules: std::option::Option<std::vec::Vec<crate::model::Rule>>,
    /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection.  </p>
    pub visibility_config: std::option::Option<crate::model::VisibilityConfig>,
    /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    pub lock_token: std::option::Option<std::string::String>,
    /// <p>A map of custom response keys and content bodies. When you create a rule with a block action, you can send a custom response to the web request. You define these for the web ACL, and then use them in the rules and default actions that you define in the web ACL. </p>
    /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the
    /// <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the
    /// <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    pub custom_response_bodies: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::CustomResponseBody>,
    >,
}
impl std::fmt::Debug for UpdateWebAclInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateWebAclInput");
        formatter.field("name", &self.name);
        formatter.field("scope", &self.scope);
        formatter.field("id", &self.id);
        formatter.field("default_action", &self.default_action);
        formatter.field("description", &self.description);
        formatter.field("rules", &self.rules);
        formatter.field("visibility_config", &self.visibility_config);
        formatter.field("lock_token", &self.lock_token);
        formatter.field("custom_response_bodies", &self.custom_response_bodies);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateRuleGroupInput {
    /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>A unique identifier for the rule group. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>A description of the rule group that helps with identification. </p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The <a>Rule</a> statements used to identify the web requests that you
    /// want to allow, block, or count. Each rule includes one top-level statement that WAF uses to identify matching  
    /// web requests, and parameters that govern how WAF handles them.
    /// </p>
    pub rules: std::option::Option<std::vec::Vec<crate::model::Rule>>,
    /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection.  </p>
    pub visibility_config: std::option::Option<crate::model::VisibilityConfig>,
    /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    pub lock_token: std::option::Option<std::string::String>,
    /// <p>A map of custom response keys and content bodies. When you create a rule with a block action, you can send a custom response to the web request. You define these for the rule group, and then use them in the rules that you define in the rule group. </p>
    /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the
    /// <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the
    /// <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    pub custom_response_bodies: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::CustomResponseBody>,
    >,
}
impl std::fmt::Debug for UpdateRuleGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateRuleGroupInput");
        formatter.field("name", &self.name);
        formatter.field("scope", &self.scope);
        formatter.field("id", &self.id);
        formatter.field("description", &self.description);
        formatter.field("rules", &self.rules);
        formatter.field("visibility_config", &self.visibility_config);
        formatter.field("lock_token", &self.lock_token);
        formatter.field("custom_response_bodies", &self.custom_response_bodies);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateRegexPatternSetInput {
    /// <p>The name of the set. You cannot change the name after you create the set.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>A description of the set that helps with identification. </p>
    pub description: std::option::Option<std::string::String>,
    /// <p></p>
    pub regular_expression_list: std::option::Option<std::vec::Vec<crate::model::Regex>>,
    /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    pub lock_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateRegexPatternSetInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateRegexPatternSetInput");
        formatter.field("name", &self.name);
        formatter.field("scope", &self.scope);
        formatter.field("id", &self.id);
        formatter.field("description", &self.description);
        formatter.field("regular_expression_list", &self.regular_expression_list);
        formatter.field("lock_token", &self.lock_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateIpSetInput {
    /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>A description of the IP set that helps with identification. </p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Contains an array of strings that specify one or more IP addresses or blocks of IP addresses in Classless Inter-Domain Routing (CIDR) notation. WAF supports all IPv4 and IPv6 CIDR ranges except for /0. </p>
    /// <p>Examples: </p>
    /// <ul>
    /// <li>
    /// <p>To configure WAF to allow, block, or count requests that originated from the IP address 192.0.2.44, specify <code>192.0.2.44/32</code>.</p>
    /// </li>
    /// <li>
    /// <p>To configure WAF to allow, block, or count requests that originated from IP addresses from 192.0.2.0 to 192.0.2.255, specify
    /// <code>192.0.2.0/24</code>.</p>
    /// </li>
    /// <li>
    /// <p>To configure WAF to allow, block, or count requests that originated from the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify <code>1111:0000:0000:0000:0000:0000:0000:0111/128</code>.</p>
    /// </li>
    /// <li>
    /// <p>To configure WAF to allow, block, or count requests that originated from IP addresses 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify <code>1111:0000:0000:0000:0000:0000:0000:0000/64</code>.</p>
    /// </li>
    /// </ul>
    /// <p>For more information about CIDR notation, see the Wikipedia entry <a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless
    /// Inter-Domain Routing</a>.</p>
    pub addresses: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    pub lock_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateIpSetInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateIpSetInput");
        formatter.field("name", &self.name);
        formatter.field("scope", &self.scope);
        formatter.field("id", &self.id);
        formatter.field("description", &self.description);
        formatter.field("addresses", &self.addresses);
        formatter.field("lock_token", &self.lock_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>An array of keys identifying the tags to disassociate from the resource.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for UntagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>An array of key:value pairs to associate with the resource.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutPermissionPolicyInput {
    /// <p>The Amazon Resource Name (ARN) of the <a>RuleGroup</a> to which you want to attach the policy.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The policy to attach to the specified rule group. </p>
    /// <p>The policy specifications must conform to the following:</p>
    /// <ul>
    /// <li>
    /// <p>The policy must be composed using IAM Policy version 2012-10-17 or version 2015-01-01.</p>
    /// </li>
    /// <li>
    /// <p>The policy must include specifications for <code>Effect</code>, <code>Action</code>, and <code>Principal</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Effect</code> must specify <code>Allow</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Action</code> must specify <code>wafv2:CreateWebACL</code>, <code>wafv2:UpdateWebACL</code>, and <code>wafv2:PutFirewallManagerRuleGroups</code>. WAF rejects any extra actions or wildcard actions in the policy.</p>
    /// </li>
    /// <li>
    /// <p>The policy must not include a <code>Resource</code> parameter.</p>
    /// </li>
    /// </ul>     
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html">IAM Policies</a>.  </p>
    pub policy: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutPermissionPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutPermissionPolicyInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("policy", &self.policy);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutLoggingConfigurationInput {
    /// <p></p>
    pub logging_configuration: std::option::Option<crate::model::LoggingConfiguration>,
}
impl std::fmt::Debug for PutLoggingConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutLoggingConfigurationInput");
        formatter.field("logging_configuration", &self.logging_configuration);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListWebAcLsInput {
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
    /// for retrieval exceeds the limit, WAF returns a <code>NextMarker</code>
    /// value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub next_marker: std::option::Option<std::string::String>,
    /// <p>The maximum number of objects that you want WAF to return for this request. If more
    /// objects are available, in the response, WAF provides a
    /// <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    pub limit: std::option::Option<i32>,
}
impl std::fmt::Debug for ListWebAcLsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListWebAcLsInput");
        formatter.field("scope", &self.scope);
        formatter.field("next_marker", &self.next_marker);
        formatter.field("limit", &self.limit);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceInput {
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
    /// for retrieval exceeds the limit, WAF returns a <code>NextMarker</code>
    /// value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub next_marker: std::option::Option<std::string::String>,
    /// <p>The maximum number of objects that you want WAF to return for this request. If more
    /// objects are available, in the response, WAF provides a
    /// <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    pub limit: std::option::Option<i32>,
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListTagsForResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceInput");
        formatter.field("next_marker", &self.next_marker);
        formatter.field("limit", &self.limit);
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListRuleGroupsInput {
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
    /// for retrieval exceeds the limit, WAF returns a <code>NextMarker</code>
    /// value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub next_marker: std::option::Option<std::string::String>,
    /// <p>The maximum number of objects that you want WAF to return for this request. If more
    /// objects are available, in the response, WAF provides a
    /// <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    pub limit: std::option::Option<i32>,
}
impl std::fmt::Debug for ListRuleGroupsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListRuleGroupsInput");
        formatter.field("scope", &self.scope);
        formatter.field("next_marker", &self.next_marker);
        formatter.field("limit", &self.limit);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListResourcesForWebAclInput {
    /// <p>The Amazon Resource Name (ARN) of the web ACL.</p>
    pub web_acl_arn: std::option::Option<std::string::String>,
    /// <p>Used for web ACLs that are scoped for regional applications. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API. </p>
    pub resource_type: std::option::Option<crate::model::ResourceType>,
}
impl std::fmt::Debug for ListResourcesForWebAclInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListResourcesForWebAclInput");
        formatter.field("web_acl_arn", &self.web_acl_arn);
        formatter.field("resource_type", &self.resource_type);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListRegexPatternSetsInput {
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
    /// for retrieval exceeds the limit, WAF returns a <code>NextMarker</code>
    /// value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub next_marker: std::option::Option<std::string::String>,
    /// <p>The maximum number of objects that you want WAF to return for this request. If more
    /// objects are available, in the response, WAF provides a
    /// <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    pub limit: std::option::Option<i32>,
}
impl std::fmt::Debug for ListRegexPatternSetsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListRegexPatternSetsInput");
        formatter.field("scope", &self.scope);
        formatter.field("next_marker", &self.next_marker);
        formatter.field("limit", &self.limit);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListLoggingConfigurationsInput {
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
    /// for retrieval exceeds the limit, WAF returns a <code>NextMarker</code>
    /// value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub next_marker: std::option::Option<std::string::String>,
    /// <p>The maximum number of objects that you want WAF to return for this request. If more
    /// objects are available, in the response, WAF provides a
    /// <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    pub limit: std::option::Option<i32>,
}
impl std::fmt::Debug for ListLoggingConfigurationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListLoggingConfigurationsInput");
        formatter.field("scope", &self.scope);
        formatter.field("next_marker", &self.next_marker);
        formatter.field("limit", &self.limit);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListIpSetsInput {
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
    /// for retrieval exceeds the limit, WAF returns a <code>NextMarker</code>
    /// value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub next_marker: std::option::Option<std::string::String>,
    /// <p>The maximum number of objects that you want WAF to return for this request. If more
    /// objects are available, in the response, WAF provides a
    /// <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    pub limit: std::option::Option<i32>,
}
impl std::fmt::Debug for ListIpSetsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListIpSetsInput");
        formatter.field("scope", &self.scope);
        formatter.field("next_marker", &self.next_marker);
        formatter.field("limit", &self.limit);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAvailableManagedRuleGroupsInput {
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
    /// for retrieval exceeds the limit, WAF returns a <code>NextMarker</code>
    /// value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    pub next_marker: std::option::Option<std::string::String>,
    /// <p>The maximum number of objects that you want WAF to return for this request. If more
    /// objects are available, in the response, WAF provides a
    /// <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    pub limit: std::option::Option<i32>,
}
impl std::fmt::Debug for ListAvailableManagedRuleGroupsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAvailableManagedRuleGroupsInput");
        formatter.field("scope", &self.scope);
        formatter.field("next_marker", &self.next_marker);
        formatter.field("limit", &self.limit);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetWebAclForResourceInput {
    /// <p>The ARN (Amazon Resource Name) of the resource.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetWebAclForResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetWebAclForResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetWebAclInput {
    /// <p>The name of the web ACL. You cannot change the name of a web ACL after you create it.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>The unique identifier for the web ACL. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetWebAclInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetWebAclInput");
        formatter.field("name", &self.name);
        formatter.field("scope", &self.scope);
        formatter.field("id", &self.id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetSampledRequestsInput {
    /// <p>The Amazon resource name (ARN) of the <code>WebACL</code> for which you want a sample of requests.</p>
    pub web_acl_arn: std::option::Option<std::string::String>,
    /// <p>The metric name assigned to the <code>Rule</code> or <code>RuleGroup</code> for which you want a sample of requests.</p>
    pub rule_metric_name: std::option::Option<std::string::String>,
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>The start date and time and the end date and time of the range for which you want <code>GetSampledRequests</code> to return a
    /// sample of requests. You must specify the times in Coordinated Universal Time (UTC) format. UTC format includes the special designator, <code>Z</code>. For example, <code>"2016-09-27T14:50Z"</code>. You can specify any time range in the previous three hours. If you specify a start time that's earlier than three hours ago, WAF sets it to three hours ago.</p>
    pub time_window: std::option::Option<crate::model::TimeWindow>,
    /// <p>The number of requests that you want WAF to return from among the first 5,000 requests that your Amazon Web Services resource received
    /// during the time range. If your resource received fewer requests than the value of <code>MaxItems</code>, <code>GetSampledRequests</code>
    /// returns information about all of them. </p>
    pub max_items: i64,
}
impl std::fmt::Debug for GetSampledRequestsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetSampledRequestsInput");
        formatter.field("web_acl_arn", &self.web_acl_arn);
        formatter.field("rule_metric_name", &self.rule_metric_name);
        formatter.field("scope", &self.scope);
        formatter.field("time_window", &self.time_window);
        formatter.field("max_items", &self.max_items);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRuleGroupInput {
    /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>A unique identifier for the rule group. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    pub arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetRuleGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRuleGroupInput");
        formatter.field("name", &self.name);
        formatter.field("scope", &self.scope);
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRegexPatternSetInput {
    /// <p>The name of the set. You cannot change the name after you create the set.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetRegexPatternSetInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRegexPatternSetInput");
        formatter.field("name", &self.name);
        formatter.field("scope", &self.scope);
        formatter.field("id", &self.id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRateBasedStatementManagedKeysInput {
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>The name of the web ACL. You cannot change the name of a web ACL after you create it.</p>
    pub web_acl_name: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the web ACL. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub web_acl_id: std::option::Option<std::string::String>,
    /// <p>The name of the rate-based rule to get the keys for.</p>
    pub rule_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetRateBasedStatementManagedKeysInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRateBasedStatementManagedKeysInput");
        formatter.field("scope", &self.scope);
        formatter.field("web_acl_name", &self.web_acl_name);
        formatter.field("web_acl_id", &self.web_acl_id);
        formatter.field("rule_name", &self.rule_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPermissionPolicyInput {
    /// <p>The Amazon Resource Name (ARN) of the rule group for which you want to get the policy.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetPermissionPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetPermissionPolicyInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLoggingConfigurationInput {
    /// <p>The Amazon Resource Name (ARN) of the web ACL for which you want to get the <a>LoggingConfiguration</a>.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetLoggingConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLoggingConfigurationInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetIpSetInput {
    /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetIpSetInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetIpSetInput");
        formatter.field("name", &self.name);
        formatter.field("scope", &self.scope);
        formatter.field("id", &self.id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisassociateWebAclInput {
    /// <p>The Amazon Resource Name (ARN) of the resource to disassociate from the web ACL. </p>
    /// <p>The ARN must be in one of the following formats:</p>
    /// <ul>
    /// <li>
    /// <p>For an Application Load Balancer: <code>arn:aws:elasticloadbalancing:<i>region</i>:<i>account-id</i>:loadbalancer/app/<i>load-balancer-name</i>/<i>load-balancer-id</i>
    /// </code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>For an Amazon API Gateway REST API: <code>arn:aws:apigateway:<i>region</i>::/restapis/<i>api-id</i>/stages/<i>stage-name</i>
    /// </code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>For an AppSync GraphQL API: <code>arn:aws:appsync:<i>region</i>:<i>account-id</i>:apis/<i>GraphQLApiId</i>
    /// </code>
    /// </p>
    /// </li>
    /// </ul>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DisassociateWebAclInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisassociateWebAclInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeManagedRuleGroupInput {
    /// <p>The name of the managed rule group vendor. You use this, along with the rule group name, to identify the rule group.</p>
    pub vendor_name: std::option::Option<std::string::String>,
    /// <p>The name of the managed rule group. You use this, along with the vendor name, to identify the rule group.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
}
impl std::fmt::Debug for DescribeManagedRuleGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeManagedRuleGroupInput");
        formatter.field("vendor_name", &self.vendor_name);
        formatter.field("name", &self.name);
        formatter.field("scope", &self.scope);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteWebAclInput {
    /// <p>The name of the web ACL. You cannot change the name of a web ACL after you create it.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>The unique identifier for the web ACL. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    pub lock_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteWebAclInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteWebAclInput");
        formatter.field("name", &self.name);
        formatter.field("scope", &self.scope);
        formatter.field("id", &self.id);
        formatter.field("lock_token", &self.lock_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteRuleGroupInput {
    /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>A unique identifier for the rule group. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    pub lock_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteRuleGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteRuleGroupInput");
        formatter.field("name", &self.name);
        formatter.field("scope", &self.scope);
        formatter.field("id", &self.id);
        formatter.field("lock_token", &self.lock_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteRegexPatternSetInput {
    /// <p>The name of the set. You cannot change the name after you create the set.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    pub lock_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteRegexPatternSetInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteRegexPatternSetInput");
        formatter.field("name", &self.name);
        formatter.field("scope", &self.scope);
        formatter.field("id", &self.id);
        formatter.field("lock_token", &self.lock_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeletePermissionPolicyInput {
    /// <p>The Amazon Resource Name (ARN) of the rule group from which you want to delete the policy.</p>
    /// <p>You must be the owner of the rule group to perform this operation.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeletePermissionPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeletePermissionPolicyInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteLoggingConfigurationInput {
    /// <p>The Amazon Resource Name (ARN) of the web ACL from which you want to delete the <a>LoggingConfiguration</a>.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteLoggingConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteLoggingConfigurationInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteIpSetInput {
    /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    pub lock_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteIpSetInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteIpSetInput");
        formatter.field("name", &self.name);
        formatter.field("scope", &self.scope);
        formatter.field("id", &self.id);
        formatter.field("lock_token", &self.lock_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteFirewallManagerRuleGroupsInput {
    /// <p>The Amazon Resource Name (ARN) of the web ACL.</p>
    pub web_acl_arn: std::option::Option<std::string::String>,
    /// <p>A token used for optimistic locking. WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    pub web_acl_lock_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteFirewallManagerRuleGroupsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteFirewallManagerRuleGroupsInput");
        formatter.field("web_acl_arn", &self.web_acl_arn);
        formatter.field("web_acl_lock_token", &self.web_acl_lock_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateWebAclInput {
    /// <p>The name of the web ACL. You cannot change the name of a web ACL after you create it.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>The action to perform if none of the <code>Rules</code> contained in the <code>WebACL</code> match. </p>
    pub default_action: std::option::Option<crate::model::DefaultAction>,
    /// <p>A description of the web ACL that helps with identification. </p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The <a>Rule</a> statements used to identify the web requests that you
    /// want to allow, block, or count. Each rule includes one top-level statement that WAF uses to identify matching  
    /// web requests, and parameters that govern how WAF handles them.
    /// </p>
    pub rules: std::option::Option<std::vec::Vec<crate::model::Rule>>,
    /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection.  </p>
    pub visibility_config: std::option::Option<crate::model::VisibilityConfig>,
    /// <p>An array of key:value pairs to associate with the resource.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>A map of custom response keys and content bodies. When you create a rule with a block action, you can send a custom response to the web request. You define these for the web ACL, and then use them in the rules and default actions that you define in the web ACL. </p>
    /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the
    /// <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the
    /// <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    pub custom_response_bodies: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::CustomResponseBody>,
    >,
}
impl std::fmt::Debug for CreateWebAclInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateWebAclInput");
        formatter.field("name", &self.name);
        formatter.field("scope", &self.scope);
        formatter.field("default_action", &self.default_action);
        formatter.field("description", &self.description);
        formatter.field("rules", &self.rules);
        formatter.field("visibility_config", &self.visibility_config);
        formatter.field("tags", &self.tags);
        formatter.field("custom_response_bodies", &self.custom_response_bodies);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateRuleGroupInput {
    /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>The web ACL capacity units (WCUs) required for this rule group.</p>
    /// <p>When you create your own rule group, you define this, and you cannot change it after creation.
    /// When you add or modify the rules in a rule group, WAF enforces this limit. You can check the capacity
    /// for a set of rules using <a>CheckCapacity</a>.</p>
    /// <p>WAF uses WCUs to calculate and control the operating
    /// resources that are used to run your rules, rule groups, and web ACLs. WAF
    /// calculates capacity differently for each rule type, to reflect the relative cost of each rule.
    /// Simple rules that cost little to run use fewer WCUs than more complex rules
    /// that use more processing power.
    /// Rule group capacity is fixed at creation, which helps users plan their  
    /// web ACL WCU usage when they use a rule group.
    /// The WCU limit for web ACLs is 1,500.  </p>
    pub capacity: i64,
    /// <p>A description of the rule group that helps with identification. </p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The <a>Rule</a> statements used to identify the web requests that you
    /// want to allow, block, or count. Each rule includes one top-level statement that WAF uses to identify matching  
    /// web requests, and parameters that govern how WAF handles them.
    /// </p>
    pub rules: std::option::Option<std::vec::Vec<crate::model::Rule>>,
    /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection.  </p>
    pub visibility_config: std::option::Option<crate::model::VisibilityConfig>,
    /// <p>An array of key:value pairs to associate with the resource.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>A map of custom response keys and content bodies. When you create a rule with a block action, you can send a custom response to the web request. You define these for the rule group, and then use them in the rules that you define in the rule group. </p>
    /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the
    /// <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the
    /// <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    pub custom_response_bodies: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::CustomResponseBody>,
    >,
}
impl std::fmt::Debug for CreateRuleGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateRuleGroupInput");
        formatter.field("name", &self.name);
        formatter.field("scope", &self.scope);
        formatter.field("capacity", &self.capacity);
        formatter.field("description", &self.description);
        formatter.field("rules", &self.rules);
        formatter.field("visibility_config", &self.visibility_config);
        formatter.field("tags", &self.tags);
        formatter.field("custom_response_bodies", &self.custom_response_bodies);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateRegexPatternSetInput {
    /// <p>The name of the set. You cannot change the name after you create the set.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>A description of the set that helps with identification. </p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Array of regular expression strings. </p>
    pub regular_expression_list: std::option::Option<std::vec::Vec<crate::model::Regex>>,
    /// <p>An array of key:value pairs to associate with the resource.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for CreateRegexPatternSetInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateRegexPatternSetInput");
        formatter.field("name", &self.name);
        formatter.field("scope", &self.scope);
        formatter.field("description", &self.description);
        formatter.field("regular_expression_list", &self.regular_expression_list);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateIpSetInput {
    /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>A description of the IP set that helps with identification. </p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Specify IPV4 or IPV6. </p>
    pub ip_address_version: std::option::Option<crate::model::IpAddressVersion>,
    /// <p>Contains an array of strings that specify one or more IP addresses or blocks of IP addresses in Classless Inter-Domain Routing (CIDR) notation. WAF supports all IPv4 and IPv6 CIDR ranges except for /0. </p>
    /// <p>Examples: </p>
    /// <ul>
    /// <li>
    /// <p>To configure WAF to allow, block, or count requests that originated from the IP address 192.0.2.44, specify <code>192.0.2.44/32</code>.</p>
    /// </li>
    /// <li>
    /// <p>To configure WAF to allow, block, or count requests that originated from IP addresses from 192.0.2.0 to 192.0.2.255, specify
    /// <code>192.0.2.0/24</code>.</p>
    /// </li>
    /// <li>
    /// <p>To configure WAF to allow, block, or count requests that originated from the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify <code>1111:0000:0000:0000:0000:0000:0000:0111/128</code>.</p>
    /// </li>
    /// <li>
    /// <p>To configure WAF to allow, block, or count requests that originated from IP addresses 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify <code>1111:0000:0000:0000:0000:0000:0000:0000/64</code>.</p>
    /// </li>
    /// </ul>
    /// <p>For more information about CIDR notation, see the Wikipedia entry <a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless
    /// Inter-Domain Routing</a>.</p>
    pub addresses: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An array of key:value pairs to associate with the resource.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for CreateIpSetInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateIpSetInput");
        formatter.field("name", &self.name);
        formatter.field("scope", &self.scope);
        formatter.field("description", &self.description);
        formatter.field("ip_address_version", &self.ip_address_version);
        formatter.field("addresses", &self.addresses);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CheckCapacityInput {
    /// <p>Specifies whether this is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, or an AppSync GraphQL API.  </p>
    /// <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    /// <ul>
    /// <li>
    /// <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    /// </li>
    /// <li>
    /// <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    /// </li>
    /// </ul>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>An array of <a>Rule</a> that you're configuring to use in a rule group or web ACL. </p>
    pub rules: std::option::Option<std::vec::Vec<crate::model::Rule>>,
}
impl std::fmt::Debug for CheckCapacityInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CheckCapacityInput");
        formatter.field("scope", &self.scope);
        formatter.field("rules", &self.rules);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociateWebAclInput {
    /// <p>The Amazon Resource Name (ARN) of the web ACL that you want to associate with the resource.</p>
    pub web_acl_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the resource to associate with the web ACL. </p>
    /// <p>The ARN must be in one of the following formats:</p>
    /// <ul>
    /// <li>
    /// <p>For an Application Load Balancer: <code>arn:aws:elasticloadbalancing:<i>region</i>:<i>account-id</i>:loadbalancer/app/<i>load-balancer-name</i>/<i>load-balancer-id</i>
    /// </code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>For an Amazon API Gateway REST API: <code>arn:aws:apigateway:<i>region</i>::/restapis/<i>api-id</i>/stages/<i>stage-name</i>
    /// </code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>For an AppSync GraphQL API: <code>arn:aws:appsync:<i>region</i>:<i>account-id</i>:apis/<i>GraphQLApiId</i>
    /// </code>
    /// </p>
    /// </li>
    /// </ul>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AssociateWebAclInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociateWebAclInput");
        formatter.field("web_acl_arn", &self.web_acl_arn);
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}
