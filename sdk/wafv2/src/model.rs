// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ParameterExceptionField {
    #[allow(missing_docs)] // documentation missing in model
    AndStatement,
    #[allow(missing_docs)] // documentation missing in model
    AssociableResource,
    #[allow(missing_docs)] // documentation missing in model
    BodyParsingFallbackBehavior,
    #[allow(missing_docs)] // documentation missing in model
    ByteMatchStatement,
    #[allow(missing_docs)] // documentation missing in model
    ChangePropagationStatus,
    #[allow(missing_docs)] // documentation missing in model
    CustomRequestHandling,
    #[allow(missing_docs)] // documentation missing in model
    CustomResponse,
    #[allow(missing_docs)] // documentation missing in model
    CustomResponseBody,
    #[allow(missing_docs)] // documentation missing in model
    DefaultAction,
    #[allow(missing_docs)] // documentation missing in model
    EntityLimit,
    #[allow(missing_docs)] // documentation missing in model
    ExcludedRule,
    #[allow(missing_docs)] // documentation missing in model
    ExpireTimestamp,
    #[allow(missing_docs)] // documentation missing in model
    FallbackBehavior,
    #[allow(missing_docs)] // documentation missing in model
    FieldToMatch,
    #[allow(missing_docs)] // documentation missing in model
    FilterCondition,
    #[allow(missing_docs)] // documentation missing in model
    FirewallManagerStatement,
    #[allow(missing_docs)] // documentation missing in model
    ForwardedIpConfig,
    #[allow(missing_docs)] // documentation missing in model
    GeoMatchStatement,
    #[allow(missing_docs)] // documentation missing in model
    HeaderName,
    #[allow(missing_docs)] // documentation missing in model
    IpAddress,
    #[allow(missing_docs)] // documentation missing in model
    IpAddressVersion,
    #[allow(missing_docs)] // documentation missing in model
    IpSet,
    #[allow(missing_docs)] // documentation missing in model
    IpSetForwardedIpConfig,
    #[allow(missing_docs)] // documentation missing in model
    IpSetReferenceStatement,
    #[allow(missing_docs)] // documentation missing in model
    JsonMatchPattern,
    #[allow(missing_docs)] // documentation missing in model
    JsonMatchScope,
    #[allow(missing_docs)] // documentation missing in model
    LabelMatchStatement,
    #[allow(missing_docs)] // documentation missing in model
    LoggingFilter,
    #[allow(missing_docs)] // documentation missing in model
    LogDestination,
    #[allow(missing_docs)] // documentation missing in model
    ManagedRuleGroupConfig,
    #[allow(missing_docs)] // documentation missing in model
    ManagedRuleSet,
    #[allow(missing_docs)] // documentation missing in model
    ManagedRuleSetStatement,
    #[allow(missing_docs)] // documentation missing in model
    MetricName,
    #[allow(missing_docs)] // documentation missing in model
    NotStatement,
    #[allow(missing_docs)] // documentation missing in model
    OrStatement,
    #[allow(missing_docs)] // documentation missing in model
    OverrideAction,
    #[allow(missing_docs)] // documentation missing in model
    PayloadType,
    #[allow(missing_docs)] // documentation missing in model
    Position,
    #[allow(missing_docs)] // documentation missing in model
    RateBasedStatement,
    #[allow(missing_docs)] // documentation missing in model
    RegexPatternReferenceStatement,
    #[allow(missing_docs)] // documentation missing in model
    RegexPatternSet,
    #[allow(missing_docs)] // documentation missing in model
    ResourceArn,
    #[allow(missing_docs)] // documentation missing in model
    ResourceType,
    #[allow(missing_docs)] // documentation missing in model
    ResponseContentType,
    #[allow(missing_docs)] // documentation missing in model
    Rule,
    #[allow(missing_docs)] // documentation missing in model
    RuleAction,
    #[allow(missing_docs)] // documentation missing in model
    RuleGroup,
    #[allow(missing_docs)] // documentation missing in model
    RuleGroupReferenceStatement,
    #[allow(missing_docs)] // documentation missing in model
    ScopeValue,
    #[allow(missing_docs)] // documentation missing in model
    SingleHeader,
    #[allow(missing_docs)] // documentation missing in model
    SingleQueryArgument,
    #[allow(missing_docs)] // documentation missing in model
    SizeConstraintStatement,
    #[allow(missing_docs)] // documentation missing in model
    SqliMatchStatement,
    #[allow(missing_docs)] // documentation missing in model
    Statement,
    #[allow(missing_docs)] // documentation missing in model
    Tags,
    #[allow(missing_docs)] // documentation missing in model
    TagKeys,
    #[allow(missing_docs)] // documentation missing in model
    TextTransformation,
    #[allow(missing_docs)] // documentation missing in model
    WebAcl,
    #[allow(missing_docs)] // documentation missing in model
    XssMatchStatement,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ParameterExceptionField {
    fn from(s: &str) -> Self {
        match s {
            "AND_STATEMENT" => ParameterExceptionField::AndStatement,
            "ASSOCIABLE_RESOURCE" => ParameterExceptionField::AssociableResource,
            "BODY_PARSING_FALLBACK_BEHAVIOR" => {
                ParameterExceptionField::BodyParsingFallbackBehavior
            }
            "BYTE_MATCH_STATEMENT" => ParameterExceptionField::ByteMatchStatement,
            "CHANGE_PROPAGATION_STATUS" => ParameterExceptionField::ChangePropagationStatus,
            "CUSTOM_REQUEST_HANDLING" => ParameterExceptionField::CustomRequestHandling,
            "CUSTOM_RESPONSE" => ParameterExceptionField::CustomResponse,
            "CUSTOM_RESPONSE_BODY" => ParameterExceptionField::CustomResponseBody,
            "DEFAULT_ACTION" => ParameterExceptionField::DefaultAction,
            "ENTITY_LIMIT" => ParameterExceptionField::EntityLimit,
            "EXCLUDED_RULE" => ParameterExceptionField::ExcludedRule,
            "EXPIRE_TIMESTAMP" => ParameterExceptionField::ExpireTimestamp,
            "FALLBACK_BEHAVIOR" => ParameterExceptionField::FallbackBehavior,
            "FIELD_TO_MATCH" => ParameterExceptionField::FieldToMatch,
            "FILTER_CONDITION" => ParameterExceptionField::FilterCondition,
            "FIREWALL_MANAGER_STATEMENT" => ParameterExceptionField::FirewallManagerStatement,
            "FORWARDED_IP_CONFIG" => ParameterExceptionField::ForwardedIpConfig,
            "GEO_MATCH_STATEMENT" => ParameterExceptionField::GeoMatchStatement,
            "HEADER_NAME" => ParameterExceptionField::HeaderName,
            "IP_ADDRESS" => ParameterExceptionField::IpAddress,
            "IP_ADDRESS_VERSION" => ParameterExceptionField::IpAddressVersion,
            "IP_SET" => ParameterExceptionField::IpSet,
            "IP_SET_FORWARDED_IP_CONFIG" => ParameterExceptionField::IpSetForwardedIpConfig,
            "IP_SET_REFERENCE_STATEMENT" => ParameterExceptionField::IpSetReferenceStatement,
            "JSON_MATCH_PATTERN" => ParameterExceptionField::JsonMatchPattern,
            "JSON_MATCH_SCOPE" => ParameterExceptionField::JsonMatchScope,
            "LABEL_MATCH_STATEMENT" => ParameterExceptionField::LabelMatchStatement,
            "LOGGING_FILTER" => ParameterExceptionField::LoggingFilter,
            "LOG_DESTINATION" => ParameterExceptionField::LogDestination,
            "MANAGED_RULE_GROUP_CONFIG" => ParameterExceptionField::ManagedRuleGroupConfig,
            "MANAGED_RULE_SET" => ParameterExceptionField::ManagedRuleSet,
            "MANAGED_RULE_SET_STATEMENT" => ParameterExceptionField::ManagedRuleSetStatement,
            "METRIC_NAME" => ParameterExceptionField::MetricName,
            "NOT_STATEMENT" => ParameterExceptionField::NotStatement,
            "OR_STATEMENT" => ParameterExceptionField::OrStatement,
            "OVERRIDE_ACTION" => ParameterExceptionField::OverrideAction,
            "PAYLOAD_TYPE" => ParameterExceptionField::PayloadType,
            "POSITION" => ParameterExceptionField::Position,
            "RATE_BASED_STATEMENT" => ParameterExceptionField::RateBasedStatement,
            "REGEX_PATTERN_REFERENCE_STATEMENT" => {
                ParameterExceptionField::RegexPatternReferenceStatement
            }
            "REGEX_PATTERN_SET" => ParameterExceptionField::RegexPatternSet,
            "RESOURCE_ARN" => ParameterExceptionField::ResourceArn,
            "RESOURCE_TYPE" => ParameterExceptionField::ResourceType,
            "RESPONSE_CONTENT_TYPE" => ParameterExceptionField::ResponseContentType,
            "RULE" => ParameterExceptionField::Rule,
            "RULE_ACTION" => ParameterExceptionField::RuleAction,
            "RULE_GROUP" => ParameterExceptionField::RuleGroup,
            "RULE_GROUP_REFERENCE_STATEMENT" => {
                ParameterExceptionField::RuleGroupReferenceStatement
            }
            "SCOPE_VALUE" => ParameterExceptionField::ScopeValue,
            "SINGLE_HEADER" => ParameterExceptionField::SingleHeader,
            "SINGLE_QUERY_ARGUMENT" => ParameterExceptionField::SingleQueryArgument,
            "SIZE_CONSTRAINT_STATEMENT" => ParameterExceptionField::SizeConstraintStatement,
            "SQLI_MATCH_STATEMENT" => ParameterExceptionField::SqliMatchStatement,
            "STATEMENT" => ParameterExceptionField::Statement,
            "TAGS" => ParameterExceptionField::Tags,
            "TAG_KEYS" => ParameterExceptionField::TagKeys,
            "TEXT_TRANSFORMATION" => ParameterExceptionField::TextTransformation,
            "WEB_ACL" => ParameterExceptionField::WebAcl,
            "XSS_MATCH_STATEMENT" => ParameterExceptionField::XssMatchStatement,
            other => ParameterExceptionField::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ParameterExceptionField {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ParameterExceptionField::from(s))
    }
}
impl ParameterExceptionField {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ParameterExceptionField::AndStatement => "AND_STATEMENT",
            ParameterExceptionField::AssociableResource => "ASSOCIABLE_RESOURCE",
            ParameterExceptionField::BodyParsingFallbackBehavior => {
                "BODY_PARSING_FALLBACK_BEHAVIOR"
            }
            ParameterExceptionField::ByteMatchStatement => "BYTE_MATCH_STATEMENT",
            ParameterExceptionField::ChangePropagationStatus => "CHANGE_PROPAGATION_STATUS",
            ParameterExceptionField::CustomRequestHandling => "CUSTOM_REQUEST_HANDLING",
            ParameterExceptionField::CustomResponse => "CUSTOM_RESPONSE",
            ParameterExceptionField::CustomResponseBody => "CUSTOM_RESPONSE_BODY",
            ParameterExceptionField::DefaultAction => "DEFAULT_ACTION",
            ParameterExceptionField::EntityLimit => "ENTITY_LIMIT",
            ParameterExceptionField::ExcludedRule => "EXCLUDED_RULE",
            ParameterExceptionField::ExpireTimestamp => "EXPIRE_TIMESTAMP",
            ParameterExceptionField::FallbackBehavior => "FALLBACK_BEHAVIOR",
            ParameterExceptionField::FieldToMatch => "FIELD_TO_MATCH",
            ParameterExceptionField::FilterCondition => "FILTER_CONDITION",
            ParameterExceptionField::FirewallManagerStatement => "FIREWALL_MANAGER_STATEMENT",
            ParameterExceptionField::ForwardedIpConfig => "FORWARDED_IP_CONFIG",
            ParameterExceptionField::GeoMatchStatement => "GEO_MATCH_STATEMENT",
            ParameterExceptionField::HeaderName => "HEADER_NAME",
            ParameterExceptionField::IpAddress => "IP_ADDRESS",
            ParameterExceptionField::IpAddressVersion => "IP_ADDRESS_VERSION",
            ParameterExceptionField::IpSet => "IP_SET",
            ParameterExceptionField::IpSetForwardedIpConfig => "IP_SET_FORWARDED_IP_CONFIG",
            ParameterExceptionField::IpSetReferenceStatement => "IP_SET_REFERENCE_STATEMENT",
            ParameterExceptionField::JsonMatchPattern => "JSON_MATCH_PATTERN",
            ParameterExceptionField::JsonMatchScope => "JSON_MATCH_SCOPE",
            ParameterExceptionField::LabelMatchStatement => "LABEL_MATCH_STATEMENT",
            ParameterExceptionField::LoggingFilter => "LOGGING_FILTER",
            ParameterExceptionField::LogDestination => "LOG_DESTINATION",
            ParameterExceptionField::ManagedRuleGroupConfig => "MANAGED_RULE_GROUP_CONFIG",
            ParameterExceptionField::ManagedRuleSet => "MANAGED_RULE_SET",
            ParameterExceptionField::ManagedRuleSetStatement => "MANAGED_RULE_SET_STATEMENT",
            ParameterExceptionField::MetricName => "METRIC_NAME",
            ParameterExceptionField::NotStatement => "NOT_STATEMENT",
            ParameterExceptionField::OrStatement => "OR_STATEMENT",
            ParameterExceptionField::OverrideAction => "OVERRIDE_ACTION",
            ParameterExceptionField::PayloadType => "PAYLOAD_TYPE",
            ParameterExceptionField::Position => "POSITION",
            ParameterExceptionField::RateBasedStatement => "RATE_BASED_STATEMENT",
            ParameterExceptionField::RegexPatternReferenceStatement => {
                "REGEX_PATTERN_REFERENCE_STATEMENT"
            }
            ParameterExceptionField::RegexPatternSet => "REGEX_PATTERN_SET",
            ParameterExceptionField::ResourceArn => "RESOURCE_ARN",
            ParameterExceptionField::ResourceType => "RESOURCE_TYPE",
            ParameterExceptionField::ResponseContentType => "RESPONSE_CONTENT_TYPE",
            ParameterExceptionField::Rule => "RULE",
            ParameterExceptionField::RuleAction => "RULE_ACTION",
            ParameterExceptionField::RuleGroup => "RULE_GROUP",
            ParameterExceptionField::RuleGroupReferenceStatement => {
                "RULE_GROUP_REFERENCE_STATEMENT"
            }
            ParameterExceptionField::ScopeValue => "SCOPE_VALUE",
            ParameterExceptionField::SingleHeader => "SINGLE_HEADER",
            ParameterExceptionField::SingleQueryArgument => "SINGLE_QUERY_ARGUMENT",
            ParameterExceptionField::SizeConstraintStatement => "SIZE_CONSTRAINT_STATEMENT",
            ParameterExceptionField::SqliMatchStatement => "SQLI_MATCH_STATEMENT",
            ParameterExceptionField::Statement => "STATEMENT",
            ParameterExceptionField::Tags => "TAGS",
            ParameterExceptionField::TagKeys => "TAG_KEYS",
            ParameterExceptionField::TextTransformation => "TEXT_TRANSFORMATION",
            ParameterExceptionField::WebAcl => "WEB_ACL",
            ParameterExceptionField::XssMatchStatement => "XSS_MATCH_STATEMENT",
            ParameterExceptionField::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "AND_STATEMENT",
            "ASSOCIABLE_RESOURCE",
            "BODY_PARSING_FALLBACK_BEHAVIOR",
            "BYTE_MATCH_STATEMENT",
            "CHANGE_PROPAGATION_STATUS",
            "CUSTOM_REQUEST_HANDLING",
            "CUSTOM_RESPONSE",
            "CUSTOM_RESPONSE_BODY",
            "DEFAULT_ACTION",
            "ENTITY_LIMIT",
            "EXCLUDED_RULE",
            "EXPIRE_TIMESTAMP",
            "FALLBACK_BEHAVIOR",
            "FIELD_TO_MATCH",
            "FILTER_CONDITION",
            "FIREWALL_MANAGER_STATEMENT",
            "FORWARDED_IP_CONFIG",
            "GEO_MATCH_STATEMENT",
            "HEADER_NAME",
            "IP_ADDRESS",
            "IP_ADDRESS_VERSION",
            "IP_SET",
            "IP_SET_FORWARDED_IP_CONFIG",
            "IP_SET_REFERENCE_STATEMENT",
            "JSON_MATCH_PATTERN",
            "JSON_MATCH_SCOPE",
            "LABEL_MATCH_STATEMENT",
            "LOGGING_FILTER",
            "LOG_DESTINATION",
            "MANAGED_RULE_GROUP_CONFIG",
            "MANAGED_RULE_SET",
            "MANAGED_RULE_SET_STATEMENT",
            "METRIC_NAME",
            "NOT_STATEMENT",
            "OR_STATEMENT",
            "OVERRIDE_ACTION",
            "PAYLOAD_TYPE",
            "POSITION",
            "RATE_BASED_STATEMENT",
            "REGEX_PATTERN_REFERENCE_STATEMENT",
            "REGEX_PATTERN_SET",
            "RESOURCE_ARN",
            "RESOURCE_TYPE",
            "RESPONSE_CONTENT_TYPE",
            "RULE",
            "RULE_ACTION",
            "RULE_GROUP",
            "RULE_GROUP_REFERENCE_STATEMENT",
            "SCOPE_VALUE",
            "SINGLE_HEADER",
            "SINGLE_QUERY_ARGUMENT",
            "SIZE_CONSTRAINT_STATEMENT",
            "SQLI_MATCH_STATEMENT",
            "STATEMENT",
            "TAGS",
            "TAG_KEYS",
            "TEXT_TRANSFORMATION",
            "WEB_ACL",
            "XSS_MATCH_STATEMENT",
        ]
    }
}
impl AsRef<str> for ParameterExceptionField {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies how WAF should handle <code>CAPTCHA</code> evaluations. This is available at the web ACL level and in each rule. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CaptchaConfig {
    /// <p>Determines how long a <code>CAPTCHA</code> token remains valid after the client successfully solves a <code>CAPTCHA</code> puzzle. </p>
    pub immunity_time_property: std::option::Option<crate::model::ImmunityTimeProperty>,
}
impl CaptchaConfig {
    /// <p>Determines how long a <code>CAPTCHA</code> token remains valid after the client successfully solves a <code>CAPTCHA</code> puzzle. </p>
    pub fn immunity_time_property(
        &self,
    ) -> std::option::Option<&crate::model::ImmunityTimeProperty> {
        self.immunity_time_property.as_ref()
    }
}
impl std::fmt::Debug for CaptchaConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CaptchaConfig");
        formatter.field("immunity_time_property", &self.immunity_time_property);
        formatter.finish()
    }
}
/// See [`CaptchaConfig`](crate::model::CaptchaConfig)
pub mod captcha_config {
    /// A builder for [`CaptchaConfig`](crate::model::CaptchaConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) immunity_time_property: std::option::Option<crate::model::ImmunityTimeProperty>,
    }
    impl Builder {
        /// <p>Determines how long a <code>CAPTCHA</code> token remains valid after the client successfully solves a <code>CAPTCHA</code> puzzle. </p>
        pub fn immunity_time_property(mut self, input: crate::model::ImmunityTimeProperty) -> Self {
            self.immunity_time_property = Some(input);
            self
        }
        /// <p>Determines how long a <code>CAPTCHA</code> token remains valid after the client successfully solves a <code>CAPTCHA</code> puzzle. </p>
        pub fn set_immunity_time_property(
            mut self,
            input: std::option::Option<crate::model::ImmunityTimeProperty>,
        ) -> Self {
            self.immunity_time_property = input;
            self
        }
        /// Consumes the builder and constructs a [`CaptchaConfig`](crate::model::CaptchaConfig)
        pub fn build(self) -> crate::model::CaptchaConfig {
            crate::model::CaptchaConfig {
                immunity_time_property: self.immunity_time_property,
            }
        }
    }
}
impl CaptchaConfig {
    /// Creates a new builder-style object to manufacture [`CaptchaConfig`](crate::model::CaptchaConfig)
    pub fn builder() -> crate::model::captcha_config::Builder {
        crate::model::captcha_config::Builder::default()
    }
}

/// <p>Determines how long a <code>CAPTCHA</code> token remains valid after the client successfully solves a <code>CAPTCHA</code> puzzle. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImmunityTimeProperty {
    /// <p>The amount of time, in seconds, that a <code>CAPTCHA</code> token is valid. The default setting is 300.</p>
    pub immunity_time: std::option::Option<i64>,
}
impl ImmunityTimeProperty {
    /// <p>The amount of time, in seconds, that a <code>CAPTCHA</code> token is valid. The default setting is 300.</p>
    pub fn immunity_time(&self) -> std::option::Option<i64> {
        self.immunity_time
    }
}
impl std::fmt::Debug for ImmunityTimeProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImmunityTimeProperty");
        formatter.field("immunity_time", &self.immunity_time);
        formatter.finish()
    }
}
/// See [`ImmunityTimeProperty`](crate::model::ImmunityTimeProperty)
pub mod immunity_time_property {
    /// A builder for [`ImmunityTimeProperty`](crate::model::ImmunityTimeProperty)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) immunity_time: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The amount of time, in seconds, that a <code>CAPTCHA</code> token is valid. The default setting is 300.</p>
        pub fn immunity_time(mut self, input: i64) -> Self {
            self.immunity_time = Some(input);
            self
        }
        /// <p>The amount of time, in seconds, that a <code>CAPTCHA</code> token is valid. The default setting is 300.</p>
        pub fn set_immunity_time(mut self, input: std::option::Option<i64>) -> Self {
            self.immunity_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ImmunityTimeProperty`](crate::model::ImmunityTimeProperty)
        pub fn build(self) -> crate::model::ImmunityTimeProperty {
            crate::model::ImmunityTimeProperty {
                immunity_time: self.immunity_time,
            }
        }
    }
}
impl ImmunityTimeProperty {
    /// Creates a new builder-style object to manufacture [`ImmunityTimeProperty`](crate::model::ImmunityTimeProperty)
    pub fn builder() -> crate::model::immunity_time_property::Builder {
        crate::model::immunity_time_property::Builder::default()
    }
}

/// <p>The response body to use in a custom response to a web request. This is referenced by key from <code>CustomResponse</code> <code>CustomResponseBodyKey</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomResponseBody {
    /// <p>The type of content in the payload that you are defining in the <code>Content</code> string.</p>
    pub content_type: std::option::Option<crate::model::ResponseContentType>,
    /// <p>The payload of the custom response. </p>
    /// <p>You can use JSON escape strings in JSON content. To do this, you must specify JSON content in the <code>ContentType</code> setting. </p>
    /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    pub content: std::option::Option<std::string::String>,
}
impl CustomResponseBody {
    /// <p>The type of content in the payload that you are defining in the <code>Content</code> string.</p>
    pub fn content_type(&self) -> std::option::Option<&crate::model::ResponseContentType> {
        self.content_type.as_ref()
    }
    /// <p>The payload of the custom response. </p>
    /// <p>You can use JSON escape strings in JSON content. To do this, you must specify JSON content in the <code>ContentType</code> setting. </p>
    /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
}
impl std::fmt::Debug for CustomResponseBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomResponseBody");
        formatter.field("content_type", &self.content_type);
        formatter.field("content", &self.content);
        formatter.finish()
    }
}
/// See [`CustomResponseBody`](crate::model::CustomResponseBody)
pub mod custom_response_body {
    /// A builder for [`CustomResponseBody`](crate::model::CustomResponseBody)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) content_type: std::option::Option<crate::model::ResponseContentType>,
        pub(crate) content: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of content in the payload that you are defining in the <code>Content</code> string.</p>
        pub fn content_type(mut self, input: crate::model::ResponseContentType) -> Self {
            self.content_type = Some(input);
            self
        }
        /// <p>The type of content in the payload that you are defining in the <code>Content</code> string.</p>
        pub fn set_content_type(
            mut self,
            input: std::option::Option<crate::model::ResponseContentType>,
        ) -> Self {
            self.content_type = input;
            self
        }
        /// <p>The payload of the custom response. </p>
        /// <p>You can use JSON escape strings in JSON content. To do this, you must specify JSON content in the <code>ContentType</code> setting. </p>
        /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The payload of the custom response. </p>
        /// <p>You can use JSON escape strings in JSON content. To do this, you must specify JSON content in the <code>ContentType</code> setting. </p>
        /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomResponseBody`](crate::model::CustomResponseBody)
        pub fn build(self) -> crate::model::CustomResponseBody {
            crate::model::CustomResponseBody {
                content_type: self.content_type,
                content: self.content,
            }
        }
    }
}
impl CustomResponseBody {
    /// Creates a new builder-style object to manufacture [`CustomResponseBody`](crate::model::CustomResponseBody)
    pub fn builder() -> crate::model::custom_response_body::Builder {
        crate::model::custom_response_body::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResponseContentType {
    #[allow(missing_docs)] // documentation missing in model
    ApplicationJson,
    #[allow(missing_docs)] // documentation missing in model
    TextHtml,
    #[allow(missing_docs)] // documentation missing in model
    TextPlain,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ResponseContentType {
    fn from(s: &str) -> Self {
        match s {
            "APPLICATION_JSON" => ResponseContentType::ApplicationJson,
            "TEXT_HTML" => ResponseContentType::TextHtml,
            "TEXT_PLAIN" => ResponseContentType::TextPlain,
            other => ResponseContentType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ResponseContentType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResponseContentType::from(s))
    }
}
impl ResponseContentType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResponseContentType::ApplicationJson => "APPLICATION_JSON",
            ResponseContentType::TextHtml => "TEXT_HTML",
            ResponseContentType::TextPlain => "TEXT_PLAIN",
            ResponseContentType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["APPLICATION_JSON", "TEXT_HTML", "TEXT_PLAIN"]
    }
}
impl AsRef<str> for ResponseContentType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VisibilityConfig {
    /// <p>A boolean indicating whether WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the WAF console. </p>
    pub sampled_requests_enabled: bool,
    /// <p>A boolean indicating whether the associated resource sends metrics to Amazon CloudWatch. For the list of available metrics, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics">WAF Metrics</a>.</p>
    pub cloud_watch_metrics_enabled: bool,
    /// <p>A name of the Amazon CloudWatch metric. The name can contain only the characters: A-Z, a-z, 0-9, - (hyphen), and _ (underscore). The name can be from one to 128 characters long. It can't contain whitespace or metric names reserved for WAF, for example "All" and "Default_Action." </p>
    pub metric_name: std::option::Option<std::string::String>,
}
impl VisibilityConfig {
    /// <p>A boolean indicating whether WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the WAF console. </p>
    pub fn sampled_requests_enabled(&self) -> bool {
        self.sampled_requests_enabled
    }
    /// <p>A boolean indicating whether the associated resource sends metrics to Amazon CloudWatch. For the list of available metrics, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics">WAF Metrics</a>.</p>
    pub fn cloud_watch_metrics_enabled(&self) -> bool {
        self.cloud_watch_metrics_enabled
    }
    /// <p>A name of the Amazon CloudWatch metric. The name can contain only the characters: A-Z, a-z, 0-9, - (hyphen), and _ (underscore). The name can be from one to 128 characters long. It can't contain whitespace or metric names reserved for WAF, for example "All" and "Default_Action." </p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
}
impl std::fmt::Debug for VisibilityConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VisibilityConfig");
        formatter.field("sampled_requests_enabled", &self.sampled_requests_enabled);
        formatter.field(
            "cloud_watch_metrics_enabled",
            &self.cloud_watch_metrics_enabled,
        );
        formatter.field("metric_name", &self.metric_name);
        formatter.finish()
    }
}
/// See [`VisibilityConfig`](crate::model::VisibilityConfig)
pub mod visibility_config {
    /// A builder for [`VisibilityConfig`](crate::model::VisibilityConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sampled_requests_enabled: std::option::Option<bool>,
        pub(crate) cloud_watch_metrics_enabled: std::option::Option<bool>,
        pub(crate) metric_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A boolean indicating whether WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the WAF console. </p>
        pub fn sampled_requests_enabled(mut self, input: bool) -> Self {
            self.sampled_requests_enabled = Some(input);
            self
        }
        /// <p>A boolean indicating whether WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the WAF console. </p>
        pub fn set_sampled_requests_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.sampled_requests_enabled = input;
            self
        }
        /// <p>A boolean indicating whether the associated resource sends metrics to Amazon CloudWatch. For the list of available metrics, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics">WAF Metrics</a>.</p>
        pub fn cloud_watch_metrics_enabled(mut self, input: bool) -> Self {
            self.cloud_watch_metrics_enabled = Some(input);
            self
        }
        /// <p>A boolean indicating whether the associated resource sends metrics to Amazon CloudWatch. For the list of available metrics, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics">WAF Metrics</a>.</p>
        pub fn set_cloud_watch_metrics_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.cloud_watch_metrics_enabled = input;
            self
        }
        /// <p>A name of the Amazon CloudWatch metric. The name can contain only the characters: A-Z, a-z, 0-9, - (hyphen), and _ (underscore). The name can be from one to 128 characters long. It can't contain whitespace or metric names reserved for WAF, for example "All" and "Default_Action." </p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>A name of the Amazon CloudWatch metric. The name can contain only the characters: A-Z, a-z, 0-9, - (hyphen), and _ (underscore). The name can be from one to 128 characters long. It can't contain whitespace or metric names reserved for WAF, for example "All" and "Default_Action." </p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// Consumes the builder and constructs a [`VisibilityConfig`](crate::model::VisibilityConfig)
        pub fn build(self) -> crate::model::VisibilityConfig {
            crate::model::VisibilityConfig {
                sampled_requests_enabled: self.sampled_requests_enabled.unwrap_or_default(),
                cloud_watch_metrics_enabled: self.cloud_watch_metrics_enabled.unwrap_or_default(),
                metric_name: self.metric_name,
            }
        }
    }
}
impl VisibilityConfig {
    /// Creates a new builder-style object to manufacture [`VisibilityConfig`](crate::model::VisibilityConfig)
    pub fn builder() -> crate::model::visibility_config::Builder {
        crate::model::visibility_config::Builder::default()
    }
}

/// <p>A single rule, which you can use in a <code>WebACL</code> or <code>RuleGroup</code> to identify web requests that you want to allow, block, or count. Each rule includes one top-level <code>Statement</code> that WAF uses to identify matching web requests, and parameters that govern how WAF handles them. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Rule {
    /// <p>The name of the rule. You can't change the name of a <code>Rule</code> after you create it. </p>
    pub name: std::option::Option<std::string::String>,
    /// <p>If you define more than one <code>Rule</code> in a <code>WebACL</code>, WAF evaluates each request against the <code>Rules</code> in order based on the value of <code>Priority</code>. WAF processes rules with lower priority first. The priorities don't need to be consecutive, but they must all be different.</p>
    pub priority: i32,
    /// <p>The WAF processing statement for the rule, for example <code>ByteMatchStatement</code> or <code>SizeConstraintStatement</code>. </p>
    pub statement: std::option::Option<crate::model::Statement>,
    /// <p>The action that WAF should take on a web request when it matches the rule statement. Settings at the web ACL level can override the rule action setting. </p>
    /// <p>This is used only for rules whose statements do not reference a rule group. Rule statements that reference a rule group include <code>RuleGroupReferenceStatement</code> and <code>ManagedRuleGroupStatement</code>. </p>
    /// <p>You must specify either this <code>Action</code> setting or the rule <code>OverrideAction</code> setting, but not both:</p>
    /// <ul>
    /// <li> <p>If the rule statement does not reference a rule group, use this rule action setting and not the rule override action setting. </p> </li>
    /// <li> <p>If the rule statement references a rule group, use the override action setting and not this action setting. </p> </li>
    /// </ul>
    pub action: std::option::Option<crate::model::RuleAction>,
    /// <p>The action to use in the place of the action that results from the rule group evaluation. Set the override action to none to leave the result of the rule group alone. Set it to count to override the result to count only. </p>
    /// <p>You can only use this for rule statements that reference a rule group, like <code>RuleGroupReferenceStatement</code> and <code>ManagedRuleGroupStatement</code>. </p> <note>
    /// <p>This option is usually set to none. It does not affect how the rules in the rule group are evaluated. If you want the rules in the rule group to only count matches, do not use this and instead exclude those rules in your rule group reference statement settings. </p>
    /// </note>
    pub override_action: std::option::Option<crate::model::OverrideAction>,
    /// <p>Labels to apply to web requests that match the rule match statement. WAF applies fully qualified labels to matching web requests. A fully qualified label is the concatenation of a label namespace and a rule label. The rule's rule group or web ACL defines the label namespace. </p>
    /// <p>Rules that run after this rule in the web ACL can match against these labels using a <code>LabelMatchStatement</code>.</p>
    /// <p>For each label, provide a case-sensitive string containing optional namespaces and a label name, according to the following guidelines:</p>
    /// <ul>
    /// <li> <p>Separate each component of the label with a colon. </p> </li>
    /// <li> <p>Each namespace or name can have up to 128 characters.</p> </li>
    /// <li> <p>You can specify up to 5 namespaces in a label.</p> </li>
    /// <li> <p>Don't use the following reserved words in your label specification: <code>aws</code>, <code>waf</code>, <code>managed</code>, <code>rulegroup</code>, <code>webacl</code>, <code>regexpatternset</code>, or <code>ipset</code>.</p> </li>
    /// </ul>
    /// <p>For example, <code>myLabelName</code> or <code>nameSpace1:nameSpace2:myLabelName</code>. </p>
    pub rule_labels: std::option::Option<std::vec::Vec<crate::model::Label>>,
    /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection. </p>
    pub visibility_config: std::option::Option<crate::model::VisibilityConfig>,
    /// <p>Specifies how WAF should handle <code>CAPTCHA</code> evaluations. If you don't specify this, WAF uses the <code>CAPTCHA</code> configuration that's defined for the web ACL. </p>
    pub captcha_config: std::option::Option<crate::model::CaptchaConfig>,
}
impl Rule {
    /// <p>The name of the rule. You can't change the name of a <code>Rule</code> after you create it. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>If you define more than one <code>Rule</code> in a <code>WebACL</code>, WAF evaluates each request against the <code>Rules</code> in order based on the value of <code>Priority</code>. WAF processes rules with lower priority first. The priorities don't need to be consecutive, but they must all be different.</p>
    pub fn priority(&self) -> i32 {
        self.priority
    }
    /// <p>The WAF processing statement for the rule, for example <code>ByteMatchStatement</code> or <code>SizeConstraintStatement</code>. </p>
    pub fn statement(&self) -> std::option::Option<&crate::model::Statement> {
        self.statement.as_ref()
    }
    /// <p>The action that WAF should take on a web request when it matches the rule statement. Settings at the web ACL level can override the rule action setting. </p>
    /// <p>This is used only for rules whose statements do not reference a rule group. Rule statements that reference a rule group include <code>RuleGroupReferenceStatement</code> and <code>ManagedRuleGroupStatement</code>. </p>
    /// <p>You must specify either this <code>Action</code> setting or the rule <code>OverrideAction</code> setting, but not both:</p>
    /// <ul>
    /// <li> <p>If the rule statement does not reference a rule group, use this rule action setting and not the rule override action setting. </p> </li>
    /// <li> <p>If the rule statement references a rule group, use the override action setting and not this action setting. </p> </li>
    /// </ul>
    pub fn action(&self) -> std::option::Option<&crate::model::RuleAction> {
        self.action.as_ref()
    }
    /// <p>The action to use in the place of the action that results from the rule group evaluation. Set the override action to none to leave the result of the rule group alone. Set it to count to override the result to count only. </p>
    /// <p>You can only use this for rule statements that reference a rule group, like <code>RuleGroupReferenceStatement</code> and <code>ManagedRuleGroupStatement</code>. </p> <note>
    /// <p>This option is usually set to none. It does not affect how the rules in the rule group are evaluated. If you want the rules in the rule group to only count matches, do not use this and instead exclude those rules in your rule group reference statement settings. </p>
    /// </note>
    pub fn override_action(&self) -> std::option::Option<&crate::model::OverrideAction> {
        self.override_action.as_ref()
    }
    /// <p>Labels to apply to web requests that match the rule match statement. WAF applies fully qualified labels to matching web requests. A fully qualified label is the concatenation of a label namespace and a rule label. The rule's rule group or web ACL defines the label namespace. </p>
    /// <p>Rules that run after this rule in the web ACL can match against these labels using a <code>LabelMatchStatement</code>.</p>
    /// <p>For each label, provide a case-sensitive string containing optional namespaces and a label name, according to the following guidelines:</p>
    /// <ul>
    /// <li> <p>Separate each component of the label with a colon. </p> </li>
    /// <li> <p>Each namespace or name can have up to 128 characters.</p> </li>
    /// <li> <p>You can specify up to 5 namespaces in a label.</p> </li>
    /// <li> <p>Don't use the following reserved words in your label specification: <code>aws</code>, <code>waf</code>, <code>managed</code>, <code>rulegroup</code>, <code>webacl</code>, <code>regexpatternset</code>, or <code>ipset</code>.</p> </li>
    /// </ul>
    /// <p>For example, <code>myLabelName</code> or <code>nameSpace1:nameSpace2:myLabelName</code>. </p>
    pub fn rule_labels(&self) -> std::option::Option<&[crate::model::Label]> {
        self.rule_labels.as_deref()
    }
    /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection. </p>
    pub fn visibility_config(&self) -> std::option::Option<&crate::model::VisibilityConfig> {
        self.visibility_config.as_ref()
    }
    /// <p>Specifies how WAF should handle <code>CAPTCHA</code> evaluations. If you don't specify this, WAF uses the <code>CAPTCHA</code> configuration that's defined for the web ACL. </p>
    pub fn captcha_config(&self) -> std::option::Option<&crate::model::CaptchaConfig> {
        self.captcha_config.as_ref()
    }
}
impl std::fmt::Debug for Rule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Rule");
        formatter.field("name", &self.name);
        formatter.field("priority", &self.priority);
        formatter.field("statement", &self.statement);
        formatter.field("action", &self.action);
        formatter.field("override_action", &self.override_action);
        formatter.field("rule_labels", &self.rule_labels);
        formatter.field("visibility_config", &self.visibility_config);
        formatter.field("captcha_config", &self.captcha_config);
        formatter.finish()
    }
}
/// See [`Rule`](crate::model::Rule)
pub mod rule {
    /// A builder for [`Rule`](crate::model::Rule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) priority: std::option::Option<i32>,
        pub(crate) statement: std::option::Option<crate::model::Statement>,
        pub(crate) action: std::option::Option<crate::model::RuleAction>,
        pub(crate) override_action: std::option::Option<crate::model::OverrideAction>,
        pub(crate) rule_labels: std::option::Option<std::vec::Vec<crate::model::Label>>,
        pub(crate) visibility_config: std::option::Option<crate::model::VisibilityConfig>,
        pub(crate) captcha_config: std::option::Option<crate::model::CaptchaConfig>,
    }
    impl Builder {
        /// <p>The name of the rule. You can't change the name of a <code>Rule</code> after you create it. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the rule. You can't change the name of a <code>Rule</code> after you create it. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>If you define more than one <code>Rule</code> in a <code>WebACL</code>, WAF evaluates each request against the <code>Rules</code> in order based on the value of <code>Priority</code>. WAF processes rules with lower priority first. The priorities don't need to be consecutive, but they must all be different.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        /// <p>If you define more than one <code>Rule</code> in a <code>WebACL</code>, WAF evaluates each request against the <code>Rules</code> in order based on the value of <code>Priority</code>. WAF processes rules with lower priority first. The priorities don't need to be consecutive, but they must all be different.</p>
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        /// <p>The WAF processing statement for the rule, for example <code>ByteMatchStatement</code> or <code>SizeConstraintStatement</code>. </p>
        pub fn statement(mut self, input: crate::model::Statement) -> Self {
            self.statement = Some(input);
            self
        }
        /// <p>The WAF processing statement for the rule, for example <code>ByteMatchStatement</code> or <code>SizeConstraintStatement</code>. </p>
        pub fn set_statement(
            mut self,
            input: std::option::Option<crate::model::Statement>,
        ) -> Self {
            self.statement = input;
            self
        }
        /// <p>The action that WAF should take on a web request when it matches the rule statement. Settings at the web ACL level can override the rule action setting. </p>
        /// <p>This is used only for rules whose statements do not reference a rule group. Rule statements that reference a rule group include <code>RuleGroupReferenceStatement</code> and <code>ManagedRuleGroupStatement</code>. </p>
        /// <p>You must specify either this <code>Action</code> setting or the rule <code>OverrideAction</code> setting, but not both:</p>
        /// <ul>
        /// <li> <p>If the rule statement does not reference a rule group, use this rule action setting and not the rule override action setting. </p> </li>
        /// <li> <p>If the rule statement references a rule group, use the override action setting and not this action setting. </p> </li>
        /// </ul>
        pub fn action(mut self, input: crate::model::RuleAction) -> Self {
            self.action = Some(input);
            self
        }
        /// <p>The action that WAF should take on a web request when it matches the rule statement. Settings at the web ACL level can override the rule action setting. </p>
        /// <p>This is used only for rules whose statements do not reference a rule group. Rule statements that reference a rule group include <code>RuleGroupReferenceStatement</code> and <code>ManagedRuleGroupStatement</code>. </p>
        /// <p>You must specify either this <code>Action</code> setting or the rule <code>OverrideAction</code> setting, but not both:</p>
        /// <ul>
        /// <li> <p>If the rule statement does not reference a rule group, use this rule action setting and not the rule override action setting. </p> </li>
        /// <li> <p>If the rule statement references a rule group, use the override action setting and not this action setting. </p> </li>
        /// </ul>
        pub fn set_action(mut self, input: std::option::Option<crate::model::RuleAction>) -> Self {
            self.action = input;
            self
        }
        /// <p>The action to use in the place of the action that results from the rule group evaluation. Set the override action to none to leave the result of the rule group alone. Set it to count to override the result to count only. </p>
        /// <p>You can only use this for rule statements that reference a rule group, like <code>RuleGroupReferenceStatement</code> and <code>ManagedRuleGroupStatement</code>. </p> <note>
        /// <p>This option is usually set to none. It does not affect how the rules in the rule group are evaluated. If you want the rules in the rule group to only count matches, do not use this and instead exclude those rules in your rule group reference statement settings. </p>
        /// </note>
        pub fn override_action(mut self, input: crate::model::OverrideAction) -> Self {
            self.override_action = Some(input);
            self
        }
        /// <p>The action to use in the place of the action that results from the rule group evaluation. Set the override action to none to leave the result of the rule group alone. Set it to count to override the result to count only. </p>
        /// <p>You can only use this for rule statements that reference a rule group, like <code>RuleGroupReferenceStatement</code> and <code>ManagedRuleGroupStatement</code>. </p> <note>
        /// <p>This option is usually set to none. It does not affect how the rules in the rule group are evaluated. If you want the rules in the rule group to only count matches, do not use this and instead exclude those rules in your rule group reference statement settings. </p>
        /// </note>
        pub fn set_override_action(
            mut self,
            input: std::option::Option<crate::model::OverrideAction>,
        ) -> Self {
            self.override_action = input;
            self
        }
        /// Appends an item to `rule_labels`.
        ///
        /// To override the contents of this collection use [`set_rule_labels`](Self::set_rule_labels).
        ///
        /// <p>Labels to apply to web requests that match the rule match statement. WAF applies fully qualified labels to matching web requests. A fully qualified label is the concatenation of a label namespace and a rule label. The rule's rule group or web ACL defines the label namespace. </p>
        /// <p>Rules that run after this rule in the web ACL can match against these labels using a <code>LabelMatchStatement</code>.</p>
        /// <p>For each label, provide a case-sensitive string containing optional namespaces and a label name, according to the following guidelines:</p>
        /// <ul>
        /// <li> <p>Separate each component of the label with a colon. </p> </li>
        /// <li> <p>Each namespace or name can have up to 128 characters.</p> </li>
        /// <li> <p>You can specify up to 5 namespaces in a label.</p> </li>
        /// <li> <p>Don't use the following reserved words in your label specification: <code>aws</code>, <code>waf</code>, <code>managed</code>, <code>rulegroup</code>, <code>webacl</code>, <code>regexpatternset</code>, or <code>ipset</code>.</p> </li>
        /// </ul>
        /// <p>For example, <code>myLabelName</code> or <code>nameSpace1:nameSpace2:myLabelName</code>. </p>
        pub fn rule_labels(mut self, input: crate::model::Label) -> Self {
            let mut v = self.rule_labels.unwrap_or_default();
            v.push(input);
            self.rule_labels = Some(v);
            self
        }
        /// <p>Labels to apply to web requests that match the rule match statement. WAF applies fully qualified labels to matching web requests. A fully qualified label is the concatenation of a label namespace and a rule label. The rule's rule group or web ACL defines the label namespace. </p>
        /// <p>Rules that run after this rule in the web ACL can match against these labels using a <code>LabelMatchStatement</code>.</p>
        /// <p>For each label, provide a case-sensitive string containing optional namespaces and a label name, according to the following guidelines:</p>
        /// <ul>
        /// <li> <p>Separate each component of the label with a colon. </p> </li>
        /// <li> <p>Each namespace or name can have up to 128 characters.</p> </li>
        /// <li> <p>You can specify up to 5 namespaces in a label.</p> </li>
        /// <li> <p>Don't use the following reserved words in your label specification: <code>aws</code>, <code>waf</code>, <code>managed</code>, <code>rulegroup</code>, <code>webacl</code>, <code>regexpatternset</code>, or <code>ipset</code>.</p> </li>
        /// </ul>
        /// <p>For example, <code>myLabelName</code> or <code>nameSpace1:nameSpace2:myLabelName</code>. </p>
        pub fn set_rule_labels(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Label>>,
        ) -> Self {
            self.rule_labels = input;
            self
        }
        /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection. </p>
        pub fn visibility_config(mut self, input: crate::model::VisibilityConfig) -> Self {
            self.visibility_config = Some(input);
            self
        }
        /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection. </p>
        pub fn set_visibility_config(
            mut self,
            input: std::option::Option<crate::model::VisibilityConfig>,
        ) -> Self {
            self.visibility_config = input;
            self
        }
        /// <p>Specifies how WAF should handle <code>CAPTCHA</code> evaluations. If you don't specify this, WAF uses the <code>CAPTCHA</code> configuration that's defined for the web ACL. </p>
        pub fn captcha_config(mut self, input: crate::model::CaptchaConfig) -> Self {
            self.captcha_config = Some(input);
            self
        }
        /// <p>Specifies how WAF should handle <code>CAPTCHA</code> evaluations. If you don't specify this, WAF uses the <code>CAPTCHA</code> configuration that's defined for the web ACL. </p>
        pub fn set_captcha_config(
            mut self,
            input: std::option::Option<crate::model::CaptchaConfig>,
        ) -> Self {
            self.captcha_config = input;
            self
        }
        /// Consumes the builder and constructs a [`Rule`](crate::model::Rule)
        pub fn build(self) -> crate::model::Rule {
            crate::model::Rule {
                name: self.name,
                priority: self.priority.unwrap_or_default(),
                statement: self.statement,
                action: self.action,
                override_action: self.override_action,
                rule_labels: self.rule_labels,
                visibility_config: self.visibility_config,
                captcha_config: self.captcha_config,
            }
        }
    }
}
impl Rule {
    /// Creates a new builder-style object to manufacture [`Rule`](crate::model::Rule)
    pub fn builder() -> crate::model::rule::Builder {
        crate::model::rule::Builder::default()
    }
}

/// <p>A single label container. This is used as an element of a label array in multiple contexts, for example, in <code>RuleLabels</code> inside a <code>Rule</code> and in <code>Labels</code> inside a <code>SampledHTTPRequest</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Label {
    /// <p>The label string. </p>
    pub name: std::option::Option<std::string::String>,
}
impl Label {
    /// <p>The label string. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl std::fmt::Debug for Label {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Label");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`Label`](crate::model::Label)
pub mod label {
    /// A builder for [`Label`](crate::model::Label)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The label string. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The label string. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`Label`](crate::model::Label)
        pub fn build(self) -> crate::model::Label {
            crate::model::Label { name: self.name }
        }
    }
}
impl Label {
    /// Creates a new builder-style object to manufacture [`Label`](crate::model::Label)
    pub fn builder() -> crate::model::label::Builder {
        crate::model::label::Builder::default()
    }
}

/// <p>The action to use in the place of the action that results from the rule group evaluation. Set the override action to none to leave the result of the rule group alone. Set it to count to override the result to count only. </p>
/// <p>You can only use this for rule statements that reference a rule group, like <code>RuleGroupReferenceStatement</code> and <code>ManagedRuleGroupStatement</code>. </p> <note>
/// <p>This option is usually set to none. It does not affect how the rules in the rule group are evaluated. If you want the rules in the rule group to only count matches, do not use this and instead exclude those rules in your rule group reference statement settings. </p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OverrideAction {
    /// <p>Override the rule group evaluation result to count only. </p> <note>
    /// <p>This option is usually set to none. It does not affect how the rules in the rule group are evaluated. If you want the rules in the rule group to only count matches, do not use this and instead exclude those rules in your rule group reference statement settings. </p>
    /// </note>
    pub count: std::option::Option<crate::model::CountAction>,
    /// <p>Don't override the rule group evaluation result. This is the most common setting.</p>
    pub none: std::option::Option<crate::model::NoneAction>,
}
impl OverrideAction {
    /// <p>Override the rule group evaluation result to count only. </p> <note>
    /// <p>This option is usually set to none. It does not affect how the rules in the rule group are evaluated. If you want the rules in the rule group to only count matches, do not use this and instead exclude those rules in your rule group reference statement settings. </p>
    /// </note>
    pub fn count(&self) -> std::option::Option<&crate::model::CountAction> {
        self.count.as_ref()
    }
    /// <p>Don't override the rule group evaluation result. This is the most common setting.</p>
    pub fn none(&self) -> std::option::Option<&crate::model::NoneAction> {
        self.none.as_ref()
    }
}
impl std::fmt::Debug for OverrideAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OverrideAction");
        formatter.field("count", &self.count);
        formatter.field("none", &self.none);
        formatter.finish()
    }
}
/// See [`OverrideAction`](crate::model::OverrideAction)
pub mod override_action {
    /// A builder for [`OverrideAction`](crate::model::OverrideAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) count: std::option::Option<crate::model::CountAction>,
        pub(crate) none: std::option::Option<crate::model::NoneAction>,
    }
    impl Builder {
        /// <p>Override the rule group evaluation result to count only. </p> <note>
        /// <p>This option is usually set to none. It does not affect how the rules in the rule group are evaluated. If you want the rules in the rule group to only count matches, do not use this and instead exclude those rules in your rule group reference statement settings. </p>
        /// </note>
        pub fn count(mut self, input: crate::model::CountAction) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>Override the rule group evaluation result to count only. </p> <note>
        /// <p>This option is usually set to none. It does not affect how the rules in the rule group are evaluated. If you want the rules in the rule group to only count matches, do not use this and instead exclude those rules in your rule group reference statement settings. </p>
        /// </note>
        pub fn set_count(mut self, input: std::option::Option<crate::model::CountAction>) -> Self {
            self.count = input;
            self
        }
        /// <p>Don't override the rule group evaluation result. This is the most common setting.</p>
        pub fn none(mut self, input: crate::model::NoneAction) -> Self {
            self.none = Some(input);
            self
        }
        /// <p>Don't override the rule group evaluation result. This is the most common setting.</p>
        pub fn set_none(mut self, input: std::option::Option<crate::model::NoneAction>) -> Self {
            self.none = input;
            self
        }
        /// Consumes the builder and constructs a [`OverrideAction`](crate::model::OverrideAction)
        pub fn build(self) -> crate::model::OverrideAction {
            crate::model::OverrideAction {
                count: self.count,
                none: self.none,
            }
        }
    }
}
impl OverrideAction {
    /// Creates a new builder-style object to manufacture [`OverrideAction`](crate::model::OverrideAction)
    pub fn builder() -> crate::model::override_action::Builder {
        crate::model::override_action::Builder::default()
    }
}

/// <p>Specifies that WAF should do nothing. This is used for the <code>OverrideAction</code> setting on a <code>Rule</code> when the rule uses a rule group reference statement. </p>
/// <p>This is used in the context of other settings, for example to specify values for <code>RuleAction</code> and web ACL <code>DefaultAction</code>. </p>
/// <p>JSON specification: <code>"None": {}</code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoneAction {}
impl std::fmt::Debug for NoneAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoneAction");
        formatter.finish()
    }
}
/// See [`NoneAction`](crate::model::NoneAction)
pub mod none_action {
    /// A builder for [`NoneAction`](crate::model::NoneAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`NoneAction`](crate::model::NoneAction)
        pub fn build(self) -> crate::model::NoneAction {
            crate::model::NoneAction {}
        }
    }
}
impl NoneAction {
    /// Creates a new builder-style object to manufacture [`NoneAction`](crate::model::NoneAction)
    pub fn builder() -> crate::model::none_action::Builder {
        crate::model::none_action::Builder::default()
    }
}

/// <p>Specifies that WAF should count the request. Optionally defines additional custom handling for the request.</p>
/// <p>This is used in the context of other settings, for example to specify values for <code>RuleAction</code> and web ACL <code>DefaultAction</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CountAction {
    /// <p>Defines custom handling for the web request.</p>
    /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    pub custom_request_handling: std::option::Option<crate::model::CustomRequestHandling>,
}
impl CountAction {
    /// <p>Defines custom handling for the web request.</p>
    /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    pub fn custom_request_handling(
        &self,
    ) -> std::option::Option<&crate::model::CustomRequestHandling> {
        self.custom_request_handling.as_ref()
    }
}
impl std::fmt::Debug for CountAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CountAction");
        formatter.field("custom_request_handling", &self.custom_request_handling);
        formatter.finish()
    }
}
/// See [`CountAction`](crate::model::CountAction)
pub mod count_action {
    /// A builder for [`CountAction`](crate::model::CountAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) custom_request_handling:
            std::option::Option<crate::model::CustomRequestHandling>,
    }
    impl Builder {
        /// <p>Defines custom handling for the web request.</p>
        /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        pub fn custom_request_handling(
            mut self,
            input: crate::model::CustomRequestHandling,
        ) -> Self {
            self.custom_request_handling = Some(input);
            self
        }
        /// <p>Defines custom handling for the web request.</p>
        /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        pub fn set_custom_request_handling(
            mut self,
            input: std::option::Option<crate::model::CustomRequestHandling>,
        ) -> Self {
            self.custom_request_handling = input;
            self
        }
        /// Consumes the builder and constructs a [`CountAction`](crate::model::CountAction)
        pub fn build(self) -> crate::model::CountAction {
            crate::model::CountAction {
                custom_request_handling: self.custom_request_handling,
            }
        }
    }
}
impl CountAction {
    /// Creates a new builder-style object to manufacture [`CountAction`](crate::model::CountAction)
    pub fn builder() -> crate::model::count_action::Builder {
        crate::model::count_action::Builder::default()
    }
}

/// <p>Custom request handling behavior that inserts custom headers into a web request. You can add custom request handling for the rule actions allow and count. </p>
/// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomRequestHandling {
    /// <p>The HTTP headers to insert into the request. Duplicate header names are not allowed. </p>
    /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    pub insert_headers: std::option::Option<std::vec::Vec<crate::model::CustomHttpHeader>>,
}
impl CustomRequestHandling {
    /// <p>The HTTP headers to insert into the request. Duplicate header names are not allowed. </p>
    /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    pub fn insert_headers(&self) -> std::option::Option<&[crate::model::CustomHttpHeader]> {
        self.insert_headers.as_deref()
    }
}
impl std::fmt::Debug for CustomRequestHandling {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomRequestHandling");
        formatter.field("insert_headers", &self.insert_headers);
        formatter.finish()
    }
}
/// See [`CustomRequestHandling`](crate::model::CustomRequestHandling)
pub mod custom_request_handling {
    /// A builder for [`CustomRequestHandling`](crate::model::CustomRequestHandling)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) insert_headers:
            std::option::Option<std::vec::Vec<crate::model::CustomHttpHeader>>,
    }
    impl Builder {
        /// Appends an item to `insert_headers`.
        ///
        /// To override the contents of this collection use [`set_insert_headers`](Self::set_insert_headers).
        ///
        /// <p>The HTTP headers to insert into the request. Duplicate header names are not allowed. </p>
        /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        pub fn insert_headers(mut self, input: crate::model::CustomHttpHeader) -> Self {
            let mut v = self.insert_headers.unwrap_or_default();
            v.push(input);
            self.insert_headers = Some(v);
            self
        }
        /// <p>The HTTP headers to insert into the request. Duplicate header names are not allowed. </p>
        /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        pub fn set_insert_headers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CustomHttpHeader>>,
        ) -> Self {
            self.insert_headers = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomRequestHandling`](crate::model::CustomRequestHandling)
        pub fn build(self) -> crate::model::CustomRequestHandling {
            crate::model::CustomRequestHandling {
                insert_headers: self.insert_headers,
            }
        }
    }
}
impl CustomRequestHandling {
    /// Creates a new builder-style object to manufacture [`CustomRequestHandling`](crate::model::CustomRequestHandling)
    pub fn builder() -> crate::model::custom_request_handling::Builder {
        crate::model::custom_request_handling::Builder::default()
    }
}

/// <p>A custom header for custom request and response handling. This is used in <code>CustomResponse</code> and <code>CustomRequestHandling</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomHttpHeader {
    /// <p>The name of the custom header. </p>
    /// <p>For custom request header insertion, when WAF inserts the header into the request, it prefixes this name <code>x-amzn-waf-</code>, to avoid confusion with the headers that are already in the request. For example, for the header name <code>sample</code>, WAF inserts the header <code>x-amzn-waf-sample</code>.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The value of the custom header.</p>
    pub value: std::option::Option<std::string::String>,
}
impl CustomHttpHeader {
    /// <p>The name of the custom header. </p>
    /// <p>For custom request header insertion, when WAF inserts the header into the request, it prefixes this name <code>x-amzn-waf-</code>, to avoid confusion with the headers that are already in the request. For example, for the header name <code>sample</code>, WAF inserts the header <code>x-amzn-waf-sample</code>.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The value of the custom header.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for CustomHttpHeader {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomHttpHeader");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`CustomHttpHeader`](crate::model::CustomHttpHeader)
pub mod custom_http_header {
    /// A builder for [`CustomHttpHeader`](crate::model::CustomHttpHeader)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the custom header. </p>
        /// <p>For custom request header insertion, when WAF inserts the header into the request, it prefixes this name <code>x-amzn-waf-</code>, to avoid confusion with the headers that are already in the request. For example, for the header name <code>sample</code>, WAF inserts the header <code>x-amzn-waf-sample</code>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the custom header. </p>
        /// <p>For custom request header insertion, when WAF inserts the header into the request, it prefixes this name <code>x-amzn-waf-</code>, to avoid confusion with the headers that are already in the request. For example, for the header name <code>sample</code>, WAF inserts the header <code>x-amzn-waf-sample</code>.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The value of the custom header.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the custom header.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomHttpHeader`](crate::model::CustomHttpHeader)
        pub fn build(self) -> crate::model::CustomHttpHeader {
            crate::model::CustomHttpHeader {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl CustomHttpHeader {
    /// Creates a new builder-style object to manufacture [`CustomHttpHeader`](crate::model::CustomHttpHeader)
    pub fn builder() -> crate::model::custom_http_header::Builder {
        crate::model::custom_http_header::Builder::default()
    }
}

/// <p>The action that WAF should take on a web request when it matches a rule's statement. Settings at the web ACL level can override the rule action setting. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuleAction {
    /// <p>Instructs WAF to block the web request.</p>
    pub block: std::option::Option<crate::model::BlockAction>,
    /// <p>Instructs WAF to allow the web request.</p>
    pub allow: std::option::Option<crate::model::AllowAction>,
    /// <p>Instructs WAF to count the web request and allow it.</p>
    pub count: std::option::Option<crate::model::CountAction>,
    /// <p>Instructs WAF to run a <code>CAPTCHA</code> check against the web request.</p>
    pub captcha: std::option::Option<crate::model::CaptchaAction>,
}
impl RuleAction {
    /// <p>Instructs WAF to block the web request.</p>
    pub fn block(&self) -> std::option::Option<&crate::model::BlockAction> {
        self.block.as_ref()
    }
    /// <p>Instructs WAF to allow the web request.</p>
    pub fn allow(&self) -> std::option::Option<&crate::model::AllowAction> {
        self.allow.as_ref()
    }
    /// <p>Instructs WAF to count the web request and allow it.</p>
    pub fn count(&self) -> std::option::Option<&crate::model::CountAction> {
        self.count.as_ref()
    }
    /// <p>Instructs WAF to run a <code>CAPTCHA</code> check against the web request.</p>
    pub fn captcha(&self) -> std::option::Option<&crate::model::CaptchaAction> {
        self.captcha.as_ref()
    }
}
impl std::fmt::Debug for RuleAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RuleAction");
        formatter.field("block", &self.block);
        formatter.field("allow", &self.allow);
        formatter.field("count", &self.count);
        formatter.field("captcha", &self.captcha);
        formatter.finish()
    }
}
/// See [`RuleAction`](crate::model::RuleAction)
pub mod rule_action {
    /// A builder for [`RuleAction`](crate::model::RuleAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) block: std::option::Option<crate::model::BlockAction>,
        pub(crate) allow: std::option::Option<crate::model::AllowAction>,
        pub(crate) count: std::option::Option<crate::model::CountAction>,
        pub(crate) captcha: std::option::Option<crate::model::CaptchaAction>,
    }
    impl Builder {
        /// <p>Instructs WAF to block the web request.</p>
        pub fn block(mut self, input: crate::model::BlockAction) -> Self {
            self.block = Some(input);
            self
        }
        /// <p>Instructs WAF to block the web request.</p>
        pub fn set_block(mut self, input: std::option::Option<crate::model::BlockAction>) -> Self {
            self.block = input;
            self
        }
        /// <p>Instructs WAF to allow the web request.</p>
        pub fn allow(mut self, input: crate::model::AllowAction) -> Self {
            self.allow = Some(input);
            self
        }
        /// <p>Instructs WAF to allow the web request.</p>
        pub fn set_allow(mut self, input: std::option::Option<crate::model::AllowAction>) -> Self {
            self.allow = input;
            self
        }
        /// <p>Instructs WAF to count the web request and allow it.</p>
        pub fn count(mut self, input: crate::model::CountAction) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>Instructs WAF to count the web request and allow it.</p>
        pub fn set_count(mut self, input: std::option::Option<crate::model::CountAction>) -> Self {
            self.count = input;
            self
        }
        /// <p>Instructs WAF to run a <code>CAPTCHA</code> check against the web request.</p>
        pub fn captcha(mut self, input: crate::model::CaptchaAction) -> Self {
            self.captcha = Some(input);
            self
        }
        /// <p>Instructs WAF to run a <code>CAPTCHA</code> check against the web request.</p>
        pub fn set_captcha(
            mut self,
            input: std::option::Option<crate::model::CaptchaAction>,
        ) -> Self {
            self.captcha = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleAction`](crate::model::RuleAction)
        pub fn build(self) -> crate::model::RuleAction {
            crate::model::RuleAction {
                block: self.block,
                allow: self.allow,
                count: self.count,
                captcha: self.captcha,
            }
        }
    }
}
impl RuleAction {
    /// Creates a new builder-style object to manufacture [`RuleAction`](crate::model::RuleAction)
    pub fn builder() -> crate::model::rule_action::Builder {
        crate::model::rule_action::Builder::default()
    }
}

/// <p>Specifies that WAF should run a <code>CAPTCHA</code> check against the request: </p>
/// <ul>
/// <li> <p>If the request includes a valid, unexpired <code>CAPTCHA</code> token, WAF allows the web request inspection to proceed to the next rule, similar to a <code>CountAction</code>. </p> </li>
/// <li> <p>If the request doesn't include a valid, unexpired <code>CAPTCHA</code> token, WAF discontinues the web ACL evaluation of the request and blocks it from going to its intended destination.</p> <p>WAF generates a response that it sends back to the client, which includes the following: </p>
/// <ul>
/// <li> <p>The header <code>x-amzn-waf-action</code> with a value of <code>captcha</code>. </p> </li>
/// <li> <p>The HTTP status code <code>405 Method Not Allowed</code>. </p> </li>
/// <li> <p>If the request contains an <code>Accept</code> header with a value of <code>text/html</code>, the response includes a <code>CAPTCHA</code> challenge. </p> </li>
/// </ul> </li>
/// </ul>
/// <p>You can configure the expiration time in the <code>CaptchaConfig</code> <code>ImmunityTimeProperty</code> setting at the rule and web ACL level. The rule setting overrides the web ACL setting. </p>
/// <p>This action option is available for rules. It isn't available for web ACL default actions. </p>
/// <p>This is used in the context of other settings, for example to specify values for <code>RuleAction</code> and web ACL <code>DefaultAction</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CaptchaAction {
    /// <p>Defines custom handling for the web request.</p>
    /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    pub custom_request_handling: std::option::Option<crate::model::CustomRequestHandling>,
}
impl CaptchaAction {
    /// <p>Defines custom handling for the web request.</p>
    /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    pub fn custom_request_handling(
        &self,
    ) -> std::option::Option<&crate::model::CustomRequestHandling> {
        self.custom_request_handling.as_ref()
    }
}
impl std::fmt::Debug for CaptchaAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CaptchaAction");
        formatter.field("custom_request_handling", &self.custom_request_handling);
        formatter.finish()
    }
}
/// See [`CaptchaAction`](crate::model::CaptchaAction)
pub mod captcha_action {
    /// A builder for [`CaptchaAction`](crate::model::CaptchaAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) custom_request_handling:
            std::option::Option<crate::model::CustomRequestHandling>,
    }
    impl Builder {
        /// <p>Defines custom handling for the web request.</p>
        /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        pub fn custom_request_handling(
            mut self,
            input: crate::model::CustomRequestHandling,
        ) -> Self {
            self.custom_request_handling = Some(input);
            self
        }
        /// <p>Defines custom handling for the web request.</p>
        /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        pub fn set_custom_request_handling(
            mut self,
            input: std::option::Option<crate::model::CustomRequestHandling>,
        ) -> Self {
            self.custom_request_handling = input;
            self
        }
        /// Consumes the builder and constructs a [`CaptchaAction`](crate::model::CaptchaAction)
        pub fn build(self) -> crate::model::CaptchaAction {
            crate::model::CaptchaAction {
                custom_request_handling: self.custom_request_handling,
            }
        }
    }
}
impl CaptchaAction {
    /// Creates a new builder-style object to manufacture [`CaptchaAction`](crate::model::CaptchaAction)
    pub fn builder() -> crate::model::captcha_action::Builder {
        crate::model::captcha_action::Builder::default()
    }
}

/// <p>Specifies that WAF should allow the request and optionally defines additional custom handling for the request.</p>
/// <p>This is used in the context of other settings, for example to specify values for <code>RuleAction</code> and web ACL <code>DefaultAction</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AllowAction {
    /// <p>Defines custom handling for the web request.</p>
    /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    pub custom_request_handling: std::option::Option<crate::model::CustomRequestHandling>,
}
impl AllowAction {
    /// <p>Defines custom handling for the web request.</p>
    /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    pub fn custom_request_handling(
        &self,
    ) -> std::option::Option<&crate::model::CustomRequestHandling> {
        self.custom_request_handling.as_ref()
    }
}
impl std::fmt::Debug for AllowAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AllowAction");
        formatter.field("custom_request_handling", &self.custom_request_handling);
        formatter.finish()
    }
}
/// See [`AllowAction`](crate::model::AllowAction)
pub mod allow_action {
    /// A builder for [`AllowAction`](crate::model::AllowAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) custom_request_handling:
            std::option::Option<crate::model::CustomRequestHandling>,
    }
    impl Builder {
        /// <p>Defines custom handling for the web request.</p>
        /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        pub fn custom_request_handling(
            mut self,
            input: crate::model::CustomRequestHandling,
        ) -> Self {
            self.custom_request_handling = Some(input);
            self
        }
        /// <p>Defines custom handling for the web request.</p>
        /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        pub fn set_custom_request_handling(
            mut self,
            input: std::option::Option<crate::model::CustomRequestHandling>,
        ) -> Self {
            self.custom_request_handling = input;
            self
        }
        /// Consumes the builder and constructs a [`AllowAction`](crate::model::AllowAction)
        pub fn build(self) -> crate::model::AllowAction {
            crate::model::AllowAction {
                custom_request_handling: self.custom_request_handling,
            }
        }
    }
}
impl AllowAction {
    /// Creates a new builder-style object to manufacture [`AllowAction`](crate::model::AllowAction)
    pub fn builder() -> crate::model::allow_action::Builder {
        crate::model::allow_action::Builder::default()
    }
}

/// <p>Specifies that WAF should block the request and optionally defines additional custom handling for the response to the web request.</p>
/// <p>This is used in the context of other settings, for example to specify values for <code>RuleAction</code> and web ACL <code>DefaultAction</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BlockAction {
    /// <p>Defines a custom response for the web request.</p>
    /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    pub custom_response: std::option::Option<crate::model::CustomResponse>,
}
impl BlockAction {
    /// <p>Defines a custom response for the web request.</p>
    /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    pub fn custom_response(&self) -> std::option::Option<&crate::model::CustomResponse> {
        self.custom_response.as_ref()
    }
}
impl std::fmt::Debug for BlockAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BlockAction");
        formatter.field("custom_response", &self.custom_response);
        formatter.finish()
    }
}
/// See [`BlockAction`](crate::model::BlockAction)
pub mod block_action {
    /// A builder for [`BlockAction`](crate::model::BlockAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) custom_response: std::option::Option<crate::model::CustomResponse>,
    }
    impl Builder {
        /// <p>Defines a custom response for the web request.</p>
        /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        pub fn custom_response(mut self, input: crate::model::CustomResponse) -> Self {
            self.custom_response = Some(input);
            self
        }
        /// <p>Defines a custom response for the web request.</p>
        /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        pub fn set_custom_response(
            mut self,
            input: std::option::Option<crate::model::CustomResponse>,
        ) -> Self {
            self.custom_response = input;
            self
        }
        /// Consumes the builder and constructs a [`BlockAction`](crate::model::BlockAction)
        pub fn build(self) -> crate::model::BlockAction {
            crate::model::BlockAction {
                custom_response: self.custom_response,
            }
        }
    }
}
impl BlockAction {
    /// Creates a new builder-style object to manufacture [`BlockAction`](crate::model::BlockAction)
    pub fn builder() -> crate::model::block_action::Builder {
        crate::model::block_action::Builder::default()
    }
}

/// <p>A custom response to send to the client. You can define a custom response for rule actions and default web ACL actions that are set to <code>BlockAction</code>. </p>
/// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomResponse {
    /// <p>The HTTP status code to return to the client. </p>
    /// <p>For a list of status codes that you can use in your custom reqponses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/customizing-the-response-status-codes.html">Supported status codes for custom response</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    pub response_code: std::option::Option<i32>,
    /// <p>References the response body that you want WAF to return to the web request client. You can define a custom response for a rule action or a default web ACL action that is set to block. To do this, you first define the response body key and value in the <code>CustomResponseBodies</code> setting for the <code>WebACL</code> or <code>RuleGroup</code> where you want to use it. Then, in the rule action or web ACL default action <code>BlockAction</code> setting, you reference the response body using this key. </p>
    pub custom_response_body_key: std::option::Option<std::string::String>,
    /// <p>The HTTP headers to use in the response. Duplicate header names are not allowed. </p>
    /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    pub response_headers: std::option::Option<std::vec::Vec<crate::model::CustomHttpHeader>>,
}
impl CustomResponse {
    /// <p>The HTTP status code to return to the client. </p>
    /// <p>For a list of status codes that you can use in your custom reqponses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/customizing-the-response-status-codes.html">Supported status codes for custom response</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    pub fn response_code(&self) -> std::option::Option<i32> {
        self.response_code
    }
    /// <p>References the response body that you want WAF to return to the web request client. You can define a custom response for a rule action or a default web ACL action that is set to block. To do this, you first define the response body key and value in the <code>CustomResponseBodies</code> setting for the <code>WebACL</code> or <code>RuleGroup</code> where you want to use it. Then, in the rule action or web ACL default action <code>BlockAction</code> setting, you reference the response body using this key. </p>
    pub fn custom_response_body_key(&self) -> std::option::Option<&str> {
        self.custom_response_body_key.as_deref()
    }
    /// <p>The HTTP headers to use in the response. Duplicate header names are not allowed. </p>
    /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    pub fn response_headers(&self) -> std::option::Option<&[crate::model::CustomHttpHeader]> {
        self.response_headers.as_deref()
    }
}
impl std::fmt::Debug for CustomResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomResponse");
        formatter.field("response_code", &self.response_code);
        formatter.field("custom_response_body_key", &self.custom_response_body_key);
        formatter.field("response_headers", &self.response_headers);
        formatter.finish()
    }
}
/// See [`CustomResponse`](crate::model::CustomResponse)
pub mod custom_response {
    /// A builder for [`CustomResponse`](crate::model::CustomResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) response_code: std::option::Option<i32>,
        pub(crate) custom_response_body_key: std::option::Option<std::string::String>,
        pub(crate) response_headers:
            std::option::Option<std::vec::Vec<crate::model::CustomHttpHeader>>,
    }
    impl Builder {
        /// <p>The HTTP status code to return to the client. </p>
        /// <p>For a list of status codes that you can use in your custom reqponses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/customizing-the-response-status-codes.html">Supported status codes for custom response</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        pub fn response_code(mut self, input: i32) -> Self {
            self.response_code = Some(input);
            self
        }
        /// <p>The HTTP status code to return to the client. </p>
        /// <p>For a list of status codes that you can use in your custom reqponses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/customizing-the-response-status-codes.html">Supported status codes for custom response</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        pub fn set_response_code(mut self, input: std::option::Option<i32>) -> Self {
            self.response_code = input;
            self
        }
        /// <p>References the response body that you want WAF to return to the web request client. You can define a custom response for a rule action or a default web ACL action that is set to block. To do this, you first define the response body key and value in the <code>CustomResponseBodies</code> setting for the <code>WebACL</code> or <code>RuleGroup</code> where you want to use it. Then, in the rule action or web ACL default action <code>BlockAction</code> setting, you reference the response body using this key. </p>
        pub fn custom_response_body_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_response_body_key = Some(input.into());
            self
        }
        /// <p>References the response body that you want WAF to return to the web request client. You can define a custom response for a rule action or a default web ACL action that is set to block. To do this, you first define the response body key and value in the <code>CustomResponseBodies</code> setting for the <code>WebACL</code> or <code>RuleGroup</code> where you want to use it. Then, in the rule action or web ACL default action <code>BlockAction</code> setting, you reference the response body using this key. </p>
        pub fn set_custom_response_body_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.custom_response_body_key = input;
            self
        }
        /// Appends an item to `response_headers`.
        ///
        /// To override the contents of this collection use [`set_response_headers`](Self::set_response_headers).
        ///
        /// <p>The HTTP headers to use in the response. Duplicate header names are not allowed. </p>
        /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        pub fn response_headers(mut self, input: crate::model::CustomHttpHeader) -> Self {
            let mut v = self.response_headers.unwrap_or_default();
            v.push(input);
            self.response_headers = Some(v);
            self
        }
        /// <p>The HTTP headers to use in the response. Duplicate header names are not allowed. </p>
        /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        pub fn set_response_headers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CustomHttpHeader>>,
        ) -> Self {
            self.response_headers = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomResponse`](crate::model::CustomResponse)
        pub fn build(self) -> crate::model::CustomResponse {
            crate::model::CustomResponse {
                response_code: self.response_code,
                custom_response_body_key: self.custom_response_body_key,
                response_headers: self.response_headers,
            }
        }
    }
}
impl CustomResponse {
    /// Creates a new builder-style object to manufacture [`CustomResponse`](crate::model::CustomResponse)
    pub fn builder() -> crate::model::custom_response::Builder {
        crate::model::custom_response::Builder::default()
    }
}

/// <p>The processing guidance for a <code>Rule</code>, used by WAF to determine whether a web request matches the rule. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Statement {
    /// <p>A rule statement that defines a string match search for WAF to apply to web requests. The byte match statement provides the bytes to search for, the location in requests that you want WAF to search, and other settings. The bytes to search for are typically a string that corresponds with ASCII characters. In the WAF console and the developer guide, this is refered to as a string match statement.</p>
    pub byte_match_statement: std::option::Option<crate::model::ByteMatchStatement>,
    /// <p>Attackers sometimes insert malicious SQL code into web requests in an effort to extract data from your database. To allow or block web requests that appear to contain malicious SQL code, create one or more SQL injection match conditions. An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want WAF to inspect. Later in the process, when you create a web ACL, you specify whether to allow or block requests that appear to contain malicious SQL code.</p>
    pub sqli_match_statement: std::option::Option<crate::model::SqliMatchStatement>,
    /// <p>A rule statement that defines a cross-site scripting (XSS) match search for WAF to apply to web requests. XSS attacks are those where the attacker uses vulnerabilities in a benign website as a vehicle to inject malicious client-site scripts into other legitimate web browsers. The XSS match statement provides the location in requests that you want WAF to search and text transformations to use on the search area before WAF searches for character sequences that are likely to be malicious strings. </p>
    pub xss_match_statement: std::option::Option<crate::model::XssMatchStatement>,
    /// <p>A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (&gt;) or less than (&lt;). For example, you can use a size constraint statement to look for query strings that are longer than 100 bytes. </p>
    /// <p>If you configure WAF to inspect the request body, WAF inspects only the first 8192 bytes (8 KB). If the request body for your web requests never exceeds 8192 bytes, you can create a size constraint condition and block requests that have a request body greater than 8192 bytes.</p>
    /// <p>If you choose URI for the value of Part of the request to filter on, the slash (/) in the URI counts as one character. For example, the URI <code>/logo.jpg</code> is nine characters long.</p>
    pub size_constraint_statement: std::option::Option<crate::model::SizeConstraintStatement>,
    /// <p>A rule statement used to identify web requests based on country of origin. </p>
    pub geo_match_statement: std::option::Option<crate::model::GeoMatchStatement>,
    /// <p>A rule statement used to run the rules that are defined in a <code>RuleGroup</code>. To use this, create a rule group with your rules, then provide the ARN of the rule group in this statement.</p>
    /// <p>You cannot nest a <code>RuleGroupReferenceStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. You can only use a rule group reference statement at the top level inside a web ACL. </p>
    pub rule_group_reference_statement:
        std::option::Option<crate::model::RuleGroupReferenceStatement>,
    /// <p>A rule statement used to detect web requests coming from particular IP addresses or address ranges. To use this, create an <code>IPSet</code> that specifies the addresses you want to detect, then use the ARN of that set in this statement. To create an IP set, see <code>CreateIPSet</code>.</p>
    /// <p>Each IP set rule statement references an IP set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, WAF automatically updates all rules that reference it.</p>
    pub ip_set_reference_statement: std::option::Option<crate::model::IpSetReferenceStatement>,
    /// <p>A rule statement used to search web request components for matches with regular expressions. To use this, create a <code>RegexPatternSet</code> that specifies the expressions that you want to detect, then use the ARN of that set in this statement. A web request matches the pattern set rule statement if the request component matches any of the patterns in the set. To create a regex pattern set, see <code>CreateRegexPatternSet</code>.</p>
    /// <p>Each regex pattern set rule statement references a regex pattern set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, WAF automatically updates all rules that reference it.</p>
    pub regex_pattern_set_reference_statement:
        std::option::Option<crate::model::RegexPatternSetReferenceStatement>,
    /// <p>A rate-based rule tracks the rate of requests for each originating IP address, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any 5-minute time span. You can use this to put a temporary block on requests from an IP address that is sending excessive requests. </p>
    /// <p>WAF tracks and manages web requests separately for each instance of a rate-based rule that you use. For example, if you provide the same rate-based rule settings in two web ACLs, each of the two rule statements represents a separate instance of the rate-based rule and gets its own tracking and management by WAF. If you define a rate-based rule inside a rule group, and then use that rule group in multiple places, each use creates a separate instance of the rate-based rule that gets its own tracking and management by WAF. </p>
    /// <p>When the rule action triggers, WAF blocks additional requests from the IP address until the request rate falls below the limit.</p>
    /// <p>You can optionally nest another statement inside the rate-based statement, to narrow the scope of the rule so that it only counts requests that match the nested statement. For example, based on recent requests that you have seen from an attacker, you might create a rate-based rule with a nested AND rule statement that contains the following nested statements:</p>
    /// <ul>
    /// <li> <p>An IP match statement with an IP set that specified the address 192.0.2.44.</p> </li>
    /// <li> <p>A string match statement that searches in the User-Agent header for the string BadBot.</p> </li>
    /// </ul>
    /// <p>In this rate-based rule, you also define a rate limit. For this example, the rate limit is 1,000. Requests that meet both of the conditions in the statements are counted. If the count exceeds 1,000 requests per five minutes, the rule action triggers. Requests that do not meet both conditions are not counted towards the rate limit and are not affected by this rule.</p>
    /// <p>You cannot nest a <code>RateBasedStatement</code> inside another statement, for example inside a <code>NotStatement</code> or <code>OrStatement</code>. You can define a <code>RateBasedStatement</code> inside a web ACL and inside a rule group. </p>
    pub rate_based_statement: std::option::Option<crate::model::RateBasedStatement>,
    /// <p>A logical rule statement used to combine other rule statements with AND logic. You provide more than one <code>Statement</code> within the <code>AndStatement</code>. </p>
    pub and_statement: std::option::Option<crate::model::AndStatement>,
    /// <p>A logical rule statement used to combine other rule statements with OR logic. You provide more than one <code>Statement</code> within the <code>OrStatement</code>. </p>
    pub or_statement: std::option::Option<crate::model::OrStatement>,
    /// <p>A logical rule statement used to negate the results of another rule statement. You provide one <code>Statement</code> within the <code>NotStatement</code>.</p>
    pub not_statement: std::option::Option<crate::model::NotStatement>,
    /// <p>A rule statement used to run the rules that are defined in a managed rule group. To use this, provide the vendor name and the name of the rule group in this statement. You can retrieve the required names by calling <code>ListAvailableManagedRuleGroups</code>.</p>
    /// <p>You cannot nest a <code>ManagedRuleGroupStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. It can only be referenced as a top-level statement within a rule.</p>
    pub managed_rule_group_statement: std::option::Option<crate::model::ManagedRuleGroupStatement>,
    /// <p>A rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. </p>
    /// <p>The label match statement provides the label or namespace string to search for. The label string can represent a part or all of the fully qualified label name that had been added to the web request. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. If you do not provide the fully qualified name in your label match string, WAF performs the search for labels that were added in the same context as the label match statement. </p>
    pub label_match_statement: std::option::Option<crate::model::LabelMatchStatement>,
    /// <p>A rule statement used to search web request components for a match against a single regular expression. </p>
    pub regex_match_statement: std::option::Option<crate::model::RegexMatchStatement>,
}
impl Statement {
    /// <p>A rule statement that defines a string match search for WAF to apply to web requests. The byte match statement provides the bytes to search for, the location in requests that you want WAF to search, and other settings. The bytes to search for are typically a string that corresponds with ASCII characters. In the WAF console and the developer guide, this is refered to as a string match statement.</p>
    pub fn byte_match_statement(&self) -> std::option::Option<&crate::model::ByteMatchStatement> {
        self.byte_match_statement.as_ref()
    }
    /// <p>Attackers sometimes insert malicious SQL code into web requests in an effort to extract data from your database. To allow or block web requests that appear to contain malicious SQL code, create one or more SQL injection match conditions. An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want WAF to inspect. Later in the process, when you create a web ACL, you specify whether to allow or block requests that appear to contain malicious SQL code.</p>
    pub fn sqli_match_statement(&self) -> std::option::Option<&crate::model::SqliMatchStatement> {
        self.sqli_match_statement.as_ref()
    }
    /// <p>A rule statement that defines a cross-site scripting (XSS) match search for WAF to apply to web requests. XSS attacks are those where the attacker uses vulnerabilities in a benign website as a vehicle to inject malicious client-site scripts into other legitimate web browsers. The XSS match statement provides the location in requests that you want WAF to search and text transformations to use on the search area before WAF searches for character sequences that are likely to be malicious strings. </p>
    pub fn xss_match_statement(&self) -> std::option::Option<&crate::model::XssMatchStatement> {
        self.xss_match_statement.as_ref()
    }
    /// <p>A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (&gt;) or less than (&lt;). For example, you can use a size constraint statement to look for query strings that are longer than 100 bytes. </p>
    /// <p>If you configure WAF to inspect the request body, WAF inspects only the first 8192 bytes (8 KB). If the request body for your web requests never exceeds 8192 bytes, you can create a size constraint condition and block requests that have a request body greater than 8192 bytes.</p>
    /// <p>If you choose URI for the value of Part of the request to filter on, the slash (/) in the URI counts as one character. For example, the URI <code>/logo.jpg</code> is nine characters long.</p>
    pub fn size_constraint_statement(
        &self,
    ) -> std::option::Option<&crate::model::SizeConstraintStatement> {
        self.size_constraint_statement.as_ref()
    }
    /// <p>A rule statement used to identify web requests based on country of origin. </p>
    pub fn geo_match_statement(&self) -> std::option::Option<&crate::model::GeoMatchStatement> {
        self.geo_match_statement.as_ref()
    }
    /// <p>A rule statement used to run the rules that are defined in a <code>RuleGroup</code>. To use this, create a rule group with your rules, then provide the ARN of the rule group in this statement.</p>
    /// <p>You cannot nest a <code>RuleGroupReferenceStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. You can only use a rule group reference statement at the top level inside a web ACL. </p>
    pub fn rule_group_reference_statement(
        &self,
    ) -> std::option::Option<&crate::model::RuleGroupReferenceStatement> {
        self.rule_group_reference_statement.as_ref()
    }
    /// <p>A rule statement used to detect web requests coming from particular IP addresses or address ranges. To use this, create an <code>IPSet</code> that specifies the addresses you want to detect, then use the ARN of that set in this statement. To create an IP set, see <code>CreateIPSet</code>.</p>
    /// <p>Each IP set rule statement references an IP set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, WAF automatically updates all rules that reference it.</p>
    pub fn ip_set_reference_statement(
        &self,
    ) -> std::option::Option<&crate::model::IpSetReferenceStatement> {
        self.ip_set_reference_statement.as_ref()
    }
    /// <p>A rule statement used to search web request components for matches with regular expressions. To use this, create a <code>RegexPatternSet</code> that specifies the expressions that you want to detect, then use the ARN of that set in this statement. A web request matches the pattern set rule statement if the request component matches any of the patterns in the set. To create a regex pattern set, see <code>CreateRegexPatternSet</code>.</p>
    /// <p>Each regex pattern set rule statement references a regex pattern set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, WAF automatically updates all rules that reference it.</p>
    pub fn regex_pattern_set_reference_statement(
        &self,
    ) -> std::option::Option<&crate::model::RegexPatternSetReferenceStatement> {
        self.regex_pattern_set_reference_statement.as_ref()
    }
    /// <p>A rate-based rule tracks the rate of requests for each originating IP address, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any 5-minute time span. You can use this to put a temporary block on requests from an IP address that is sending excessive requests. </p>
    /// <p>WAF tracks and manages web requests separately for each instance of a rate-based rule that you use. For example, if you provide the same rate-based rule settings in two web ACLs, each of the two rule statements represents a separate instance of the rate-based rule and gets its own tracking and management by WAF. If you define a rate-based rule inside a rule group, and then use that rule group in multiple places, each use creates a separate instance of the rate-based rule that gets its own tracking and management by WAF. </p>
    /// <p>When the rule action triggers, WAF blocks additional requests from the IP address until the request rate falls below the limit.</p>
    /// <p>You can optionally nest another statement inside the rate-based statement, to narrow the scope of the rule so that it only counts requests that match the nested statement. For example, based on recent requests that you have seen from an attacker, you might create a rate-based rule with a nested AND rule statement that contains the following nested statements:</p>
    /// <ul>
    /// <li> <p>An IP match statement with an IP set that specified the address 192.0.2.44.</p> </li>
    /// <li> <p>A string match statement that searches in the User-Agent header for the string BadBot.</p> </li>
    /// </ul>
    /// <p>In this rate-based rule, you also define a rate limit. For this example, the rate limit is 1,000. Requests that meet both of the conditions in the statements are counted. If the count exceeds 1,000 requests per five minutes, the rule action triggers. Requests that do not meet both conditions are not counted towards the rate limit and are not affected by this rule.</p>
    /// <p>You cannot nest a <code>RateBasedStatement</code> inside another statement, for example inside a <code>NotStatement</code> or <code>OrStatement</code>. You can define a <code>RateBasedStatement</code> inside a web ACL and inside a rule group. </p>
    pub fn rate_based_statement(&self) -> std::option::Option<&crate::model::RateBasedStatement> {
        self.rate_based_statement.as_ref()
    }
    /// <p>A logical rule statement used to combine other rule statements with AND logic. You provide more than one <code>Statement</code> within the <code>AndStatement</code>. </p>
    pub fn and_statement(&self) -> std::option::Option<&crate::model::AndStatement> {
        self.and_statement.as_ref()
    }
    /// <p>A logical rule statement used to combine other rule statements with OR logic. You provide more than one <code>Statement</code> within the <code>OrStatement</code>. </p>
    pub fn or_statement(&self) -> std::option::Option<&crate::model::OrStatement> {
        self.or_statement.as_ref()
    }
    /// <p>A logical rule statement used to negate the results of another rule statement. You provide one <code>Statement</code> within the <code>NotStatement</code>.</p>
    pub fn not_statement(&self) -> std::option::Option<&crate::model::NotStatement> {
        self.not_statement.as_ref()
    }
    /// <p>A rule statement used to run the rules that are defined in a managed rule group. To use this, provide the vendor name and the name of the rule group in this statement. You can retrieve the required names by calling <code>ListAvailableManagedRuleGroups</code>.</p>
    /// <p>You cannot nest a <code>ManagedRuleGroupStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. It can only be referenced as a top-level statement within a rule.</p>
    pub fn managed_rule_group_statement(
        &self,
    ) -> std::option::Option<&crate::model::ManagedRuleGroupStatement> {
        self.managed_rule_group_statement.as_ref()
    }
    /// <p>A rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. </p>
    /// <p>The label match statement provides the label or namespace string to search for. The label string can represent a part or all of the fully qualified label name that had been added to the web request. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. If you do not provide the fully qualified name in your label match string, WAF performs the search for labels that were added in the same context as the label match statement. </p>
    pub fn label_match_statement(&self) -> std::option::Option<&crate::model::LabelMatchStatement> {
        self.label_match_statement.as_ref()
    }
    /// <p>A rule statement used to search web request components for a match against a single regular expression. </p>
    pub fn regex_match_statement(&self) -> std::option::Option<&crate::model::RegexMatchStatement> {
        self.regex_match_statement.as_ref()
    }
}
impl std::fmt::Debug for Statement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Statement");
        formatter.field("byte_match_statement", &self.byte_match_statement);
        formatter.field("sqli_match_statement", &self.sqli_match_statement);
        formatter.field("xss_match_statement", &self.xss_match_statement);
        formatter.field("size_constraint_statement", &self.size_constraint_statement);
        formatter.field("geo_match_statement", &self.geo_match_statement);
        formatter.field(
            "rule_group_reference_statement",
            &self.rule_group_reference_statement,
        );
        formatter.field(
            "ip_set_reference_statement",
            &self.ip_set_reference_statement,
        );
        formatter.field(
            "regex_pattern_set_reference_statement",
            &self.regex_pattern_set_reference_statement,
        );
        formatter.field("rate_based_statement", &self.rate_based_statement);
        formatter.field("and_statement", &self.and_statement);
        formatter.field("or_statement", &self.or_statement);
        formatter.field("not_statement", &self.not_statement);
        formatter.field(
            "managed_rule_group_statement",
            &self.managed_rule_group_statement,
        );
        formatter.field("label_match_statement", &self.label_match_statement);
        formatter.field("regex_match_statement", &self.regex_match_statement);
        formatter.finish()
    }
}
/// See [`Statement`](crate::model::Statement)
pub mod statement {
    /// A builder for [`Statement`](crate::model::Statement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) byte_match_statement: std::option::Option<crate::model::ByteMatchStatement>,
        pub(crate) sqli_match_statement: std::option::Option<crate::model::SqliMatchStatement>,
        pub(crate) xss_match_statement: std::option::Option<crate::model::XssMatchStatement>,
        pub(crate) size_constraint_statement:
            std::option::Option<crate::model::SizeConstraintStatement>,
        pub(crate) geo_match_statement: std::option::Option<crate::model::GeoMatchStatement>,
        pub(crate) rule_group_reference_statement:
            std::option::Option<crate::model::RuleGroupReferenceStatement>,
        pub(crate) ip_set_reference_statement:
            std::option::Option<crate::model::IpSetReferenceStatement>,
        pub(crate) regex_pattern_set_reference_statement:
            std::option::Option<crate::model::RegexPatternSetReferenceStatement>,
        pub(crate) rate_based_statement: std::option::Option<crate::model::RateBasedStatement>,
        pub(crate) and_statement: std::option::Option<crate::model::AndStatement>,
        pub(crate) or_statement: std::option::Option<crate::model::OrStatement>,
        pub(crate) not_statement: std::option::Option<crate::model::NotStatement>,
        pub(crate) managed_rule_group_statement:
            std::option::Option<crate::model::ManagedRuleGroupStatement>,
        pub(crate) label_match_statement: std::option::Option<crate::model::LabelMatchStatement>,
        pub(crate) regex_match_statement: std::option::Option<crate::model::RegexMatchStatement>,
    }
    impl Builder {
        /// <p>A rule statement that defines a string match search for WAF to apply to web requests. The byte match statement provides the bytes to search for, the location in requests that you want WAF to search, and other settings. The bytes to search for are typically a string that corresponds with ASCII characters. In the WAF console and the developer guide, this is refered to as a string match statement.</p>
        pub fn byte_match_statement(mut self, input: crate::model::ByteMatchStatement) -> Self {
            self.byte_match_statement = Some(input);
            self
        }
        /// <p>A rule statement that defines a string match search for WAF to apply to web requests. The byte match statement provides the bytes to search for, the location in requests that you want WAF to search, and other settings. The bytes to search for are typically a string that corresponds with ASCII characters. In the WAF console and the developer guide, this is refered to as a string match statement.</p>
        pub fn set_byte_match_statement(
            mut self,
            input: std::option::Option<crate::model::ByteMatchStatement>,
        ) -> Self {
            self.byte_match_statement = input;
            self
        }
        /// <p>Attackers sometimes insert malicious SQL code into web requests in an effort to extract data from your database. To allow or block web requests that appear to contain malicious SQL code, create one or more SQL injection match conditions. An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want WAF to inspect. Later in the process, when you create a web ACL, you specify whether to allow or block requests that appear to contain malicious SQL code.</p>
        pub fn sqli_match_statement(mut self, input: crate::model::SqliMatchStatement) -> Self {
            self.sqli_match_statement = Some(input);
            self
        }
        /// <p>Attackers sometimes insert malicious SQL code into web requests in an effort to extract data from your database. To allow or block web requests that appear to contain malicious SQL code, create one or more SQL injection match conditions. An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want WAF to inspect. Later in the process, when you create a web ACL, you specify whether to allow or block requests that appear to contain malicious SQL code.</p>
        pub fn set_sqli_match_statement(
            mut self,
            input: std::option::Option<crate::model::SqliMatchStatement>,
        ) -> Self {
            self.sqli_match_statement = input;
            self
        }
        /// <p>A rule statement that defines a cross-site scripting (XSS) match search for WAF to apply to web requests. XSS attacks are those where the attacker uses vulnerabilities in a benign website as a vehicle to inject malicious client-site scripts into other legitimate web browsers. The XSS match statement provides the location in requests that you want WAF to search and text transformations to use on the search area before WAF searches for character sequences that are likely to be malicious strings. </p>
        pub fn xss_match_statement(mut self, input: crate::model::XssMatchStatement) -> Self {
            self.xss_match_statement = Some(input);
            self
        }
        /// <p>A rule statement that defines a cross-site scripting (XSS) match search for WAF to apply to web requests. XSS attacks are those where the attacker uses vulnerabilities in a benign website as a vehicle to inject malicious client-site scripts into other legitimate web browsers. The XSS match statement provides the location in requests that you want WAF to search and text transformations to use on the search area before WAF searches for character sequences that are likely to be malicious strings. </p>
        pub fn set_xss_match_statement(
            mut self,
            input: std::option::Option<crate::model::XssMatchStatement>,
        ) -> Self {
            self.xss_match_statement = input;
            self
        }
        /// <p>A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (&gt;) or less than (&lt;). For example, you can use a size constraint statement to look for query strings that are longer than 100 bytes. </p>
        /// <p>If you configure WAF to inspect the request body, WAF inspects only the first 8192 bytes (8 KB). If the request body for your web requests never exceeds 8192 bytes, you can create a size constraint condition and block requests that have a request body greater than 8192 bytes.</p>
        /// <p>If you choose URI for the value of Part of the request to filter on, the slash (/) in the URI counts as one character. For example, the URI <code>/logo.jpg</code> is nine characters long.</p>
        pub fn size_constraint_statement(
            mut self,
            input: crate::model::SizeConstraintStatement,
        ) -> Self {
            self.size_constraint_statement = Some(input);
            self
        }
        /// <p>A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (&gt;) or less than (&lt;). For example, you can use a size constraint statement to look for query strings that are longer than 100 bytes. </p>
        /// <p>If you configure WAF to inspect the request body, WAF inspects only the first 8192 bytes (8 KB). If the request body for your web requests never exceeds 8192 bytes, you can create a size constraint condition and block requests that have a request body greater than 8192 bytes.</p>
        /// <p>If you choose URI for the value of Part of the request to filter on, the slash (/) in the URI counts as one character. For example, the URI <code>/logo.jpg</code> is nine characters long.</p>
        pub fn set_size_constraint_statement(
            mut self,
            input: std::option::Option<crate::model::SizeConstraintStatement>,
        ) -> Self {
            self.size_constraint_statement = input;
            self
        }
        /// <p>A rule statement used to identify web requests based on country of origin. </p>
        pub fn geo_match_statement(mut self, input: crate::model::GeoMatchStatement) -> Self {
            self.geo_match_statement = Some(input);
            self
        }
        /// <p>A rule statement used to identify web requests based on country of origin. </p>
        pub fn set_geo_match_statement(
            mut self,
            input: std::option::Option<crate::model::GeoMatchStatement>,
        ) -> Self {
            self.geo_match_statement = input;
            self
        }
        /// <p>A rule statement used to run the rules that are defined in a <code>RuleGroup</code>. To use this, create a rule group with your rules, then provide the ARN of the rule group in this statement.</p>
        /// <p>You cannot nest a <code>RuleGroupReferenceStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. You can only use a rule group reference statement at the top level inside a web ACL. </p>
        pub fn rule_group_reference_statement(
            mut self,
            input: crate::model::RuleGroupReferenceStatement,
        ) -> Self {
            self.rule_group_reference_statement = Some(input);
            self
        }
        /// <p>A rule statement used to run the rules that are defined in a <code>RuleGroup</code>. To use this, create a rule group with your rules, then provide the ARN of the rule group in this statement.</p>
        /// <p>You cannot nest a <code>RuleGroupReferenceStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. You can only use a rule group reference statement at the top level inside a web ACL. </p>
        pub fn set_rule_group_reference_statement(
            mut self,
            input: std::option::Option<crate::model::RuleGroupReferenceStatement>,
        ) -> Self {
            self.rule_group_reference_statement = input;
            self
        }
        /// <p>A rule statement used to detect web requests coming from particular IP addresses or address ranges. To use this, create an <code>IPSet</code> that specifies the addresses you want to detect, then use the ARN of that set in this statement. To create an IP set, see <code>CreateIPSet</code>.</p>
        /// <p>Each IP set rule statement references an IP set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, WAF automatically updates all rules that reference it.</p>
        pub fn ip_set_reference_statement(
            mut self,
            input: crate::model::IpSetReferenceStatement,
        ) -> Self {
            self.ip_set_reference_statement = Some(input);
            self
        }
        /// <p>A rule statement used to detect web requests coming from particular IP addresses or address ranges. To use this, create an <code>IPSet</code> that specifies the addresses you want to detect, then use the ARN of that set in this statement. To create an IP set, see <code>CreateIPSet</code>.</p>
        /// <p>Each IP set rule statement references an IP set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, WAF automatically updates all rules that reference it.</p>
        pub fn set_ip_set_reference_statement(
            mut self,
            input: std::option::Option<crate::model::IpSetReferenceStatement>,
        ) -> Self {
            self.ip_set_reference_statement = input;
            self
        }
        /// <p>A rule statement used to search web request components for matches with regular expressions. To use this, create a <code>RegexPatternSet</code> that specifies the expressions that you want to detect, then use the ARN of that set in this statement. A web request matches the pattern set rule statement if the request component matches any of the patterns in the set. To create a regex pattern set, see <code>CreateRegexPatternSet</code>.</p>
        /// <p>Each regex pattern set rule statement references a regex pattern set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, WAF automatically updates all rules that reference it.</p>
        pub fn regex_pattern_set_reference_statement(
            mut self,
            input: crate::model::RegexPatternSetReferenceStatement,
        ) -> Self {
            self.regex_pattern_set_reference_statement = Some(input);
            self
        }
        /// <p>A rule statement used to search web request components for matches with regular expressions. To use this, create a <code>RegexPatternSet</code> that specifies the expressions that you want to detect, then use the ARN of that set in this statement. A web request matches the pattern set rule statement if the request component matches any of the patterns in the set. To create a regex pattern set, see <code>CreateRegexPatternSet</code>.</p>
        /// <p>Each regex pattern set rule statement references a regex pattern set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, WAF automatically updates all rules that reference it.</p>
        pub fn set_regex_pattern_set_reference_statement(
            mut self,
            input: std::option::Option<crate::model::RegexPatternSetReferenceStatement>,
        ) -> Self {
            self.regex_pattern_set_reference_statement = input;
            self
        }
        /// <p>A rate-based rule tracks the rate of requests for each originating IP address, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any 5-minute time span. You can use this to put a temporary block on requests from an IP address that is sending excessive requests. </p>
        /// <p>WAF tracks and manages web requests separately for each instance of a rate-based rule that you use. For example, if you provide the same rate-based rule settings in two web ACLs, each of the two rule statements represents a separate instance of the rate-based rule and gets its own tracking and management by WAF. If you define a rate-based rule inside a rule group, and then use that rule group in multiple places, each use creates a separate instance of the rate-based rule that gets its own tracking and management by WAF. </p>
        /// <p>When the rule action triggers, WAF blocks additional requests from the IP address until the request rate falls below the limit.</p>
        /// <p>You can optionally nest another statement inside the rate-based statement, to narrow the scope of the rule so that it only counts requests that match the nested statement. For example, based on recent requests that you have seen from an attacker, you might create a rate-based rule with a nested AND rule statement that contains the following nested statements:</p>
        /// <ul>
        /// <li> <p>An IP match statement with an IP set that specified the address 192.0.2.44.</p> </li>
        /// <li> <p>A string match statement that searches in the User-Agent header for the string BadBot.</p> </li>
        /// </ul>
        /// <p>In this rate-based rule, you also define a rate limit. For this example, the rate limit is 1,000. Requests that meet both of the conditions in the statements are counted. If the count exceeds 1,000 requests per five minutes, the rule action triggers. Requests that do not meet both conditions are not counted towards the rate limit and are not affected by this rule.</p>
        /// <p>You cannot nest a <code>RateBasedStatement</code> inside another statement, for example inside a <code>NotStatement</code> or <code>OrStatement</code>. You can define a <code>RateBasedStatement</code> inside a web ACL and inside a rule group. </p>
        pub fn rate_based_statement(mut self, input: crate::model::RateBasedStatement) -> Self {
            self.rate_based_statement = Some(input);
            self
        }
        /// <p>A rate-based rule tracks the rate of requests for each originating IP address, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any 5-minute time span. You can use this to put a temporary block on requests from an IP address that is sending excessive requests. </p>
        /// <p>WAF tracks and manages web requests separately for each instance of a rate-based rule that you use. For example, if you provide the same rate-based rule settings in two web ACLs, each of the two rule statements represents a separate instance of the rate-based rule and gets its own tracking and management by WAF. If you define a rate-based rule inside a rule group, and then use that rule group in multiple places, each use creates a separate instance of the rate-based rule that gets its own tracking and management by WAF. </p>
        /// <p>When the rule action triggers, WAF blocks additional requests from the IP address until the request rate falls below the limit.</p>
        /// <p>You can optionally nest another statement inside the rate-based statement, to narrow the scope of the rule so that it only counts requests that match the nested statement. For example, based on recent requests that you have seen from an attacker, you might create a rate-based rule with a nested AND rule statement that contains the following nested statements:</p>
        /// <ul>
        /// <li> <p>An IP match statement with an IP set that specified the address 192.0.2.44.</p> </li>
        /// <li> <p>A string match statement that searches in the User-Agent header for the string BadBot.</p> </li>
        /// </ul>
        /// <p>In this rate-based rule, you also define a rate limit. For this example, the rate limit is 1,000. Requests that meet both of the conditions in the statements are counted. If the count exceeds 1,000 requests per five minutes, the rule action triggers. Requests that do not meet both conditions are not counted towards the rate limit and are not affected by this rule.</p>
        /// <p>You cannot nest a <code>RateBasedStatement</code> inside another statement, for example inside a <code>NotStatement</code> or <code>OrStatement</code>. You can define a <code>RateBasedStatement</code> inside a web ACL and inside a rule group. </p>
        pub fn set_rate_based_statement(
            mut self,
            input: std::option::Option<crate::model::RateBasedStatement>,
        ) -> Self {
            self.rate_based_statement = input;
            self
        }
        /// <p>A logical rule statement used to combine other rule statements with AND logic. You provide more than one <code>Statement</code> within the <code>AndStatement</code>. </p>
        pub fn and_statement(mut self, input: crate::model::AndStatement) -> Self {
            self.and_statement = Some(input);
            self
        }
        /// <p>A logical rule statement used to combine other rule statements with AND logic. You provide more than one <code>Statement</code> within the <code>AndStatement</code>. </p>
        pub fn set_and_statement(
            mut self,
            input: std::option::Option<crate::model::AndStatement>,
        ) -> Self {
            self.and_statement = input;
            self
        }
        /// <p>A logical rule statement used to combine other rule statements with OR logic. You provide more than one <code>Statement</code> within the <code>OrStatement</code>. </p>
        pub fn or_statement(mut self, input: crate::model::OrStatement) -> Self {
            self.or_statement = Some(input);
            self
        }
        /// <p>A logical rule statement used to combine other rule statements with OR logic. You provide more than one <code>Statement</code> within the <code>OrStatement</code>. </p>
        pub fn set_or_statement(
            mut self,
            input: std::option::Option<crate::model::OrStatement>,
        ) -> Self {
            self.or_statement = input;
            self
        }
        /// <p>A logical rule statement used to negate the results of another rule statement. You provide one <code>Statement</code> within the <code>NotStatement</code>.</p>
        pub fn not_statement(mut self, input: crate::model::NotStatement) -> Self {
            self.not_statement = Some(input);
            self
        }
        /// <p>A logical rule statement used to negate the results of another rule statement. You provide one <code>Statement</code> within the <code>NotStatement</code>.</p>
        pub fn set_not_statement(
            mut self,
            input: std::option::Option<crate::model::NotStatement>,
        ) -> Self {
            self.not_statement = input;
            self
        }
        /// <p>A rule statement used to run the rules that are defined in a managed rule group. To use this, provide the vendor name and the name of the rule group in this statement. You can retrieve the required names by calling <code>ListAvailableManagedRuleGroups</code>.</p>
        /// <p>You cannot nest a <code>ManagedRuleGroupStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. It can only be referenced as a top-level statement within a rule.</p>
        pub fn managed_rule_group_statement(
            mut self,
            input: crate::model::ManagedRuleGroupStatement,
        ) -> Self {
            self.managed_rule_group_statement = Some(input);
            self
        }
        /// <p>A rule statement used to run the rules that are defined in a managed rule group. To use this, provide the vendor name and the name of the rule group in this statement. You can retrieve the required names by calling <code>ListAvailableManagedRuleGroups</code>.</p>
        /// <p>You cannot nest a <code>ManagedRuleGroupStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. It can only be referenced as a top-level statement within a rule.</p>
        pub fn set_managed_rule_group_statement(
            mut self,
            input: std::option::Option<crate::model::ManagedRuleGroupStatement>,
        ) -> Self {
            self.managed_rule_group_statement = input;
            self
        }
        /// <p>A rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. </p>
        /// <p>The label match statement provides the label or namespace string to search for. The label string can represent a part or all of the fully qualified label name that had been added to the web request. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. If you do not provide the fully qualified name in your label match string, WAF performs the search for labels that were added in the same context as the label match statement. </p>
        pub fn label_match_statement(mut self, input: crate::model::LabelMatchStatement) -> Self {
            self.label_match_statement = Some(input);
            self
        }
        /// <p>A rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. </p>
        /// <p>The label match statement provides the label or namespace string to search for. The label string can represent a part or all of the fully qualified label name that had been added to the web request. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. If you do not provide the fully qualified name in your label match string, WAF performs the search for labels that were added in the same context as the label match statement. </p>
        pub fn set_label_match_statement(
            mut self,
            input: std::option::Option<crate::model::LabelMatchStatement>,
        ) -> Self {
            self.label_match_statement = input;
            self
        }
        /// <p>A rule statement used to search web request components for a match against a single regular expression. </p>
        pub fn regex_match_statement(mut self, input: crate::model::RegexMatchStatement) -> Self {
            self.regex_match_statement = Some(input);
            self
        }
        /// <p>A rule statement used to search web request components for a match against a single regular expression. </p>
        pub fn set_regex_match_statement(
            mut self,
            input: std::option::Option<crate::model::RegexMatchStatement>,
        ) -> Self {
            self.regex_match_statement = input;
            self
        }
        /// Consumes the builder and constructs a [`Statement`](crate::model::Statement)
        pub fn build(self) -> crate::model::Statement {
            crate::model::Statement {
                byte_match_statement: self.byte_match_statement,
                sqli_match_statement: self.sqli_match_statement,
                xss_match_statement: self.xss_match_statement,
                size_constraint_statement: self.size_constraint_statement,
                geo_match_statement: self.geo_match_statement,
                rule_group_reference_statement: self.rule_group_reference_statement,
                ip_set_reference_statement: self.ip_set_reference_statement,
                regex_pattern_set_reference_statement: self.regex_pattern_set_reference_statement,
                rate_based_statement: self.rate_based_statement,
                and_statement: self.and_statement,
                or_statement: self.or_statement,
                not_statement: self.not_statement,
                managed_rule_group_statement: self.managed_rule_group_statement,
                label_match_statement: self.label_match_statement,
                regex_match_statement: self.regex_match_statement,
            }
        }
    }
}
impl Statement {
    /// Creates a new builder-style object to manufacture [`Statement`](crate::model::Statement)
    pub fn builder() -> crate::model::statement::Builder {
        crate::model::statement::Builder::default()
    }
}

/// <p>A rule statement used to search web request components for a match against a single regular expression. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegexMatchStatement {
    /// <p>The string representing the regular expression.</p>
    pub regex_string: std::option::Option<std::string::String>,
    /// <p>The part of a web request that you want WAF to inspect. For more information, see <code>FieldToMatch</code>. </p>
    pub field_to_match: std::option::Option<crate::model::FieldToMatch>,
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, WAF performs all transformations on the content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
    pub text_transformations: std::option::Option<std::vec::Vec<crate::model::TextTransformation>>,
}
impl RegexMatchStatement {
    /// <p>The string representing the regular expression.</p>
    pub fn regex_string(&self) -> std::option::Option<&str> {
        self.regex_string.as_deref()
    }
    /// <p>The part of a web request that you want WAF to inspect. For more information, see <code>FieldToMatch</code>. </p>
    pub fn field_to_match(&self) -> std::option::Option<&crate::model::FieldToMatch> {
        self.field_to_match.as_ref()
    }
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, WAF performs all transformations on the content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
    pub fn text_transformations(&self) -> std::option::Option<&[crate::model::TextTransformation]> {
        self.text_transformations.as_deref()
    }
}
impl std::fmt::Debug for RegexMatchStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegexMatchStatement");
        formatter.field("regex_string", &self.regex_string);
        formatter.field("field_to_match", &self.field_to_match);
        formatter.field("text_transformations", &self.text_transformations);
        formatter.finish()
    }
}
/// See [`RegexMatchStatement`](crate::model::RegexMatchStatement)
pub mod regex_match_statement {
    /// A builder for [`RegexMatchStatement`](crate::model::RegexMatchStatement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) regex_string: std::option::Option<std::string::String>,
        pub(crate) field_to_match: std::option::Option<crate::model::FieldToMatch>,
        pub(crate) text_transformations:
            std::option::Option<std::vec::Vec<crate::model::TextTransformation>>,
    }
    impl Builder {
        /// <p>The string representing the regular expression.</p>
        pub fn regex_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.regex_string = Some(input.into());
            self
        }
        /// <p>The string representing the regular expression.</p>
        pub fn set_regex_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.regex_string = input;
            self
        }
        /// <p>The part of a web request that you want WAF to inspect. For more information, see <code>FieldToMatch</code>. </p>
        pub fn field_to_match(mut self, input: crate::model::FieldToMatch) -> Self {
            self.field_to_match = Some(input);
            self
        }
        /// <p>The part of a web request that you want WAF to inspect. For more information, see <code>FieldToMatch</code>. </p>
        pub fn set_field_to_match(
            mut self,
            input: std::option::Option<crate::model::FieldToMatch>,
        ) -> Self {
            self.field_to_match = input;
            self
        }
        /// Appends an item to `text_transformations`.
        ///
        /// To override the contents of this collection use [`set_text_transformations`](Self::set_text_transformations).
        ///
        /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, WAF performs all transformations on the content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
        pub fn text_transformations(mut self, input: crate::model::TextTransformation) -> Self {
            let mut v = self.text_transformations.unwrap_or_default();
            v.push(input);
            self.text_transformations = Some(v);
            self
        }
        /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, WAF performs all transformations on the content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
        pub fn set_text_transformations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TextTransformation>>,
        ) -> Self {
            self.text_transformations = input;
            self
        }
        /// Consumes the builder and constructs a [`RegexMatchStatement`](crate::model::RegexMatchStatement)
        pub fn build(self) -> crate::model::RegexMatchStatement {
            crate::model::RegexMatchStatement {
                regex_string: self.regex_string,
                field_to_match: self.field_to_match,
                text_transformations: self.text_transformations,
            }
        }
    }
}
impl RegexMatchStatement {
    /// Creates a new builder-style object to manufacture [`RegexMatchStatement`](crate::model::RegexMatchStatement)
    pub fn builder() -> crate::model::regex_match_statement::Builder {
        crate::model::regex_match_statement::Builder::default()
    }
}

/// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TextTransformation {
    /// <p>Sets the relative processing order for multiple transformations that are defined for a rule statement. WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content. The priorities don't need to be consecutive, but they must all be different. </p>
    pub priority: i32,
    /// <p>You can specify the following transformation types:</p>
    /// <p> <b>BASE64_DECODE</b> - Decode a <code>Base64</code>-encoded string.</p>
    /// <p> <b>BASE64_DECODE_EXT</b> - Decode a <code>Base64</code>-encoded string, but use a forgiving implementation that ignores characters that aren't valid.</p>
    /// <p> <b>CMD_LINE</b> - Command-line transformations. These are helpful in reducing effectiveness of attackers who inject an operating system command-line command and use unusual formatting to disguise some or all of the command. </p>
    /// <ul>
    /// <li> <p>Delete the following characters: <code>\ " ' ^</code> </p> </li>
    /// <li> <p>Delete spaces before the following characters: <code>/ (</code> </p> </li>
    /// <li> <p>Replace the following characters with a space: <code>, ;</code> </p> </li>
    /// <li> <p>Replace multiple spaces with one space</p> </li>
    /// <li> <p>Convert uppercase letters (A-Z) to lowercase (a-z)</p> </li>
    /// </ul>
    /// <p> <b>COMPRESS_WHITE_SPACE</b> - Replace these characters with a space character (decimal 32): </p>
    /// <ul>
    /// <li> <p> <code>\f</code>, formfeed, decimal 12</p> </li>
    /// <li> <p> <code>\t</code>, tab, decimal 9</p> </li>
    /// <li> <p> <code>\n</code>, newline, decimal 10</p> </li>
    /// <li> <p> <code>\r</code>, carriage return, decimal 13</p> </li>
    /// <li> <p> <code>\v</code>, vertical tab, decimal 11</p> </li>
    /// <li> <p>Non-breaking space, decimal 160</p> </li>
    /// </ul>
    /// <p> <code>COMPRESS_WHITE_SPACE</code> also replaces multiple spaces with one space.</p>
    /// <p> <b>CSS_DECODE</b> - Decode characters that were encoded using CSS 2.x escape rules <code>syndata.html#characters</code>. This function uses up to two bytes in the decoding process, so it can help to uncover ASCII characters that were encoded using CSS encoding that wouldn’t typically be encoded. It's also useful in countering evasion, which is a combination of a backslash and non-hexadecimal characters. For example, <code>ja\vascript</code> for javascript. </p>
    /// <p> <b>ESCAPE_SEQ_DECODE</b> - Decode the following ANSI C escape sequences: <code>\a</code>, <code>\b</code>, <code>\f</code>, <code>\n</code>, <code>\r</code>, <code>\t</code>, <code>\v</code>, <code>\\</code>, <code>\?</code>, <code>\'</code>, <code>\"</code>, <code>\xHH</code> (hexadecimal), <code>\0OOO</code> (octal). Encodings that aren't valid remain in the output. </p>
    /// <p> <b>HEX_DECODE</b> - Decode a string of hexadecimal characters into a binary.</p>
    /// <p> <b>HTML_ENTITY_DECODE</b> - Replace HTML-encoded characters with unencoded characters. <code>HTML_ENTITY_DECODE</code> performs these operations: </p>
    /// <ul>
    /// <li> <p>Replaces <code>(ampersand)quot;</code> with <code>"</code> </p> </li>
    /// <li> <p>Replaces <code>(ampersand)nbsp;</code> with a non-breaking space, decimal 160</p> </li>
    /// <li> <p>Replaces <code>(ampersand)lt;</code> with a "less than" symbol</p> </li>
    /// <li> <p>Replaces <code>(ampersand)gt;</code> with <code>&gt;</code> </p> </li>
    /// <li> <p>Replaces characters that are represented in hexadecimal format, <code>(ampersand)#xhhhh;</code>, with the corresponding characters</p> </li>
    /// <li> <p>Replaces characters that are represented in decimal format, <code>(ampersand)#nnnn;</code>, with the corresponding characters</p> </li>
    /// </ul>
    /// <p> <b>JS_DECODE</b> - Decode JavaScript escape sequences. If a <code>\</code> <code>u</code> <code>HHHH</code> code is in the full-width ASCII code range of <code>FF01-FF5E</code>, then the higher byte is used to detect and adjust the lower byte. If not, only the lower byte is used and the higher byte is zeroed, causing a possible loss of information. </p>
    /// <p> <b>LOWERCASE</b> - Convert uppercase letters (A-Z) to lowercase (a-z). </p>
    /// <p> <b>MD5</b> - Calculate an MD5 hash from the data in the input. The computed hash is in a raw binary form. </p>
    /// <p> <b>NONE</b> - Specify <code>NONE</code> if you don't want any text transformations. </p>
    /// <p> <b>NORMALIZE_PATH</b> - Remove multiple slashes, directory self-references, and directory back-references that are not at the beginning of the input from an input string. </p>
    /// <p> <b>NORMALIZE_PATH_WIN</b> - This is the same as <code>NORMALIZE_PATH</code>, but first converts backslash characters to forward slashes. </p>
    /// <p> <b>REMOVE_NULLS</b> - Remove all <code>NULL</code> bytes from the input. </p>
    /// <p> <b>REPLACE_COMMENTS</b> - Replace each occurrence of a C-style comment (<code>/* ... */</code>) with a single space. Multiple consecutive occurrences are not compressed. Unterminated comments are also replaced with a space (ASCII 0x20). However, a standalone termination of a comment (<code>*/</code>) is not acted upon. </p>
    /// <p> <b>REPLACE_NULLS</b> - Replace NULL bytes in the input with space characters (ASCII <code>0x20</code>). </p>
    /// <p> <b>SQL_HEX_DECODE</b> - Decode SQL hex data. Example (<code>0x414243</code>) will be decoded to (<code>ABC</code>).</p>
    /// <p> <b>URL_DECODE</b> - Decode a URL-encoded value. </p>
    /// <p> <b>URL_DECODE_UNI</b> - Like <code>URL_DECODE</code>, but with support for Microsoft-specific <code>%u</code> encoding. If the code is in the full-width ASCII code range of <code>FF01-FF5E</code>, the higher byte is used to detect and adjust the lower byte. Otherwise, only the lower byte is used and the higher byte is zeroed. </p>
    /// <p> <b>UTF8_TO_UNICODE</b> - Convert all UTF-8 character sequences to Unicode. This helps input normalization, and minimizing false-positives and false-negatives for non-English languages.</p>
    pub r#type: std::option::Option<crate::model::TextTransformationType>,
}
impl TextTransformation {
    /// <p>Sets the relative processing order for multiple transformations that are defined for a rule statement. WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content. The priorities don't need to be consecutive, but they must all be different. </p>
    pub fn priority(&self) -> i32 {
        self.priority
    }
    /// <p>You can specify the following transformation types:</p>
    /// <p> <b>BASE64_DECODE</b> - Decode a <code>Base64</code>-encoded string.</p>
    /// <p> <b>BASE64_DECODE_EXT</b> - Decode a <code>Base64</code>-encoded string, but use a forgiving implementation that ignores characters that aren't valid.</p>
    /// <p> <b>CMD_LINE</b> - Command-line transformations. These are helpful in reducing effectiveness of attackers who inject an operating system command-line command and use unusual formatting to disguise some or all of the command. </p>
    /// <ul>
    /// <li> <p>Delete the following characters: <code>\ " ' ^</code> </p> </li>
    /// <li> <p>Delete spaces before the following characters: <code>/ (</code> </p> </li>
    /// <li> <p>Replace the following characters with a space: <code>, ;</code> </p> </li>
    /// <li> <p>Replace multiple spaces with one space</p> </li>
    /// <li> <p>Convert uppercase letters (A-Z) to lowercase (a-z)</p> </li>
    /// </ul>
    /// <p> <b>COMPRESS_WHITE_SPACE</b> - Replace these characters with a space character (decimal 32): </p>
    /// <ul>
    /// <li> <p> <code>\f</code>, formfeed, decimal 12</p> </li>
    /// <li> <p> <code>\t</code>, tab, decimal 9</p> </li>
    /// <li> <p> <code>\n</code>, newline, decimal 10</p> </li>
    /// <li> <p> <code>\r</code>, carriage return, decimal 13</p> </li>
    /// <li> <p> <code>\v</code>, vertical tab, decimal 11</p> </li>
    /// <li> <p>Non-breaking space, decimal 160</p> </li>
    /// </ul>
    /// <p> <code>COMPRESS_WHITE_SPACE</code> also replaces multiple spaces with one space.</p>
    /// <p> <b>CSS_DECODE</b> - Decode characters that were encoded using CSS 2.x escape rules <code>syndata.html#characters</code>. This function uses up to two bytes in the decoding process, so it can help to uncover ASCII characters that were encoded using CSS encoding that wouldn’t typically be encoded. It's also useful in countering evasion, which is a combination of a backslash and non-hexadecimal characters. For example, <code>ja\vascript</code> for javascript. </p>
    /// <p> <b>ESCAPE_SEQ_DECODE</b> - Decode the following ANSI C escape sequences: <code>\a</code>, <code>\b</code>, <code>\f</code>, <code>\n</code>, <code>\r</code>, <code>\t</code>, <code>\v</code>, <code>\\</code>, <code>\?</code>, <code>\'</code>, <code>\"</code>, <code>\xHH</code> (hexadecimal), <code>\0OOO</code> (octal). Encodings that aren't valid remain in the output. </p>
    /// <p> <b>HEX_DECODE</b> - Decode a string of hexadecimal characters into a binary.</p>
    /// <p> <b>HTML_ENTITY_DECODE</b> - Replace HTML-encoded characters with unencoded characters. <code>HTML_ENTITY_DECODE</code> performs these operations: </p>
    /// <ul>
    /// <li> <p>Replaces <code>(ampersand)quot;</code> with <code>"</code> </p> </li>
    /// <li> <p>Replaces <code>(ampersand)nbsp;</code> with a non-breaking space, decimal 160</p> </li>
    /// <li> <p>Replaces <code>(ampersand)lt;</code> with a "less than" symbol</p> </li>
    /// <li> <p>Replaces <code>(ampersand)gt;</code> with <code>&gt;</code> </p> </li>
    /// <li> <p>Replaces characters that are represented in hexadecimal format, <code>(ampersand)#xhhhh;</code>, with the corresponding characters</p> </li>
    /// <li> <p>Replaces characters that are represented in decimal format, <code>(ampersand)#nnnn;</code>, with the corresponding characters</p> </li>
    /// </ul>
    /// <p> <b>JS_DECODE</b> - Decode JavaScript escape sequences. If a <code>\</code> <code>u</code> <code>HHHH</code> code is in the full-width ASCII code range of <code>FF01-FF5E</code>, then the higher byte is used to detect and adjust the lower byte. If not, only the lower byte is used and the higher byte is zeroed, causing a possible loss of information. </p>
    /// <p> <b>LOWERCASE</b> - Convert uppercase letters (A-Z) to lowercase (a-z). </p>
    /// <p> <b>MD5</b> - Calculate an MD5 hash from the data in the input. The computed hash is in a raw binary form. </p>
    /// <p> <b>NONE</b> - Specify <code>NONE</code> if you don't want any text transformations. </p>
    /// <p> <b>NORMALIZE_PATH</b> - Remove multiple slashes, directory self-references, and directory back-references that are not at the beginning of the input from an input string. </p>
    /// <p> <b>NORMALIZE_PATH_WIN</b> - This is the same as <code>NORMALIZE_PATH</code>, but first converts backslash characters to forward slashes. </p>
    /// <p> <b>REMOVE_NULLS</b> - Remove all <code>NULL</code> bytes from the input. </p>
    /// <p> <b>REPLACE_COMMENTS</b> - Replace each occurrence of a C-style comment (<code>/* ... */</code>) with a single space. Multiple consecutive occurrences are not compressed. Unterminated comments are also replaced with a space (ASCII 0x20). However, a standalone termination of a comment (<code>*/</code>) is not acted upon. </p>
    /// <p> <b>REPLACE_NULLS</b> - Replace NULL bytes in the input with space characters (ASCII <code>0x20</code>). </p>
    /// <p> <b>SQL_HEX_DECODE</b> - Decode SQL hex data. Example (<code>0x414243</code>) will be decoded to (<code>ABC</code>).</p>
    /// <p> <b>URL_DECODE</b> - Decode a URL-encoded value. </p>
    /// <p> <b>URL_DECODE_UNI</b> - Like <code>URL_DECODE</code>, but with support for Microsoft-specific <code>%u</code> encoding. If the code is in the full-width ASCII code range of <code>FF01-FF5E</code>, the higher byte is used to detect and adjust the lower byte. Otherwise, only the lower byte is used and the higher byte is zeroed. </p>
    /// <p> <b>UTF8_TO_UNICODE</b> - Convert all UTF-8 character sequences to Unicode. This helps input normalization, and minimizing false-positives and false-negatives for non-English languages.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::TextTransformationType> {
        self.r#type.as_ref()
    }
}
impl std::fmt::Debug for TextTransformation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TextTransformation");
        formatter.field("priority", &self.priority);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`TextTransformation`](crate::model::TextTransformation)
pub mod text_transformation {
    /// A builder for [`TextTransformation`](crate::model::TextTransformation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) priority: std::option::Option<i32>,
        pub(crate) r#type: std::option::Option<crate::model::TextTransformationType>,
    }
    impl Builder {
        /// <p>Sets the relative processing order for multiple transformations that are defined for a rule statement. WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content. The priorities don't need to be consecutive, but they must all be different. </p>
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        /// <p>Sets the relative processing order for multiple transformations that are defined for a rule statement. WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content. The priorities don't need to be consecutive, but they must all be different. </p>
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        /// <p>You can specify the following transformation types:</p>
        /// <p> <b>BASE64_DECODE</b> - Decode a <code>Base64</code>-encoded string.</p>
        /// <p> <b>BASE64_DECODE_EXT</b> - Decode a <code>Base64</code>-encoded string, but use a forgiving implementation that ignores characters that aren't valid.</p>
        /// <p> <b>CMD_LINE</b> - Command-line transformations. These are helpful in reducing effectiveness of attackers who inject an operating system command-line command and use unusual formatting to disguise some or all of the command. </p>
        /// <ul>
        /// <li> <p>Delete the following characters: <code>\ " ' ^</code> </p> </li>
        /// <li> <p>Delete spaces before the following characters: <code>/ (</code> </p> </li>
        /// <li> <p>Replace the following characters with a space: <code>, ;</code> </p> </li>
        /// <li> <p>Replace multiple spaces with one space</p> </li>
        /// <li> <p>Convert uppercase letters (A-Z) to lowercase (a-z)</p> </li>
        /// </ul>
        /// <p> <b>COMPRESS_WHITE_SPACE</b> - Replace these characters with a space character (decimal 32): </p>
        /// <ul>
        /// <li> <p> <code>\f</code>, formfeed, decimal 12</p> </li>
        /// <li> <p> <code>\t</code>, tab, decimal 9</p> </li>
        /// <li> <p> <code>\n</code>, newline, decimal 10</p> </li>
        /// <li> <p> <code>\r</code>, carriage return, decimal 13</p> </li>
        /// <li> <p> <code>\v</code>, vertical tab, decimal 11</p> </li>
        /// <li> <p>Non-breaking space, decimal 160</p> </li>
        /// </ul>
        /// <p> <code>COMPRESS_WHITE_SPACE</code> also replaces multiple spaces with one space.</p>
        /// <p> <b>CSS_DECODE</b> - Decode characters that were encoded using CSS 2.x escape rules <code>syndata.html#characters</code>. This function uses up to two bytes in the decoding process, so it can help to uncover ASCII characters that were encoded using CSS encoding that wouldn’t typically be encoded. It's also useful in countering evasion, which is a combination of a backslash and non-hexadecimal characters. For example, <code>ja\vascript</code> for javascript. </p>
        /// <p> <b>ESCAPE_SEQ_DECODE</b> - Decode the following ANSI C escape sequences: <code>\a</code>, <code>\b</code>, <code>\f</code>, <code>\n</code>, <code>\r</code>, <code>\t</code>, <code>\v</code>, <code>\\</code>, <code>\?</code>, <code>\'</code>, <code>\"</code>, <code>\xHH</code> (hexadecimal), <code>\0OOO</code> (octal). Encodings that aren't valid remain in the output. </p>
        /// <p> <b>HEX_DECODE</b> - Decode a string of hexadecimal characters into a binary.</p>
        /// <p> <b>HTML_ENTITY_DECODE</b> - Replace HTML-encoded characters with unencoded characters. <code>HTML_ENTITY_DECODE</code> performs these operations: </p>
        /// <ul>
        /// <li> <p>Replaces <code>(ampersand)quot;</code> with <code>"</code> </p> </li>
        /// <li> <p>Replaces <code>(ampersand)nbsp;</code> with a non-breaking space, decimal 160</p> </li>
        /// <li> <p>Replaces <code>(ampersand)lt;</code> with a "less than" symbol</p> </li>
        /// <li> <p>Replaces <code>(ampersand)gt;</code> with <code>&gt;</code> </p> </li>
        /// <li> <p>Replaces characters that are represented in hexadecimal format, <code>(ampersand)#xhhhh;</code>, with the corresponding characters</p> </li>
        /// <li> <p>Replaces characters that are represented in decimal format, <code>(ampersand)#nnnn;</code>, with the corresponding characters</p> </li>
        /// </ul>
        /// <p> <b>JS_DECODE</b> - Decode JavaScript escape sequences. If a <code>\</code> <code>u</code> <code>HHHH</code> code is in the full-width ASCII code range of <code>FF01-FF5E</code>, then the higher byte is used to detect and adjust the lower byte. If not, only the lower byte is used and the higher byte is zeroed, causing a possible loss of information. </p>
        /// <p> <b>LOWERCASE</b> - Convert uppercase letters (A-Z) to lowercase (a-z). </p>
        /// <p> <b>MD5</b> - Calculate an MD5 hash from the data in the input. The computed hash is in a raw binary form. </p>
        /// <p> <b>NONE</b> - Specify <code>NONE</code> if you don't want any text transformations. </p>
        /// <p> <b>NORMALIZE_PATH</b> - Remove multiple slashes, directory self-references, and directory back-references that are not at the beginning of the input from an input string. </p>
        /// <p> <b>NORMALIZE_PATH_WIN</b> - This is the same as <code>NORMALIZE_PATH</code>, but first converts backslash characters to forward slashes. </p>
        /// <p> <b>REMOVE_NULLS</b> - Remove all <code>NULL</code> bytes from the input. </p>
        /// <p> <b>REPLACE_COMMENTS</b> - Replace each occurrence of a C-style comment (<code>/* ... */</code>) with a single space. Multiple consecutive occurrences are not compressed. Unterminated comments are also replaced with a space (ASCII 0x20). However, a standalone termination of a comment (<code>*/</code>) is not acted upon. </p>
        /// <p> <b>REPLACE_NULLS</b> - Replace NULL bytes in the input with space characters (ASCII <code>0x20</code>). </p>
        /// <p> <b>SQL_HEX_DECODE</b> - Decode SQL hex data. Example (<code>0x414243</code>) will be decoded to (<code>ABC</code>).</p>
        /// <p> <b>URL_DECODE</b> - Decode a URL-encoded value. </p>
        /// <p> <b>URL_DECODE_UNI</b> - Like <code>URL_DECODE</code>, but with support for Microsoft-specific <code>%u</code> encoding. If the code is in the full-width ASCII code range of <code>FF01-FF5E</code>, the higher byte is used to detect and adjust the lower byte. Otherwise, only the lower byte is used and the higher byte is zeroed. </p>
        /// <p> <b>UTF8_TO_UNICODE</b> - Convert all UTF-8 character sequences to Unicode. This helps input normalization, and minimizing false-positives and false-negatives for non-English languages.</p>
        pub fn r#type(mut self, input: crate::model::TextTransformationType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>You can specify the following transformation types:</p>
        /// <p> <b>BASE64_DECODE</b> - Decode a <code>Base64</code>-encoded string.</p>
        /// <p> <b>BASE64_DECODE_EXT</b> - Decode a <code>Base64</code>-encoded string, but use a forgiving implementation that ignores characters that aren't valid.</p>
        /// <p> <b>CMD_LINE</b> - Command-line transformations. These are helpful in reducing effectiveness of attackers who inject an operating system command-line command and use unusual formatting to disguise some or all of the command. </p>
        /// <ul>
        /// <li> <p>Delete the following characters: <code>\ " ' ^</code> </p> </li>
        /// <li> <p>Delete spaces before the following characters: <code>/ (</code> </p> </li>
        /// <li> <p>Replace the following characters with a space: <code>, ;</code> </p> </li>
        /// <li> <p>Replace multiple spaces with one space</p> </li>
        /// <li> <p>Convert uppercase letters (A-Z) to lowercase (a-z)</p> </li>
        /// </ul>
        /// <p> <b>COMPRESS_WHITE_SPACE</b> - Replace these characters with a space character (decimal 32): </p>
        /// <ul>
        /// <li> <p> <code>\f</code>, formfeed, decimal 12</p> </li>
        /// <li> <p> <code>\t</code>, tab, decimal 9</p> </li>
        /// <li> <p> <code>\n</code>, newline, decimal 10</p> </li>
        /// <li> <p> <code>\r</code>, carriage return, decimal 13</p> </li>
        /// <li> <p> <code>\v</code>, vertical tab, decimal 11</p> </li>
        /// <li> <p>Non-breaking space, decimal 160</p> </li>
        /// </ul>
        /// <p> <code>COMPRESS_WHITE_SPACE</code> also replaces multiple spaces with one space.</p>
        /// <p> <b>CSS_DECODE</b> - Decode characters that were encoded using CSS 2.x escape rules <code>syndata.html#characters</code>. This function uses up to two bytes in the decoding process, so it can help to uncover ASCII characters that were encoded using CSS encoding that wouldn’t typically be encoded. It's also useful in countering evasion, which is a combination of a backslash and non-hexadecimal characters. For example, <code>ja\vascript</code> for javascript. </p>
        /// <p> <b>ESCAPE_SEQ_DECODE</b> - Decode the following ANSI C escape sequences: <code>\a</code>, <code>\b</code>, <code>\f</code>, <code>\n</code>, <code>\r</code>, <code>\t</code>, <code>\v</code>, <code>\\</code>, <code>\?</code>, <code>\'</code>, <code>\"</code>, <code>\xHH</code> (hexadecimal), <code>\0OOO</code> (octal). Encodings that aren't valid remain in the output. </p>
        /// <p> <b>HEX_DECODE</b> - Decode a string of hexadecimal characters into a binary.</p>
        /// <p> <b>HTML_ENTITY_DECODE</b> - Replace HTML-encoded characters with unencoded characters. <code>HTML_ENTITY_DECODE</code> performs these operations: </p>
        /// <ul>
        /// <li> <p>Replaces <code>(ampersand)quot;</code> with <code>"</code> </p> </li>
        /// <li> <p>Replaces <code>(ampersand)nbsp;</code> with a non-breaking space, decimal 160</p> </li>
        /// <li> <p>Replaces <code>(ampersand)lt;</code> with a "less than" symbol</p> </li>
        /// <li> <p>Replaces <code>(ampersand)gt;</code> with <code>&gt;</code> </p> </li>
        /// <li> <p>Replaces characters that are represented in hexadecimal format, <code>(ampersand)#xhhhh;</code>, with the corresponding characters</p> </li>
        /// <li> <p>Replaces characters that are represented in decimal format, <code>(ampersand)#nnnn;</code>, with the corresponding characters</p> </li>
        /// </ul>
        /// <p> <b>JS_DECODE</b> - Decode JavaScript escape sequences. If a <code>\</code> <code>u</code> <code>HHHH</code> code is in the full-width ASCII code range of <code>FF01-FF5E</code>, then the higher byte is used to detect and adjust the lower byte. If not, only the lower byte is used and the higher byte is zeroed, causing a possible loss of information. </p>
        /// <p> <b>LOWERCASE</b> - Convert uppercase letters (A-Z) to lowercase (a-z). </p>
        /// <p> <b>MD5</b> - Calculate an MD5 hash from the data in the input. The computed hash is in a raw binary form. </p>
        /// <p> <b>NONE</b> - Specify <code>NONE</code> if you don't want any text transformations. </p>
        /// <p> <b>NORMALIZE_PATH</b> - Remove multiple slashes, directory self-references, and directory back-references that are not at the beginning of the input from an input string. </p>
        /// <p> <b>NORMALIZE_PATH_WIN</b> - This is the same as <code>NORMALIZE_PATH</code>, but first converts backslash characters to forward slashes. </p>
        /// <p> <b>REMOVE_NULLS</b> - Remove all <code>NULL</code> bytes from the input. </p>
        /// <p> <b>REPLACE_COMMENTS</b> - Replace each occurrence of a C-style comment (<code>/* ... */</code>) with a single space. Multiple consecutive occurrences are not compressed. Unterminated comments are also replaced with a space (ASCII 0x20). However, a standalone termination of a comment (<code>*/</code>) is not acted upon. </p>
        /// <p> <b>REPLACE_NULLS</b> - Replace NULL bytes in the input with space characters (ASCII <code>0x20</code>). </p>
        /// <p> <b>SQL_HEX_DECODE</b> - Decode SQL hex data. Example (<code>0x414243</code>) will be decoded to (<code>ABC</code>).</p>
        /// <p> <b>URL_DECODE</b> - Decode a URL-encoded value. </p>
        /// <p> <b>URL_DECODE_UNI</b> - Like <code>URL_DECODE</code>, but with support for Microsoft-specific <code>%u</code> encoding. If the code is in the full-width ASCII code range of <code>FF01-FF5E</code>, the higher byte is used to detect and adjust the lower byte. Otherwise, only the lower byte is used and the higher byte is zeroed. </p>
        /// <p> <b>UTF8_TO_UNICODE</b> - Convert all UTF-8 character sequences to Unicode. This helps input normalization, and minimizing false-positives and false-negatives for non-English languages.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::TextTransformationType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`TextTransformation`](crate::model::TextTransformation)
        pub fn build(self) -> crate::model::TextTransformation {
            crate::model::TextTransformation {
                priority: self.priority.unwrap_or_default(),
                r#type: self.r#type,
            }
        }
    }
}
impl TextTransformation {
    /// Creates a new builder-style object to manufacture [`TextTransformation`](crate::model::TextTransformation)
    pub fn builder() -> crate::model::text_transformation::Builder {
        crate::model::text_transformation::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TextTransformationType {
    #[allow(missing_docs)] // documentation missing in model
    Base64Decode,
    #[allow(missing_docs)] // documentation missing in model
    Base64DecodeExt,
    #[allow(missing_docs)] // documentation missing in model
    CmdLine,
    #[allow(missing_docs)] // documentation missing in model
    CompressWhiteSpace,
    #[allow(missing_docs)] // documentation missing in model
    CssDecode,
    #[allow(missing_docs)] // documentation missing in model
    EscapeSeqDecode,
    #[allow(missing_docs)] // documentation missing in model
    HexDecode,
    #[allow(missing_docs)] // documentation missing in model
    HtmlEntityDecode,
    #[allow(missing_docs)] // documentation missing in model
    JsDecode,
    #[allow(missing_docs)] // documentation missing in model
    Lowercase,
    #[allow(missing_docs)] // documentation missing in model
    Md5,
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    NormalizePath,
    #[allow(missing_docs)] // documentation missing in model
    NormalizePathWin,
    #[allow(missing_docs)] // documentation missing in model
    RemoveNulls,
    #[allow(missing_docs)] // documentation missing in model
    ReplaceComments,
    #[allow(missing_docs)] // documentation missing in model
    ReplaceNulls,
    #[allow(missing_docs)] // documentation missing in model
    SqlHexDecode,
    #[allow(missing_docs)] // documentation missing in model
    UrlDecode,
    #[allow(missing_docs)] // documentation missing in model
    UrlDecodeUni,
    #[allow(missing_docs)] // documentation missing in model
    Utf8ToUnicode,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TextTransformationType {
    fn from(s: &str) -> Self {
        match s {
            "BASE64_DECODE" => TextTransformationType::Base64Decode,
            "BASE64_DECODE_EXT" => TextTransformationType::Base64DecodeExt,
            "CMD_LINE" => TextTransformationType::CmdLine,
            "COMPRESS_WHITE_SPACE" => TextTransformationType::CompressWhiteSpace,
            "CSS_DECODE" => TextTransformationType::CssDecode,
            "ESCAPE_SEQ_DECODE" => TextTransformationType::EscapeSeqDecode,
            "HEX_DECODE" => TextTransformationType::HexDecode,
            "HTML_ENTITY_DECODE" => TextTransformationType::HtmlEntityDecode,
            "JS_DECODE" => TextTransformationType::JsDecode,
            "LOWERCASE" => TextTransformationType::Lowercase,
            "MD5" => TextTransformationType::Md5,
            "NONE" => TextTransformationType::None,
            "NORMALIZE_PATH" => TextTransformationType::NormalizePath,
            "NORMALIZE_PATH_WIN" => TextTransformationType::NormalizePathWin,
            "REMOVE_NULLS" => TextTransformationType::RemoveNulls,
            "REPLACE_COMMENTS" => TextTransformationType::ReplaceComments,
            "REPLACE_NULLS" => TextTransformationType::ReplaceNulls,
            "SQL_HEX_DECODE" => TextTransformationType::SqlHexDecode,
            "URL_DECODE" => TextTransformationType::UrlDecode,
            "URL_DECODE_UNI" => TextTransformationType::UrlDecodeUni,
            "UTF8_TO_UNICODE" => TextTransformationType::Utf8ToUnicode,
            other => TextTransformationType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TextTransformationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TextTransformationType::from(s))
    }
}
impl TextTransformationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TextTransformationType::Base64Decode => "BASE64_DECODE",
            TextTransformationType::Base64DecodeExt => "BASE64_DECODE_EXT",
            TextTransformationType::CmdLine => "CMD_LINE",
            TextTransformationType::CompressWhiteSpace => "COMPRESS_WHITE_SPACE",
            TextTransformationType::CssDecode => "CSS_DECODE",
            TextTransformationType::EscapeSeqDecode => "ESCAPE_SEQ_DECODE",
            TextTransformationType::HexDecode => "HEX_DECODE",
            TextTransformationType::HtmlEntityDecode => "HTML_ENTITY_DECODE",
            TextTransformationType::JsDecode => "JS_DECODE",
            TextTransformationType::Lowercase => "LOWERCASE",
            TextTransformationType::Md5 => "MD5",
            TextTransformationType::None => "NONE",
            TextTransformationType::NormalizePath => "NORMALIZE_PATH",
            TextTransformationType::NormalizePathWin => "NORMALIZE_PATH_WIN",
            TextTransformationType::RemoveNulls => "REMOVE_NULLS",
            TextTransformationType::ReplaceComments => "REPLACE_COMMENTS",
            TextTransformationType::ReplaceNulls => "REPLACE_NULLS",
            TextTransformationType::SqlHexDecode => "SQL_HEX_DECODE",
            TextTransformationType::UrlDecode => "URL_DECODE",
            TextTransformationType::UrlDecodeUni => "URL_DECODE_UNI",
            TextTransformationType::Utf8ToUnicode => "UTF8_TO_UNICODE",
            TextTransformationType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "BASE64_DECODE",
            "BASE64_DECODE_EXT",
            "CMD_LINE",
            "COMPRESS_WHITE_SPACE",
            "CSS_DECODE",
            "ESCAPE_SEQ_DECODE",
            "HEX_DECODE",
            "HTML_ENTITY_DECODE",
            "JS_DECODE",
            "LOWERCASE",
            "MD5",
            "NONE",
            "NORMALIZE_PATH",
            "NORMALIZE_PATH_WIN",
            "REMOVE_NULLS",
            "REPLACE_COMMENTS",
            "REPLACE_NULLS",
            "SQL_HEX_DECODE",
            "URL_DECODE",
            "URL_DECODE_UNI",
            "UTF8_TO_UNICODE",
        ]
    }
}
impl AsRef<str> for TextTransformationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The part of a web request that you want WAF to inspect. Include the single <code>FieldToMatch</code> type that you want to inspect, with additional specifications as needed, according to the type. You specify a single request component in <code>FieldToMatch</code> for each rule statement that requires it. To inspect more than one component of a web request, create a separate rule statement for each component.</p>
/// <p>JSON specification for a <code>QueryString</code> field to match: </p>
/// <p> <code> "FieldToMatch": { "QueryString": {} }</code> </p>
/// <p>Example JSON for a <code>Method</code> field to match specification:</p>
/// <p> <code> "FieldToMatch": { "Method": { "Name": "DELETE" } }</code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FieldToMatch {
    /// <p>Inspect a single header. Provide the name of the header to inspect, for example, <code>User-Agent</code> or <code>Referer</code>. This setting isn't case sensitive.</p>
    /// <p>Example JSON: <code>"SingleHeader": { "Name": "haystack" }</code> </p>
    pub single_header: std::option::Option<crate::model::SingleHeader>,
    /// <p>Inspect a single query argument. Provide the name of the query argument to inspect, such as <i>UserName</i> or <i>SalesRegion</i>. The name can be up to 30 characters long and isn't case sensitive. </p>
    /// <p>This is used only to indicate the web request component for WAF to inspect, in the <code>FieldToMatch</code> specification. </p>
    /// <p>Example JSON: <code>"SingleQueryArgument": { "Name": "myArgument" }</code> </p>
    pub single_query_argument: std::option::Option<crate::model::SingleQueryArgument>,
    /// <p>Inspect all query arguments. </p>
    pub all_query_arguments: std::option::Option<crate::model::AllQueryArguments>,
    /// <p>Inspect the request URI path. This is the part of a web request that identifies a resource, for example, <code>/images/daily-ad.jpg</code>.</p>
    pub uri_path: std::option::Option<crate::model::UriPath>,
    /// <p>Inspect the query string. This is the part of a URL that appears after a <code>?</code> character, if any.</p>
    pub query_string: std::option::Option<crate::model::QueryString>,
    /// <p>Inspect the request body as plain text. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. </p>
    /// <p>Note that only the first 8 KB (8192 bytes) of the request body are forwarded to WAF for inspection by the underlying host service. If you don't need to inspect more than 8 KB, you can guarantee that you don't allow additional bytes in by combining a statement that inspects the body of the web request, such as <code>ByteMatchStatement</code> or <code>RegexPatternSetReferenceStatement</code>, with a <code>SizeConstraintStatement</code> that enforces an 8 KB size limit on the body of the request. WAF doesn't support inspecting the entire contents of web requests whose bodies exceed the 8 KB limit.</p>
    pub body: std::option::Option<crate::model::Body>,
    /// <p>Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform. </p>
    pub method: std::option::Option<crate::model::Method>,
    /// <p>Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. </p>
    /// <p>Note that only the first 8 KB (8192 bytes) of the request body are forwarded to WAF for inspection by the underlying host service. If you don't need to inspect more than 8 KB, you can guarantee that you don't allow additional bytes in by combining a statement that inspects the body of the web request, such as <code>ByteMatchStatement</code> or <code>RegexPatternSetReferenceStatement</code>, with a <code>SizeConstraintStatement</code> that enforces an 8 KB size limit on the body of the request. WAF doesn't support inspecting the entire contents of web requests whose bodies exceed the 8 KB limit.</p>
    pub json_body: std::option::Option<crate::model::JsonBody>,
}
impl FieldToMatch {
    /// <p>Inspect a single header. Provide the name of the header to inspect, for example, <code>User-Agent</code> or <code>Referer</code>. This setting isn't case sensitive.</p>
    /// <p>Example JSON: <code>"SingleHeader": { "Name": "haystack" }</code> </p>
    pub fn single_header(&self) -> std::option::Option<&crate::model::SingleHeader> {
        self.single_header.as_ref()
    }
    /// <p>Inspect a single query argument. Provide the name of the query argument to inspect, such as <i>UserName</i> or <i>SalesRegion</i>. The name can be up to 30 characters long and isn't case sensitive. </p>
    /// <p>This is used only to indicate the web request component for WAF to inspect, in the <code>FieldToMatch</code> specification. </p>
    /// <p>Example JSON: <code>"SingleQueryArgument": { "Name": "myArgument" }</code> </p>
    pub fn single_query_argument(&self) -> std::option::Option<&crate::model::SingleQueryArgument> {
        self.single_query_argument.as_ref()
    }
    /// <p>Inspect all query arguments. </p>
    pub fn all_query_arguments(&self) -> std::option::Option<&crate::model::AllQueryArguments> {
        self.all_query_arguments.as_ref()
    }
    /// <p>Inspect the request URI path. This is the part of a web request that identifies a resource, for example, <code>/images/daily-ad.jpg</code>.</p>
    pub fn uri_path(&self) -> std::option::Option<&crate::model::UriPath> {
        self.uri_path.as_ref()
    }
    /// <p>Inspect the query string. This is the part of a URL that appears after a <code>?</code> character, if any.</p>
    pub fn query_string(&self) -> std::option::Option<&crate::model::QueryString> {
        self.query_string.as_ref()
    }
    /// <p>Inspect the request body as plain text. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. </p>
    /// <p>Note that only the first 8 KB (8192 bytes) of the request body are forwarded to WAF for inspection by the underlying host service. If you don't need to inspect more than 8 KB, you can guarantee that you don't allow additional bytes in by combining a statement that inspects the body of the web request, such as <code>ByteMatchStatement</code> or <code>RegexPatternSetReferenceStatement</code>, with a <code>SizeConstraintStatement</code> that enforces an 8 KB size limit on the body of the request. WAF doesn't support inspecting the entire contents of web requests whose bodies exceed the 8 KB limit.</p>
    pub fn body(&self) -> std::option::Option<&crate::model::Body> {
        self.body.as_ref()
    }
    /// <p>Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform. </p>
    pub fn method(&self) -> std::option::Option<&crate::model::Method> {
        self.method.as_ref()
    }
    /// <p>Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. </p>
    /// <p>Note that only the first 8 KB (8192 bytes) of the request body are forwarded to WAF for inspection by the underlying host service. If you don't need to inspect more than 8 KB, you can guarantee that you don't allow additional bytes in by combining a statement that inspects the body of the web request, such as <code>ByteMatchStatement</code> or <code>RegexPatternSetReferenceStatement</code>, with a <code>SizeConstraintStatement</code> that enforces an 8 KB size limit on the body of the request. WAF doesn't support inspecting the entire contents of web requests whose bodies exceed the 8 KB limit.</p>
    pub fn json_body(&self) -> std::option::Option<&crate::model::JsonBody> {
        self.json_body.as_ref()
    }
}
impl std::fmt::Debug for FieldToMatch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FieldToMatch");
        formatter.field("single_header", &self.single_header);
        formatter.field("single_query_argument", &self.single_query_argument);
        formatter.field("all_query_arguments", &self.all_query_arguments);
        formatter.field("uri_path", &self.uri_path);
        formatter.field("query_string", &self.query_string);
        formatter.field("body", &self.body);
        formatter.field("method", &self.method);
        formatter.field("json_body", &self.json_body);
        formatter.finish()
    }
}
/// See [`FieldToMatch`](crate::model::FieldToMatch)
pub mod field_to_match {
    /// A builder for [`FieldToMatch`](crate::model::FieldToMatch)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) single_header: std::option::Option<crate::model::SingleHeader>,
        pub(crate) single_query_argument: std::option::Option<crate::model::SingleQueryArgument>,
        pub(crate) all_query_arguments: std::option::Option<crate::model::AllQueryArguments>,
        pub(crate) uri_path: std::option::Option<crate::model::UriPath>,
        pub(crate) query_string: std::option::Option<crate::model::QueryString>,
        pub(crate) body: std::option::Option<crate::model::Body>,
        pub(crate) method: std::option::Option<crate::model::Method>,
        pub(crate) json_body: std::option::Option<crate::model::JsonBody>,
    }
    impl Builder {
        /// <p>Inspect a single header. Provide the name of the header to inspect, for example, <code>User-Agent</code> or <code>Referer</code>. This setting isn't case sensitive.</p>
        /// <p>Example JSON: <code>"SingleHeader": { "Name": "haystack" }</code> </p>
        pub fn single_header(mut self, input: crate::model::SingleHeader) -> Self {
            self.single_header = Some(input);
            self
        }
        /// <p>Inspect a single header. Provide the name of the header to inspect, for example, <code>User-Agent</code> or <code>Referer</code>. This setting isn't case sensitive.</p>
        /// <p>Example JSON: <code>"SingleHeader": { "Name": "haystack" }</code> </p>
        pub fn set_single_header(
            mut self,
            input: std::option::Option<crate::model::SingleHeader>,
        ) -> Self {
            self.single_header = input;
            self
        }
        /// <p>Inspect a single query argument. Provide the name of the query argument to inspect, such as <i>UserName</i> or <i>SalesRegion</i>. The name can be up to 30 characters long and isn't case sensitive. </p>
        /// <p>This is used only to indicate the web request component for WAF to inspect, in the <code>FieldToMatch</code> specification. </p>
        /// <p>Example JSON: <code>"SingleQueryArgument": { "Name": "myArgument" }</code> </p>
        pub fn single_query_argument(mut self, input: crate::model::SingleQueryArgument) -> Self {
            self.single_query_argument = Some(input);
            self
        }
        /// <p>Inspect a single query argument. Provide the name of the query argument to inspect, such as <i>UserName</i> or <i>SalesRegion</i>. The name can be up to 30 characters long and isn't case sensitive. </p>
        /// <p>This is used only to indicate the web request component for WAF to inspect, in the <code>FieldToMatch</code> specification. </p>
        /// <p>Example JSON: <code>"SingleQueryArgument": { "Name": "myArgument" }</code> </p>
        pub fn set_single_query_argument(
            mut self,
            input: std::option::Option<crate::model::SingleQueryArgument>,
        ) -> Self {
            self.single_query_argument = input;
            self
        }
        /// <p>Inspect all query arguments. </p>
        pub fn all_query_arguments(mut self, input: crate::model::AllQueryArguments) -> Self {
            self.all_query_arguments = Some(input);
            self
        }
        /// <p>Inspect all query arguments. </p>
        pub fn set_all_query_arguments(
            mut self,
            input: std::option::Option<crate::model::AllQueryArguments>,
        ) -> Self {
            self.all_query_arguments = input;
            self
        }
        /// <p>Inspect the request URI path. This is the part of a web request that identifies a resource, for example, <code>/images/daily-ad.jpg</code>.</p>
        pub fn uri_path(mut self, input: crate::model::UriPath) -> Self {
            self.uri_path = Some(input);
            self
        }
        /// <p>Inspect the request URI path. This is the part of a web request that identifies a resource, for example, <code>/images/daily-ad.jpg</code>.</p>
        pub fn set_uri_path(mut self, input: std::option::Option<crate::model::UriPath>) -> Self {
            self.uri_path = input;
            self
        }
        /// <p>Inspect the query string. This is the part of a URL that appears after a <code>?</code> character, if any.</p>
        pub fn query_string(mut self, input: crate::model::QueryString) -> Self {
            self.query_string = Some(input);
            self
        }
        /// <p>Inspect the query string. This is the part of a URL that appears after a <code>?</code> character, if any.</p>
        pub fn set_query_string(
            mut self,
            input: std::option::Option<crate::model::QueryString>,
        ) -> Self {
            self.query_string = input;
            self
        }
        /// <p>Inspect the request body as plain text. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. </p>
        /// <p>Note that only the first 8 KB (8192 bytes) of the request body are forwarded to WAF for inspection by the underlying host service. If you don't need to inspect more than 8 KB, you can guarantee that you don't allow additional bytes in by combining a statement that inspects the body of the web request, such as <code>ByteMatchStatement</code> or <code>RegexPatternSetReferenceStatement</code>, with a <code>SizeConstraintStatement</code> that enforces an 8 KB size limit on the body of the request. WAF doesn't support inspecting the entire contents of web requests whose bodies exceed the 8 KB limit.</p>
        pub fn body(mut self, input: crate::model::Body) -> Self {
            self.body = Some(input);
            self
        }
        /// <p>Inspect the request body as plain text. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. </p>
        /// <p>Note that only the first 8 KB (8192 bytes) of the request body are forwarded to WAF for inspection by the underlying host service. If you don't need to inspect more than 8 KB, you can guarantee that you don't allow additional bytes in by combining a statement that inspects the body of the web request, such as <code>ByteMatchStatement</code> or <code>RegexPatternSetReferenceStatement</code>, with a <code>SizeConstraintStatement</code> that enforces an 8 KB size limit on the body of the request. WAF doesn't support inspecting the entire contents of web requests whose bodies exceed the 8 KB limit.</p>
        pub fn set_body(mut self, input: std::option::Option<crate::model::Body>) -> Self {
            self.body = input;
            self
        }
        /// <p>Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform. </p>
        pub fn method(mut self, input: crate::model::Method) -> Self {
            self.method = Some(input);
            self
        }
        /// <p>Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform. </p>
        pub fn set_method(mut self, input: std::option::Option<crate::model::Method>) -> Self {
            self.method = input;
            self
        }
        /// <p>Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. </p>
        /// <p>Note that only the first 8 KB (8192 bytes) of the request body are forwarded to WAF for inspection by the underlying host service. If you don't need to inspect more than 8 KB, you can guarantee that you don't allow additional bytes in by combining a statement that inspects the body of the web request, such as <code>ByteMatchStatement</code> or <code>RegexPatternSetReferenceStatement</code>, with a <code>SizeConstraintStatement</code> that enforces an 8 KB size limit on the body of the request. WAF doesn't support inspecting the entire contents of web requests whose bodies exceed the 8 KB limit.</p>
        pub fn json_body(mut self, input: crate::model::JsonBody) -> Self {
            self.json_body = Some(input);
            self
        }
        /// <p>Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. </p>
        /// <p>Note that only the first 8 KB (8192 bytes) of the request body are forwarded to WAF for inspection by the underlying host service. If you don't need to inspect more than 8 KB, you can guarantee that you don't allow additional bytes in by combining a statement that inspects the body of the web request, such as <code>ByteMatchStatement</code> or <code>RegexPatternSetReferenceStatement</code>, with a <code>SizeConstraintStatement</code> that enforces an 8 KB size limit on the body of the request. WAF doesn't support inspecting the entire contents of web requests whose bodies exceed the 8 KB limit.</p>
        pub fn set_json_body(mut self, input: std::option::Option<crate::model::JsonBody>) -> Self {
            self.json_body = input;
            self
        }
        /// Consumes the builder and constructs a [`FieldToMatch`](crate::model::FieldToMatch)
        pub fn build(self) -> crate::model::FieldToMatch {
            crate::model::FieldToMatch {
                single_header: self.single_header,
                single_query_argument: self.single_query_argument,
                all_query_arguments: self.all_query_arguments,
                uri_path: self.uri_path,
                query_string: self.query_string,
                body: self.body,
                method: self.method,
                json_body: self.json_body,
            }
        }
    }
}
impl FieldToMatch {
    /// Creates a new builder-style object to manufacture [`FieldToMatch`](crate::model::FieldToMatch)
    pub fn builder() -> crate::model::field_to_match::Builder {
        crate::model::field_to_match::Builder::default()
    }
}

/// <p>The body of a web request, inspected as JSON. The body immediately follows the request headers. This is used in the <code>FieldToMatch</code> specification.</p>
/// <p>Use the specifications in this object to indicate which parts of the JSON body to inspect using the rule's inspection criteria. WAF inspects only the parts of the JSON that result from the matches that you indicate. </p>
/// <p>Example JSON: <code>"JsonBody": { "MatchPattern": { "All": {} }, "MatchScope": "ALL" }</code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JsonBody {
    /// <p>The patterns to look for in the JSON body. WAF inspects the results of these pattern matches against the rule inspection criteria. </p>
    pub match_pattern: std::option::Option<crate::model::JsonMatchPattern>,
    /// <p>The parts of the JSON to match against using the <code>MatchPattern</code>. If you specify <code>All</code>, WAF matches against keys and values. </p>
    pub match_scope: std::option::Option<crate::model::JsonMatchScope>,
    /// <p>What WAF should do if it fails to completely parse the JSON body. The options are the following:</p>
    /// <ul>
    /// <li> <p> <code>EVALUATE_AS_STRING</code> - Inspect the body as plain text. WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.</p> </li>
    /// <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li>
    /// <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li>
    /// </ul>
    /// <p>If you don't provide this setting, WAF parses and evaluates the content only up to the first parsing failure that it encounters. </p>
    /// <p>WAF does its best to parse the entire JSON body, but might be forced to stop for reasons such as invalid characters, duplicate keys, truncation, and any content whose root node isn't an object or an array. </p>
    /// <p>WAF parses the JSON in the following examples as two valid key, value pairs: </p>
    /// <ul>
    /// <li> <p>Missing comma: <code>{"key1":"value1""key2":"value2"}</code> </p> </li>
    /// <li> <p>Missing colon: <code>{"key1":"value1","key2""value2"}</code> </p> </li>
    /// <li> <p>Extra colons: <code>{"key1"::"value1","key2""value2"}</code> </p> </li>
    /// </ul>
    pub invalid_fallback_behavior: std::option::Option<crate::model::BodyParsingFallbackBehavior>,
}
impl JsonBody {
    /// <p>The patterns to look for in the JSON body. WAF inspects the results of these pattern matches against the rule inspection criteria. </p>
    pub fn match_pattern(&self) -> std::option::Option<&crate::model::JsonMatchPattern> {
        self.match_pattern.as_ref()
    }
    /// <p>The parts of the JSON to match against using the <code>MatchPattern</code>. If you specify <code>All</code>, WAF matches against keys and values. </p>
    pub fn match_scope(&self) -> std::option::Option<&crate::model::JsonMatchScope> {
        self.match_scope.as_ref()
    }
    /// <p>What WAF should do if it fails to completely parse the JSON body. The options are the following:</p>
    /// <ul>
    /// <li> <p> <code>EVALUATE_AS_STRING</code> - Inspect the body as plain text. WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.</p> </li>
    /// <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li>
    /// <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li>
    /// </ul>
    /// <p>If you don't provide this setting, WAF parses and evaluates the content only up to the first parsing failure that it encounters. </p>
    /// <p>WAF does its best to parse the entire JSON body, but might be forced to stop for reasons such as invalid characters, duplicate keys, truncation, and any content whose root node isn't an object or an array. </p>
    /// <p>WAF parses the JSON in the following examples as two valid key, value pairs: </p>
    /// <ul>
    /// <li> <p>Missing comma: <code>{"key1":"value1""key2":"value2"}</code> </p> </li>
    /// <li> <p>Missing colon: <code>{"key1":"value1","key2""value2"}</code> </p> </li>
    /// <li> <p>Extra colons: <code>{"key1"::"value1","key2""value2"}</code> </p> </li>
    /// </ul>
    pub fn invalid_fallback_behavior(
        &self,
    ) -> std::option::Option<&crate::model::BodyParsingFallbackBehavior> {
        self.invalid_fallback_behavior.as_ref()
    }
}
impl std::fmt::Debug for JsonBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JsonBody");
        formatter.field("match_pattern", &self.match_pattern);
        formatter.field("match_scope", &self.match_scope);
        formatter.field("invalid_fallback_behavior", &self.invalid_fallback_behavior);
        formatter.finish()
    }
}
/// See [`JsonBody`](crate::model::JsonBody)
pub mod json_body {
    /// A builder for [`JsonBody`](crate::model::JsonBody)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) match_pattern: std::option::Option<crate::model::JsonMatchPattern>,
        pub(crate) match_scope: std::option::Option<crate::model::JsonMatchScope>,
        pub(crate) invalid_fallback_behavior:
            std::option::Option<crate::model::BodyParsingFallbackBehavior>,
    }
    impl Builder {
        /// <p>The patterns to look for in the JSON body. WAF inspects the results of these pattern matches against the rule inspection criteria. </p>
        pub fn match_pattern(mut self, input: crate::model::JsonMatchPattern) -> Self {
            self.match_pattern = Some(input);
            self
        }
        /// <p>The patterns to look for in the JSON body. WAF inspects the results of these pattern matches against the rule inspection criteria. </p>
        pub fn set_match_pattern(
            mut self,
            input: std::option::Option<crate::model::JsonMatchPattern>,
        ) -> Self {
            self.match_pattern = input;
            self
        }
        /// <p>The parts of the JSON to match against using the <code>MatchPattern</code>. If you specify <code>All</code>, WAF matches against keys and values. </p>
        pub fn match_scope(mut self, input: crate::model::JsonMatchScope) -> Self {
            self.match_scope = Some(input);
            self
        }
        /// <p>The parts of the JSON to match against using the <code>MatchPattern</code>. If you specify <code>All</code>, WAF matches against keys and values. </p>
        pub fn set_match_scope(
            mut self,
            input: std::option::Option<crate::model::JsonMatchScope>,
        ) -> Self {
            self.match_scope = input;
            self
        }
        /// <p>What WAF should do if it fails to completely parse the JSON body. The options are the following:</p>
        /// <ul>
        /// <li> <p> <code>EVALUATE_AS_STRING</code> - Inspect the body as plain text. WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.</p> </li>
        /// <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li>
        /// <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li>
        /// </ul>
        /// <p>If you don't provide this setting, WAF parses and evaluates the content only up to the first parsing failure that it encounters. </p>
        /// <p>WAF does its best to parse the entire JSON body, but might be forced to stop for reasons such as invalid characters, duplicate keys, truncation, and any content whose root node isn't an object or an array. </p>
        /// <p>WAF parses the JSON in the following examples as two valid key, value pairs: </p>
        /// <ul>
        /// <li> <p>Missing comma: <code>{"key1":"value1""key2":"value2"}</code> </p> </li>
        /// <li> <p>Missing colon: <code>{"key1":"value1","key2""value2"}</code> </p> </li>
        /// <li> <p>Extra colons: <code>{"key1"::"value1","key2""value2"}</code> </p> </li>
        /// </ul>
        pub fn invalid_fallback_behavior(
            mut self,
            input: crate::model::BodyParsingFallbackBehavior,
        ) -> Self {
            self.invalid_fallback_behavior = Some(input);
            self
        }
        /// <p>What WAF should do if it fails to completely parse the JSON body. The options are the following:</p>
        /// <ul>
        /// <li> <p> <code>EVALUATE_AS_STRING</code> - Inspect the body as plain text. WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.</p> </li>
        /// <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li>
        /// <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li>
        /// </ul>
        /// <p>If you don't provide this setting, WAF parses and evaluates the content only up to the first parsing failure that it encounters. </p>
        /// <p>WAF does its best to parse the entire JSON body, but might be forced to stop for reasons such as invalid characters, duplicate keys, truncation, and any content whose root node isn't an object or an array. </p>
        /// <p>WAF parses the JSON in the following examples as two valid key, value pairs: </p>
        /// <ul>
        /// <li> <p>Missing comma: <code>{"key1":"value1""key2":"value2"}</code> </p> </li>
        /// <li> <p>Missing colon: <code>{"key1":"value1","key2""value2"}</code> </p> </li>
        /// <li> <p>Extra colons: <code>{"key1"::"value1","key2""value2"}</code> </p> </li>
        /// </ul>
        pub fn set_invalid_fallback_behavior(
            mut self,
            input: std::option::Option<crate::model::BodyParsingFallbackBehavior>,
        ) -> Self {
            self.invalid_fallback_behavior = input;
            self
        }
        /// Consumes the builder and constructs a [`JsonBody`](crate::model::JsonBody)
        pub fn build(self) -> crate::model::JsonBody {
            crate::model::JsonBody {
                match_pattern: self.match_pattern,
                match_scope: self.match_scope,
                invalid_fallback_behavior: self.invalid_fallback_behavior,
            }
        }
    }
}
impl JsonBody {
    /// Creates a new builder-style object to manufacture [`JsonBody`](crate::model::JsonBody)
    pub fn builder() -> crate::model::json_body::Builder {
        crate::model::json_body::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BodyParsingFallbackBehavior {
    #[allow(missing_docs)] // documentation missing in model
    EvaluateAsString,
    #[allow(missing_docs)] // documentation missing in model
    Match,
    #[allow(missing_docs)] // documentation missing in model
    NoMatch,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for BodyParsingFallbackBehavior {
    fn from(s: &str) -> Self {
        match s {
            "EVALUATE_AS_STRING" => BodyParsingFallbackBehavior::EvaluateAsString,
            "MATCH" => BodyParsingFallbackBehavior::Match,
            "NO_MATCH" => BodyParsingFallbackBehavior::NoMatch,
            other => BodyParsingFallbackBehavior::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for BodyParsingFallbackBehavior {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BodyParsingFallbackBehavior::from(s))
    }
}
impl BodyParsingFallbackBehavior {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BodyParsingFallbackBehavior::EvaluateAsString => "EVALUATE_AS_STRING",
            BodyParsingFallbackBehavior::Match => "MATCH",
            BodyParsingFallbackBehavior::NoMatch => "NO_MATCH",
            BodyParsingFallbackBehavior::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["EVALUATE_AS_STRING", "MATCH", "NO_MATCH"]
    }
}
impl AsRef<str> for BodyParsingFallbackBehavior {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum JsonMatchScope {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    Key,
    #[allow(missing_docs)] // documentation missing in model
    Value,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for JsonMatchScope {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => JsonMatchScope::All,
            "KEY" => JsonMatchScope::Key,
            "VALUE" => JsonMatchScope::Value,
            other => JsonMatchScope::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for JsonMatchScope {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(JsonMatchScope::from(s))
    }
}
impl JsonMatchScope {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            JsonMatchScope::All => "ALL",
            JsonMatchScope::Key => "KEY",
            JsonMatchScope::Value => "VALUE",
            JsonMatchScope::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ALL", "KEY", "VALUE"]
    }
}
impl AsRef<str> for JsonMatchScope {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The patterns to look for in the JSON body. WAF inspects the results of these pattern matches against the rule inspection criteria. This is used with the <code>FieldToMatch</code> option <code>JsonBody</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JsonMatchPattern {
    /// <p>Match all of the elements. See also <code>MatchScope</code> in <code>JsonBody</code>. </p>
    /// <p>You must specify either this setting or the <code>IncludedPaths</code> setting, but not both.</p>
    pub all: std::option::Option<crate::model::All>,
    /// <p>Match only the specified include paths. See also <code>MatchScope</code> in <code>JsonBody</code>. </p>
    /// <p>Provide the include paths using JSON Pointer syntax. For example, <code>"IncludedPaths": ["/dogs/0/name", "/dogs/1/name"]</code>. For information about this syntax, see the Internet Engineering Task Force (IETF) documentation <a href="https://tools.ietf.org/html/rfc6901">JavaScript Object Notation (JSON) Pointer</a>. </p>
    /// <p>You must specify either this setting or the <code>All</code> setting, but not both.</p> <note>
    /// <p>Don't use this option to include all paths. Instead, use the <code>All</code> setting. </p>
    /// </note>
    pub included_paths: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl JsonMatchPattern {
    /// <p>Match all of the elements. See also <code>MatchScope</code> in <code>JsonBody</code>. </p>
    /// <p>You must specify either this setting or the <code>IncludedPaths</code> setting, but not both.</p>
    pub fn all(&self) -> std::option::Option<&crate::model::All> {
        self.all.as_ref()
    }
    /// <p>Match only the specified include paths. See also <code>MatchScope</code> in <code>JsonBody</code>. </p>
    /// <p>Provide the include paths using JSON Pointer syntax. For example, <code>"IncludedPaths": ["/dogs/0/name", "/dogs/1/name"]</code>. For information about this syntax, see the Internet Engineering Task Force (IETF) documentation <a href="https://tools.ietf.org/html/rfc6901">JavaScript Object Notation (JSON) Pointer</a>. </p>
    /// <p>You must specify either this setting or the <code>All</code> setting, but not both.</p> <note>
    /// <p>Don't use this option to include all paths. Instead, use the <code>All</code> setting. </p>
    /// </note>
    pub fn included_paths(&self) -> std::option::Option<&[std::string::String]> {
        self.included_paths.as_deref()
    }
}
impl std::fmt::Debug for JsonMatchPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JsonMatchPattern");
        formatter.field("all", &self.all);
        formatter.field("included_paths", &self.included_paths);
        formatter.finish()
    }
}
/// See [`JsonMatchPattern`](crate::model::JsonMatchPattern)
pub mod json_match_pattern {
    /// A builder for [`JsonMatchPattern`](crate::model::JsonMatchPattern)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) all: std::option::Option<crate::model::All>,
        pub(crate) included_paths: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>Match all of the elements. See also <code>MatchScope</code> in <code>JsonBody</code>. </p>
        /// <p>You must specify either this setting or the <code>IncludedPaths</code> setting, but not both.</p>
        pub fn all(mut self, input: crate::model::All) -> Self {
            self.all = Some(input);
            self
        }
        /// <p>Match all of the elements. See also <code>MatchScope</code> in <code>JsonBody</code>. </p>
        /// <p>You must specify either this setting or the <code>IncludedPaths</code> setting, but not both.</p>
        pub fn set_all(mut self, input: std::option::Option<crate::model::All>) -> Self {
            self.all = input;
            self
        }
        /// Appends an item to `included_paths`.
        ///
        /// To override the contents of this collection use [`set_included_paths`](Self::set_included_paths).
        ///
        /// <p>Match only the specified include paths. See also <code>MatchScope</code> in <code>JsonBody</code>. </p>
        /// <p>Provide the include paths using JSON Pointer syntax. For example, <code>"IncludedPaths": ["/dogs/0/name", "/dogs/1/name"]</code>. For information about this syntax, see the Internet Engineering Task Force (IETF) documentation <a href="https://tools.ietf.org/html/rfc6901">JavaScript Object Notation (JSON) Pointer</a>. </p>
        /// <p>You must specify either this setting or the <code>All</code> setting, but not both.</p> <note>
        /// <p>Don't use this option to include all paths. Instead, use the <code>All</code> setting. </p>
        /// </note>
        pub fn included_paths(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.included_paths.unwrap_or_default();
            v.push(input.into());
            self.included_paths = Some(v);
            self
        }
        /// <p>Match only the specified include paths. See also <code>MatchScope</code> in <code>JsonBody</code>. </p>
        /// <p>Provide the include paths using JSON Pointer syntax. For example, <code>"IncludedPaths": ["/dogs/0/name", "/dogs/1/name"]</code>. For information about this syntax, see the Internet Engineering Task Force (IETF) documentation <a href="https://tools.ietf.org/html/rfc6901">JavaScript Object Notation (JSON) Pointer</a>. </p>
        /// <p>You must specify either this setting or the <code>All</code> setting, but not both.</p> <note>
        /// <p>Don't use this option to include all paths. Instead, use the <code>All</code> setting. </p>
        /// </note>
        pub fn set_included_paths(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.included_paths = input;
            self
        }
        /// Consumes the builder and constructs a [`JsonMatchPattern`](crate::model::JsonMatchPattern)
        pub fn build(self) -> crate::model::JsonMatchPattern {
            crate::model::JsonMatchPattern {
                all: self.all,
                included_paths: self.included_paths,
            }
        }
    }
}
impl JsonMatchPattern {
    /// Creates a new builder-style object to manufacture [`JsonMatchPattern`](crate::model::JsonMatchPattern)
    pub fn builder() -> crate::model::json_match_pattern::Builder {
        crate::model::json_match_pattern::Builder::default()
    }
}

/// <p>Inspect all of the elements that WAF has parsed and extracted from the web request JSON body that are within the <code>JsonBody</code> <code>MatchScope</code>. This is used with the <code>FieldToMatch</code> option <code>JsonBody</code>. </p>
/// <p>This is used only to indicate the web request component for WAF to inspect, in the <code>FieldToMatch</code> specification. </p>
/// <p>JSON specification: <code>"All": {}</code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct All {}
impl std::fmt::Debug for All {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("All");
        formatter.finish()
    }
}
/// See [`All`](crate::model::All)
pub mod all {
    /// A builder for [`All`](crate::model::All)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`All`](crate::model::All)
        pub fn build(self) -> crate::model::All {
            crate::model::All {}
        }
    }
}
impl All {
    /// Creates a new builder-style object to manufacture [`All`](crate::model::All)
    pub fn builder() -> crate::model::all::Builder {
        crate::model::all::Builder::default()
    }
}

/// <p>The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform. </p>
/// <p>This is used only to indicate the web request component for WAF to inspect, in the <code>FieldToMatch</code> specification. </p>
/// <p>JSON specification: <code>"Method": {}</code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Method {}
impl std::fmt::Debug for Method {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Method");
        formatter.finish()
    }
}
/// See [`Method`](crate::model::Method)
pub mod method {
    /// A builder for [`Method`](crate::model::Method)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`Method`](crate::model::Method)
        pub fn build(self) -> crate::model::Method {
            crate::model::Method {}
        }
    }
}
impl Method {
    /// Creates a new builder-style object to manufacture [`Method`](crate::model::Method)
    pub fn builder() -> crate::model::method::Builder {
        crate::model::method::Builder::default()
    }
}

/// <p>The body of a web request. This immediately follows the request headers.</p>
/// <p>This is used only to indicate the web request component for WAF to inspect, in the <code>FieldToMatch</code> specification. </p>
/// <p>JSON specification: <code>"Body": {}</code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Body {}
impl std::fmt::Debug for Body {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Body");
        formatter.finish()
    }
}
/// See [`Body`](crate::model::Body)
pub mod body {
    /// A builder for [`Body`](crate::model::Body)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`Body`](crate::model::Body)
        pub fn build(self) -> crate::model::Body {
            crate::model::Body {}
        }
    }
}
impl Body {
    /// Creates a new builder-style object to manufacture [`Body`](crate::model::Body)
    pub fn builder() -> crate::model::body::Builder {
        crate::model::body::Builder::default()
    }
}

/// <p>The query string of a web request. This is the part of a URL that appears after a <code>?</code> character, if any.</p>
/// <p>This is used only to indicate the web request component for WAF to inspect, in the <code>FieldToMatch</code> specification. </p>
/// <p>JSON specification: <code>"QueryString": {}</code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct QueryString {}
impl std::fmt::Debug for QueryString {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("QueryString");
        formatter.finish()
    }
}
/// See [`QueryString`](crate::model::QueryString)
pub mod query_string {
    /// A builder for [`QueryString`](crate::model::QueryString)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`QueryString`](crate::model::QueryString)
        pub fn build(self) -> crate::model::QueryString {
            crate::model::QueryString {}
        }
    }
}
impl QueryString {
    /// Creates a new builder-style object to manufacture [`QueryString`](crate::model::QueryString)
    pub fn builder() -> crate::model::query_string::Builder {
        crate::model::query_string::Builder::default()
    }
}

/// <p>The path component of the URI of a web request. This is the part of a web request that identifies a resource. For example, <code>/images/daily-ad.jpg</code>.</p>
/// <p>This is used only to indicate the web request component for WAF to inspect, in the <code>FieldToMatch</code> specification. </p>
/// <p>JSON specification: <code>"UriPath": {}</code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UriPath {}
impl std::fmt::Debug for UriPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UriPath");
        formatter.finish()
    }
}
/// See [`UriPath`](crate::model::UriPath)
pub mod uri_path {
    /// A builder for [`UriPath`](crate::model::UriPath)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`UriPath`](crate::model::UriPath)
        pub fn build(self) -> crate::model::UriPath {
            crate::model::UriPath {}
        }
    }
}
impl UriPath {
    /// Creates a new builder-style object to manufacture [`UriPath`](crate::model::UriPath)
    pub fn builder() -> crate::model::uri_path::Builder {
        crate::model::uri_path::Builder::default()
    }
}

/// <p>All query arguments of a web request. </p>
/// <p>This is used only to indicate the web request component for WAF to inspect, in the <code>FieldToMatch</code> specification. </p>
/// <p>JSON specification: <code>"AllQueryArguments": {}</code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AllQueryArguments {}
impl std::fmt::Debug for AllQueryArguments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AllQueryArguments");
        formatter.finish()
    }
}
/// See [`AllQueryArguments`](crate::model::AllQueryArguments)
pub mod all_query_arguments {
    /// A builder for [`AllQueryArguments`](crate::model::AllQueryArguments)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`AllQueryArguments`](crate::model::AllQueryArguments)
        pub fn build(self) -> crate::model::AllQueryArguments {
            crate::model::AllQueryArguments {}
        }
    }
}
impl AllQueryArguments {
    /// Creates a new builder-style object to manufacture [`AllQueryArguments`](crate::model::AllQueryArguments)
    pub fn builder() -> crate::model::all_query_arguments::Builder {
        crate::model::all_query_arguments::Builder::default()
    }
}

/// <p>One query argument in a web request, identified by name, for example <i>UserName</i> or <i>SalesRegion</i>. The name can be up to 30 characters long and isn't case sensitive. </p>
/// <p>Example JSON: <code>"SingleQueryArgument": { "Name": "myArgument" }</code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SingleQueryArgument {
    /// <p>The name of the query argument to inspect.</p>
    pub name: std::option::Option<std::string::String>,
}
impl SingleQueryArgument {
    /// <p>The name of the query argument to inspect.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl std::fmt::Debug for SingleQueryArgument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SingleQueryArgument");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`SingleQueryArgument`](crate::model::SingleQueryArgument)
pub mod single_query_argument {
    /// A builder for [`SingleQueryArgument`](crate::model::SingleQueryArgument)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the query argument to inspect.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the query argument to inspect.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`SingleQueryArgument`](crate::model::SingleQueryArgument)
        pub fn build(self) -> crate::model::SingleQueryArgument {
            crate::model::SingleQueryArgument { name: self.name }
        }
    }
}
impl SingleQueryArgument {
    /// Creates a new builder-style object to manufacture [`SingleQueryArgument`](crate::model::SingleQueryArgument)
    pub fn builder() -> crate::model::single_query_argument::Builder {
        crate::model::single_query_argument::Builder::default()
    }
}

/// <p>One of the headers in a web request, identified by name, for example, <code>User-Agent</code> or <code>Referer</code>. This setting isn't case sensitive.</p>
/// <p>This is used only to indicate the web request component for WAF to inspect, in the <code>FieldToMatch</code> specification. </p>
/// <p>Example JSON: <code>"SingleHeader": { "Name": "haystack" }</code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SingleHeader {
    /// <p>The name of the query header to inspect.</p>
    pub name: std::option::Option<std::string::String>,
}
impl SingleHeader {
    /// <p>The name of the query header to inspect.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl std::fmt::Debug for SingleHeader {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SingleHeader");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`SingleHeader`](crate::model::SingleHeader)
pub mod single_header {
    /// A builder for [`SingleHeader`](crate::model::SingleHeader)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the query header to inspect.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the query header to inspect.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`SingleHeader`](crate::model::SingleHeader)
        pub fn build(self) -> crate::model::SingleHeader {
            crate::model::SingleHeader { name: self.name }
        }
    }
}
impl SingleHeader {
    /// Creates a new builder-style object to manufacture [`SingleHeader`](crate::model::SingleHeader)
    pub fn builder() -> crate::model::single_header::Builder {
        crate::model::single_header::Builder::default()
    }
}

/// <p>A rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. </p>
/// <p>The label match statement provides the label or namespace string to search for. The label string can represent a part or all of the fully qualified label name that had been added to the web request. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. If you do not provide the fully qualified name in your label match string, WAF performs the search for labels that were added in the same context as the label match statement. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelMatchStatement {
    /// <p>Specify whether you want to match using the label name or just the namespace. </p>
    pub scope: std::option::Option<crate::model::LabelMatchScope>,
    /// <p>The string to match against. The setting you provide for this depends on the match statement's <code>Scope</code> setting: </p>
    /// <ul>
    /// <li> <p>If the <code>Scope</code> indicates <code>LABEL</code>, then this specification must include the name and can include any number of preceding namespace specifications and prefix up to providing the fully qualified label name. </p> </li>
    /// <li> <p>If the <code>Scope</code> indicates <code>NAMESPACE</code>, then this specification can include any number of contiguous namespace strings, and can include the entire label namespace prefix from the rule group or web ACL where the label originates.</p> </li>
    /// </ul>
    /// <p>Labels are case sensitive and components of a label must be separated by colon, for example <code>NS1:NS2:name</code>.</p>
    pub key: std::option::Option<std::string::String>,
}
impl LabelMatchStatement {
    /// <p>Specify whether you want to match using the label name or just the namespace. </p>
    pub fn scope(&self) -> std::option::Option<&crate::model::LabelMatchScope> {
        self.scope.as_ref()
    }
    /// <p>The string to match against. The setting you provide for this depends on the match statement's <code>Scope</code> setting: </p>
    /// <ul>
    /// <li> <p>If the <code>Scope</code> indicates <code>LABEL</code>, then this specification must include the name and can include any number of preceding namespace specifications and prefix up to providing the fully qualified label name. </p> </li>
    /// <li> <p>If the <code>Scope</code> indicates <code>NAMESPACE</code>, then this specification can include any number of contiguous namespace strings, and can include the entire label namespace prefix from the rule group or web ACL where the label originates.</p> </li>
    /// </ul>
    /// <p>Labels are case sensitive and components of a label must be separated by colon, for example <code>NS1:NS2:name</code>.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
}
impl std::fmt::Debug for LabelMatchStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelMatchStatement");
        formatter.field("scope", &self.scope);
        formatter.field("key", &self.key);
        formatter.finish()
    }
}
/// See [`LabelMatchStatement`](crate::model::LabelMatchStatement)
pub mod label_match_statement {
    /// A builder for [`LabelMatchStatement`](crate::model::LabelMatchStatement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scope: std::option::Option<crate::model::LabelMatchScope>,
        pub(crate) key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specify whether you want to match using the label name or just the namespace. </p>
        pub fn scope(mut self, input: crate::model::LabelMatchScope) -> Self {
            self.scope = Some(input);
            self
        }
        /// <p>Specify whether you want to match using the label name or just the namespace. </p>
        pub fn set_scope(
            mut self,
            input: std::option::Option<crate::model::LabelMatchScope>,
        ) -> Self {
            self.scope = input;
            self
        }
        /// <p>The string to match against. The setting you provide for this depends on the match statement's <code>Scope</code> setting: </p>
        /// <ul>
        /// <li> <p>If the <code>Scope</code> indicates <code>LABEL</code>, then this specification must include the name and can include any number of preceding namespace specifications and prefix up to providing the fully qualified label name. </p> </li>
        /// <li> <p>If the <code>Scope</code> indicates <code>NAMESPACE</code>, then this specification can include any number of contiguous namespace strings, and can include the entire label namespace prefix from the rule group or web ACL where the label originates.</p> </li>
        /// </ul>
        /// <p>Labels are case sensitive and components of a label must be separated by colon, for example <code>NS1:NS2:name</code>.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The string to match against. The setting you provide for this depends on the match statement's <code>Scope</code> setting: </p>
        /// <ul>
        /// <li> <p>If the <code>Scope</code> indicates <code>LABEL</code>, then this specification must include the name and can include any number of preceding namespace specifications and prefix up to providing the fully qualified label name. </p> </li>
        /// <li> <p>If the <code>Scope</code> indicates <code>NAMESPACE</code>, then this specification can include any number of contiguous namespace strings, and can include the entire label namespace prefix from the rule group or web ACL where the label originates.</p> </li>
        /// </ul>
        /// <p>Labels are case sensitive and components of a label must be separated by colon, for example <code>NS1:NS2:name</code>.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelMatchStatement`](crate::model::LabelMatchStatement)
        pub fn build(self) -> crate::model::LabelMatchStatement {
            crate::model::LabelMatchStatement {
                scope: self.scope,
                key: self.key,
            }
        }
    }
}
impl LabelMatchStatement {
    /// Creates a new builder-style object to manufacture [`LabelMatchStatement`](crate::model::LabelMatchStatement)
    pub fn builder() -> crate::model::label_match_statement::Builder {
        crate::model::label_match_statement::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LabelMatchScope {
    #[allow(missing_docs)] // documentation missing in model
    Label,
    #[allow(missing_docs)] // documentation missing in model
    Namespace,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LabelMatchScope {
    fn from(s: &str) -> Self {
        match s {
            "LABEL" => LabelMatchScope::Label,
            "NAMESPACE" => LabelMatchScope::Namespace,
            other => LabelMatchScope::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LabelMatchScope {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LabelMatchScope::from(s))
    }
}
impl LabelMatchScope {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LabelMatchScope::Label => "LABEL",
            LabelMatchScope::Namespace => "NAMESPACE",
            LabelMatchScope::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["LABEL", "NAMESPACE"]
    }
}
impl AsRef<str> for LabelMatchScope {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A rule statement used to run the rules that are defined in a managed rule group. To use this, provide the vendor name and the name of the rule group in this statement. You can retrieve the required names by calling <code>ListAvailableManagedRuleGroups</code>.</p>
/// <p>You cannot nest a <code>ManagedRuleGroupStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. It can only be referenced as a top-level statement within a rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ManagedRuleGroupStatement {
    /// <p>The name of the managed rule group vendor. You use this, along with the rule group name, to identify the rule group.</p>
    pub vendor_name: std::option::Option<std::string::String>,
    /// <p>The name of the managed rule group. You use this, along with the vendor name, to identify the rule group.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The version of the managed rule group to use. If you specify this, the version setting is fixed until you change it. If you don't specify this, WAF uses the vendor's default version, and then keeps the version at the vendor's default when the vendor updates the managed rule group settings. </p>
    pub version: std::option::Option<std::string::String>,
    /// <p>The rules in the referenced rule group whose actions are set to <code>Count</code>. When you exclude a rule, WAF evaluates it exactly as it would if the rule action setting were <code>Count</code>. This is a useful option for testing the rules in a rule group without modifying how they handle your web traffic.</p>
    pub excluded_rules: std::option::Option<std::vec::Vec<crate::model::ExcludedRule>>,
    /// <p>An optional nested statement that narrows the scope of the web requests that are evaluated by the managed rule group. Requests are only evaluated by the rule group if they match the scope-down statement. You can use any nestable <code>Statement</code> in the scope-down statement, and you can nest statements at any level, the same as you can for a rule statement. </p>
    pub scope_down_statement: std::option::Option<std::boxed::Box<crate::model::Statement>>,
    /// <p>Additional information that's used by a managed rule group. Most managed rule groups don't require this.</p>
    /// <p>Use this for the account takeover prevention managed rule group <code>AWSManagedRulesATPRuleSet</code>, to provide information about the sign-in page of your application. </p>
    pub managed_rule_group_configs:
        std::option::Option<std::vec::Vec<crate::model::ManagedRuleGroupConfig>>,
}
impl ManagedRuleGroupStatement {
    /// <p>The name of the managed rule group vendor. You use this, along with the rule group name, to identify the rule group.</p>
    pub fn vendor_name(&self) -> std::option::Option<&str> {
        self.vendor_name.as_deref()
    }
    /// <p>The name of the managed rule group. You use this, along with the vendor name, to identify the rule group.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The version of the managed rule group to use. If you specify this, the version setting is fixed until you change it. If you don't specify this, WAF uses the vendor's default version, and then keeps the version at the vendor's default when the vendor updates the managed rule group settings. </p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
    /// <p>The rules in the referenced rule group whose actions are set to <code>Count</code>. When you exclude a rule, WAF evaluates it exactly as it would if the rule action setting were <code>Count</code>. This is a useful option for testing the rules in a rule group without modifying how they handle your web traffic.</p>
    pub fn excluded_rules(&self) -> std::option::Option<&[crate::model::ExcludedRule]> {
        self.excluded_rules.as_deref()
    }
    /// <p>An optional nested statement that narrows the scope of the web requests that are evaluated by the managed rule group. Requests are only evaluated by the rule group if they match the scope-down statement. You can use any nestable <code>Statement</code> in the scope-down statement, and you can nest statements at any level, the same as you can for a rule statement. </p>
    pub fn scope_down_statement(&self) -> std::option::Option<&crate::model::Statement> {
        self.scope_down_statement.as_deref()
    }
    /// <p>Additional information that's used by a managed rule group. Most managed rule groups don't require this.</p>
    /// <p>Use this for the account takeover prevention managed rule group <code>AWSManagedRulesATPRuleSet</code>, to provide information about the sign-in page of your application. </p>
    pub fn managed_rule_group_configs(
        &self,
    ) -> std::option::Option<&[crate::model::ManagedRuleGroupConfig]> {
        self.managed_rule_group_configs.as_deref()
    }
}
impl std::fmt::Debug for ManagedRuleGroupStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ManagedRuleGroupStatement");
        formatter.field("vendor_name", &self.vendor_name);
        formatter.field("name", &self.name);
        formatter.field("version", &self.version);
        formatter.field("excluded_rules", &self.excluded_rules);
        formatter.field("scope_down_statement", &self.scope_down_statement);
        formatter.field(
            "managed_rule_group_configs",
            &self.managed_rule_group_configs,
        );
        formatter.finish()
    }
}
/// See [`ManagedRuleGroupStatement`](crate::model::ManagedRuleGroupStatement)
pub mod managed_rule_group_statement {
    /// A builder for [`ManagedRuleGroupStatement`](crate::model::ManagedRuleGroupStatement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vendor_name: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
        pub(crate) excluded_rules: std::option::Option<std::vec::Vec<crate::model::ExcludedRule>>,
        pub(crate) scope_down_statement:
            std::option::Option<std::boxed::Box<crate::model::Statement>>,
        pub(crate) managed_rule_group_configs:
            std::option::Option<std::vec::Vec<crate::model::ManagedRuleGroupConfig>>,
    }
    impl Builder {
        /// <p>The name of the managed rule group vendor. You use this, along with the rule group name, to identify the rule group.</p>
        pub fn vendor_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vendor_name = Some(input.into());
            self
        }
        /// <p>The name of the managed rule group vendor. You use this, along with the rule group name, to identify the rule group.</p>
        pub fn set_vendor_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vendor_name = input;
            self
        }
        /// <p>The name of the managed rule group. You use this, along with the vendor name, to identify the rule group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the managed rule group. You use this, along with the vendor name, to identify the rule group.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The version of the managed rule group to use. If you specify this, the version setting is fixed until you change it. If you don't specify this, WAF uses the vendor's default version, and then keeps the version at the vendor's default when the vendor updates the managed rule group settings. </p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The version of the managed rule group to use. If you specify this, the version setting is fixed until you change it. If you don't specify this, WAF uses the vendor's default version, and then keeps the version at the vendor's default when the vendor updates the managed rule group settings. </p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Appends an item to `excluded_rules`.
        ///
        /// To override the contents of this collection use [`set_excluded_rules`](Self::set_excluded_rules).
        ///
        /// <p>The rules in the referenced rule group whose actions are set to <code>Count</code>. When you exclude a rule, WAF evaluates it exactly as it would if the rule action setting were <code>Count</code>. This is a useful option for testing the rules in a rule group without modifying how they handle your web traffic.</p>
        pub fn excluded_rules(mut self, input: crate::model::ExcludedRule) -> Self {
            let mut v = self.excluded_rules.unwrap_or_default();
            v.push(input);
            self.excluded_rules = Some(v);
            self
        }
        /// <p>The rules in the referenced rule group whose actions are set to <code>Count</code>. When you exclude a rule, WAF evaluates it exactly as it would if the rule action setting were <code>Count</code>. This is a useful option for testing the rules in a rule group without modifying how they handle your web traffic.</p>
        pub fn set_excluded_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ExcludedRule>>,
        ) -> Self {
            self.excluded_rules = input;
            self
        }
        /// <p>An optional nested statement that narrows the scope of the web requests that are evaluated by the managed rule group. Requests are only evaluated by the rule group if they match the scope-down statement. You can use any nestable <code>Statement</code> in the scope-down statement, and you can nest statements at any level, the same as you can for a rule statement. </p>
        pub fn scope_down_statement(
            mut self,
            input: impl Into<std::boxed::Box<crate::model::Statement>>,
        ) -> Self {
            self.scope_down_statement = Some(input.into());
            self
        }
        /// <p>An optional nested statement that narrows the scope of the web requests that are evaluated by the managed rule group. Requests are only evaluated by the rule group if they match the scope-down statement. You can use any nestable <code>Statement</code> in the scope-down statement, and you can nest statements at any level, the same as you can for a rule statement. </p>
        pub fn set_scope_down_statement(
            mut self,
            input: std::option::Option<std::boxed::Box<crate::model::Statement>>,
        ) -> Self {
            self.scope_down_statement = input;
            self
        }
        /// Appends an item to `managed_rule_group_configs`.
        ///
        /// To override the contents of this collection use [`set_managed_rule_group_configs`](Self::set_managed_rule_group_configs).
        ///
        /// <p>Additional information that's used by a managed rule group. Most managed rule groups don't require this.</p>
        /// <p>Use this for the account takeover prevention managed rule group <code>AWSManagedRulesATPRuleSet</code>, to provide information about the sign-in page of your application. </p>
        pub fn managed_rule_group_configs(
            mut self,
            input: crate::model::ManagedRuleGroupConfig,
        ) -> Self {
            let mut v = self.managed_rule_group_configs.unwrap_or_default();
            v.push(input);
            self.managed_rule_group_configs = Some(v);
            self
        }
        /// <p>Additional information that's used by a managed rule group. Most managed rule groups don't require this.</p>
        /// <p>Use this for the account takeover prevention managed rule group <code>AWSManagedRulesATPRuleSet</code>, to provide information about the sign-in page of your application. </p>
        pub fn set_managed_rule_group_configs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ManagedRuleGroupConfig>>,
        ) -> Self {
            self.managed_rule_group_configs = input;
            self
        }
        /// Consumes the builder and constructs a [`ManagedRuleGroupStatement`](crate::model::ManagedRuleGroupStatement)
        pub fn build(self) -> crate::model::ManagedRuleGroupStatement {
            crate::model::ManagedRuleGroupStatement {
                vendor_name: self.vendor_name,
                name: self.name,
                version: self.version,
                excluded_rules: self.excluded_rules,
                scope_down_statement: self.scope_down_statement,
                managed_rule_group_configs: self.managed_rule_group_configs,
            }
        }
    }
}
impl ManagedRuleGroupStatement {
    /// Creates a new builder-style object to manufacture [`ManagedRuleGroupStatement`](crate::model::ManagedRuleGroupStatement)
    pub fn builder() -> crate::model::managed_rule_group_statement::Builder {
        crate::model::managed_rule_group_statement::Builder::default()
    }
}

/// <p>Additional information that's used by a managed rule group. Most managed rule groups don't require this.</p>
/// <p>Use this for the account takeover prevention managed rule group <code>AWSManagedRulesATPRuleSet</code>, to provide information about the sign-in page of your application. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ManagedRuleGroupConfig {
    /// <p>The path of the login endpoint for your application. For example, for the URL <code>https://example.com/web/login</code>, you would provide the path <code>/web/login</code>.</p>
    pub login_path: std::option::Option<std::string::String>,
    /// <p>The payload type for your login endpoint, either JSON or form encoded.</p>
    pub payload_type: std::option::Option<crate::model::PayloadType>,
    /// <p>Details about your login page username field. </p>
    pub username_field: std::option::Option<crate::model::UsernameField>,
    /// <p>Details about your login page password field. </p>
    pub password_field: std::option::Option<crate::model::PasswordField>,
}
impl ManagedRuleGroupConfig {
    /// <p>The path of the login endpoint for your application. For example, for the URL <code>https://example.com/web/login</code>, you would provide the path <code>/web/login</code>.</p>
    pub fn login_path(&self) -> std::option::Option<&str> {
        self.login_path.as_deref()
    }
    /// <p>The payload type for your login endpoint, either JSON or form encoded.</p>
    pub fn payload_type(&self) -> std::option::Option<&crate::model::PayloadType> {
        self.payload_type.as_ref()
    }
    /// <p>Details about your login page username field. </p>
    pub fn username_field(&self) -> std::option::Option<&crate::model::UsernameField> {
        self.username_field.as_ref()
    }
    /// <p>Details about your login page password field. </p>
    pub fn password_field(&self) -> std::option::Option<&crate::model::PasswordField> {
        self.password_field.as_ref()
    }
}
impl std::fmt::Debug for ManagedRuleGroupConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ManagedRuleGroupConfig");
        formatter.field("login_path", &self.login_path);
        formatter.field("payload_type", &self.payload_type);
        formatter.field("username_field", &self.username_field);
        formatter.field("password_field", &self.password_field);
        formatter.finish()
    }
}
/// See [`ManagedRuleGroupConfig`](crate::model::ManagedRuleGroupConfig)
pub mod managed_rule_group_config {
    /// A builder for [`ManagedRuleGroupConfig`](crate::model::ManagedRuleGroupConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) login_path: std::option::Option<std::string::String>,
        pub(crate) payload_type: std::option::Option<crate::model::PayloadType>,
        pub(crate) username_field: std::option::Option<crate::model::UsernameField>,
        pub(crate) password_field: std::option::Option<crate::model::PasswordField>,
    }
    impl Builder {
        /// <p>The path of the login endpoint for your application. For example, for the URL <code>https://example.com/web/login</code>, you would provide the path <code>/web/login</code>.</p>
        pub fn login_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.login_path = Some(input.into());
            self
        }
        /// <p>The path of the login endpoint for your application. For example, for the URL <code>https://example.com/web/login</code>, you would provide the path <code>/web/login</code>.</p>
        pub fn set_login_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.login_path = input;
            self
        }
        /// <p>The payload type for your login endpoint, either JSON or form encoded.</p>
        pub fn payload_type(mut self, input: crate::model::PayloadType) -> Self {
            self.payload_type = Some(input);
            self
        }
        /// <p>The payload type for your login endpoint, either JSON or form encoded.</p>
        pub fn set_payload_type(
            mut self,
            input: std::option::Option<crate::model::PayloadType>,
        ) -> Self {
            self.payload_type = input;
            self
        }
        /// <p>Details about your login page username field. </p>
        pub fn username_field(mut self, input: crate::model::UsernameField) -> Self {
            self.username_field = Some(input);
            self
        }
        /// <p>Details about your login page username field. </p>
        pub fn set_username_field(
            mut self,
            input: std::option::Option<crate::model::UsernameField>,
        ) -> Self {
            self.username_field = input;
            self
        }
        /// <p>Details about your login page password field. </p>
        pub fn password_field(mut self, input: crate::model::PasswordField) -> Self {
            self.password_field = Some(input);
            self
        }
        /// <p>Details about your login page password field. </p>
        pub fn set_password_field(
            mut self,
            input: std::option::Option<crate::model::PasswordField>,
        ) -> Self {
            self.password_field = input;
            self
        }
        /// Consumes the builder and constructs a [`ManagedRuleGroupConfig`](crate::model::ManagedRuleGroupConfig)
        pub fn build(self) -> crate::model::ManagedRuleGroupConfig {
            crate::model::ManagedRuleGroupConfig {
                login_path: self.login_path,
                payload_type: self.payload_type,
                username_field: self.username_field,
                password_field: self.password_field,
            }
        }
    }
}
impl ManagedRuleGroupConfig {
    /// Creates a new builder-style object to manufacture [`ManagedRuleGroupConfig`](crate::model::ManagedRuleGroupConfig)
    pub fn builder() -> crate::model::managed_rule_group_config::Builder {
        crate::model::managed_rule_group_config::Builder::default()
    }
}

/// <p>Details about your login page password field, used in a <code>ManagedRuleGroupConfig</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PasswordField {
    /// <p>The name of the password field. For example <code>/form/password</code>.</p>
    pub identifier: std::option::Option<std::string::String>,
}
impl PasswordField {
    /// <p>The name of the password field. For example <code>/form/password</code>.</p>
    pub fn identifier(&self) -> std::option::Option<&str> {
        self.identifier.as_deref()
    }
}
impl std::fmt::Debug for PasswordField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PasswordField");
        formatter.field("identifier", &self.identifier);
        formatter.finish()
    }
}
/// See [`PasswordField`](crate::model::PasswordField)
pub mod password_field {
    /// A builder for [`PasswordField`](crate::model::PasswordField)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identifier: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the password field. For example <code>/form/password</code>.</p>
        pub fn identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.identifier = Some(input.into());
            self
        }
        /// <p>The name of the password field. For example <code>/form/password</code>.</p>
        pub fn set_identifier(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.identifier = input;
            self
        }
        /// Consumes the builder and constructs a [`PasswordField`](crate::model::PasswordField)
        pub fn build(self) -> crate::model::PasswordField {
            crate::model::PasswordField {
                identifier: self.identifier,
            }
        }
    }
}
impl PasswordField {
    /// Creates a new builder-style object to manufacture [`PasswordField`](crate::model::PasswordField)
    pub fn builder() -> crate::model::password_field::Builder {
        crate::model::password_field::Builder::default()
    }
}

/// <p>Details about your login page username field, used in a <code>ManagedRuleGroupConfig</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UsernameField {
    /// <p>The name of the username field. For example <code>/form/username</code>.</p>
    pub identifier: std::option::Option<std::string::String>,
}
impl UsernameField {
    /// <p>The name of the username field. For example <code>/form/username</code>.</p>
    pub fn identifier(&self) -> std::option::Option<&str> {
        self.identifier.as_deref()
    }
}
impl std::fmt::Debug for UsernameField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UsernameField");
        formatter.field("identifier", &self.identifier);
        formatter.finish()
    }
}
/// See [`UsernameField`](crate::model::UsernameField)
pub mod username_field {
    /// A builder for [`UsernameField`](crate::model::UsernameField)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identifier: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the username field. For example <code>/form/username</code>.</p>
        pub fn identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.identifier = Some(input.into());
            self
        }
        /// <p>The name of the username field. For example <code>/form/username</code>.</p>
        pub fn set_identifier(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.identifier = input;
            self
        }
        /// Consumes the builder and constructs a [`UsernameField`](crate::model::UsernameField)
        pub fn build(self) -> crate::model::UsernameField {
            crate::model::UsernameField {
                identifier: self.identifier,
            }
        }
    }
}
impl UsernameField {
    /// Creates a new builder-style object to manufacture [`UsernameField`](crate::model::UsernameField)
    pub fn builder() -> crate::model::username_field::Builder {
        crate::model::username_field::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PayloadType {
    #[allow(missing_docs)] // documentation missing in model
    FormEncoded,
    #[allow(missing_docs)] // documentation missing in model
    Json,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PayloadType {
    fn from(s: &str) -> Self {
        match s {
            "FORM_ENCODED" => PayloadType::FormEncoded,
            "JSON" => PayloadType::Json,
            other => PayloadType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PayloadType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PayloadType::from(s))
    }
}
impl PayloadType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PayloadType::FormEncoded => "FORM_ENCODED",
            PayloadType::Json => "JSON",
            PayloadType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["FORM_ENCODED", "JSON"]
    }
}
impl AsRef<str> for PayloadType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies a single rule in a rule group whose action you want to override to <code>Count</code>. When you exclude a rule, WAF evaluates it exactly as it would if the rule action setting were <code>Count</code>. This is a useful option for testing the rules in a rule group without modifying how they handle your web traffic. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExcludedRule {
    /// <p>The name of the rule whose action you want to override to <code>Count</code>.</p>
    pub name: std::option::Option<std::string::String>,
}
impl ExcludedRule {
    /// <p>The name of the rule whose action you want to override to <code>Count</code>.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl std::fmt::Debug for ExcludedRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExcludedRule");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`ExcludedRule`](crate::model::ExcludedRule)
pub mod excluded_rule {
    /// A builder for [`ExcludedRule`](crate::model::ExcludedRule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the rule whose action you want to override to <code>Count</code>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the rule whose action you want to override to <code>Count</code>.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`ExcludedRule`](crate::model::ExcludedRule)
        pub fn build(self) -> crate::model::ExcludedRule {
            crate::model::ExcludedRule { name: self.name }
        }
    }
}
impl ExcludedRule {
    /// Creates a new builder-style object to manufacture [`ExcludedRule`](crate::model::ExcludedRule)
    pub fn builder() -> crate::model::excluded_rule::Builder {
        crate::model::excluded_rule::Builder::default()
    }
}

/// <p>A logical rule statement used to negate the results of another rule statement. You provide one <code>Statement</code> within the <code>NotStatement</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotStatement {
    /// <p>The statement to negate. You can use any statement that can be nested.</p>
    pub statement: std::option::Option<std::boxed::Box<crate::model::Statement>>,
}
impl NotStatement {
    /// <p>The statement to negate. You can use any statement that can be nested.</p>
    pub fn statement(&self) -> std::option::Option<&crate::model::Statement> {
        self.statement.as_deref()
    }
}
impl std::fmt::Debug for NotStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotStatement");
        formatter.field("statement", &self.statement);
        formatter.finish()
    }
}
/// See [`NotStatement`](crate::model::NotStatement)
pub mod not_statement {
    /// A builder for [`NotStatement`](crate::model::NotStatement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) statement: std::option::Option<std::boxed::Box<crate::model::Statement>>,
    }
    impl Builder {
        /// <p>The statement to negate. You can use any statement that can be nested.</p>
        pub fn statement(
            mut self,
            input: impl Into<std::boxed::Box<crate::model::Statement>>,
        ) -> Self {
            self.statement = Some(input.into());
            self
        }
        /// <p>The statement to negate. You can use any statement that can be nested.</p>
        pub fn set_statement(
            mut self,
            input: std::option::Option<std::boxed::Box<crate::model::Statement>>,
        ) -> Self {
            self.statement = input;
            self
        }
        /// Consumes the builder and constructs a [`NotStatement`](crate::model::NotStatement)
        pub fn build(self) -> crate::model::NotStatement {
            crate::model::NotStatement {
                statement: self.statement,
            }
        }
    }
}
impl NotStatement {
    /// Creates a new builder-style object to manufacture [`NotStatement`](crate::model::NotStatement)
    pub fn builder() -> crate::model::not_statement::Builder {
        crate::model::not_statement::Builder::default()
    }
}

/// <p>A logical rule statement used to combine other rule statements with OR logic. You provide more than one <code>Statement</code> within the <code>OrStatement</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OrStatement {
    /// <p>The statements to combine with OR logic. You can use any statements that can be nested.</p>
    pub statements: std::option::Option<std::vec::Vec<crate::model::Statement>>,
}
impl OrStatement {
    /// <p>The statements to combine with OR logic. You can use any statements that can be nested.</p>
    pub fn statements(&self) -> std::option::Option<&[crate::model::Statement]> {
        self.statements.as_deref()
    }
}
impl std::fmt::Debug for OrStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OrStatement");
        formatter.field("statements", &self.statements);
        formatter.finish()
    }
}
/// See [`OrStatement`](crate::model::OrStatement)
pub mod or_statement {
    /// A builder for [`OrStatement`](crate::model::OrStatement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) statements: std::option::Option<std::vec::Vec<crate::model::Statement>>,
    }
    impl Builder {
        /// Appends an item to `statements`.
        ///
        /// To override the contents of this collection use [`set_statements`](Self::set_statements).
        ///
        /// <p>The statements to combine with OR logic. You can use any statements that can be nested.</p>
        pub fn statements(mut self, input: crate::model::Statement) -> Self {
            let mut v = self.statements.unwrap_or_default();
            v.push(input);
            self.statements = Some(v);
            self
        }
        /// <p>The statements to combine with OR logic. You can use any statements that can be nested.</p>
        pub fn set_statements(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Statement>>,
        ) -> Self {
            self.statements = input;
            self
        }
        /// Consumes the builder and constructs a [`OrStatement`](crate::model::OrStatement)
        pub fn build(self) -> crate::model::OrStatement {
            crate::model::OrStatement {
                statements: self.statements,
            }
        }
    }
}
impl OrStatement {
    /// Creates a new builder-style object to manufacture [`OrStatement`](crate::model::OrStatement)
    pub fn builder() -> crate::model::or_statement::Builder {
        crate::model::or_statement::Builder::default()
    }
}

/// <p>A logical rule statement used to combine other rule statements with AND logic. You provide more than one <code>Statement</code> within the <code>AndStatement</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AndStatement {
    /// <p>The statements to combine with AND logic. You can use any statements that can be nested. </p>
    pub statements: std::option::Option<std::vec::Vec<crate::model::Statement>>,
}
impl AndStatement {
    /// <p>The statements to combine with AND logic. You can use any statements that can be nested. </p>
    pub fn statements(&self) -> std::option::Option<&[crate::model::Statement]> {
        self.statements.as_deref()
    }
}
impl std::fmt::Debug for AndStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AndStatement");
        formatter.field("statements", &self.statements);
        formatter.finish()
    }
}
/// See [`AndStatement`](crate::model::AndStatement)
pub mod and_statement {
    /// A builder for [`AndStatement`](crate::model::AndStatement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) statements: std::option::Option<std::vec::Vec<crate::model::Statement>>,
    }
    impl Builder {
        /// Appends an item to `statements`.
        ///
        /// To override the contents of this collection use [`set_statements`](Self::set_statements).
        ///
        /// <p>The statements to combine with AND logic. You can use any statements that can be nested. </p>
        pub fn statements(mut self, input: crate::model::Statement) -> Self {
            let mut v = self.statements.unwrap_or_default();
            v.push(input);
            self.statements = Some(v);
            self
        }
        /// <p>The statements to combine with AND logic. You can use any statements that can be nested. </p>
        pub fn set_statements(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Statement>>,
        ) -> Self {
            self.statements = input;
            self
        }
        /// Consumes the builder and constructs a [`AndStatement`](crate::model::AndStatement)
        pub fn build(self) -> crate::model::AndStatement {
            crate::model::AndStatement {
                statements: self.statements,
            }
        }
    }
}
impl AndStatement {
    /// Creates a new builder-style object to manufacture [`AndStatement`](crate::model::AndStatement)
    pub fn builder() -> crate::model::and_statement::Builder {
        crate::model::and_statement::Builder::default()
    }
}

/// <p>A rate-based rule tracks the rate of requests for each originating IP address, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any 5-minute time span. You can use this to put a temporary block on requests from an IP address that is sending excessive requests. </p>
/// <p>WAF tracks and manages web requests separately for each instance of a rate-based rule that you use. For example, if you provide the same rate-based rule settings in two web ACLs, each of the two rule statements represents a separate instance of the rate-based rule and gets its own tracking and management by WAF. If you define a rate-based rule inside a rule group, and then use that rule group in multiple places, each use creates a separate instance of the rate-based rule that gets its own tracking and management by WAF. </p>
/// <p>When the rule action triggers, WAF blocks additional requests from the IP address until the request rate falls below the limit.</p>
/// <p>You can optionally nest another statement inside the rate-based statement, to narrow the scope of the rule so that it only counts requests that match the nested statement. For example, based on recent requests that you have seen from an attacker, you might create a rate-based rule with a nested AND rule statement that contains the following nested statements:</p>
/// <ul>
/// <li> <p>An IP match statement with an IP set that specified the address 192.0.2.44.</p> </li>
/// <li> <p>A string match statement that searches in the User-Agent header for the string BadBot.</p> </li>
/// </ul>
/// <p>In this rate-based rule, you also define a rate limit. For this example, the rate limit is 1,000. Requests that meet both of the conditions in the statements are counted. If the count exceeds 1,000 requests per five minutes, the rule action triggers. Requests that do not meet both conditions are not counted towards the rate limit and are not affected by this rule.</p>
/// <p>You cannot nest a <code>RateBasedStatement</code> inside another statement, for example inside a <code>NotStatement</code> or <code>OrStatement</code>. You can define a <code>RateBasedStatement</code> inside a web ACL and inside a rule group. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RateBasedStatement {
    /// <p>The limit on requests per 5-minute period for a single originating IP address. If the statement includes a <code>ScopeDownStatement</code>, this limit is applied only to the requests that match the statement.</p>
    pub limit: i64,
    /// <p>Setting that indicates how to aggregate the request counts. The options are the following:</p>
    /// <ul>
    /// <li> <p>IP - Aggregate the request counts on the IP address from the web request origin.</p> </li>
    /// <li> <p>FORWARDED_IP - Aggregate the request counts on the first IP address in an HTTP header. If you use this, configure the <code>ForwardedIPConfig</code>, to specify the header to use. </p> </li>
    /// </ul>
    pub aggregate_key_type: std::option::Option<crate::model::RateBasedStatementAggregateKeyType>,
    /// <p>An optional nested statement that narrows the scope of the web requests that are evaluated by the rate-based statement. Requests are only tracked by the rate-based statement if they match the scope-down statement. You can use any nestable <code>Statement</code> in the scope-down statement, and you can nest statements at any level, the same as you can for a rule statement. </p>
    pub scope_down_statement: std::option::Option<std::boxed::Box<crate::model::Statement>>,
    /// <p>The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name. </p> <note>
    /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
    /// </note>
    /// <p>This is required if <code>AggregateKeyType</code> is set to <code>FORWARDED_IP</code>.</p>
    pub forwarded_ip_config: std::option::Option<crate::model::ForwardedIpConfig>,
}
impl RateBasedStatement {
    /// <p>The limit on requests per 5-minute period for a single originating IP address. If the statement includes a <code>ScopeDownStatement</code>, this limit is applied only to the requests that match the statement.</p>
    pub fn limit(&self) -> i64 {
        self.limit
    }
    /// <p>Setting that indicates how to aggregate the request counts. The options are the following:</p>
    /// <ul>
    /// <li> <p>IP - Aggregate the request counts on the IP address from the web request origin.</p> </li>
    /// <li> <p>FORWARDED_IP - Aggregate the request counts on the first IP address in an HTTP header. If you use this, configure the <code>ForwardedIPConfig</code>, to specify the header to use. </p> </li>
    /// </ul>
    pub fn aggregate_key_type(
        &self,
    ) -> std::option::Option<&crate::model::RateBasedStatementAggregateKeyType> {
        self.aggregate_key_type.as_ref()
    }
    /// <p>An optional nested statement that narrows the scope of the web requests that are evaluated by the rate-based statement. Requests are only tracked by the rate-based statement if they match the scope-down statement. You can use any nestable <code>Statement</code> in the scope-down statement, and you can nest statements at any level, the same as you can for a rule statement. </p>
    pub fn scope_down_statement(&self) -> std::option::Option<&crate::model::Statement> {
        self.scope_down_statement.as_deref()
    }
    /// <p>The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name. </p> <note>
    /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
    /// </note>
    /// <p>This is required if <code>AggregateKeyType</code> is set to <code>FORWARDED_IP</code>.</p>
    pub fn forwarded_ip_config(&self) -> std::option::Option<&crate::model::ForwardedIpConfig> {
        self.forwarded_ip_config.as_ref()
    }
}
impl std::fmt::Debug for RateBasedStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RateBasedStatement");
        formatter.field("limit", &self.limit);
        formatter.field("aggregate_key_type", &self.aggregate_key_type);
        formatter.field("scope_down_statement", &self.scope_down_statement);
        formatter.field("forwarded_ip_config", &self.forwarded_ip_config);
        formatter.finish()
    }
}
/// See [`RateBasedStatement`](crate::model::RateBasedStatement)
pub mod rate_based_statement {
    /// A builder for [`RateBasedStatement`](crate::model::RateBasedStatement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) limit: std::option::Option<i64>,
        pub(crate) aggregate_key_type:
            std::option::Option<crate::model::RateBasedStatementAggregateKeyType>,
        pub(crate) scope_down_statement:
            std::option::Option<std::boxed::Box<crate::model::Statement>>,
        pub(crate) forwarded_ip_config: std::option::Option<crate::model::ForwardedIpConfig>,
    }
    impl Builder {
        /// <p>The limit on requests per 5-minute period for a single originating IP address. If the statement includes a <code>ScopeDownStatement</code>, this limit is applied only to the requests that match the statement.</p>
        pub fn limit(mut self, input: i64) -> Self {
            self.limit = Some(input);
            self
        }
        /// <p>The limit on requests per 5-minute period for a single originating IP address. If the statement includes a <code>ScopeDownStatement</code>, this limit is applied only to the requests that match the statement.</p>
        pub fn set_limit(mut self, input: std::option::Option<i64>) -> Self {
            self.limit = input;
            self
        }
        /// <p>Setting that indicates how to aggregate the request counts. The options are the following:</p>
        /// <ul>
        /// <li> <p>IP - Aggregate the request counts on the IP address from the web request origin.</p> </li>
        /// <li> <p>FORWARDED_IP - Aggregate the request counts on the first IP address in an HTTP header. If you use this, configure the <code>ForwardedIPConfig</code>, to specify the header to use. </p> </li>
        /// </ul>
        pub fn aggregate_key_type(
            mut self,
            input: crate::model::RateBasedStatementAggregateKeyType,
        ) -> Self {
            self.aggregate_key_type = Some(input);
            self
        }
        /// <p>Setting that indicates how to aggregate the request counts. The options are the following:</p>
        /// <ul>
        /// <li> <p>IP - Aggregate the request counts on the IP address from the web request origin.</p> </li>
        /// <li> <p>FORWARDED_IP - Aggregate the request counts on the first IP address in an HTTP header. If you use this, configure the <code>ForwardedIPConfig</code>, to specify the header to use. </p> </li>
        /// </ul>
        pub fn set_aggregate_key_type(
            mut self,
            input: std::option::Option<crate::model::RateBasedStatementAggregateKeyType>,
        ) -> Self {
            self.aggregate_key_type = input;
            self
        }
        /// <p>An optional nested statement that narrows the scope of the web requests that are evaluated by the rate-based statement. Requests are only tracked by the rate-based statement if they match the scope-down statement. You can use any nestable <code>Statement</code> in the scope-down statement, and you can nest statements at any level, the same as you can for a rule statement. </p>
        pub fn scope_down_statement(
            mut self,
            input: impl Into<std::boxed::Box<crate::model::Statement>>,
        ) -> Self {
            self.scope_down_statement = Some(input.into());
            self
        }
        /// <p>An optional nested statement that narrows the scope of the web requests that are evaluated by the rate-based statement. Requests are only tracked by the rate-based statement if they match the scope-down statement. You can use any nestable <code>Statement</code> in the scope-down statement, and you can nest statements at any level, the same as you can for a rule statement. </p>
        pub fn set_scope_down_statement(
            mut self,
            input: std::option::Option<std::boxed::Box<crate::model::Statement>>,
        ) -> Self {
            self.scope_down_statement = input;
            self
        }
        /// <p>The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name. </p> <note>
        /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
        /// </note>
        /// <p>This is required if <code>AggregateKeyType</code> is set to <code>FORWARDED_IP</code>.</p>
        pub fn forwarded_ip_config(mut self, input: crate::model::ForwardedIpConfig) -> Self {
            self.forwarded_ip_config = Some(input);
            self
        }
        /// <p>The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name. </p> <note>
        /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
        /// </note>
        /// <p>This is required if <code>AggregateKeyType</code> is set to <code>FORWARDED_IP</code>.</p>
        pub fn set_forwarded_ip_config(
            mut self,
            input: std::option::Option<crate::model::ForwardedIpConfig>,
        ) -> Self {
            self.forwarded_ip_config = input;
            self
        }
        /// Consumes the builder and constructs a [`RateBasedStatement`](crate::model::RateBasedStatement)
        pub fn build(self) -> crate::model::RateBasedStatement {
            crate::model::RateBasedStatement {
                limit: self.limit.unwrap_or_default(),
                aggregate_key_type: self.aggregate_key_type,
                scope_down_statement: self.scope_down_statement,
                forwarded_ip_config: self.forwarded_ip_config,
            }
        }
    }
}
impl RateBasedStatement {
    /// Creates a new builder-style object to manufacture [`RateBasedStatement`](crate::model::RateBasedStatement)
    pub fn builder() -> crate::model::rate_based_statement::Builder {
        crate::model::rate_based_statement::Builder::default()
    }
}

/// <p>The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name. </p> <note>
/// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
/// </note>
/// <p>This configuration is used for <code>GeoMatchStatement</code> and <code>RateBasedStatement</code>. For <code>IPSetReferenceStatement</code>, use <code>IPSetForwardedIPConfig</code> instead. </p>
/// <p>WAF only evaluates the first IP address found in the specified HTTP header. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ForwardedIpConfig {
    /// <p>The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to <code>X-Forwarded-For</code>.</p> <note>
    /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
    /// </note>
    pub header_name: std::option::Option<std::string::String>,
    /// <p>The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.</p> <note>
    /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
    /// </note>
    /// <p>You can specify the following fallback behaviors:</p>
    /// <ul>
    /// <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li>
    /// <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li>
    /// </ul>
    pub fallback_behavior: std::option::Option<crate::model::FallbackBehavior>,
}
impl ForwardedIpConfig {
    /// <p>The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to <code>X-Forwarded-For</code>.</p> <note>
    /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
    /// </note>
    pub fn header_name(&self) -> std::option::Option<&str> {
        self.header_name.as_deref()
    }
    /// <p>The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.</p> <note>
    /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
    /// </note>
    /// <p>You can specify the following fallback behaviors:</p>
    /// <ul>
    /// <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li>
    /// <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li>
    /// </ul>
    pub fn fallback_behavior(&self) -> std::option::Option<&crate::model::FallbackBehavior> {
        self.fallback_behavior.as_ref()
    }
}
impl std::fmt::Debug for ForwardedIpConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ForwardedIpConfig");
        formatter.field("header_name", &self.header_name);
        formatter.field("fallback_behavior", &self.fallback_behavior);
        formatter.finish()
    }
}
/// See [`ForwardedIpConfig`](crate::model::ForwardedIpConfig)
pub mod forwarded_ip_config {
    /// A builder for [`ForwardedIpConfig`](crate::model::ForwardedIpConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) header_name: std::option::Option<std::string::String>,
        pub(crate) fallback_behavior: std::option::Option<crate::model::FallbackBehavior>,
    }
    impl Builder {
        /// <p>The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to <code>X-Forwarded-For</code>.</p> <note>
        /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
        /// </note>
        pub fn header_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.header_name = Some(input.into());
            self
        }
        /// <p>The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to <code>X-Forwarded-For</code>.</p> <note>
        /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
        /// </note>
        pub fn set_header_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.header_name = input;
            self
        }
        /// <p>The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.</p> <note>
        /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
        /// </note>
        /// <p>You can specify the following fallback behaviors:</p>
        /// <ul>
        /// <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li>
        /// <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li>
        /// </ul>
        pub fn fallback_behavior(mut self, input: crate::model::FallbackBehavior) -> Self {
            self.fallback_behavior = Some(input);
            self
        }
        /// <p>The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.</p> <note>
        /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
        /// </note>
        /// <p>You can specify the following fallback behaviors:</p>
        /// <ul>
        /// <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li>
        /// <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li>
        /// </ul>
        pub fn set_fallback_behavior(
            mut self,
            input: std::option::Option<crate::model::FallbackBehavior>,
        ) -> Self {
            self.fallback_behavior = input;
            self
        }
        /// Consumes the builder and constructs a [`ForwardedIpConfig`](crate::model::ForwardedIpConfig)
        pub fn build(self) -> crate::model::ForwardedIpConfig {
            crate::model::ForwardedIpConfig {
                header_name: self.header_name,
                fallback_behavior: self.fallback_behavior,
            }
        }
    }
}
impl ForwardedIpConfig {
    /// Creates a new builder-style object to manufacture [`ForwardedIpConfig`](crate::model::ForwardedIpConfig)
    pub fn builder() -> crate::model::forwarded_ip_config::Builder {
        crate::model::forwarded_ip_config::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FallbackBehavior {
    #[allow(missing_docs)] // documentation missing in model
    Match,
    #[allow(missing_docs)] // documentation missing in model
    NoMatch,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FallbackBehavior {
    fn from(s: &str) -> Self {
        match s {
            "MATCH" => FallbackBehavior::Match,
            "NO_MATCH" => FallbackBehavior::NoMatch,
            other => FallbackBehavior::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FallbackBehavior {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FallbackBehavior::from(s))
    }
}
impl FallbackBehavior {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FallbackBehavior::Match => "MATCH",
            FallbackBehavior::NoMatch => "NO_MATCH",
            FallbackBehavior::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["MATCH", "NO_MATCH"]
    }
}
impl AsRef<str> for FallbackBehavior {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RateBasedStatementAggregateKeyType {
    #[allow(missing_docs)] // documentation missing in model
    ForwardedIp,
    #[allow(missing_docs)] // documentation missing in model
    Ip,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RateBasedStatementAggregateKeyType {
    fn from(s: &str) -> Self {
        match s {
            "FORWARDED_IP" => RateBasedStatementAggregateKeyType::ForwardedIp,
            "IP" => RateBasedStatementAggregateKeyType::Ip,
            other => RateBasedStatementAggregateKeyType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RateBasedStatementAggregateKeyType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RateBasedStatementAggregateKeyType::from(s))
    }
}
impl RateBasedStatementAggregateKeyType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RateBasedStatementAggregateKeyType::ForwardedIp => "FORWARDED_IP",
            RateBasedStatementAggregateKeyType::Ip => "IP",
            RateBasedStatementAggregateKeyType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["FORWARDED_IP", "IP"]
    }
}
impl AsRef<str> for RateBasedStatementAggregateKeyType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A rule statement used to search web request components for matches with regular expressions. To use this, create a <code>RegexPatternSet</code> that specifies the expressions that you want to detect, then use the ARN of that set in this statement. A web request matches the pattern set rule statement if the request component matches any of the patterns in the set. To create a regex pattern set, see <code>CreateRegexPatternSet</code>.</p>
/// <p>Each regex pattern set rule statement references a regex pattern set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, WAF automatically updates all rules that reference it.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegexPatternSetReferenceStatement {
    /// <p>The Amazon Resource Name (ARN) of the <code>RegexPatternSet</code> that this statement references.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The part of a web request that you want WAF to inspect. For more information, see <code>FieldToMatch</code>. </p>
    pub field_to_match: std::option::Option<crate::model::FieldToMatch>,
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, WAF performs all transformations on the content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
    pub text_transformations: std::option::Option<std::vec::Vec<crate::model::TextTransformation>>,
}
impl RegexPatternSetReferenceStatement {
    /// <p>The Amazon Resource Name (ARN) of the <code>RegexPatternSet</code> that this statement references.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The part of a web request that you want WAF to inspect. For more information, see <code>FieldToMatch</code>. </p>
    pub fn field_to_match(&self) -> std::option::Option<&crate::model::FieldToMatch> {
        self.field_to_match.as_ref()
    }
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, WAF performs all transformations on the content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
    pub fn text_transformations(&self) -> std::option::Option<&[crate::model::TextTransformation]> {
        self.text_transformations.as_deref()
    }
}
impl std::fmt::Debug for RegexPatternSetReferenceStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegexPatternSetReferenceStatement");
        formatter.field("arn", &self.arn);
        formatter.field("field_to_match", &self.field_to_match);
        formatter.field("text_transformations", &self.text_transformations);
        formatter.finish()
    }
}
/// See [`RegexPatternSetReferenceStatement`](crate::model::RegexPatternSetReferenceStatement)
pub mod regex_pattern_set_reference_statement {
    /// A builder for [`RegexPatternSetReferenceStatement`](crate::model::RegexPatternSetReferenceStatement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) field_to_match: std::option::Option<crate::model::FieldToMatch>,
        pub(crate) text_transformations:
            std::option::Option<std::vec::Vec<crate::model::TextTransformation>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the <code>RegexPatternSet</code> that this statement references.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the <code>RegexPatternSet</code> that this statement references.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The part of a web request that you want WAF to inspect. For more information, see <code>FieldToMatch</code>. </p>
        pub fn field_to_match(mut self, input: crate::model::FieldToMatch) -> Self {
            self.field_to_match = Some(input);
            self
        }
        /// <p>The part of a web request that you want WAF to inspect. For more information, see <code>FieldToMatch</code>. </p>
        pub fn set_field_to_match(
            mut self,
            input: std::option::Option<crate::model::FieldToMatch>,
        ) -> Self {
            self.field_to_match = input;
            self
        }
        /// Appends an item to `text_transformations`.
        ///
        /// To override the contents of this collection use [`set_text_transformations`](Self::set_text_transformations).
        ///
        /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, WAF performs all transformations on the content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
        pub fn text_transformations(mut self, input: crate::model::TextTransformation) -> Self {
            let mut v = self.text_transformations.unwrap_or_default();
            v.push(input);
            self.text_transformations = Some(v);
            self
        }
        /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, WAF performs all transformations on the content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
        pub fn set_text_transformations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TextTransformation>>,
        ) -> Self {
            self.text_transformations = input;
            self
        }
        /// Consumes the builder and constructs a [`RegexPatternSetReferenceStatement`](crate::model::RegexPatternSetReferenceStatement)
        pub fn build(self) -> crate::model::RegexPatternSetReferenceStatement {
            crate::model::RegexPatternSetReferenceStatement {
                arn: self.arn,
                field_to_match: self.field_to_match,
                text_transformations: self.text_transformations,
            }
        }
    }
}
impl RegexPatternSetReferenceStatement {
    /// Creates a new builder-style object to manufacture [`RegexPatternSetReferenceStatement`](crate::model::RegexPatternSetReferenceStatement)
    pub fn builder() -> crate::model::regex_pattern_set_reference_statement::Builder {
        crate::model::regex_pattern_set_reference_statement::Builder::default()
    }
}

/// <p>A rule statement used to detect web requests coming from particular IP addresses or address ranges. To use this, create an <code>IPSet</code> that specifies the addresses you want to detect, then use the ARN of that set in this statement. To create an IP set, see <code>CreateIPSet</code>.</p>
/// <p>Each IP set rule statement references an IP set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, WAF automatically updates all rules that reference it.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IpSetReferenceStatement {
    /// <p>The Amazon Resource Name (ARN) of the <code>IPSet</code> that this statement references.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name. </p> <note>
    /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
    /// </note>
    pub ip_set_forwarded_ip_config: std::option::Option<crate::model::IpSetForwardedIpConfig>,
}
impl IpSetReferenceStatement {
    /// <p>The Amazon Resource Name (ARN) of the <code>IPSet</code> that this statement references.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name. </p> <note>
    /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
    /// </note>
    pub fn ip_set_forwarded_ip_config(
        &self,
    ) -> std::option::Option<&crate::model::IpSetForwardedIpConfig> {
        self.ip_set_forwarded_ip_config.as_ref()
    }
}
impl std::fmt::Debug for IpSetReferenceStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IpSetReferenceStatement");
        formatter.field("arn", &self.arn);
        formatter.field(
            "ip_set_forwarded_ip_config",
            &self.ip_set_forwarded_ip_config,
        );
        formatter.finish()
    }
}
/// See [`IpSetReferenceStatement`](crate::model::IpSetReferenceStatement)
pub mod ip_set_reference_statement {
    /// A builder for [`IpSetReferenceStatement`](crate::model::IpSetReferenceStatement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) ip_set_forwarded_ip_config:
            std::option::Option<crate::model::IpSetForwardedIpConfig>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the <code>IPSet</code> that this statement references.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the <code>IPSet</code> that this statement references.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name. </p> <note>
        /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
        /// </note>
        pub fn ip_set_forwarded_ip_config(
            mut self,
            input: crate::model::IpSetForwardedIpConfig,
        ) -> Self {
            self.ip_set_forwarded_ip_config = Some(input);
            self
        }
        /// <p>The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name. </p> <note>
        /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
        /// </note>
        pub fn set_ip_set_forwarded_ip_config(
            mut self,
            input: std::option::Option<crate::model::IpSetForwardedIpConfig>,
        ) -> Self {
            self.ip_set_forwarded_ip_config = input;
            self
        }
        /// Consumes the builder and constructs a [`IpSetReferenceStatement`](crate::model::IpSetReferenceStatement)
        pub fn build(self) -> crate::model::IpSetReferenceStatement {
            crate::model::IpSetReferenceStatement {
                arn: self.arn,
                ip_set_forwarded_ip_config: self.ip_set_forwarded_ip_config,
            }
        }
    }
}
impl IpSetReferenceStatement {
    /// Creates a new builder-style object to manufacture [`IpSetReferenceStatement`](crate::model::IpSetReferenceStatement)
    pub fn builder() -> crate::model::ip_set_reference_statement::Builder {
        crate::model::ip_set_reference_statement::Builder::default()
    }
}

/// <p>The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name. </p> <note>
/// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
/// </note>
/// <p>This configuration is used only for <code>IPSetReferenceStatement</code>. For <code>GeoMatchStatement</code> and <code>RateBasedStatement</code>, use <code>ForwardedIPConfig</code> instead. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IpSetForwardedIpConfig {
    /// <p>The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to <code>X-Forwarded-For</code>.</p> <note>
    /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
    /// </note>
    pub header_name: std::option::Option<std::string::String>,
    /// <p>The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.</p> <note>
    /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
    /// </note>
    /// <p>You can specify the following fallback behaviors:</p>
    /// <ul>
    /// <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li>
    /// <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li>
    /// </ul>
    pub fallback_behavior: std::option::Option<crate::model::FallbackBehavior>,
    /// <p>The position in the header to search for the IP address. The header can contain IP addresses of the original client and also of proxies. For example, the header value could be <code>10.1.1.1, 127.0.0.0, 10.10.10.10</code> where the first IP address identifies the original client and the rest identify proxies that the request went through. </p>
    /// <p>The options for this setting are the following: </p>
    /// <ul>
    /// <li> <p>FIRST - Inspect the first IP address in the list of IP addresses in the header. This is usually the client's original IP.</p> </li>
    /// <li> <p>LAST - Inspect the last IP address in the list of IP addresses in the header.</p> </li>
    /// <li> <p>ANY - Inspect all IP addresses in the header for a match. If the header contains more than 10 IP addresses, WAF inspects the last 10.</p> </li>
    /// </ul>
    pub position: std::option::Option<crate::model::ForwardedIpPosition>,
}
impl IpSetForwardedIpConfig {
    /// <p>The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to <code>X-Forwarded-For</code>.</p> <note>
    /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
    /// </note>
    pub fn header_name(&self) -> std::option::Option<&str> {
        self.header_name.as_deref()
    }
    /// <p>The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.</p> <note>
    /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
    /// </note>
    /// <p>You can specify the following fallback behaviors:</p>
    /// <ul>
    /// <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li>
    /// <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li>
    /// </ul>
    pub fn fallback_behavior(&self) -> std::option::Option<&crate::model::FallbackBehavior> {
        self.fallback_behavior.as_ref()
    }
    /// <p>The position in the header to search for the IP address. The header can contain IP addresses of the original client and also of proxies. For example, the header value could be <code>10.1.1.1, 127.0.0.0, 10.10.10.10</code> where the first IP address identifies the original client and the rest identify proxies that the request went through. </p>
    /// <p>The options for this setting are the following: </p>
    /// <ul>
    /// <li> <p>FIRST - Inspect the first IP address in the list of IP addresses in the header. This is usually the client's original IP.</p> </li>
    /// <li> <p>LAST - Inspect the last IP address in the list of IP addresses in the header.</p> </li>
    /// <li> <p>ANY - Inspect all IP addresses in the header for a match. If the header contains more than 10 IP addresses, WAF inspects the last 10.</p> </li>
    /// </ul>
    pub fn position(&self) -> std::option::Option<&crate::model::ForwardedIpPosition> {
        self.position.as_ref()
    }
}
impl std::fmt::Debug for IpSetForwardedIpConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IpSetForwardedIpConfig");
        formatter.field("header_name", &self.header_name);
        formatter.field("fallback_behavior", &self.fallback_behavior);
        formatter.field("position", &self.position);
        formatter.finish()
    }
}
/// See [`IpSetForwardedIpConfig`](crate::model::IpSetForwardedIpConfig)
pub mod ip_set_forwarded_ip_config {
    /// A builder for [`IpSetForwardedIpConfig`](crate::model::IpSetForwardedIpConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) header_name: std::option::Option<std::string::String>,
        pub(crate) fallback_behavior: std::option::Option<crate::model::FallbackBehavior>,
        pub(crate) position: std::option::Option<crate::model::ForwardedIpPosition>,
    }
    impl Builder {
        /// <p>The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to <code>X-Forwarded-For</code>.</p> <note>
        /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
        /// </note>
        pub fn header_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.header_name = Some(input.into());
            self
        }
        /// <p>The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to <code>X-Forwarded-For</code>.</p> <note>
        /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
        /// </note>
        pub fn set_header_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.header_name = input;
            self
        }
        /// <p>The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.</p> <note>
        /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
        /// </note>
        /// <p>You can specify the following fallback behaviors:</p>
        /// <ul>
        /// <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li>
        /// <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li>
        /// </ul>
        pub fn fallback_behavior(mut self, input: crate::model::FallbackBehavior) -> Self {
            self.fallback_behavior = Some(input);
            self
        }
        /// <p>The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.</p> <note>
        /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
        /// </note>
        /// <p>You can specify the following fallback behaviors:</p>
        /// <ul>
        /// <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li>
        /// <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li>
        /// </ul>
        pub fn set_fallback_behavior(
            mut self,
            input: std::option::Option<crate::model::FallbackBehavior>,
        ) -> Self {
            self.fallback_behavior = input;
            self
        }
        /// <p>The position in the header to search for the IP address. The header can contain IP addresses of the original client and also of proxies. For example, the header value could be <code>10.1.1.1, 127.0.0.0, 10.10.10.10</code> where the first IP address identifies the original client and the rest identify proxies that the request went through. </p>
        /// <p>The options for this setting are the following: </p>
        /// <ul>
        /// <li> <p>FIRST - Inspect the first IP address in the list of IP addresses in the header. This is usually the client's original IP.</p> </li>
        /// <li> <p>LAST - Inspect the last IP address in the list of IP addresses in the header.</p> </li>
        /// <li> <p>ANY - Inspect all IP addresses in the header for a match. If the header contains more than 10 IP addresses, WAF inspects the last 10.</p> </li>
        /// </ul>
        pub fn position(mut self, input: crate::model::ForwardedIpPosition) -> Self {
            self.position = Some(input);
            self
        }
        /// <p>The position in the header to search for the IP address. The header can contain IP addresses of the original client and also of proxies. For example, the header value could be <code>10.1.1.1, 127.0.0.0, 10.10.10.10</code> where the first IP address identifies the original client and the rest identify proxies that the request went through. </p>
        /// <p>The options for this setting are the following: </p>
        /// <ul>
        /// <li> <p>FIRST - Inspect the first IP address in the list of IP addresses in the header. This is usually the client's original IP.</p> </li>
        /// <li> <p>LAST - Inspect the last IP address in the list of IP addresses in the header.</p> </li>
        /// <li> <p>ANY - Inspect all IP addresses in the header for a match. If the header contains more than 10 IP addresses, WAF inspects the last 10.</p> </li>
        /// </ul>
        pub fn set_position(
            mut self,
            input: std::option::Option<crate::model::ForwardedIpPosition>,
        ) -> Self {
            self.position = input;
            self
        }
        /// Consumes the builder and constructs a [`IpSetForwardedIpConfig`](crate::model::IpSetForwardedIpConfig)
        pub fn build(self) -> crate::model::IpSetForwardedIpConfig {
            crate::model::IpSetForwardedIpConfig {
                header_name: self.header_name,
                fallback_behavior: self.fallback_behavior,
                position: self.position,
            }
        }
    }
}
impl IpSetForwardedIpConfig {
    /// Creates a new builder-style object to manufacture [`IpSetForwardedIpConfig`](crate::model::IpSetForwardedIpConfig)
    pub fn builder() -> crate::model::ip_set_forwarded_ip_config::Builder {
        crate::model::ip_set_forwarded_ip_config::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ForwardedIpPosition {
    #[allow(missing_docs)] // documentation missing in model
    Any,
    #[allow(missing_docs)] // documentation missing in model
    First,
    #[allow(missing_docs)] // documentation missing in model
    Last,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ForwardedIpPosition {
    fn from(s: &str) -> Self {
        match s {
            "ANY" => ForwardedIpPosition::Any,
            "FIRST" => ForwardedIpPosition::First,
            "LAST" => ForwardedIpPosition::Last,
            other => ForwardedIpPosition::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ForwardedIpPosition {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ForwardedIpPosition::from(s))
    }
}
impl ForwardedIpPosition {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ForwardedIpPosition::Any => "ANY",
            ForwardedIpPosition::First => "FIRST",
            ForwardedIpPosition::Last => "LAST",
            ForwardedIpPosition::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ANY", "FIRST", "LAST"]
    }
}
impl AsRef<str> for ForwardedIpPosition {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A rule statement used to run the rules that are defined in a <code>RuleGroup</code>. To use this, create a rule group with your rules, then provide the ARN of the rule group in this statement.</p>
/// <p>You cannot nest a <code>RuleGroupReferenceStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. You can only use a rule group reference statement at the top level inside a web ACL. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuleGroupReferenceStatement {
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The rules in the referenced rule group whose actions are set to <code>Count</code>. When you exclude a rule, WAF evaluates it exactly as it would if the rule action setting were <code>Count</code>. This is a useful option for testing the rules in a rule group without modifying how they handle your web traffic.</p>
    pub excluded_rules: std::option::Option<std::vec::Vec<crate::model::ExcludedRule>>,
}
impl RuleGroupReferenceStatement {
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The rules in the referenced rule group whose actions are set to <code>Count</code>. When you exclude a rule, WAF evaluates it exactly as it would if the rule action setting were <code>Count</code>. This is a useful option for testing the rules in a rule group without modifying how they handle your web traffic.</p>
    pub fn excluded_rules(&self) -> std::option::Option<&[crate::model::ExcludedRule]> {
        self.excluded_rules.as_deref()
    }
}
impl std::fmt::Debug for RuleGroupReferenceStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RuleGroupReferenceStatement");
        formatter.field("arn", &self.arn);
        formatter.field("excluded_rules", &self.excluded_rules);
        formatter.finish()
    }
}
/// See [`RuleGroupReferenceStatement`](crate::model::RuleGroupReferenceStatement)
pub mod rule_group_reference_statement {
    /// A builder for [`RuleGroupReferenceStatement`](crate::model::RuleGroupReferenceStatement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) excluded_rules: std::option::Option<std::vec::Vec<crate::model::ExcludedRule>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the entity.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entity.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Appends an item to `excluded_rules`.
        ///
        /// To override the contents of this collection use [`set_excluded_rules`](Self::set_excluded_rules).
        ///
        /// <p>The rules in the referenced rule group whose actions are set to <code>Count</code>. When you exclude a rule, WAF evaluates it exactly as it would if the rule action setting were <code>Count</code>. This is a useful option for testing the rules in a rule group without modifying how they handle your web traffic.</p>
        pub fn excluded_rules(mut self, input: crate::model::ExcludedRule) -> Self {
            let mut v = self.excluded_rules.unwrap_or_default();
            v.push(input);
            self.excluded_rules = Some(v);
            self
        }
        /// <p>The rules in the referenced rule group whose actions are set to <code>Count</code>. When you exclude a rule, WAF evaluates it exactly as it would if the rule action setting were <code>Count</code>. This is a useful option for testing the rules in a rule group without modifying how they handle your web traffic.</p>
        pub fn set_excluded_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ExcludedRule>>,
        ) -> Self {
            self.excluded_rules = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleGroupReferenceStatement`](crate::model::RuleGroupReferenceStatement)
        pub fn build(self) -> crate::model::RuleGroupReferenceStatement {
            crate::model::RuleGroupReferenceStatement {
                arn: self.arn,
                excluded_rules: self.excluded_rules,
            }
        }
    }
}
impl RuleGroupReferenceStatement {
    /// Creates a new builder-style object to manufacture [`RuleGroupReferenceStatement`](crate::model::RuleGroupReferenceStatement)
    pub fn builder() -> crate::model::rule_group_reference_statement::Builder {
        crate::model::rule_group_reference_statement::Builder::default()
    }
}

/// <p>A rule statement used to identify web requests based on country of origin. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GeoMatchStatement {
    /// <p>An array of two-character country codes, for example, <code>[ "US", "CN" ]</code>, from the alpha-2 country ISO codes of the ISO 3166 international standard. </p>
    pub country_codes: std::option::Option<std::vec::Vec<crate::model::CountryCode>>,
    /// <p>The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name. </p> <note>
    /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
    /// </note>
    pub forwarded_ip_config: std::option::Option<crate::model::ForwardedIpConfig>,
}
impl GeoMatchStatement {
    /// <p>An array of two-character country codes, for example, <code>[ "US", "CN" ]</code>, from the alpha-2 country ISO codes of the ISO 3166 international standard. </p>
    pub fn country_codes(&self) -> std::option::Option<&[crate::model::CountryCode]> {
        self.country_codes.as_deref()
    }
    /// <p>The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name. </p> <note>
    /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
    /// </note>
    pub fn forwarded_ip_config(&self) -> std::option::Option<&crate::model::ForwardedIpConfig> {
        self.forwarded_ip_config.as_ref()
    }
}
impl std::fmt::Debug for GeoMatchStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GeoMatchStatement");
        formatter.field("country_codes", &self.country_codes);
        formatter.field("forwarded_ip_config", &self.forwarded_ip_config);
        formatter.finish()
    }
}
/// See [`GeoMatchStatement`](crate::model::GeoMatchStatement)
pub mod geo_match_statement {
    /// A builder for [`GeoMatchStatement`](crate::model::GeoMatchStatement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) country_codes: std::option::Option<std::vec::Vec<crate::model::CountryCode>>,
        pub(crate) forwarded_ip_config: std::option::Option<crate::model::ForwardedIpConfig>,
    }
    impl Builder {
        /// Appends an item to `country_codes`.
        ///
        /// To override the contents of this collection use [`set_country_codes`](Self::set_country_codes).
        ///
        /// <p>An array of two-character country codes, for example, <code>[ "US", "CN" ]</code>, from the alpha-2 country ISO codes of the ISO 3166 international standard. </p>
        pub fn country_codes(mut self, input: crate::model::CountryCode) -> Self {
            let mut v = self.country_codes.unwrap_or_default();
            v.push(input);
            self.country_codes = Some(v);
            self
        }
        /// <p>An array of two-character country codes, for example, <code>[ "US", "CN" ]</code>, from the alpha-2 country ISO codes of the ISO 3166 international standard. </p>
        pub fn set_country_codes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CountryCode>>,
        ) -> Self {
            self.country_codes = input;
            self
        }
        /// <p>The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name. </p> <note>
        /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
        /// </note>
        pub fn forwarded_ip_config(mut self, input: crate::model::ForwardedIpConfig) -> Self {
            self.forwarded_ip_config = Some(input);
            self
        }
        /// <p>The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name. </p> <note>
        /// <p>If the specified header isn't present in the request, WAF doesn't apply the rule to the web request at all.</p>
        /// </note>
        pub fn set_forwarded_ip_config(
            mut self,
            input: std::option::Option<crate::model::ForwardedIpConfig>,
        ) -> Self {
            self.forwarded_ip_config = input;
            self
        }
        /// Consumes the builder and constructs a [`GeoMatchStatement`](crate::model::GeoMatchStatement)
        pub fn build(self) -> crate::model::GeoMatchStatement {
            crate::model::GeoMatchStatement {
                country_codes: self.country_codes,
                forwarded_ip_config: self.forwarded_ip_config,
            }
        }
    }
}
impl GeoMatchStatement {
    /// Creates a new builder-style object to manufacture [`GeoMatchStatement`](crate::model::GeoMatchStatement)
    pub fn builder() -> crate::model::geo_match_statement::Builder {
        crate::model::geo_match_statement::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CountryCode {
    #[allow(missing_docs)] // documentation missing in model
    Ad,
    #[allow(missing_docs)] // documentation missing in model
    Ae,
    #[allow(missing_docs)] // documentation missing in model
    Af,
    #[allow(missing_docs)] // documentation missing in model
    Ag,
    #[allow(missing_docs)] // documentation missing in model
    Ai,
    #[allow(missing_docs)] // documentation missing in model
    Al,
    #[allow(missing_docs)] // documentation missing in model
    Am,
    #[allow(missing_docs)] // documentation missing in model
    Ao,
    #[allow(missing_docs)] // documentation missing in model
    Aq,
    #[allow(missing_docs)] // documentation missing in model
    Ar,
    #[allow(missing_docs)] // documentation missing in model
    As,
    #[allow(missing_docs)] // documentation missing in model
    At,
    #[allow(missing_docs)] // documentation missing in model
    Au,
    #[allow(missing_docs)] // documentation missing in model
    Aw,
    #[allow(missing_docs)] // documentation missing in model
    Ax,
    #[allow(missing_docs)] // documentation missing in model
    Az,
    #[allow(missing_docs)] // documentation missing in model
    Ba,
    #[allow(missing_docs)] // documentation missing in model
    Bb,
    #[allow(missing_docs)] // documentation missing in model
    Bd,
    #[allow(missing_docs)] // documentation missing in model
    Be,
    #[allow(missing_docs)] // documentation missing in model
    Bf,
    #[allow(missing_docs)] // documentation missing in model
    Bg,
    #[allow(missing_docs)] // documentation missing in model
    Bh,
    #[allow(missing_docs)] // documentation missing in model
    Bi,
    #[allow(missing_docs)] // documentation missing in model
    Bj,
    #[allow(missing_docs)] // documentation missing in model
    Bl,
    #[allow(missing_docs)] // documentation missing in model
    Bm,
    #[allow(missing_docs)] // documentation missing in model
    Bn,
    #[allow(missing_docs)] // documentation missing in model
    Bo,
    #[allow(missing_docs)] // documentation missing in model
    Bq,
    #[allow(missing_docs)] // documentation missing in model
    Br,
    #[allow(missing_docs)] // documentation missing in model
    Bs,
    #[allow(missing_docs)] // documentation missing in model
    Bt,
    #[allow(missing_docs)] // documentation missing in model
    Bv,
    #[allow(missing_docs)] // documentation missing in model
    Bw,
    #[allow(missing_docs)] // documentation missing in model
    By,
    #[allow(missing_docs)] // documentation missing in model
    Bz,
    #[allow(missing_docs)] // documentation missing in model
    Ca,
    #[allow(missing_docs)] // documentation missing in model
    Cc,
    #[allow(missing_docs)] // documentation missing in model
    Cd,
    #[allow(missing_docs)] // documentation missing in model
    Cf,
    #[allow(missing_docs)] // documentation missing in model
    Cg,
    #[allow(missing_docs)] // documentation missing in model
    Ch,
    #[allow(missing_docs)] // documentation missing in model
    Ci,
    #[allow(missing_docs)] // documentation missing in model
    Ck,
    #[allow(missing_docs)] // documentation missing in model
    Cl,
    #[allow(missing_docs)] // documentation missing in model
    Cm,
    #[allow(missing_docs)] // documentation missing in model
    Cn,
    #[allow(missing_docs)] // documentation missing in model
    Co,
    #[allow(missing_docs)] // documentation missing in model
    Cr,
    #[allow(missing_docs)] // documentation missing in model
    Cu,
    #[allow(missing_docs)] // documentation missing in model
    Cv,
    #[allow(missing_docs)] // documentation missing in model
    Cw,
    #[allow(missing_docs)] // documentation missing in model
    Cx,
    #[allow(missing_docs)] // documentation missing in model
    Cy,
    #[allow(missing_docs)] // documentation missing in model
    Cz,
    #[allow(missing_docs)] // documentation missing in model
    De,
    #[allow(missing_docs)] // documentation missing in model
    Dj,
    #[allow(missing_docs)] // documentation missing in model
    Dk,
    #[allow(missing_docs)] // documentation missing in model
    Dm,
    #[allow(missing_docs)] // documentation missing in model
    Do,
    #[allow(missing_docs)] // documentation missing in model
    Dz,
    #[allow(missing_docs)] // documentation missing in model
    Ec,
    #[allow(missing_docs)] // documentation missing in model
    Ee,
    #[allow(missing_docs)] // documentation missing in model
    Eg,
    #[allow(missing_docs)] // documentation missing in model
    Eh,
    #[allow(missing_docs)] // documentation missing in model
    Er,
    #[allow(missing_docs)] // documentation missing in model
    Es,
    #[allow(missing_docs)] // documentation missing in model
    Et,
    #[allow(missing_docs)] // documentation missing in model
    Fi,
    #[allow(missing_docs)] // documentation missing in model
    Fj,
    #[allow(missing_docs)] // documentation missing in model
    Fk,
    #[allow(missing_docs)] // documentation missing in model
    Fm,
    #[allow(missing_docs)] // documentation missing in model
    Fo,
    #[allow(missing_docs)] // documentation missing in model
    Fr,
    #[allow(missing_docs)] // documentation missing in model
    Ga,
    #[allow(missing_docs)] // documentation missing in model
    Gb,
    #[allow(missing_docs)] // documentation missing in model
    Gd,
    #[allow(missing_docs)] // documentation missing in model
    Ge,
    #[allow(missing_docs)] // documentation missing in model
    Gf,
    #[allow(missing_docs)] // documentation missing in model
    Gg,
    #[allow(missing_docs)] // documentation missing in model
    Gh,
    #[allow(missing_docs)] // documentation missing in model
    Gi,
    #[allow(missing_docs)] // documentation missing in model
    Gl,
    #[allow(missing_docs)] // documentation missing in model
    Gm,
    #[allow(missing_docs)] // documentation missing in model
    Gn,
    #[allow(missing_docs)] // documentation missing in model
    Gp,
    #[allow(missing_docs)] // documentation missing in model
    Gq,
    #[allow(missing_docs)] // documentation missing in model
    Gr,
    #[allow(missing_docs)] // documentation missing in model
    Gs,
    #[allow(missing_docs)] // documentation missing in model
    Gt,
    #[allow(missing_docs)] // documentation missing in model
    Gu,
    #[allow(missing_docs)] // documentation missing in model
    Gw,
    #[allow(missing_docs)] // documentation missing in model
    Gy,
    #[allow(missing_docs)] // documentation missing in model
    Hk,
    #[allow(missing_docs)] // documentation missing in model
    Hm,
    #[allow(missing_docs)] // documentation missing in model
    Hn,
    #[allow(missing_docs)] // documentation missing in model
    Hr,
    #[allow(missing_docs)] // documentation missing in model
    Ht,
    #[allow(missing_docs)] // documentation missing in model
    Hu,
    #[allow(missing_docs)] // documentation missing in model
    Id,
    #[allow(missing_docs)] // documentation missing in model
    Ie,
    #[allow(missing_docs)] // documentation missing in model
    Il,
    #[allow(missing_docs)] // documentation missing in model
    Im,
    #[allow(missing_docs)] // documentation missing in model
    In,
    #[allow(missing_docs)] // documentation missing in model
    Io,
    #[allow(missing_docs)] // documentation missing in model
    Iq,
    #[allow(missing_docs)] // documentation missing in model
    Ir,
    #[allow(missing_docs)] // documentation missing in model
    Is,
    #[allow(missing_docs)] // documentation missing in model
    It,
    #[allow(missing_docs)] // documentation missing in model
    Je,
    #[allow(missing_docs)] // documentation missing in model
    Jm,
    #[allow(missing_docs)] // documentation missing in model
    Jo,
    #[allow(missing_docs)] // documentation missing in model
    Jp,
    #[allow(missing_docs)] // documentation missing in model
    Ke,
    #[allow(missing_docs)] // documentation missing in model
    Kg,
    #[allow(missing_docs)] // documentation missing in model
    Kh,
    #[allow(missing_docs)] // documentation missing in model
    Ki,
    #[allow(missing_docs)] // documentation missing in model
    Km,
    #[allow(missing_docs)] // documentation missing in model
    Kn,
    #[allow(missing_docs)] // documentation missing in model
    Kp,
    #[allow(missing_docs)] // documentation missing in model
    Kr,
    #[allow(missing_docs)] // documentation missing in model
    Kw,
    #[allow(missing_docs)] // documentation missing in model
    Ky,
    #[allow(missing_docs)] // documentation missing in model
    Kz,
    #[allow(missing_docs)] // documentation missing in model
    La,
    #[allow(missing_docs)] // documentation missing in model
    Lb,
    #[allow(missing_docs)] // documentation missing in model
    Lc,
    #[allow(missing_docs)] // documentation missing in model
    Li,
    #[allow(missing_docs)] // documentation missing in model
    Lk,
    #[allow(missing_docs)] // documentation missing in model
    Lr,
    #[allow(missing_docs)] // documentation missing in model
    Ls,
    #[allow(missing_docs)] // documentation missing in model
    Lt,
    #[allow(missing_docs)] // documentation missing in model
    Lu,
    #[allow(missing_docs)] // documentation missing in model
    Lv,
    #[allow(missing_docs)] // documentation missing in model
    Ly,
    #[allow(missing_docs)] // documentation missing in model
    Ma,
    #[allow(missing_docs)] // documentation missing in model
    Mc,
    #[allow(missing_docs)] // documentation missing in model
    Md,
    #[allow(missing_docs)] // documentation missing in model
    Me,
    #[allow(missing_docs)] // documentation missing in model
    Mf,
    #[allow(missing_docs)] // documentation missing in model
    Mg,
    #[allow(missing_docs)] // documentation missing in model
    Mh,
    #[allow(missing_docs)] // documentation missing in model
    Mk,
    #[allow(missing_docs)] // documentation missing in model
    Ml,
    #[allow(missing_docs)] // documentation missing in model
    Mm,
    #[allow(missing_docs)] // documentation missing in model
    Mn,
    #[allow(missing_docs)] // documentation missing in model
    Mo,
    #[allow(missing_docs)] // documentation missing in model
    Mp,
    #[allow(missing_docs)] // documentation missing in model
    Mq,
    #[allow(missing_docs)] // documentation missing in model
    Mr,
    #[allow(missing_docs)] // documentation missing in model
    Ms,
    #[allow(missing_docs)] // documentation missing in model
    Mt,
    #[allow(missing_docs)] // documentation missing in model
    Mu,
    #[allow(missing_docs)] // documentation missing in model
    Mv,
    #[allow(missing_docs)] // documentation missing in model
    Mw,
    #[allow(missing_docs)] // documentation missing in model
    Mx,
    #[allow(missing_docs)] // documentation missing in model
    My,
    #[allow(missing_docs)] // documentation missing in model
    Mz,
    #[allow(missing_docs)] // documentation missing in model
    Na,
    #[allow(missing_docs)] // documentation missing in model
    Nc,
    #[allow(missing_docs)] // documentation missing in model
    Ne,
    #[allow(missing_docs)] // documentation missing in model
    Nf,
    #[allow(missing_docs)] // documentation missing in model
    Ng,
    #[allow(missing_docs)] // documentation missing in model
    Ni,
    #[allow(missing_docs)] // documentation missing in model
    Nl,
    #[allow(missing_docs)] // documentation missing in model
    No,
    #[allow(missing_docs)] // documentation missing in model
    Np,
    #[allow(missing_docs)] // documentation missing in model
    Nr,
    #[allow(missing_docs)] // documentation missing in model
    Nu,
    #[allow(missing_docs)] // documentation missing in model
    Nz,
    #[allow(missing_docs)] // documentation missing in model
    Om,
    #[allow(missing_docs)] // documentation missing in model
    Pa,
    #[allow(missing_docs)] // documentation missing in model
    Pe,
    #[allow(missing_docs)] // documentation missing in model
    Pf,
    #[allow(missing_docs)] // documentation missing in model
    Pg,
    #[allow(missing_docs)] // documentation missing in model
    Ph,
    #[allow(missing_docs)] // documentation missing in model
    Pk,
    #[allow(missing_docs)] // documentation missing in model
    Pl,
    #[allow(missing_docs)] // documentation missing in model
    Pm,
    #[allow(missing_docs)] // documentation missing in model
    Pn,
    #[allow(missing_docs)] // documentation missing in model
    Pr,
    #[allow(missing_docs)] // documentation missing in model
    Ps,
    #[allow(missing_docs)] // documentation missing in model
    Pt,
    #[allow(missing_docs)] // documentation missing in model
    Pw,
    #[allow(missing_docs)] // documentation missing in model
    Py,
    #[allow(missing_docs)] // documentation missing in model
    Qa,
    #[allow(missing_docs)] // documentation missing in model
    Re,
    #[allow(missing_docs)] // documentation missing in model
    Ro,
    #[allow(missing_docs)] // documentation missing in model
    Rs,
    #[allow(missing_docs)] // documentation missing in model
    Ru,
    #[allow(missing_docs)] // documentation missing in model
    Rw,
    #[allow(missing_docs)] // documentation missing in model
    Sa,
    #[allow(missing_docs)] // documentation missing in model
    Sb,
    #[allow(missing_docs)] // documentation missing in model
    Sc,
    #[allow(missing_docs)] // documentation missing in model
    Sd,
    #[allow(missing_docs)] // documentation missing in model
    Se,
    #[allow(missing_docs)] // documentation missing in model
    Sg,
    #[allow(missing_docs)] // documentation missing in model
    Sh,
    #[allow(missing_docs)] // documentation missing in model
    Si,
    #[allow(missing_docs)] // documentation missing in model
    Sj,
    #[allow(missing_docs)] // documentation missing in model
    Sk,
    #[allow(missing_docs)] // documentation missing in model
    Sl,
    #[allow(missing_docs)] // documentation missing in model
    Sm,
    #[allow(missing_docs)] // documentation missing in model
    Sn,
    #[allow(missing_docs)] // documentation missing in model
    So,
    #[allow(missing_docs)] // documentation missing in model
    Sr,
    #[allow(missing_docs)] // documentation missing in model
    Ss,
    #[allow(missing_docs)] // documentation missing in model
    St,
    #[allow(missing_docs)] // documentation missing in model
    Sv,
    #[allow(missing_docs)] // documentation missing in model
    Sx,
    #[allow(missing_docs)] // documentation missing in model
    Sy,
    #[allow(missing_docs)] // documentation missing in model
    Sz,
    #[allow(missing_docs)] // documentation missing in model
    Tc,
    #[allow(missing_docs)] // documentation missing in model
    Td,
    #[allow(missing_docs)] // documentation missing in model
    Tf,
    #[allow(missing_docs)] // documentation missing in model
    Tg,
    #[allow(missing_docs)] // documentation missing in model
    Th,
    #[allow(missing_docs)] // documentation missing in model
    Tj,
    #[allow(missing_docs)] // documentation missing in model
    Tk,
    #[allow(missing_docs)] // documentation missing in model
    Tl,
    #[allow(missing_docs)] // documentation missing in model
    Tm,
    #[allow(missing_docs)] // documentation missing in model
    Tn,
    #[allow(missing_docs)] // documentation missing in model
    To,
    #[allow(missing_docs)] // documentation missing in model
    Tr,
    #[allow(missing_docs)] // documentation missing in model
    Tt,
    #[allow(missing_docs)] // documentation missing in model
    Tv,
    #[allow(missing_docs)] // documentation missing in model
    Tw,
    #[allow(missing_docs)] // documentation missing in model
    Tz,
    #[allow(missing_docs)] // documentation missing in model
    Ua,
    #[allow(missing_docs)] // documentation missing in model
    Ug,
    #[allow(missing_docs)] // documentation missing in model
    Um,
    #[allow(missing_docs)] // documentation missing in model
    Us,
    #[allow(missing_docs)] // documentation missing in model
    Uy,
    #[allow(missing_docs)] // documentation missing in model
    Uz,
    #[allow(missing_docs)] // documentation missing in model
    Va,
    #[allow(missing_docs)] // documentation missing in model
    Vc,
    #[allow(missing_docs)] // documentation missing in model
    Ve,
    #[allow(missing_docs)] // documentation missing in model
    Vg,
    #[allow(missing_docs)] // documentation missing in model
    Vi,
    #[allow(missing_docs)] // documentation missing in model
    Vn,
    #[allow(missing_docs)] // documentation missing in model
    Vu,
    #[allow(missing_docs)] // documentation missing in model
    Wf,
    #[allow(missing_docs)] // documentation missing in model
    Ws,
    #[allow(missing_docs)] // documentation missing in model
    Ye,
    #[allow(missing_docs)] // documentation missing in model
    Yt,
    #[allow(missing_docs)] // documentation missing in model
    Za,
    #[allow(missing_docs)] // documentation missing in model
    Zm,
    #[allow(missing_docs)] // documentation missing in model
    Zw,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CountryCode {
    fn from(s: &str) -> Self {
        match s {
            "AD" => CountryCode::Ad,
            "AE" => CountryCode::Ae,
            "AF" => CountryCode::Af,
            "AG" => CountryCode::Ag,
            "AI" => CountryCode::Ai,
            "AL" => CountryCode::Al,
            "AM" => CountryCode::Am,
            "AO" => CountryCode::Ao,
            "AQ" => CountryCode::Aq,
            "AR" => CountryCode::Ar,
            "AS" => CountryCode::As,
            "AT" => CountryCode::At,
            "AU" => CountryCode::Au,
            "AW" => CountryCode::Aw,
            "AX" => CountryCode::Ax,
            "AZ" => CountryCode::Az,
            "BA" => CountryCode::Ba,
            "BB" => CountryCode::Bb,
            "BD" => CountryCode::Bd,
            "BE" => CountryCode::Be,
            "BF" => CountryCode::Bf,
            "BG" => CountryCode::Bg,
            "BH" => CountryCode::Bh,
            "BI" => CountryCode::Bi,
            "BJ" => CountryCode::Bj,
            "BL" => CountryCode::Bl,
            "BM" => CountryCode::Bm,
            "BN" => CountryCode::Bn,
            "BO" => CountryCode::Bo,
            "BQ" => CountryCode::Bq,
            "BR" => CountryCode::Br,
            "BS" => CountryCode::Bs,
            "BT" => CountryCode::Bt,
            "BV" => CountryCode::Bv,
            "BW" => CountryCode::Bw,
            "BY" => CountryCode::By,
            "BZ" => CountryCode::Bz,
            "CA" => CountryCode::Ca,
            "CC" => CountryCode::Cc,
            "CD" => CountryCode::Cd,
            "CF" => CountryCode::Cf,
            "CG" => CountryCode::Cg,
            "CH" => CountryCode::Ch,
            "CI" => CountryCode::Ci,
            "CK" => CountryCode::Ck,
            "CL" => CountryCode::Cl,
            "CM" => CountryCode::Cm,
            "CN" => CountryCode::Cn,
            "CO" => CountryCode::Co,
            "CR" => CountryCode::Cr,
            "CU" => CountryCode::Cu,
            "CV" => CountryCode::Cv,
            "CW" => CountryCode::Cw,
            "CX" => CountryCode::Cx,
            "CY" => CountryCode::Cy,
            "CZ" => CountryCode::Cz,
            "DE" => CountryCode::De,
            "DJ" => CountryCode::Dj,
            "DK" => CountryCode::Dk,
            "DM" => CountryCode::Dm,
            "DO" => CountryCode::Do,
            "DZ" => CountryCode::Dz,
            "EC" => CountryCode::Ec,
            "EE" => CountryCode::Ee,
            "EG" => CountryCode::Eg,
            "EH" => CountryCode::Eh,
            "ER" => CountryCode::Er,
            "ES" => CountryCode::Es,
            "ET" => CountryCode::Et,
            "FI" => CountryCode::Fi,
            "FJ" => CountryCode::Fj,
            "FK" => CountryCode::Fk,
            "FM" => CountryCode::Fm,
            "FO" => CountryCode::Fo,
            "FR" => CountryCode::Fr,
            "GA" => CountryCode::Ga,
            "GB" => CountryCode::Gb,
            "GD" => CountryCode::Gd,
            "GE" => CountryCode::Ge,
            "GF" => CountryCode::Gf,
            "GG" => CountryCode::Gg,
            "GH" => CountryCode::Gh,
            "GI" => CountryCode::Gi,
            "GL" => CountryCode::Gl,
            "GM" => CountryCode::Gm,
            "GN" => CountryCode::Gn,
            "GP" => CountryCode::Gp,
            "GQ" => CountryCode::Gq,
            "GR" => CountryCode::Gr,
            "GS" => CountryCode::Gs,
            "GT" => CountryCode::Gt,
            "GU" => CountryCode::Gu,
            "GW" => CountryCode::Gw,
            "GY" => CountryCode::Gy,
            "HK" => CountryCode::Hk,
            "HM" => CountryCode::Hm,
            "HN" => CountryCode::Hn,
            "HR" => CountryCode::Hr,
            "HT" => CountryCode::Ht,
            "HU" => CountryCode::Hu,
            "ID" => CountryCode::Id,
            "IE" => CountryCode::Ie,
            "IL" => CountryCode::Il,
            "IM" => CountryCode::Im,
            "IN" => CountryCode::In,
            "IO" => CountryCode::Io,
            "IQ" => CountryCode::Iq,
            "IR" => CountryCode::Ir,
            "IS" => CountryCode::Is,
            "IT" => CountryCode::It,
            "JE" => CountryCode::Je,
            "JM" => CountryCode::Jm,
            "JO" => CountryCode::Jo,
            "JP" => CountryCode::Jp,
            "KE" => CountryCode::Ke,
            "KG" => CountryCode::Kg,
            "KH" => CountryCode::Kh,
            "KI" => CountryCode::Ki,
            "KM" => CountryCode::Km,
            "KN" => CountryCode::Kn,
            "KP" => CountryCode::Kp,
            "KR" => CountryCode::Kr,
            "KW" => CountryCode::Kw,
            "KY" => CountryCode::Ky,
            "KZ" => CountryCode::Kz,
            "LA" => CountryCode::La,
            "LB" => CountryCode::Lb,
            "LC" => CountryCode::Lc,
            "LI" => CountryCode::Li,
            "LK" => CountryCode::Lk,
            "LR" => CountryCode::Lr,
            "LS" => CountryCode::Ls,
            "LT" => CountryCode::Lt,
            "LU" => CountryCode::Lu,
            "LV" => CountryCode::Lv,
            "LY" => CountryCode::Ly,
            "MA" => CountryCode::Ma,
            "MC" => CountryCode::Mc,
            "MD" => CountryCode::Md,
            "ME" => CountryCode::Me,
            "MF" => CountryCode::Mf,
            "MG" => CountryCode::Mg,
            "MH" => CountryCode::Mh,
            "MK" => CountryCode::Mk,
            "ML" => CountryCode::Ml,
            "MM" => CountryCode::Mm,
            "MN" => CountryCode::Mn,
            "MO" => CountryCode::Mo,
            "MP" => CountryCode::Mp,
            "MQ" => CountryCode::Mq,
            "MR" => CountryCode::Mr,
            "MS" => CountryCode::Ms,
            "MT" => CountryCode::Mt,
            "MU" => CountryCode::Mu,
            "MV" => CountryCode::Mv,
            "MW" => CountryCode::Mw,
            "MX" => CountryCode::Mx,
            "MY" => CountryCode::My,
            "MZ" => CountryCode::Mz,
            "NA" => CountryCode::Na,
            "NC" => CountryCode::Nc,
            "NE" => CountryCode::Ne,
            "NF" => CountryCode::Nf,
            "NG" => CountryCode::Ng,
            "NI" => CountryCode::Ni,
            "NL" => CountryCode::Nl,
            "NO" => CountryCode::No,
            "NP" => CountryCode::Np,
            "NR" => CountryCode::Nr,
            "NU" => CountryCode::Nu,
            "NZ" => CountryCode::Nz,
            "OM" => CountryCode::Om,
            "PA" => CountryCode::Pa,
            "PE" => CountryCode::Pe,
            "PF" => CountryCode::Pf,
            "PG" => CountryCode::Pg,
            "PH" => CountryCode::Ph,
            "PK" => CountryCode::Pk,
            "PL" => CountryCode::Pl,
            "PM" => CountryCode::Pm,
            "PN" => CountryCode::Pn,
            "PR" => CountryCode::Pr,
            "PS" => CountryCode::Ps,
            "PT" => CountryCode::Pt,
            "PW" => CountryCode::Pw,
            "PY" => CountryCode::Py,
            "QA" => CountryCode::Qa,
            "RE" => CountryCode::Re,
            "RO" => CountryCode::Ro,
            "RS" => CountryCode::Rs,
            "RU" => CountryCode::Ru,
            "RW" => CountryCode::Rw,
            "SA" => CountryCode::Sa,
            "SB" => CountryCode::Sb,
            "SC" => CountryCode::Sc,
            "SD" => CountryCode::Sd,
            "SE" => CountryCode::Se,
            "SG" => CountryCode::Sg,
            "SH" => CountryCode::Sh,
            "SI" => CountryCode::Si,
            "SJ" => CountryCode::Sj,
            "SK" => CountryCode::Sk,
            "SL" => CountryCode::Sl,
            "SM" => CountryCode::Sm,
            "SN" => CountryCode::Sn,
            "SO" => CountryCode::So,
            "SR" => CountryCode::Sr,
            "SS" => CountryCode::Ss,
            "ST" => CountryCode::St,
            "SV" => CountryCode::Sv,
            "SX" => CountryCode::Sx,
            "SY" => CountryCode::Sy,
            "SZ" => CountryCode::Sz,
            "TC" => CountryCode::Tc,
            "TD" => CountryCode::Td,
            "TF" => CountryCode::Tf,
            "TG" => CountryCode::Tg,
            "TH" => CountryCode::Th,
            "TJ" => CountryCode::Tj,
            "TK" => CountryCode::Tk,
            "TL" => CountryCode::Tl,
            "TM" => CountryCode::Tm,
            "TN" => CountryCode::Tn,
            "TO" => CountryCode::To,
            "TR" => CountryCode::Tr,
            "TT" => CountryCode::Tt,
            "TV" => CountryCode::Tv,
            "TW" => CountryCode::Tw,
            "TZ" => CountryCode::Tz,
            "UA" => CountryCode::Ua,
            "UG" => CountryCode::Ug,
            "UM" => CountryCode::Um,
            "US" => CountryCode::Us,
            "UY" => CountryCode::Uy,
            "UZ" => CountryCode::Uz,
            "VA" => CountryCode::Va,
            "VC" => CountryCode::Vc,
            "VE" => CountryCode::Ve,
            "VG" => CountryCode::Vg,
            "VI" => CountryCode::Vi,
            "VN" => CountryCode::Vn,
            "VU" => CountryCode::Vu,
            "WF" => CountryCode::Wf,
            "WS" => CountryCode::Ws,
            "YE" => CountryCode::Ye,
            "YT" => CountryCode::Yt,
            "ZA" => CountryCode::Za,
            "ZM" => CountryCode::Zm,
            "ZW" => CountryCode::Zw,
            other => CountryCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CountryCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CountryCode::from(s))
    }
}
impl CountryCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CountryCode::Ad => "AD",
            CountryCode::Ae => "AE",
            CountryCode::Af => "AF",
            CountryCode::Ag => "AG",
            CountryCode::Ai => "AI",
            CountryCode::Al => "AL",
            CountryCode::Am => "AM",
            CountryCode::Ao => "AO",
            CountryCode::Aq => "AQ",
            CountryCode::Ar => "AR",
            CountryCode::As => "AS",
            CountryCode::At => "AT",
            CountryCode::Au => "AU",
            CountryCode::Aw => "AW",
            CountryCode::Ax => "AX",
            CountryCode::Az => "AZ",
            CountryCode::Ba => "BA",
            CountryCode::Bb => "BB",
            CountryCode::Bd => "BD",
            CountryCode::Be => "BE",
            CountryCode::Bf => "BF",
            CountryCode::Bg => "BG",
            CountryCode::Bh => "BH",
            CountryCode::Bi => "BI",
            CountryCode::Bj => "BJ",
            CountryCode::Bl => "BL",
            CountryCode::Bm => "BM",
            CountryCode::Bn => "BN",
            CountryCode::Bo => "BO",
            CountryCode::Bq => "BQ",
            CountryCode::Br => "BR",
            CountryCode::Bs => "BS",
            CountryCode::Bt => "BT",
            CountryCode::Bv => "BV",
            CountryCode::Bw => "BW",
            CountryCode::By => "BY",
            CountryCode::Bz => "BZ",
            CountryCode::Ca => "CA",
            CountryCode::Cc => "CC",
            CountryCode::Cd => "CD",
            CountryCode::Cf => "CF",
            CountryCode::Cg => "CG",
            CountryCode::Ch => "CH",
            CountryCode::Ci => "CI",
            CountryCode::Ck => "CK",
            CountryCode::Cl => "CL",
            CountryCode::Cm => "CM",
            CountryCode::Cn => "CN",
            CountryCode::Co => "CO",
            CountryCode::Cr => "CR",
            CountryCode::Cu => "CU",
            CountryCode::Cv => "CV",
            CountryCode::Cw => "CW",
            CountryCode::Cx => "CX",
            CountryCode::Cy => "CY",
            CountryCode::Cz => "CZ",
            CountryCode::De => "DE",
            CountryCode::Dj => "DJ",
            CountryCode::Dk => "DK",
            CountryCode::Dm => "DM",
            CountryCode::Do => "DO",
            CountryCode::Dz => "DZ",
            CountryCode::Ec => "EC",
            CountryCode::Ee => "EE",
            CountryCode::Eg => "EG",
            CountryCode::Eh => "EH",
            CountryCode::Er => "ER",
            CountryCode::Es => "ES",
            CountryCode::Et => "ET",
            CountryCode::Fi => "FI",
            CountryCode::Fj => "FJ",
            CountryCode::Fk => "FK",
            CountryCode::Fm => "FM",
            CountryCode::Fo => "FO",
            CountryCode::Fr => "FR",
            CountryCode::Ga => "GA",
            CountryCode::Gb => "GB",
            CountryCode::Gd => "GD",
            CountryCode::Ge => "GE",
            CountryCode::Gf => "GF",
            CountryCode::Gg => "GG",
            CountryCode::Gh => "GH",
            CountryCode::Gi => "GI",
            CountryCode::Gl => "GL",
            CountryCode::Gm => "GM",
            CountryCode::Gn => "GN",
            CountryCode::Gp => "GP",
            CountryCode::Gq => "GQ",
            CountryCode::Gr => "GR",
            CountryCode::Gs => "GS",
            CountryCode::Gt => "GT",
            CountryCode::Gu => "GU",
            CountryCode::Gw => "GW",
            CountryCode::Gy => "GY",
            CountryCode::Hk => "HK",
            CountryCode::Hm => "HM",
            CountryCode::Hn => "HN",
            CountryCode::Hr => "HR",
            CountryCode::Ht => "HT",
            CountryCode::Hu => "HU",
            CountryCode::Id => "ID",
            CountryCode::Ie => "IE",
            CountryCode::Il => "IL",
            CountryCode::Im => "IM",
            CountryCode::In => "IN",
            CountryCode::Io => "IO",
            CountryCode::Iq => "IQ",
            CountryCode::Ir => "IR",
            CountryCode::Is => "IS",
            CountryCode::It => "IT",
            CountryCode::Je => "JE",
            CountryCode::Jm => "JM",
            CountryCode::Jo => "JO",
            CountryCode::Jp => "JP",
            CountryCode::Ke => "KE",
            CountryCode::Kg => "KG",
            CountryCode::Kh => "KH",
            CountryCode::Ki => "KI",
            CountryCode::Km => "KM",
            CountryCode::Kn => "KN",
            CountryCode::Kp => "KP",
            CountryCode::Kr => "KR",
            CountryCode::Kw => "KW",
            CountryCode::Ky => "KY",
            CountryCode::Kz => "KZ",
            CountryCode::La => "LA",
            CountryCode::Lb => "LB",
            CountryCode::Lc => "LC",
            CountryCode::Li => "LI",
            CountryCode::Lk => "LK",
            CountryCode::Lr => "LR",
            CountryCode::Ls => "LS",
            CountryCode::Lt => "LT",
            CountryCode::Lu => "LU",
            CountryCode::Lv => "LV",
            CountryCode::Ly => "LY",
            CountryCode::Ma => "MA",
            CountryCode::Mc => "MC",
            CountryCode::Md => "MD",
            CountryCode::Me => "ME",
            CountryCode::Mf => "MF",
            CountryCode::Mg => "MG",
            CountryCode::Mh => "MH",
            CountryCode::Mk => "MK",
            CountryCode::Ml => "ML",
            CountryCode::Mm => "MM",
            CountryCode::Mn => "MN",
            CountryCode::Mo => "MO",
            CountryCode::Mp => "MP",
            CountryCode::Mq => "MQ",
            CountryCode::Mr => "MR",
            CountryCode::Ms => "MS",
            CountryCode::Mt => "MT",
            CountryCode::Mu => "MU",
            CountryCode::Mv => "MV",
            CountryCode::Mw => "MW",
            CountryCode::Mx => "MX",
            CountryCode::My => "MY",
            CountryCode::Mz => "MZ",
            CountryCode::Na => "NA",
            CountryCode::Nc => "NC",
            CountryCode::Ne => "NE",
            CountryCode::Nf => "NF",
            CountryCode::Ng => "NG",
            CountryCode::Ni => "NI",
            CountryCode::Nl => "NL",
            CountryCode::No => "NO",
            CountryCode::Np => "NP",
            CountryCode::Nr => "NR",
            CountryCode::Nu => "NU",
            CountryCode::Nz => "NZ",
            CountryCode::Om => "OM",
            CountryCode::Pa => "PA",
            CountryCode::Pe => "PE",
            CountryCode::Pf => "PF",
            CountryCode::Pg => "PG",
            CountryCode::Ph => "PH",
            CountryCode::Pk => "PK",
            CountryCode::Pl => "PL",
            CountryCode::Pm => "PM",
            CountryCode::Pn => "PN",
            CountryCode::Pr => "PR",
            CountryCode::Ps => "PS",
            CountryCode::Pt => "PT",
            CountryCode::Pw => "PW",
            CountryCode::Py => "PY",
            CountryCode::Qa => "QA",
            CountryCode::Re => "RE",
            CountryCode::Ro => "RO",
            CountryCode::Rs => "RS",
            CountryCode::Ru => "RU",
            CountryCode::Rw => "RW",
            CountryCode::Sa => "SA",
            CountryCode::Sb => "SB",
            CountryCode::Sc => "SC",
            CountryCode::Sd => "SD",
            CountryCode::Se => "SE",
            CountryCode::Sg => "SG",
            CountryCode::Sh => "SH",
            CountryCode::Si => "SI",
            CountryCode::Sj => "SJ",
            CountryCode::Sk => "SK",
            CountryCode::Sl => "SL",
            CountryCode::Sm => "SM",
            CountryCode::Sn => "SN",
            CountryCode::So => "SO",
            CountryCode::Sr => "SR",
            CountryCode::Ss => "SS",
            CountryCode::St => "ST",
            CountryCode::Sv => "SV",
            CountryCode::Sx => "SX",
            CountryCode::Sy => "SY",
            CountryCode::Sz => "SZ",
            CountryCode::Tc => "TC",
            CountryCode::Td => "TD",
            CountryCode::Tf => "TF",
            CountryCode::Tg => "TG",
            CountryCode::Th => "TH",
            CountryCode::Tj => "TJ",
            CountryCode::Tk => "TK",
            CountryCode::Tl => "TL",
            CountryCode::Tm => "TM",
            CountryCode::Tn => "TN",
            CountryCode::To => "TO",
            CountryCode::Tr => "TR",
            CountryCode::Tt => "TT",
            CountryCode::Tv => "TV",
            CountryCode::Tw => "TW",
            CountryCode::Tz => "TZ",
            CountryCode::Ua => "UA",
            CountryCode::Ug => "UG",
            CountryCode::Um => "UM",
            CountryCode::Us => "US",
            CountryCode::Uy => "UY",
            CountryCode::Uz => "UZ",
            CountryCode::Va => "VA",
            CountryCode::Vc => "VC",
            CountryCode::Ve => "VE",
            CountryCode::Vg => "VG",
            CountryCode::Vi => "VI",
            CountryCode::Vn => "VN",
            CountryCode::Vu => "VU",
            CountryCode::Wf => "WF",
            CountryCode::Ws => "WS",
            CountryCode::Ye => "YE",
            CountryCode::Yt => "YT",
            CountryCode::Za => "ZA",
            CountryCode::Zm => "ZM",
            CountryCode::Zw => "ZW",
            CountryCode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "AD", "AE", "AF", "AG", "AI", "AL", "AM", "AO", "AQ", "AR", "AS", "AT", "AU", "AW",
            "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN",
            "BO", "BQ", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG",
            "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ",
            "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI",
            "FJ", "FK", "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL",
            "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR",
            "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM",
            "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA",
            "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME",
            "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU",
            "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP",
            "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR",
            "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD",
            "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "SS", "ST", "SV",
            "SX", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TL", "TM", "TN", "TO",
            "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE",
            "VG", "VI", "VN", "VU", "WF", "WS", "YE", "YT", "ZA", "ZM", "ZW",
        ]
    }
}
impl AsRef<str> for CountryCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (&gt;) or less than (&lt;). For example, you can use a size constraint statement to look for query strings that are longer than 100 bytes. </p>
/// <p>If you configure WAF to inspect the request body, WAF inspects only the first 8192 bytes (8 KB). If the request body for your web requests never exceeds 8192 bytes, you can create a size constraint condition and block requests that have a request body greater than 8192 bytes.</p>
/// <p>If you choose URI for the value of Part of the request to filter on, the slash (/) in the URI counts as one character. For example, the URI <code>/logo.jpg</code> is nine characters long.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SizeConstraintStatement {
    /// <p>The part of a web request that you want WAF to inspect. For more information, see <code>FieldToMatch</code>. </p>
    pub field_to_match: std::option::Option<crate::model::FieldToMatch>,
    /// <p>The operator to use to compare the request part to the size setting. </p>
    pub comparison_operator: std::option::Option<crate::model::ComparisonOperator>,
    /// <p>The size, in byte, to compare to the request part, after any transformations.</p>
    pub size: i64,
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, WAF performs all transformations on the content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
    pub text_transformations: std::option::Option<std::vec::Vec<crate::model::TextTransformation>>,
}
impl SizeConstraintStatement {
    /// <p>The part of a web request that you want WAF to inspect. For more information, see <code>FieldToMatch</code>. </p>
    pub fn field_to_match(&self) -> std::option::Option<&crate::model::FieldToMatch> {
        self.field_to_match.as_ref()
    }
    /// <p>The operator to use to compare the request part to the size setting. </p>
    pub fn comparison_operator(&self) -> std::option::Option<&crate::model::ComparisonOperator> {
        self.comparison_operator.as_ref()
    }
    /// <p>The size, in byte, to compare to the request part, after any transformations.</p>
    pub fn size(&self) -> i64 {
        self.size
    }
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, WAF performs all transformations on the content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
    pub fn text_transformations(&self) -> std::option::Option<&[crate::model::TextTransformation]> {
        self.text_transformations.as_deref()
    }
}
impl std::fmt::Debug for SizeConstraintStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SizeConstraintStatement");
        formatter.field("field_to_match", &self.field_to_match);
        formatter.field("comparison_operator", &self.comparison_operator);
        formatter.field("size", &self.size);
        formatter.field("text_transformations", &self.text_transformations);
        formatter.finish()
    }
}
/// See [`SizeConstraintStatement`](crate::model::SizeConstraintStatement)
pub mod size_constraint_statement {
    /// A builder for [`SizeConstraintStatement`](crate::model::SizeConstraintStatement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_to_match: std::option::Option<crate::model::FieldToMatch>,
        pub(crate) comparison_operator: std::option::Option<crate::model::ComparisonOperator>,
        pub(crate) size: std::option::Option<i64>,
        pub(crate) text_transformations:
            std::option::Option<std::vec::Vec<crate::model::TextTransformation>>,
    }
    impl Builder {
        /// <p>The part of a web request that you want WAF to inspect. For more information, see <code>FieldToMatch</code>. </p>
        pub fn field_to_match(mut self, input: crate::model::FieldToMatch) -> Self {
            self.field_to_match = Some(input);
            self
        }
        /// <p>The part of a web request that you want WAF to inspect. For more information, see <code>FieldToMatch</code>. </p>
        pub fn set_field_to_match(
            mut self,
            input: std::option::Option<crate::model::FieldToMatch>,
        ) -> Self {
            self.field_to_match = input;
            self
        }
        /// <p>The operator to use to compare the request part to the size setting. </p>
        pub fn comparison_operator(mut self, input: crate::model::ComparisonOperator) -> Self {
            self.comparison_operator = Some(input);
            self
        }
        /// <p>The operator to use to compare the request part to the size setting. </p>
        pub fn set_comparison_operator(
            mut self,
            input: std::option::Option<crate::model::ComparisonOperator>,
        ) -> Self {
            self.comparison_operator = input;
            self
        }
        /// <p>The size, in byte, to compare to the request part, after any transformations.</p>
        pub fn size(mut self, input: i64) -> Self {
            self.size = Some(input);
            self
        }
        /// <p>The size, in byte, to compare to the request part, after any transformations.</p>
        pub fn set_size(mut self, input: std::option::Option<i64>) -> Self {
            self.size = input;
            self
        }
        /// Appends an item to `text_transformations`.
        ///
        /// To override the contents of this collection use [`set_text_transformations`](Self::set_text_transformations).
        ///
        /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, WAF performs all transformations on the content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
        pub fn text_transformations(mut self, input: crate::model::TextTransformation) -> Self {
            let mut v = self.text_transformations.unwrap_or_default();
            v.push(input);
            self.text_transformations = Some(v);
            self
        }
        /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, WAF performs all transformations on the content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
        pub fn set_text_transformations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TextTransformation>>,
        ) -> Self {
            self.text_transformations = input;
            self
        }
        /// Consumes the builder and constructs a [`SizeConstraintStatement`](crate::model::SizeConstraintStatement)
        pub fn build(self) -> crate::model::SizeConstraintStatement {
            crate::model::SizeConstraintStatement {
                field_to_match: self.field_to_match,
                comparison_operator: self.comparison_operator,
                size: self.size.unwrap_or_default(),
                text_transformations: self.text_transformations,
            }
        }
    }
}
impl SizeConstraintStatement {
    /// Creates a new builder-style object to manufacture [`SizeConstraintStatement`](crate::model::SizeConstraintStatement)
    pub fn builder() -> crate::model::size_constraint_statement::Builder {
        crate::model::size_constraint_statement::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ComparisonOperator {
    #[allow(missing_docs)] // documentation missing in model
    Eq,
    #[allow(missing_docs)] // documentation missing in model
    Ge,
    #[allow(missing_docs)] // documentation missing in model
    Gt,
    #[allow(missing_docs)] // documentation missing in model
    Le,
    #[allow(missing_docs)] // documentation missing in model
    Lt,
    #[allow(missing_docs)] // documentation missing in model
    Ne,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ComparisonOperator {
    fn from(s: &str) -> Self {
        match s {
            "EQ" => ComparisonOperator::Eq,
            "GE" => ComparisonOperator::Ge,
            "GT" => ComparisonOperator::Gt,
            "LE" => ComparisonOperator::Le,
            "LT" => ComparisonOperator::Lt,
            "NE" => ComparisonOperator::Ne,
            other => ComparisonOperator::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ComparisonOperator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ComparisonOperator::from(s))
    }
}
impl ComparisonOperator {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ComparisonOperator::Eq => "EQ",
            ComparisonOperator::Ge => "GE",
            ComparisonOperator::Gt => "GT",
            ComparisonOperator::Le => "LE",
            ComparisonOperator::Lt => "LT",
            ComparisonOperator::Ne => "NE",
            ComparisonOperator::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["EQ", "GE", "GT", "LE", "LT", "NE"]
    }
}
impl AsRef<str> for ComparisonOperator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A rule statement that defines a cross-site scripting (XSS) match search for WAF to apply to web requests. XSS attacks are those where the attacker uses vulnerabilities in a benign website as a vehicle to inject malicious client-site scripts into other legitimate web browsers. The XSS match statement provides the location in requests that you want WAF to search and text transformations to use on the search area before WAF searches for character sequences that are likely to be malicious strings. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct XssMatchStatement {
    /// <p>The part of a web request that you want WAF to inspect. For more information, see <code>FieldToMatch</code>. </p>
    pub field_to_match: std::option::Option<crate::model::FieldToMatch>,
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, WAF performs all transformations on the content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
    pub text_transformations: std::option::Option<std::vec::Vec<crate::model::TextTransformation>>,
}
impl XssMatchStatement {
    /// <p>The part of a web request that you want WAF to inspect. For more information, see <code>FieldToMatch</code>. </p>
    pub fn field_to_match(&self) -> std::option::Option<&crate::model::FieldToMatch> {
        self.field_to_match.as_ref()
    }
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, WAF performs all transformations on the content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
    pub fn text_transformations(&self) -> std::option::Option<&[crate::model::TextTransformation]> {
        self.text_transformations.as_deref()
    }
}
impl std::fmt::Debug for XssMatchStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("XssMatchStatement");
        formatter.field("field_to_match", &self.field_to_match);
        formatter.field("text_transformations", &self.text_transformations);
        formatter.finish()
    }
}
/// See [`XssMatchStatement`](crate::model::XssMatchStatement)
pub mod xss_match_statement {
    /// A builder for [`XssMatchStatement`](crate::model::XssMatchStatement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_to_match: std::option::Option<crate::model::FieldToMatch>,
        pub(crate) text_transformations:
            std::option::Option<std::vec::Vec<crate::model::TextTransformation>>,
    }
    impl Builder {
        /// <p>The part of a web request that you want WAF to inspect. For more information, see <code>FieldToMatch</code>. </p>
        pub fn field_to_match(mut self, input: crate::model::FieldToMatch) -> Self {
            self.field_to_match = Some(input);
            self
        }
        /// <p>The part of a web request that you want WAF to inspect. For more information, see <code>FieldToMatch</code>. </p>
        pub fn set_field_to_match(
            mut self,
            input: std::option::Option<crate::model::FieldToMatch>,
        ) -> Self {
            self.field_to_match = input;
            self
        }
        /// Appends an item to `text_transformations`.
        ///
        /// To override the contents of this collection use [`set_text_transformations`](Self::set_text_transformations).
        ///
        /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, WAF performs all transformations on the content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
        pub fn text_transformations(mut self, input: crate::model::TextTransformation) -> Self {
            let mut v = self.text_transformations.unwrap_or_default();
            v.push(input);
            self.text_transformations = Some(v);
            self
        }
        /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, WAF performs all transformations on the content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
        pub fn set_text_transformations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TextTransformation>>,
        ) -> Self {
            self.text_transformations = input;
            self
        }
        /// Consumes the builder and constructs a [`XssMatchStatement`](crate::model::XssMatchStatement)
        pub fn build(self) -> crate::model::XssMatchStatement {
            crate::model::XssMatchStatement {
                field_to_match: self.field_to_match,
                text_transformations: self.text_transformations,
            }
        }
    }
}
impl XssMatchStatement {
    /// Creates a new builder-style object to manufacture [`XssMatchStatement`](crate::model::XssMatchStatement)
    pub fn builder() -> crate::model::xss_match_statement::Builder {
        crate::model::xss_match_statement::Builder::default()
    }
}

/// <p>Attackers sometimes insert malicious SQL code into web requests in an effort to extract data from your database. To allow or block web requests that appear to contain malicious SQL code, create one or more SQL injection match conditions. An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want WAF to inspect. Later in the process, when you create a web ACL, you specify whether to allow or block requests that appear to contain malicious SQL code.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SqliMatchStatement {
    /// <p>The part of a web request that you want WAF to inspect. For more information, see <code>FieldToMatch</code>. </p>
    pub field_to_match: std::option::Option<crate::model::FieldToMatch>,
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, WAF performs all transformations on the content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
    pub text_transformations: std::option::Option<std::vec::Vec<crate::model::TextTransformation>>,
}
impl SqliMatchStatement {
    /// <p>The part of a web request that you want WAF to inspect. For more information, see <code>FieldToMatch</code>. </p>
    pub fn field_to_match(&self) -> std::option::Option<&crate::model::FieldToMatch> {
        self.field_to_match.as_ref()
    }
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, WAF performs all transformations on the content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
    pub fn text_transformations(&self) -> std::option::Option<&[crate::model::TextTransformation]> {
        self.text_transformations.as_deref()
    }
}
impl std::fmt::Debug for SqliMatchStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SqliMatchStatement");
        formatter.field("field_to_match", &self.field_to_match);
        formatter.field("text_transformations", &self.text_transformations);
        formatter.finish()
    }
}
/// See [`SqliMatchStatement`](crate::model::SqliMatchStatement)
pub mod sqli_match_statement {
    /// A builder for [`SqliMatchStatement`](crate::model::SqliMatchStatement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_to_match: std::option::Option<crate::model::FieldToMatch>,
        pub(crate) text_transformations:
            std::option::Option<std::vec::Vec<crate::model::TextTransformation>>,
    }
    impl Builder {
        /// <p>The part of a web request that you want WAF to inspect. For more information, see <code>FieldToMatch</code>. </p>
        pub fn field_to_match(mut self, input: crate::model::FieldToMatch) -> Self {
            self.field_to_match = Some(input);
            self
        }
        /// <p>The part of a web request that you want WAF to inspect. For more information, see <code>FieldToMatch</code>. </p>
        pub fn set_field_to_match(
            mut self,
            input: std::option::Option<crate::model::FieldToMatch>,
        ) -> Self {
            self.field_to_match = input;
            self
        }
        /// Appends an item to `text_transformations`.
        ///
        /// To override the contents of this collection use [`set_text_transformations`](Self::set_text_transformations).
        ///
        /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, WAF performs all transformations on the content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
        pub fn text_transformations(mut self, input: crate::model::TextTransformation) -> Self {
            let mut v = self.text_transformations.unwrap_or_default();
            v.push(input);
            self.text_transformations = Some(v);
            self
        }
        /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, WAF performs all transformations on the content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
        pub fn set_text_transformations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TextTransformation>>,
        ) -> Self {
            self.text_transformations = input;
            self
        }
        /// Consumes the builder and constructs a [`SqliMatchStatement`](crate::model::SqliMatchStatement)
        pub fn build(self) -> crate::model::SqliMatchStatement {
            crate::model::SqliMatchStatement {
                field_to_match: self.field_to_match,
                text_transformations: self.text_transformations,
            }
        }
    }
}
impl SqliMatchStatement {
    /// Creates a new builder-style object to manufacture [`SqliMatchStatement`](crate::model::SqliMatchStatement)
    pub fn builder() -> crate::model::sqli_match_statement::Builder {
        crate::model::sqli_match_statement::Builder::default()
    }
}

/// <p>A rule statement that defines a string match search for WAF to apply to web requests. The byte match statement provides the bytes to search for, the location in requests that you want WAF to search, and other settings. The bytes to search for are typically a string that corresponds with ASCII characters. In the WAF console and the developer guide, this is refered to as a string match statement.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ByteMatchStatement {
    /// <p>A string value that you want WAF to search for. WAF searches only in the part of web requests that you designate for inspection in <code>FieldToMatch</code>. The maximum length of the value is 50 bytes.</p>
    /// <p>Valid values depend on the component that you specify for inspection in <code>FieldToMatch</code>:</p>
    /// <ul>
    /// <li> <p> <code>Method</code>: The HTTP method that you want WAF to search for. This indicates the type of operation specified in the request. </p> </li>
    /// <li> <p> <code>UriPath</code>: The value that you want WAF to search for in the URI path, for example, <code>/images/daily-ad.jpg</code>. </p> </li>
    /// </ul>
    /// <p>If <code>SearchString</code> includes alphabetic characters A-Z and a-z, note that the value is case sensitive.</p>
    /// <p> <b>If you're using the WAF API</b> </p>
    /// <p>Specify a base64-encoded version of the value. The maximum length of the value before you base64-encode it is 50 bytes.</p>
    /// <p>For example, suppose the value of <code>Type</code> is <code>HEADER</code> and the value of <code>Data</code> is <code>User-Agent</code>. If you want to search the <code>User-Agent</code> header for the value <code>BadBot</code>, you base64-encode <code>BadBot</code> using MIME base64-encoding and include the resulting value, <code>QmFkQm90</code>, in the value of <code>SearchString</code>.</p>
    /// <p> <b>If you're using the CLI or one of the Amazon Web Services SDKs</b> </p>
    /// <p>The value that you want WAF to search for. The SDK automatically base64 encodes the value.</p>
    pub search_string: std::option::Option<aws_smithy_types::Blob>,
    /// <p>The part of a web request that you want WAF to inspect. For more information, see <code>FieldToMatch</code>. </p>
    pub field_to_match: std::option::Option<crate::model::FieldToMatch>,
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, WAF performs all transformations on the content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
    pub text_transformations: std::option::Option<std::vec::Vec<crate::model::TextTransformation>>,
    /// <p>The area within the portion of a web request that you want WAF to search for <code>SearchString</code>. Valid values include the following:</p>
    /// <p> <b>CONTAINS</b> </p>
    /// <p>The specified part of the web request must include the value of <code>SearchString</code>, but the location doesn't matter.</p>
    /// <p> <b>CONTAINS_WORD</b> </p>
    /// <p>The specified part of the web request must include the value of <code>SearchString</code>, and <code>SearchString</code> must contain only alphanumeric characters or underscore (A-Z, a-z, 0-9, or _). In addition, <code>SearchString</code> must be a word, which means that both of the following are true:</p>
    /// <ul>
    /// <li> <p> <code>SearchString</code> is at the beginning of the specified part of the web request or is preceded by a character other than an alphanumeric character or underscore (_). Examples include the value of a header and <code>;BadBot</code>.</p> </li>
    /// <li> <p> <code>SearchString</code> is at the end of the specified part of the web request or is followed by a character other than an alphanumeric character or underscore (_), for example, <code>BadBot;</code> and <code>-BadBot;</code>.</p> </li>
    /// </ul>
    /// <p> <b>EXACTLY</b> </p>
    /// <p>The value of the specified part of the web request must exactly match the value of <code>SearchString</code>.</p>
    /// <p> <b>STARTS_WITH</b> </p>
    /// <p>The value of <code>SearchString</code> must appear at the beginning of the specified part of the web request.</p>
    /// <p> <b>ENDS_WITH</b> </p>
    /// <p>The value of <code>SearchString</code> must appear at the end of the specified part of the web request.</p>
    pub positional_constraint: std::option::Option<crate::model::PositionalConstraint>,
}
impl ByteMatchStatement {
    /// <p>A string value that you want WAF to search for. WAF searches only in the part of web requests that you designate for inspection in <code>FieldToMatch</code>. The maximum length of the value is 50 bytes.</p>
    /// <p>Valid values depend on the component that you specify for inspection in <code>FieldToMatch</code>:</p>
    /// <ul>
    /// <li> <p> <code>Method</code>: The HTTP method that you want WAF to search for. This indicates the type of operation specified in the request. </p> </li>
    /// <li> <p> <code>UriPath</code>: The value that you want WAF to search for in the URI path, for example, <code>/images/daily-ad.jpg</code>. </p> </li>
    /// </ul>
    /// <p>If <code>SearchString</code> includes alphabetic characters A-Z and a-z, note that the value is case sensitive.</p>
    /// <p> <b>If you're using the WAF API</b> </p>
    /// <p>Specify a base64-encoded version of the value. The maximum length of the value before you base64-encode it is 50 bytes.</p>
    /// <p>For example, suppose the value of <code>Type</code> is <code>HEADER</code> and the value of <code>Data</code> is <code>User-Agent</code>. If you want to search the <code>User-Agent</code> header for the value <code>BadBot</code>, you base64-encode <code>BadBot</code> using MIME base64-encoding and include the resulting value, <code>QmFkQm90</code>, in the value of <code>SearchString</code>.</p>
    /// <p> <b>If you're using the CLI or one of the Amazon Web Services SDKs</b> </p>
    /// <p>The value that you want WAF to search for. The SDK automatically base64 encodes the value.</p>
    pub fn search_string(&self) -> std::option::Option<&aws_smithy_types::Blob> {
        self.search_string.as_ref()
    }
    /// <p>The part of a web request that you want WAF to inspect. For more information, see <code>FieldToMatch</code>. </p>
    pub fn field_to_match(&self) -> std::option::Option<&crate::model::FieldToMatch> {
        self.field_to_match.as_ref()
    }
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, WAF performs all transformations on the content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
    pub fn text_transformations(&self) -> std::option::Option<&[crate::model::TextTransformation]> {
        self.text_transformations.as_deref()
    }
    /// <p>The area within the portion of a web request that you want WAF to search for <code>SearchString</code>. Valid values include the following:</p>
    /// <p> <b>CONTAINS</b> </p>
    /// <p>The specified part of the web request must include the value of <code>SearchString</code>, but the location doesn't matter.</p>
    /// <p> <b>CONTAINS_WORD</b> </p>
    /// <p>The specified part of the web request must include the value of <code>SearchString</code>, and <code>SearchString</code> must contain only alphanumeric characters or underscore (A-Z, a-z, 0-9, or _). In addition, <code>SearchString</code> must be a word, which means that both of the following are true:</p>
    /// <ul>
    /// <li> <p> <code>SearchString</code> is at the beginning of the specified part of the web request or is preceded by a character other than an alphanumeric character or underscore (_). Examples include the value of a header and <code>;BadBot</code>.</p> </li>
    /// <li> <p> <code>SearchString</code> is at the end of the specified part of the web request or is followed by a character other than an alphanumeric character or underscore (_), for example, <code>BadBot;</code> and <code>-BadBot;</code>.</p> </li>
    /// </ul>
    /// <p> <b>EXACTLY</b> </p>
    /// <p>The value of the specified part of the web request must exactly match the value of <code>SearchString</code>.</p>
    /// <p> <b>STARTS_WITH</b> </p>
    /// <p>The value of <code>SearchString</code> must appear at the beginning of the specified part of the web request.</p>
    /// <p> <b>ENDS_WITH</b> </p>
    /// <p>The value of <code>SearchString</code> must appear at the end of the specified part of the web request.</p>
    pub fn positional_constraint(
        &self,
    ) -> std::option::Option<&crate::model::PositionalConstraint> {
        self.positional_constraint.as_ref()
    }
}
impl std::fmt::Debug for ByteMatchStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ByteMatchStatement");
        formatter.field("search_string", &self.search_string);
        formatter.field("field_to_match", &self.field_to_match);
        formatter.field("text_transformations", &self.text_transformations);
        formatter.field("positional_constraint", &self.positional_constraint);
        formatter.finish()
    }
}
/// See [`ByteMatchStatement`](crate::model::ByteMatchStatement)
pub mod byte_match_statement {
    /// A builder for [`ByteMatchStatement`](crate::model::ByteMatchStatement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) search_string: std::option::Option<aws_smithy_types::Blob>,
        pub(crate) field_to_match: std::option::Option<crate::model::FieldToMatch>,
        pub(crate) text_transformations:
            std::option::Option<std::vec::Vec<crate::model::TextTransformation>>,
        pub(crate) positional_constraint: std::option::Option<crate::model::PositionalConstraint>,
    }
    impl Builder {
        /// <p>A string value that you want WAF to search for. WAF searches only in the part of web requests that you designate for inspection in <code>FieldToMatch</code>. The maximum length of the value is 50 bytes.</p>
        /// <p>Valid values depend on the component that you specify for inspection in <code>FieldToMatch</code>:</p>
        /// <ul>
        /// <li> <p> <code>Method</code>: The HTTP method that you want WAF to search for. This indicates the type of operation specified in the request. </p> </li>
        /// <li> <p> <code>UriPath</code>: The value that you want WAF to search for in the URI path, for example, <code>/images/daily-ad.jpg</code>. </p> </li>
        /// </ul>
        /// <p>If <code>SearchString</code> includes alphabetic characters A-Z and a-z, note that the value is case sensitive.</p>
        /// <p> <b>If you're using the WAF API</b> </p>
        /// <p>Specify a base64-encoded version of the value. The maximum length of the value before you base64-encode it is 50 bytes.</p>
        /// <p>For example, suppose the value of <code>Type</code> is <code>HEADER</code> and the value of <code>Data</code> is <code>User-Agent</code>. If you want to search the <code>User-Agent</code> header for the value <code>BadBot</code>, you base64-encode <code>BadBot</code> using MIME base64-encoding and include the resulting value, <code>QmFkQm90</code>, in the value of <code>SearchString</code>.</p>
        /// <p> <b>If you're using the CLI or one of the Amazon Web Services SDKs</b> </p>
        /// <p>The value that you want WAF to search for. The SDK automatically base64 encodes the value.</p>
        pub fn search_string(mut self, input: aws_smithy_types::Blob) -> Self {
            self.search_string = Some(input);
            self
        }
        /// <p>A string value that you want WAF to search for. WAF searches only in the part of web requests that you designate for inspection in <code>FieldToMatch</code>. The maximum length of the value is 50 bytes.</p>
        /// <p>Valid values depend on the component that you specify for inspection in <code>FieldToMatch</code>:</p>
        /// <ul>
        /// <li> <p> <code>Method</code>: The HTTP method that you want WAF to search for. This indicates the type of operation specified in the request. </p> </li>
        /// <li> <p> <code>UriPath</code>: The value that you want WAF to search for in the URI path, for example, <code>/images/daily-ad.jpg</code>. </p> </li>
        /// </ul>
        /// <p>If <code>SearchString</code> includes alphabetic characters A-Z and a-z, note that the value is case sensitive.</p>
        /// <p> <b>If you're using the WAF API</b> </p>
        /// <p>Specify a base64-encoded version of the value. The maximum length of the value before you base64-encode it is 50 bytes.</p>
        /// <p>For example, suppose the value of <code>Type</code> is <code>HEADER</code> and the value of <code>Data</code> is <code>User-Agent</code>. If you want to search the <code>User-Agent</code> header for the value <code>BadBot</code>, you base64-encode <code>BadBot</code> using MIME base64-encoding and include the resulting value, <code>QmFkQm90</code>, in the value of <code>SearchString</code>.</p>
        /// <p> <b>If you're using the CLI or one of the Amazon Web Services SDKs</b> </p>
        /// <p>The value that you want WAF to search for. The SDK automatically base64 encodes the value.</p>
        pub fn set_search_string(
            mut self,
            input: std::option::Option<aws_smithy_types::Blob>,
        ) -> Self {
            self.search_string = input;
            self
        }
        /// <p>The part of a web request that you want WAF to inspect. For more information, see <code>FieldToMatch</code>. </p>
        pub fn field_to_match(mut self, input: crate::model::FieldToMatch) -> Self {
            self.field_to_match = Some(input);
            self
        }
        /// <p>The part of a web request that you want WAF to inspect. For more information, see <code>FieldToMatch</code>. </p>
        pub fn set_field_to_match(
            mut self,
            input: std::option::Option<crate::model::FieldToMatch>,
        ) -> Self {
            self.field_to_match = input;
            self
        }
        /// Appends an item to `text_transformations`.
        ///
        /// To override the contents of this collection use [`set_text_transformations`](Self::set_text_transformations).
        ///
        /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, WAF performs all transformations on the content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
        pub fn text_transformations(mut self, input: crate::model::TextTransformation) -> Self {
            let mut v = self.text_transformations.unwrap_or_default();
            v.push(input);
            self.text_transformations = Some(v);
            self
        }
        /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, WAF performs all transformations on the content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
        pub fn set_text_transformations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TextTransformation>>,
        ) -> Self {
            self.text_transformations = input;
            self
        }
        /// <p>The area within the portion of a web request that you want WAF to search for <code>SearchString</code>. Valid values include the following:</p>
        /// <p> <b>CONTAINS</b> </p>
        /// <p>The specified part of the web request must include the value of <code>SearchString</code>, but the location doesn't matter.</p>
        /// <p> <b>CONTAINS_WORD</b> </p>
        /// <p>The specified part of the web request must include the value of <code>SearchString</code>, and <code>SearchString</code> must contain only alphanumeric characters or underscore (A-Z, a-z, 0-9, or _). In addition, <code>SearchString</code> must be a word, which means that both of the following are true:</p>
        /// <ul>
        /// <li> <p> <code>SearchString</code> is at the beginning of the specified part of the web request or is preceded by a character other than an alphanumeric character or underscore (_). Examples include the value of a header and <code>;BadBot</code>.</p> </li>
        /// <li> <p> <code>SearchString</code> is at the end of the specified part of the web request or is followed by a character other than an alphanumeric character or underscore (_), for example, <code>BadBot;</code> and <code>-BadBot;</code>.</p> </li>
        /// </ul>
        /// <p> <b>EXACTLY</b> </p>
        /// <p>The value of the specified part of the web request must exactly match the value of <code>SearchString</code>.</p>
        /// <p> <b>STARTS_WITH</b> </p>
        /// <p>The value of <code>SearchString</code> must appear at the beginning of the specified part of the web request.</p>
        /// <p> <b>ENDS_WITH</b> </p>
        /// <p>The value of <code>SearchString</code> must appear at the end of the specified part of the web request.</p>
        pub fn positional_constraint(mut self, input: crate::model::PositionalConstraint) -> Self {
            self.positional_constraint = Some(input);
            self
        }
        /// <p>The area within the portion of a web request that you want WAF to search for <code>SearchString</code>. Valid values include the following:</p>
        /// <p> <b>CONTAINS</b> </p>
        /// <p>The specified part of the web request must include the value of <code>SearchString</code>, but the location doesn't matter.</p>
        /// <p> <b>CONTAINS_WORD</b> </p>
        /// <p>The specified part of the web request must include the value of <code>SearchString</code>, and <code>SearchString</code> must contain only alphanumeric characters or underscore (A-Z, a-z, 0-9, or _). In addition, <code>SearchString</code> must be a word, which means that both of the following are true:</p>
        /// <ul>
        /// <li> <p> <code>SearchString</code> is at the beginning of the specified part of the web request or is preceded by a character other than an alphanumeric character or underscore (_). Examples include the value of a header and <code>;BadBot</code>.</p> </li>
        /// <li> <p> <code>SearchString</code> is at the end of the specified part of the web request or is followed by a character other than an alphanumeric character or underscore (_), for example, <code>BadBot;</code> and <code>-BadBot;</code>.</p> </li>
        /// </ul>
        /// <p> <b>EXACTLY</b> </p>
        /// <p>The value of the specified part of the web request must exactly match the value of <code>SearchString</code>.</p>
        /// <p> <b>STARTS_WITH</b> </p>
        /// <p>The value of <code>SearchString</code> must appear at the beginning of the specified part of the web request.</p>
        /// <p> <b>ENDS_WITH</b> </p>
        /// <p>The value of <code>SearchString</code> must appear at the end of the specified part of the web request.</p>
        pub fn set_positional_constraint(
            mut self,
            input: std::option::Option<crate::model::PositionalConstraint>,
        ) -> Self {
            self.positional_constraint = input;
            self
        }
        /// Consumes the builder and constructs a [`ByteMatchStatement`](crate::model::ByteMatchStatement)
        pub fn build(self) -> crate::model::ByteMatchStatement {
            crate::model::ByteMatchStatement {
                search_string: self.search_string,
                field_to_match: self.field_to_match,
                text_transformations: self.text_transformations,
                positional_constraint: self.positional_constraint,
            }
        }
    }
}
impl ByteMatchStatement {
    /// Creates a new builder-style object to manufacture [`ByteMatchStatement`](crate::model::ByteMatchStatement)
    pub fn builder() -> crate::model::byte_match_statement::Builder {
        crate::model::byte_match_statement::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PositionalConstraint {
    #[allow(missing_docs)] // documentation missing in model
    Contains,
    #[allow(missing_docs)] // documentation missing in model
    ContainsWord,
    #[allow(missing_docs)] // documentation missing in model
    EndsWith,
    #[allow(missing_docs)] // documentation missing in model
    Exactly,
    #[allow(missing_docs)] // documentation missing in model
    StartsWith,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PositionalConstraint {
    fn from(s: &str) -> Self {
        match s {
            "CONTAINS" => PositionalConstraint::Contains,
            "CONTAINS_WORD" => PositionalConstraint::ContainsWord,
            "ENDS_WITH" => PositionalConstraint::EndsWith,
            "EXACTLY" => PositionalConstraint::Exactly,
            "STARTS_WITH" => PositionalConstraint::StartsWith,
            other => PositionalConstraint::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PositionalConstraint {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PositionalConstraint::from(s))
    }
}
impl PositionalConstraint {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PositionalConstraint::Contains => "CONTAINS",
            PositionalConstraint::ContainsWord => "CONTAINS_WORD",
            PositionalConstraint::EndsWith => "ENDS_WITH",
            PositionalConstraint::Exactly => "EXACTLY",
            PositionalConstraint::StartsWith => "STARTS_WITH",
            PositionalConstraint::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "CONTAINS",
            "CONTAINS_WORD",
            "ENDS_WITH",
            "EXACTLY",
            "STARTS_WITH",
        ]
    }
}
impl AsRef<str> for PositionalConstraint {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>In a <code>WebACL</code>, this is the action that you want WAF to perform when a web request doesn't match any of the rules in the <code>WebACL</code>. The default action must be a terminating action, so you can't use count.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DefaultAction {
    /// <p>Specifies that WAF should block requests by default. </p>
    pub block: std::option::Option<crate::model::BlockAction>,
    /// <p>Specifies that WAF should allow requests by default.</p>
    pub allow: std::option::Option<crate::model::AllowAction>,
}
impl DefaultAction {
    /// <p>Specifies that WAF should block requests by default. </p>
    pub fn block(&self) -> std::option::Option<&crate::model::BlockAction> {
        self.block.as_ref()
    }
    /// <p>Specifies that WAF should allow requests by default.</p>
    pub fn allow(&self) -> std::option::Option<&crate::model::AllowAction> {
        self.allow.as_ref()
    }
}
impl std::fmt::Debug for DefaultAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DefaultAction");
        formatter.field("block", &self.block);
        formatter.field("allow", &self.allow);
        formatter.finish()
    }
}
/// See [`DefaultAction`](crate::model::DefaultAction)
pub mod default_action {
    /// A builder for [`DefaultAction`](crate::model::DefaultAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) block: std::option::Option<crate::model::BlockAction>,
        pub(crate) allow: std::option::Option<crate::model::AllowAction>,
    }
    impl Builder {
        /// <p>Specifies that WAF should block requests by default. </p>
        pub fn block(mut self, input: crate::model::BlockAction) -> Self {
            self.block = Some(input);
            self
        }
        /// <p>Specifies that WAF should block requests by default. </p>
        pub fn set_block(mut self, input: std::option::Option<crate::model::BlockAction>) -> Self {
            self.block = input;
            self
        }
        /// <p>Specifies that WAF should allow requests by default.</p>
        pub fn allow(mut self, input: crate::model::AllowAction) -> Self {
            self.allow = Some(input);
            self
        }
        /// <p>Specifies that WAF should allow requests by default.</p>
        pub fn set_allow(mut self, input: std::option::Option<crate::model::AllowAction>) -> Self {
            self.allow = input;
            self
        }
        /// Consumes the builder and constructs a [`DefaultAction`](crate::model::DefaultAction)
        pub fn build(self) -> crate::model::DefaultAction {
            crate::model::DefaultAction {
                block: self.block,
                allow: self.allow,
            }
        }
    }
}
impl DefaultAction {
    /// Creates a new builder-style object to manufacture [`DefaultAction`](crate::model::DefaultAction)
    pub fn builder() -> crate::model::default_action::Builder {
        crate::model::default_action::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Scope {
    #[allow(missing_docs)] // documentation missing in model
    Cloudfront,
    #[allow(missing_docs)] // documentation missing in model
    Regional,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Scope {
    fn from(s: &str) -> Self {
        match s {
            "CLOUDFRONT" => Scope::Cloudfront,
            "REGIONAL" => Scope::Regional,
            other => Scope::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Scope {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Scope::from(s))
    }
}
impl Scope {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Scope::Cloudfront => "CLOUDFRONT",
            Scope::Regional => "REGIONAL",
            Scope::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CLOUDFRONT", "REGIONAL"]
    }
}
impl AsRef<str> for Scope {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A single regular expression. This is used in a <code>RegexPatternSet</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Regex {
    /// <p>The string representing the regular expression.</p>
    pub regex_string: std::option::Option<std::string::String>,
}
impl Regex {
    /// <p>The string representing the regular expression.</p>
    pub fn regex_string(&self) -> std::option::Option<&str> {
        self.regex_string.as_deref()
    }
}
impl std::fmt::Debug for Regex {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Regex");
        formatter.field("regex_string", &self.regex_string);
        formatter.finish()
    }
}
/// See [`Regex`](crate::model::Regex)
pub mod regex {
    /// A builder for [`Regex`](crate::model::Regex)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) regex_string: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The string representing the regular expression.</p>
        pub fn regex_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.regex_string = Some(input.into());
            self
        }
        /// <p>The string representing the regular expression.</p>
        pub fn set_regex_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.regex_string = input;
            self
        }
        /// Consumes the builder and constructs a [`Regex`](crate::model::Regex)
        pub fn build(self) -> crate::model::Regex {
            crate::model::Regex {
                regex_string: self.regex_string,
            }
        }
    }
}
impl Regex {
    /// Creates a new builder-style object to manufacture [`Regex`](crate::model::Regex)
    pub fn builder() -> crate::model::regex::Builder {
        crate::model::regex::Builder::default()
    }
}

/// <p>A tag associated with an Amazon Web Services resource. Tags are key:value pairs that you can use to categorize and manage your resources, for purposes like billing or other management. Typically, the tag key represents a category, such as "environment", and the tag value represents a specific value within that category, such as "test," "development," or "production". Or you might set the tag key to "customer" and the value to the customer name or ID. You can specify one or more tags to add to each Amazon Web Services resource, up to 50 tags for a resource.</p>
/// <p>You can tag the Amazon Web Services resources that you manage through WAF: web ACLs, rule groups, IP sets, and regex pattern sets. You can't manage or view tags through the WAF console. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Tag {
    /// <p>Part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>Part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.</p>
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>Part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>Part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Tag");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Tag`](crate::model::Tag)
pub mod tag {
    /// A builder for [`Tag`](crate::model::Tag)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>Part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>Part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>Part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag)
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag)
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>A version of the named managed rule group, that the rule group's vendor publishes for use by customers. </p> <note>
/// <p>This is intended for use only by vendors of managed rule sets. Vendors are Amazon Web Services and Amazon Web Services Marketplace sellers. </p>
/// <p>Vendors, you can use the managed rule set APIs to provide controlled rollout of your versioned managed rule group offerings for your customers. The APIs are <code>ListManagedRuleSets</code>, <code>GetManagedRuleSet</code>, <code>PutManagedRuleSetVersions</code>, and <code>UpdateManagedRuleSetVersionExpiryDate</code>.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VersionToPublish {
    /// <p>The Amazon Resource Name (ARN) of the vendor's rule group that's used in the published managed rule group version. </p>
    pub associated_rule_group_arn: std::option::Option<std::string::String>,
    /// <p>The amount of time the vendor expects this version of the managed rule group to last, in days. </p>
    pub forecasted_lifetime: std::option::Option<i32>,
}
impl VersionToPublish {
    /// <p>The Amazon Resource Name (ARN) of the vendor's rule group that's used in the published managed rule group version. </p>
    pub fn associated_rule_group_arn(&self) -> std::option::Option<&str> {
        self.associated_rule_group_arn.as_deref()
    }
    /// <p>The amount of time the vendor expects this version of the managed rule group to last, in days. </p>
    pub fn forecasted_lifetime(&self) -> std::option::Option<i32> {
        self.forecasted_lifetime
    }
}
impl std::fmt::Debug for VersionToPublish {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VersionToPublish");
        formatter.field("associated_rule_group_arn", &self.associated_rule_group_arn);
        formatter.field("forecasted_lifetime", &self.forecasted_lifetime);
        formatter.finish()
    }
}
/// See [`VersionToPublish`](crate::model::VersionToPublish)
pub mod version_to_publish {
    /// A builder for [`VersionToPublish`](crate::model::VersionToPublish)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) associated_rule_group_arn: std::option::Option<std::string::String>,
        pub(crate) forecasted_lifetime: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the vendor's rule group that's used in the published managed rule group version. </p>
        pub fn associated_rule_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.associated_rule_group_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the vendor's rule group that's used in the published managed rule group version. </p>
        pub fn set_associated_rule_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.associated_rule_group_arn = input;
            self
        }
        /// <p>The amount of time the vendor expects this version of the managed rule group to last, in days. </p>
        pub fn forecasted_lifetime(mut self, input: i32) -> Self {
            self.forecasted_lifetime = Some(input);
            self
        }
        /// <p>The amount of time the vendor expects this version of the managed rule group to last, in days. </p>
        pub fn set_forecasted_lifetime(mut self, input: std::option::Option<i32>) -> Self {
            self.forecasted_lifetime = input;
            self
        }
        /// Consumes the builder and constructs a [`VersionToPublish`](crate::model::VersionToPublish)
        pub fn build(self) -> crate::model::VersionToPublish {
            crate::model::VersionToPublish {
                associated_rule_group_arn: self.associated_rule_group_arn,
                forecasted_lifetime: self.forecasted_lifetime,
            }
        }
    }
}
impl VersionToPublish {
    /// Creates a new builder-style object to manufacture [`VersionToPublish`](crate::model::VersionToPublish)
    pub fn builder() -> crate::model::version_to_publish::Builder {
        crate::model::version_to_publish::Builder::default()
    }
}

/// <p>Defines an association between logging destinations and a web ACL resource, for logging from WAF. As part of the association, you can specify parts of the standard logging fields to keep out of the logs and you can specify filters so that you log only a subset of the logging records. </p> <note>
/// <p>You can define one logging destination per web ACL.</p>
/// </note>
/// <p>You can access information about the traffic that WAF inspects using the following steps:</p>
/// <ol>
/// <li> <p>Create your logging destination. You can use an Amazon CloudWatch Logs log group, an Amazon Simple Storage Service (Amazon S3) bucket, or an Amazon Kinesis Data Firehose. For information about configuring logging destinations and the permissions that are required for each, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/logging.html">Logging web ACL traffic information</a> in the <i>WAF Developer Guide</i>.</p> </li>
/// <li> <p>Associate your logging destination to your web ACL using a <code>PutLoggingConfiguration</code> request.</p> </li>
/// </ol>
/// <p>When you successfully enable logging using a <code>PutLoggingConfiguration</code> request, WAF creates an additional role or policy that is required to write logs to the logging destination. For an Amazon CloudWatch Logs log group, WAF creates a resource policy on the log group. For an Amazon S3 bucket, WAF creates a bucket policy. For an Amazon Kinesis Data Firehose, WAF creates a service-linked role.</p>
/// <p>For additional information about web ACL logging, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/logging.html">Logging web ACL traffic information</a> in the <i>WAF Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LoggingConfiguration {
    /// <p>The Amazon Resource Name (ARN) of the web ACL that you want to associate with <code>LogDestinationConfigs</code>.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The logging destination configuration that you want to associate with the web ACL.</p> <note>
    /// <p>You can associate one logging destination to a web ACL.</p>
    /// </note>
    pub log_destination_configs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The parts of the request that you want to keep out of the logs. For example, if you redact the <code>SingleHeader</code> field, the <code>HEADER</code> field in the logs will be <code>xxx</code>. </p> <note>
    /// <p>You can specify only the following fields for redaction: <code>UriPath</code>, <code>QueryString</code>, <code>SingleHeader</code>, <code>Method</code>, and <code>JsonBody</code>.</p>
    /// </note>
    pub redacted_fields: std::option::Option<std::vec::Vec<crate::model::FieldToMatch>>,
    /// <p>Indicates whether the logging configuration was created by Firewall Manager, as part of an WAF policy configuration. If true, only Firewall Manager can modify or delete the configuration. </p>
    pub managed_by_firewall_manager: bool,
    /// <p>Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation. </p>
    pub logging_filter: std::option::Option<crate::model::LoggingFilter>,
}
impl LoggingConfiguration {
    /// <p>The Amazon Resource Name (ARN) of the web ACL that you want to associate with <code>LogDestinationConfigs</code>.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The logging destination configuration that you want to associate with the web ACL.</p> <note>
    /// <p>You can associate one logging destination to a web ACL.</p>
    /// </note>
    pub fn log_destination_configs(&self) -> std::option::Option<&[std::string::String]> {
        self.log_destination_configs.as_deref()
    }
    /// <p>The parts of the request that you want to keep out of the logs. For example, if you redact the <code>SingleHeader</code> field, the <code>HEADER</code> field in the logs will be <code>xxx</code>. </p> <note>
    /// <p>You can specify only the following fields for redaction: <code>UriPath</code>, <code>QueryString</code>, <code>SingleHeader</code>, <code>Method</code>, and <code>JsonBody</code>.</p>
    /// </note>
    pub fn redacted_fields(&self) -> std::option::Option<&[crate::model::FieldToMatch]> {
        self.redacted_fields.as_deref()
    }
    /// <p>Indicates whether the logging configuration was created by Firewall Manager, as part of an WAF policy configuration. If true, only Firewall Manager can modify or delete the configuration. </p>
    pub fn managed_by_firewall_manager(&self) -> bool {
        self.managed_by_firewall_manager
    }
    /// <p>Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation. </p>
    pub fn logging_filter(&self) -> std::option::Option<&crate::model::LoggingFilter> {
        self.logging_filter.as_ref()
    }
}
impl std::fmt::Debug for LoggingConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LoggingConfiguration");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("log_destination_configs", &self.log_destination_configs);
        formatter.field("redacted_fields", &self.redacted_fields);
        formatter.field(
            "managed_by_firewall_manager",
            &self.managed_by_firewall_manager,
        );
        formatter.field("logging_filter", &self.logging_filter);
        formatter.finish()
    }
}
/// See [`LoggingConfiguration`](crate::model::LoggingConfiguration)
pub mod logging_configuration {
    /// A builder for [`LoggingConfiguration`](crate::model::LoggingConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) log_destination_configs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) redacted_fields: std::option::Option<std::vec::Vec<crate::model::FieldToMatch>>,
        pub(crate) managed_by_firewall_manager: std::option::Option<bool>,
        pub(crate) logging_filter: std::option::Option<crate::model::LoggingFilter>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the web ACL that you want to associate with <code>LogDestinationConfigs</code>.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the web ACL that you want to associate with <code>LogDestinationConfigs</code>.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `log_destination_configs`.
        ///
        /// To override the contents of this collection use [`set_log_destination_configs`](Self::set_log_destination_configs).
        ///
        /// <p>The logging destination configuration that you want to associate with the web ACL.</p> <note>
        /// <p>You can associate one logging destination to a web ACL.</p>
        /// </note>
        pub fn log_destination_configs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.log_destination_configs.unwrap_or_default();
            v.push(input.into());
            self.log_destination_configs = Some(v);
            self
        }
        /// <p>The logging destination configuration that you want to associate with the web ACL.</p> <note>
        /// <p>You can associate one logging destination to a web ACL.</p>
        /// </note>
        pub fn set_log_destination_configs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.log_destination_configs = input;
            self
        }
        /// Appends an item to `redacted_fields`.
        ///
        /// To override the contents of this collection use [`set_redacted_fields`](Self::set_redacted_fields).
        ///
        /// <p>The parts of the request that you want to keep out of the logs. For example, if you redact the <code>SingleHeader</code> field, the <code>HEADER</code> field in the logs will be <code>xxx</code>. </p> <note>
        /// <p>You can specify only the following fields for redaction: <code>UriPath</code>, <code>QueryString</code>, <code>SingleHeader</code>, <code>Method</code>, and <code>JsonBody</code>.</p>
        /// </note>
        pub fn redacted_fields(mut self, input: crate::model::FieldToMatch) -> Self {
            let mut v = self.redacted_fields.unwrap_or_default();
            v.push(input);
            self.redacted_fields = Some(v);
            self
        }
        /// <p>The parts of the request that you want to keep out of the logs. For example, if you redact the <code>SingleHeader</code> field, the <code>HEADER</code> field in the logs will be <code>xxx</code>. </p> <note>
        /// <p>You can specify only the following fields for redaction: <code>UriPath</code>, <code>QueryString</code>, <code>SingleHeader</code>, <code>Method</code>, and <code>JsonBody</code>.</p>
        /// </note>
        pub fn set_redacted_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldToMatch>>,
        ) -> Self {
            self.redacted_fields = input;
            self
        }
        /// <p>Indicates whether the logging configuration was created by Firewall Manager, as part of an WAF policy configuration. If true, only Firewall Manager can modify or delete the configuration. </p>
        pub fn managed_by_firewall_manager(mut self, input: bool) -> Self {
            self.managed_by_firewall_manager = Some(input);
            self
        }
        /// <p>Indicates whether the logging configuration was created by Firewall Manager, as part of an WAF policy configuration. If true, only Firewall Manager can modify or delete the configuration. </p>
        pub fn set_managed_by_firewall_manager(mut self, input: std::option::Option<bool>) -> Self {
            self.managed_by_firewall_manager = input;
            self
        }
        /// <p>Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation. </p>
        pub fn logging_filter(mut self, input: crate::model::LoggingFilter) -> Self {
            self.logging_filter = Some(input);
            self
        }
        /// <p>Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation. </p>
        pub fn set_logging_filter(
            mut self,
            input: std::option::Option<crate::model::LoggingFilter>,
        ) -> Self {
            self.logging_filter = input;
            self
        }
        /// Consumes the builder and constructs a [`LoggingConfiguration`](crate::model::LoggingConfiguration)
        pub fn build(self) -> crate::model::LoggingConfiguration {
            crate::model::LoggingConfiguration {
                resource_arn: self.resource_arn,
                log_destination_configs: self.log_destination_configs,
                redacted_fields: self.redacted_fields,
                managed_by_firewall_manager: self.managed_by_firewall_manager.unwrap_or_default(),
                logging_filter: self.logging_filter,
            }
        }
    }
}
impl LoggingConfiguration {
    /// Creates a new builder-style object to manufacture [`LoggingConfiguration`](crate::model::LoggingConfiguration)
    pub fn builder() -> crate::model::logging_configuration::Builder {
        crate::model::logging_configuration::Builder::default()
    }
}

/// <p>Filtering that specifies which web requests are kept in the logs and which are dropped, defined for a web ACL's <code>LoggingConfiguration</code>. </p>
/// <p>You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LoggingFilter {
    /// <p>The filters that you want to apply to the logs. </p>
    pub filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
    /// <p>Default handling for logs that don't match any of the specified filtering conditions. </p>
    pub default_behavior: std::option::Option<crate::model::FilterBehavior>,
}
impl LoggingFilter {
    /// <p>The filters that you want to apply to the logs. </p>
    pub fn filters(&self) -> std::option::Option<&[crate::model::Filter]> {
        self.filters.as_deref()
    }
    /// <p>Default handling for logs that don't match any of the specified filtering conditions. </p>
    pub fn default_behavior(&self) -> std::option::Option<&crate::model::FilterBehavior> {
        self.default_behavior.as_ref()
    }
}
impl std::fmt::Debug for LoggingFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LoggingFilter");
        formatter.field("filters", &self.filters);
        formatter.field("default_behavior", &self.default_behavior);
        formatter.finish()
    }
}
/// See [`LoggingFilter`](crate::model::LoggingFilter)
pub mod logging_filter {
    /// A builder for [`LoggingFilter`](crate::model::LoggingFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        pub(crate) default_behavior: std::option::Option<crate::model::FilterBehavior>,
    }
    impl Builder {
        /// Appends an item to `filters`.
        ///
        /// To override the contents of this collection use [`set_filters`](Self::set_filters).
        ///
        /// <p>The filters that you want to apply to the logs. </p>
        pub fn filters(mut self, input: crate::model::Filter) -> Self {
            let mut v = self.filters.unwrap_or_default();
            v.push(input);
            self.filters = Some(v);
            self
        }
        /// <p>The filters that you want to apply to the logs. </p>
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.filters = input;
            self
        }
        /// <p>Default handling for logs that don't match any of the specified filtering conditions. </p>
        pub fn default_behavior(mut self, input: crate::model::FilterBehavior) -> Self {
            self.default_behavior = Some(input);
            self
        }
        /// <p>Default handling for logs that don't match any of the specified filtering conditions. </p>
        pub fn set_default_behavior(
            mut self,
            input: std::option::Option<crate::model::FilterBehavior>,
        ) -> Self {
            self.default_behavior = input;
            self
        }
        /// Consumes the builder and constructs a [`LoggingFilter`](crate::model::LoggingFilter)
        pub fn build(self) -> crate::model::LoggingFilter {
            crate::model::LoggingFilter {
                filters: self.filters,
                default_behavior: self.default_behavior,
            }
        }
    }
}
impl LoggingFilter {
    /// Creates a new builder-style object to manufacture [`LoggingFilter`](crate::model::LoggingFilter)
    pub fn builder() -> crate::model::logging_filter::Builder {
        crate::model::logging_filter::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FilterBehavior {
    #[allow(missing_docs)] // documentation missing in model
    Drop,
    #[allow(missing_docs)] // documentation missing in model
    Keep,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FilterBehavior {
    fn from(s: &str) -> Self {
        match s {
            "DROP" => FilterBehavior::Drop,
            "KEEP" => FilterBehavior::Keep,
            other => FilterBehavior::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FilterBehavior {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FilterBehavior::from(s))
    }
}
impl FilterBehavior {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FilterBehavior::Drop => "DROP",
            FilterBehavior::Keep => "KEEP",
            FilterBehavior::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["DROP", "KEEP"]
    }
}
impl AsRef<str> for FilterBehavior {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A single logging filter, used in <code>LoggingFilter</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Filter {
    /// <p>How to handle logs that satisfy the filter's conditions and requirement. </p>
    pub behavior: std::option::Option<crate::model::FilterBehavior>,
    /// <p>Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.</p>
    pub requirement: std::option::Option<crate::model::FilterRequirement>,
    /// <p>Match conditions for the filter.</p>
    pub conditions: std::option::Option<std::vec::Vec<crate::model::Condition>>,
}
impl Filter {
    /// <p>How to handle logs that satisfy the filter's conditions and requirement. </p>
    pub fn behavior(&self) -> std::option::Option<&crate::model::FilterBehavior> {
        self.behavior.as_ref()
    }
    /// <p>Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.</p>
    pub fn requirement(&self) -> std::option::Option<&crate::model::FilterRequirement> {
        self.requirement.as_ref()
    }
    /// <p>Match conditions for the filter.</p>
    pub fn conditions(&self) -> std::option::Option<&[crate::model::Condition]> {
        self.conditions.as_deref()
    }
}
impl std::fmt::Debug for Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Filter");
        formatter.field("behavior", &self.behavior);
        formatter.field("requirement", &self.requirement);
        formatter.field("conditions", &self.conditions);
        formatter.finish()
    }
}
/// See [`Filter`](crate::model::Filter)
pub mod filter {
    /// A builder for [`Filter`](crate::model::Filter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) behavior: std::option::Option<crate::model::FilterBehavior>,
        pub(crate) requirement: std::option::Option<crate::model::FilterRequirement>,
        pub(crate) conditions: std::option::Option<std::vec::Vec<crate::model::Condition>>,
    }
    impl Builder {
        /// <p>How to handle logs that satisfy the filter's conditions and requirement. </p>
        pub fn behavior(mut self, input: crate::model::FilterBehavior) -> Self {
            self.behavior = Some(input);
            self
        }
        /// <p>How to handle logs that satisfy the filter's conditions and requirement. </p>
        pub fn set_behavior(
            mut self,
            input: std::option::Option<crate::model::FilterBehavior>,
        ) -> Self {
            self.behavior = input;
            self
        }
        /// <p>Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.</p>
        pub fn requirement(mut self, input: crate::model::FilterRequirement) -> Self {
            self.requirement = Some(input);
            self
        }
        /// <p>Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.</p>
        pub fn set_requirement(
            mut self,
            input: std::option::Option<crate::model::FilterRequirement>,
        ) -> Self {
            self.requirement = input;
            self
        }
        /// Appends an item to `conditions`.
        ///
        /// To override the contents of this collection use [`set_conditions`](Self::set_conditions).
        ///
        /// <p>Match conditions for the filter.</p>
        pub fn conditions(mut self, input: crate::model::Condition) -> Self {
            let mut v = self.conditions.unwrap_or_default();
            v.push(input);
            self.conditions = Some(v);
            self
        }
        /// <p>Match conditions for the filter.</p>
        pub fn set_conditions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Condition>>,
        ) -> Self {
            self.conditions = input;
            self
        }
        /// Consumes the builder and constructs a [`Filter`](crate::model::Filter)
        pub fn build(self) -> crate::model::Filter {
            crate::model::Filter {
                behavior: self.behavior,
                requirement: self.requirement,
                conditions: self.conditions,
            }
        }
    }
}
impl Filter {
    /// Creates a new builder-style object to manufacture [`Filter`](crate::model::Filter)
    pub fn builder() -> crate::model::filter::Builder {
        crate::model::filter::Builder::default()
    }
}

/// <p>A single match condition for a <code>Filter</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Condition {
    /// <p>A single action condition.</p>
    pub action_condition: std::option::Option<crate::model::ActionCondition>,
    /// <p>A single label name condition.</p>
    pub label_name_condition: std::option::Option<crate::model::LabelNameCondition>,
}
impl Condition {
    /// <p>A single action condition.</p>
    pub fn action_condition(&self) -> std::option::Option<&crate::model::ActionCondition> {
        self.action_condition.as_ref()
    }
    /// <p>A single label name condition.</p>
    pub fn label_name_condition(&self) -> std::option::Option<&crate::model::LabelNameCondition> {
        self.label_name_condition.as_ref()
    }
}
impl std::fmt::Debug for Condition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Condition");
        formatter.field("action_condition", &self.action_condition);
        formatter.field("label_name_condition", &self.label_name_condition);
        formatter.finish()
    }
}
/// See [`Condition`](crate::model::Condition)
pub mod condition {
    /// A builder for [`Condition`](crate::model::Condition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action_condition: std::option::Option<crate::model::ActionCondition>,
        pub(crate) label_name_condition: std::option::Option<crate::model::LabelNameCondition>,
    }
    impl Builder {
        /// <p>A single action condition.</p>
        pub fn action_condition(mut self, input: crate::model::ActionCondition) -> Self {
            self.action_condition = Some(input);
            self
        }
        /// <p>A single action condition.</p>
        pub fn set_action_condition(
            mut self,
            input: std::option::Option<crate::model::ActionCondition>,
        ) -> Self {
            self.action_condition = input;
            self
        }
        /// <p>A single label name condition.</p>
        pub fn label_name_condition(mut self, input: crate::model::LabelNameCondition) -> Self {
            self.label_name_condition = Some(input);
            self
        }
        /// <p>A single label name condition.</p>
        pub fn set_label_name_condition(
            mut self,
            input: std::option::Option<crate::model::LabelNameCondition>,
        ) -> Self {
            self.label_name_condition = input;
            self
        }
        /// Consumes the builder and constructs a [`Condition`](crate::model::Condition)
        pub fn build(self) -> crate::model::Condition {
            crate::model::Condition {
                action_condition: self.action_condition,
                label_name_condition: self.label_name_condition,
            }
        }
    }
}
impl Condition {
    /// Creates a new builder-style object to manufacture [`Condition`](crate::model::Condition)
    pub fn builder() -> crate::model::condition::Builder {
        crate::model::condition::Builder::default()
    }
}

/// <p>A single label name condition for a <code>Condition</code> in a logging filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelNameCondition {
    /// <p>The label name that a log record must contain in order to meet the condition. This must be a fully qualified label name. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. </p>
    pub label_name: std::option::Option<std::string::String>,
}
impl LabelNameCondition {
    /// <p>The label name that a log record must contain in order to meet the condition. This must be a fully qualified label name. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. </p>
    pub fn label_name(&self) -> std::option::Option<&str> {
        self.label_name.as_deref()
    }
}
impl std::fmt::Debug for LabelNameCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelNameCondition");
        formatter.field("label_name", &self.label_name);
        formatter.finish()
    }
}
/// See [`LabelNameCondition`](crate::model::LabelNameCondition)
pub mod label_name_condition {
    /// A builder for [`LabelNameCondition`](crate::model::LabelNameCondition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) label_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The label name that a log record must contain in order to meet the condition. This must be a fully qualified label name. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. </p>
        pub fn label_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.label_name = Some(input.into());
            self
        }
        /// <p>The label name that a log record must contain in order to meet the condition. This must be a fully qualified label name. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. </p>
        pub fn set_label_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.label_name = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelNameCondition`](crate::model::LabelNameCondition)
        pub fn build(self) -> crate::model::LabelNameCondition {
            crate::model::LabelNameCondition {
                label_name: self.label_name,
            }
        }
    }
}
impl LabelNameCondition {
    /// Creates a new builder-style object to manufacture [`LabelNameCondition`](crate::model::LabelNameCondition)
    pub fn builder() -> crate::model::label_name_condition::Builder {
        crate::model::label_name_condition::Builder::default()
    }
}

/// <p>A single action condition for a <code>Condition</code> in a logging filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ActionCondition {
    /// <p>The action setting that a log record must contain in order to meet the condition. </p>
    pub action: std::option::Option<crate::model::ActionValue>,
}
impl ActionCondition {
    /// <p>The action setting that a log record must contain in order to meet the condition. </p>
    pub fn action(&self) -> std::option::Option<&crate::model::ActionValue> {
        self.action.as_ref()
    }
}
impl std::fmt::Debug for ActionCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ActionCondition");
        formatter.field("action", &self.action);
        formatter.finish()
    }
}
/// See [`ActionCondition`](crate::model::ActionCondition)
pub mod action_condition {
    /// A builder for [`ActionCondition`](crate::model::ActionCondition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action: std::option::Option<crate::model::ActionValue>,
    }
    impl Builder {
        /// <p>The action setting that a log record must contain in order to meet the condition. </p>
        pub fn action(mut self, input: crate::model::ActionValue) -> Self {
            self.action = Some(input);
            self
        }
        /// <p>The action setting that a log record must contain in order to meet the condition. </p>
        pub fn set_action(mut self, input: std::option::Option<crate::model::ActionValue>) -> Self {
            self.action = input;
            self
        }
        /// Consumes the builder and constructs a [`ActionCondition`](crate::model::ActionCondition)
        pub fn build(self) -> crate::model::ActionCondition {
            crate::model::ActionCondition {
                action: self.action,
            }
        }
    }
}
impl ActionCondition {
    /// Creates a new builder-style object to manufacture [`ActionCondition`](crate::model::ActionCondition)
    pub fn builder() -> crate::model::action_condition::Builder {
        crate::model::action_condition::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ActionValue {
    #[allow(missing_docs)] // documentation missing in model
    Allow,
    #[allow(missing_docs)] // documentation missing in model
    Block,
    #[allow(missing_docs)] // documentation missing in model
    Captcha,
    #[allow(missing_docs)] // documentation missing in model
    Count,
    #[allow(missing_docs)] // documentation missing in model
    ExcludedAsCount,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ActionValue {
    fn from(s: &str) -> Self {
        match s {
            "ALLOW" => ActionValue::Allow,
            "BLOCK" => ActionValue::Block,
            "CAPTCHA" => ActionValue::Captcha,
            "COUNT" => ActionValue::Count,
            "EXCLUDED_AS_COUNT" => ActionValue::ExcludedAsCount,
            other => ActionValue::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ActionValue {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ActionValue::from(s))
    }
}
impl ActionValue {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ActionValue::Allow => "ALLOW",
            ActionValue::Block => "BLOCK",
            ActionValue::Captcha => "CAPTCHA",
            ActionValue::Count => "COUNT",
            ActionValue::ExcludedAsCount => "EXCLUDED_AS_COUNT",
            ActionValue::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ALLOW", "BLOCK", "CAPTCHA", "COUNT", "EXCLUDED_AS_COUNT"]
    }
}
impl AsRef<str> for ActionValue {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FilterRequirement {
    #[allow(missing_docs)] // documentation missing in model
    MeetsAll,
    #[allow(missing_docs)] // documentation missing in model
    MeetsAny,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FilterRequirement {
    fn from(s: &str) -> Self {
        match s {
            "MEETS_ALL" => FilterRequirement::MeetsAll,
            "MEETS_ANY" => FilterRequirement::MeetsAny,
            other => FilterRequirement::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FilterRequirement {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FilterRequirement::from(s))
    }
}
impl FilterRequirement {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FilterRequirement::MeetsAll => "MEETS_ALL",
            FilterRequirement::MeetsAny => "MEETS_ANY",
            FilterRequirement::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["MEETS_ALL", "MEETS_ANY"]
    }
}
impl AsRef<str> for FilterRequirement {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>High-level information about a <code>WebACL</code>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage a <code>WebACL</code>, and the ARN, that you provide to operations like <code>AssociateWebACL</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WebAclSummary {
    /// <p>The name of the web ACL. You cannot change the name of a web ACL after you create it.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the web ACL. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>A description of the web ACL that helps with identification. </p>
    pub description: std::option::Option<std::string::String>,
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub lock_token: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    pub arn: std::option::Option<std::string::String>,
}
impl WebAclSummary {
    /// <p>The name of the web ACL. You cannot change the name of a web ACL after you create it.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The unique identifier for the web ACL. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>A description of the web ACL that helps with identification. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub fn lock_token(&self) -> std::option::Option<&str> {
        self.lock_token.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl std::fmt::Debug for WebAclSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WebAclSummary");
        formatter.field("name", &self.name);
        formatter.field("id", &self.id);
        formatter.field("description", &self.description);
        formatter.field("lock_token", &self.lock_token);
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}
/// See [`WebAclSummary`](crate::model::WebAclSummary)
pub mod web_acl_summary {
    /// A builder for [`WebAclSummary`](crate::model::WebAclSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) lock_token: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the web ACL. You cannot change the name of a web ACL after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the web ACL. You cannot change the name of a web ACL after you create it.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The unique identifier for the web ACL. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the web ACL. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>A description of the web ACL that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the web ACL that helps with identification. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.lock_token = Some(input.into());
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lock_token = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entity.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entity.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`WebAclSummary`](crate::model::WebAclSummary)
        pub fn build(self) -> crate::model::WebAclSummary {
            crate::model::WebAclSummary {
                name: self.name,
                id: self.id,
                description: self.description,
                lock_token: self.lock_token,
                arn: self.arn,
            }
        }
    }
}
impl WebAclSummary {
    /// Creates a new builder-style object to manufacture [`WebAclSummary`](crate::model::WebAclSummary)
    pub fn builder() -> crate::model::web_acl_summary::Builder {
        crate::model::web_acl_summary::Builder::default()
    }
}

/// <p>The collection of tagging definitions for an Amazon Web Services resource. Tags are key:value pairs that you can use to categorize and manage your resources, for purposes like billing or other management. Typically, the tag key represents a category, such as "environment", and the tag value represents a specific value within that category, such as "test," "development," or "production". Or you might set the tag key to "customer" and the value to the customer name or ID. You can specify one or more tags to add to each Amazon Web Services resource, up to 50 tags for a resource.</p>
/// <p>You can tag the Amazon Web Services resources that you manage through WAF: web ACLs, rule groups, IP sets, and regex pattern sets. You can't manage or view tags through the WAF console. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagInfoForResource {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The array of <code>Tag</code> objects defined for the resource. </p>
    pub tag_list: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl TagInfoForResource {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The array of <code>Tag</code> objects defined for the resource. </p>
    pub fn tag_list(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tag_list.as_deref()
    }
}
impl std::fmt::Debug for TagInfoForResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagInfoForResource");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tag_list", &self.tag_list);
        formatter.finish()
    }
}
/// See [`TagInfoForResource`](crate::model::TagInfoForResource)
pub mod tag_info_for_resource {
    /// A builder for [`TagInfoForResource`](crate::model::TagInfoForResource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_list: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tag_list`.
        ///
        /// To override the contents of this collection use [`set_tag_list`](Self::set_tag_list).
        ///
        /// <p>The array of <code>Tag</code> objects defined for the resource. </p>
        pub fn tag_list(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tag_list.unwrap_or_default();
            v.push(input);
            self.tag_list = Some(v);
            self
        }
        /// <p>The array of <code>Tag</code> objects defined for the resource. </p>
        pub fn set_tag_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tag_list = input;
            self
        }
        /// Consumes the builder and constructs a [`TagInfoForResource`](crate::model::TagInfoForResource)
        pub fn build(self) -> crate::model::TagInfoForResource {
            crate::model::TagInfoForResource {
                resource_arn: self.resource_arn,
                tag_list: self.tag_list,
            }
        }
    }
}
impl TagInfoForResource {
    /// Creates a new builder-style object to manufacture [`TagInfoForResource`](crate::model::TagInfoForResource)
    pub fn builder() -> crate::model::tag_info_for_resource::Builder {
        crate::model::tag_info_for_resource::Builder::default()
    }
}

/// <p>High-level information about a <code>RuleGroup</code>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage a <code>RuleGroup</code>, and the ARN, that you provide to the <code>RuleGroupReferenceStatement</code> to use the rule group in a <code>Rule</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuleGroupSummary {
    /// <p>The name of the data type instance. You cannot change the name after you create the instance.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the rule group. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>A description of the rule group that helps with identification. </p>
    pub description: std::option::Option<std::string::String>,
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub lock_token: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    pub arn: std::option::Option<std::string::String>,
}
impl RuleGroupSummary {
    /// <p>The name of the data type instance. You cannot change the name after you create the instance.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A unique identifier for the rule group. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>A description of the rule group that helps with identification. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub fn lock_token(&self) -> std::option::Option<&str> {
        self.lock_token.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl std::fmt::Debug for RuleGroupSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RuleGroupSummary");
        formatter.field("name", &self.name);
        formatter.field("id", &self.id);
        formatter.field("description", &self.description);
        formatter.field("lock_token", &self.lock_token);
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}
/// See [`RuleGroupSummary`](crate::model::RuleGroupSummary)
pub mod rule_group_summary {
    /// A builder for [`RuleGroupSummary`](crate::model::RuleGroupSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) lock_token: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the data type instance. You cannot change the name after you create the instance.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data type instance. You cannot change the name after you create the instance.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A unique identifier for the rule group. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the rule group. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>A description of the rule group that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the rule group that helps with identification. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.lock_token = Some(input.into());
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lock_token = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entity.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entity.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleGroupSummary`](crate::model::RuleGroupSummary)
        pub fn build(self) -> crate::model::RuleGroupSummary {
            crate::model::RuleGroupSummary {
                name: self.name,
                id: self.id,
                description: self.description,
                lock_token: self.lock_token,
                arn: self.arn,
            }
        }
    }
}
impl RuleGroupSummary {
    /// Creates a new builder-style object to manufacture [`RuleGroupSummary`](crate::model::RuleGroupSummary)
    pub fn builder() -> crate::model::rule_group_summary::Builder {
        crate::model::rule_group_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceType {
    #[allow(missing_docs)] // documentation missing in model
    ApiGateway,
    #[allow(missing_docs)] // documentation missing in model
    ApplicationLoadBalancer,
    #[allow(missing_docs)] // documentation missing in model
    Appsync,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ResourceType {
    fn from(s: &str) -> Self {
        match s {
            "API_GATEWAY" => ResourceType::ApiGateway,
            "APPLICATION_LOAD_BALANCER" => ResourceType::ApplicationLoadBalancer,
            "APPSYNC" => ResourceType::Appsync,
            other => ResourceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceType::from(s))
    }
}
impl ResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceType::ApiGateway => "API_GATEWAY",
            ResourceType::ApplicationLoadBalancer => "APPLICATION_LOAD_BALANCER",
            ResourceType::Appsync => "APPSYNC",
            ResourceType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["API_GATEWAY", "APPLICATION_LOAD_BALANCER", "APPSYNC"]
    }
}
impl AsRef<str> for ResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>High-level information about a <code>RegexPatternSet</code>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage a <code>RegexPatternSet</code>, and the ARN, that you provide to the <code>RegexPatternSetReferenceStatement</code> to use the pattern set in a <code>Rule</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegexPatternSetSummary {
    /// <p>The name of the data type instance. You cannot change the name after you create the instance.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>A description of the set that helps with identification. </p>
    pub description: std::option::Option<std::string::String>,
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub lock_token: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    pub arn: std::option::Option<std::string::String>,
}
impl RegexPatternSetSummary {
    /// <p>The name of the data type instance. You cannot change the name after you create the instance.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>A description of the set that helps with identification. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub fn lock_token(&self) -> std::option::Option<&str> {
        self.lock_token.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl std::fmt::Debug for RegexPatternSetSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegexPatternSetSummary");
        formatter.field("name", &self.name);
        formatter.field("id", &self.id);
        formatter.field("description", &self.description);
        formatter.field("lock_token", &self.lock_token);
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}
/// See [`RegexPatternSetSummary`](crate::model::RegexPatternSetSummary)
pub mod regex_pattern_set_summary {
    /// A builder for [`RegexPatternSetSummary`](crate::model::RegexPatternSetSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) lock_token: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the data type instance. You cannot change the name after you create the instance.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data type instance. You cannot change the name after you create the instance.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>A description of the set that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the set that helps with identification. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.lock_token = Some(input.into());
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lock_token = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entity.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entity.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`RegexPatternSetSummary`](crate::model::RegexPatternSetSummary)
        pub fn build(self) -> crate::model::RegexPatternSetSummary {
            crate::model::RegexPatternSetSummary {
                name: self.name,
                id: self.id,
                description: self.description,
                lock_token: self.lock_token,
                arn: self.arn,
            }
        }
    }
}
impl RegexPatternSetSummary {
    /// Creates a new builder-style object to manufacture [`RegexPatternSetSummary`](crate::model::RegexPatternSetSummary)
    pub fn builder() -> crate::model::regex_pattern_set_summary::Builder {
        crate::model::regex_pattern_set_summary::Builder::default()
    }
}

/// <p>High level information for an SDK release. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReleaseSummary {
    /// <p>The release version. </p>
    pub release_version: std::option::Option<std::string::String>,
    /// <p>The timestamp of the release. </p>
    pub timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl ReleaseSummary {
    /// <p>The release version. </p>
    pub fn release_version(&self) -> std::option::Option<&str> {
        self.release_version.as_deref()
    }
    /// <p>The timestamp of the release. </p>
    pub fn timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.timestamp.as_ref()
    }
}
impl std::fmt::Debug for ReleaseSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReleaseSummary");
        formatter.field("release_version", &self.release_version);
        formatter.field("timestamp", &self.timestamp);
        formatter.finish()
    }
}
/// See [`ReleaseSummary`](crate::model::ReleaseSummary)
pub mod release_summary {
    /// A builder for [`ReleaseSummary`](crate::model::ReleaseSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) release_version: std::option::Option<std::string::String>,
        pub(crate) timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The release version. </p>
        pub fn release_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.release_version = Some(input.into());
            self
        }
        /// <p>The release version. </p>
        pub fn set_release_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.release_version = input;
            self
        }
        /// <p>The timestamp of the release. </p>
        pub fn timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.timestamp = Some(input);
            self
        }
        /// <p>The timestamp of the release. </p>
        pub fn set_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`ReleaseSummary`](crate::model::ReleaseSummary)
        pub fn build(self) -> crate::model::ReleaseSummary {
            crate::model::ReleaseSummary {
                release_version: self.release_version,
                timestamp: self.timestamp,
            }
        }
    }
}
impl ReleaseSummary {
    /// Creates a new builder-style object to manufacture [`ReleaseSummary`](crate::model::ReleaseSummary)
    pub fn builder() -> crate::model::release_summary::Builder {
        crate::model::release_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Platform {
    #[allow(missing_docs)] // documentation missing in model
    Android,
    #[allow(missing_docs)] // documentation missing in model
    Ios,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Platform {
    fn from(s: &str) -> Self {
        match s {
            "ANDROID" => Platform::Android,
            "IOS" => Platform::Ios,
            other => Platform::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Platform {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Platform::from(s))
    }
}
impl Platform {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Platform::Android => "ANDROID",
            Platform::Ios => "IOS",
            Platform::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ANDROID", "IOS"]
    }
}
impl AsRef<str> for Platform {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>High-level information for a managed rule set. </p> <note>
/// <p>This is intended for use only by vendors of managed rule sets. Vendors are Amazon Web Services and Amazon Web Services Marketplace sellers. </p>
/// <p>Vendors, you can use the managed rule set APIs to provide controlled rollout of your versioned managed rule group offerings for your customers. The APIs are <code>ListManagedRuleSets</code>, <code>GetManagedRuleSet</code>, <code>PutManagedRuleSetVersions</code>, and <code>UpdateManagedRuleSetVersionExpiryDate</code>.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ManagedRuleSetSummary {
    /// <p>The name of the managed rule set. You use this, along with the rule set ID, to identify the rule set.</p>
    /// <p>This name is assigned to the corresponding managed rule group, which your customers can access and use. </p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the managed rule set. The ID is returned in the responses to commands like <code>list</code>. You provide it to operations like <code>get</code> and <code>update</code>.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>A description of the set that helps with identification. </p>
    pub description: std::option::Option<std::string::String>,
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub lock_token: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The label namespace prefix for the managed rule groups that are offered to customers from this managed rule set. All labels that are added by rules in the managed rule group have this prefix. </p>
    /// <ul>
    /// <li> <p>The syntax for the label namespace prefix for a managed rule group is the following: </p> <p> <code>awswaf:managed:
    /// <vendor>
    /// :
    /// <rule group name></rule>
    /// </vendor></code>:</p> </li>
    /// <li> <p>When a rule with a label matches a web request, WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p> <p> <code><label namespace>:<label from rule></label></label></code> </p> </li>
    /// </ul>
    pub label_namespace: std::option::Option<std::string::String>,
}
impl ManagedRuleSetSummary {
    /// <p>The name of the managed rule set. You use this, along with the rule set ID, to identify the rule set.</p>
    /// <p>This name is assigned to the corresponding managed rule group, which your customers can access and use. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A unique identifier for the managed rule set. The ID is returned in the responses to commands like <code>list</code>. You provide it to operations like <code>get</code> and <code>update</code>.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>A description of the set that helps with identification. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub fn lock_token(&self) -> std::option::Option<&str> {
        self.lock_token.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The label namespace prefix for the managed rule groups that are offered to customers from this managed rule set. All labels that are added by rules in the managed rule group have this prefix. </p>
    /// <ul>
    /// <li> <p>The syntax for the label namespace prefix for a managed rule group is the following: </p> <p> <code>awswaf:managed:
    /// <vendor>
    /// :
    /// <rule group name></rule>
    /// </vendor></code>:</p> </li>
    /// <li> <p>When a rule with a label matches a web request, WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p> <p> <code><label namespace>:<label from rule></label></label></code> </p> </li>
    /// </ul>
    pub fn label_namespace(&self) -> std::option::Option<&str> {
        self.label_namespace.as_deref()
    }
}
impl std::fmt::Debug for ManagedRuleSetSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ManagedRuleSetSummary");
        formatter.field("name", &self.name);
        formatter.field("id", &self.id);
        formatter.field("description", &self.description);
        formatter.field("lock_token", &self.lock_token);
        formatter.field("arn", &self.arn);
        formatter.field("label_namespace", &self.label_namespace);
        formatter.finish()
    }
}
/// See [`ManagedRuleSetSummary`](crate::model::ManagedRuleSetSummary)
pub mod managed_rule_set_summary {
    /// A builder for [`ManagedRuleSetSummary`](crate::model::ManagedRuleSetSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) lock_token: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) label_namespace: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the managed rule set. You use this, along with the rule set ID, to identify the rule set.</p>
        /// <p>This name is assigned to the corresponding managed rule group, which your customers can access and use. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the managed rule set. You use this, along with the rule set ID, to identify the rule set.</p>
        /// <p>This name is assigned to the corresponding managed rule group, which your customers can access and use. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A unique identifier for the managed rule set. The ID is returned in the responses to commands like <code>list</code>. You provide it to operations like <code>get</code> and <code>update</code>.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the managed rule set. The ID is returned in the responses to commands like <code>list</code>. You provide it to operations like <code>get</code> and <code>update</code>.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>A description of the set that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the set that helps with identification. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.lock_token = Some(input.into());
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lock_token = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entity.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entity.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The label namespace prefix for the managed rule groups that are offered to customers from this managed rule set. All labels that are added by rules in the managed rule group have this prefix. </p>
        /// <ul>
        /// <li> <p>The syntax for the label namespace prefix for a managed rule group is the following: </p> <p> <code>awswaf:managed:
        /// <vendor>
        /// :
        /// <rule group name></rule>
        /// </vendor></code>:</p> </li>
        /// <li> <p>When a rule with a label matches a web request, WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p> <p> <code><label namespace>:<label from rule></label></label></code> </p> </li>
        /// </ul>
        pub fn label_namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.label_namespace = Some(input.into());
            self
        }
        /// <p>The label namespace prefix for the managed rule groups that are offered to customers from this managed rule set. All labels that are added by rules in the managed rule group have this prefix. </p>
        /// <ul>
        /// <li> <p>The syntax for the label namespace prefix for a managed rule group is the following: </p> <p> <code>awswaf:managed:
        /// <vendor>
        /// :
        /// <rule group name></rule>
        /// </vendor></code>:</p> </li>
        /// <li> <p>When a rule with a label matches a web request, WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p> <p> <code><label namespace>:<label from rule></label></label></code> </p> </li>
        /// </ul>
        pub fn set_label_namespace(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.label_namespace = input;
            self
        }
        /// Consumes the builder and constructs a [`ManagedRuleSetSummary`](crate::model::ManagedRuleSetSummary)
        pub fn build(self) -> crate::model::ManagedRuleSetSummary {
            crate::model::ManagedRuleSetSummary {
                name: self.name,
                id: self.id,
                description: self.description,
                lock_token: self.lock_token,
                arn: self.arn,
                label_namespace: self.label_namespace,
            }
        }
    }
}
impl ManagedRuleSetSummary {
    /// Creates a new builder-style object to manufacture [`ManagedRuleSetSummary`](crate::model::ManagedRuleSetSummary)
    pub fn builder() -> crate::model::managed_rule_set_summary::Builder {
        crate::model::managed_rule_set_summary::Builder::default()
    }
}

/// <p>High-level information about an <code>IPSet</code>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage an <code>IPSet</code>, and the ARN, that you provide to the <code>IPSetReferenceStatement</code> to use the address set in a <code>Rule</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IpSetSummary {
    /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>A description of the IP set that helps with identification. </p>
    pub description: std::option::Option<std::string::String>,
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub lock_token: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    pub arn: std::option::Option<std::string::String>,
}
impl IpSetSummary {
    /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>A description of the IP set that helps with identification. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
    pub fn lock_token(&self) -> std::option::Option<&str> {
        self.lock_token.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl std::fmt::Debug for IpSetSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IpSetSummary");
        formatter.field("name", &self.name);
        formatter.field("id", &self.id);
        formatter.field("description", &self.description);
        formatter.field("lock_token", &self.lock_token);
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}
/// See [`IpSetSummary`](crate::model::IpSetSummary)
pub mod ip_set_summary {
    /// A builder for [`IpSetSummary`](crate::model::IpSetSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) lock_token: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>A description of the IP set that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the IP set that helps with identification. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn lock_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.lock_token = Some(input.into());
            self
        }
        /// <p>A token used for optimistic locking. WAF returns a token to your <code>get</code> and <code>list</code> requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like <code>update</code> and <code>delete</code>. WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another <code>get</code>, and use the new token returned by that operation. </p>
        pub fn set_lock_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lock_token = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entity.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entity.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`IpSetSummary`](crate::model::IpSetSummary)
        pub fn build(self) -> crate::model::IpSetSummary {
            crate::model::IpSetSummary {
                name: self.name,
                id: self.id,
                description: self.description,
                lock_token: self.lock_token,
                arn: self.arn,
            }
        }
    }
}
impl IpSetSummary {
    /// Creates a new builder-style object to manufacture [`IpSetSummary`](crate::model::IpSetSummary)
    pub fn builder() -> crate::model::ip_set_summary::Builder {
        crate::model::ip_set_summary::Builder::default()
    }
}

/// <p>Describes a single version of a managed rule group. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ManagedRuleGroupVersion {
    /// <p>The version name. </p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The date and time that the managed rule group owner updated the rule group version information. </p>
    pub last_update_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl ManagedRuleGroupVersion {
    /// <p>The version name. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The date and time that the managed rule group owner updated the rule group version information. </p>
    pub fn last_update_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_update_timestamp.as_ref()
    }
}
impl std::fmt::Debug for ManagedRuleGroupVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ManagedRuleGroupVersion");
        formatter.field("name", &self.name);
        formatter.field("last_update_timestamp", &self.last_update_timestamp);
        formatter.finish()
    }
}
/// See [`ManagedRuleGroupVersion`](crate::model::ManagedRuleGroupVersion)
pub mod managed_rule_group_version {
    /// A builder for [`ManagedRuleGroupVersion`](crate::model::ManagedRuleGroupVersion)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) last_update_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The version name. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The version name. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The date and time that the managed rule group owner updated the rule group version information. </p>
        pub fn last_update_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_update_timestamp = Some(input);
            self
        }
        /// <p>The date and time that the managed rule group owner updated the rule group version information. </p>
        pub fn set_last_update_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_update_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`ManagedRuleGroupVersion`](crate::model::ManagedRuleGroupVersion)
        pub fn build(self) -> crate::model::ManagedRuleGroupVersion {
            crate::model::ManagedRuleGroupVersion {
                name: self.name,
                last_update_timestamp: self.last_update_timestamp,
            }
        }
    }
}
impl ManagedRuleGroupVersion {
    /// Creates a new builder-style object to manufacture [`ManagedRuleGroupVersion`](crate::model::ManagedRuleGroupVersion)
    pub fn builder() -> crate::model::managed_rule_group_version::Builder {
        crate::model::managed_rule_group_version::Builder::default()
    }
}

/// <p>High-level information about a managed rule group, returned by <code>ListAvailableManagedRuleGroups</code>. This provides information like the name and vendor name, that you provide when you add a <code>ManagedRuleGroupStatement</code> to a web ACL. Managed rule groups include Amazon Web Services Managed Rules rule groups, which are free of charge to WAF customers, and Amazon Web Services Marketplace managed rule groups, which you can subscribe to through Amazon Web Services Marketplace. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ManagedRuleGroupSummary {
    /// <p>The name of the managed rule group vendor. You use this, along with the rule group name, to identify the rule group.</p>
    pub vendor_name: std::option::Option<std::string::String>,
    /// <p>The name of the managed rule group. You use this, along with the vendor name, to identify the rule group.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the managed rule group, provided by Amazon Web Services Managed Rules or the Amazon Web Services Marketplace seller who manages it.</p>
    pub description: std::option::Option<std::string::String>,
}
impl ManagedRuleGroupSummary {
    /// <p>The name of the managed rule group vendor. You use this, along with the rule group name, to identify the rule group.</p>
    pub fn vendor_name(&self) -> std::option::Option<&str> {
        self.vendor_name.as_deref()
    }
    /// <p>The name of the managed rule group. You use this, along with the vendor name, to identify the rule group.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the managed rule group, provided by Amazon Web Services Managed Rules or the Amazon Web Services Marketplace seller who manages it.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
impl std::fmt::Debug for ManagedRuleGroupSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ManagedRuleGroupSummary");
        formatter.field("vendor_name", &self.vendor_name);
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}
/// See [`ManagedRuleGroupSummary`](crate::model::ManagedRuleGroupSummary)
pub mod managed_rule_group_summary {
    /// A builder for [`ManagedRuleGroupSummary`](crate::model::ManagedRuleGroupSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vendor_name: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the managed rule group vendor. You use this, along with the rule group name, to identify the rule group.</p>
        pub fn vendor_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vendor_name = Some(input.into());
            self
        }
        /// <p>The name of the managed rule group vendor. You use this, along with the rule group name, to identify the rule group.</p>
        pub fn set_vendor_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vendor_name = input;
            self
        }
        /// <p>The name of the managed rule group. You use this, along with the vendor name, to identify the rule group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the managed rule group. You use this, along with the vendor name, to identify the rule group.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the managed rule group, provided by Amazon Web Services Managed Rules or the Amazon Web Services Marketplace seller who manages it.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the managed rule group, provided by Amazon Web Services Managed Rules or the Amazon Web Services Marketplace seller who manages it.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`ManagedRuleGroupSummary`](crate::model::ManagedRuleGroupSummary)
        pub fn build(self) -> crate::model::ManagedRuleGroupSummary {
            crate::model::ManagedRuleGroupSummary {
                vendor_name: self.vendor_name,
                name: self.name,
                description: self.description,
            }
        }
    }
}
impl ManagedRuleGroupSummary {
    /// Creates a new builder-style object to manufacture [`ManagedRuleGroupSummary`](crate::model::ManagedRuleGroupSummary)
    pub fn builder() -> crate::model::managed_rule_group_summary::Builder {
        crate::model::managed_rule_group_summary::Builder::default()
    }
}

/// <p> A web ACL defines a collection of rules to use to inspect and control web requests. Each rule has an action defined (allow, block, or count) for requests that match the statement of the rule. In the web ACL, you assign a default action to take (allow, block) for any request that does not match any of the rules. The rules in a web ACL can be a combination of the types <code>Rule</code>, <code>RuleGroup</code>, and managed rule group. You can associate a web ACL with one or more Amazon Web Services resources to protect. The resources can be an Amazon CloudFront distribution, an Amazon API Gateway REST API, an Application Load Balancer, or an AppSync GraphQL API. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WebAcl {
    /// <p>The name of the web ACL. You cannot change the name of a web ACL after you create it.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the <code>WebACL</code>. This ID is returned in the responses to create and list commands. You use this ID to do things like get, update, and delete a <code>WebACL</code>.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the web ACL that you want to associate with the resource.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The action to perform if none of the <code>Rules</code> contained in the <code>WebACL</code> match. </p>
    pub default_action: std::option::Option<crate::model::DefaultAction>,
    /// <p>A description of the web ACL that helps with identification. </p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The <code>Rule</code> statements used to identify the web requests that you want to allow, block, or count. Each rule includes one top-level statement that WAF uses to identify matching web requests, and parameters that govern how WAF handles them. </p>
    pub rules: std::option::Option<std::vec::Vec<crate::model::Rule>>,
    /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection. </p>
    pub visibility_config: std::option::Option<crate::model::VisibilityConfig>,
    /// <p>The web ACL capacity units (WCUs) currently being used by this web ACL. </p>
    /// <p>WAF uses WCUs to calculate and control the operating resources that are used to run your rules, rule groups, and web ACLs. WAF calculates capacity differently for each rule type, to reflect the relative cost of each rule. Simple rules that cost little to run use fewer WCUs than more complex rules that use more processing power. Rule group capacity is fixed at creation, which helps users plan their web ACL WCU usage when they use a rule group. The WCU limit for web ACLs is 1,500. </p>
    pub capacity: i64,
    /// <p>The first set of rules for WAF to process in the web ACL. This is defined in an Firewall Manager WAF policy and contains only rule group references. You can't alter these. Any rules and rule groups that you define for the web ACL are prioritized after these. </p>
    /// <p>In the Firewall Manager WAF policy, the Firewall Manager administrator can define a set of rule groups to run first in the web ACL and a set of rule groups to run last. Within each set, the administrator prioritizes the rule groups, to determine their relative processing order.</p>
    pub pre_process_firewall_manager_rule_groups:
        std::option::Option<std::vec::Vec<crate::model::FirewallManagerRuleGroup>>,
    /// <p>The last set of rules for WAF to process in the web ACL. This is defined in an Firewall Manager WAF policy and contains only rule group references. You can't alter these. Any rules and rule groups that you define for the web ACL are prioritized before these. </p>
    /// <p>In the Firewall Manager WAF policy, the Firewall Manager administrator can define a set of rule groups to run first in the web ACL and a set of rule groups to run last. Within each set, the administrator prioritizes the rule groups, to determine their relative processing order.</p>
    pub post_process_firewall_manager_rule_groups:
        std::option::Option<std::vec::Vec<crate::model::FirewallManagerRuleGroup>>,
    /// <p>Indicates whether this web ACL is managed by Firewall Manager. If true, then only Firewall Manager can delete the web ACL or any Firewall Manager rule groups in the web ACL. </p>
    pub managed_by_firewall_manager: bool,
    /// <p>The label namespace prefix for this web ACL. All labels added by rules in this web ACL have this prefix. </p>
    /// <ul>
    /// <li> <p>The syntax for the label namespace prefix for a web ACL is the following: </p> <p> <code>awswaf:
    /// <account id>
    /// :webacl:
    /// <web acl name>
    /// :
    /// </web>
    /// </account></code> </p> </li>
    /// <li> <p>When a rule with a label matches a web request, WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p> <p> <code><label namespace>:<label from rule></label></label></code> </p> </li>
    /// </ul>
    pub label_namespace: std::option::Option<std::string::String>,
    /// <p>A map of custom response keys and content bodies. When you create a rule with a block action, you can send a custom response to the web request. You define these for the web ACL, and then use them in the rules and default actions that you define in the web ACL. </p>
    /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    pub custom_response_bodies: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::CustomResponseBody>,
    >,
    /// <p>Specifies how WAF should handle <code>CAPTCHA</code> evaluations for rules that don't have their own <code>CaptchaConfig</code> settings. If you don't specify this, WAF uses its default settings for <code>CaptchaConfig</code>. </p>
    pub captcha_config: std::option::Option<crate::model::CaptchaConfig>,
}
impl WebAcl {
    /// <p>The name of the web ACL. You cannot change the name of a web ACL after you create it.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A unique identifier for the <code>WebACL</code>. This ID is returned in the responses to create and list commands. You use this ID to do things like get, update, and delete a <code>WebACL</code>.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the web ACL that you want to associate with the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The action to perform if none of the <code>Rules</code> contained in the <code>WebACL</code> match. </p>
    pub fn default_action(&self) -> std::option::Option<&crate::model::DefaultAction> {
        self.default_action.as_ref()
    }
    /// <p>A description of the web ACL that helps with identification. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The <code>Rule</code> statements used to identify the web requests that you want to allow, block, or count. Each rule includes one top-level statement that WAF uses to identify matching web requests, and parameters that govern how WAF handles them. </p>
    pub fn rules(&self) -> std::option::Option<&[crate::model::Rule]> {
        self.rules.as_deref()
    }
    /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection. </p>
    pub fn visibility_config(&self) -> std::option::Option<&crate::model::VisibilityConfig> {
        self.visibility_config.as_ref()
    }
    /// <p>The web ACL capacity units (WCUs) currently being used by this web ACL. </p>
    /// <p>WAF uses WCUs to calculate and control the operating resources that are used to run your rules, rule groups, and web ACLs. WAF calculates capacity differently for each rule type, to reflect the relative cost of each rule. Simple rules that cost little to run use fewer WCUs than more complex rules that use more processing power. Rule group capacity is fixed at creation, which helps users plan their web ACL WCU usage when they use a rule group. The WCU limit for web ACLs is 1,500. </p>
    pub fn capacity(&self) -> i64 {
        self.capacity
    }
    /// <p>The first set of rules for WAF to process in the web ACL. This is defined in an Firewall Manager WAF policy and contains only rule group references. You can't alter these. Any rules and rule groups that you define for the web ACL are prioritized after these. </p>
    /// <p>In the Firewall Manager WAF policy, the Firewall Manager administrator can define a set of rule groups to run first in the web ACL and a set of rule groups to run last. Within each set, the administrator prioritizes the rule groups, to determine their relative processing order.</p>
    pub fn pre_process_firewall_manager_rule_groups(
        &self,
    ) -> std::option::Option<&[crate::model::FirewallManagerRuleGroup]> {
        self.pre_process_firewall_manager_rule_groups.as_deref()
    }
    /// <p>The last set of rules for WAF to process in the web ACL. This is defined in an Firewall Manager WAF policy and contains only rule group references. You can't alter these. Any rules and rule groups that you define for the web ACL are prioritized before these. </p>
    /// <p>In the Firewall Manager WAF policy, the Firewall Manager administrator can define a set of rule groups to run first in the web ACL and a set of rule groups to run last. Within each set, the administrator prioritizes the rule groups, to determine their relative processing order.</p>
    pub fn post_process_firewall_manager_rule_groups(
        &self,
    ) -> std::option::Option<&[crate::model::FirewallManagerRuleGroup]> {
        self.post_process_firewall_manager_rule_groups.as_deref()
    }
    /// <p>Indicates whether this web ACL is managed by Firewall Manager. If true, then only Firewall Manager can delete the web ACL or any Firewall Manager rule groups in the web ACL. </p>
    pub fn managed_by_firewall_manager(&self) -> bool {
        self.managed_by_firewall_manager
    }
    /// <p>The label namespace prefix for this web ACL. All labels added by rules in this web ACL have this prefix. </p>
    /// <ul>
    /// <li> <p>The syntax for the label namespace prefix for a web ACL is the following: </p> <p> <code>awswaf:
    /// <account id>
    /// :webacl:
    /// <web acl name>
    /// :
    /// </web>
    /// </account></code> </p> </li>
    /// <li> <p>When a rule with a label matches a web request, WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p> <p> <code><label namespace>:<label from rule></label></label></code> </p> </li>
    /// </ul>
    pub fn label_namespace(&self) -> std::option::Option<&str> {
        self.label_namespace.as_deref()
    }
    /// <p>A map of custom response keys and content bodies. When you create a rule with a block action, you can send a custom response to the web request. You define these for the web ACL, and then use them in the rules and default actions that you define in the web ACL. </p>
    /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    pub fn custom_response_bodies(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::CustomResponseBody>,
    > {
        self.custom_response_bodies.as_ref()
    }
    /// <p>Specifies how WAF should handle <code>CAPTCHA</code> evaluations for rules that don't have their own <code>CaptchaConfig</code> settings. If you don't specify this, WAF uses its default settings for <code>CaptchaConfig</code>. </p>
    pub fn captcha_config(&self) -> std::option::Option<&crate::model::CaptchaConfig> {
        self.captcha_config.as_ref()
    }
}
impl std::fmt::Debug for WebAcl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WebAcl");
        formatter.field("name", &self.name);
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("default_action", &self.default_action);
        formatter.field("description", &self.description);
        formatter.field("rules", &self.rules);
        formatter.field("visibility_config", &self.visibility_config);
        formatter.field("capacity", &self.capacity);
        formatter.field(
            "pre_process_firewall_manager_rule_groups",
            &self.pre_process_firewall_manager_rule_groups,
        );
        formatter.field(
            "post_process_firewall_manager_rule_groups",
            &self.post_process_firewall_manager_rule_groups,
        );
        formatter.field(
            "managed_by_firewall_manager",
            &self.managed_by_firewall_manager,
        );
        formatter.field("label_namespace", &self.label_namespace);
        formatter.field("custom_response_bodies", &self.custom_response_bodies);
        formatter.field("captcha_config", &self.captcha_config);
        formatter.finish()
    }
}
/// See [`WebAcl`](crate::model::WebAcl)
pub mod web_acl {
    /// A builder for [`WebAcl`](crate::model::WebAcl)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) default_action: std::option::Option<crate::model::DefaultAction>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) rules: std::option::Option<std::vec::Vec<crate::model::Rule>>,
        pub(crate) visibility_config: std::option::Option<crate::model::VisibilityConfig>,
        pub(crate) capacity: std::option::Option<i64>,
        pub(crate) pre_process_firewall_manager_rule_groups:
            std::option::Option<std::vec::Vec<crate::model::FirewallManagerRuleGroup>>,
        pub(crate) post_process_firewall_manager_rule_groups:
            std::option::Option<std::vec::Vec<crate::model::FirewallManagerRuleGroup>>,
        pub(crate) managed_by_firewall_manager: std::option::Option<bool>,
        pub(crate) label_namespace: std::option::Option<std::string::String>,
        pub(crate) custom_response_bodies: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::CustomResponseBody>,
        >,
        pub(crate) captcha_config: std::option::Option<crate::model::CaptchaConfig>,
    }
    impl Builder {
        /// <p>The name of the web ACL. You cannot change the name of a web ACL after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the web ACL. You cannot change the name of a web ACL after you create it.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A unique identifier for the <code>WebACL</code>. This ID is returned in the responses to create and list commands. You use this ID to do things like get, update, and delete a <code>WebACL</code>.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the <code>WebACL</code>. This ID is returned in the responses to create and list commands. You use this ID to do things like get, update, and delete a <code>WebACL</code>.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the web ACL that you want to associate with the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the web ACL that you want to associate with the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The action to perform if none of the <code>Rules</code> contained in the <code>WebACL</code> match. </p>
        pub fn default_action(mut self, input: crate::model::DefaultAction) -> Self {
            self.default_action = Some(input);
            self
        }
        /// <p>The action to perform if none of the <code>Rules</code> contained in the <code>WebACL</code> match. </p>
        pub fn set_default_action(
            mut self,
            input: std::option::Option<crate::model::DefaultAction>,
        ) -> Self {
            self.default_action = input;
            self
        }
        /// <p>A description of the web ACL that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the web ACL that helps with identification. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `rules`.
        ///
        /// To override the contents of this collection use [`set_rules`](Self::set_rules).
        ///
        /// <p>The <code>Rule</code> statements used to identify the web requests that you want to allow, block, or count. Each rule includes one top-level statement that WAF uses to identify matching web requests, and parameters that govern how WAF handles them. </p>
        pub fn rules(mut self, input: crate::model::Rule) -> Self {
            let mut v = self.rules.unwrap_or_default();
            v.push(input);
            self.rules = Some(v);
            self
        }
        /// <p>The <code>Rule</code> statements used to identify the web requests that you want to allow, block, or count. Each rule includes one top-level statement that WAF uses to identify matching web requests, and parameters that govern how WAF handles them. </p>
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Rule>>,
        ) -> Self {
            self.rules = input;
            self
        }
        /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection. </p>
        pub fn visibility_config(mut self, input: crate::model::VisibilityConfig) -> Self {
            self.visibility_config = Some(input);
            self
        }
        /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection. </p>
        pub fn set_visibility_config(
            mut self,
            input: std::option::Option<crate::model::VisibilityConfig>,
        ) -> Self {
            self.visibility_config = input;
            self
        }
        /// <p>The web ACL capacity units (WCUs) currently being used by this web ACL. </p>
        /// <p>WAF uses WCUs to calculate and control the operating resources that are used to run your rules, rule groups, and web ACLs. WAF calculates capacity differently for each rule type, to reflect the relative cost of each rule. Simple rules that cost little to run use fewer WCUs than more complex rules that use more processing power. Rule group capacity is fixed at creation, which helps users plan their web ACL WCU usage when they use a rule group. The WCU limit for web ACLs is 1,500. </p>
        pub fn capacity(mut self, input: i64) -> Self {
            self.capacity = Some(input);
            self
        }
        /// <p>The web ACL capacity units (WCUs) currently being used by this web ACL. </p>
        /// <p>WAF uses WCUs to calculate and control the operating resources that are used to run your rules, rule groups, and web ACLs. WAF calculates capacity differently for each rule type, to reflect the relative cost of each rule. Simple rules that cost little to run use fewer WCUs than more complex rules that use more processing power. Rule group capacity is fixed at creation, which helps users plan their web ACL WCU usage when they use a rule group. The WCU limit for web ACLs is 1,500. </p>
        pub fn set_capacity(mut self, input: std::option::Option<i64>) -> Self {
            self.capacity = input;
            self
        }
        /// Appends an item to `pre_process_firewall_manager_rule_groups`.
        ///
        /// To override the contents of this collection use [`set_pre_process_firewall_manager_rule_groups`](Self::set_pre_process_firewall_manager_rule_groups).
        ///
        /// <p>The first set of rules for WAF to process in the web ACL. This is defined in an Firewall Manager WAF policy and contains only rule group references. You can't alter these. Any rules and rule groups that you define for the web ACL are prioritized after these. </p>
        /// <p>In the Firewall Manager WAF policy, the Firewall Manager administrator can define a set of rule groups to run first in the web ACL and a set of rule groups to run last. Within each set, the administrator prioritizes the rule groups, to determine their relative processing order.</p>
        pub fn pre_process_firewall_manager_rule_groups(
            mut self,
            input: crate::model::FirewallManagerRuleGroup,
        ) -> Self {
            let mut v = self
                .pre_process_firewall_manager_rule_groups
                .unwrap_or_default();
            v.push(input);
            self.pre_process_firewall_manager_rule_groups = Some(v);
            self
        }
        /// <p>The first set of rules for WAF to process in the web ACL. This is defined in an Firewall Manager WAF policy and contains only rule group references. You can't alter these. Any rules and rule groups that you define for the web ACL are prioritized after these. </p>
        /// <p>In the Firewall Manager WAF policy, the Firewall Manager administrator can define a set of rule groups to run first in the web ACL and a set of rule groups to run last. Within each set, the administrator prioritizes the rule groups, to determine their relative processing order.</p>
        pub fn set_pre_process_firewall_manager_rule_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FirewallManagerRuleGroup>>,
        ) -> Self {
            self.pre_process_firewall_manager_rule_groups = input;
            self
        }
        /// Appends an item to `post_process_firewall_manager_rule_groups`.
        ///
        /// To override the contents of this collection use [`set_post_process_firewall_manager_rule_groups`](Self::set_post_process_firewall_manager_rule_groups).
        ///
        /// <p>The last set of rules for WAF to process in the web ACL. This is defined in an Firewall Manager WAF policy and contains only rule group references. You can't alter these. Any rules and rule groups that you define for the web ACL are prioritized before these. </p>
        /// <p>In the Firewall Manager WAF policy, the Firewall Manager administrator can define a set of rule groups to run first in the web ACL and a set of rule groups to run last. Within each set, the administrator prioritizes the rule groups, to determine their relative processing order.</p>
        pub fn post_process_firewall_manager_rule_groups(
            mut self,
            input: crate::model::FirewallManagerRuleGroup,
        ) -> Self {
            let mut v = self
                .post_process_firewall_manager_rule_groups
                .unwrap_or_default();
            v.push(input);
            self.post_process_firewall_manager_rule_groups = Some(v);
            self
        }
        /// <p>The last set of rules for WAF to process in the web ACL. This is defined in an Firewall Manager WAF policy and contains only rule group references. You can't alter these. Any rules and rule groups that you define for the web ACL are prioritized before these. </p>
        /// <p>In the Firewall Manager WAF policy, the Firewall Manager administrator can define a set of rule groups to run first in the web ACL and a set of rule groups to run last. Within each set, the administrator prioritizes the rule groups, to determine their relative processing order.</p>
        pub fn set_post_process_firewall_manager_rule_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FirewallManagerRuleGroup>>,
        ) -> Self {
            self.post_process_firewall_manager_rule_groups = input;
            self
        }
        /// <p>Indicates whether this web ACL is managed by Firewall Manager. If true, then only Firewall Manager can delete the web ACL or any Firewall Manager rule groups in the web ACL. </p>
        pub fn managed_by_firewall_manager(mut self, input: bool) -> Self {
            self.managed_by_firewall_manager = Some(input);
            self
        }
        /// <p>Indicates whether this web ACL is managed by Firewall Manager. If true, then only Firewall Manager can delete the web ACL or any Firewall Manager rule groups in the web ACL. </p>
        pub fn set_managed_by_firewall_manager(mut self, input: std::option::Option<bool>) -> Self {
            self.managed_by_firewall_manager = input;
            self
        }
        /// <p>The label namespace prefix for this web ACL. All labels added by rules in this web ACL have this prefix. </p>
        /// <ul>
        /// <li> <p>The syntax for the label namespace prefix for a web ACL is the following: </p> <p> <code>awswaf:
        /// <account id>
        /// :webacl:
        /// <web acl name>
        /// :
        /// </web>
        /// </account></code> </p> </li>
        /// <li> <p>When a rule with a label matches a web request, WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p> <p> <code><label namespace>:<label from rule></label></label></code> </p> </li>
        /// </ul>
        pub fn label_namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.label_namespace = Some(input.into());
            self
        }
        /// <p>The label namespace prefix for this web ACL. All labels added by rules in this web ACL have this prefix. </p>
        /// <ul>
        /// <li> <p>The syntax for the label namespace prefix for a web ACL is the following: </p> <p> <code>awswaf:
        /// <account id>
        /// :webacl:
        /// <web acl name>
        /// :
        /// </web>
        /// </account></code> </p> </li>
        /// <li> <p>When a rule with a label matches a web request, WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p> <p> <code><label namespace>:<label from rule></label></label></code> </p> </li>
        /// </ul>
        pub fn set_label_namespace(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.label_namespace = input;
            self
        }
        /// Adds a key-value pair to `custom_response_bodies`.
        ///
        /// To override the contents of this collection use [`set_custom_response_bodies`](Self::set_custom_response_bodies).
        ///
        /// <p>A map of custom response keys and content bodies. When you create a rule with a block action, you can send a custom response to the web request. You define these for the web ACL, and then use them in the rules and default actions that you define in the web ACL. </p>
        /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        pub fn custom_response_bodies(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::CustomResponseBody,
        ) -> Self {
            let mut hash_map = self.custom_response_bodies.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.custom_response_bodies = Some(hash_map);
            self
        }
        /// <p>A map of custom response keys and content bodies. When you create a rule with a block action, you can send a custom response to the web request. You define these for the web ACL, and then use them in the rules and default actions that you define in the web ACL. </p>
        /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        pub fn set_custom_response_bodies(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::CustomResponseBody>,
            >,
        ) -> Self {
            self.custom_response_bodies = input;
            self
        }
        /// <p>Specifies how WAF should handle <code>CAPTCHA</code> evaluations for rules that don't have their own <code>CaptchaConfig</code> settings. If you don't specify this, WAF uses its default settings for <code>CaptchaConfig</code>. </p>
        pub fn captcha_config(mut self, input: crate::model::CaptchaConfig) -> Self {
            self.captcha_config = Some(input);
            self
        }
        /// <p>Specifies how WAF should handle <code>CAPTCHA</code> evaluations for rules that don't have their own <code>CaptchaConfig</code> settings. If you don't specify this, WAF uses its default settings for <code>CaptchaConfig</code>. </p>
        pub fn set_captcha_config(
            mut self,
            input: std::option::Option<crate::model::CaptchaConfig>,
        ) -> Self {
            self.captcha_config = input;
            self
        }
        /// Consumes the builder and constructs a [`WebAcl`](crate::model::WebAcl)
        pub fn build(self) -> crate::model::WebAcl {
            crate::model::WebAcl {
                name: self.name,
                id: self.id,
                arn: self.arn,
                default_action: self.default_action,
                description: self.description,
                rules: self.rules,
                visibility_config: self.visibility_config,
                capacity: self.capacity.unwrap_or_default(),
                pre_process_firewall_manager_rule_groups: self
                    .pre_process_firewall_manager_rule_groups,
                post_process_firewall_manager_rule_groups: self
                    .post_process_firewall_manager_rule_groups,
                managed_by_firewall_manager: self.managed_by_firewall_manager.unwrap_or_default(),
                label_namespace: self.label_namespace,
                custom_response_bodies: self.custom_response_bodies,
                captcha_config: self.captcha_config,
            }
        }
    }
}
impl WebAcl {
    /// Creates a new builder-style object to manufacture [`WebAcl`](crate::model::WebAcl)
    pub fn builder() -> crate::model::web_acl::Builder {
        crate::model::web_acl::Builder::default()
    }
}

/// <p>A rule group that's defined for an Firewall Manager WAF policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FirewallManagerRuleGroup {
    /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>If you define more than one rule group in the first or last Firewall Manager rule groups, WAF evaluates each request against the rule groups in order, starting from the lowest priority setting. The priorities don't need to be consecutive, but they must all be different.</p>
    pub priority: i32,
    /// <p>The processing guidance for an Firewall Manager rule. This is like a regular rule <code>Statement</code>, but it can only contain a rule group reference.</p>
    pub firewall_manager_statement: std::option::Option<crate::model::FirewallManagerStatement>,
    /// <p>The action to use in the place of the action that results from the rule group evaluation. Set the override action to none to leave the result of the rule group alone. Set it to count to override the result to count only. </p>
    /// <p>You can only use this for rule statements that reference a rule group, like <code>RuleGroupReferenceStatement</code> and <code>ManagedRuleGroupStatement</code>. </p> <note>
    /// <p>This option is usually set to none. It does not affect how the rules in the rule group are evaluated. If you want the rules in the rule group to only count matches, do not use this and instead exclude those rules in your rule group reference statement settings. </p>
    /// </note>
    pub override_action: std::option::Option<crate::model::OverrideAction>,
    /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection. </p>
    pub visibility_config: std::option::Option<crate::model::VisibilityConfig>,
}
impl FirewallManagerRuleGroup {
    /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>If you define more than one rule group in the first or last Firewall Manager rule groups, WAF evaluates each request against the rule groups in order, starting from the lowest priority setting. The priorities don't need to be consecutive, but they must all be different.</p>
    pub fn priority(&self) -> i32 {
        self.priority
    }
    /// <p>The processing guidance for an Firewall Manager rule. This is like a regular rule <code>Statement</code>, but it can only contain a rule group reference.</p>
    pub fn firewall_manager_statement(
        &self,
    ) -> std::option::Option<&crate::model::FirewallManagerStatement> {
        self.firewall_manager_statement.as_ref()
    }
    /// <p>The action to use in the place of the action that results from the rule group evaluation. Set the override action to none to leave the result of the rule group alone. Set it to count to override the result to count only. </p>
    /// <p>You can only use this for rule statements that reference a rule group, like <code>RuleGroupReferenceStatement</code> and <code>ManagedRuleGroupStatement</code>. </p> <note>
    /// <p>This option is usually set to none. It does not affect how the rules in the rule group are evaluated. If you want the rules in the rule group to only count matches, do not use this and instead exclude those rules in your rule group reference statement settings. </p>
    /// </note>
    pub fn override_action(&self) -> std::option::Option<&crate::model::OverrideAction> {
        self.override_action.as_ref()
    }
    /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection. </p>
    pub fn visibility_config(&self) -> std::option::Option<&crate::model::VisibilityConfig> {
        self.visibility_config.as_ref()
    }
}
impl std::fmt::Debug for FirewallManagerRuleGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FirewallManagerRuleGroup");
        formatter.field("name", &self.name);
        formatter.field("priority", &self.priority);
        formatter.field(
            "firewall_manager_statement",
            &self.firewall_manager_statement,
        );
        formatter.field("override_action", &self.override_action);
        formatter.field("visibility_config", &self.visibility_config);
        formatter.finish()
    }
}
/// See [`FirewallManagerRuleGroup`](crate::model::FirewallManagerRuleGroup)
pub mod firewall_manager_rule_group {
    /// A builder for [`FirewallManagerRuleGroup`](crate::model::FirewallManagerRuleGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) priority: std::option::Option<i32>,
        pub(crate) firewall_manager_statement:
            std::option::Option<crate::model::FirewallManagerStatement>,
        pub(crate) override_action: std::option::Option<crate::model::OverrideAction>,
        pub(crate) visibility_config: std::option::Option<crate::model::VisibilityConfig>,
    }
    impl Builder {
        /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>If you define more than one rule group in the first or last Firewall Manager rule groups, WAF evaluates each request against the rule groups in order, starting from the lowest priority setting. The priorities don't need to be consecutive, but they must all be different.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        /// <p>If you define more than one rule group in the first or last Firewall Manager rule groups, WAF evaluates each request against the rule groups in order, starting from the lowest priority setting. The priorities don't need to be consecutive, but they must all be different.</p>
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        /// <p>The processing guidance for an Firewall Manager rule. This is like a regular rule <code>Statement</code>, but it can only contain a rule group reference.</p>
        pub fn firewall_manager_statement(
            mut self,
            input: crate::model::FirewallManagerStatement,
        ) -> Self {
            self.firewall_manager_statement = Some(input);
            self
        }
        /// <p>The processing guidance for an Firewall Manager rule. This is like a regular rule <code>Statement</code>, but it can only contain a rule group reference.</p>
        pub fn set_firewall_manager_statement(
            mut self,
            input: std::option::Option<crate::model::FirewallManagerStatement>,
        ) -> Self {
            self.firewall_manager_statement = input;
            self
        }
        /// <p>The action to use in the place of the action that results from the rule group evaluation. Set the override action to none to leave the result of the rule group alone. Set it to count to override the result to count only. </p>
        /// <p>You can only use this for rule statements that reference a rule group, like <code>RuleGroupReferenceStatement</code> and <code>ManagedRuleGroupStatement</code>. </p> <note>
        /// <p>This option is usually set to none. It does not affect how the rules in the rule group are evaluated. If you want the rules in the rule group to only count matches, do not use this and instead exclude those rules in your rule group reference statement settings. </p>
        /// </note>
        pub fn override_action(mut self, input: crate::model::OverrideAction) -> Self {
            self.override_action = Some(input);
            self
        }
        /// <p>The action to use in the place of the action that results from the rule group evaluation. Set the override action to none to leave the result of the rule group alone. Set it to count to override the result to count only. </p>
        /// <p>You can only use this for rule statements that reference a rule group, like <code>RuleGroupReferenceStatement</code> and <code>ManagedRuleGroupStatement</code>. </p> <note>
        /// <p>This option is usually set to none. It does not affect how the rules in the rule group are evaluated. If you want the rules in the rule group to only count matches, do not use this and instead exclude those rules in your rule group reference statement settings. </p>
        /// </note>
        pub fn set_override_action(
            mut self,
            input: std::option::Option<crate::model::OverrideAction>,
        ) -> Self {
            self.override_action = input;
            self
        }
        /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection. </p>
        pub fn visibility_config(mut self, input: crate::model::VisibilityConfig) -> Self {
            self.visibility_config = Some(input);
            self
        }
        /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection. </p>
        pub fn set_visibility_config(
            mut self,
            input: std::option::Option<crate::model::VisibilityConfig>,
        ) -> Self {
            self.visibility_config = input;
            self
        }
        /// Consumes the builder and constructs a [`FirewallManagerRuleGroup`](crate::model::FirewallManagerRuleGroup)
        pub fn build(self) -> crate::model::FirewallManagerRuleGroup {
            crate::model::FirewallManagerRuleGroup {
                name: self.name,
                priority: self.priority.unwrap_or_default(),
                firewall_manager_statement: self.firewall_manager_statement,
                override_action: self.override_action,
                visibility_config: self.visibility_config,
            }
        }
    }
}
impl FirewallManagerRuleGroup {
    /// Creates a new builder-style object to manufacture [`FirewallManagerRuleGroup`](crate::model::FirewallManagerRuleGroup)
    pub fn builder() -> crate::model::firewall_manager_rule_group::Builder {
        crate::model::firewall_manager_rule_group::Builder::default()
    }
}

/// <p>The processing guidance for an Firewall Manager rule. This is like a regular rule <code>Statement</code>, but it can only contain a rule group reference.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FirewallManagerStatement {
    /// <p>A rule statement used to run the rules that are defined in a managed rule group. To use this, provide the vendor name and the name of the rule group in this statement. You can retrieve the required names by calling <code>ListAvailableManagedRuleGroups</code>.</p>
    /// <p>You cannot nest a <code>ManagedRuleGroupStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. It can only be referenced as a top-level statement within a rule.</p>
    pub managed_rule_group_statement: std::option::Option<crate::model::ManagedRuleGroupStatement>,
    /// <p>A rule statement used to run the rules that are defined in a <code>RuleGroup</code>. To use this, create a rule group with your rules, then provide the ARN of the rule group in this statement.</p>
    /// <p>You cannot nest a <code>RuleGroupReferenceStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. You can only use a rule group reference statement at the top level inside a web ACL. </p>
    pub rule_group_reference_statement:
        std::option::Option<crate::model::RuleGroupReferenceStatement>,
}
impl FirewallManagerStatement {
    /// <p>A rule statement used to run the rules that are defined in a managed rule group. To use this, provide the vendor name and the name of the rule group in this statement. You can retrieve the required names by calling <code>ListAvailableManagedRuleGroups</code>.</p>
    /// <p>You cannot nest a <code>ManagedRuleGroupStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. It can only be referenced as a top-level statement within a rule.</p>
    pub fn managed_rule_group_statement(
        &self,
    ) -> std::option::Option<&crate::model::ManagedRuleGroupStatement> {
        self.managed_rule_group_statement.as_ref()
    }
    /// <p>A rule statement used to run the rules that are defined in a <code>RuleGroup</code>. To use this, create a rule group with your rules, then provide the ARN of the rule group in this statement.</p>
    /// <p>You cannot nest a <code>RuleGroupReferenceStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. You can only use a rule group reference statement at the top level inside a web ACL. </p>
    pub fn rule_group_reference_statement(
        &self,
    ) -> std::option::Option<&crate::model::RuleGroupReferenceStatement> {
        self.rule_group_reference_statement.as_ref()
    }
}
impl std::fmt::Debug for FirewallManagerStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FirewallManagerStatement");
        formatter.field(
            "managed_rule_group_statement",
            &self.managed_rule_group_statement,
        );
        formatter.field(
            "rule_group_reference_statement",
            &self.rule_group_reference_statement,
        );
        formatter.finish()
    }
}
/// See [`FirewallManagerStatement`](crate::model::FirewallManagerStatement)
pub mod firewall_manager_statement {
    /// A builder for [`FirewallManagerStatement`](crate::model::FirewallManagerStatement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) managed_rule_group_statement:
            std::option::Option<crate::model::ManagedRuleGroupStatement>,
        pub(crate) rule_group_reference_statement:
            std::option::Option<crate::model::RuleGroupReferenceStatement>,
    }
    impl Builder {
        /// <p>A rule statement used to run the rules that are defined in a managed rule group. To use this, provide the vendor name and the name of the rule group in this statement. You can retrieve the required names by calling <code>ListAvailableManagedRuleGroups</code>.</p>
        /// <p>You cannot nest a <code>ManagedRuleGroupStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. It can only be referenced as a top-level statement within a rule.</p>
        pub fn managed_rule_group_statement(
            mut self,
            input: crate::model::ManagedRuleGroupStatement,
        ) -> Self {
            self.managed_rule_group_statement = Some(input);
            self
        }
        /// <p>A rule statement used to run the rules that are defined in a managed rule group. To use this, provide the vendor name and the name of the rule group in this statement. You can retrieve the required names by calling <code>ListAvailableManagedRuleGroups</code>.</p>
        /// <p>You cannot nest a <code>ManagedRuleGroupStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. It can only be referenced as a top-level statement within a rule.</p>
        pub fn set_managed_rule_group_statement(
            mut self,
            input: std::option::Option<crate::model::ManagedRuleGroupStatement>,
        ) -> Self {
            self.managed_rule_group_statement = input;
            self
        }
        /// <p>A rule statement used to run the rules that are defined in a <code>RuleGroup</code>. To use this, create a rule group with your rules, then provide the ARN of the rule group in this statement.</p>
        /// <p>You cannot nest a <code>RuleGroupReferenceStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. You can only use a rule group reference statement at the top level inside a web ACL. </p>
        pub fn rule_group_reference_statement(
            mut self,
            input: crate::model::RuleGroupReferenceStatement,
        ) -> Self {
            self.rule_group_reference_statement = Some(input);
            self
        }
        /// <p>A rule statement used to run the rules that are defined in a <code>RuleGroup</code>. To use this, create a rule group with your rules, then provide the ARN of the rule group in this statement.</p>
        /// <p>You cannot nest a <code>RuleGroupReferenceStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. You can only use a rule group reference statement at the top level inside a web ACL. </p>
        pub fn set_rule_group_reference_statement(
            mut self,
            input: std::option::Option<crate::model::RuleGroupReferenceStatement>,
        ) -> Self {
            self.rule_group_reference_statement = input;
            self
        }
        /// Consumes the builder and constructs a [`FirewallManagerStatement`](crate::model::FirewallManagerStatement)
        pub fn build(self) -> crate::model::FirewallManagerStatement {
            crate::model::FirewallManagerStatement {
                managed_rule_group_statement: self.managed_rule_group_statement,
                rule_group_reference_statement: self.rule_group_reference_statement,
            }
        }
    }
}
impl FirewallManagerStatement {
    /// Creates a new builder-style object to manufacture [`FirewallManagerStatement`](crate::model::FirewallManagerStatement)
    pub fn builder() -> crate::model::firewall_manager_statement::Builder {
        crate::model::firewall_manager_statement::Builder::default()
    }
}

/// <p>In a <code>GetSampledRequests</code> request, the <code>StartTime</code> and <code>EndTime</code> objects specify the time range for which you want WAF to return a sample of web requests.</p>
/// <p>You must specify the times in Coordinated Universal Time (UTC) format. UTC format includes the special designator, <code>Z</code>. For example, <code>"2016-09-27T14:50Z"</code>. You can specify any time range in the previous three hours.</p>
/// <p>In a <code>GetSampledRequests</code> response, the <code>StartTime</code> and <code>EndTime</code> objects specify the time range for which WAF actually returned a sample of web requests. WAF gets the specified number of requests from among the first 5,000 requests that your Amazon Web Services resource receives during the specified time period. If your resource receives more than 5,000 requests during that period, WAF stops sampling after the 5,000th request. In that case, <code>EndTime</code> is the time that WAF received the 5,000th request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TimeWindow {
    /// <p>The beginning of the time range from which you want <code>GetSampledRequests</code> to return a sample of the requests that your Amazon Web Services resource received. You must specify the times in Coordinated Universal Time (UTC) format. UTC format includes the special designator, <code>Z</code>. For example, <code>"2016-09-27T14:50Z"</code>. You can specify any time range in the previous three hours.</p>
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The end of the time range from which you want <code>GetSampledRequests</code> to return a sample of the requests that your Amazon Web Services resource received. You must specify the times in Coordinated Universal Time (UTC) format. UTC format includes the special designator, <code>Z</code>. For example, <code>"2016-09-27T14:50Z"</code>. You can specify any time range in the previous three hours.</p>
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl TimeWindow {
    /// <p>The beginning of the time range from which you want <code>GetSampledRequests</code> to return a sample of the requests that your Amazon Web Services resource received. You must specify the times in Coordinated Universal Time (UTC) format. UTC format includes the special designator, <code>Z</code>. For example, <code>"2016-09-27T14:50Z"</code>. You can specify any time range in the previous three hours.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The end of the time range from which you want <code>GetSampledRequests</code> to return a sample of the requests that your Amazon Web Services resource received. You must specify the times in Coordinated Universal Time (UTC) format. UTC format includes the special designator, <code>Z</code>. For example, <code>"2016-09-27T14:50Z"</code>. You can specify any time range in the previous three hours.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
}
impl std::fmt::Debug for TimeWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TimeWindow");
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.finish()
    }
}
/// See [`TimeWindow`](crate::model::TimeWindow)
pub mod time_window {
    /// A builder for [`TimeWindow`](crate::model::TimeWindow)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The beginning of the time range from which you want <code>GetSampledRequests</code> to return a sample of the requests that your Amazon Web Services resource received. You must specify the times in Coordinated Universal Time (UTC) format. UTC format includes the special designator, <code>Z</code>. For example, <code>"2016-09-27T14:50Z"</code>. You can specify any time range in the previous three hours.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The beginning of the time range from which you want <code>GetSampledRequests</code> to return a sample of the requests that your Amazon Web Services resource received. You must specify the times in Coordinated Universal Time (UTC) format. UTC format includes the special designator, <code>Z</code>. For example, <code>"2016-09-27T14:50Z"</code>. You can specify any time range in the previous three hours.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end of the time range from which you want <code>GetSampledRequests</code> to return a sample of the requests that your Amazon Web Services resource received. You must specify the times in Coordinated Universal Time (UTC) format. UTC format includes the special designator, <code>Z</code>. For example, <code>"2016-09-27T14:50Z"</code>. You can specify any time range in the previous three hours.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end of the time range from which you want <code>GetSampledRequests</code> to return a sample of the requests that your Amazon Web Services resource received. You must specify the times in Coordinated Universal Time (UTC) format. UTC format includes the special designator, <code>Z</code>. For example, <code>"2016-09-27T14:50Z"</code>. You can specify any time range in the previous three hours.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// Consumes the builder and constructs a [`TimeWindow`](crate::model::TimeWindow)
        pub fn build(self) -> crate::model::TimeWindow {
            crate::model::TimeWindow {
                start_time: self.start_time,
                end_time: self.end_time,
            }
        }
    }
}
impl TimeWindow {
    /// Creates a new builder-style object to manufacture [`TimeWindow`](crate::model::TimeWindow)
    pub fn builder() -> crate::model::time_window::Builder {
        crate::model::time_window::Builder::default()
    }
}

/// <p>Represents a single sampled web request. The response from <code>GetSampledRequests</code> includes a <code>SampledHTTPRequests</code> complex type that appears as <code>SampledRequests</code> in the response syntax. <code>SampledHTTPRequests</code> contains an array of <code>SampledHTTPRequest</code> objects.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SampledHttpRequest {
    /// <p>A complex type that contains detailed information about the request.</p>
    pub request: std::option::Option<crate::model::HttpRequest>,
    /// <p>A value that indicates how one result in the response relates proportionally to other results in the response. For example, a result that has a weight of <code>2</code> represents roughly twice as many web requests as a result that has a weight of <code>1</code>.</p>
    pub weight: i64,
    /// <p>The time at which WAF received the request from your Amazon Web Services resource, in Unix time format (in seconds).</p>
    pub timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The action for the <code>Rule</code> that the request matched: <code>Allow</code>, <code>Block</code>, or <code>Count</code>.</p>
    pub action: std::option::Option<std::string::String>,
    /// <p>The name of the <code>Rule</code> that the request matched. For managed rule groups, the format for this name is <code>
    /// <vendor name>
    /// #
    /// <managed rule group name>
    /// #
    /// <rule name></rule>
    /// </managed>
    /// </vendor></code>. For your own rule groups, the format for this name is <code>
    /// <rule group name>
    /// #
    /// <rule name></rule>
    /// </rule></code>. If the rule is not in a rule group, this field is absent. </p>
    pub rule_name_within_rule_group: std::option::Option<std::string::String>,
    /// <p>Custom request headers inserted by WAF into the request, according to the custom request configuration for the matching rule action.</p>
    pub request_headers_inserted: std::option::Option<std::vec::Vec<crate::model::HttpHeader>>,
    /// <p>The response code that was sent for the request.</p>
    pub response_code_sent: std::option::Option<i32>,
    /// <p>Labels applied to the web request by matching rules. WAF applies fully qualified labels to matching web requests. A fully qualified label is the concatenation of a label namespace and a rule label. The rule's rule group or web ACL defines the label namespace. </p>
    /// <p>For example, <code>awswaf:111122223333:myRuleGroup:testRules:testNS1:testNS2:labelNameA</code> or <code>awswaf:managed:aws:managed-rule-set:header:encoding:utf8</code>. </p>
    pub labels: std::option::Option<std::vec::Vec<crate::model::Label>>,
    /// <p>The <code>CAPTCHA</code> response for the request.</p>
    pub captcha_response: std::option::Option<crate::model::CaptchaResponse>,
}
impl SampledHttpRequest {
    /// <p>A complex type that contains detailed information about the request.</p>
    pub fn request(&self) -> std::option::Option<&crate::model::HttpRequest> {
        self.request.as_ref()
    }
    /// <p>A value that indicates how one result in the response relates proportionally to other results in the response. For example, a result that has a weight of <code>2</code> represents roughly twice as many web requests as a result that has a weight of <code>1</code>.</p>
    pub fn weight(&self) -> i64 {
        self.weight
    }
    /// <p>The time at which WAF received the request from your Amazon Web Services resource, in Unix time format (in seconds).</p>
    pub fn timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.timestamp.as_ref()
    }
    /// <p>The action for the <code>Rule</code> that the request matched: <code>Allow</code>, <code>Block</code>, or <code>Count</code>.</p>
    pub fn action(&self) -> std::option::Option<&str> {
        self.action.as_deref()
    }
    /// <p>The name of the <code>Rule</code> that the request matched. For managed rule groups, the format for this name is <code>
    /// <vendor name>
    /// #
    /// <managed rule group name>
    /// #
    /// <rule name></rule>
    /// </managed>
    /// </vendor></code>. For your own rule groups, the format for this name is <code>
    /// <rule group name>
    /// #
    /// <rule name></rule>
    /// </rule></code>. If the rule is not in a rule group, this field is absent. </p>
    pub fn rule_name_within_rule_group(&self) -> std::option::Option<&str> {
        self.rule_name_within_rule_group.as_deref()
    }
    /// <p>Custom request headers inserted by WAF into the request, according to the custom request configuration for the matching rule action.</p>
    pub fn request_headers_inserted(&self) -> std::option::Option<&[crate::model::HttpHeader]> {
        self.request_headers_inserted.as_deref()
    }
    /// <p>The response code that was sent for the request.</p>
    pub fn response_code_sent(&self) -> std::option::Option<i32> {
        self.response_code_sent
    }
    /// <p>Labels applied to the web request by matching rules. WAF applies fully qualified labels to matching web requests. A fully qualified label is the concatenation of a label namespace and a rule label. The rule's rule group or web ACL defines the label namespace. </p>
    /// <p>For example, <code>awswaf:111122223333:myRuleGroup:testRules:testNS1:testNS2:labelNameA</code> or <code>awswaf:managed:aws:managed-rule-set:header:encoding:utf8</code>. </p>
    pub fn labels(&self) -> std::option::Option<&[crate::model::Label]> {
        self.labels.as_deref()
    }
    /// <p>The <code>CAPTCHA</code> response for the request.</p>
    pub fn captcha_response(&self) -> std::option::Option<&crate::model::CaptchaResponse> {
        self.captcha_response.as_ref()
    }
}
impl std::fmt::Debug for SampledHttpRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SampledHttpRequest");
        formatter.field("request", &self.request);
        formatter.field("weight", &self.weight);
        formatter.field("timestamp", &self.timestamp);
        formatter.field("action", &self.action);
        formatter.field(
            "rule_name_within_rule_group",
            &self.rule_name_within_rule_group,
        );
        formatter.field("request_headers_inserted", &self.request_headers_inserted);
        formatter.field("response_code_sent", &self.response_code_sent);
        formatter.field("labels", &self.labels);
        formatter.field("captcha_response", &self.captcha_response);
        formatter.finish()
    }
}
/// See [`SampledHttpRequest`](crate::model::SampledHttpRequest)
pub mod sampled_http_request {
    /// A builder for [`SampledHttpRequest`](crate::model::SampledHttpRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) request: std::option::Option<crate::model::HttpRequest>,
        pub(crate) weight: std::option::Option<i64>,
        pub(crate) timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) action: std::option::Option<std::string::String>,
        pub(crate) rule_name_within_rule_group: std::option::Option<std::string::String>,
        pub(crate) request_headers_inserted:
            std::option::Option<std::vec::Vec<crate::model::HttpHeader>>,
        pub(crate) response_code_sent: std::option::Option<i32>,
        pub(crate) labels: std::option::Option<std::vec::Vec<crate::model::Label>>,
        pub(crate) captcha_response: std::option::Option<crate::model::CaptchaResponse>,
    }
    impl Builder {
        /// <p>A complex type that contains detailed information about the request.</p>
        pub fn request(mut self, input: crate::model::HttpRequest) -> Self {
            self.request = Some(input);
            self
        }
        /// <p>A complex type that contains detailed information about the request.</p>
        pub fn set_request(
            mut self,
            input: std::option::Option<crate::model::HttpRequest>,
        ) -> Self {
            self.request = input;
            self
        }
        /// <p>A value that indicates how one result in the response relates proportionally to other results in the response. For example, a result that has a weight of <code>2</code> represents roughly twice as many web requests as a result that has a weight of <code>1</code>.</p>
        pub fn weight(mut self, input: i64) -> Self {
            self.weight = Some(input);
            self
        }
        /// <p>A value that indicates how one result in the response relates proportionally to other results in the response. For example, a result that has a weight of <code>2</code> represents roughly twice as many web requests as a result that has a weight of <code>1</code>.</p>
        pub fn set_weight(mut self, input: std::option::Option<i64>) -> Self {
            self.weight = input;
            self
        }
        /// <p>The time at which WAF received the request from your Amazon Web Services resource, in Unix time format (in seconds).</p>
        pub fn timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.timestamp = Some(input);
            self
        }
        /// <p>The time at which WAF received the request from your Amazon Web Services resource, in Unix time format (in seconds).</p>
        pub fn set_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.timestamp = input;
            self
        }
        /// <p>The action for the <code>Rule</code> that the request matched: <code>Allow</code>, <code>Block</code>, or <code>Count</code>.</p>
        pub fn action(mut self, input: impl Into<std::string::String>) -> Self {
            self.action = Some(input.into());
            self
        }
        /// <p>The action for the <code>Rule</code> that the request matched: <code>Allow</code>, <code>Block</code>, or <code>Count</code>.</p>
        pub fn set_action(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action = input;
            self
        }
        /// <p>The name of the <code>Rule</code> that the request matched. For managed rule groups, the format for this name is <code>
        /// <vendor name>
        /// #
        /// <managed rule group name>
        /// #
        /// <rule name></rule>
        /// </managed>
        /// </vendor></code>. For your own rule groups, the format for this name is <code>
        /// <rule group name>
        /// #
        /// <rule name></rule>
        /// </rule></code>. If the rule is not in a rule group, this field is absent. </p>
        pub fn rule_name_within_rule_group(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.rule_name_within_rule_group = Some(input.into());
            self
        }
        /// <p>The name of the <code>Rule</code> that the request matched. For managed rule groups, the format for this name is <code>
        /// <vendor name>
        /// #
        /// <managed rule group name>
        /// #
        /// <rule name></rule>
        /// </managed>
        /// </vendor></code>. For your own rule groups, the format for this name is <code>
        /// <rule group name>
        /// #
        /// <rule name></rule>
        /// </rule></code>. If the rule is not in a rule group, this field is absent. </p>
        pub fn set_rule_name_within_rule_group(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_name_within_rule_group = input;
            self
        }
        /// Appends an item to `request_headers_inserted`.
        ///
        /// To override the contents of this collection use [`set_request_headers_inserted`](Self::set_request_headers_inserted).
        ///
        /// <p>Custom request headers inserted by WAF into the request, according to the custom request configuration for the matching rule action.</p>
        pub fn request_headers_inserted(mut self, input: crate::model::HttpHeader) -> Self {
            let mut v = self.request_headers_inserted.unwrap_or_default();
            v.push(input);
            self.request_headers_inserted = Some(v);
            self
        }
        /// <p>Custom request headers inserted by WAF into the request, according to the custom request configuration for the matching rule action.</p>
        pub fn set_request_headers_inserted(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HttpHeader>>,
        ) -> Self {
            self.request_headers_inserted = input;
            self
        }
        /// <p>The response code that was sent for the request.</p>
        pub fn response_code_sent(mut self, input: i32) -> Self {
            self.response_code_sent = Some(input);
            self
        }
        /// <p>The response code that was sent for the request.</p>
        pub fn set_response_code_sent(mut self, input: std::option::Option<i32>) -> Self {
            self.response_code_sent = input;
            self
        }
        /// Appends an item to `labels`.
        ///
        /// To override the contents of this collection use [`set_labels`](Self::set_labels).
        ///
        /// <p>Labels applied to the web request by matching rules. WAF applies fully qualified labels to matching web requests. A fully qualified label is the concatenation of a label namespace and a rule label. The rule's rule group or web ACL defines the label namespace. </p>
        /// <p>For example, <code>awswaf:111122223333:myRuleGroup:testRules:testNS1:testNS2:labelNameA</code> or <code>awswaf:managed:aws:managed-rule-set:header:encoding:utf8</code>. </p>
        pub fn labels(mut self, input: crate::model::Label) -> Self {
            let mut v = self.labels.unwrap_or_default();
            v.push(input);
            self.labels = Some(v);
            self
        }
        /// <p>Labels applied to the web request by matching rules. WAF applies fully qualified labels to matching web requests. A fully qualified label is the concatenation of a label namespace and a rule label. The rule's rule group or web ACL defines the label namespace. </p>
        /// <p>For example, <code>awswaf:111122223333:myRuleGroup:testRules:testNS1:testNS2:labelNameA</code> or <code>awswaf:managed:aws:managed-rule-set:header:encoding:utf8</code>. </p>
        pub fn set_labels(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Label>>,
        ) -> Self {
            self.labels = input;
            self
        }
        /// <p>The <code>CAPTCHA</code> response for the request.</p>
        pub fn captcha_response(mut self, input: crate::model::CaptchaResponse) -> Self {
            self.captcha_response = Some(input);
            self
        }
        /// <p>The <code>CAPTCHA</code> response for the request.</p>
        pub fn set_captcha_response(
            mut self,
            input: std::option::Option<crate::model::CaptchaResponse>,
        ) -> Self {
            self.captcha_response = input;
            self
        }
        /// Consumes the builder and constructs a [`SampledHttpRequest`](crate::model::SampledHttpRequest)
        pub fn build(self) -> crate::model::SampledHttpRequest {
            crate::model::SampledHttpRequest {
                request: self.request,
                weight: self.weight.unwrap_or_default(),
                timestamp: self.timestamp,
                action: self.action,
                rule_name_within_rule_group: self.rule_name_within_rule_group,
                request_headers_inserted: self.request_headers_inserted,
                response_code_sent: self.response_code_sent,
                labels: self.labels,
                captcha_response: self.captcha_response,
            }
        }
    }
}
impl SampledHttpRequest {
    /// Creates a new builder-style object to manufacture [`SampledHttpRequest`](crate::model::SampledHttpRequest)
    pub fn builder() -> crate::model::sampled_http_request::Builder {
        crate::model::sampled_http_request::Builder::default()
    }
}

/// <p>The result from the inspection of the web request for a valid <code>CAPTCHA</code> token. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CaptchaResponse {
    /// <p>The HTTP response code indicating the status of the <code>CAPTCHA</code> token in the web request. If the token is missing, invalid, or expired, this code is <code>405 Method Not Allowed</code>.</p>
    pub response_code: std::option::Option<i32>,
    /// <p>The time that the <code>CAPTCHA</code> puzzle was solved for the supplied token. </p>
    pub solve_timestamp: std::option::Option<i64>,
    /// <p>The reason for failure, populated when the evaluation of the token fails.</p>
    pub failure_reason: std::option::Option<crate::model::FailureReason>,
}
impl CaptchaResponse {
    /// <p>The HTTP response code indicating the status of the <code>CAPTCHA</code> token in the web request. If the token is missing, invalid, or expired, this code is <code>405 Method Not Allowed</code>.</p>
    pub fn response_code(&self) -> std::option::Option<i32> {
        self.response_code
    }
    /// <p>The time that the <code>CAPTCHA</code> puzzle was solved for the supplied token. </p>
    pub fn solve_timestamp(&self) -> std::option::Option<i64> {
        self.solve_timestamp
    }
    /// <p>The reason for failure, populated when the evaluation of the token fails.</p>
    pub fn failure_reason(&self) -> std::option::Option<&crate::model::FailureReason> {
        self.failure_reason.as_ref()
    }
}
impl std::fmt::Debug for CaptchaResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CaptchaResponse");
        formatter.field("response_code", &self.response_code);
        formatter.field("solve_timestamp", &self.solve_timestamp);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.finish()
    }
}
/// See [`CaptchaResponse`](crate::model::CaptchaResponse)
pub mod captcha_response {
    /// A builder for [`CaptchaResponse`](crate::model::CaptchaResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) response_code: std::option::Option<i32>,
        pub(crate) solve_timestamp: std::option::Option<i64>,
        pub(crate) failure_reason: std::option::Option<crate::model::FailureReason>,
    }
    impl Builder {
        /// <p>The HTTP response code indicating the status of the <code>CAPTCHA</code> token in the web request. If the token is missing, invalid, or expired, this code is <code>405 Method Not Allowed</code>.</p>
        pub fn response_code(mut self, input: i32) -> Self {
            self.response_code = Some(input);
            self
        }
        /// <p>The HTTP response code indicating the status of the <code>CAPTCHA</code> token in the web request. If the token is missing, invalid, or expired, this code is <code>405 Method Not Allowed</code>.</p>
        pub fn set_response_code(mut self, input: std::option::Option<i32>) -> Self {
            self.response_code = input;
            self
        }
        /// <p>The time that the <code>CAPTCHA</code> puzzle was solved for the supplied token. </p>
        pub fn solve_timestamp(mut self, input: i64) -> Self {
            self.solve_timestamp = Some(input);
            self
        }
        /// <p>The time that the <code>CAPTCHA</code> puzzle was solved for the supplied token. </p>
        pub fn set_solve_timestamp(mut self, input: std::option::Option<i64>) -> Self {
            self.solve_timestamp = input;
            self
        }
        /// <p>The reason for failure, populated when the evaluation of the token fails.</p>
        pub fn failure_reason(mut self, input: crate::model::FailureReason) -> Self {
            self.failure_reason = Some(input);
            self
        }
        /// <p>The reason for failure, populated when the evaluation of the token fails.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<crate::model::FailureReason>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`CaptchaResponse`](crate::model::CaptchaResponse)
        pub fn build(self) -> crate::model::CaptchaResponse {
            crate::model::CaptchaResponse {
                response_code: self.response_code,
                solve_timestamp: self.solve_timestamp,
                failure_reason: self.failure_reason,
            }
        }
    }
}
impl CaptchaResponse {
    /// Creates a new builder-style object to manufacture [`CaptchaResponse`](crate::model::CaptchaResponse)
    pub fn builder() -> crate::model::captcha_response::Builder {
        crate::model::captcha_response::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FailureReason {
    #[allow(missing_docs)] // documentation missing in model
    TokenExpired,
    #[allow(missing_docs)] // documentation missing in model
    TokenMissing,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FailureReason {
    fn from(s: &str) -> Self {
        match s {
            "TOKEN_EXPIRED" => FailureReason::TokenExpired,
            "TOKEN_MISSING" => FailureReason::TokenMissing,
            other => FailureReason::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FailureReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FailureReason::from(s))
    }
}
impl FailureReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FailureReason::TokenExpired => "TOKEN_EXPIRED",
            FailureReason::TokenMissing => "TOKEN_MISSING",
            FailureReason::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["TOKEN_EXPIRED", "TOKEN_MISSING"]
    }
}
impl AsRef<str> for FailureReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Part of the response from <code>GetSampledRequests</code>. This is a complex type that appears as <code>Headers</code> in the response syntax. <code>HTTPHeader</code> contains the names and values of all of the headers that appear in one of the web requests. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HttpHeader {
    /// <p>The name of the HTTP header.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The value of the HTTP header.</p>
    pub value: std::option::Option<std::string::String>,
}
impl HttpHeader {
    /// <p>The name of the HTTP header.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The value of the HTTP header.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for HttpHeader {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HttpHeader");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`HttpHeader`](crate::model::HttpHeader)
pub mod http_header {
    /// A builder for [`HttpHeader`](crate::model::HttpHeader)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the HTTP header.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the HTTP header.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The value of the HTTP header.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the HTTP header.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`HttpHeader`](crate::model::HttpHeader)
        pub fn build(self) -> crate::model::HttpHeader {
            crate::model::HttpHeader {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl HttpHeader {
    /// Creates a new builder-style object to manufacture [`HttpHeader`](crate::model::HttpHeader)
    pub fn builder() -> crate::model::http_header::Builder {
        crate::model::http_header::Builder::default()
    }
}

/// <p>Part of the response from <code>GetSampledRequests</code>. This is a complex type that appears as <code>Request</code> in the response syntax. <code>HTTPRequest</code> contains information about one of the web requests. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HttpRequest {
    /// <p>The IP address that the request originated from. If the web ACL is associated with a CloudFront distribution, this is the value of one of the following fields in CloudFront access logs:</p>
    /// <ul>
    /// <li> <p> <code>c-ip</code>, if the viewer did not use an HTTP proxy or a load balancer to send the request</p> </li>
    /// <li> <p> <code>x-forwarded-for</code>, if the viewer did use an HTTP proxy or a load balancer to send the request</p> </li>
    /// </ul>
    pub client_ip: std::option::Option<std::string::String>,
    /// <p>The two-letter country code for the country that the request originated from. For a current list of country codes, see the Wikipedia entry <a href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2">ISO 3166-1 alpha-2</a>.</p>
    pub country: std::option::Option<std::string::String>,
    /// <p>The URI path of the request, which identifies the resource, for example, <code>/images/daily-ad.jpg</code>.</p>
    pub uri: std::option::Option<std::string::String>,
    /// <p>The HTTP method specified in the sampled web request. </p>
    pub method: std::option::Option<std::string::String>,
    /// <p>The HTTP version specified in the sampled web request, for example, <code>HTTP/1.1</code>.</p>
    pub http_version: std::option::Option<std::string::String>,
    /// <p>A complex type that contains the name and value for each header in the sampled web request.</p>
    pub headers: std::option::Option<std::vec::Vec<crate::model::HttpHeader>>,
}
impl HttpRequest {
    /// <p>The IP address that the request originated from. If the web ACL is associated with a CloudFront distribution, this is the value of one of the following fields in CloudFront access logs:</p>
    /// <ul>
    /// <li> <p> <code>c-ip</code>, if the viewer did not use an HTTP proxy or a load balancer to send the request</p> </li>
    /// <li> <p> <code>x-forwarded-for</code>, if the viewer did use an HTTP proxy or a load balancer to send the request</p> </li>
    /// </ul>
    pub fn client_ip(&self) -> std::option::Option<&str> {
        self.client_ip.as_deref()
    }
    /// <p>The two-letter country code for the country that the request originated from. For a current list of country codes, see the Wikipedia entry <a href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2">ISO 3166-1 alpha-2</a>.</p>
    pub fn country(&self) -> std::option::Option<&str> {
        self.country.as_deref()
    }
    /// <p>The URI path of the request, which identifies the resource, for example, <code>/images/daily-ad.jpg</code>.</p>
    pub fn uri(&self) -> std::option::Option<&str> {
        self.uri.as_deref()
    }
    /// <p>The HTTP method specified in the sampled web request. </p>
    pub fn method(&self) -> std::option::Option<&str> {
        self.method.as_deref()
    }
    /// <p>The HTTP version specified in the sampled web request, for example, <code>HTTP/1.1</code>.</p>
    pub fn http_version(&self) -> std::option::Option<&str> {
        self.http_version.as_deref()
    }
    /// <p>A complex type that contains the name and value for each header in the sampled web request.</p>
    pub fn headers(&self) -> std::option::Option<&[crate::model::HttpHeader]> {
        self.headers.as_deref()
    }
}
impl std::fmt::Debug for HttpRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HttpRequest");
        formatter.field("client_ip", &self.client_ip);
        formatter.field("country", &self.country);
        formatter.field("uri", &self.uri);
        formatter.field("method", &self.method);
        formatter.field("http_version", &self.http_version);
        formatter.field("headers", &self.headers);
        formatter.finish()
    }
}
/// See [`HttpRequest`](crate::model::HttpRequest)
pub mod http_request {
    /// A builder for [`HttpRequest`](crate::model::HttpRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_ip: std::option::Option<std::string::String>,
        pub(crate) country: std::option::Option<std::string::String>,
        pub(crate) uri: std::option::Option<std::string::String>,
        pub(crate) method: std::option::Option<std::string::String>,
        pub(crate) http_version: std::option::Option<std::string::String>,
        pub(crate) headers: std::option::Option<std::vec::Vec<crate::model::HttpHeader>>,
    }
    impl Builder {
        /// <p>The IP address that the request originated from. If the web ACL is associated with a CloudFront distribution, this is the value of one of the following fields in CloudFront access logs:</p>
        /// <ul>
        /// <li> <p> <code>c-ip</code>, if the viewer did not use an HTTP proxy or a load balancer to send the request</p> </li>
        /// <li> <p> <code>x-forwarded-for</code>, if the viewer did use an HTTP proxy or a load balancer to send the request</p> </li>
        /// </ul>
        pub fn client_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_ip = Some(input.into());
            self
        }
        /// <p>The IP address that the request originated from. If the web ACL is associated with a CloudFront distribution, this is the value of one of the following fields in CloudFront access logs:</p>
        /// <ul>
        /// <li> <p> <code>c-ip</code>, if the viewer did not use an HTTP proxy or a load balancer to send the request</p> </li>
        /// <li> <p> <code>x-forwarded-for</code>, if the viewer did use an HTTP proxy or a load balancer to send the request</p> </li>
        /// </ul>
        pub fn set_client_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_ip = input;
            self
        }
        /// <p>The two-letter country code for the country that the request originated from. For a current list of country codes, see the Wikipedia entry <a href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2">ISO 3166-1 alpha-2</a>.</p>
        pub fn country(mut self, input: impl Into<std::string::String>) -> Self {
            self.country = Some(input.into());
            self
        }
        /// <p>The two-letter country code for the country that the request originated from. For a current list of country codes, see the Wikipedia entry <a href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2">ISO 3166-1 alpha-2</a>.</p>
        pub fn set_country(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.country = input;
            self
        }
        /// <p>The URI path of the request, which identifies the resource, for example, <code>/images/daily-ad.jpg</code>.</p>
        pub fn uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.uri = Some(input.into());
            self
        }
        /// <p>The URI path of the request, which identifies the resource, for example, <code>/images/daily-ad.jpg</code>.</p>
        pub fn set_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.uri = input;
            self
        }
        /// <p>The HTTP method specified in the sampled web request. </p>
        pub fn method(mut self, input: impl Into<std::string::String>) -> Self {
            self.method = Some(input.into());
            self
        }
        /// <p>The HTTP method specified in the sampled web request. </p>
        pub fn set_method(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.method = input;
            self
        }
        /// <p>The HTTP version specified in the sampled web request, for example, <code>HTTP/1.1</code>.</p>
        pub fn http_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.http_version = Some(input.into());
            self
        }
        /// <p>The HTTP version specified in the sampled web request, for example, <code>HTTP/1.1</code>.</p>
        pub fn set_http_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.http_version = input;
            self
        }
        /// Appends an item to `headers`.
        ///
        /// To override the contents of this collection use [`set_headers`](Self::set_headers).
        ///
        /// <p>A complex type that contains the name and value for each header in the sampled web request.</p>
        pub fn headers(mut self, input: crate::model::HttpHeader) -> Self {
            let mut v = self.headers.unwrap_or_default();
            v.push(input);
            self.headers = Some(v);
            self
        }
        /// <p>A complex type that contains the name and value for each header in the sampled web request.</p>
        pub fn set_headers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HttpHeader>>,
        ) -> Self {
            self.headers = input;
            self
        }
        /// Consumes the builder and constructs a [`HttpRequest`](crate::model::HttpRequest)
        pub fn build(self) -> crate::model::HttpRequest {
            crate::model::HttpRequest {
                client_ip: self.client_ip,
                country: self.country,
                uri: self.uri,
                method: self.method,
                http_version: self.http_version,
                headers: self.headers,
            }
        }
    }
}
impl HttpRequest {
    /// Creates a new builder-style object to manufacture [`HttpRequest`](crate::model::HttpRequest)
    pub fn builder() -> crate::model::http_request::Builder {
        crate::model::http_request::Builder::default()
    }
}

/// <p> A rule group defines a collection of rules to inspect and control web requests that you can use in a <code>WebACL</code>. When you create a rule group, you define an immutable capacity limit. If you update a rule group, you must stay within the capacity. This allows others to reuse the rule group with confidence in its capacity requirements. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuleGroup {
    /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the rule group. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The web ACL capacity units (WCUs) required for this rule group.</p>
    /// <p>When you create your own rule group, you define this, and you cannot change it after creation. When you add or modify the rules in a rule group, WAF enforces this limit. You can check the capacity for a set of rules using <code>CheckCapacity</code>.</p>
    /// <p>WAF uses WCUs to calculate and control the operating resources that are used to run your rules, rule groups, and web ACLs. WAF calculates capacity differently for each rule type, to reflect the relative cost of each rule. Simple rules that cost little to run use fewer WCUs than more complex rules that use more processing power. Rule group capacity is fixed at creation, which helps users plan their web ACL WCU usage when they use a rule group. The WCU limit for web ACLs is 1,500. </p>
    pub capacity: i64,
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>A description of the rule group that helps with identification. </p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The <code>Rule</code> statements used to identify the web requests that you want to allow, block, or count. Each rule includes one top-level statement that WAF uses to identify matching web requests, and parameters that govern how WAF handles them. </p>
    pub rules: std::option::Option<std::vec::Vec<crate::model::Rule>>,
    /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection. </p>
    pub visibility_config: std::option::Option<crate::model::VisibilityConfig>,
    /// <p>The label namespace prefix for this rule group. All labels added by rules in this rule group have this prefix. </p>
    /// <ul>
    /// <li> <p>The syntax for the label namespace prefix for your rule groups is the following: </p> <p> <code>awswaf:
    /// <account id>
    /// :rulegroup:
    /// <rule group name>
    /// :
    /// </rule>
    /// </account></code> </p> </li>
    /// <li> <p>When a rule with a label matches a web request, WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p> <p> <code><label namespace>:<label from rule></label></label></code> </p> </li>
    /// </ul>
    pub label_namespace: std::option::Option<std::string::String>,
    /// <p>A map of custom response keys and content bodies. When you create a rule with a block action, you can send a custom response to the web request. You define these for the rule group, and then use them in the rules that you define in the rule group. </p>
    /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    pub custom_response_bodies: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::CustomResponseBody>,
    >,
    /// <p>The labels that one or more rules in this rule group add to matching web requests. These labels are defined in the <code>RuleLabels</code> for a <code>Rule</code>.</p>
    pub available_labels: std::option::Option<std::vec::Vec<crate::model::LabelSummary>>,
    /// <p>The labels that one or more rules in this rule group match against in label match statements. These labels are defined in a <code>LabelMatchStatement</code> specification, in the <code>Statement</code> definition of a rule. </p>
    pub consumed_labels: std::option::Option<std::vec::Vec<crate::model::LabelSummary>>,
}
impl RuleGroup {
    /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A unique identifier for the rule group. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The web ACL capacity units (WCUs) required for this rule group.</p>
    /// <p>When you create your own rule group, you define this, and you cannot change it after creation. When you add or modify the rules in a rule group, WAF enforces this limit. You can check the capacity for a set of rules using <code>CheckCapacity</code>.</p>
    /// <p>WAF uses WCUs to calculate and control the operating resources that are used to run your rules, rule groups, and web ACLs. WAF calculates capacity differently for each rule type, to reflect the relative cost of each rule. Simple rules that cost little to run use fewer WCUs than more complex rules that use more processing power. Rule group capacity is fixed at creation, which helps users plan their web ACL WCU usage when they use a rule group. The WCU limit for web ACLs is 1,500. </p>
    pub fn capacity(&self) -> i64 {
        self.capacity
    }
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>A description of the rule group that helps with identification. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The <code>Rule</code> statements used to identify the web requests that you want to allow, block, or count. Each rule includes one top-level statement that WAF uses to identify matching web requests, and parameters that govern how WAF handles them. </p>
    pub fn rules(&self) -> std::option::Option<&[crate::model::Rule]> {
        self.rules.as_deref()
    }
    /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection. </p>
    pub fn visibility_config(&self) -> std::option::Option<&crate::model::VisibilityConfig> {
        self.visibility_config.as_ref()
    }
    /// <p>The label namespace prefix for this rule group. All labels added by rules in this rule group have this prefix. </p>
    /// <ul>
    /// <li> <p>The syntax for the label namespace prefix for your rule groups is the following: </p> <p> <code>awswaf:
    /// <account id>
    /// :rulegroup:
    /// <rule group name>
    /// :
    /// </rule>
    /// </account></code> </p> </li>
    /// <li> <p>When a rule with a label matches a web request, WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p> <p> <code><label namespace>:<label from rule></label></label></code> </p> </li>
    /// </ul>
    pub fn label_namespace(&self) -> std::option::Option<&str> {
        self.label_namespace.as_deref()
    }
    /// <p>A map of custom response keys and content bodies. When you create a rule with a block action, you can send a custom response to the web request. You define these for the rule group, and then use them in the rules that you define in the rule group. </p>
    /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
    pub fn custom_response_bodies(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::CustomResponseBody>,
    > {
        self.custom_response_bodies.as_ref()
    }
    /// <p>The labels that one or more rules in this rule group add to matching web requests. These labels are defined in the <code>RuleLabels</code> for a <code>Rule</code>.</p>
    pub fn available_labels(&self) -> std::option::Option<&[crate::model::LabelSummary]> {
        self.available_labels.as_deref()
    }
    /// <p>The labels that one or more rules in this rule group match against in label match statements. These labels are defined in a <code>LabelMatchStatement</code> specification, in the <code>Statement</code> definition of a rule. </p>
    pub fn consumed_labels(&self) -> std::option::Option<&[crate::model::LabelSummary]> {
        self.consumed_labels.as_deref()
    }
}
impl std::fmt::Debug for RuleGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RuleGroup");
        formatter.field("name", &self.name);
        formatter.field("id", &self.id);
        formatter.field("capacity", &self.capacity);
        formatter.field("arn", &self.arn);
        formatter.field("description", &self.description);
        formatter.field("rules", &self.rules);
        formatter.field("visibility_config", &self.visibility_config);
        formatter.field("label_namespace", &self.label_namespace);
        formatter.field("custom_response_bodies", &self.custom_response_bodies);
        formatter.field("available_labels", &self.available_labels);
        formatter.field("consumed_labels", &self.consumed_labels);
        formatter.finish()
    }
}
/// See [`RuleGroup`](crate::model::RuleGroup)
pub mod rule_group {
    /// A builder for [`RuleGroup`](crate::model::RuleGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) capacity: std::option::Option<i64>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) rules: std::option::Option<std::vec::Vec<crate::model::Rule>>,
        pub(crate) visibility_config: std::option::Option<crate::model::VisibilityConfig>,
        pub(crate) label_namespace: std::option::Option<std::string::String>,
        pub(crate) custom_response_bodies: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::CustomResponseBody>,
        >,
        pub(crate) available_labels: std::option::Option<std::vec::Vec<crate::model::LabelSummary>>,
        pub(crate) consumed_labels: std::option::Option<std::vec::Vec<crate::model::LabelSummary>>,
    }
    impl Builder {
        /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A unique identifier for the rule group. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the rule group. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The web ACL capacity units (WCUs) required for this rule group.</p>
        /// <p>When you create your own rule group, you define this, and you cannot change it after creation. When you add or modify the rules in a rule group, WAF enforces this limit. You can check the capacity for a set of rules using <code>CheckCapacity</code>.</p>
        /// <p>WAF uses WCUs to calculate and control the operating resources that are used to run your rules, rule groups, and web ACLs. WAF calculates capacity differently for each rule type, to reflect the relative cost of each rule. Simple rules that cost little to run use fewer WCUs than more complex rules that use more processing power. Rule group capacity is fixed at creation, which helps users plan their web ACL WCU usage when they use a rule group. The WCU limit for web ACLs is 1,500. </p>
        pub fn capacity(mut self, input: i64) -> Self {
            self.capacity = Some(input);
            self
        }
        /// <p>The web ACL capacity units (WCUs) required for this rule group.</p>
        /// <p>When you create your own rule group, you define this, and you cannot change it after creation. When you add or modify the rules in a rule group, WAF enforces this limit. You can check the capacity for a set of rules using <code>CheckCapacity</code>.</p>
        /// <p>WAF uses WCUs to calculate and control the operating resources that are used to run your rules, rule groups, and web ACLs. WAF calculates capacity differently for each rule type, to reflect the relative cost of each rule. Simple rules that cost little to run use fewer WCUs than more complex rules that use more processing power. Rule group capacity is fixed at creation, which helps users plan their web ACL WCU usage when they use a rule group. The WCU limit for web ACLs is 1,500. </p>
        pub fn set_capacity(mut self, input: std::option::Option<i64>) -> Self {
            self.capacity = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entity.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entity.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>A description of the rule group that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the rule group that helps with identification. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `rules`.
        ///
        /// To override the contents of this collection use [`set_rules`](Self::set_rules).
        ///
        /// <p>The <code>Rule</code> statements used to identify the web requests that you want to allow, block, or count. Each rule includes one top-level statement that WAF uses to identify matching web requests, and parameters that govern how WAF handles them. </p>
        pub fn rules(mut self, input: crate::model::Rule) -> Self {
            let mut v = self.rules.unwrap_or_default();
            v.push(input);
            self.rules = Some(v);
            self
        }
        /// <p>The <code>Rule</code> statements used to identify the web requests that you want to allow, block, or count. Each rule includes one top-level statement that WAF uses to identify matching web requests, and parameters that govern how WAF handles them. </p>
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Rule>>,
        ) -> Self {
            self.rules = input;
            self
        }
        /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection. </p>
        pub fn visibility_config(mut self, input: crate::model::VisibilityConfig) -> Self {
            self.visibility_config = Some(input);
            self
        }
        /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection. </p>
        pub fn set_visibility_config(
            mut self,
            input: std::option::Option<crate::model::VisibilityConfig>,
        ) -> Self {
            self.visibility_config = input;
            self
        }
        /// <p>The label namespace prefix for this rule group. All labels added by rules in this rule group have this prefix. </p>
        /// <ul>
        /// <li> <p>The syntax for the label namespace prefix for your rule groups is the following: </p> <p> <code>awswaf:
        /// <account id>
        /// :rulegroup:
        /// <rule group name>
        /// :
        /// </rule>
        /// </account></code> </p> </li>
        /// <li> <p>When a rule with a label matches a web request, WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p> <p> <code><label namespace>:<label from rule></label></label></code> </p> </li>
        /// </ul>
        pub fn label_namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.label_namespace = Some(input.into());
            self
        }
        /// <p>The label namespace prefix for this rule group. All labels added by rules in this rule group have this prefix. </p>
        /// <ul>
        /// <li> <p>The syntax for the label namespace prefix for your rule groups is the following: </p> <p> <code>awswaf:
        /// <account id>
        /// :rulegroup:
        /// <rule group name>
        /// :
        /// </rule>
        /// </account></code> </p> </li>
        /// <li> <p>When a rule with a label matches a web request, WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p> <p> <code><label namespace>:<label from rule></label></label></code> </p> </li>
        /// </ul>
        pub fn set_label_namespace(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.label_namespace = input;
            self
        }
        /// Adds a key-value pair to `custom_response_bodies`.
        ///
        /// To override the contents of this collection use [`set_custom_response_bodies`](Self::set_custom_response_bodies).
        ///
        /// <p>A map of custom response keys and content bodies. When you create a rule with a block action, you can send a custom response to the web request. You define these for the rule group, and then use them in the rules that you define in the rule group. </p>
        /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        pub fn custom_response_bodies(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::CustomResponseBody,
        ) -> Self {
            let mut hash_map = self.custom_response_bodies.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.custom_response_bodies = Some(hash_map);
            self
        }
        /// <p>A map of custom response keys and content bodies. When you create a rule with a block action, you can send a custom response to the web request. You define these for the rule group, and then use them in the rules that you define in the rule group. </p>
        /// <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in WAF</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        /// <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">WAF quotas</a> in the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">WAF Developer Guide</a>. </p>
        pub fn set_custom_response_bodies(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::CustomResponseBody>,
            >,
        ) -> Self {
            self.custom_response_bodies = input;
            self
        }
        /// Appends an item to `available_labels`.
        ///
        /// To override the contents of this collection use [`set_available_labels`](Self::set_available_labels).
        ///
        /// <p>The labels that one or more rules in this rule group add to matching web requests. These labels are defined in the <code>RuleLabels</code> for a <code>Rule</code>.</p>
        pub fn available_labels(mut self, input: crate::model::LabelSummary) -> Self {
            let mut v = self.available_labels.unwrap_or_default();
            v.push(input);
            self.available_labels = Some(v);
            self
        }
        /// <p>The labels that one or more rules in this rule group add to matching web requests. These labels are defined in the <code>RuleLabels</code> for a <code>Rule</code>.</p>
        pub fn set_available_labels(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LabelSummary>>,
        ) -> Self {
            self.available_labels = input;
            self
        }
        /// Appends an item to `consumed_labels`.
        ///
        /// To override the contents of this collection use [`set_consumed_labels`](Self::set_consumed_labels).
        ///
        /// <p>The labels that one or more rules in this rule group match against in label match statements. These labels are defined in a <code>LabelMatchStatement</code> specification, in the <code>Statement</code> definition of a rule. </p>
        pub fn consumed_labels(mut self, input: crate::model::LabelSummary) -> Self {
            let mut v = self.consumed_labels.unwrap_or_default();
            v.push(input);
            self.consumed_labels = Some(v);
            self
        }
        /// <p>The labels that one or more rules in this rule group match against in label match statements. These labels are defined in a <code>LabelMatchStatement</code> specification, in the <code>Statement</code> definition of a rule. </p>
        pub fn set_consumed_labels(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LabelSummary>>,
        ) -> Self {
            self.consumed_labels = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleGroup`](crate::model::RuleGroup)
        pub fn build(self) -> crate::model::RuleGroup {
            crate::model::RuleGroup {
                name: self.name,
                id: self.id,
                capacity: self.capacity.unwrap_or_default(),
                arn: self.arn,
                description: self.description,
                rules: self.rules,
                visibility_config: self.visibility_config,
                label_namespace: self.label_namespace,
                custom_response_bodies: self.custom_response_bodies,
                available_labels: self.available_labels,
                consumed_labels: self.consumed_labels,
            }
        }
    }
}
impl RuleGroup {
    /// Creates a new builder-style object to manufacture [`RuleGroup`](crate::model::RuleGroup)
    pub fn builder() -> crate::model::rule_group::Builder {
        crate::model::rule_group::Builder::default()
    }
}

/// <p>List of labels used by one or more of the rules of a <code>RuleGroup</code>. This summary object is used for the following rule group lists: </p>
/// <ul>
/// <li> <p> <code>AvailableLabels</code> - Labels that rules add to matching requests. These labels are defined in the <code>RuleLabels</code> for a <code>Rule</code>. </p> </li>
/// <li> <p> <code>ConsumedLabels</code> - Labels that rules match against. These labels are defined in a <code>LabelMatchStatement</code> specification, in the <code>Statement</code> definition of a rule. </p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelSummary {
    /// <p>An individual label specification.</p>
    pub name: std::option::Option<std::string::String>,
}
impl LabelSummary {
    /// <p>An individual label specification.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl std::fmt::Debug for LabelSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelSummary");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`LabelSummary`](crate::model::LabelSummary)
pub mod label_summary {
    /// A builder for [`LabelSummary`](crate::model::LabelSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An individual label specification.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>An individual label specification.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelSummary`](crate::model::LabelSummary)
        pub fn build(self) -> crate::model::LabelSummary {
            crate::model::LabelSummary { name: self.name }
        }
    }
}
impl LabelSummary {
    /// Creates a new builder-style object to manufacture [`LabelSummary`](crate::model::LabelSummary)
    pub fn builder() -> crate::model::label_summary::Builder {
        crate::model::label_summary::Builder::default()
    }
}

/// <p>Contains one or more regular expressions. </p>
/// <p>WAF assigns an ARN to each <code>RegexPatternSet</code> that you create. To use a set in a rule, you provide the ARN to the <code>Rule</code> statement <code>RegexPatternSetReferenceStatement</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegexPatternSet {
    /// <p>The name of the set. You cannot change the name after you create the set.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>A description of the set that helps with identification. </p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The regular expression patterns in the set.</p>
    pub regular_expression_list: std::option::Option<std::vec::Vec<crate::model::Regex>>,
}
impl RegexPatternSet {
    /// <p>The name of the set. You cannot change the name after you create the set.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>A description of the set that helps with identification. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The regular expression patterns in the set.</p>
    pub fn regular_expression_list(&self) -> std::option::Option<&[crate::model::Regex]> {
        self.regular_expression_list.as_deref()
    }
}
impl std::fmt::Debug for RegexPatternSet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegexPatternSet");
        formatter.field("name", &self.name);
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("description", &self.description);
        formatter.field("regular_expression_list", &self.regular_expression_list);
        formatter.finish()
    }
}
/// See [`RegexPatternSet`](crate::model::RegexPatternSet)
pub mod regex_pattern_set {
    /// A builder for [`RegexPatternSet`](crate::model::RegexPatternSet)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) regular_expression_list: std::option::Option<std::vec::Vec<crate::model::Regex>>,
    }
    impl Builder {
        /// <p>The name of the set. You cannot change the name after you create the set.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the set. You cannot change the name after you create the set.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entity.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entity.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>A description of the set that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the set that helps with identification. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `regular_expression_list`.
        ///
        /// To override the contents of this collection use [`set_regular_expression_list`](Self::set_regular_expression_list).
        ///
        /// <p>The regular expression patterns in the set.</p>
        pub fn regular_expression_list(mut self, input: crate::model::Regex) -> Self {
            let mut v = self.regular_expression_list.unwrap_or_default();
            v.push(input);
            self.regular_expression_list = Some(v);
            self
        }
        /// <p>The regular expression patterns in the set.</p>
        pub fn set_regular_expression_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Regex>>,
        ) -> Self {
            self.regular_expression_list = input;
            self
        }
        /// Consumes the builder and constructs a [`RegexPatternSet`](crate::model::RegexPatternSet)
        pub fn build(self) -> crate::model::RegexPatternSet {
            crate::model::RegexPatternSet {
                name: self.name,
                id: self.id,
                arn: self.arn,
                description: self.description,
                regular_expression_list: self.regular_expression_list,
            }
        }
    }
}
impl RegexPatternSet {
    /// Creates a new builder-style object to manufacture [`RegexPatternSet`](crate::model::RegexPatternSet)
    pub fn builder() -> crate::model::regex_pattern_set::Builder {
        crate::model::regex_pattern_set::Builder::default()
    }
}

/// <p>The set of IP addresses that are currently blocked for a <code>RateBasedStatement</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RateBasedStatementManagedKeysIpSet {
    /// <p>The version of the IP addresses, either <code>IPV4</code> or <code>IPV6</code>. </p>
    pub ip_address_version: std::option::Option<crate::model::IpAddressVersion>,
    /// <p>The IP addresses that are currently blocked.</p>
    pub addresses: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl RateBasedStatementManagedKeysIpSet {
    /// <p>The version of the IP addresses, either <code>IPV4</code> or <code>IPV6</code>. </p>
    pub fn ip_address_version(&self) -> std::option::Option<&crate::model::IpAddressVersion> {
        self.ip_address_version.as_ref()
    }
    /// <p>The IP addresses that are currently blocked.</p>
    pub fn addresses(&self) -> std::option::Option<&[std::string::String]> {
        self.addresses.as_deref()
    }
}
impl std::fmt::Debug for RateBasedStatementManagedKeysIpSet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RateBasedStatementManagedKeysIpSet");
        formatter.field("ip_address_version", &self.ip_address_version);
        formatter.field("addresses", &self.addresses);
        formatter.finish()
    }
}
/// See [`RateBasedStatementManagedKeysIpSet`](crate::model::RateBasedStatementManagedKeysIpSet)
pub mod rate_based_statement_managed_keys_ip_set {
    /// A builder for [`RateBasedStatementManagedKeysIpSet`](crate::model::RateBasedStatementManagedKeysIpSet)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ip_address_version: std::option::Option<crate::model::IpAddressVersion>,
        pub(crate) addresses: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The version of the IP addresses, either <code>IPV4</code> or <code>IPV6</code>. </p>
        pub fn ip_address_version(mut self, input: crate::model::IpAddressVersion) -> Self {
            self.ip_address_version = Some(input);
            self
        }
        /// <p>The version of the IP addresses, either <code>IPV4</code> or <code>IPV6</code>. </p>
        pub fn set_ip_address_version(
            mut self,
            input: std::option::Option<crate::model::IpAddressVersion>,
        ) -> Self {
            self.ip_address_version = input;
            self
        }
        /// Appends an item to `addresses`.
        ///
        /// To override the contents of this collection use [`set_addresses`](Self::set_addresses).
        ///
        /// <p>The IP addresses that are currently blocked.</p>
        pub fn addresses(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.addresses.unwrap_or_default();
            v.push(input.into());
            self.addresses = Some(v);
            self
        }
        /// <p>The IP addresses that are currently blocked.</p>
        pub fn set_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.addresses = input;
            self
        }
        /// Consumes the builder and constructs a [`RateBasedStatementManagedKeysIpSet`](crate::model::RateBasedStatementManagedKeysIpSet)
        pub fn build(self) -> crate::model::RateBasedStatementManagedKeysIpSet {
            crate::model::RateBasedStatementManagedKeysIpSet {
                ip_address_version: self.ip_address_version,
                addresses: self.addresses,
            }
        }
    }
}
impl RateBasedStatementManagedKeysIpSet {
    /// Creates a new builder-style object to manufacture [`RateBasedStatementManagedKeysIpSet`](crate::model::RateBasedStatementManagedKeysIpSet)
    pub fn builder() -> crate::model::rate_based_statement_managed_keys_ip_set::Builder {
        crate::model::rate_based_statement_managed_keys_ip_set::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum IpAddressVersion {
    #[allow(missing_docs)] // documentation missing in model
    Ipv4,
    #[allow(missing_docs)] // documentation missing in model
    Ipv6,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for IpAddressVersion {
    fn from(s: &str) -> Self {
        match s {
            "IPV4" => IpAddressVersion::Ipv4,
            "IPV6" => IpAddressVersion::Ipv6,
            other => IpAddressVersion::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for IpAddressVersion {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(IpAddressVersion::from(s))
    }
}
impl IpAddressVersion {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            IpAddressVersion::Ipv4 => "IPV4",
            IpAddressVersion::Ipv6 => "IPV6",
            IpAddressVersion::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["IPV4", "IPV6"]
    }
}
impl AsRef<str> for IpAddressVersion {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information for a release of the mobile SDK, including release notes and tags.</p>
/// <p>The mobile SDK is not generally available. Customers who have access to the mobile SDK can use it to establish and manage Security Token Service (STS) security tokens for use in HTTP(S) requests from a mobile device to WAF. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-application-integration.html">WAF client application integration</a> in the <i>WAF Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MobileSdkRelease {
    /// <p>The release version. </p>
    pub release_version: std::option::Option<std::string::String>,
    /// <p>The timestamp of the release. </p>
    pub timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Notes describing the release.</p>
    pub release_notes: std::option::Option<std::string::String>,
    /// <p>Tags that are associated with the release. </p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl MobileSdkRelease {
    /// <p>The release version. </p>
    pub fn release_version(&self) -> std::option::Option<&str> {
        self.release_version.as_deref()
    }
    /// <p>The timestamp of the release. </p>
    pub fn timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.timestamp.as_ref()
    }
    /// <p>Notes describing the release.</p>
    pub fn release_notes(&self) -> std::option::Option<&str> {
        self.release_notes.as_deref()
    }
    /// <p>Tags that are associated with the release. </p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for MobileSdkRelease {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MobileSdkRelease");
        formatter.field("release_version", &self.release_version);
        formatter.field("timestamp", &self.timestamp);
        formatter.field("release_notes", &self.release_notes);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`MobileSdkRelease`](crate::model::MobileSdkRelease)
pub mod mobile_sdk_release {
    /// A builder for [`MobileSdkRelease`](crate::model::MobileSdkRelease)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) release_version: std::option::Option<std::string::String>,
        pub(crate) timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) release_notes: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The release version. </p>
        pub fn release_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.release_version = Some(input.into());
            self
        }
        /// <p>The release version. </p>
        pub fn set_release_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.release_version = input;
            self
        }
        /// <p>The timestamp of the release. </p>
        pub fn timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.timestamp = Some(input);
            self
        }
        /// <p>The timestamp of the release. </p>
        pub fn set_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.timestamp = input;
            self
        }
        /// <p>Notes describing the release.</p>
        pub fn release_notes(mut self, input: impl Into<std::string::String>) -> Self {
            self.release_notes = Some(input.into());
            self
        }
        /// <p>Notes describing the release.</p>
        pub fn set_release_notes(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.release_notes = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Tags that are associated with the release. </p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Tags that are associated with the release. </p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`MobileSdkRelease`](crate::model::MobileSdkRelease)
        pub fn build(self) -> crate::model::MobileSdkRelease {
            crate::model::MobileSdkRelease {
                release_version: self.release_version,
                timestamp: self.timestamp,
                release_notes: self.release_notes,
                tags: self.tags,
            }
        }
    }
}
impl MobileSdkRelease {
    /// Creates a new builder-style object to manufacture [`MobileSdkRelease`](crate::model::MobileSdkRelease)
    pub fn builder() -> crate::model::mobile_sdk_release::Builder {
        crate::model::mobile_sdk_release::Builder::default()
    }
}

/// <p>A set of rules that is managed by Amazon Web Services and Amazon Web Services Marketplace sellers to provide versioned managed rule groups for customers of WAF.</p> <note>
/// <p>This is intended for use only by vendors of managed rule sets. Vendors are Amazon Web Services and Amazon Web Services Marketplace sellers. </p>
/// <p>Vendors, you can use the managed rule set APIs to provide controlled rollout of your versioned managed rule group offerings for your customers. The APIs are <code>ListManagedRuleSets</code>, <code>GetManagedRuleSet</code>, <code>PutManagedRuleSetVersions</code>, and <code>UpdateManagedRuleSetVersionExpiryDate</code>.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ManagedRuleSet {
    /// <p>The name of the managed rule set. You use this, along with the rule set ID, to identify the rule set.</p>
    /// <p>This name is assigned to the corresponding managed rule group, which your customers can access and use. </p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the managed rule set. The ID is returned in the responses to commands like <code>list</code>. You provide it to operations like <code>get</code> and <code>update</code>.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>A description of the set that helps with identification. </p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The versions of this managed rule set that are available for use by customers. </p>
    pub published_versions: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::ManagedRuleSetVersion>,
    >,
    /// <p>The version that you would like your customers to use.</p>
    pub recommended_version: std::option::Option<std::string::String>,
    /// <p>The label namespace prefix for the managed rule groups that are offered to customers from this managed rule set. All labels that are added by rules in the managed rule group have this prefix. </p>
    /// <ul>
    /// <li> <p>The syntax for the label namespace prefix for a managed rule group is the following: </p> <p> <code>awswaf:managed:
    /// <vendor>
    /// :
    /// <rule group name></rule>
    /// </vendor></code>:</p> </li>
    /// <li> <p>When a rule with a label matches a web request, WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p> <p> <code><label namespace>:<label from rule></label></label></code> </p> </li>
    /// </ul>
    pub label_namespace: std::option::Option<std::string::String>,
}
impl ManagedRuleSet {
    /// <p>The name of the managed rule set. You use this, along with the rule set ID, to identify the rule set.</p>
    /// <p>This name is assigned to the corresponding managed rule group, which your customers can access and use. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A unique identifier for the managed rule set. The ID is returned in the responses to commands like <code>list</code>. You provide it to operations like <code>get</code> and <code>update</code>.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>A description of the set that helps with identification. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The versions of this managed rule set that are available for use by customers. </p>
    pub fn published_versions(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::ManagedRuleSetVersion>,
    > {
        self.published_versions.as_ref()
    }
    /// <p>The version that you would like your customers to use.</p>
    pub fn recommended_version(&self) -> std::option::Option<&str> {
        self.recommended_version.as_deref()
    }
    /// <p>The label namespace prefix for the managed rule groups that are offered to customers from this managed rule set. All labels that are added by rules in the managed rule group have this prefix. </p>
    /// <ul>
    /// <li> <p>The syntax for the label namespace prefix for a managed rule group is the following: </p> <p> <code>awswaf:managed:
    /// <vendor>
    /// :
    /// <rule group name></rule>
    /// </vendor></code>:</p> </li>
    /// <li> <p>When a rule with a label matches a web request, WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p> <p> <code><label namespace>:<label from rule></label></label></code> </p> </li>
    /// </ul>
    pub fn label_namespace(&self) -> std::option::Option<&str> {
        self.label_namespace.as_deref()
    }
}
impl std::fmt::Debug for ManagedRuleSet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ManagedRuleSet");
        formatter.field("name", &self.name);
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("description", &self.description);
        formatter.field("published_versions", &self.published_versions);
        formatter.field("recommended_version", &self.recommended_version);
        formatter.field("label_namespace", &self.label_namespace);
        formatter.finish()
    }
}
/// See [`ManagedRuleSet`](crate::model::ManagedRuleSet)
pub mod managed_rule_set {
    /// A builder for [`ManagedRuleSet`](crate::model::ManagedRuleSet)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) published_versions: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::ManagedRuleSetVersion>,
        >,
        pub(crate) recommended_version: std::option::Option<std::string::String>,
        pub(crate) label_namespace: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the managed rule set. You use this, along with the rule set ID, to identify the rule set.</p>
        /// <p>This name is assigned to the corresponding managed rule group, which your customers can access and use. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the managed rule set. You use this, along with the rule set ID, to identify the rule set.</p>
        /// <p>This name is assigned to the corresponding managed rule group, which your customers can access and use. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A unique identifier for the managed rule set. The ID is returned in the responses to commands like <code>list</code>. You provide it to operations like <code>get</code> and <code>update</code>.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the managed rule set. The ID is returned in the responses to commands like <code>list</code>. You provide it to operations like <code>get</code> and <code>update</code>.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entity.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entity.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>A description of the set that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the set that helps with identification. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Adds a key-value pair to `published_versions`.
        ///
        /// To override the contents of this collection use [`set_published_versions`](Self::set_published_versions).
        ///
        /// <p>The versions of this managed rule set that are available for use by customers. </p>
        pub fn published_versions(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::ManagedRuleSetVersion,
        ) -> Self {
            let mut hash_map = self.published_versions.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.published_versions = Some(hash_map);
            self
        }
        /// <p>The versions of this managed rule set that are available for use by customers. </p>
        pub fn set_published_versions(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::ManagedRuleSetVersion>,
            >,
        ) -> Self {
            self.published_versions = input;
            self
        }
        /// <p>The version that you would like your customers to use.</p>
        pub fn recommended_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.recommended_version = Some(input.into());
            self
        }
        /// <p>The version that you would like your customers to use.</p>
        pub fn set_recommended_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommended_version = input;
            self
        }
        /// <p>The label namespace prefix for the managed rule groups that are offered to customers from this managed rule set. All labels that are added by rules in the managed rule group have this prefix. </p>
        /// <ul>
        /// <li> <p>The syntax for the label namespace prefix for a managed rule group is the following: </p> <p> <code>awswaf:managed:
        /// <vendor>
        /// :
        /// <rule group name></rule>
        /// </vendor></code>:</p> </li>
        /// <li> <p>When a rule with a label matches a web request, WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p> <p> <code><label namespace>:<label from rule></label></label></code> </p> </li>
        /// </ul>
        pub fn label_namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.label_namespace = Some(input.into());
            self
        }
        /// <p>The label namespace prefix for the managed rule groups that are offered to customers from this managed rule set. All labels that are added by rules in the managed rule group have this prefix. </p>
        /// <ul>
        /// <li> <p>The syntax for the label namespace prefix for a managed rule group is the following: </p> <p> <code>awswaf:managed:
        /// <vendor>
        /// :
        /// <rule group name></rule>
        /// </vendor></code>:</p> </li>
        /// <li> <p>When a rule with a label matches a web request, WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p> <p> <code><label namespace>:<label from rule></label></label></code> </p> </li>
        /// </ul>
        pub fn set_label_namespace(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.label_namespace = input;
            self
        }
        /// Consumes the builder and constructs a [`ManagedRuleSet`](crate::model::ManagedRuleSet)
        pub fn build(self) -> crate::model::ManagedRuleSet {
            crate::model::ManagedRuleSet {
                name: self.name,
                id: self.id,
                arn: self.arn,
                description: self.description,
                published_versions: self.published_versions,
                recommended_version: self.recommended_version,
                label_namespace: self.label_namespace,
            }
        }
    }
}
impl ManagedRuleSet {
    /// Creates a new builder-style object to manufacture [`ManagedRuleSet`](crate::model::ManagedRuleSet)
    pub fn builder() -> crate::model::managed_rule_set::Builder {
        crate::model::managed_rule_set::Builder::default()
    }
}

/// <p>Information for a single version of a managed rule set. </p> <note>
/// <p>This is intended for use only by vendors of managed rule sets. Vendors are Amazon Web Services and Amazon Web Services Marketplace sellers. </p>
/// <p>Vendors, you can use the managed rule set APIs to provide controlled rollout of your versioned managed rule group offerings for your customers. The APIs are <code>ListManagedRuleSets</code>, <code>GetManagedRuleSet</code>, <code>PutManagedRuleSetVersions</code>, and <code>UpdateManagedRuleSetVersionExpiryDate</code>.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ManagedRuleSetVersion {
    /// <p>The Amazon Resource Name (ARN) of the vendor rule group that's used to define the published version of your managed rule group. </p>
    pub associated_rule_group_arn: std::option::Option<std::string::String>,
    /// <p>The web ACL capacity units (WCUs) required for this rule group.</p>
    /// <p>WAF uses WCUs to calculate and control the operating resources that are used to run your rules, rule groups, and web ACLs. WAF calculates capacity differently for each rule type, to reflect the relative cost of each rule. Simple rules that cost little to run use fewer WCUs than more complex rules that use more processing power. Rule group capacity is fixed at creation, which helps users plan their web ACL WCU usage when they use a rule group. The WCU limit for web ACLs is 1,500. </p>
    pub capacity: i64,
    /// <p>The amount of time you expect this version of your managed rule group to last, in days. </p>
    pub forecasted_lifetime: std::option::Option<i32>,
    /// <p>The time that you first published this version. </p>
    /// <p>Times are in Coordinated Universal Time (UTC) format. UTC format includes the special designator, Z. For example, "2016-09-27T14:50Z". </p>
    pub publish_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time that you updated this version. </p>
    /// <p>Times are in Coordinated Universal Time (UTC) format. UTC format includes the special designator, Z. For example, "2016-09-27T14:50Z". </p>
    pub last_update_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that this version is set to expire.</p>
    /// <p>Times are in Coordinated Universal Time (UTC) format. UTC format includes the special designator, Z. For example, "2016-09-27T14:50Z". </p>
    pub expiry_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl ManagedRuleSetVersion {
    /// <p>The Amazon Resource Name (ARN) of the vendor rule group that's used to define the published version of your managed rule group. </p>
    pub fn associated_rule_group_arn(&self) -> std::option::Option<&str> {
        self.associated_rule_group_arn.as_deref()
    }
    /// <p>The web ACL capacity units (WCUs) required for this rule group.</p>
    /// <p>WAF uses WCUs to calculate and control the operating resources that are used to run your rules, rule groups, and web ACLs. WAF calculates capacity differently for each rule type, to reflect the relative cost of each rule. Simple rules that cost little to run use fewer WCUs than more complex rules that use more processing power. Rule group capacity is fixed at creation, which helps users plan their web ACL WCU usage when they use a rule group. The WCU limit for web ACLs is 1,500. </p>
    pub fn capacity(&self) -> i64 {
        self.capacity
    }
    /// <p>The amount of time you expect this version of your managed rule group to last, in days. </p>
    pub fn forecasted_lifetime(&self) -> std::option::Option<i32> {
        self.forecasted_lifetime
    }
    /// <p>The time that you first published this version. </p>
    /// <p>Times are in Coordinated Universal Time (UTC) format. UTC format includes the special designator, Z. For example, "2016-09-27T14:50Z". </p>
    pub fn publish_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.publish_timestamp.as_ref()
    }
    /// <p>The last time that you updated this version. </p>
    /// <p>Times are in Coordinated Universal Time (UTC) format. UTC format includes the special designator, Z. For example, "2016-09-27T14:50Z". </p>
    pub fn last_update_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_update_timestamp.as_ref()
    }
    /// <p>The time that this version is set to expire.</p>
    /// <p>Times are in Coordinated Universal Time (UTC) format. UTC format includes the special designator, Z. For example, "2016-09-27T14:50Z". </p>
    pub fn expiry_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.expiry_timestamp.as_ref()
    }
}
impl std::fmt::Debug for ManagedRuleSetVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ManagedRuleSetVersion");
        formatter.field("associated_rule_group_arn", &self.associated_rule_group_arn);
        formatter.field("capacity", &self.capacity);
        formatter.field("forecasted_lifetime", &self.forecasted_lifetime);
        formatter.field("publish_timestamp", &self.publish_timestamp);
        formatter.field("last_update_timestamp", &self.last_update_timestamp);
        formatter.field("expiry_timestamp", &self.expiry_timestamp);
        formatter.finish()
    }
}
/// See [`ManagedRuleSetVersion`](crate::model::ManagedRuleSetVersion)
pub mod managed_rule_set_version {
    /// A builder for [`ManagedRuleSetVersion`](crate::model::ManagedRuleSetVersion)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) associated_rule_group_arn: std::option::Option<std::string::String>,
        pub(crate) capacity: std::option::Option<i64>,
        pub(crate) forecasted_lifetime: std::option::Option<i32>,
        pub(crate) publish_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_update_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) expiry_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the vendor rule group that's used to define the published version of your managed rule group. </p>
        pub fn associated_rule_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.associated_rule_group_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the vendor rule group that's used to define the published version of your managed rule group. </p>
        pub fn set_associated_rule_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.associated_rule_group_arn = input;
            self
        }
        /// <p>The web ACL capacity units (WCUs) required for this rule group.</p>
        /// <p>WAF uses WCUs to calculate and control the operating resources that are used to run your rules, rule groups, and web ACLs. WAF calculates capacity differently for each rule type, to reflect the relative cost of each rule. Simple rules that cost little to run use fewer WCUs than more complex rules that use more processing power. Rule group capacity is fixed at creation, which helps users plan their web ACL WCU usage when they use a rule group. The WCU limit for web ACLs is 1,500. </p>
        pub fn capacity(mut self, input: i64) -> Self {
            self.capacity = Some(input);
            self
        }
        /// <p>The web ACL capacity units (WCUs) required for this rule group.</p>
        /// <p>WAF uses WCUs to calculate and control the operating resources that are used to run your rules, rule groups, and web ACLs. WAF calculates capacity differently for each rule type, to reflect the relative cost of each rule. Simple rules that cost little to run use fewer WCUs than more complex rules that use more processing power. Rule group capacity is fixed at creation, which helps users plan their web ACL WCU usage when they use a rule group. The WCU limit for web ACLs is 1,500. </p>
        pub fn set_capacity(mut self, input: std::option::Option<i64>) -> Self {
            self.capacity = input;
            self
        }
        /// <p>The amount of time you expect this version of your managed rule group to last, in days. </p>
        pub fn forecasted_lifetime(mut self, input: i32) -> Self {
            self.forecasted_lifetime = Some(input);
            self
        }
        /// <p>The amount of time you expect this version of your managed rule group to last, in days. </p>
        pub fn set_forecasted_lifetime(mut self, input: std::option::Option<i32>) -> Self {
            self.forecasted_lifetime = input;
            self
        }
        /// <p>The time that you first published this version. </p>
        /// <p>Times are in Coordinated Universal Time (UTC) format. UTC format includes the special designator, Z. For example, "2016-09-27T14:50Z". </p>
        pub fn publish_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.publish_timestamp = Some(input);
            self
        }
        /// <p>The time that you first published this version. </p>
        /// <p>Times are in Coordinated Universal Time (UTC) format. UTC format includes the special designator, Z. For example, "2016-09-27T14:50Z". </p>
        pub fn set_publish_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.publish_timestamp = input;
            self
        }
        /// <p>The last time that you updated this version. </p>
        /// <p>Times are in Coordinated Universal Time (UTC) format. UTC format includes the special designator, Z. For example, "2016-09-27T14:50Z". </p>
        pub fn last_update_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_update_timestamp = Some(input);
            self
        }
        /// <p>The last time that you updated this version. </p>
        /// <p>Times are in Coordinated Universal Time (UTC) format. UTC format includes the special designator, Z. For example, "2016-09-27T14:50Z". </p>
        pub fn set_last_update_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_update_timestamp = input;
            self
        }
        /// <p>The time that this version is set to expire.</p>
        /// <p>Times are in Coordinated Universal Time (UTC) format. UTC format includes the special designator, Z. For example, "2016-09-27T14:50Z". </p>
        pub fn expiry_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.expiry_timestamp = Some(input);
            self
        }
        /// <p>The time that this version is set to expire.</p>
        /// <p>Times are in Coordinated Universal Time (UTC) format. UTC format includes the special designator, Z. For example, "2016-09-27T14:50Z". </p>
        pub fn set_expiry_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.expiry_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`ManagedRuleSetVersion`](crate::model::ManagedRuleSetVersion)
        pub fn build(self) -> crate::model::ManagedRuleSetVersion {
            crate::model::ManagedRuleSetVersion {
                associated_rule_group_arn: self.associated_rule_group_arn,
                capacity: self.capacity.unwrap_or_default(),
                forecasted_lifetime: self.forecasted_lifetime,
                publish_timestamp: self.publish_timestamp,
                last_update_timestamp: self.last_update_timestamp,
                expiry_timestamp: self.expiry_timestamp,
            }
        }
    }
}
impl ManagedRuleSetVersion {
    /// Creates a new builder-style object to manufacture [`ManagedRuleSetVersion`](crate::model::ManagedRuleSetVersion)
    pub fn builder() -> crate::model::managed_rule_set_version::Builder {
        crate::model::managed_rule_set_version::Builder::default()
    }
}

/// <p>Contains zero or more IP addresses or blocks of IP addresses specified in Classless Inter-Domain Routing (CIDR) notation. WAF supports all IPv4 and IPv6 CIDR ranges except for /0. For information about CIDR notation, see the Wikipedia entry <a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p>
/// <p>WAF assigns an ARN to each <code>IPSet</code> that you create. To use an IP set in a rule, you provide the ARN to the <code>Rule</code> statement <code>IPSetReferenceStatement</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IpSet {
    /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>A description of the IP set that helps with identification. </p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The version of the IP addresses, either <code>IPV4</code> or <code>IPV6</code>. </p>
    pub ip_address_version: std::option::Option<crate::model::IpAddressVersion>,
    /// <p>Contains an array of strings that specifies zero or more IP addresses or blocks of IP addresses in Classless Inter-Domain Routing (CIDR) notation. WAF supports all IPv4 and IPv6 CIDR ranges except for /0. </p>
    /// <p>Example address strings: </p>
    /// <ul>
    /// <li> <p>To configure WAF to allow, block, or count requests that originated from the IP address 192.0.2.44, specify <code>192.0.2.44/32</code>.</p> </li>
    /// <li> <p>To configure WAF to allow, block, or count requests that originated from IP addresses from 192.0.2.0 to 192.0.2.255, specify <code>192.0.2.0/24</code>.</p> </li>
    /// <li> <p>To configure WAF to allow, block, or count requests that originated from the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify <code>1111:0000:0000:0000:0000:0000:0000:0111/128</code>.</p> </li>
    /// <li> <p>To configure WAF to allow, block, or count requests that originated from IP addresses 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify <code>1111:0000:0000:0000:0000:0000:0000:0000/64</code>.</p> </li>
    /// </ul>
    /// <p>For more information about CIDR notation, see the Wikipedia entry <a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>.</p>
    /// <p>Example JSON <code>Addresses</code> specifications: </p>
    /// <ul>
    /// <li> <p>Empty array: <code>"Addresses": []</code> </p> </li>
    /// <li> <p>Array with one address: <code>"Addresses": ["192.0.2.44/32"]</code> </p> </li>
    /// <li> <p>Array with three addresses: <code>"Addresses": ["192.0.2.44/32", "192.0.2.0/24", "192.0.0.0/16"]</code> </p> </li>
    /// <li> <p>INVALID specification: <code>"Addresses": [""]</code> INVALID </p> </li>
    /// </ul>
    pub addresses: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl IpSet {
    /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>A description of the IP set that helps with identification. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The version of the IP addresses, either <code>IPV4</code> or <code>IPV6</code>. </p>
    pub fn ip_address_version(&self) -> std::option::Option<&crate::model::IpAddressVersion> {
        self.ip_address_version.as_ref()
    }
    /// <p>Contains an array of strings that specifies zero or more IP addresses or blocks of IP addresses in Classless Inter-Domain Routing (CIDR) notation. WAF supports all IPv4 and IPv6 CIDR ranges except for /0. </p>
    /// <p>Example address strings: </p>
    /// <ul>
    /// <li> <p>To configure WAF to allow, block, or count requests that originated from the IP address 192.0.2.44, specify <code>192.0.2.44/32</code>.</p> </li>
    /// <li> <p>To configure WAF to allow, block, or count requests that originated from IP addresses from 192.0.2.0 to 192.0.2.255, specify <code>192.0.2.0/24</code>.</p> </li>
    /// <li> <p>To configure WAF to allow, block, or count requests that originated from the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify <code>1111:0000:0000:0000:0000:0000:0000:0111/128</code>.</p> </li>
    /// <li> <p>To configure WAF to allow, block, or count requests that originated from IP addresses 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify <code>1111:0000:0000:0000:0000:0000:0000:0000/64</code>.</p> </li>
    /// </ul>
    /// <p>For more information about CIDR notation, see the Wikipedia entry <a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>.</p>
    /// <p>Example JSON <code>Addresses</code> specifications: </p>
    /// <ul>
    /// <li> <p>Empty array: <code>"Addresses": []</code> </p> </li>
    /// <li> <p>Array with one address: <code>"Addresses": ["192.0.2.44/32"]</code> </p> </li>
    /// <li> <p>Array with three addresses: <code>"Addresses": ["192.0.2.44/32", "192.0.2.0/24", "192.0.0.0/16"]</code> </p> </li>
    /// <li> <p>INVALID specification: <code>"Addresses": [""]</code> INVALID </p> </li>
    /// </ul>
    pub fn addresses(&self) -> std::option::Option<&[std::string::String]> {
        self.addresses.as_deref()
    }
}
impl std::fmt::Debug for IpSet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IpSet");
        formatter.field("name", &self.name);
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.field("description", &self.description);
        formatter.field("ip_address_version", &self.ip_address_version);
        formatter.field("addresses", &self.addresses);
        formatter.finish()
    }
}
/// See [`IpSet`](crate::model::IpSet)
pub mod ip_set {
    /// A builder for [`IpSet`](crate::model::IpSet)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) ip_address_version: std::option::Option<crate::model::IpAddressVersion>,
        pub(crate) addresses: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entity.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entity.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>A description of the IP set that helps with identification. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the IP set that helps with identification. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The version of the IP addresses, either <code>IPV4</code> or <code>IPV6</code>. </p>
        pub fn ip_address_version(mut self, input: crate::model::IpAddressVersion) -> Self {
            self.ip_address_version = Some(input);
            self
        }
        /// <p>The version of the IP addresses, either <code>IPV4</code> or <code>IPV6</code>. </p>
        pub fn set_ip_address_version(
            mut self,
            input: std::option::Option<crate::model::IpAddressVersion>,
        ) -> Self {
            self.ip_address_version = input;
            self
        }
        /// Appends an item to `addresses`.
        ///
        /// To override the contents of this collection use [`set_addresses`](Self::set_addresses).
        ///
        /// <p>Contains an array of strings that specifies zero or more IP addresses or blocks of IP addresses in Classless Inter-Domain Routing (CIDR) notation. WAF supports all IPv4 and IPv6 CIDR ranges except for /0. </p>
        /// <p>Example address strings: </p>
        /// <ul>
        /// <li> <p>To configure WAF to allow, block, or count requests that originated from the IP address 192.0.2.44, specify <code>192.0.2.44/32</code>.</p> </li>
        /// <li> <p>To configure WAF to allow, block, or count requests that originated from IP addresses from 192.0.2.0 to 192.0.2.255, specify <code>192.0.2.0/24</code>.</p> </li>
        /// <li> <p>To configure WAF to allow, block, or count requests that originated from the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify <code>1111:0000:0000:0000:0000:0000:0000:0111/128</code>.</p> </li>
        /// <li> <p>To configure WAF to allow, block, or count requests that originated from IP addresses 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify <code>1111:0000:0000:0000:0000:0000:0000:0000/64</code>.</p> </li>
        /// </ul>
        /// <p>For more information about CIDR notation, see the Wikipedia entry <a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>.</p>
        /// <p>Example JSON <code>Addresses</code> specifications: </p>
        /// <ul>
        /// <li> <p>Empty array: <code>"Addresses": []</code> </p> </li>
        /// <li> <p>Array with one address: <code>"Addresses": ["192.0.2.44/32"]</code> </p> </li>
        /// <li> <p>Array with three addresses: <code>"Addresses": ["192.0.2.44/32", "192.0.2.0/24", "192.0.0.0/16"]</code> </p> </li>
        /// <li> <p>INVALID specification: <code>"Addresses": [""]</code> INVALID </p> </li>
        /// </ul>
        pub fn addresses(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.addresses.unwrap_or_default();
            v.push(input.into());
            self.addresses = Some(v);
            self
        }
        /// <p>Contains an array of strings that specifies zero or more IP addresses or blocks of IP addresses in Classless Inter-Domain Routing (CIDR) notation. WAF supports all IPv4 and IPv6 CIDR ranges except for /0. </p>
        /// <p>Example address strings: </p>
        /// <ul>
        /// <li> <p>To configure WAF to allow, block, or count requests that originated from the IP address 192.0.2.44, specify <code>192.0.2.44/32</code>.</p> </li>
        /// <li> <p>To configure WAF to allow, block, or count requests that originated from IP addresses from 192.0.2.0 to 192.0.2.255, specify <code>192.0.2.0/24</code>.</p> </li>
        /// <li> <p>To configure WAF to allow, block, or count requests that originated from the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify <code>1111:0000:0000:0000:0000:0000:0000:0111/128</code>.</p> </li>
        /// <li> <p>To configure WAF to allow, block, or count requests that originated from IP addresses 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify <code>1111:0000:0000:0000:0000:0000:0000:0000/64</code>.</p> </li>
        /// </ul>
        /// <p>For more information about CIDR notation, see the Wikipedia entry <a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>.</p>
        /// <p>Example JSON <code>Addresses</code> specifications: </p>
        /// <ul>
        /// <li> <p>Empty array: <code>"Addresses": []</code> </p> </li>
        /// <li> <p>Array with one address: <code>"Addresses": ["192.0.2.44/32"]</code> </p> </li>
        /// <li> <p>Array with three addresses: <code>"Addresses": ["192.0.2.44/32", "192.0.2.0/24", "192.0.0.0/16"]</code> </p> </li>
        /// <li> <p>INVALID specification: <code>"Addresses": [""]</code> INVALID </p> </li>
        /// </ul>
        pub fn set_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.addresses = input;
            self
        }
        /// Consumes the builder and constructs a [`IpSet`](crate::model::IpSet)
        pub fn build(self) -> crate::model::IpSet {
            crate::model::IpSet {
                name: self.name,
                id: self.id,
                arn: self.arn,
                description: self.description,
                ip_address_version: self.ip_address_version,
                addresses: self.addresses,
            }
        }
    }
}
impl IpSet {
    /// Creates a new builder-style object to manufacture [`IpSet`](crate::model::IpSet)
    pub fn builder() -> crate::model::ip_set::Builder {
        crate::model::ip_set::Builder::default()
    }
}

/// <p>High-level information about a <code>Rule</code>, returned by operations like <code>DescribeManagedRuleGroup</code>. This provides information like the ID, that you can use to retrieve and manage a <code>RuleGroup</code>, and the ARN, that you provide to the <code>RuleGroupReferenceStatement</code> to use the rule group in a <code>Rule</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuleSummary {
    /// <p>The name of the rule. </p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The action that WAF should take on a web request when it matches a rule's statement. Settings at the web ACL level can override the rule action setting. </p>
    pub action: std::option::Option<crate::model::RuleAction>,
}
impl RuleSummary {
    /// <p>The name of the rule. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The action that WAF should take on a web request when it matches a rule's statement. Settings at the web ACL level can override the rule action setting. </p>
    pub fn action(&self) -> std::option::Option<&crate::model::RuleAction> {
        self.action.as_ref()
    }
}
impl std::fmt::Debug for RuleSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RuleSummary");
        formatter.field("name", &self.name);
        formatter.field("action", &self.action);
        formatter.finish()
    }
}
/// See [`RuleSummary`](crate::model::RuleSummary)
pub mod rule_summary {
    /// A builder for [`RuleSummary`](crate::model::RuleSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) action: std::option::Option<crate::model::RuleAction>,
    }
    impl Builder {
        /// <p>The name of the rule. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the rule. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The action that WAF should take on a web request when it matches a rule's statement. Settings at the web ACL level can override the rule action setting. </p>
        pub fn action(mut self, input: crate::model::RuleAction) -> Self {
            self.action = Some(input);
            self
        }
        /// <p>The action that WAF should take on a web request when it matches a rule's statement. Settings at the web ACL level can override the rule action setting. </p>
        pub fn set_action(mut self, input: std::option::Option<crate::model::RuleAction>) -> Self {
            self.action = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleSummary`](crate::model::RuleSummary)
        pub fn build(self) -> crate::model::RuleSummary {
            crate::model::RuleSummary {
                name: self.name,
                action: self.action,
            }
        }
    }
}
impl RuleSummary {
    /// Creates a new builder-style object to manufacture [`RuleSummary`](crate::model::RuleSummary)
    pub fn builder() -> crate::model::rule_summary::Builder {
        crate::model::rule_summary::Builder::default()
    }
}
