// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn create_cluster(&self) -> fluent_builders::CreateCluster<C> {
        fluent_builders::CreateCluster::new(self.handle.clone())
    }
    pub fn create_parameter_group(&self) -> fluent_builders::CreateParameterGroup<C> {
        fluent_builders::CreateParameterGroup::new(self.handle.clone())
    }
    pub fn create_subnet_group(&self) -> fluent_builders::CreateSubnetGroup<C> {
        fluent_builders::CreateSubnetGroup::new(self.handle.clone())
    }
    pub fn decrease_replication_factor(&self) -> fluent_builders::DecreaseReplicationFactor<C> {
        fluent_builders::DecreaseReplicationFactor::new(self.handle.clone())
    }
    pub fn delete_cluster(&self) -> fluent_builders::DeleteCluster<C> {
        fluent_builders::DeleteCluster::new(self.handle.clone())
    }
    pub fn delete_parameter_group(&self) -> fluent_builders::DeleteParameterGroup<C> {
        fluent_builders::DeleteParameterGroup::new(self.handle.clone())
    }
    pub fn delete_subnet_group(&self) -> fluent_builders::DeleteSubnetGroup<C> {
        fluent_builders::DeleteSubnetGroup::new(self.handle.clone())
    }
    pub fn describe_clusters(&self) -> fluent_builders::DescribeClusters<C> {
        fluent_builders::DescribeClusters::new(self.handle.clone())
    }
    pub fn describe_default_parameters(&self) -> fluent_builders::DescribeDefaultParameters<C> {
        fluent_builders::DescribeDefaultParameters::new(self.handle.clone())
    }
    pub fn describe_events(&self) -> fluent_builders::DescribeEvents<C> {
        fluent_builders::DescribeEvents::new(self.handle.clone())
    }
    pub fn describe_parameter_groups(&self) -> fluent_builders::DescribeParameterGroups<C> {
        fluent_builders::DescribeParameterGroups::new(self.handle.clone())
    }
    pub fn describe_parameters(&self) -> fluent_builders::DescribeParameters<C> {
        fluent_builders::DescribeParameters::new(self.handle.clone())
    }
    pub fn describe_subnet_groups(&self) -> fluent_builders::DescribeSubnetGroups<C> {
        fluent_builders::DescribeSubnetGroups::new(self.handle.clone())
    }
    pub fn increase_replication_factor(&self) -> fluent_builders::IncreaseReplicationFactor<C> {
        fluent_builders::IncreaseReplicationFactor::new(self.handle.clone())
    }
    pub fn list_tags(&self) -> fluent_builders::ListTags<C> {
        fluent_builders::ListTags::new(self.handle.clone())
    }
    pub fn reboot_node(&self) -> fluent_builders::RebootNode<C> {
        fluent_builders::RebootNode::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_cluster(&self) -> fluent_builders::UpdateCluster<C> {
        fluent_builders::UpdateCluster::new(self.handle.clone())
    }
    pub fn update_parameter_group(&self) -> fluent_builders::UpdateParameterGroup<C> {
        fluent_builders::UpdateParameterGroup::new(self.handle.clone())
    }
    pub fn update_subnet_group(&self) -> fluent_builders::UpdateSubnetGroup<C> {
        fluent_builders::UpdateSubnetGroup::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CreateCluster<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_cluster_input::Builder,
    }
    impl<C> CreateCluster<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateClusterOutput,
            smithy_http::result::SdkError<crate::error::CreateClusterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The cluster identifier. This parameter is stored as a lowercase
        /// string.</p>
        /// <p>
        /// <b>Constraints:</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>A name must contain from 1 to 20 alphanumeric characters or
        /// hyphens.</p>
        /// </li>
        /// <li>
        /// <p>The first character must be a letter.</p>
        /// </li>
        /// <li>
        /// <p>A name cannot end with a hyphen or contain two consecutive
        /// hyphens.</p>
        /// </li>
        /// </ul>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>The compute and memory capacity of the nodes in the cluster.</p>
        pub fn node_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.node_type(input);
            self
        }
        pub fn set_node_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_node_type(input);
            self
        }
        /// <p>A description of the cluster.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The number of nodes in the DAX cluster. A replication factor of 1 will
        /// create a single-node cluster, without any read replicas. For additional fault tolerance,
        /// you can create a multiple node cluster with one or more read replicas. To do this, set
        /// <code>ReplicationFactor</code> to a number between 3 (one primary and two read replicas) and 10 (one primary and nine read replicas).
        /// <code>If the AvailabilityZones</code> parameter is provided, its length must equal the <code>ReplicationFactor</code>.</p>
        /// <note>
        /// <p>AWS recommends that you have at least two read replicas per cluster.</p>
        /// </note>
        pub fn replication_factor(mut self, input: i32) -> Self {
            self.inner = self.inner.replication_factor(input);
            self
        }
        pub fn set_replication_factor(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_replication_factor(input);
            self
        }
        /// <p>The Availability Zones (AZs) in which the cluster nodes will reside after the cluster
        /// has been created or updated. If provided, the length of this list must equal the <code>ReplicationFactor</code> parameter.
        /// If you omit this parameter, DAX will spread the nodes across Availability Zones for the highest availability.</p>
        pub fn availability_zones(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zones(inp);
            self
        }
        pub fn set_availability_zones(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_availability_zones(input);
            self
        }
        /// <p>The name of the subnet group to be used for the replication group.</p>
        /// <important>
        /// <p>DAX clusters can only run in an Amazon VPC environment. All of the subnets
        /// that you specify in a subnet group must exist in the same VPC.</p>
        /// </important>
        pub fn subnet_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_group_name(input);
            self
        }
        pub fn set_subnet_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_subnet_group_name(input);
            self
        }
        /// <p>A list of security group IDs to be assigned to each node in the DAX cluster. (Each of the
        /// security group ID is system-generated.)</p>
        /// <p>If this parameter is not specified, DAX assigns the default VPC security group to
        /// each node.</p>
        pub fn security_group_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_group_ids(inp);
            self
        }
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_security_group_ids(input);
            self
        }
        /// <p>Specifies the weekly time range during which maintenance on the DAX cluster is
        /// performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock
        /// UTC). The minimum maintenance window is a 60 minute period. Valid values for
        /// <code>ddd</code> are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>sun</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>mon</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tue</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>wed</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>thu</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>fri</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>sat</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>Example: <code>sun:05:00-sun:09:00</code>
        /// </p>
        /// <note>
        /// <p>If you don't specify a preferred maintenance window when you create or modify a
        /// cache cluster, DAX assigns a 60-minute maintenance window on a randomly selected day
        /// of the week.</p>
        /// </note>
        pub fn preferred_maintenance_window(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.preferred_maintenance_window(input);
            self
        }
        pub fn set_preferred_maintenance_window(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_preferred_maintenance_window(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic to which notifications will
        /// be sent.</p>
        /// <note>
        /// <p>The Amazon SNS topic owner must be same as the DAX cluster owner.</p>
        /// </note>
        pub fn notification_topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.notification_topic_arn(input);
            self
        }
        pub fn set_notification_topic_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_notification_topic_arn(input);
            self
        }
        /// <p>A valid Amazon Resource Name (ARN) that identifies an IAM role. At runtime, DAX
        /// will assume this role and use the role's permissions to access DynamoDB on your
        /// behalf.</p>
        pub fn iam_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.iam_role_arn(input);
            self
        }
        pub fn set_iam_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_iam_role_arn(input);
            self
        }
        /// <p>The parameter group to be associated with the DAX cluster.</p>
        pub fn parameter_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.parameter_group_name(input);
            self
        }
        pub fn set_parameter_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_parameter_group_name(input);
            self
        }
        /// <p>A set of tags to associate with the DAX cluster.  </p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>Represents the settings used to enable server-side encryption on the cluster.</p>
        pub fn sse_specification(mut self, input: crate::model::SseSpecification) -> Self {
            self.inner = self.inner.sse_specification(input);
            self
        }
        pub fn set_sse_specification(
            mut self,
            input: std::option::Option<crate::model::SseSpecification>,
        ) -> Self {
            self.inner = self.inner.set_sse_specification(input);
            self
        }
        /// <p>The type of encryption the cluster's endpoint should support. Values are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>NONE</code> for no encryption</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TLS</code> for Transport Layer Security</p>
        /// </li>
        /// </ul>
        pub fn cluster_endpoint_encryption_type(
            mut self,
            input: crate::model::ClusterEndpointEncryptionType,
        ) -> Self {
            self.inner = self.inner.cluster_endpoint_encryption_type(input);
            self
        }
        pub fn set_cluster_endpoint_encryption_type(
            mut self,
            input: std::option::Option<crate::model::ClusterEndpointEncryptionType>,
        ) -> Self {
            self.inner = self.inner.set_cluster_endpoint_encryption_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateParameterGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_parameter_group_input::Builder,
    }
    impl<C> CreateParameterGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateParameterGroupOutput,
            smithy_http::result::SdkError<crate::error::CreateParameterGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the parameter group to apply to all of the clusters in this replication
        /// group.</p>
        pub fn parameter_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.parameter_group_name(input);
            self
        }
        pub fn set_parameter_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_parameter_group_name(input);
            self
        }
        /// <p>A description of the parameter group.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateSubnetGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_subnet_group_input::Builder,
    }
    impl<C> CreateSubnetGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateSubnetGroupOutput,
            smithy_http::result::SdkError<crate::error::CreateSubnetGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A name for the subnet group. This value is stored as a lowercase string. </p>
        pub fn subnet_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_group_name(input);
            self
        }
        pub fn set_subnet_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_subnet_group_name(input);
            self
        }
        /// <p>A description for the subnet group</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>A list of VPC subnet IDs for the subnet group.</p>
        pub fn subnet_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_ids(inp);
            self
        }
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subnet_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DecreaseReplicationFactor<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::decrease_replication_factor_input::Builder,
    }
    impl<C> DecreaseReplicationFactor<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DecreaseReplicationFactorOutput,
            smithy_http::result::SdkError<crate::error::DecreaseReplicationFactorError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the DAX cluster from which you want to remove nodes.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>The new number of nodes for the DAX cluster.</p>
        pub fn new_replication_factor(mut self, input: i32) -> Self {
            self.inner = self.inner.new_replication_factor(input);
            self
        }
        pub fn set_new_replication_factor(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_new_replication_factor(input);
            self
        }
        /// <p>The Availability Zone(s) from which to remove nodes.</p>
        pub fn availability_zones(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zones(inp);
            self
        }
        pub fn set_availability_zones(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_availability_zones(input);
            self
        }
        /// <p>The unique identifiers of the nodes to be removed from the cluster.</p>
        pub fn node_ids_to_remove(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.node_ids_to_remove(inp);
            self
        }
        pub fn set_node_ids_to_remove(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_node_ids_to_remove(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCluster<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_cluster_input::Builder,
    }
    impl<C> DeleteCluster<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteClusterOutput,
            smithy_http::result::SdkError<crate::error::DeleteClusterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the cluster to be deleted.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteParameterGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_parameter_group_input::Builder,
    }
    impl<C> DeleteParameterGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteParameterGroupOutput,
            smithy_http::result::SdkError<crate::error::DeleteParameterGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the parameter group to delete.</p>
        pub fn parameter_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.parameter_group_name(input);
            self
        }
        pub fn set_parameter_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_parameter_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteSubnetGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_subnet_group_input::Builder,
    }
    impl<C> DeleteSubnetGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteSubnetGroupOutput,
            smithy_http::result::SdkError<crate::error::DeleteSubnetGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the subnet group to delete.</p>
        pub fn subnet_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_group_name(input);
            self
        }
        pub fn set_subnet_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_subnet_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeClusters<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_clusters_input::Builder,
    }
    impl<C> DescribeClusters<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeClustersOutput,
            smithy_http::result::SdkError<crate::error::DescribeClustersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The names of the DAX clusters being described.</p>
        pub fn cluster_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_names(inp);
            self
        }
        pub fn set_cluster_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_cluster_names(input);
            self
        }
        /// <p>The maximum number of results to include in the response. If more results exist
        /// than the specified <code>MaxResults</code> value, a token is included in the response so
        /// that the remaining results can be retrieved.</p>
        /// <p>The value for <code>MaxResults</code> must be between 20 and 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>An optional token returned from a prior request. Use this token for pagination of
        /// results from this action. If this parameter is specified, the response includes only
        /// results beyond the token, up to the value specified by
        /// <code>MaxResults</code>.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeDefaultParameters<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_default_parameters_input::Builder,
    }
    impl<C> DescribeDefaultParameters<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeDefaultParametersOutput,
            smithy_http::result::SdkError<crate::error::DescribeDefaultParametersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results to include in the response. If more results exist
        /// than the specified <code>MaxResults</code> value, a token is included in the response so
        /// that the remaining results can be retrieved.</p>
        /// <p>The value for <code>MaxResults</code> must be between 20 and 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>An optional token returned from a prior request. Use this token for pagination of
        /// results from this action. If this parameter is specified, the response includes only
        /// results beyond the token, up to the value specified by
        /// <code>MaxResults</code>.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeEvents<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_events_input::Builder,
    }
    impl<C> DescribeEvents<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeEventsOutput,
            smithy_http::result::SdkError<crate::error::DescribeEventsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the event source for which events will be returned. If not
        /// specified, then all sources are included in the response.</p>
        pub fn source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_name(input);
            self
        }
        pub fn set_source_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_source_name(input);
            self
        }
        /// <p>The event source to retrieve events for. If no value is specified, all events are
        /// returned.</p>
        pub fn source_type(mut self, input: crate::model::SourceType) -> Self {
            self.inner = self.inner.source_type(input);
            self
        }
        pub fn set_source_type(
            mut self,
            input: std::option::Option<crate::model::SourceType>,
        ) -> Self {
            self.inner = self.inner.set_source_type(input);
            self
        }
        /// <p>The beginning of the time interval to retrieve events for, specified in ISO 8601
        /// format.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The end of the time interval for which to retrieve events, specified in ISO 8601
        /// format.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>The number of minutes' worth of events to retrieve.</p>
        pub fn duration(mut self, input: i32) -> Self {
            self.inner = self.inner.duration(input);
            self
        }
        pub fn set_duration(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_duration(input);
            self
        }
        /// <p>The maximum number of results to include in the response. If more results exist
        /// than the specified <code>MaxResults</code> value, a token is included in the response so
        /// that the remaining results can be retrieved.</p>
        /// <p>The value for <code>MaxResults</code> must be between 20 and 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>An optional token returned from a prior request. Use this token for pagination of
        /// results from this action. If this parameter is specified, the response includes only
        /// results beyond the token, up to the value specified by
        /// <code>MaxResults</code>.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeParameterGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_parameter_groups_input::Builder,
    }
    impl<C> DescribeParameterGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeParameterGroupsOutput,
            smithy_http::result::SdkError<crate::error::DescribeParameterGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The names of the parameter groups.</p>
        pub fn parameter_group_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.parameter_group_names(inp);
            self
        }
        pub fn set_parameter_group_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_parameter_group_names(input);
            self
        }
        /// <p>The maximum number of results to include in the response. If more results exist
        /// than the specified <code>MaxResults</code> value, a token is included in the response so
        /// that the remaining results can be retrieved.</p>
        /// <p>The value for <code>MaxResults</code> must be between 20 and 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>An optional token returned from a prior request. Use this token for pagination of
        /// results from this action. If this parameter is specified, the response includes only
        /// results beyond the token, up to the value specified by
        /// <code>MaxResults</code>.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeParameters<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_parameters_input::Builder,
    }
    impl<C> DescribeParameters<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeParametersOutput,
            smithy_http::result::SdkError<crate::error::DescribeParametersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the parameter group.</p>
        pub fn parameter_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.parameter_group_name(input);
            self
        }
        pub fn set_parameter_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_parameter_group_name(input);
            self
        }
        /// <p>How the parameter is defined. For example, <code>system</code> denotes a
        /// system-defined parameter.</p>
        pub fn source(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source(input);
            self
        }
        pub fn set_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_source(input);
            self
        }
        /// <p>The maximum number of results to include in the response. If more results exist
        /// than the specified <code>MaxResults</code> value, a token is included in the response so
        /// that the remaining results can be retrieved.</p>
        /// <p>The value for <code>MaxResults</code> must be between 20 and 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>An optional token returned from a prior request. Use this token for pagination of
        /// results from this action. If this parameter is specified, the response includes only
        /// results beyond the token, up to the value specified by
        /// <code>MaxResults</code>.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSubnetGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_subnet_groups_input::Builder,
    }
    impl<C> DescribeSubnetGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSubnetGroupsOutput,
            smithy_http::result::SdkError<crate::error::DescribeSubnetGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the subnet group.</p>
        pub fn subnet_group_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_group_names(inp);
            self
        }
        pub fn set_subnet_group_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subnet_group_names(input);
            self
        }
        /// <p>The maximum number of results to include in the response. If more results exist
        /// than the specified <code>MaxResults</code> value, a token is included in the response so
        /// that the remaining results can be retrieved.</p>
        /// <p>The value for <code>MaxResults</code> must be between 20 and 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>An optional token returned from a prior request. Use this token for pagination of
        /// results from this action. If this parameter is specified, the response includes only
        /// results beyond the token, up to the value specified by
        /// <code>MaxResults</code>.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct IncreaseReplicationFactor<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::increase_replication_factor_input::Builder,
    }
    impl<C> IncreaseReplicationFactor<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::IncreaseReplicationFactorOutput,
            smithy_http::result::SdkError<crate::error::IncreaseReplicationFactorError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the DAX cluster that will receive additional nodes.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>The new number of nodes for the DAX cluster.</p>
        pub fn new_replication_factor(mut self, input: i32) -> Self {
            self.inner = self.inner.new_replication_factor(input);
            self
        }
        pub fn set_new_replication_factor(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_new_replication_factor(input);
            self
        }
        /// <p>The Availability Zones (AZs) in which the cluster nodes will be created. All nodes
        /// belonging to the cluster are placed in these Availability Zones. Use this parameter if you want
        /// to distribute the nodes across multiple AZs.</p>
        pub fn availability_zones(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zones(inp);
            self
        }
        pub fn set_availability_zones(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_availability_zones(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_input::Builder,
    }
    impl<C> ListTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsOutput,
            smithy_http::result::SdkError<crate::error::ListTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the DAX resource to which the tags belong.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_name(input);
            self
        }
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resource_name(input);
            self
        }
        /// <p>An optional token returned from a prior request. Use this token for pagination of
        /// results from this action. If this parameter is specified, the response includes only
        /// results beyond the token.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RebootNode<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reboot_node_input::Builder,
    }
    impl<C> RebootNode<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RebootNodeOutput,
            smithy_http::result::SdkError<crate::error::RebootNodeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the DAX cluster containing the node to be rebooted.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>The system-assigned ID of the node to be rebooted.</p>
        pub fn node_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.node_id(input);
            self
        }
        pub fn set_node_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_node_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the DAX resource to which tags should be added.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_name(input);
            self
        }
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resource_name(input);
            self
        }
        /// <p>The tags to be assigned to the DAX resource. </p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the DAX resource from which the tags should be removed.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_name(input);
            self
        }
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resource_name(input);
            self
        }
        /// <p>A list of tag keys. If the DAX cluster has any tags with these keys, then the tags are removed from the cluster.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateCluster<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_cluster_input::Builder,
    }
    impl<C> UpdateCluster<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateClusterOutput,
            smithy_http::result::SdkError<crate::error::UpdateClusterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the DAX cluster to be modified.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>A description of the changes being made to the cluster.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>A range of time when maintenance of DAX cluster software will be performed. For
        /// example: <code>sun:01:00-sun:09:00</code>. Cluster maintenance normally takes less than
        /// 30 minutes, and is performed automatically within the maintenance window.</p>
        pub fn preferred_maintenance_window(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.preferred_maintenance_window(input);
            self
        }
        pub fn set_preferred_maintenance_window(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_preferred_maintenance_window(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) that identifies the topic.</p>
        pub fn notification_topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.notification_topic_arn(input);
            self
        }
        pub fn set_notification_topic_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_notification_topic_arn(input);
            self
        }
        /// <p>The current state of the topic. A value of active means that notifications will
        /// be sent to the topic. A value of inactive means that notifications will not be sent to the
        /// topic.</p>
        pub fn notification_topic_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.notification_topic_status(input);
            self
        }
        pub fn set_notification_topic_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_notification_topic_status(input);
            self
        }
        /// <p>The name of a parameter group for this cluster.</p>
        pub fn parameter_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.parameter_group_name(input);
            self
        }
        pub fn set_parameter_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_parameter_group_name(input);
            self
        }
        /// <p>A list of user-specified security group IDs to be assigned to each node in the DAX cluster.  If this parameter is not
        /// specified, DAX assigns the default VPC security group to each node.</p>
        pub fn security_group_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_group_ids(inp);
            self
        }
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_security_group_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateParameterGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_parameter_group_input::Builder,
    }
    impl<C> UpdateParameterGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateParameterGroupOutput,
            smithy_http::result::SdkError<crate::error::UpdateParameterGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the parameter group.</p>
        pub fn parameter_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.parameter_group_name(input);
            self
        }
        pub fn set_parameter_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_parameter_group_name(input);
            self
        }
        /// <p>An array of name-value pairs for the parameters in the group. Each element in the
        /// array represents a single parameter.</p>
        /// <note>
        /// <p>
        /// <code>record-ttl-millis</code> and <code>query-ttl-millis</code> are the only supported parameter names. For more details, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DAX.cluster-management.html#DAX.cluster-management.custom-settings.ttl">Configuring TTL Settings</a>.</p>
        /// </note>
        pub fn parameter_name_values(
            mut self,
            inp: impl Into<crate::model::ParameterNameValue>,
        ) -> Self {
            self.inner = self.inner.parameter_name_values(inp);
            self
        }
        pub fn set_parameter_name_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ParameterNameValue>>,
        ) -> Self {
            self.inner = self.inner.set_parameter_name_values(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateSubnetGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_subnet_group_input::Builder,
    }
    impl<C> UpdateSubnetGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateSubnetGroupOutput,
            smithy_http::result::SdkError<crate::error::UpdateSubnetGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the subnet group.</p>
        pub fn subnet_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_group_name(input);
            self
        }
        pub fn set_subnet_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_subnet_group_name(input);
            self
        }
        /// <p>A description of the subnet group.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>A list of subnet IDs in the subnet group.</p>
        pub fn subnet_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_ids(inp);
            self
        }
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subnet_ids(input);
            self
        }
    }
}
