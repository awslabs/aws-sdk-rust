// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Contains all of the attributes of a specific DAX cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Cluster {
    /// <p>The name of the DAX cluster.</p>
    #[doc(hidden)]
    pub cluster_name: std::option::Option<std::string::String>,
    /// <p>The description of the cluster.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster. </p>
    #[doc(hidden)]
    pub cluster_arn: std::option::Option<std::string::String>,
    /// <p>The total number of nodes in the cluster.</p>
    #[doc(hidden)]
    pub total_nodes: std::option::Option<i32>,
    /// <p>The number of nodes in the cluster that are active (i.e., capable of serving requests).</p>
    #[doc(hidden)]
    pub active_nodes: std::option::Option<i32>,
    /// <p>The node type for the nodes in the cluster. (All nodes in a DAX cluster are of the same type.)</p>
    #[doc(hidden)]
    pub node_type: std::option::Option<std::string::String>,
    /// <p>The current status of the cluster.</p>
    #[doc(hidden)]
    pub status: std::option::Option<std::string::String>,
    /// <p>The endpoint for this DAX cluster, consisting of a DNS name, a port number, and a URL. Applications should use the URL to configure the DAX client to find their cluster.</p>
    #[doc(hidden)]
    pub cluster_discovery_endpoint: std::option::Option<crate::types::Endpoint>,
    /// <p>A list of nodes to be removed from the cluster.</p>
    #[doc(hidden)]
    pub node_ids_to_remove: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of nodes that are currently in the cluster.</p>
    #[doc(hidden)]
    pub nodes: std::option::Option<std::vec::Vec<crate::types::Node>>,
    /// <p>A range of time when maintenance of DAX cluster software will be performed. For example: <code>sun:01:00-sun:09:00</code>. Cluster maintenance normally takes less than 30 minutes, and is performed automatically within the maintenance window.</p>
    #[doc(hidden)]
    pub preferred_maintenance_window: std::option::Option<std::string::String>,
    /// <p>Describes a notification topic and its status. Notification topics are used for publishing DAX events to subscribers using Amazon Simple Notification Service (SNS).</p>
    #[doc(hidden)]
    pub notification_configuration: std::option::Option<crate::types::NotificationConfiguration>,
    /// <p>The subnet group where the DAX cluster is running.</p>
    #[doc(hidden)]
    pub subnet_group: std::option::Option<std::string::String>,
    /// <p>A list of security groups, and the status of each, for the nodes in the cluster.</p>
    #[doc(hidden)]
    pub security_groups: std::option::Option<std::vec::Vec<crate::types::SecurityGroupMembership>>,
    /// <p>A valid Amazon Resource Name (ARN) that identifies an IAM role. At runtime, DAX will assume this role and use the role's permissions to access DynamoDB on your behalf.</p>
    #[doc(hidden)]
    pub iam_role_arn: std::option::Option<std::string::String>,
    /// <p>The parameter group being used by nodes in the cluster.</p>
    #[doc(hidden)]
    pub parameter_group: std::option::Option<crate::types::ParameterGroupStatus>,
    /// <p>The description of the server-side encryption status on the specified DAX cluster.</p>
    #[doc(hidden)]
    pub sse_description: std::option::Option<crate::types::SseDescription>,
    /// <p>The type of encryption supported by the cluster's endpoint. Values are:</p>
    /// <ul>
    /// <li> <p> <code>NONE</code> for no encryption</p> <p> <code>TLS</code> for Transport Layer Security</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub cluster_endpoint_encryption_type:
        std::option::Option<crate::types::ClusterEndpointEncryptionType>,
}
impl Cluster {
    /// <p>The name of the DAX cluster.</p>
    pub fn cluster_name(&self) -> std::option::Option<&str> {
        self.cluster_name.as_deref()
    }
    /// <p>The description of the cluster.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster. </p>
    pub fn cluster_arn(&self) -> std::option::Option<&str> {
        self.cluster_arn.as_deref()
    }
    /// <p>The total number of nodes in the cluster.</p>
    pub fn total_nodes(&self) -> std::option::Option<i32> {
        self.total_nodes
    }
    /// <p>The number of nodes in the cluster that are active (i.e., capable of serving requests).</p>
    pub fn active_nodes(&self) -> std::option::Option<i32> {
        self.active_nodes
    }
    /// <p>The node type for the nodes in the cluster. (All nodes in a DAX cluster are of the same type.)</p>
    pub fn node_type(&self) -> std::option::Option<&str> {
        self.node_type.as_deref()
    }
    /// <p>The current status of the cluster.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>The endpoint for this DAX cluster, consisting of a DNS name, a port number, and a URL. Applications should use the URL to configure the DAX client to find their cluster.</p>
    pub fn cluster_discovery_endpoint(&self) -> std::option::Option<&crate::types::Endpoint> {
        self.cluster_discovery_endpoint.as_ref()
    }
    /// <p>A list of nodes to be removed from the cluster.</p>
    pub fn node_ids_to_remove(&self) -> std::option::Option<&[std::string::String]> {
        self.node_ids_to_remove.as_deref()
    }
    /// <p>A list of nodes that are currently in the cluster.</p>
    pub fn nodes(&self) -> std::option::Option<&[crate::types::Node]> {
        self.nodes.as_deref()
    }
    /// <p>A range of time when maintenance of DAX cluster software will be performed. For example: <code>sun:01:00-sun:09:00</code>. Cluster maintenance normally takes less than 30 minutes, and is performed automatically within the maintenance window.</p>
    pub fn preferred_maintenance_window(&self) -> std::option::Option<&str> {
        self.preferred_maintenance_window.as_deref()
    }
    /// <p>Describes a notification topic and its status. Notification topics are used for publishing DAX events to subscribers using Amazon Simple Notification Service (SNS).</p>
    pub fn notification_configuration(
        &self,
    ) -> std::option::Option<&crate::types::NotificationConfiguration> {
        self.notification_configuration.as_ref()
    }
    /// <p>The subnet group where the DAX cluster is running.</p>
    pub fn subnet_group(&self) -> std::option::Option<&str> {
        self.subnet_group.as_deref()
    }
    /// <p>A list of security groups, and the status of each, for the nodes in the cluster.</p>
    pub fn security_groups(&self) -> std::option::Option<&[crate::types::SecurityGroupMembership]> {
        self.security_groups.as_deref()
    }
    /// <p>A valid Amazon Resource Name (ARN) that identifies an IAM role. At runtime, DAX will assume this role and use the role's permissions to access DynamoDB on your behalf.</p>
    pub fn iam_role_arn(&self) -> std::option::Option<&str> {
        self.iam_role_arn.as_deref()
    }
    /// <p>The parameter group being used by nodes in the cluster.</p>
    pub fn parameter_group(&self) -> std::option::Option<&crate::types::ParameterGroupStatus> {
        self.parameter_group.as_ref()
    }
    /// <p>The description of the server-side encryption status on the specified DAX cluster.</p>
    pub fn sse_description(&self) -> std::option::Option<&crate::types::SseDescription> {
        self.sse_description.as_ref()
    }
    /// <p>The type of encryption supported by the cluster's endpoint. Values are:</p>
    /// <ul>
    /// <li> <p> <code>NONE</code> for no encryption</p> <p> <code>TLS</code> for Transport Layer Security</p> </li>
    /// </ul>
    pub fn cluster_endpoint_encryption_type(
        &self,
    ) -> std::option::Option<&crate::types::ClusterEndpointEncryptionType> {
        self.cluster_endpoint_encryption_type.as_ref()
    }
}
impl Cluster {
    /// Creates a new builder-style object to manufacture [`Cluster`](crate::types::Cluster).
    pub fn builder() -> crate::types::builders::ClusterBuilder {
        crate::types::builders::ClusterBuilder::default()
    }
}

/// A builder for [`Cluster`](crate::types::Cluster).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct ClusterBuilder {
    pub(crate) cluster_name: std::option::Option<std::string::String>,
    pub(crate) description: std::option::Option<std::string::String>,
    pub(crate) cluster_arn: std::option::Option<std::string::String>,
    pub(crate) total_nodes: std::option::Option<i32>,
    pub(crate) active_nodes: std::option::Option<i32>,
    pub(crate) node_type: std::option::Option<std::string::String>,
    pub(crate) status: std::option::Option<std::string::String>,
    pub(crate) cluster_discovery_endpoint: std::option::Option<crate::types::Endpoint>,
    pub(crate) node_ids_to_remove: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) nodes: std::option::Option<std::vec::Vec<crate::types::Node>>,
    pub(crate) preferred_maintenance_window: std::option::Option<std::string::String>,
    pub(crate) notification_configuration:
        std::option::Option<crate::types::NotificationConfiguration>,
    pub(crate) subnet_group: std::option::Option<std::string::String>,
    pub(crate) security_groups:
        std::option::Option<std::vec::Vec<crate::types::SecurityGroupMembership>>,
    pub(crate) iam_role_arn: std::option::Option<std::string::String>,
    pub(crate) parameter_group: std::option::Option<crate::types::ParameterGroupStatus>,
    pub(crate) sse_description: std::option::Option<crate::types::SseDescription>,
    pub(crate) cluster_endpoint_encryption_type:
        std::option::Option<crate::types::ClusterEndpointEncryptionType>,
}
impl ClusterBuilder {
    /// <p>The name of the DAX cluster.</p>
    pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.cluster_name = Some(input.into());
        self
    }
    /// <p>The name of the DAX cluster.</p>
    pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.cluster_name = input;
        self
    }
    /// <p>The description of the cluster.</p>
    pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
        self.description = Some(input.into());
        self
    }
    /// <p>The description of the cluster.</p>
    pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster. </p>
    pub fn cluster_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.cluster_arn = Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster. </p>
    pub fn set_cluster_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.cluster_arn = input;
        self
    }
    /// <p>The total number of nodes in the cluster.</p>
    pub fn total_nodes(mut self, input: i32) -> Self {
        self.total_nodes = Some(input);
        self
    }
    /// <p>The total number of nodes in the cluster.</p>
    pub fn set_total_nodes(mut self, input: std::option::Option<i32>) -> Self {
        self.total_nodes = input;
        self
    }
    /// <p>The number of nodes in the cluster that are active (i.e., capable of serving requests).</p>
    pub fn active_nodes(mut self, input: i32) -> Self {
        self.active_nodes = Some(input);
        self
    }
    /// <p>The number of nodes in the cluster that are active (i.e., capable of serving requests).</p>
    pub fn set_active_nodes(mut self, input: std::option::Option<i32>) -> Self {
        self.active_nodes = input;
        self
    }
    /// <p>The node type for the nodes in the cluster. (All nodes in a DAX cluster are of the same type.)</p>
    pub fn node_type(mut self, input: impl Into<std::string::String>) -> Self {
        self.node_type = Some(input.into());
        self
    }
    /// <p>The node type for the nodes in the cluster. (All nodes in a DAX cluster are of the same type.)</p>
    pub fn set_node_type(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.node_type = input;
        self
    }
    /// <p>The current status of the cluster.</p>
    pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
        self.status = Some(input.into());
        self
    }
    /// <p>The current status of the cluster.</p>
    pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.status = input;
        self
    }
    /// <p>The endpoint for this DAX cluster, consisting of a DNS name, a port number, and a URL. Applications should use the URL to configure the DAX client to find their cluster.</p>
    pub fn cluster_discovery_endpoint(mut self, input: crate::types::Endpoint) -> Self {
        self.cluster_discovery_endpoint = Some(input);
        self
    }
    /// <p>The endpoint for this DAX cluster, consisting of a DNS name, a port number, and a URL. Applications should use the URL to configure the DAX client to find their cluster.</p>
    pub fn set_cluster_discovery_endpoint(
        mut self,
        input: std::option::Option<crate::types::Endpoint>,
    ) -> Self {
        self.cluster_discovery_endpoint = input;
        self
    }
    /// Appends an item to `node_ids_to_remove`.
    ///
    /// To override the contents of this collection use [`set_node_ids_to_remove`](Self::set_node_ids_to_remove).
    ///
    /// <p>A list of nodes to be removed from the cluster.</p>
    pub fn node_ids_to_remove(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.node_ids_to_remove.unwrap_or_default();
        v.push(input.into());
        self.node_ids_to_remove = Some(v);
        self
    }
    /// <p>A list of nodes to be removed from the cluster.</p>
    pub fn set_node_ids_to_remove(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.node_ids_to_remove = input;
        self
    }
    /// Appends an item to `nodes`.
    ///
    /// To override the contents of this collection use [`set_nodes`](Self::set_nodes).
    ///
    /// <p>A list of nodes that are currently in the cluster.</p>
    pub fn nodes(mut self, input: crate::types::Node) -> Self {
        let mut v = self.nodes.unwrap_or_default();
        v.push(input);
        self.nodes = Some(v);
        self
    }
    /// <p>A list of nodes that are currently in the cluster.</p>
    pub fn set_nodes(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::Node>>,
    ) -> Self {
        self.nodes = input;
        self
    }
    /// <p>A range of time when maintenance of DAX cluster software will be performed. For example: <code>sun:01:00-sun:09:00</code>. Cluster maintenance normally takes less than 30 minutes, and is performed automatically within the maintenance window.</p>
    pub fn preferred_maintenance_window(mut self, input: impl Into<std::string::String>) -> Self {
        self.preferred_maintenance_window = Some(input.into());
        self
    }
    /// <p>A range of time when maintenance of DAX cluster software will be performed. For example: <code>sun:01:00-sun:09:00</code>. Cluster maintenance normally takes less than 30 minutes, and is performed automatically within the maintenance window.</p>
    pub fn set_preferred_maintenance_window(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.preferred_maintenance_window = input;
        self
    }
    /// <p>Describes a notification topic and its status. Notification topics are used for publishing DAX events to subscribers using Amazon Simple Notification Service (SNS).</p>
    pub fn notification_configuration(
        mut self,
        input: crate::types::NotificationConfiguration,
    ) -> Self {
        self.notification_configuration = Some(input);
        self
    }
    /// <p>Describes a notification topic and its status. Notification topics are used for publishing DAX events to subscribers using Amazon Simple Notification Service (SNS).</p>
    pub fn set_notification_configuration(
        mut self,
        input: std::option::Option<crate::types::NotificationConfiguration>,
    ) -> Self {
        self.notification_configuration = input;
        self
    }
    /// <p>The subnet group where the DAX cluster is running.</p>
    pub fn subnet_group(mut self, input: impl Into<std::string::String>) -> Self {
        self.subnet_group = Some(input.into());
        self
    }
    /// <p>The subnet group where the DAX cluster is running.</p>
    pub fn set_subnet_group(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.subnet_group = input;
        self
    }
    /// Appends an item to `security_groups`.
    ///
    /// To override the contents of this collection use [`set_security_groups`](Self::set_security_groups).
    ///
    /// <p>A list of security groups, and the status of each, for the nodes in the cluster.</p>
    pub fn security_groups(mut self, input: crate::types::SecurityGroupMembership) -> Self {
        let mut v = self.security_groups.unwrap_or_default();
        v.push(input);
        self.security_groups = Some(v);
        self
    }
    /// <p>A list of security groups, and the status of each, for the nodes in the cluster.</p>
    pub fn set_security_groups(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::SecurityGroupMembership>>,
    ) -> Self {
        self.security_groups = input;
        self
    }
    /// <p>A valid Amazon Resource Name (ARN) that identifies an IAM role. At runtime, DAX will assume this role and use the role's permissions to access DynamoDB on your behalf.</p>
    pub fn iam_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.iam_role_arn = Some(input.into());
        self
    }
    /// <p>A valid Amazon Resource Name (ARN) that identifies an IAM role. At runtime, DAX will assume this role and use the role's permissions to access DynamoDB on your behalf.</p>
    pub fn set_iam_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.iam_role_arn = input;
        self
    }
    /// <p>The parameter group being used by nodes in the cluster.</p>
    pub fn parameter_group(mut self, input: crate::types::ParameterGroupStatus) -> Self {
        self.parameter_group = Some(input);
        self
    }
    /// <p>The parameter group being used by nodes in the cluster.</p>
    pub fn set_parameter_group(
        mut self,
        input: std::option::Option<crate::types::ParameterGroupStatus>,
    ) -> Self {
        self.parameter_group = input;
        self
    }
    /// <p>The description of the server-side encryption status on the specified DAX cluster.</p>
    pub fn sse_description(mut self, input: crate::types::SseDescription) -> Self {
        self.sse_description = Some(input);
        self
    }
    /// <p>The description of the server-side encryption status on the specified DAX cluster.</p>
    pub fn set_sse_description(
        mut self,
        input: std::option::Option<crate::types::SseDescription>,
    ) -> Self {
        self.sse_description = input;
        self
    }
    /// <p>The type of encryption supported by the cluster's endpoint. Values are:</p>
    /// <ul>
    /// <li> <p> <code>NONE</code> for no encryption</p> <p> <code>TLS</code> for Transport Layer Security</p> </li>
    /// </ul>
    pub fn cluster_endpoint_encryption_type(
        mut self,
        input: crate::types::ClusterEndpointEncryptionType,
    ) -> Self {
        self.cluster_endpoint_encryption_type = Some(input);
        self
    }
    /// <p>The type of encryption supported by the cluster's endpoint. Values are:</p>
    /// <ul>
    /// <li> <p> <code>NONE</code> for no encryption</p> <p> <code>TLS</code> for Transport Layer Security</p> </li>
    /// </ul>
    pub fn set_cluster_endpoint_encryption_type(
        mut self,
        input: std::option::Option<crate::types::ClusterEndpointEncryptionType>,
    ) -> Self {
        self.cluster_endpoint_encryption_type = input;
        self
    }
    /// Consumes the builder and constructs a [`Cluster`](crate::types::Cluster).
    pub fn build(self) -> crate::types::Cluster {
        crate::types::Cluster {
            cluster_name: self.cluster_name,
            description: self.description,
            cluster_arn: self.cluster_arn,
            total_nodes: self.total_nodes,
            active_nodes: self.active_nodes,
            node_type: self.node_type,
            status: self.status,
            cluster_discovery_endpoint: self.cluster_discovery_endpoint,
            node_ids_to_remove: self.node_ids_to_remove,
            nodes: self.nodes,
            preferred_maintenance_window: self.preferred_maintenance_window,
            notification_configuration: self.notification_configuration,
            subnet_group: self.subnet_group,
            security_groups: self.security_groups,
            iam_role_arn: self.iam_role_arn,
            parameter_group: self.parameter_group,
            sse_description: self.sse_description,
            cluster_endpoint_encryption_type: self.cluster_endpoint_encryption_type,
        }
    }
}
