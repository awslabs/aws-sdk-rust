// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn add_flow_media_streams(&self) -> fluent_builders::AddFlowMediaStreams<C> {
        fluent_builders::AddFlowMediaStreams::new(self.handle.clone())
    }
    pub fn add_flow_outputs(&self) -> fluent_builders::AddFlowOutputs<C> {
        fluent_builders::AddFlowOutputs::new(self.handle.clone())
    }
    pub fn add_flow_sources(&self) -> fluent_builders::AddFlowSources<C> {
        fluent_builders::AddFlowSources::new(self.handle.clone())
    }
    pub fn add_flow_vpc_interfaces(&self) -> fluent_builders::AddFlowVpcInterfaces<C> {
        fluent_builders::AddFlowVpcInterfaces::new(self.handle.clone())
    }
    pub fn create_flow(&self) -> fluent_builders::CreateFlow<C> {
        fluent_builders::CreateFlow::new(self.handle.clone())
    }
    pub fn delete_flow(&self) -> fluent_builders::DeleteFlow<C> {
        fluent_builders::DeleteFlow::new(self.handle.clone())
    }
    pub fn describe_flow(&self) -> fluent_builders::DescribeFlow<C> {
        fluent_builders::DescribeFlow::new(self.handle.clone())
    }
    pub fn describe_offering(&self) -> fluent_builders::DescribeOffering<C> {
        fluent_builders::DescribeOffering::new(self.handle.clone())
    }
    pub fn describe_reservation(&self) -> fluent_builders::DescribeReservation<C> {
        fluent_builders::DescribeReservation::new(self.handle.clone())
    }
    pub fn grant_flow_entitlements(&self) -> fluent_builders::GrantFlowEntitlements<C> {
        fluent_builders::GrantFlowEntitlements::new(self.handle.clone())
    }
    pub fn list_entitlements(&self) -> fluent_builders::ListEntitlements<C> {
        fluent_builders::ListEntitlements::new(self.handle.clone())
    }
    pub fn list_flows(&self) -> fluent_builders::ListFlows<C> {
        fluent_builders::ListFlows::new(self.handle.clone())
    }
    pub fn list_offerings(&self) -> fluent_builders::ListOfferings<C> {
        fluent_builders::ListOfferings::new(self.handle.clone())
    }
    pub fn list_reservations(&self) -> fluent_builders::ListReservations<C> {
        fluent_builders::ListReservations::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn purchase_offering(&self) -> fluent_builders::PurchaseOffering<C> {
        fluent_builders::PurchaseOffering::new(self.handle.clone())
    }
    pub fn remove_flow_media_stream(&self) -> fluent_builders::RemoveFlowMediaStream<C> {
        fluent_builders::RemoveFlowMediaStream::new(self.handle.clone())
    }
    pub fn remove_flow_output(&self) -> fluent_builders::RemoveFlowOutput<C> {
        fluent_builders::RemoveFlowOutput::new(self.handle.clone())
    }
    pub fn remove_flow_source(&self) -> fluent_builders::RemoveFlowSource<C> {
        fluent_builders::RemoveFlowSource::new(self.handle.clone())
    }
    pub fn remove_flow_vpc_interface(&self) -> fluent_builders::RemoveFlowVpcInterface<C> {
        fluent_builders::RemoveFlowVpcInterface::new(self.handle.clone())
    }
    pub fn revoke_flow_entitlement(&self) -> fluent_builders::RevokeFlowEntitlement<C> {
        fluent_builders::RevokeFlowEntitlement::new(self.handle.clone())
    }
    pub fn start_flow(&self) -> fluent_builders::StartFlow<C> {
        fluent_builders::StartFlow::new(self.handle.clone())
    }
    pub fn stop_flow(&self) -> fluent_builders::StopFlow<C> {
        fluent_builders::StopFlow::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_flow(&self) -> fluent_builders::UpdateFlow<C> {
        fluent_builders::UpdateFlow::new(self.handle.clone())
    }
    pub fn update_flow_entitlement(&self) -> fluent_builders::UpdateFlowEntitlement<C> {
        fluent_builders::UpdateFlowEntitlement::new(self.handle.clone())
    }
    pub fn update_flow_media_stream(&self) -> fluent_builders::UpdateFlowMediaStream<C> {
        fluent_builders::UpdateFlowMediaStream::new(self.handle.clone())
    }
    pub fn update_flow_source(&self) -> fluent_builders::UpdateFlowSource<C> {
        fluent_builders::UpdateFlowSource::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AddFlowMediaStreams<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_flow_media_streams_input::Builder,
    }
    impl<C> AddFlowMediaStreams<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddFlowMediaStreamsOutput,
            smithy_http::result::SdkError<crate::error::AddFlowMediaStreamsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The Amazon Resource Name (ARN) of the flow.
        pub fn flow_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.flow_arn(input);
            self
        }
        pub fn set_flow_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_flow_arn(input);
            self
        }
        /// The media streams that you want to add to the flow.
        pub fn media_streams(
            mut self,
            inp: impl Into<crate::model::AddMediaStreamRequest>,
        ) -> Self {
            self.inner = self.inner.media_streams(inp);
            self
        }
        pub fn set_media_streams(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AddMediaStreamRequest>>,
        ) -> Self {
            self.inner = self.inner.set_media_streams(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AddFlowOutputs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_flow_outputs_input::Builder,
    }
    impl<C> AddFlowOutputs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddFlowOutputsOutput,
            smithy_http::result::SdkError<crate::error::AddFlowOutputsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The flow that you want to add outputs to.
        pub fn flow_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.flow_arn(input);
            self
        }
        pub fn set_flow_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_flow_arn(input);
            self
        }
        /// A list of outputs that you want to add.
        pub fn outputs(mut self, inp: impl Into<crate::model::AddOutputRequest>) -> Self {
            self.inner = self.inner.outputs(inp);
            self
        }
        pub fn set_outputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AddOutputRequest>>,
        ) -> Self {
            self.inner = self.inner.set_outputs(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AddFlowSources<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_flow_sources_input::Builder,
    }
    impl<C> AddFlowSources<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddFlowSourcesOutput,
            smithy_http::result::SdkError<crate::error::AddFlowSourcesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The flow that you want to mutate.
        pub fn flow_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.flow_arn(input);
            self
        }
        pub fn set_flow_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_flow_arn(input);
            self
        }
        /// A list of sources that you want to add.
        pub fn sources(mut self, inp: impl Into<crate::model::SetSourceRequest>) -> Self {
            self.inner = self.inner.sources(inp);
            self
        }
        pub fn set_sources(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SetSourceRequest>>,
        ) -> Self {
            self.inner = self.inner.set_sources(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AddFlowVpcInterfaces<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_flow_vpc_interfaces_input::Builder,
    }
    impl<C> AddFlowVpcInterfaces<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddFlowVpcInterfacesOutput,
            smithy_http::result::SdkError<crate::error::AddFlowVpcInterfacesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The flow that you want to mutate.
        pub fn flow_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.flow_arn(input);
            self
        }
        pub fn set_flow_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_flow_arn(input);
            self
        }
        /// A list of VPC interfaces that you want to add.
        pub fn vpc_interfaces(mut self, inp: impl Into<crate::model::VpcInterfaceRequest>) -> Self {
            self.inner = self.inner.vpc_interfaces(inp);
            self
        }
        pub fn set_vpc_interfaces(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VpcInterfaceRequest>>,
        ) -> Self {
            self.inner = self.inner.set_vpc_interfaces(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateFlow<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_flow_input::Builder,
    }
    impl<C> CreateFlow<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateFlowOutput,
            smithy_http::result::SdkError<crate::error::CreateFlowError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The Availability Zone that you want to create the flow in. These options are limited to the Availability Zones within the current AWS Region.
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zone(input);
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_availability_zone(input);
            self
        }
        /// The entitlements that you want to grant on a flow.
        pub fn entitlements(
            mut self,
            inp: impl Into<crate::model::GrantEntitlementRequest>,
        ) -> Self {
            self.inner = self.inner.entitlements(inp);
            self
        }
        pub fn set_entitlements(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GrantEntitlementRequest>>,
        ) -> Self {
            self.inner = self.inner.set_entitlements(input);
            self
        }
        /// The media streams that you want to add to the flow. You can associate these media streams with sources and outputs on the flow.
        pub fn media_streams(
            mut self,
            inp: impl Into<crate::model::AddMediaStreamRequest>,
        ) -> Self {
            self.inner = self.inner.media_streams(inp);
            self
        }
        pub fn set_media_streams(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AddMediaStreamRequest>>,
        ) -> Self {
            self.inner = self.inner.set_media_streams(input);
            self
        }
        /// The name of the flow.
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// The outputs that you want to add to this flow.
        pub fn outputs(mut self, inp: impl Into<crate::model::AddOutputRequest>) -> Self {
            self.inner = self.inner.outputs(inp);
            self
        }
        pub fn set_outputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AddOutputRequest>>,
        ) -> Self {
            self.inner = self.inner.set_outputs(input);
            self
        }
        /// The settings for the source of the flow.
        pub fn source(mut self, input: crate::model::SetSourceRequest) -> Self {
            self.inner = self.inner.source(input);
            self
        }
        pub fn set_source(
            mut self,
            input: std::option::Option<crate::model::SetSourceRequest>,
        ) -> Self {
            self.inner = self.inner.set_source(input);
            self
        }
        /// The settings for source failover
        pub fn source_failover_config(mut self, input: crate::model::FailoverConfig) -> Self {
            self.inner = self.inner.source_failover_config(input);
            self
        }
        pub fn set_source_failover_config(
            mut self,
            input: std::option::Option<crate::model::FailoverConfig>,
        ) -> Self {
            self.inner = self.inner.set_source_failover_config(input);
            self
        }
        pub fn sources(mut self, inp: impl Into<crate::model::SetSourceRequest>) -> Self {
            self.inner = self.inner.sources(inp);
            self
        }
        pub fn set_sources(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SetSourceRequest>>,
        ) -> Self {
            self.inner = self.inner.set_sources(input);
            self
        }
        /// The VPC interfaces you want on the flow.
        pub fn vpc_interfaces(mut self, inp: impl Into<crate::model::VpcInterfaceRequest>) -> Self {
            self.inner = self.inner.vpc_interfaces(inp);
            self
        }
        pub fn set_vpc_interfaces(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VpcInterfaceRequest>>,
        ) -> Self {
            self.inner = self.inner.set_vpc_interfaces(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFlow<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_flow_input::Builder,
    }
    impl<C> DeleteFlow<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFlowOutput,
            smithy_http::result::SdkError<crate::error::DeleteFlowError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The ARN of the flow that you want to delete.
        pub fn flow_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.flow_arn(input);
            self
        }
        pub fn set_flow_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_flow_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFlow<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_flow_input::Builder,
    }
    impl<C> DescribeFlow<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFlowOutput,
            smithy_http::result::SdkError<crate::error::DescribeFlowError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The ARN of the flow that you want to describe.
        pub fn flow_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.flow_arn(input);
            self
        }
        pub fn set_flow_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_flow_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeOffering<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_offering_input::Builder,
    }
    impl<C> DescribeOffering<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeOfferingOutput,
            smithy_http::result::SdkError<crate::error::DescribeOfferingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The Amazon Resource Name (ARN) of the offering.
        pub fn offering_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.offering_arn(input);
            self
        }
        pub fn set_offering_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_offering_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeReservation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_reservation_input::Builder,
    }
    impl<C> DescribeReservation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeReservationOutput,
            smithy_http::result::SdkError<crate::error::DescribeReservationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The Amazon Resource Name (ARN) of the reservation.
        pub fn reservation_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reservation_arn(input);
            self
        }
        pub fn set_reservation_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_reservation_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GrantFlowEntitlements<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::grant_flow_entitlements_input::Builder,
    }
    impl<C> GrantFlowEntitlements<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GrantFlowEntitlementsOutput,
            smithy_http::result::SdkError<crate::error::GrantFlowEntitlementsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The list of entitlements that you want to grant.
        pub fn entitlements(
            mut self,
            inp: impl Into<crate::model::GrantEntitlementRequest>,
        ) -> Self {
            self.inner = self.inner.entitlements(inp);
            self
        }
        pub fn set_entitlements(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GrantEntitlementRequest>>,
        ) -> Self {
            self.inner = self.inner.set_entitlements(input);
            self
        }
        /// The flow that you want to grant entitlements on.
        pub fn flow_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.flow_arn(input);
            self
        }
        pub fn set_flow_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_flow_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListEntitlements<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_entitlements_input::Builder,
    }
    impl<C> ListEntitlements<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListEntitlementsOutput,
            smithy_http::result::SdkError<crate::error::ListEntitlementsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The maximum number of results to return per API request. For example, you submit a ListEntitlements request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 20 results per page.
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// The token that identifies which batch of results that you want to see. For example, you submit a ListEntitlements request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListEntitlements request a second time and specify the NextToken value.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFlows<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_flows_input::Builder,
    }
    impl<C> ListFlows<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFlowsOutput,
            smithy_http::result::SdkError<crate::error::ListFlowsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The maximum number of results to return per API request. For example, you submit a ListFlows request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// The token that identifies which batch of results that you want to see. For example, you submit a ListFlows request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListFlows request a second time and specify the NextToken value.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListOfferings<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_offerings_input::Builder,
    }
    impl<C> ListOfferings<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListOfferingsOutput,
            smithy_http::result::SdkError<crate::error::ListOfferingsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The maximum number of results to return per API request. For example, you submit a ListOfferings request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// The token that identifies which batch of results that you want to see. For example, you submit a ListOfferings request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListOfferings request a second time and specify the NextToken value.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListReservations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_reservations_input::Builder,
    }
    impl<C> ListReservations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListReservationsOutput,
            smithy_http::result::SdkError<crate::error::ListReservationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The maximum number of results to return per API request. For example, you submit a ListReservations request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// The token that identifies which batch of results that you want to see. For example, you submit a ListReservations request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListOfferings request a second time and specify the NextToken value.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The Amazon Resource Name (ARN) that identifies the AWS Elemental MediaConnect resource for which to list the tags.
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PurchaseOffering<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::purchase_offering_input::Builder,
    }
    impl<C> PurchaseOffering<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PurchaseOfferingOutput,
            smithy_http::result::SdkError<crate::error::PurchaseOfferingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The Amazon Resource Name (ARN) of the offering.
        pub fn offering_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.offering_arn(input);
            self
        }
        pub fn set_offering_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_offering_arn(input);
            self
        }
        /// The name that you want to use for the reservation.
        pub fn reservation_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reservation_name(input);
            self
        }
        pub fn set_reservation_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_reservation_name(input);
            self
        }
        /// The date and time that you want the reservation to begin, in Coordinated Universal Time (UTC). You can specify any date and time between 12:00am on the first day of the current month to the current time on today's date, inclusive. Specify the start in a 24-hour notation. Use the following format: YYYY-MM-DDTHH:mm:SSZ, where T and Z are literal characters. For example, to specify 11:30pm on March 5, 2020, enter 2020-03-05T23:30:00Z.
        pub fn start(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.start(input);
            self
        }
        pub fn set_start(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_start(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveFlowMediaStream<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::remove_flow_media_stream_input::Builder,
    }
    impl<C> RemoveFlowMediaStream<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemoveFlowMediaStreamOutput,
            smithy_http::result::SdkError<crate::error::RemoveFlowMediaStreamError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The Amazon Resource Name (ARN) of the flow.
        pub fn flow_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.flow_arn(input);
            self
        }
        pub fn set_flow_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_flow_arn(input);
            self
        }
        /// The name of the media stream that you want to remove.
        pub fn media_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.media_stream_name(input);
            self
        }
        pub fn set_media_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_media_stream_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveFlowOutput<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::remove_flow_output_input::Builder,
    }
    impl<C> RemoveFlowOutput<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemoveFlowOutputOutput,
            smithy_http::result::SdkError<crate::error::RemoveFlowOutputError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The flow that you want to remove an output from.
        pub fn flow_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.flow_arn(input);
            self
        }
        pub fn set_flow_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_flow_arn(input);
            self
        }
        /// The ARN of the output that you want to remove.
        pub fn output_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.output_arn(input);
            self
        }
        pub fn set_output_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_output_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveFlowSource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::remove_flow_source_input::Builder,
    }
    impl<C> RemoveFlowSource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemoveFlowSourceOutput,
            smithy_http::result::SdkError<crate::error::RemoveFlowSourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The flow that you want to remove a source from.
        pub fn flow_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.flow_arn(input);
            self
        }
        pub fn set_flow_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_flow_arn(input);
            self
        }
        /// The ARN of the source that you want to remove.
        pub fn source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_arn(input);
            self
        }
        pub fn set_source_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_source_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveFlowVpcInterface<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::remove_flow_vpc_interface_input::Builder,
    }
    impl<C> RemoveFlowVpcInterface<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemoveFlowVpcInterfaceOutput,
            smithy_http::result::SdkError<crate::error::RemoveFlowVpcInterfaceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The flow that you want to remove a VPC interface from.
        pub fn flow_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.flow_arn(input);
            self
        }
        pub fn set_flow_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_flow_arn(input);
            self
        }
        /// The name of the VPC interface that you want to remove.
        pub fn vpc_interface_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_interface_name(input);
            self
        }
        pub fn set_vpc_interface_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpc_interface_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RevokeFlowEntitlement<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::revoke_flow_entitlement_input::Builder,
    }
    impl<C> RevokeFlowEntitlement<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RevokeFlowEntitlementOutput,
            smithy_http::result::SdkError<crate::error::RevokeFlowEntitlementError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The ARN of the entitlement that you want to revoke.
        pub fn entitlement_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.entitlement_arn(input);
            self
        }
        pub fn set_entitlement_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_entitlement_arn(input);
            self
        }
        /// The flow that you want to revoke an entitlement from.
        pub fn flow_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.flow_arn(input);
            self
        }
        pub fn set_flow_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_flow_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartFlow<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_flow_input::Builder,
    }
    impl<C> StartFlow<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartFlowOutput,
            smithy_http::result::SdkError<crate::error::StartFlowError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The ARN of the flow that you want to start.
        pub fn flow_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.flow_arn(input);
            self
        }
        pub fn set_flow_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_flow_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopFlow<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_flow_input::Builder,
    }
    impl<C> StopFlow<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopFlowOutput,
            smithy_http::result::SdkError<crate::error::StopFlowError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The ARN of the flow that you want to stop.
        pub fn flow_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.flow_arn(input);
            self
        }
        pub fn set_flow_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_flow_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The Amazon Resource Name (ARN) that identifies the AWS Elemental MediaConnect resource to which to add tags.
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// A map from tag keys to values. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The Amazon Resource Name (ARN) that identifies the AWS Elemental MediaConnect resource from which to delete tags.
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// The keys of the tags to be removed.
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFlow<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_flow_input::Builder,
    }
    impl<C> UpdateFlow<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateFlowOutput,
            smithy_http::result::SdkError<crate::error::UpdateFlowError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The flow that you want to update.
        pub fn flow_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.flow_arn(input);
            self
        }
        pub fn set_flow_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_flow_arn(input);
            self
        }
        /// The settings for source failover
        pub fn source_failover_config(mut self, input: crate::model::UpdateFailoverConfig) -> Self {
            self.inner = self.inner.source_failover_config(input);
            self
        }
        pub fn set_source_failover_config(
            mut self,
            input: std::option::Option<crate::model::UpdateFailoverConfig>,
        ) -> Self {
            self.inner = self.inner.set_source_failover_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFlowEntitlement<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_flow_entitlement_input::Builder,
    }
    impl<C> UpdateFlowEntitlement<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateFlowEntitlementOutput,
            smithy_http::result::SdkError<crate::error::UpdateFlowEntitlementError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// A description of the entitlement. This description appears only on the AWS Elemental MediaConnect console and will not be seen by the subscriber or end user.
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// The type of encryption that will be used on the output associated with this entitlement.
        pub fn encryption(mut self, input: crate::model::UpdateEncryption) -> Self {
            self.inner = self.inner.encryption(input);
            self
        }
        pub fn set_encryption(
            mut self,
            input: std::option::Option<crate::model::UpdateEncryption>,
        ) -> Self {
            self.inner = self.inner.set_encryption(input);
            self
        }
        /// The ARN of the entitlement that you want to update.
        pub fn entitlement_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.entitlement_arn(input);
            self
        }
        pub fn set_entitlement_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_entitlement_arn(input);
            self
        }
        /// An indication of whether you want to enable the entitlement to allow access, or disable it to stop streaming content to the subscribers flow temporarily. If you dont specify the entitlementStatus field in your request, MediaConnect leaves the value unchanged.
        pub fn entitlement_status(mut self, input: crate::model::EntitlementStatus) -> Self {
            self.inner = self.inner.entitlement_status(input);
            self
        }
        pub fn set_entitlement_status(
            mut self,
            input: std::option::Option<crate::model::EntitlementStatus>,
        ) -> Self {
            self.inner = self.inner.set_entitlement_status(input);
            self
        }
        /// The flow that is associated with the entitlement that you want to update.
        pub fn flow_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.flow_arn(input);
            self
        }
        pub fn set_flow_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_flow_arn(input);
            self
        }
        /// The AWS account IDs that you want to share your content with. The receiving accounts (subscribers) will be allowed to create their own flow using your content as the source.
        pub fn subscribers(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subscribers(inp);
            self
        }
        pub fn set_subscribers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subscribers(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFlowMediaStream<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_flow_media_stream_input::Builder,
    }
    impl<C> UpdateFlowMediaStream<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateFlowMediaStreamOutput,
            smithy_http::result::SdkError<crate::error::UpdateFlowMediaStreamError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The attributes that you want to assign to the media stream.
        pub fn attributes(mut self, input: crate::model::MediaStreamAttributesRequest) -> Self {
            self.inner = self.inner.attributes(input);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<crate::model::MediaStreamAttributesRequest>,
        ) -> Self {
            self.inner = self.inner.set_attributes(input);
            self
        }
        /// The sample rate (in Hz) for the stream. If the media stream type is video or ancillary data, set this value to 90000. If the media stream type is audio, set this value to either 48000 or 96000.
        pub fn clock_rate(mut self, input: i32) -> Self {
            self.inner = self.inner.clock_rate(input);
            self
        }
        pub fn set_clock_rate(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_clock_rate(input);
            self
        }
        /// Description
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// The Amazon Resource Name (ARN) of the flow.
        pub fn flow_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.flow_arn(input);
            self
        }
        pub fn set_flow_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_flow_arn(input);
            self
        }
        /// The name of the media stream that you want to update.
        pub fn media_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.media_stream_name(input);
            self
        }
        pub fn set_media_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_media_stream_name(input);
            self
        }
        /// The type of media stream.
        pub fn media_stream_type(mut self, input: crate::model::MediaStreamType) -> Self {
            self.inner = self.inner.media_stream_type(input);
            self
        }
        pub fn set_media_stream_type(
            mut self,
            input: std::option::Option<crate::model::MediaStreamType>,
        ) -> Self {
            self.inner = self.inner.set_media_stream_type(input);
            self
        }
        /// The resolution of the video.
        pub fn video_format(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.video_format(input);
            self
        }
        pub fn set_video_format(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_video_format(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFlowSource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_flow_source_input::Builder,
    }
    impl<C> UpdateFlowSource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateFlowSourceOutput,
            smithy_http::result::SdkError<crate::error::UpdateFlowSourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// The type of encryption used on the content ingested from this source.
        pub fn decryption(mut self, input: crate::model::UpdateEncryption) -> Self {
            self.inner = self.inner.decryption(input);
            self
        }
        pub fn set_decryption(
            mut self,
            input: std::option::Option<crate::model::UpdateEncryption>,
        ) -> Self {
            self.inner = self.inner.set_decryption(input);
            self
        }
        /// A description for the source. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// The ARN of the entitlement that allows you to subscribe to this flow. The entitlement is set by the flow originator, and the ARN is generated as part of the originator's flow.
        pub fn entitlement_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.entitlement_arn(input);
            self
        }
        pub fn set_entitlement_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_entitlement_arn(input);
            self
        }
        /// The flow that is associated with the source that you want to update.
        pub fn flow_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.flow_arn(input);
            self
        }
        pub fn set_flow_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_flow_arn(input);
            self
        }
        /// The port that the flow will be listening on for incoming content.
        pub fn ingest_port(mut self, input: i32) -> Self {
            self.inner = self.inner.ingest_port(input);
            self
        }
        pub fn set_ingest_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_ingest_port(input);
            self
        }
        /// The smoothing max bitrate for RIST, RTP, and RTP-FEC streams.
        pub fn max_bitrate(mut self, input: i32) -> Self {
            self.inner = self.inner.max_bitrate(input);
            self
        }
        pub fn set_max_bitrate(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_bitrate(input);
            self
        }
        /// The maximum latency in milliseconds. This parameter applies only to RIST-based and Zixi-based streams.
        pub fn max_latency(mut self, input: i32) -> Self {
            self.inner = self.inner.max_latency(input);
            self
        }
        pub fn set_max_latency(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_latency(input);
            self
        }
        /// The size of the buffer (in milliseconds) to use to sync incoming source data.
        pub fn max_sync_buffer(mut self, input: i32) -> Self {
            self.inner = self.inner.max_sync_buffer(input);
            self
        }
        pub fn set_max_sync_buffer(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_sync_buffer(input);
            self
        }
        /// The media streams that are associated with the source, and the parameters for those associations.
        pub fn media_stream_source_configurations(
            mut self,
            inp: impl Into<crate::model::MediaStreamSourceConfigurationRequest>,
        ) -> Self {
            self.inner = self.inner.media_stream_source_configurations(inp);
            self
        }
        pub fn set_media_stream_source_configurations(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::MediaStreamSourceConfigurationRequest>,
            >,
        ) -> Self {
            self.inner = self.inner.set_media_stream_source_configurations(input);
            self
        }
        /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the senders minimum latency and the receivers minimum latency.
        pub fn min_latency(mut self, input: i32) -> Self {
            self.inner = self.inner.min_latency(input);
            self
        }
        pub fn set_min_latency(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_min_latency(input);
            self
        }
        /// The protocol that is used by the source.
        pub fn protocol(mut self, input: crate::model::Protocol) -> Self {
            self.inner = self.inner.protocol(input);
            self
        }
        pub fn set_protocol(mut self, input: std::option::Option<crate::model::Protocol>) -> Self {
            self.inner = self.inner.set_protocol(input);
            self
        }
        /// The ARN of the source that you want to update.
        pub fn source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_arn(input);
            self
        }
        pub fn set_source_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_source_arn(input);
            self
        }
        /// The stream ID that you want to use for this transport. This parameter applies only to Zixi-based streams.
        pub fn stream_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_id(input);
            self
        }
        pub fn set_stream_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_id(input);
            self
        }
        /// The name of the VPC interface to use for this source.
        pub fn vpc_interface_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_interface_name(input);
            self
        }
        pub fn set_vpc_interface_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpc_interface_name(input);
            self
        }
        /// The range of IP addresses that should be allowed to contribute content to your source. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        pub fn whitelist_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.whitelist_cidr(input);
            self
        }
        pub fn set_whitelist_cidr(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_whitelist_cidr(input);
            self
        }
    }
}
