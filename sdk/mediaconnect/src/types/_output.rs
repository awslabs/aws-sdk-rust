// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The settings for an output.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct Output {
    /// <p>Percentage from 0-100 of the data transfer cost to be billed to the subscriber.</p>
    pub data_transfer_subscriber_fee_percent: ::std::option::Option<i32>,
    /// <p>A description of the output.</p>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>The address where you want to send the output.</p>
    pub destination: ::std::option::Option<::std::string::String>,
    /// <p>The type of key used for the encryption. If no keyType is provided, the service will use the default setting (static-key).</p>
    pub encryption: ::std::option::Option<crate::types::Encryption>,
    /// <p>The ARN of the entitlement on the originator''s flow. This value is relevant only on entitled flows.</p>
    pub entitlement_arn: ::std::option::Option<::std::string::String>,
    /// <p>The IP address that the receiver requires in order to establish a connection with the flow. For public networking, the ListenerAddress is represented by the elastic IP address of the flow. For private networking, the ListenerAddress is represented by the elastic network interface IP address of the VPC. This field applies only to outputs that use the Zixi pull or SRT listener protocol.</p>
    pub listener_address: ::std::option::Option<::std::string::String>,
    /// <p>The input ARN of the MediaLive channel. This parameter is relevant only for outputs that were added by creating a MediaLive input.</p>
    pub media_live_input_arn: ::std::option::Option<::std::string::String>,
    /// <p>The configuration for each media stream that is associated with the output.</p>
    pub media_stream_output_configurations: ::std::option::Option<::std::vec::Vec<crate::types::MediaStreamOutputConfiguration>>,
    /// <p>The name of the output. This value must be unique within the current flow.</p>
    pub name: ::std::option::Option<::std::string::String>,
    /// <p>The ARN of the output.</p>
    pub output_arn: ::std::option::Option<::std::string::String>,
    /// <p>The port to use when content is distributed to this output.</p>
    pub port: ::std::option::Option<i32>,
    /// <p>Attributes related to the transport stream that are used in the output.</p>
    pub transport: ::std::option::Option<crate::types::Transport>,
    /// <p>The name of the VPC interface attachment to use for this output.</p>
    pub vpc_interface_attachment: ::std::option::Option<crate::types::VpcInterfaceAttachment>,
    /// <p>The ARN of the bridge added to this output.</p>
    pub bridge_arn: ::std::option::Option<::std::string::String>,
    /// <p>The bridge output ports currently in use.</p>
    pub bridge_ports: ::std::option::Option<::std::vec::Vec<i32>>,
    /// <p>An indication of whether the output is transmitting data or not.</p>
    pub output_status: ::std::option::Option<crate::types::OutputStatus>,
    /// <p>The IP address of the device that is currently receiving content from this output.</p><note>
    /// <ul>
    /// <li>
    /// <p>For outputs that use protocols where you specify the destination (such as SRT Caller or Zixi Push), this value matches the configured destination address.</p></li>
    /// <li>
    /// <p>For outputs that use listener protocols (such as SRT Listener), this value shows the address of the connected receiver.</p></li>
    /// <li>
    /// <p>Peer IP addresses aren't available for entitlements, managed MediaLive outputs, NDI outputs, and CDI/ST2110 outputs.</p></li>
    /// <li>
    /// <p>The peer IP address might not be visible for flows that haven't been started yet, or flows that were started before May 2025. In these cases, restart your flow to see the peer IP address.</p></li>
    /// </ul>
    /// </note>
    pub peer_ip_address: ::std::option::Option<::std::string::String>,
    /// <p>Indicates if router integration is enabled or disabled on the flow output.</p>
    pub router_integration_state: ::std::option::Option<crate::types::State>,
    /// <p>The encryption configuration for the output when router integration is enabled.</p>
    pub router_integration_transit_encryption: ::std::option::Option<crate::types::FlowTransitEncryption>,
    /// <p>The ARN of the router input that's connected to this flow output.</p>
    pub connected_router_input_arn: ::std::option::Option<::std::string::String>,
}
impl Output {
    /// <p>Percentage from 0-100 of the data transfer cost to be billed to the subscriber.</p>
    pub fn data_transfer_subscriber_fee_percent(&self) -> ::std::option::Option<i32> {
        self.data_transfer_subscriber_fee_percent
    }
    /// <p>A description of the output.</p>
    pub fn description(&self) -> ::std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The address where you want to send the output.</p>
    pub fn destination(&self) -> ::std::option::Option<&str> {
        self.destination.as_deref()
    }
    /// <p>The type of key used for the encryption. If no keyType is provided, the service will use the default setting (static-key).</p>
    pub fn encryption(&self) -> ::std::option::Option<&crate::types::Encryption> {
        self.encryption.as_ref()
    }
    /// <p>The ARN of the entitlement on the originator''s flow. This value is relevant only on entitled flows.</p>
    pub fn entitlement_arn(&self) -> ::std::option::Option<&str> {
        self.entitlement_arn.as_deref()
    }
    /// <p>The IP address that the receiver requires in order to establish a connection with the flow. For public networking, the ListenerAddress is represented by the elastic IP address of the flow. For private networking, the ListenerAddress is represented by the elastic network interface IP address of the VPC. This field applies only to outputs that use the Zixi pull or SRT listener protocol.</p>
    pub fn listener_address(&self) -> ::std::option::Option<&str> {
        self.listener_address.as_deref()
    }
    /// <p>The input ARN of the MediaLive channel. This parameter is relevant only for outputs that were added by creating a MediaLive input.</p>
    pub fn media_live_input_arn(&self) -> ::std::option::Option<&str> {
        self.media_live_input_arn.as_deref()
    }
    /// <p>The configuration for each media stream that is associated with the output.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.media_stream_output_configurations.is_none()`.
    pub fn media_stream_output_configurations(&self) -> &[crate::types::MediaStreamOutputConfiguration] {
        self.media_stream_output_configurations.as_deref().unwrap_or_default()
    }
    /// <p>The name of the output. This value must be unique within the current flow.</p>
    pub fn name(&self) -> ::std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ARN of the output.</p>
    pub fn output_arn(&self) -> ::std::option::Option<&str> {
        self.output_arn.as_deref()
    }
    /// <p>The port to use when content is distributed to this output.</p>
    pub fn port(&self) -> ::std::option::Option<i32> {
        self.port
    }
    /// <p>Attributes related to the transport stream that are used in the output.</p>
    pub fn transport(&self) -> ::std::option::Option<&crate::types::Transport> {
        self.transport.as_ref()
    }
    /// <p>The name of the VPC interface attachment to use for this output.</p>
    pub fn vpc_interface_attachment(&self) -> ::std::option::Option<&crate::types::VpcInterfaceAttachment> {
        self.vpc_interface_attachment.as_ref()
    }
    /// <p>The ARN of the bridge added to this output.</p>
    pub fn bridge_arn(&self) -> ::std::option::Option<&str> {
        self.bridge_arn.as_deref()
    }
    /// <p>The bridge output ports currently in use.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.bridge_ports.is_none()`.
    pub fn bridge_ports(&self) -> &[i32] {
        self.bridge_ports.as_deref().unwrap_or_default()
    }
    /// <p>An indication of whether the output is transmitting data or not.</p>
    pub fn output_status(&self) -> ::std::option::Option<&crate::types::OutputStatus> {
        self.output_status.as_ref()
    }
    /// <p>The IP address of the device that is currently receiving content from this output.</p><note>
    /// <ul>
    /// <li>
    /// <p>For outputs that use protocols where you specify the destination (such as SRT Caller or Zixi Push), this value matches the configured destination address.</p></li>
    /// <li>
    /// <p>For outputs that use listener protocols (such as SRT Listener), this value shows the address of the connected receiver.</p></li>
    /// <li>
    /// <p>Peer IP addresses aren't available for entitlements, managed MediaLive outputs, NDI outputs, and CDI/ST2110 outputs.</p></li>
    /// <li>
    /// <p>The peer IP address might not be visible for flows that haven't been started yet, or flows that were started before May 2025. In these cases, restart your flow to see the peer IP address.</p></li>
    /// </ul>
    /// </note>
    pub fn peer_ip_address(&self) -> ::std::option::Option<&str> {
        self.peer_ip_address.as_deref()
    }
    /// <p>Indicates if router integration is enabled or disabled on the flow output.</p>
    pub fn router_integration_state(&self) -> ::std::option::Option<&crate::types::State> {
        self.router_integration_state.as_ref()
    }
    /// <p>The encryption configuration for the output when router integration is enabled.</p>
    pub fn router_integration_transit_encryption(&self) -> ::std::option::Option<&crate::types::FlowTransitEncryption> {
        self.router_integration_transit_encryption.as_ref()
    }
    /// <p>The ARN of the router input that's connected to this flow output.</p>
    pub fn connected_router_input_arn(&self) -> ::std::option::Option<&str> {
        self.connected_router_input_arn.as_deref()
    }
}
impl Output {
    /// Creates a new builder-style object to manufacture [`Output`](crate::types::Output).
    pub fn builder() -> crate::types::builders::OutputBuilder {
        crate::types::builders::OutputBuilder::default()
    }
}

/// A builder for [`Output`](crate::types::Output).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct OutputBuilder {
    pub(crate) data_transfer_subscriber_fee_percent: ::std::option::Option<i32>,
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) destination: ::std::option::Option<::std::string::String>,
    pub(crate) encryption: ::std::option::Option<crate::types::Encryption>,
    pub(crate) entitlement_arn: ::std::option::Option<::std::string::String>,
    pub(crate) listener_address: ::std::option::Option<::std::string::String>,
    pub(crate) media_live_input_arn: ::std::option::Option<::std::string::String>,
    pub(crate) media_stream_output_configurations: ::std::option::Option<::std::vec::Vec<crate::types::MediaStreamOutputConfiguration>>,
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) output_arn: ::std::option::Option<::std::string::String>,
    pub(crate) port: ::std::option::Option<i32>,
    pub(crate) transport: ::std::option::Option<crate::types::Transport>,
    pub(crate) vpc_interface_attachment: ::std::option::Option<crate::types::VpcInterfaceAttachment>,
    pub(crate) bridge_arn: ::std::option::Option<::std::string::String>,
    pub(crate) bridge_ports: ::std::option::Option<::std::vec::Vec<i32>>,
    pub(crate) output_status: ::std::option::Option<crate::types::OutputStatus>,
    pub(crate) peer_ip_address: ::std::option::Option<::std::string::String>,
    pub(crate) router_integration_state: ::std::option::Option<crate::types::State>,
    pub(crate) router_integration_transit_encryption: ::std::option::Option<crate::types::FlowTransitEncryption>,
    pub(crate) connected_router_input_arn: ::std::option::Option<::std::string::String>,
}
impl OutputBuilder {
    /// <p>Percentage from 0-100 of the data transfer cost to be billed to the subscriber.</p>
    pub fn data_transfer_subscriber_fee_percent(mut self, input: i32) -> Self {
        self.data_transfer_subscriber_fee_percent = ::std::option::Option::Some(input);
        self
    }
    /// <p>Percentage from 0-100 of the data transfer cost to be billed to the subscriber.</p>
    pub fn set_data_transfer_subscriber_fee_percent(mut self, input: ::std::option::Option<i32>) -> Self {
        self.data_transfer_subscriber_fee_percent = input;
        self
    }
    /// <p>Percentage from 0-100 of the data transfer cost to be billed to the subscriber.</p>
    pub fn get_data_transfer_subscriber_fee_percent(&self) -> &::std::option::Option<i32> {
        &self.data_transfer_subscriber_fee_percent
    }
    /// <p>A description of the output.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A description of the output.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>A description of the output.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// <p>The address where you want to send the output.</p>
    pub fn destination(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.destination = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The address where you want to send the output.</p>
    pub fn set_destination(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.destination = input;
        self
    }
    /// <p>The address where you want to send the output.</p>
    pub fn get_destination(&self) -> &::std::option::Option<::std::string::String> {
        &self.destination
    }
    /// <p>The type of key used for the encryption. If no keyType is provided, the service will use the default setting (static-key).</p>
    pub fn encryption(mut self, input: crate::types::Encryption) -> Self {
        self.encryption = ::std::option::Option::Some(input);
        self
    }
    /// <p>The type of key used for the encryption. If no keyType is provided, the service will use the default setting (static-key).</p>
    pub fn set_encryption(mut self, input: ::std::option::Option<crate::types::Encryption>) -> Self {
        self.encryption = input;
        self
    }
    /// <p>The type of key used for the encryption. If no keyType is provided, the service will use the default setting (static-key).</p>
    pub fn get_encryption(&self) -> &::std::option::Option<crate::types::Encryption> {
        &self.encryption
    }
    /// <p>The ARN of the entitlement on the originator''s flow. This value is relevant only on entitled flows.</p>
    pub fn entitlement_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.entitlement_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN of the entitlement on the originator''s flow. This value is relevant only on entitled flows.</p>
    pub fn set_entitlement_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.entitlement_arn = input;
        self
    }
    /// <p>The ARN of the entitlement on the originator''s flow. This value is relevant only on entitled flows.</p>
    pub fn get_entitlement_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.entitlement_arn
    }
    /// <p>The IP address that the receiver requires in order to establish a connection with the flow. For public networking, the ListenerAddress is represented by the elastic IP address of the flow. For private networking, the ListenerAddress is represented by the elastic network interface IP address of the VPC. This field applies only to outputs that use the Zixi pull or SRT listener protocol.</p>
    pub fn listener_address(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.listener_address = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The IP address that the receiver requires in order to establish a connection with the flow. For public networking, the ListenerAddress is represented by the elastic IP address of the flow. For private networking, the ListenerAddress is represented by the elastic network interface IP address of the VPC. This field applies only to outputs that use the Zixi pull or SRT listener protocol.</p>
    pub fn set_listener_address(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.listener_address = input;
        self
    }
    /// <p>The IP address that the receiver requires in order to establish a connection with the flow. For public networking, the ListenerAddress is represented by the elastic IP address of the flow. For private networking, the ListenerAddress is represented by the elastic network interface IP address of the VPC. This field applies only to outputs that use the Zixi pull or SRT listener protocol.</p>
    pub fn get_listener_address(&self) -> &::std::option::Option<::std::string::String> {
        &self.listener_address
    }
    /// <p>The input ARN of the MediaLive channel. This parameter is relevant only for outputs that were added by creating a MediaLive input.</p>
    pub fn media_live_input_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.media_live_input_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The input ARN of the MediaLive channel. This parameter is relevant only for outputs that were added by creating a MediaLive input.</p>
    pub fn set_media_live_input_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.media_live_input_arn = input;
        self
    }
    /// <p>The input ARN of the MediaLive channel. This parameter is relevant only for outputs that were added by creating a MediaLive input.</p>
    pub fn get_media_live_input_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.media_live_input_arn
    }
    /// Appends an item to `media_stream_output_configurations`.
    ///
    /// To override the contents of this collection use [`set_media_stream_output_configurations`](Self::set_media_stream_output_configurations).
    ///
    /// <p>The configuration for each media stream that is associated with the output.</p>
    pub fn media_stream_output_configurations(mut self, input: crate::types::MediaStreamOutputConfiguration) -> Self {
        let mut v = self.media_stream_output_configurations.unwrap_or_default();
        v.push(input);
        self.media_stream_output_configurations = ::std::option::Option::Some(v);
        self
    }
    /// <p>The configuration for each media stream that is associated with the output.</p>
    pub fn set_media_stream_output_configurations(
        mut self,
        input: ::std::option::Option<::std::vec::Vec<crate::types::MediaStreamOutputConfiguration>>,
    ) -> Self {
        self.media_stream_output_configurations = input;
        self
    }
    /// <p>The configuration for each media stream that is associated with the output.</p>
    pub fn get_media_stream_output_configurations(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::MediaStreamOutputConfiguration>> {
        &self.media_stream_output_configurations
    }
    /// <p>The name of the output. This value must be unique within the current flow.</p>
    /// This field is required.
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the output. This value must be unique within the current flow.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The name of the output. This value must be unique within the current flow.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>The ARN of the output.</p>
    /// This field is required.
    pub fn output_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.output_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN of the output.</p>
    pub fn set_output_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.output_arn = input;
        self
    }
    /// <p>The ARN of the output.</p>
    pub fn get_output_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.output_arn
    }
    /// <p>The port to use when content is distributed to this output.</p>
    pub fn port(mut self, input: i32) -> Self {
        self.port = ::std::option::Option::Some(input);
        self
    }
    /// <p>The port to use when content is distributed to this output.</p>
    pub fn set_port(mut self, input: ::std::option::Option<i32>) -> Self {
        self.port = input;
        self
    }
    /// <p>The port to use when content is distributed to this output.</p>
    pub fn get_port(&self) -> &::std::option::Option<i32> {
        &self.port
    }
    /// <p>Attributes related to the transport stream that are used in the output.</p>
    pub fn transport(mut self, input: crate::types::Transport) -> Self {
        self.transport = ::std::option::Option::Some(input);
        self
    }
    /// <p>Attributes related to the transport stream that are used in the output.</p>
    pub fn set_transport(mut self, input: ::std::option::Option<crate::types::Transport>) -> Self {
        self.transport = input;
        self
    }
    /// <p>Attributes related to the transport stream that are used in the output.</p>
    pub fn get_transport(&self) -> &::std::option::Option<crate::types::Transport> {
        &self.transport
    }
    /// <p>The name of the VPC interface attachment to use for this output.</p>
    pub fn vpc_interface_attachment(mut self, input: crate::types::VpcInterfaceAttachment) -> Self {
        self.vpc_interface_attachment = ::std::option::Option::Some(input);
        self
    }
    /// <p>The name of the VPC interface attachment to use for this output.</p>
    pub fn set_vpc_interface_attachment(mut self, input: ::std::option::Option<crate::types::VpcInterfaceAttachment>) -> Self {
        self.vpc_interface_attachment = input;
        self
    }
    /// <p>The name of the VPC interface attachment to use for this output.</p>
    pub fn get_vpc_interface_attachment(&self) -> &::std::option::Option<crate::types::VpcInterfaceAttachment> {
        &self.vpc_interface_attachment
    }
    /// <p>The ARN of the bridge added to this output.</p>
    pub fn bridge_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.bridge_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN of the bridge added to this output.</p>
    pub fn set_bridge_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.bridge_arn = input;
        self
    }
    /// <p>The ARN of the bridge added to this output.</p>
    pub fn get_bridge_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.bridge_arn
    }
    /// Appends an item to `bridge_ports`.
    ///
    /// To override the contents of this collection use [`set_bridge_ports`](Self::set_bridge_ports).
    ///
    /// <p>The bridge output ports currently in use.</p>
    pub fn bridge_ports(mut self, input: i32) -> Self {
        let mut v = self.bridge_ports.unwrap_or_default();
        v.push(input);
        self.bridge_ports = ::std::option::Option::Some(v);
        self
    }
    /// <p>The bridge output ports currently in use.</p>
    pub fn set_bridge_ports(mut self, input: ::std::option::Option<::std::vec::Vec<i32>>) -> Self {
        self.bridge_ports = input;
        self
    }
    /// <p>The bridge output ports currently in use.</p>
    pub fn get_bridge_ports(&self) -> &::std::option::Option<::std::vec::Vec<i32>> {
        &self.bridge_ports
    }
    /// <p>An indication of whether the output is transmitting data or not.</p>
    pub fn output_status(mut self, input: crate::types::OutputStatus) -> Self {
        self.output_status = ::std::option::Option::Some(input);
        self
    }
    /// <p>An indication of whether the output is transmitting data or not.</p>
    pub fn set_output_status(mut self, input: ::std::option::Option<crate::types::OutputStatus>) -> Self {
        self.output_status = input;
        self
    }
    /// <p>An indication of whether the output is transmitting data or not.</p>
    pub fn get_output_status(&self) -> &::std::option::Option<crate::types::OutputStatus> {
        &self.output_status
    }
    /// <p>The IP address of the device that is currently receiving content from this output.</p><note>
    /// <ul>
    /// <li>
    /// <p>For outputs that use protocols where you specify the destination (such as SRT Caller or Zixi Push), this value matches the configured destination address.</p></li>
    /// <li>
    /// <p>For outputs that use listener protocols (such as SRT Listener), this value shows the address of the connected receiver.</p></li>
    /// <li>
    /// <p>Peer IP addresses aren't available for entitlements, managed MediaLive outputs, NDI outputs, and CDI/ST2110 outputs.</p></li>
    /// <li>
    /// <p>The peer IP address might not be visible for flows that haven't been started yet, or flows that were started before May 2025. In these cases, restart your flow to see the peer IP address.</p></li>
    /// </ul>
    /// </note>
    pub fn peer_ip_address(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.peer_ip_address = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The IP address of the device that is currently receiving content from this output.</p><note>
    /// <ul>
    /// <li>
    /// <p>For outputs that use protocols where you specify the destination (such as SRT Caller or Zixi Push), this value matches the configured destination address.</p></li>
    /// <li>
    /// <p>For outputs that use listener protocols (such as SRT Listener), this value shows the address of the connected receiver.</p></li>
    /// <li>
    /// <p>Peer IP addresses aren't available for entitlements, managed MediaLive outputs, NDI outputs, and CDI/ST2110 outputs.</p></li>
    /// <li>
    /// <p>The peer IP address might not be visible for flows that haven't been started yet, or flows that were started before May 2025. In these cases, restart your flow to see the peer IP address.</p></li>
    /// </ul>
    /// </note>
    pub fn set_peer_ip_address(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.peer_ip_address = input;
        self
    }
    /// <p>The IP address of the device that is currently receiving content from this output.</p><note>
    /// <ul>
    /// <li>
    /// <p>For outputs that use protocols where you specify the destination (such as SRT Caller or Zixi Push), this value matches the configured destination address.</p></li>
    /// <li>
    /// <p>For outputs that use listener protocols (such as SRT Listener), this value shows the address of the connected receiver.</p></li>
    /// <li>
    /// <p>Peer IP addresses aren't available for entitlements, managed MediaLive outputs, NDI outputs, and CDI/ST2110 outputs.</p></li>
    /// <li>
    /// <p>The peer IP address might not be visible for flows that haven't been started yet, or flows that were started before May 2025. In these cases, restart your flow to see the peer IP address.</p></li>
    /// </ul>
    /// </note>
    pub fn get_peer_ip_address(&self) -> &::std::option::Option<::std::string::String> {
        &self.peer_ip_address
    }
    /// <p>Indicates if router integration is enabled or disabled on the flow output.</p>
    pub fn router_integration_state(mut self, input: crate::types::State) -> Self {
        self.router_integration_state = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates if router integration is enabled or disabled on the flow output.</p>
    pub fn set_router_integration_state(mut self, input: ::std::option::Option<crate::types::State>) -> Self {
        self.router_integration_state = input;
        self
    }
    /// <p>Indicates if router integration is enabled or disabled on the flow output.</p>
    pub fn get_router_integration_state(&self) -> &::std::option::Option<crate::types::State> {
        &self.router_integration_state
    }
    /// <p>The encryption configuration for the output when router integration is enabled.</p>
    pub fn router_integration_transit_encryption(mut self, input: crate::types::FlowTransitEncryption) -> Self {
        self.router_integration_transit_encryption = ::std::option::Option::Some(input);
        self
    }
    /// <p>The encryption configuration for the output when router integration is enabled.</p>
    pub fn set_router_integration_transit_encryption(mut self, input: ::std::option::Option<crate::types::FlowTransitEncryption>) -> Self {
        self.router_integration_transit_encryption = input;
        self
    }
    /// <p>The encryption configuration for the output when router integration is enabled.</p>
    pub fn get_router_integration_transit_encryption(&self) -> &::std::option::Option<crate::types::FlowTransitEncryption> {
        &self.router_integration_transit_encryption
    }
    /// <p>The ARN of the router input that's connected to this flow output.</p>
    pub fn connected_router_input_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.connected_router_input_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN of the router input that's connected to this flow output.</p>
    pub fn set_connected_router_input_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.connected_router_input_arn = input;
        self
    }
    /// <p>The ARN of the router input that's connected to this flow output.</p>
    pub fn get_connected_router_input_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.connected_router_input_arn
    }
    /// Consumes the builder and constructs a [`Output`](crate::types::Output).
    pub fn build(self) -> crate::types::Output {
        crate::types::Output {
            data_transfer_subscriber_fee_percent: self.data_transfer_subscriber_fee_percent,
            description: self.description,
            destination: self.destination,
            encryption: self.encryption,
            entitlement_arn: self.entitlement_arn,
            listener_address: self.listener_address,
            media_live_input_arn: self.media_live_input_arn,
            media_stream_output_configurations: self.media_stream_output_configurations,
            name: self.name,
            output_arn: self.output_arn,
            port: self.port,
            transport: self.transport,
            vpc_interface_attachment: self.vpc_interface_attachment,
            bridge_arn: self.bridge_arn,
            bridge_ports: self.bridge_ports,
            output_status: self.output_status,
            peer_ip_address: self.peer_ip_address,
            router_integration_state: self.router_integration_state,
            router_integration_transit_encryption: self.router_integration_transit_encryption,
            connected_router_input_arn: self.connected_router_input_arn,
        }
    }
}
