// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The criteria to use in the filter that defines the archive rule. For more information on available filter keys, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-reference-filter-keys.html">IAM Access Analyzer filter keys</a>.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct Criterion {
    /// <p>An "equals" operator to match for the filter used to create the rule.</p>
    pub eq: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>A "not equals" operator to match for the filter used to create the rule.</p>
    pub neq: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>A "contains" operator to match for the filter used to create the rule.</p>
    pub contains: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>An "exists" operator to match for the filter used to create the rule. </p>
    pub exists: ::std::option::Option<bool>,
}
impl Criterion {
    /// <p>An "equals" operator to match for the filter used to create the rule.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.eq.is_none()`.
    pub fn eq(&self) -> &[::std::string::String] {
        self.eq.as_deref().unwrap_or_default()
    }
    /// <p>A "not equals" operator to match for the filter used to create the rule.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.neq.is_none()`.
    pub fn neq(&self) -> &[::std::string::String] {
        self.neq.as_deref().unwrap_or_default()
    }
    /// <p>A "contains" operator to match for the filter used to create the rule.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.contains.is_none()`.
    pub fn contains(&self) -> &[::std::string::String] {
        self.contains.as_deref().unwrap_or_default()
    }
    /// <p>An "exists" operator to match for the filter used to create the rule. </p>
    pub fn exists(&self) -> ::std::option::Option<bool> {
        self.exists
    }
}
impl Criterion {
    /// Creates a new builder-style object to manufacture [`Criterion`](crate::types::Criterion).
    pub fn builder() -> crate::types::builders::CriterionBuilder {
        crate::types::builders::CriterionBuilder::default()
    }
}

/// A builder for [`Criterion`](crate::types::Criterion).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct CriterionBuilder {
    pub(crate) eq: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) neq: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) contains: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) exists: ::std::option::Option<bool>,
}
impl CriterionBuilder {
    /// Appends an item to `eq`.
    ///
    /// To override the contents of this collection use [`set_eq`](Self::set_eq).
    ///
    /// <p>An "equals" operator to match for the filter used to create the rule.</p>
    pub fn eq(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.eq.unwrap_or_default();
        v.push(input.into());
        self.eq = ::std::option::Option::Some(v);
        self
    }
    /// <p>An "equals" operator to match for the filter used to create the rule.</p>
    pub fn set_eq(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.eq = input;
        self
    }
    /// <p>An "equals" operator to match for the filter used to create the rule.</p>
    pub fn get_eq(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.eq
    }
    /// Appends an item to `neq`.
    ///
    /// To override the contents of this collection use [`set_neq`](Self::set_neq).
    ///
    /// <p>A "not equals" operator to match for the filter used to create the rule.</p>
    pub fn neq(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.neq.unwrap_or_default();
        v.push(input.into());
        self.neq = ::std::option::Option::Some(v);
        self
    }
    /// <p>A "not equals" operator to match for the filter used to create the rule.</p>
    pub fn set_neq(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.neq = input;
        self
    }
    /// <p>A "not equals" operator to match for the filter used to create the rule.</p>
    pub fn get_neq(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.neq
    }
    /// Appends an item to `contains`.
    ///
    /// To override the contents of this collection use [`set_contains`](Self::set_contains).
    ///
    /// <p>A "contains" operator to match for the filter used to create the rule.</p>
    pub fn contains(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.contains.unwrap_or_default();
        v.push(input.into());
        self.contains = ::std::option::Option::Some(v);
        self
    }
    /// <p>A "contains" operator to match for the filter used to create the rule.</p>
    pub fn set_contains(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.contains = input;
        self
    }
    /// <p>A "contains" operator to match for the filter used to create the rule.</p>
    pub fn get_contains(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.contains
    }
    /// <p>An "exists" operator to match for the filter used to create the rule. </p>
    pub fn exists(mut self, input: bool) -> Self {
        self.exists = ::std::option::Option::Some(input);
        self
    }
    /// <p>An "exists" operator to match for the filter used to create the rule. </p>
    pub fn set_exists(mut self, input: ::std::option::Option<bool>) -> Self {
        self.exists = input;
        self
    }
    /// <p>An "exists" operator to match for the filter used to create the rule. </p>
    pub fn get_exists(&self) -> &::std::option::Option<bool> {
        &self.exists
    }
    /// Consumes the builder and constructs a [`Criterion`](crate::types::Criterion).
    pub fn build(self) -> crate::types::Criterion {
        crate::types::Criterion {
            eq: self.eq,
            neq: self.neq,
            contains: self.contains,
            exists: self.exists,
        }
    }
}
