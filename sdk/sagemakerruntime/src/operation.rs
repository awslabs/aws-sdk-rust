// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>After you deploy a model into production using Amazon SageMaker hosting services, your
/// client applications use this API to get inferences from the model hosted at the
/// specified endpoint. </p>
/// <p>For an overview of Amazon SageMaker, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/how-it-works.html">How It Works</a>. </p>
/// <p>Amazon SageMaker strips all POST headers except those supported by the API. Amazon SageMaker might add
/// additional headers. You should not rely on the behavior of headers outside those
/// enumerated in the request syntax. </p>
/// <p>Calls to <code>InvokeEndpoint</code> are authenticated by using AWS Signature Version
/// 4. For information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-authenticating-requests.html">Authenticating
/// Requests (AWS Signature Version 4)</a> in the <i>Amazon S3 API
/// Reference</i>.</p>
/// <p>A customer's model containers must respond to requests within 60 seconds. The model
/// itself can have a maximum processing time of 60 seconds before responding to
/// invocations. If your model is going to take 50-60 seconds of processing time, the SDK
/// socket timeout should be set to be 70 seconds.</p>
/// <note>
/// <p>Endpoints are scoped to an individual account, and are not public. The URL does
/// not contain the account ID, but Amazon SageMaker determines the account ID from the
/// authentication token that is supplied by the caller.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct InvokeEndpoint {
    _private: (),
}
impl InvokeEndpoint {
    /// Creates a new builder-style object to manufacture [`InvokeEndpointInput`](crate::input::InvokeEndpointInput)
    pub fn builder() -> crate::input::invoke_endpoint_input::Builder {
        crate::input::invoke_endpoint_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for InvokeEndpoint {
    type Output = Result<crate::output::InvokeEndpointOutput, crate::error::InvokeEndpointError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_invoke_endpoint_error(response)
        } else {
            crate::operation_deser::parse_invoke_endpoint_response(response)
        }
    }
}
