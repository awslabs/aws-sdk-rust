// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`InvokeEndpointInput`](crate::input::InvokeEndpointInput)
pub mod invoke_endpoint_input {
    /// A builder for [`InvokeEndpointInput`](crate::input::InvokeEndpointInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
        pub(crate) body: std::option::Option<smithy_types::Blob>,
        pub(crate) content_type: std::option::Option<std::string::String>,
        pub(crate) accept: std::option::Option<std::string::String>,
        pub(crate) custom_attributes: std::option::Option<std::string::String>,
        pub(crate) target_model: std::option::Option<std::string::String>,
        pub(crate) target_variant: std::option::Option<std::string::String>,
        pub(crate) target_container_hostname: std::option::Option<std::string::String>,
        pub(crate) inference_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the endpoint that you specified when you created the endpoint using the
        /// <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/API_CreateEndpoint.html">CreateEndpoint</a> API. </p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// <p>Provides input data, in the format specified in the <code>ContentType</code>
        /// request header. Amazon SageMaker passes all of the data in the body to the model. </p>
        /// <p>For information about the format of the request body, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/cdf-inference.html">Common Data
        /// Formats-Inference</a>.</p>
        pub fn body(mut self, input: smithy_types::Blob) -> Self {
            self.body = Some(input);
            self
        }
        pub fn set_body(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.body = input;
            self
        }
        /// <p>The MIME type of the input data in the request body.</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// <p>The desired MIME type of the inference in the response.</p>
        pub fn accept(mut self, input: impl Into<std::string::String>) -> Self {
            self.accept = Some(input.into());
            self
        }
        pub fn set_accept(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.accept = input;
            self
        }
        /// <p>Provides additional information about a request for an inference submitted to a model
        /// hosted at an Amazon SageMaker endpoint. The information is an opaque value that is
        /// forwarded verbatim. You could use this value, for example, to provide an ID that you can
        /// use to track a request or to provide other metadata that a service endpoint was
        /// programmed to process. The value must consist of no more than 1024 visible US-ASCII
        /// characters as specified in <a href="https://tools.ietf.org/html/rfc7230#section-3.2.6">Section 3.3.6. Field Value
        /// Components</a> of the Hypertext Transfer Protocol (HTTP/1.1). </p>
        /// <p>The code in your model is responsible for setting or updating any custom attributes in
        /// the response. If your code does not set this value in the response, an empty value is
        /// returned. For example, if a custom attribute represents the trace ID, your model can
        /// prepend the custom attribute with <code>Trace ID:</code> in your post-processing
        /// function.</p>
        /// <p>This feature is currently supported in the AWS SDKs but not in the Amazon SageMaker Python
        /// SDK.</p>
        pub fn custom_attributes(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_attributes = Some(input.into());
            self
        }
        pub fn set_custom_attributes(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.custom_attributes = input;
            self
        }
        /// <p>The model to request for inference when invoking a multi-model endpoint.</p>
        pub fn target_model(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_model = Some(input.into());
            self
        }
        pub fn set_target_model(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_model = input;
            self
        }
        /// <p>Specify the production variant to send the inference request to when invoking an
        /// endpoint that is running two or more variants. Note that this parameter overrides the
        /// default behavior for the endpoint, which is to distribute the invocation traffic based
        /// on the variant weights.</p>
        /// <p>For information about how to use variant targeting to perform a/b testing, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-ab-testing.html">Test models in
        /// production</a>
        /// </p>
        pub fn target_variant(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_variant = Some(input.into());
            self
        }
        pub fn set_target_variant(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_variant = input;
            self
        }
        /// <p>If the endpoint hosts multiple containers and is configured to use direct invocation,
        /// this parameter specifies the host name of the container to invoke.</p>
        pub fn target_container_hostname(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_container_hostname = Some(input.into());
            self
        }
        pub fn set_target_container_hostname(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_container_hostname = input;
            self
        }
        /// <p>If you provide a value, it is added to the captured data when you enable data capture
        /// on the endpoint. For information about data capture, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-monitor-data-capture.html">Capture
        /// Data</a>.</p>
        pub fn inference_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inference_id = Some(input.into());
            self
        }
        pub fn set_inference_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inference_id = input;
            self
        }
        /// Consumes the builder and constructs a [`InvokeEndpointInput`](crate::input::InvokeEndpointInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::InvokeEndpointInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::InvokeEndpointInput {
                endpoint_name: self.endpoint_name.unwrap_or_default(),
                body: self.body,
                content_type: self.content_type,
                accept: self.accept,
                custom_attributes: self.custom_attributes,
                target_model: self.target_model,
                target_variant: self.target_variant,
                target_container_hostname: self.target_container_hostname,
                inference_id: self.inference_id,
            })
        }
    }
}
#[doc(hidden)]
pub type InvokeEndpointInputOperationOutputAlias = crate::operation::InvokeEndpoint;
#[doc(hidden)]
pub type InvokeEndpointInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl InvokeEndpointInput {
    /// Consumes the builder and constructs an Operation<[`InvokeEndpoint`](crate::operation::InvokeEndpoint)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::InvokeEndpoint,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_invoke_endpoint_input(self.body)?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::InvokeEndpoint::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "InvokeEndpoint",
                "sagemakerruntime",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) {
        write!(
            output,
            "/endpoints/{EndpointName}/invocations",
            EndpointName = smithy_http::label::fmt_string(&self.endpoint_name, false)
        )
        .expect("formatting should succeed")
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_1) = &self.content_type {
            let formatted_2 = AsRef::<str>::as_ref(inner_1);
            if !formatted_2.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_2;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_type",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-Type", header_value);
            }
        }
        if let Some(inner_3) = &self.accept {
            let formatted_4 = AsRef::<str>::as_ref(inner_3);
            if !formatted_4.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_4;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "accept",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Accept", header_value);
            }
        }
        if let Some(inner_5) = &self.custom_attributes {
            let formatted_6 = AsRef::<str>::as_ref(inner_5);
            if !formatted_6.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_6;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "custom_attributes",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        }
                    })?;
                builder = builder.header("X-Amzn-SageMaker-Custom-Attributes", header_value);
            }
        }
        if let Some(inner_7) = &self.target_model {
            let formatted_8 = AsRef::<str>::as_ref(inner_7);
            if !formatted_8.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_8;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "target_model",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("X-Amzn-SageMaker-Target-Model", header_value);
            }
        }
        if let Some(inner_9) = &self.target_variant {
            let formatted_10 = AsRef::<str>::as_ref(inner_9);
            if !formatted_10.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_10;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "target_variant",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("X-Amzn-SageMaker-Target-Variant", header_value);
            }
        }
        if let Some(inner_11) = &self.target_container_hostname {
            let formatted_12 = AsRef::<str>::as_ref(inner_11);
            if !formatted_12.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_12;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "target_container_hostname",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder =
                    builder.header("X-Amzn-SageMaker-Target-Container-Hostname", header_value);
            }
        }
        if let Some(inner_13) = &self.inference_id {
            let formatted_14 = AsRef::<str>::as_ref(inner_13);
            if !formatted_14.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_14;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "inference_id",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("X-Amzn-SageMaker-Inference-Id", header_value);
            }
        }
        Ok(builder)
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        let builder = self.add_headers(builder)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/octet-stream");
        self.update_http_builder(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`InvokeEndpointInput`](crate::input::InvokeEndpointInput)
    pub fn builder() -> crate::input::invoke_endpoint_input::Builder {
        crate::input::invoke_endpoint_input::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvokeEndpointInput {
    /// <p>The name of the endpoint that you specified when you created the endpoint using the
    /// <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/API_CreateEndpoint.html">CreateEndpoint</a> API. </p>
    pub endpoint_name: std::string::String,
    /// <p>Provides input data, in the format specified in the <code>ContentType</code>
    /// request header. Amazon SageMaker passes all of the data in the body to the model. </p>
    /// <p>For information about the format of the request body, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/cdf-inference.html">Common Data
    /// Formats-Inference</a>.</p>
    pub body: std::option::Option<smithy_types::Blob>,
    /// <p>The MIME type of the input data in the request body.</p>
    pub content_type: std::option::Option<std::string::String>,
    /// <p>The desired MIME type of the inference in the response.</p>
    pub accept: std::option::Option<std::string::String>,
    /// <p>Provides additional information about a request for an inference submitted to a model
    /// hosted at an Amazon SageMaker endpoint. The information is an opaque value that is
    /// forwarded verbatim. You could use this value, for example, to provide an ID that you can
    /// use to track a request or to provide other metadata that a service endpoint was
    /// programmed to process. The value must consist of no more than 1024 visible US-ASCII
    /// characters as specified in <a href="https://tools.ietf.org/html/rfc7230#section-3.2.6">Section 3.3.6. Field Value
    /// Components</a> of the Hypertext Transfer Protocol (HTTP/1.1). </p>
    /// <p>The code in your model is responsible for setting or updating any custom attributes in
    /// the response. If your code does not set this value in the response, an empty value is
    /// returned. For example, if a custom attribute represents the trace ID, your model can
    /// prepend the custom attribute with <code>Trace ID:</code> in your post-processing
    /// function.</p>
    /// <p>This feature is currently supported in the AWS SDKs but not in the Amazon SageMaker Python
    /// SDK.</p>
    pub custom_attributes: std::option::Option<std::string::String>,
    /// <p>The model to request for inference when invoking a multi-model endpoint.</p>
    pub target_model: std::option::Option<std::string::String>,
    /// <p>Specify the production variant to send the inference request to when invoking an
    /// endpoint that is running two or more variants. Note that this parameter overrides the
    /// default behavior for the endpoint, which is to distribute the invocation traffic based
    /// on the variant weights.</p>
    /// <p>For information about how to use variant targeting to perform a/b testing, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-ab-testing.html">Test models in
    /// production</a>
    /// </p>
    pub target_variant: std::option::Option<std::string::String>,
    /// <p>If the endpoint hosts multiple containers and is configured to use direct invocation,
    /// this parameter specifies the host name of the container to invoke.</p>
    pub target_container_hostname: std::option::Option<std::string::String>,
    /// <p>If you provide a value, it is added to the captured data when you enable data capture
    /// on the endpoint. For information about data capture, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-monitor-data-capture.html">Capture
    /// Data</a>.</p>
    pub inference_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvokeEndpointInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvokeEndpointInput");
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field("body", &"*** Sensitive Data Redacted ***");
        formatter.field("content_type", &self.content_type);
        formatter.field("accept", &self.accept);
        formatter.field("custom_attributes", &"*** Sensitive Data Redacted ***");
        formatter.field("target_model", &self.target_model);
        formatter.field("target_variant", &self.target_variant);
        formatter.field("target_container_hostname", &self.target_container_hostname);
        formatter.field("inference_id", &self.inference_id);
        formatter.finish()
    }
}
