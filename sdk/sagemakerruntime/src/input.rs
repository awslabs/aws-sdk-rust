// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`InvokeEndpointInput`](crate::input::InvokeEndpointInput)
pub mod invoke_endpoint_input {
    /// A builder for [`InvokeEndpointInput`](crate::input::InvokeEndpointInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
        pub(crate) body: std::option::Option<smithy_types::Blob>,
        pub(crate) content_type: std::option::Option<std::string::String>,
        pub(crate) accept: std::option::Option<std::string::String>,
        pub(crate) custom_attributes: std::option::Option<std::string::String>,
        pub(crate) target_model: std::option::Option<std::string::String>,
        pub(crate) target_variant: std::option::Option<std::string::String>,
        pub(crate) target_container_hostname: std::option::Option<std::string::String>,
        pub(crate) inference_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the endpoint that you specified when you created the endpoint using the
        /// <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/API_CreateEndpoint.html">CreateEndpoint</a> API. </p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// <p>Provides input data, in the format specified in the <code>ContentType</code>
        /// request header. Amazon SageMaker passes all of the data in the body to the model. </p>
        /// <p>For information about the format of the request body, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/cdf-inference.html">Common Data
        /// Formats-Inference</a>.</p>
        pub fn body(mut self, input: smithy_types::Blob) -> Self {
            self.body = Some(input);
            self
        }
        pub fn set_body(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.body = input;
            self
        }
        /// <p>The MIME type of the input data in the request body.</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// <p>The desired MIME type of the inference in the response.</p>
        pub fn accept(mut self, input: impl Into<std::string::String>) -> Self {
            self.accept = Some(input.into());
            self
        }
        pub fn set_accept(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.accept = input;
            self
        }
        /// <p>Provides additional information about a request for an inference submitted to a model
        /// hosted at an Amazon SageMaker endpoint. The information is an opaque value that is
        /// forwarded verbatim. You could use this value, for example, to provide an ID that you can
        /// use to track a request or to provide other metadata that a service endpoint was
        /// programmed to process. The value must consist of no more than 1024 visible US-ASCII
        /// characters as specified in <a href="https://tools.ietf.org/html/rfc7230#section-3.2.6">Section 3.3.6. Field Value
        /// Components</a> of the Hypertext Transfer Protocol (HTTP/1.1). </p>
        /// <p>The code in your model is responsible for setting or updating any custom attributes in
        /// the response. If your code does not set this value in the response, an empty value is
        /// returned. For example, if a custom attribute represents the trace ID, your model can
        /// prepend the custom attribute with <code>Trace ID:</code> in your post-processing
        /// function.</p>
        /// <p>This feature is currently supported in the AWS SDKs but not in the Amazon SageMaker Python
        /// SDK.</p>
        pub fn custom_attributes(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_attributes = Some(input.into());
            self
        }
        pub fn set_custom_attributes(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.custom_attributes = input;
            self
        }
        /// <p>The model to request for inference when invoking a multi-model endpoint.</p>
        pub fn target_model(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_model = Some(input.into());
            self
        }
        pub fn set_target_model(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_model = input;
            self
        }
        /// <p>Specify the production variant to send the inference request to when invoking an
        /// endpoint that is running two or more variants. Note that this parameter overrides the
        /// default behavior for the endpoint, which is to distribute the invocation traffic based
        /// on the variant weights.</p>
        /// <p>For information about how to use variant targeting to perform a/b testing, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-ab-testing.html">Test models in
        /// production</a>
        /// </p>
        pub fn target_variant(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_variant = Some(input.into());
            self
        }
        pub fn set_target_variant(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_variant = input;
            self
        }
        /// <p>If the endpoint hosts multiple containers and is configured to use direct invocation,
        /// this parameter specifies the host name of the container to invoke.</p>
        pub fn target_container_hostname(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_container_hostname = Some(input.into());
            self
        }
        pub fn set_target_container_hostname(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_container_hostname = input;
            self
        }
        /// <p>If you provide a value, it is added to the captured data when you enable data capture
        /// on the endpoint. For information about data capture, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-monitor-data-capture.html">Capture
        /// Data</a>.</p>
        pub fn inference_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inference_id = Some(input.into());
            self
        }
        pub fn set_inference_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inference_id = input;
            self
        }
        /// Consumes the builder and constructs a [`InvokeEndpointInput`](crate::input::InvokeEndpointInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::InvokeEndpointInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::InvokeEndpointInput {
                endpoint_name: self.endpoint_name,
                body: self.body,
                content_type: self.content_type,
                accept: self.accept,
                custom_attributes: self.custom_attributes,
                target_model: self.target_model,
                target_variant: self.target_variant,
                target_container_hostname: self.target_container_hostname,
                inference_id: self.inference_id,
            })
        }
    }
}
#[doc(hidden)]
pub type InvokeEndpointInputOperationOutputAlias = crate::operation::InvokeEndpoint;
#[doc(hidden)]
pub type InvokeEndpointInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl InvokeEndpointInput {
    /// Consumes the builder and constructs an Operation<[`InvokeEndpoint`](crate::operation::InvokeEndpoint)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::InvokeEndpoint,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::ser_payload_invoke_endpoint_input(self.body)?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::InvokeEndpoint::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "InvokeEndpoint",
                "sagemakerruntime",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_1 = &self.endpoint_name;
        let input_1 = input_1
            .as_ref()
            .ok_or(smithy_http::operation::BuildError::MissingField {
                field: "endpoint_name",
                details: "cannot be empty or unset",
            })?;
        let endpoint_name = smithy_http::label::fmt_string(input_1, false);
        if endpoint_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "endpoint_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/endpoints/{EndpointName}/invocations",
            EndpointName = endpoint_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_2) = &self.content_type {
            let formatted_3 = AsRef::<str>::as_ref(inner_2);
            if !formatted_3.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_3;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_type",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Content-Type", header_value);
            }
        }
        if let Some(inner_4) = &self.accept {
            let formatted_5 = AsRef::<str>::as_ref(inner_4);
            if !formatted_5.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_5;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "accept",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("Accept", header_value);
            }
        }
        if let Some(inner_6) = &self.custom_attributes {
            let formatted_7 = AsRef::<str>::as_ref(inner_6);
            if !formatted_7.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_7;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "custom_attributes",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        }
                    })?;
                builder = builder.header("X-Amzn-SageMaker-Custom-Attributes", header_value);
            }
        }
        if let Some(inner_8) = &self.target_model {
            let formatted_9 = AsRef::<str>::as_ref(inner_8);
            if !formatted_9.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_9;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "target_model",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("X-Amzn-SageMaker-Target-Model", header_value);
            }
        }
        if let Some(inner_10) = &self.target_variant {
            let formatted_11 = AsRef::<str>::as_ref(inner_10);
            if !formatted_11.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_11;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "target_variant",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("X-Amzn-SageMaker-Target-Variant", header_value);
            }
        }
        if let Some(inner_12) = &self.target_container_hostname {
            let formatted_13 = AsRef::<str>::as_ref(inner_12);
            if !formatted_13.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_13;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "target_container_hostname",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder =
                    builder.header("X-Amzn-SageMaker-Target-Container-Hostname", header_value);
            }
        }
        if let Some(inner_14) = &self.inference_id {
            let formatted_15 = AsRef::<str>::as_ref(inner_14);
            if !formatted_15.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_15;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "inference_id",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("X-Amzn-SageMaker-Inference-Id", header_value);
            }
        }
        Ok(builder)
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        let builder = self.add_headers(builder)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/octet-stream",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`InvokeEndpointInput`](crate::input::InvokeEndpointInput)
    pub fn builder() -> crate::input::invoke_endpoint_input::Builder {
        crate::input::invoke_endpoint_input::Builder::default()
    }
}

/// See [`InvokeEndpointAsyncInput`](crate::input::InvokeEndpointAsyncInput)
pub mod invoke_endpoint_async_input {
    /// A builder for [`InvokeEndpointAsyncInput`](crate::input::InvokeEndpointAsyncInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
        pub(crate) content_type: std::option::Option<std::string::String>,
        pub(crate) accept: std::option::Option<std::string::String>,
        pub(crate) custom_attributes: std::option::Option<std::string::String>,
        pub(crate) inference_id: std::option::Option<std::string::String>,
        pub(crate) input_location: std::option::Option<std::string::String>,
        pub(crate) request_ttl_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the endpoint that you specified when you created the endpoint using
        /// the <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_CreateEndpoint.html">
        /// <code>CreateEndpoint</code>
        /// </a> API.</p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// <p>The MIME type of the input data in the request body.</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// <p>The desired MIME type of the inference in the response.</p>
        pub fn accept(mut self, input: impl Into<std::string::String>) -> Self {
            self.accept = Some(input.into());
            self
        }
        pub fn set_accept(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.accept = input;
            self
        }
        /// <p>Provides additional information about a request for an inference submitted to
        /// a model hosted at an Amazon SageMaker endpoint. The information is an opaque value that is
        /// forwarded verbatim. You could use this value, for example, to provide an ID that you
        /// can use to track a request or to provide other metadata that a service endpoint was
        /// programmed to process. The value must consist of no more than 1024
        /// visible US-ASCII characters as specified in
        /// <a href="https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6">Section 3.3.6.
        /// Field Value Components</a> of the Hypertext Transfer Protocol (HTTP/1.1). </p>
        /// <p>The code in your model is responsible for setting or updating any custom attributes
        /// in the response. If your code does not set this value in the response, an empty
        /// value is returned. For example, if a custom attribute represents the trace ID,
        /// your model can prepend the custom attribute with <code>Trace ID</code>: in your post-processing function. </p>
        /// <p>This feature is currently supported in the AWS SDKs but not in the Amazon SageMaker Python SDK. </p>
        pub fn custom_attributes(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_attributes = Some(input.into());
            self
        }
        pub fn set_custom_attributes(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.custom_attributes = input;
            self
        }
        /// <p>The identifier for the inference request. Amazon SageMaker will generate an identifier for you
        /// if none is specified. </p>
        pub fn inference_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inference_id = Some(input.into());
            self
        }
        pub fn set_inference_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inference_id = input;
            self
        }
        /// <p>The Amazon S3 URI where the inference request payload is stored.</p>
        pub fn input_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_location = Some(input.into());
            self
        }
        pub fn set_input_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.input_location = input;
            self
        }
        /// <p>Maximum age in seconds a request can be in the queue before it is marked as expired.</p>
        pub fn request_ttl_seconds(mut self, input: i32) -> Self {
            self.request_ttl_seconds = Some(input);
            self
        }
        pub fn set_request_ttl_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.request_ttl_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`InvokeEndpointAsyncInput`](crate::input::InvokeEndpointAsyncInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::InvokeEndpointAsyncInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::InvokeEndpointAsyncInput {
                endpoint_name: self.endpoint_name,
                content_type: self.content_type,
                accept: self.accept,
                custom_attributes: self.custom_attributes,
                inference_id: self.inference_id,
                input_location: self.input_location,
                request_ttl_seconds: self.request_ttl_seconds,
            })
        }
    }
}
#[doc(hidden)]
pub type InvokeEndpointAsyncInputOperationOutputAlias = crate::operation::InvokeEndpointAsync;
#[doc(hidden)]
pub type InvokeEndpointAsyncInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl InvokeEndpointAsyncInput {
    /// Consumes the builder and constructs an Operation<[`InvokeEndpointAsync`](crate::operation::InvokeEndpointAsync)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::InvokeEndpointAsync,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::InvokeEndpointAsync::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "InvokeEndpointAsync",
                "sagemakerruntime",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_16 = &self.endpoint_name;
        let input_16 =
            input_16
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "endpoint_name",
                    details: "cannot be empty or unset",
                })?;
        let endpoint_name = smithy_http::label::fmt_string(input_16, false);
        if endpoint_name.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "endpoint_name",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/endpoints/{EndpointName}/async-invocations",
            EndpointName = endpoint_name
        )
        .expect("formatting should succeed");
        Ok(())
    }
    fn add_headers(
        &self,
        mut builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        if let Some(inner_17) = &self.content_type {
            let formatted_18 = AsRef::<str>::as_ref(inner_17);
            if !formatted_18.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_18;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "content_type",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("X-Amzn-SageMaker-Content-Type", header_value);
            }
        }
        if let Some(inner_19) = &self.accept {
            let formatted_20 = AsRef::<str>::as_ref(inner_19);
            if !formatted_20.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_20;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "accept",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("X-Amzn-SageMaker-Accept", header_value);
            }
        }
        if let Some(inner_21) = &self.custom_attributes {
            let formatted_22 = AsRef::<str>::as_ref(inner_21);
            if !formatted_22.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_22;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "custom_attributes",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &"*** Sensitive Data Redacted ***", err
                            ),
                        }
                    })?;
                builder = builder.header("X-Amzn-SageMaker-Custom-Attributes", header_value);
            }
        }
        if let Some(inner_23) = &self.inference_id {
            let formatted_24 = AsRef::<str>::as_ref(inner_23);
            if !formatted_24.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_24;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "inference_id",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("X-Amzn-SageMaker-Inference-Id", header_value);
            }
        }
        if let Some(inner_25) = &self.input_location {
            let formatted_26 = AsRef::<str>::as_ref(inner_25);
            if !formatted_26.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_26;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "input_location",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("X-Amzn-SageMaker-InputLocation", header_value);
            }
        }
        if let Some(inner_27) = &self.request_ttl_seconds {
            let mut encoder = smithy_types::primitive::Encoder::from(*inner_27);
            let formatted_28 = encoder.encode();
            if !formatted_28.is_empty() {
                use std::convert::TryFrom;
                let header_value = formatted_28;
                let header_value =
                    http::header::HeaderValue::try_from(&*header_value).map_err(|err| {
                        smithy_http::operation::BuildError::InvalidField {
                            field: "request_ttl_seconds",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        }
                    })?;
                builder = builder.header("X-Amzn-SageMaker-RequestTTLSeconds", header_value);
            }
        }
        Ok(builder)
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        let builder = self.add_headers(builder)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/json",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`InvokeEndpointAsyncInput`](crate::input::InvokeEndpointAsyncInput)
    pub fn builder() -> crate::input::invoke_endpoint_async_input::Builder {
        crate::input::invoke_endpoint_async_input::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvokeEndpointAsyncInput {
    /// <p>The name of the endpoint that you specified when you created the endpoint using
    /// the <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_CreateEndpoint.html">
    /// <code>CreateEndpoint</code>
    /// </a> API.</p>
    pub endpoint_name: std::option::Option<std::string::String>,
    /// <p>The MIME type of the input data in the request body.</p>
    pub content_type: std::option::Option<std::string::String>,
    /// <p>The desired MIME type of the inference in the response.</p>
    pub accept: std::option::Option<std::string::String>,
    /// <p>Provides additional information about a request for an inference submitted to
    /// a model hosted at an Amazon SageMaker endpoint. The information is an opaque value that is
    /// forwarded verbatim. You could use this value, for example, to provide an ID that you
    /// can use to track a request or to provide other metadata that a service endpoint was
    /// programmed to process. The value must consist of no more than 1024
    /// visible US-ASCII characters as specified in
    /// <a href="https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6">Section 3.3.6.
    /// Field Value Components</a> of the Hypertext Transfer Protocol (HTTP/1.1). </p>
    /// <p>The code in your model is responsible for setting or updating any custom attributes
    /// in the response. If your code does not set this value in the response, an empty
    /// value is returned. For example, if a custom attribute represents the trace ID,
    /// your model can prepend the custom attribute with <code>Trace ID</code>: in your post-processing function. </p>
    /// <p>This feature is currently supported in the AWS SDKs but not in the Amazon SageMaker Python SDK. </p>
    pub custom_attributes: std::option::Option<std::string::String>,
    /// <p>The identifier for the inference request. Amazon SageMaker will generate an identifier for you
    /// if none is specified. </p>
    pub inference_id: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 URI where the inference request payload is stored.</p>
    pub input_location: std::option::Option<std::string::String>,
    /// <p>Maximum age in seconds a request can be in the queue before it is marked as expired.</p>
    pub request_ttl_seconds: std::option::Option<i32>,
}
impl std::fmt::Debug for InvokeEndpointAsyncInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvokeEndpointAsyncInput");
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field("content_type", &self.content_type);
        formatter.field("accept", &self.accept);
        formatter.field("custom_attributes", &"*** Sensitive Data Redacted ***");
        formatter.field("inference_id", &self.inference_id);
        formatter.field("input_location", &self.input_location);
        formatter.field("request_ttl_seconds", &self.request_ttl_seconds);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvokeEndpointInput {
    /// <p>The name of the endpoint that you specified when you created the endpoint using the
    /// <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/API_CreateEndpoint.html">CreateEndpoint</a> API. </p>
    pub endpoint_name: std::option::Option<std::string::String>,
    /// <p>Provides input data, in the format specified in the <code>ContentType</code>
    /// request header. Amazon SageMaker passes all of the data in the body to the model. </p>
    /// <p>For information about the format of the request body, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/cdf-inference.html">Common Data
    /// Formats-Inference</a>.</p>
    pub body: std::option::Option<smithy_types::Blob>,
    /// <p>The MIME type of the input data in the request body.</p>
    pub content_type: std::option::Option<std::string::String>,
    /// <p>The desired MIME type of the inference in the response.</p>
    pub accept: std::option::Option<std::string::String>,
    /// <p>Provides additional information about a request for an inference submitted to a model
    /// hosted at an Amazon SageMaker endpoint. The information is an opaque value that is
    /// forwarded verbatim. You could use this value, for example, to provide an ID that you can
    /// use to track a request or to provide other metadata that a service endpoint was
    /// programmed to process. The value must consist of no more than 1024 visible US-ASCII
    /// characters as specified in <a href="https://tools.ietf.org/html/rfc7230#section-3.2.6">Section 3.3.6. Field Value
    /// Components</a> of the Hypertext Transfer Protocol (HTTP/1.1). </p>
    /// <p>The code in your model is responsible for setting or updating any custom attributes in
    /// the response. If your code does not set this value in the response, an empty value is
    /// returned. For example, if a custom attribute represents the trace ID, your model can
    /// prepend the custom attribute with <code>Trace ID:</code> in your post-processing
    /// function.</p>
    /// <p>This feature is currently supported in the AWS SDKs but not in the Amazon SageMaker Python
    /// SDK.</p>
    pub custom_attributes: std::option::Option<std::string::String>,
    /// <p>The model to request for inference when invoking a multi-model endpoint.</p>
    pub target_model: std::option::Option<std::string::String>,
    /// <p>Specify the production variant to send the inference request to when invoking an
    /// endpoint that is running two or more variants. Note that this parameter overrides the
    /// default behavior for the endpoint, which is to distribute the invocation traffic based
    /// on the variant weights.</p>
    /// <p>For information about how to use variant targeting to perform a/b testing, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-ab-testing.html">Test models in
    /// production</a>
    /// </p>
    pub target_variant: std::option::Option<std::string::String>,
    /// <p>If the endpoint hosts multiple containers and is configured to use direct invocation,
    /// this parameter specifies the host name of the container to invoke.</p>
    pub target_container_hostname: std::option::Option<std::string::String>,
    /// <p>If you provide a value, it is added to the captured data when you enable data capture
    /// on the endpoint. For information about data capture, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-monitor-data-capture.html">Capture
    /// Data</a>.</p>
    pub inference_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvokeEndpointInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvokeEndpointInput");
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field("body", &"*** Sensitive Data Redacted ***");
        formatter.field("content_type", &self.content_type);
        formatter.field("accept", &self.accept);
        formatter.field("custom_attributes", &"*** Sensitive Data Redacted ***");
        formatter.field("target_model", &self.target_model);
        formatter.field("target_variant", &self.target_variant);
        formatter.field("target_container_hostname", &self.target_container_hostname);
        formatter.field("inference_id", &self.inference_id);
        formatter.finish()
    }
}
