// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A structure containing an SLO budget report that you have requested.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ServiceLevelObjectiveBudgetReport {
    /// <p>The ARN of the SLO that this report is for.</p>
    pub arn: ::std::string::String,
    /// <p>The name of the SLO that this report is for.</p>
    pub name: ::std::string::String,
    /// <p>Displays whether this budget report is for a period-based SLO or a request-based SLO.</p>
    pub evaluation_type: ::std::option::Option<crate::types::EvaluationType>,
    /// <p>The status of this SLO, as it relates to the error budget for the entire time interval.</p>
    /// <ul>
    /// <li>
    /// <p><code>OK</code> means that the SLO had remaining budget above the warning threshold, as of the time that you specified in <code>TimeStamp</code>.</p></li>
    /// <li>
    /// <p><code>WARNING</code> means that the SLO's remaining budget was below the warning threshold, as of the time that you specified in <code>TimeStamp</code>.</p></li>
    /// <li>
    /// <p><code>BREACHED</code> means that the SLO's budget was exhausted, as of the time that you specified in <code>TimeStamp</code>.</p></li>
    /// <li>
    /// <p><code>INSUFFICIENT_DATA</code> means that the specified start and end times were before the SLO was created, or that attainment data is missing.</p></li>
    /// </ul>
    pub budget_status: crate::types::ServiceLevelObjectiveBudgetStatus,
    /// <p>A number between 0 and 100 that represents the success percentage of your application compared to the goal set by the SLO.</p>
    /// <p>If this is a period-based SLO, the number is the percentage of time periods that the service has attained the SLO's attainment goal, as of the time of the request.</p>
    /// <p>If this is a request-based SLO, the number is the number of successful requests divided by the number of total requests, multiplied by 100, during the time range that you specified in your request.</p>
    pub attainment: ::std::option::Option<f64>,
    /// <p>The total number of seconds in the error budget for the interval. This field is included only if the SLO is a period-based SLO.</p>
    pub total_budget_seconds: ::std::option::Option<i32>,
    /// <p>The budget amount remaining before the SLO status becomes <code>BREACHING</code>, at the time specified in the <code>Timestemp</code> parameter of the request. If this value is negative, then the SLO is already in <code>BREACHING</code> status.</p>
    /// <p>This field is included only if the SLO is a period-based SLO.</p>
    pub budget_seconds_remaining: ::std::option::Option<i32>,
    /// <p>This field is displayed only for request-based SLOs. It displays the total number of failed requests that can be tolerated during the time range between the start of the interval and the time stamp supplied in the budget report request. It is based on the total number of requests that occurred, and the percentage specified in the attainment goal. If the number of failed requests matches this number or is higher, then this SLO is currently breaching.</p>
    /// <p>This number can go up and down between reports with different time stamps, based on both how many total requests occur.</p>
    pub total_budget_requests: ::std::option::Option<i32>,
    /// <p>This field is displayed only for request-based SLOs. It displays the number of failed requests that can be tolerated before any more successful requests occur, and still have the application meet its SLO goal.</p>
    /// <p>This number can go up and down between different reports, based on both how many successful requests and how many failed requests occur in that time.</p>
    pub budget_requests_remaining: ::std::option::Option<i32>,
    /// <p>A structure that contains information about the performance metric that this SLO monitors.</p>
    pub sli: ::std::option::Option<crate::types::ServiceLevelIndicator>,
    /// <p>This structure contains information about the performance metric that a request-based SLO monitors.</p>
    pub request_based_sli: ::std::option::Option<crate::types::RequestBasedServiceLevelIndicator>,
    /// <p>This structure contains the attributes that determine the goal of an SLO. This includes the time period for evaluation and the attainment threshold.</p>
    pub goal: ::std::option::Option<crate::types::Goal>,
}
impl ServiceLevelObjectiveBudgetReport {
    /// <p>The ARN of the SLO that this report is for.</p>
    pub fn arn(&self) -> &str {
        use std::ops::Deref;
        self.arn.deref()
    }
    /// <p>The name of the SLO that this report is for.</p>
    pub fn name(&self) -> &str {
        use std::ops::Deref;
        self.name.deref()
    }
    /// <p>Displays whether this budget report is for a period-based SLO or a request-based SLO.</p>
    pub fn evaluation_type(&self) -> ::std::option::Option<&crate::types::EvaluationType> {
        self.evaluation_type.as_ref()
    }
    /// <p>The status of this SLO, as it relates to the error budget for the entire time interval.</p>
    /// <ul>
    /// <li>
    /// <p><code>OK</code> means that the SLO had remaining budget above the warning threshold, as of the time that you specified in <code>TimeStamp</code>.</p></li>
    /// <li>
    /// <p><code>WARNING</code> means that the SLO's remaining budget was below the warning threshold, as of the time that you specified in <code>TimeStamp</code>.</p></li>
    /// <li>
    /// <p><code>BREACHED</code> means that the SLO's budget was exhausted, as of the time that you specified in <code>TimeStamp</code>.</p></li>
    /// <li>
    /// <p><code>INSUFFICIENT_DATA</code> means that the specified start and end times were before the SLO was created, or that attainment data is missing.</p></li>
    /// </ul>
    pub fn budget_status(&self) -> &crate::types::ServiceLevelObjectiveBudgetStatus {
        &self.budget_status
    }
    /// <p>A number between 0 and 100 that represents the success percentage of your application compared to the goal set by the SLO.</p>
    /// <p>If this is a period-based SLO, the number is the percentage of time periods that the service has attained the SLO's attainment goal, as of the time of the request.</p>
    /// <p>If this is a request-based SLO, the number is the number of successful requests divided by the number of total requests, multiplied by 100, during the time range that you specified in your request.</p>
    pub fn attainment(&self) -> ::std::option::Option<f64> {
        self.attainment
    }
    /// <p>The total number of seconds in the error budget for the interval. This field is included only if the SLO is a period-based SLO.</p>
    pub fn total_budget_seconds(&self) -> ::std::option::Option<i32> {
        self.total_budget_seconds
    }
    /// <p>The budget amount remaining before the SLO status becomes <code>BREACHING</code>, at the time specified in the <code>Timestemp</code> parameter of the request. If this value is negative, then the SLO is already in <code>BREACHING</code> status.</p>
    /// <p>This field is included only if the SLO is a period-based SLO.</p>
    pub fn budget_seconds_remaining(&self) -> ::std::option::Option<i32> {
        self.budget_seconds_remaining
    }
    /// <p>This field is displayed only for request-based SLOs. It displays the total number of failed requests that can be tolerated during the time range between the start of the interval and the time stamp supplied in the budget report request. It is based on the total number of requests that occurred, and the percentage specified in the attainment goal. If the number of failed requests matches this number or is higher, then this SLO is currently breaching.</p>
    /// <p>This number can go up and down between reports with different time stamps, based on both how many total requests occur.</p>
    pub fn total_budget_requests(&self) -> ::std::option::Option<i32> {
        self.total_budget_requests
    }
    /// <p>This field is displayed only for request-based SLOs. It displays the number of failed requests that can be tolerated before any more successful requests occur, and still have the application meet its SLO goal.</p>
    /// <p>This number can go up and down between different reports, based on both how many successful requests and how many failed requests occur in that time.</p>
    pub fn budget_requests_remaining(&self) -> ::std::option::Option<i32> {
        self.budget_requests_remaining
    }
    /// <p>A structure that contains information about the performance metric that this SLO monitors.</p>
    pub fn sli(&self) -> ::std::option::Option<&crate::types::ServiceLevelIndicator> {
        self.sli.as_ref()
    }
    /// <p>This structure contains information about the performance metric that a request-based SLO monitors.</p>
    pub fn request_based_sli(&self) -> ::std::option::Option<&crate::types::RequestBasedServiceLevelIndicator> {
        self.request_based_sli.as_ref()
    }
    /// <p>This structure contains the attributes that determine the goal of an SLO. This includes the time period for evaluation and the attainment threshold.</p>
    pub fn goal(&self) -> ::std::option::Option<&crate::types::Goal> {
        self.goal.as_ref()
    }
}
impl ServiceLevelObjectiveBudgetReport {
    /// Creates a new builder-style object to manufacture [`ServiceLevelObjectiveBudgetReport`](crate::types::ServiceLevelObjectiveBudgetReport).
    pub fn builder() -> crate::types::builders::ServiceLevelObjectiveBudgetReportBuilder {
        crate::types::builders::ServiceLevelObjectiveBudgetReportBuilder::default()
    }
}

/// A builder for [`ServiceLevelObjectiveBudgetReport`](crate::types::ServiceLevelObjectiveBudgetReport).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct ServiceLevelObjectiveBudgetReportBuilder {
    pub(crate) arn: ::std::option::Option<::std::string::String>,
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) evaluation_type: ::std::option::Option<crate::types::EvaluationType>,
    pub(crate) budget_status: ::std::option::Option<crate::types::ServiceLevelObjectiveBudgetStatus>,
    pub(crate) attainment: ::std::option::Option<f64>,
    pub(crate) total_budget_seconds: ::std::option::Option<i32>,
    pub(crate) budget_seconds_remaining: ::std::option::Option<i32>,
    pub(crate) total_budget_requests: ::std::option::Option<i32>,
    pub(crate) budget_requests_remaining: ::std::option::Option<i32>,
    pub(crate) sli: ::std::option::Option<crate::types::ServiceLevelIndicator>,
    pub(crate) request_based_sli: ::std::option::Option<crate::types::RequestBasedServiceLevelIndicator>,
    pub(crate) goal: ::std::option::Option<crate::types::Goal>,
}
impl ServiceLevelObjectiveBudgetReportBuilder {
    /// <p>The ARN of the SLO that this report is for.</p>
    /// This field is required.
    pub fn arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN of the SLO that this report is for.</p>
    pub fn set_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.arn = input;
        self
    }
    /// <p>The ARN of the SLO that this report is for.</p>
    pub fn get_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.arn
    }
    /// <p>The name of the SLO that this report is for.</p>
    /// This field is required.
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the SLO that this report is for.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The name of the SLO that this report is for.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>Displays whether this budget report is for a period-based SLO or a request-based SLO.</p>
    pub fn evaluation_type(mut self, input: crate::types::EvaluationType) -> Self {
        self.evaluation_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>Displays whether this budget report is for a period-based SLO or a request-based SLO.</p>
    pub fn set_evaluation_type(mut self, input: ::std::option::Option<crate::types::EvaluationType>) -> Self {
        self.evaluation_type = input;
        self
    }
    /// <p>Displays whether this budget report is for a period-based SLO or a request-based SLO.</p>
    pub fn get_evaluation_type(&self) -> &::std::option::Option<crate::types::EvaluationType> {
        &self.evaluation_type
    }
    /// <p>The status of this SLO, as it relates to the error budget for the entire time interval.</p>
    /// <ul>
    /// <li>
    /// <p><code>OK</code> means that the SLO had remaining budget above the warning threshold, as of the time that you specified in <code>TimeStamp</code>.</p></li>
    /// <li>
    /// <p><code>WARNING</code> means that the SLO's remaining budget was below the warning threshold, as of the time that you specified in <code>TimeStamp</code>.</p></li>
    /// <li>
    /// <p><code>BREACHED</code> means that the SLO's budget was exhausted, as of the time that you specified in <code>TimeStamp</code>.</p></li>
    /// <li>
    /// <p><code>INSUFFICIENT_DATA</code> means that the specified start and end times were before the SLO was created, or that attainment data is missing.</p></li>
    /// </ul>
    /// This field is required.
    pub fn budget_status(mut self, input: crate::types::ServiceLevelObjectiveBudgetStatus) -> Self {
        self.budget_status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The status of this SLO, as it relates to the error budget for the entire time interval.</p>
    /// <ul>
    /// <li>
    /// <p><code>OK</code> means that the SLO had remaining budget above the warning threshold, as of the time that you specified in <code>TimeStamp</code>.</p></li>
    /// <li>
    /// <p><code>WARNING</code> means that the SLO's remaining budget was below the warning threshold, as of the time that you specified in <code>TimeStamp</code>.</p></li>
    /// <li>
    /// <p><code>BREACHED</code> means that the SLO's budget was exhausted, as of the time that you specified in <code>TimeStamp</code>.</p></li>
    /// <li>
    /// <p><code>INSUFFICIENT_DATA</code> means that the specified start and end times were before the SLO was created, or that attainment data is missing.</p></li>
    /// </ul>
    pub fn set_budget_status(mut self, input: ::std::option::Option<crate::types::ServiceLevelObjectiveBudgetStatus>) -> Self {
        self.budget_status = input;
        self
    }
    /// <p>The status of this SLO, as it relates to the error budget for the entire time interval.</p>
    /// <ul>
    /// <li>
    /// <p><code>OK</code> means that the SLO had remaining budget above the warning threshold, as of the time that you specified in <code>TimeStamp</code>.</p></li>
    /// <li>
    /// <p><code>WARNING</code> means that the SLO's remaining budget was below the warning threshold, as of the time that you specified in <code>TimeStamp</code>.</p></li>
    /// <li>
    /// <p><code>BREACHED</code> means that the SLO's budget was exhausted, as of the time that you specified in <code>TimeStamp</code>.</p></li>
    /// <li>
    /// <p><code>INSUFFICIENT_DATA</code> means that the specified start and end times were before the SLO was created, or that attainment data is missing.</p></li>
    /// </ul>
    pub fn get_budget_status(&self) -> &::std::option::Option<crate::types::ServiceLevelObjectiveBudgetStatus> {
        &self.budget_status
    }
    /// <p>A number between 0 and 100 that represents the success percentage of your application compared to the goal set by the SLO.</p>
    /// <p>If this is a period-based SLO, the number is the percentage of time periods that the service has attained the SLO's attainment goal, as of the time of the request.</p>
    /// <p>If this is a request-based SLO, the number is the number of successful requests divided by the number of total requests, multiplied by 100, during the time range that you specified in your request.</p>
    pub fn attainment(mut self, input: f64) -> Self {
        self.attainment = ::std::option::Option::Some(input);
        self
    }
    /// <p>A number between 0 and 100 that represents the success percentage of your application compared to the goal set by the SLO.</p>
    /// <p>If this is a period-based SLO, the number is the percentage of time periods that the service has attained the SLO's attainment goal, as of the time of the request.</p>
    /// <p>If this is a request-based SLO, the number is the number of successful requests divided by the number of total requests, multiplied by 100, during the time range that you specified in your request.</p>
    pub fn set_attainment(mut self, input: ::std::option::Option<f64>) -> Self {
        self.attainment = input;
        self
    }
    /// <p>A number between 0 and 100 that represents the success percentage of your application compared to the goal set by the SLO.</p>
    /// <p>If this is a period-based SLO, the number is the percentage of time periods that the service has attained the SLO's attainment goal, as of the time of the request.</p>
    /// <p>If this is a request-based SLO, the number is the number of successful requests divided by the number of total requests, multiplied by 100, during the time range that you specified in your request.</p>
    pub fn get_attainment(&self) -> &::std::option::Option<f64> {
        &self.attainment
    }
    /// <p>The total number of seconds in the error budget for the interval. This field is included only if the SLO is a period-based SLO.</p>
    pub fn total_budget_seconds(mut self, input: i32) -> Self {
        self.total_budget_seconds = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total number of seconds in the error budget for the interval. This field is included only if the SLO is a period-based SLO.</p>
    pub fn set_total_budget_seconds(mut self, input: ::std::option::Option<i32>) -> Self {
        self.total_budget_seconds = input;
        self
    }
    /// <p>The total number of seconds in the error budget for the interval. This field is included only if the SLO is a period-based SLO.</p>
    pub fn get_total_budget_seconds(&self) -> &::std::option::Option<i32> {
        &self.total_budget_seconds
    }
    /// <p>The budget amount remaining before the SLO status becomes <code>BREACHING</code>, at the time specified in the <code>Timestemp</code> parameter of the request. If this value is negative, then the SLO is already in <code>BREACHING</code> status.</p>
    /// <p>This field is included only if the SLO is a period-based SLO.</p>
    pub fn budget_seconds_remaining(mut self, input: i32) -> Self {
        self.budget_seconds_remaining = ::std::option::Option::Some(input);
        self
    }
    /// <p>The budget amount remaining before the SLO status becomes <code>BREACHING</code>, at the time specified in the <code>Timestemp</code> parameter of the request. If this value is negative, then the SLO is already in <code>BREACHING</code> status.</p>
    /// <p>This field is included only if the SLO is a period-based SLO.</p>
    pub fn set_budget_seconds_remaining(mut self, input: ::std::option::Option<i32>) -> Self {
        self.budget_seconds_remaining = input;
        self
    }
    /// <p>The budget amount remaining before the SLO status becomes <code>BREACHING</code>, at the time specified in the <code>Timestemp</code> parameter of the request. If this value is negative, then the SLO is already in <code>BREACHING</code> status.</p>
    /// <p>This field is included only if the SLO is a period-based SLO.</p>
    pub fn get_budget_seconds_remaining(&self) -> &::std::option::Option<i32> {
        &self.budget_seconds_remaining
    }
    /// <p>This field is displayed only for request-based SLOs. It displays the total number of failed requests that can be tolerated during the time range between the start of the interval and the time stamp supplied in the budget report request. It is based on the total number of requests that occurred, and the percentage specified in the attainment goal. If the number of failed requests matches this number or is higher, then this SLO is currently breaching.</p>
    /// <p>This number can go up and down between reports with different time stamps, based on both how many total requests occur.</p>
    pub fn total_budget_requests(mut self, input: i32) -> Self {
        self.total_budget_requests = ::std::option::Option::Some(input);
        self
    }
    /// <p>This field is displayed only for request-based SLOs. It displays the total number of failed requests that can be tolerated during the time range between the start of the interval and the time stamp supplied in the budget report request. It is based on the total number of requests that occurred, and the percentage specified in the attainment goal. If the number of failed requests matches this number or is higher, then this SLO is currently breaching.</p>
    /// <p>This number can go up and down between reports with different time stamps, based on both how many total requests occur.</p>
    pub fn set_total_budget_requests(mut self, input: ::std::option::Option<i32>) -> Self {
        self.total_budget_requests = input;
        self
    }
    /// <p>This field is displayed only for request-based SLOs. It displays the total number of failed requests that can be tolerated during the time range between the start of the interval and the time stamp supplied in the budget report request. It is based on the total number of requests that occurred, and the percentage specified in the attainment goal. If the number of failed requests matches this number or is higher, then this SLO is currently breaching.</p>
    /// <p>This number can go up and down between reports with different time stamps, based on both how many total requests occur.</p>
    pub fn get_total_budget_requests(&self) -> &::std::option::Option<i32> {
        &self.total_budget_requests
    }
    /// <p>This field is displayed only for request-based SLOs. It displays the number of failed requests that can be tolerated before any more successful requests occur, and still have the application meet its SLO goal.</p>
    /// <p>This number can go up and down between different reports, based on both how many successful requests and how many failed requests occur in that time.</p>
    pub fn budget_requests_remaining(mut self, input: i32) -> Self {
        self.budget_requests_remaining = ::std::option::Option::Some(input);
        self
    }
    /// <p>This field is displayed only for request-based SLOs. It displays the number of failed requests that can be tolerated before any more successful requests occur, and still have the application meet its SLO goal.</p>
    /// <p>This number can go up and down between different reports, based on both how many successful requests and how many failed requests occur in that time.</p>
    pub fn set_budget_requests_remaining(mut self, input: ::std::option::Option<i32>) -> Self {
        self.budget_requests_remaining = input;
        self
    }
    /// <p>This field is displayed only for request-based SLOs. It displays the number of failed requests that can be tolerated before any more successful requests occur, and still have the application meet its SLO goal.</p>
    /// <p>This number can go up and down between different reports, based on both how many successful requests and how many failed requests occur in that time.</p>
    pub fn get_budget_requests_remaining(&self) -> &::std::option::Option<i32> {
        &self.budget_requests_remaining
    }
    /// <p>A structure that contains information about the performance metric that this SLO monitors.</p>
    pub fn sli(mut self, input: crate::types::ServiceLevelIndicator) -> Self {
        self.sli = ::std::option::Option::Some(input);
        self
    }
    /// <p>A structure that contains information about the performance metric that this SLO monitors.</p>
    pub fn set_sli(mut self, input: ::std::option::Option<crate::types::ServiceLevelIndicator>) -> Self {
        self.sli = input;
        self
    }
    /// <p>A structure that contains information about the performance metric that this SLO monitors.</p>
    pub fn get_sli(&self) -> &::std::option::Option<crate::types::ServiceLevelIndicator> {
        &self.sli
    }
    /// <p>This structure contains information about the performance metric that a request-based SLO monitors.</p>
    pub fn request_based_sli(mut self, input: crate::types::RequestBasedServiceLevelIndicator) -> Self {
        self.request_based_sli = ::std::option::Option::Some(input);
        self
    }
    /// <p>This structure contains information about the performance metric that a request-based SLO monitors.</p>
    pub fn set_request_based_sli(mut self, input: ::std::option::Option<crate::types::RequestBasedServiceLevelIndicator>) -> Self {
        self.request_based_sli = input;
        self
    }
    /// <p>This structure contains information about the performance metric that a request-based SLO monitors.</p>
    pub fn get_request_based_sli(&self) -> &::std::option::Option<crate::types::RequestBasedServiceLevelIndicator> {
        &self.request_based_sli
    }
    /// <p>This structure contains the attributes that determine the goal of an SLO. This includes the time period for evaluation and the attainment threshold.</p>
    pub fn goal(mut self, input: crate::types::Goal) -> Self {
        self.goal = ::std::option::Option::Some(input);
        self
    }
    /// <p>This structure contains the attributes that determine the goal of an SLO. This includes the time period for evaluation and the attainment threshold.</p>
    pub fn set_goal(mut self, input: ::std::option::Option<crate::types::Goal>) -> Self {
        self.goal = input;
        self
    }
    /// <p>This structure contains the attributes that determine the goal of an SLO. This includes the time period for evaluation and the attainment threshold.</p>
    pub fn get_goal(&self) -> &::std::option::Option<crate::types::Goal> {
        &self.goal
    }
    /// Consumes the builder and constructs a [`ServiceLevelObjectiveBudgetReport`](crate::types::ServiceLevelObjectiveBudgetReport).
    /// This method will fail if any of the following fields are not set:
    /// - [`arn`](crate::types::builders::ServiceLevelObjectiveBudgetReportBuilder::arn)
    /// - [`name`](crate::types::builders::ServiceLevelObjectiveBudgetReportBuilder::name)
    /// - [`budget_status`](crate::types::builders::ServiceLevelObjectiveBudgetReportBuilder::budget_status)
    pub fn build(self) -> ::std::result::Result<crate::types::ServiceLevelObjectiveBudgetReport, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::ServiceLevelObjectiveBudgetReport {
            arn: self.arn.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "arn",
                    "arn was not specified but it is required when building ServiceLevelObjectiveBudgetReport",
                )
            })?,
            name: self.name.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "name",
                    "name was not specified but it is required when building ServiceLevelObjectiveBudgetReport",
                )
            })?,
            evaluation_type: self.evaluation_type,
            budget_status: self.budget_status.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "budget_status",
                    "budget_status was not specified but it is required when building ServiceLevelObjectiveBudgetReport",
                )
            })?,
            attainment: self.attainment,
            total_budget_seconds: self.total_budget_seconds,
            budget_seconds_remaining: self.budget_seconds_remaining,
            total_budget_requests: self.total_budget_requests,
            budget_requests_remaining: self.budget_requests_remaining,
            sli: self.sli,
            request_based_sli: self.request_based_sli,
            goal: self.goal,
        })
    }
}
