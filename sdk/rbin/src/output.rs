// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateRuleOutput {
    /// <p>The unique ID of the retention rule.</p>
    #[doc(hidden)]
    pub identifier: std::option::Option<std::string::String>,
    /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
    #[doc(hidden)]
    pub retention_period: std::option::Option<crate::model::RetentionPeriod>,
    /// <p>The retention rule description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The resource type retained by the retention rule.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>Information about the resource tags used to identify resources that are retained by the retention rule.</p>
    #[doc(hidden)]
    pub resource_tags: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
    /// <p>The state of the retention rule. Only retention rules that are in the <code>available</code> state retain resources.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::RuleStatus>,
    /// <p>The lock state for the retention rule.</p>
    /// <ul>
    /// <li> <p> <code>locked</code> - The retention rule is locked and can't be modified or deleted.</p> </li>
    /// <li> <p> <code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p> </li>
    /// <li> <p> <code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p> </li>
    /// <li> <p> <code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub lock_state: std::option::Option<crate::model::LockState>,
    /// <p>The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.</p>
    #[doc(hidden)]
    pub lock_end_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl UpdateRuleOutput {
    /// <p>The unique ID of the retention rule.</p>
    pub fn identifier(&self) -> std::option::Option<&str> {
        self.identifier.as_deref()
    }
    /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
    pub fn retention_period(&self) -> std::option::Option<&crate::model::RetentionPeriod> {
        self.retention_period.as_ref()
    }
    /// <p>The retention rule description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The resource type retained by the retention rule.</p>
    pub fn resource_type(&self) -> std::option::Option<&crate::model::ResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>Information about the resource tags used to identify resources that are retained by the retention rule.</p>
    pub fn resource_tags(&self) -> std::option::Option<&[crate::model::ResourceTag]> {
        self.resource_tags.as_deref()
    }
    /// <p>The state of the retention rule. Only retention rules that are in the <code>available</code> state retain resources.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::RuleStatus> {
        self.status.as_ref()
    }
    /// <p>The lock state for the retention rule.</p>
    /// <ul>
    /// <li> <p> <code>locked</code> - The retention rule is locked and can't be modified or deleted.</p> </li>
    /// <li> <p> <code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p> </li>
    /// <li> <p> <code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p> </li>
    /// <li> <p> <code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p> </li>
    /// </ul>
    pub fn lock_state(&self) -> std::option::Option<&crate::model::LockState> {
        self.lock_state.as_ref()
    }
    /// <p>The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.</p>
    pub fn lock_end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.lock_end_time.as_ref()
    }
}
/// See [`UpdateRuleOutput`](crate::output::UpdateRuleOutput).
pub mod update_rule_output {

    /// A builder for [`UpdateRuleOutput`](crate::output::UpdateRuleOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identifier: std::option::Option<std::string::String>,
        pub(crate) retention_period: std::option::Option<crate::model::RetentionPeriod>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) resource_tags: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
        pub(crate) status: std::option::Option<crate::model::RuleStatus>,
        pub(crate) lock_state: std::option::Option<crate::model::LockState>,
        pub(crate) lock_end_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The unique ID of the retention rule.</p>
        pub fn identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.identifier = Some(input.into());
            self
        }
        /// <p>The unique ID of the retention rule.</p>
        pub fn set_identifier(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.identifier = input;
            self
        }
        /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
        pub fn retention_period(mut self, input: crate::model::RetentionPeriod) -> Self {
            self.retention_period = Some(input);
            self
        }
        /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
        pub fn set_retention_period(
            mut self,
            input: std::option::Option<crate::model::RetentionPeriod>,
        ) -> Self {
            self.retention_period = input;
            self
        }
        /// <p>The retention rule description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The retention rule description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The resource type retained by the retention rule.</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>The resource type retained by the retention rule.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Appends an item to `resource_tags`.
        ///
        /// To override the contents of this collection use [`set_resource_tags`](Self::set_resource_tags).
        ///
        /// <p>Information about the resource tags used to identify resources that are retained by the retention rule.</p>
        pub fn resource_tags(mut self, input: crate::model::ResourceTag) -> Self {
            let mut v = self.resource_tags.unwrap_or_default();
            v.push(input);
            self.resource_tags = Some(v);
            self
        }
        /// <p>Information about the resource tags used to identify resources that are retained by the retention rule.</p>
        pub fn set_resource_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
        ) -> Self {
            self.resource_tags = input;
            self
        }
        /// <p>The state of the retention rule. Only retention rules that are in the <code>available</code> state retain resources.</p>
        pub fn status(mut self, input: crate::model::RuleStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The state of the retention rule. Only retention rules that are in the <code>available</code> state retain resources.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::RuleStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>The lock state for the retention rule.</p>
        /// <ul>
        /// <li> <p> <code>locked</code> - The retention rule is locked and can't be modified or deleted.</p> </li>
        /// <li> <p> <code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p> </li>
        /// <li> <p> <code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p> </li>
        /// <li> <p> <code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p> </li>
        /// </ul>
        pub fn lock_state(mut self, input: crate::model::LockState) -> Self {
            self.lock_state = Some(input);
            self
        }
        /// <p>The lock state for the retention rule.</p>
        /// <ul>
        /// <li> <p> <code>locked</code> - The retention rule is locked and can't be modified or deleted.</p> </li>
        /// <li> <p> <code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p> </li>
        /// <li> <p> <code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p> </li>
        /// <li> <p> <code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p> </li>
        /// </ul>
        pub fn set_lock_state(
            mut self,
            input: std::option::Option<crate::model::LockState>,
        ) -> Self {
            self.lock_state = input;
            self
        }
        /// <p>The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.</p>
        pub fn lock_end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.lock_end_time = Some(input);
            self
        }
        /// <p>The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.</p>
        pub fn set_lock_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.lock_end_time = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateRuleOutput`](crate::output::UpdateRuleOutput).
        pub fn build(self) -> crate::output::UpdateRuleOutput {
            crate::output::UpdateRuleOutput {
                identifier: self.identifier,
                retention_period: self.retention_period,
                description: self.description,
                resource_type: self.resource_type,
                resource_tags: self.resource_tags,
                status: self.status,
                lock_state: self.lock_state,
                lock_end_time: self.lock_end_time,
            }
        }
    }
}
impl UpdateRuleOutput {
    /// Creates a new builder-style object to manufacture [`UpdateRuleOutput`](crate::output::UpdateRuleOutput).
    pub fn builder() -> crate::output::update_rule_output::Builder {
        crate::output::update_rule_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UntagResourceOutput {}
/// See [`UntagResourceOutput`](crate::output::UntagResourceOutput).
pub mod untag_resource_output {

    /// A builder for [`UntagResourceOutput`](crate::output::UntagResourceOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`UntagResourceOutput`](crate::output::UntagResourceOutput).
        pub fn build(self) -> crate::output::UntagResourceOutput {
            crate::output::UntagResourceOutput {}
        }
    }
}
impl UntagResourceOutput {
    /// Creates a new builder-style object to manufacture [`UntagResourceOutput`](crate::output::UntagResourceOutput).
    pub fn builder() -> crate::output::untag_resource_output::Builder {
        crate::output::untag_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UnlockRuleOutput {
    /// <p>The unique ID of the retention rule.</p>
    #[doc(hidden)]
    pub identifier: std::option::Option<std::string::String>,
    /// <p>The retention rule description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The resource type retained by the retention rule.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
    #[doc(hidden)]
    pub retention_period: std::option::Option<crate::model::RetentionPeriod>,
    /// <p>Information about the resource tags used to identify resources that are retained by the retention rule.</p>
    #[doc(hidden)]
    pub resource_tags: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
    /// <p>The state of the retention rule. Only retention rules that are in the <code>available</code> state retain resources.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::RuleStatus>,
    /// <p>Information about the retention rule lock configuration.</p>
    #[doc(hidden)]
    pub lock_configuration: std::option::Option<crate::model::LockConfiguration>,
    /// <p>The lock state for the retention rule.</p>
    /// <ul>
    /// <li> <p> <code>locked</code> - The retention rule is locked and can't be modified or deleted.</p> </li>
    /// <li> <p> <code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p> </li>
    /// <li> <p> <code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p> </li>
    /// <li> <p> <code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub lock_state: std::option::Option<crate::model::LockState>,
    /// <p>The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.</p>
    #[doc(hidden)]
    pub lock_end_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl UnlockRuleOutput {
    /// <p>The unique ID of the retention rule.</p>
    pub fn identifier(&self) -> std::option::Option<&str> {
        self.identifier.as_deref()
    }
    /// <p>The retention rule description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The resource type retained by the retention rule.</p>
    pub fn resource_type(&self) -> std::option::Option<&crate::model::ResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
    pub fn retention_period(&self) -> std::option::Option<&crate::model::RetentionPeriod> {
        self.retention_period.as_ref()
    }
    /// <p>Information about the resource tags used to identify resources that are retained by the retention rule.</p>
    pub fn resource_tags(&self) -> std::option::Option<&[crate::model::ResourceTag]> {
        self.resource_tags.as_deref()
    }
    /// <p>The state of the retention rule. Only retention rules that are in the <code>available</code> state retain resources.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::RuleStatus> {
        self.status.as_ref()
    }
    /// <p>Information about the retention rule lock configuration.</p>
    pub fn lock_configuration(&self) -> std::option::Option<&crate::model::LockConfiguration> {
        self.lock_configuration.as_ref()
    }
    /// <p>The lock state for the retention rule.</p>
    /// <ul>
    /// <li> <p> <code>locked</code> - The retention rule is locked and can't be modified or deleted.</p> </li>
    /// <li> <p> <code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p> </li>
    /// <li> <p> <code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p> </li>
    /// <li> <p> <code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p> </li>
    /// </ul>
    pub fn lock_state(&self) -> std::option::Option<&crate::model::LockState> {
        self.lock_state.as_ref()
    }
    /// <p>The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.</p>
    pub fn lock_end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.lock_end_time.as_ref()
    }
}
/// See [`UnlockRuleOutput`](crate::output::UnlockRuleOutput).
pub mod unlock_rule_output {

    /// A builder for [`UnlockRuleOutput`](crate::output::UnlockRuleOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identifier: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) retention_period: std::option::Option<crate::model::RetentionPeriod>,
        pub(crate) resource_tags: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
        pub(crate) status: std::option::Option<crate::model::RuleStatus>,
        pub(crate) lock_configuration: std::option::Option<crate::model::LockConfiguration>,
        pub(crate) lock_state: std::option::Option<crate::model::LockState>,
        pub(crate) lock_end_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The unique ID of the retention rule.</p>
        pub fn identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.identifier = Some(input.into());
            self
        }
        /// <p>The unique ID of the retention rule.</p>
        pub fn set_identifier(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.identifier = input;
            self
        }
        /// <p>The retention rule description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The retention rule description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The resource type retained by the retention rule.</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>The resource type retained by the retention rule.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
        pub fn retention_period(mut self, input: crate::model::RetentionPeriod) -> Self {
            self.retention_period = Some(input);
            self
        }
        /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
        pub fn set_retention_period(
            mut self,
            input: std::option::Option<crate::model::RetentionPeriod>,
        ) -> Self {
            self.retention_period = input;
            self
        }
        /// Appends an item to `resource_tags`.
        ///
        /// To override the contents of this collection use [`set_resource_tags`](Self::set_resource_tags).
        ///
        /// <p>Information about the resource tags used to identify resources that are retained by the retention rule.</p>
        pub fn resource_tags(mut self, input: crate::model::ResourceTag) -> Self {
            let mut v = self.resource_tags.unwrap_or_default();
            v.push(input);
            self.resource_tags = Some(v);
            self
        }
        /// <p>Information about the resource tags used to identify resources that are retained by the retention rule.</p>
        pub fn set_resource_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
        ) -> Self {
            self.resource_tags = input;
            self
        }
        /// <p>The state of the retention rule. Only retention rules that are in the <code>available</code> state retain resources.</p>
        pub fn status(mut self, input: crate::model::RuleStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The state of the retention rule. Only retention rules that are in the <code>available</code> state retain resources.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::RuleStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>Information about the retention rule lock configuration.</p>
        pub fn lock_configuration(mut self, input: crate::model::LockConfiguration) -> Self {
            self.lock_configuration = Some(input);
            self
        }
        /// <p>Information about the retention rule lock configuration.</p>
        pub fn set_lock_configuration(
            mut self,
            input: std::option::Option<crate::model::LockConfiguration>,
        ) -> Self {
            self.lock_configuration = input;
            self
        }
        /// <p>The lock state for the retention rule.</p>
        /// <ul>
        /// <li> <p> <code>locked</code> - The retention rule is locked and can't be modified or deleted.</p> </li>
        /// <li> <p> <code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p> </li>
        /// <li> <p> <code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p> </li>
        /// <li> <p> <code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p> </li>
        /// </ul>
        pub fn lock_state(mut self, input: crate::model::LockState) -> Self {
            self.lock_state = Some(input);
            self
        }
        /// <p>The lock state for the retention rule.</p>
        /// <ul>
        /// <li> <p> <code>locked</code> - The retention rule is locked and can't be modified or deleted.</p> </li>
        /// <li> <p> <code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p> </li>
        /// <li> <p> <code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p> </li>
        /// <li> <p> <code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p> </li>
        /// </ul>
        pub fn set_lock_state(
            mut self,
            input: std::option::Option<crate::model::LockState>,
        ) -> Self {
            self.lock_state = input;
            self
        }
        /// <p>The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.</p>
        pub fn lock_end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.lock_end_time = Some(input);
            self
        }
        /// <p>The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.</p>
        pub fn set_lock_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.lock_end_time = input;
            self
        }
        /// Consumes the builder and constructs a [`UnlockRuleOutput`](crate::output::UnlockRuleOutput).
        pub fn build(self) -> crate::output::UnlockRuleOutput {
            crate::output::UnlockRuleOutput {
                identifier: self.identifier,
                description: self.description,
                resource_type: self.resource_type,
                retention_period: self.retention_period,
                resource_tags: self.resource_tags,
                status: self.status,
                lock_configuration: self.lock_configuration,
                lock_state: self.lock_state,
                lock_end_time: self.lock_end_time,
            }
        }
    }
}
impl UnlockRuleOutput {
    /// Creates a new builder-style object to manufacture [`UnlockRuleOutput`](crate::output::UnlockRuleOutput).
    pub fn builder() -> crate::output::unlock_rule_output::Builder {
        crate::output::unlock_rule_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagResourceOutput {}
/// See [`TagResourceOutput`](crate::output::TagResourceOutput).
pub mod tag_resource_output {

    /// A builder for [`TagResourceOutput`](crate::output::TagResourceOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`TagResourceOutput`](crate::output::TagResourceOutput).
        pub fn build(self) -> crate::output::TagResourceOutput {
            crate::output::TagResourceOutput {}
        }
    }
}
impl TagResourceOutput {
    /// Creates a new builder-style object to manufacture [`TagResourceOutput`](crate::output::TagResourceOutput).
    pub fn builder() -> crate::output::tag_resource_output::Builder {
        crate::output::tag_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LockRuleOutput {
    /// <p>The unique ID of the retention rule.</p>
    #[doc(hidden)]
    pub identifier: std::option::Option<std::string::String>,
    /// <p>The retention rule description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The resource type retained by the retention rule.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
    #[doc(hidden)]
    pub retention_period: std::option::Option<crate::model::RetentionPeriod>,
    /// <p>Information about the resource tags used to identify resources that are retained by the retention rule.</p>
    #[doc(hidden)]
    pub resource_tags: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
    /// <p>The state of the retention rule. Only retention rules that are in the <code>available</code> state retain resources.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::RuleStatus>,
    /// <p>Information about the retention rule lock configuration.</p>
    #[doc(hidden)]
    pub lock_configuration: std::option::Option<crate::model::LockConfiguration>,
    /// <p>The lock state for the retention rule.</p>
    /// <ul>
    /// <li> <p> <code>locked</code> - The retention rule is locked and can't be modified or deleted.</p> </li>
    /// <li> <p> <code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p> </li>
    /// <li> <p> <code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p> </li>
    /// <li> <p> <code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub lock_state: std::option::Option<crate::model::LockState>,
}
impl LockRuleOutput {
    /// <p>The unique ID of the retention rule.</p>
    pub fn identifier(&self) -> std::option::Option<&str> {
        self.identifier.as_deref()
    }
    /// <p>The retention rule description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The resource type retained by the retention rule.</p>
    pub fn resource_type(&self) -> std::option::Option<&crate::model::ResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
    pub fn retention_period(&self) -> std::option::Option<&crate::model::RetentionPeriod> {
        self.retention_period.as_ref()
    }
    /// <p>Information about the resource tags used to identify resources that are retained by the retention rule.</p>
    pub fn resource_tags(&self) -> std::option::Option<&[crate::model::ResourceTag]> {
        self.resource_tags.as_deref()
    }
    /// <p>The state of the retention rule. Only retention rules that are in the <code>available</code> state retain resources.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::RuleStatus> {
        self.status.as_ref()
    }
    /// <p>Information about the retention rule lock configuration.</p>
    pub fn lock_configuration(&self) -> std::option::Option<&crate::model::LockConfiguration> {
        self.lock_configuration.as_ref()
    }
    /// <p>The lock state for the retention rule.</p>
    /// <ul>
    /// <li> <p> <code>locked</code> - The retention rule is locked and can't be modified or deleted.</p> </li>
    /// <li> <p> <code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p> </li>
    /// <li> <p> <code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p> </li>
    /// <li> <p> <code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p> </li>
    /// </ul>
    pub fn lock_state(&self) -> std::option::Option<&crate::model::LockState> {
        self.lock_state.as_ref()
    }
}
/// See [`LockRuleOutput`](crate::output::LockRuleOutput).
pub mod lock_rule_output {

    /// A builder for [`LockRuleOutput`](crate::output::LockRuleOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identifier: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) retention_period: std::option::Option<crate::model::RetentionPeriod>,
        pub(crate) resource_tags: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
        pub(crate) status: std::option::Option<crate::model::RuleStatus>,
        pub(crate) lock_configuration: std::option::Option<crate::model::LockConfiguration>,
        pub(crate) lock_state: std::option::Option<crate::model::LockState>,
    }
    impl Builder {
        /// <p>The unique ID of the retention rule.</p>
        pub fn identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.identifier = Some(input.into());
            self
        }
        /// <p>The unique ID of the retention rule.</p>
        pub fn set_identifier(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.identifier = input;
            self
        }
        /// <p>The retention rule description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The retention rule description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The resource type retained by the retention rule.</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>The resource type retained by the retention rule.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
        pub fn retention_period(mut self, input: crate::model::RetentionPeriod) -> Self {
            self.retention_period = Some(input);
            self
        }
        /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
        pub fn set_retention_period(
            mut self,
            input: std::option::Option<crate::model::RetentionPeriod>,
        ) -> Self {
            self.retention_period = input;
            self
        }
        /// Appends an item to `resource_tags`.
        ///
        /// To override the contents of this collection use [`set_resource_tags`](Self::set_resource_tags).
        ///
        /// <p>Information about the resource tags used to identify resources that are retained by the retention rule.</p>
        pub fn resource_tags(mut self, input: crate::model::ResourceTag) -> Self {
            let mut v = self.resource_tags.unwrap_or_default();
            v.push(input);
            self.resource_tags = Some(v);
            self
        }
        /// <p>Information about the resource tags used to identify resources that are retained by the retention rule.</p>
        pub fn set_resource_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
        ) -> Self {
            self.resource_tags = input;
            self
        }
        /// <p>The state of the retention rule. Only retention rules that are in the <code>available</code> state retain resources.</p>
        pub fn status(mut self, input: crate::model::RuleStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The state of the retention rule. Only retention rules that are in the <code>available</code> state retain resources.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::RuleStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>Information about the retention rule lock configuration.</p>
        pub fn lock_configuration(mut self, input: crate::model::LockConfiguration) -> Self {
            self.lock_configuration = Some(input);
            self
        }
        /// <p>Information about the retention rule lock configuration.</p>
        pub fn set_lock_configuration(
            mut self,
            input: std::option::Option<crate::model::LockConfiguration>,
        ) -> Self {
            self.lock_configuration = input;
            self
        }
        /// <p>The lock state for the retention rule.</p>
        /// <ul>
        /// <li> <p> <code>locked</code> - The retention rule is locked and can't be modified or deleted.</p> </li>
        /// <li> <p> <code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p> </li>
        /// <li> <p> <code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p> </li>
        /// <li> <p> <code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p> </li>
        /// </ul>
        pub fn lock_state(mut self, input: crate::model::LockState) -> Self {
            self.lock_state = Some(input);
            self
        }
        /// <p>The lock state for the retention rule.</p>
        /// <ul>
        /// <li> <p> <code>locked</code> - The retention rule is locked and can't be modified or deleted.</p> </li>
        /// <li> <p> <code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p> </li>
        /// <li> <p> <code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p> </li>
        /// <li> <p> <code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p> </li>
        /// </ul>
        pub fn set_lock_state(
            mut self,
            input: std::option::Option<crate::model::LockState>,
        ) -> Self {
            self.lock_state = input;
            self
        }
        /// Consumes the builder and constructs a [`LockRuleOutput`](crate::output::LockRuleOutput).
        pub fn build(self) -> crate::output::LockRuleOutput {
            crate::output::LockRuleOutput {
                identifier: self.identifier,
                description: self.description,
                resource_type: self.resource_type,
                retention_period: self.retention_period,
                resource_tags: self.resource_tags,
                status: self.status,
                lock_configuration: self.lock_configuration,
                lock_state: self.lock_state,
            }
        }
    }
}
impl LockRuleOutput {
    /// Creates a new builder-style object to manufacture [`LockRuleOutput`](crate::output::LockRuleOutput).
    pub fn builder() -> crate::output::lock_rule_output::Builder {
        crate::output::lock_rule_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListTagsForResourceOutput {
    /// <p>Information about the tags assigned to the retention rule.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl ListTagsForResourceOutput {
    /// <p>Information about the tags assigned to the retention rule.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
/// See [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput).
pub mod list_tags_for_resource_output {

    /// A builder for [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Information about the tags assigned to the retention rule.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Information about the tags assigned to the retention rule.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput).
        pub fn build(self) -> crate::output::ListTagsForResourceOutput {
            crate::output::ListTagsForResourceOutput { tags: self.tags }
        }
    }
}
impl ListTagsForResourceOutput {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput).
    pub fn builder() -> crate::output::list_tags_for_resource_output::Builder {
        crate::output::list_tags_for_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListRulesOutput {
    /// <p>Information about the retention rules.</p>
    #[doc(hidden)]
    pub rules: std::option::Option<std::vec::Vec<crate::model::RuleSummary>>,
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListRulesOutput {
    /// <p>Information about the retention rules.</p>
    pub fn rules(&self) -> std::option::Option<&[crate::model::RuleSummary]> {
        self.rules.as_deref()
    }
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
/// See [`ListRulesOutput`](crate::output::ListRulesOutput).
pub mod list_rules_output {

    /// A builder for [`ListRulesOutput`](crate::output::ListRulesOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rules: std::option::Option<std::vec::Vec<crate::model::RuleSummary>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `rules`.
        ///
        /// To override the contents of this collection use [`set_rules`](Self::set_rules).
        ///
        /// <p>Information about the retention rules.</p>
        pub fn rules(mut self, input: crate::model::RuleSummary) -> Self {
            let mut v = self.rules.unwrap_or_default();
            v.push(input);
            self.rules = Some(v);
            self
        }
        /// <p>Information about the retention rules.</p>
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RuleSummary>>,
        ) -> Self {
            self.rules = input;
            self
        }
        /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListRulesOutput`](crate::output::ListRulesOutput).
        pub fn build(self) -> crate::output::ListRulesOutput {
            crate::output::ListRulesOutput {
                rules: self.rules,
                next_token: self.next_token,
            }
        }
    }
}
impl ListRulesOutput {
    /// Creates a new builder-style object to manufacture [`ListRulesOutput`](crate::output::ListRulesOutput).
    pub fn builder() -> crate::output::list_rules_output::Builder {
        crate::output::list_rules_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetRuleOutput {
    /// <p>The unique ID of the retention rule.</p>
    #[doc(hidden)]
    pub identifier: std::option::Option<std::string::String>,
    /// <p>The retention rule description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The resource type retained by the retention rule.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
    #[doc(hidden)]
    pub retention_period: std::option::Option<crate::model::RetentionPeriod>,
    /// <p>Information about the resource tags used to identify resources that are retained by the retention rule.</p>
    #[doc(hidden)]
    pub resource_tags: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
    /// <p>The state of the retention rule. Only retention rules that are in the <code>available</code> state retain resources.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::RuleStatus>,
    /// <p>Information about the retention rule lock configuration.</p>
    #[doc(hidden)]
    pub lock_configuration: std::option::Option<crate::model::LockConfiguration>,
    /// <p>The lock state for the retention rule.</p>
    /// <ul>
    /// <li> <p> <code>locked</code> - The retention rule is locked and can't be modified or deleted.</p> </li>
    /// <li> <p> <code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p> </li>
    /// <li> <p> <code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p> </li>
    /// <li> <p> <code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub lock_state: std::option::Option<crate::model::LockState>,
    /// <p>The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.</p>
    #[doc(hidden)]
    pub lock_end_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl GetRuleOutput {
    /// <p>The unique ID of the retention rule.</p>
    pub fn identifier(&self) -> std::option::Option<&str> {
        self.identifier.as_deref()
    }
    /// <p>The retention rule description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The resource type retained by the retention rule.</p>
    pub fn resource_type(&self) -> std::option::Option<&crate::model::ResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
    pub fn retention_period(&self) -> std::option::Option<&crate::model::RetentionPeriod> {
        self.retention_period.as_ref()
    }
    /// <p>Information about the resource tags used to identify resources that are retained by the retention rule.</p>
    pub fn resource_tags(&self) -> std::option::Option<&[crate::model::ResourceTag]> {
        self.resource_tags.as_deref()
    }
    /// <p>The state of the retention rule. Only retention rules that are in the <code>available</code> state retain resources.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::RuleStatus> {
        self.status.as_ref()
    }
    /// <p>Information about the retention rule lock configuration.</p>
    pub fn lock_configuration(&self) -> std::option::Option<&crate::model::LockConfiguration> {
        self.lock_configuration.as_ref()
    }
    /// <p>The lock state for the retention rule.</p>
    /// <ul>
    /// <li> <p> <code>locked</code> - The retention rule is locked and can't be modified or deleted.</p> </li>
    /// <li> <p> <code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p> </li>
    /// <li> <p> <code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p> </li>
    /// <li> <p> <code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p> </li>
    /// </ul>
    pub fn lock_state(&self) -> std::option::Option<&crate::model::LockState> {
        self.lock_state.as_ref()
    }
    /// <p>The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.</p>
    pub fn lock_end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.lock_end_time.as_ref()
    }
}
/// See [`GetRuleOutput`](crate::output::GetRuleOutput).
pub mod get_rule_output {

    /// A builder for [`GetRuleOutput`](crate::output::GetRuleOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identifier: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) retention_period: std::option::Option<crate::model::RetentionPeriod>,
        pub(crate) resource_tags: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
        pub(crate) status: std::option::Option<crate::model::RuleStatus>,
        pub(crate) lock_configuration: std::option::Option<crate::model::LockConfiguration>,
        pub(crate) lock_state: std::option::Option<crate::model::LockState>,
        pub(crate) lock_end_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The unique ID of the retention rule.</p>
        pub fn identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.identifier = Some(input.into());
            self
        }
        /// <p>The unique ID of the retention rule.</p>
        pub fn set_identifier(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.identifier = input;
            self
        }
        /// <p>The retention rule description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The retention rule description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The resource type retained by the retention rule.</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>The resource type retained by the retention rule.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
        pub fn retention_period(mut self, input: crate::model::RetentionPeriod) -> Self {
            self.retention_period = Some(input);
            self
        }
        /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
        pub fn set_retention_period(
            mut self,
            input: std::option::Option<crate::model::RetentionPeriod>,
        ) -> Self {
            self.retention_period = input;
            self
        }
        /// Appends an item to `resource_tags`.
        ///
        /// To override the contents of this collection use [`set_resource_tags`](Self::set_resource_tags).
        ///
        /// <p>Information about the resource tags used to identify resources that are retained by the retention rule.</p>
        pub fn resource_tags(mut self, input: crate::model::ResourceTag) -> Self {
            let mut v = self.resource_tags.unwrap_or_default();
            v.push(input);
            self.resource_tags = Some(v);
            self
        }
        /// <p>Information about the resource tags used to identify resources that are retained by the retention rule.</p>
        pub fn set_resource_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
        ) -> Self {
            self.resource_tags = input;
            self
        }
        /// <p>The state of the retention rule. Only retention rules that are in the <code>available</code> state retain resources.</p>
        pub fn status(mut self, input: crate::model::RuleStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The state of the retention rule. Only retention rules that are in the <code>available</code> state retain resources.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::RuleStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>Information about the retention rule lock configuration.</p>
        pub fn lock_configuration(mut self, input: crate::model::LockConfiguration) -> Self {
            self.lock_configuration = Some(input);
            self
        }
        /// <p>Information about the retention rule lock configuration.</p>
        pub fn set_lock_configuration(
            mut self,
            input: std::option::Option<crate::model::LockConfiguration>,
        ) -> Self {
            self.lock_configuration = input;
            self
        }
        /// <p>The lock state for the retention rule.</p>
        /// <ul>
        /// <li> <p> <code>locked</code> - The retention rule is locked and can't be modified or deleted.</p> </li>
        /// <li> <p> <code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p> </li>
        /// <li> <p> <code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p> </li>
        /// <li> <p> <code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p> </li>
        /// </ul>
        pub fn lock_state(mut self, input: crate::model::LockState) -> Self {
            self.lock_state = Some(input);
            self
        }
        /// <p>The lock state for the retention rule.</p>
        /// <ul>
        /// <li> <p> <code>locked</code> - The retention rule is locked and can't be modified or deleted.</p> </li>
        /// <li> <p> <code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p> </li>
        /// <li> <p> <code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p> </li>
        /// <li> <p> <code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p> </li>
        /// </ul>
        pub fn set_lock_state(
            mut self,
            input: std::option::Option<crate::model::LockState>,
        ) -> Self {
            self.lock_state = input;
            self
        }
        /// <p>The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.</p>
        pub fn lock_end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.lock_end_time = Some(input);
            self
        }
        /// <p>The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.</p>
        pub fn set_lock_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.lock_end_time = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRuleOutput`](crate::output::GetRuleOutput).
        pub fn build(self) -> crate::output::GetRuleOutput {
            crate::output::GetRuleOutput {
                identifier: self.identifier,
                description: self.description,
                resource_type: self.resource_type,
                retention_period: self.retention_period,
                resource_tags: self.resource_tags,
                status: self.status,
                lock_configuration: self.lock_configuration,
                lock_state: self.lock_state,
                lock_end_time: self.lock_end_time,
            }
        }
    }
}
impl GetRuleOutput {
    /// Creates a new builder-style object to manufacture [`GetRuleOutput`](crate::output::GetRuleOutput).
    pub fn builder() -> crate::output::get_rule_output::Builder {
        crate::output::get_rule_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteRuleOutput {}
/// See [`DeleteRuleOutput`](crate::output::DeleteRuleOutput).
pub mod delete_rule_output {

    /// A builder for [`DeleteRuleOutput`](crate::output::DeleteRuleOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteRuleOutput`](crate::output::DeleteRuleOutput).
        pub fn build(self) -> crate::output::DeleteRuleOutput {
            crate::output::DeleteRuleOutput {}
        }
    }
}
impl DeleteRuleOutput {
    /// Creates a new builder-style object to manufacture [`DeleteRuleOutput`](crate::output::DeleteRuleOutput).
    pub fn builder() -> crate::output::delete_rule_output::Builder {
        crate::output::delete_rule_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateRuleOutput {
    /// <p>The unique ID of the retention rule.</p>
    #[doc(hidden)]
    pub identifier: std::option::Option<std::string::String>,
    /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
    #[doc(hidden)]
    pub retention_period: std::option::Option<crate::model::RetentionPeriod>,
    /// <p>The retention rule description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Information about the tags assigned to the retention rule.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The resource type retained by the retention rule.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>Information about the resource tags used to identify resources that are retained by the retention rule.</p>
    #[doc(hidden)]
    pub resource_tags: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
    /// <p>The state of the retention rule. Only retention rules that are in the <code>available</code> state retain resources.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::RuleStatus>,
    /// <p>Information about the retention rule lock configuration.</p>
    #[doc(hidden)]
    pub lock_configuration: std::option::Option<crate::model::LockConfiguration>,
    /// <p>The lock state for the retention rule.</p>
    /// <ul>
    /// <li> <p> <code>locked</code> - The retention rule is locked and can't be modified or deleted.</p> </li>
    /// <li> <p> <code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p> </li>
    /// <li> <p> <code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p> </li>
    /// <li> <p> <code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub lock_state: std::option::Option<crate::model::LockState>,
}
impl CreateRuleOutput {
    /// <p>The unique ID of the retention rule.</p>
    pub fn identifier(&self) -> std::option::Option<&str> {
        self.identifier.as_deref()
    }
    /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
    pub fn retention_period(&self) -> std::option::Option<&crate::model::RetentionPeriod> {
        self.retention_period.as_ref()
    }
    /// <p>The retention rule description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Information about the tags assigned to the retention rule.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The resource type retained by the retention rule.</p>
    pub fn resource_type(&self) -> std::option::Option<&crate::model::ResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>Information about the resource tags used to identify resources that are retained by the retention rule.</p>
    pub fn resource_tags(&self) -> std::option::Option<&[crate::model::ResourceTag]> {
        self.resource_tags.as_deref()
    }
    /// <p>The state of the retention rule. Only retention rules that are in the <code>available</code> state retain resources.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::RuleStatus> {
        self.status.as_ref()
    }
    /// <p>Information about the retention rule lock configuration.</p>
    pub fn lock_configuration(&self) -> std::option::Option<&crate::model::LockConfiguration> {
        self.lock_configuration.as_ref()
    }
    /// <p>The lock state for the retention rule.</p>
    /// <ul>
    /// <li> <p> <code>locked</code> - The retention rule is locked and can't be modified or deleted.</p> </li>
    /// <li> <p> <code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p> </li>
    /// <li> <p> <code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p> </li>
    /// <li> <p> <code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p> </li>
    /// </ul>
    pub fn lock_state(&self) -> std::option::Option<&crate::model::LockState> {
        self.lock_state.as_ref()
    }
}
/// See [`CreateRuleOutput`](crate::output::CreateRuleOutput).
pub mod create_rule_output {

    /// A builder for [`CreateRuleOutput`](crate::output::CreateRuleOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identifier: std::option::Option<std::string::String>,
        pub(crate) retention_period: std::option::Option<crate::model::RetentionPeriod>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) resource_tags: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
        pub(crate) status: std::option::Option<crate::model::RuleStatus>,
        pub(crate) lock_configuration: std::option::Option<crate::model::LockConfiguration>,
        pub(crate) lock_state: std::option::Option<crate::model::LockState>,
    }
    impl Builder {
        /// <p>The unique ID of the retention rule.</p>
        pub fn identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.identifier = Some(input.into());
            self
        }
        /// <p>The unique ID of the retention rule.</p>
        pub fn set_identifier(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.identifier = input;
            self
        }
        /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
        pub fn retention_period(mut self, input: crate::model::RetentionPeriod) -> Self {
            self.retention_period = Some(input);
            self
        }
        /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
        pub fn set_retention_period(
            mut self,
            input: std::option::Option<crate::model::RetentionPeriod>,
        ) -> Self {
            self.retention_period = input;
            self
        }
        /// <p>The retention rule description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The retention rule description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Information about the tags assigned to the retention rule.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Information about the tags assigned to the retention rule.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The resource type retained by the retention rule.</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>The resource type retained by the retention rule.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Appends an item to `resource_tags`.
        ///
        /// To override the contents of this collection use [`set_resource_tags`](Self::set_resource_tags).
        ///
        /// <p>Information about the resource tags used to identify resources that are retained by the retention rule.</p>
        pub fn resource_tags(mut self, input: crate::model::ResourceTag) -> Self {
            let mut v = self.resource_tags.unwrap_or_default();
            v.push(input);
            self.resource_tags = Some(v);
            self
        }
        /// <p>Information about the resource tags used to identify resources that are retained by the retention rule.</p>
        pub fn set_resource_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
        ) -> Self {
            self.resource_tags = input;
            self
        }
        /// <p>The state of the retention rule. Only retention rules that are in the <code>available</code> state retain resources.</p>
        pub fn status(mut self, input: crate::model::RuleStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The state of the retention rule. Only retention rules that are in the <code>available</code> state retain resources.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::RuleStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>Information about the retention rule lock configuration.</p>
        pub fn lock_configuration(mut self, input: crate::model::LockConfiguration) -> Self {
            self.lock_configuration = Some(input);
            self
        }
        /// <p>Information about the retention rule lock configuration.</p>
        pub fn set_lock_configuration(
            mut self,
            input: std::option::Option<crate::model::LockConfiguration>,
        ) -> Self {
            self.lock_configuration = input;
            self
        }
        /// <p>The lock state for the retention rule.</p>
        /// <ul>
        /// <li> <p> <code>locked</code> - The retention rule is locked and can't be modified or deleted.</p> </li>
        /// <li> <p> <code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p> </li>
        /// <li> <p> <code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p> </li>
        /// <li> <p> <code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p> </li>
        /// </ul>
        pub fn lock_state(mut self, input: crate::model::LockState) -> Self {
            self.lock_state = Some(input);
            self
        }
        /// <p>The lock state for the retention rule.</p>
        /// <ul>
        /// <li> <p> <code>locked</code> - The retention rule is locked and can't be modified or deleted.</p> </li>
        /// <li> <p> <code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p> </li>
        /// <li> <p> <code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p> </li>
        /// <li> <p> <code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p> </li>
        /// </ul>
        pub fn set_lock_state(
            mut self,
            input: std::option::Option<crate::model::LockState>,
        ) -> Self {
            self.lock_state = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateRuleOutput`](crate::output::CreateRuleOutput).
        pub fn build(self) -> crate::output::CreateRuleOutput {
            crate::output::CreateRuleOutput {
                identifier: self.identifier,
                retention_period: self.retention_period,
                description: self.description,
                tags: self.tags,
                resource_type: self.resource_type,
                resource_tags: self.resource_tags,
                status: self.status,
                lock_configuration: self.lock_configuration,
                lock_state: self.lock_state,
            }
        }
    }
}
impl CreateRuleOutput {
    /// Creates a new builder-style object to manufacture [`CreateRuleOutput`](crate::output::CreateRuleOutput).
    pub fn builder() -> crate::output::create_rule_output::Builder {
        crate::output::create_rule_output::Builder::default()
    }
}
