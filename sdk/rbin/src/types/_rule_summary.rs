// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Information about a Recycle Bin retention rule.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct RuleSummary {
    /// <p>The unique ID of the retention rule.</p>
    pub identifier: ::std::option::Option<::std::string::String>,
    /// <p>The retention rule description.</p>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
    pub retention_period: ::std::option::Option<crate::types::RetentionPeriod>,
    /// <p>The lock state for the retention rule.</p>
    /// <ul>
    /// <li>
    /// <p><code>locked</code> - The retention rule is locked and can't be modified or deleted.</p></li>
    /// <li>
    /// <p><code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p></li>
    /// <li>
    /// <p><code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p></li>
    /// <li>
    /// <p><code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p></li>
    /// </ul>
    pub lock_state: ::std::option::Option<crate::types::LockState>,
    /// <p>The Amazon Resource Name (ARN) of the retention rule.</p>
    pub rule_arn: ::std::option::Option<::std::string::String>,
}
impl RuleSummary {
    /// <p>The unique ID of the retention rule.</p>
    pub fn identifier(&self) -> ::std::option::Option<&str> {
        self.identifier.as_deref()
    }
    /// <p>The retention rule description.</p>
    pub fn description(&self) -> ::std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
    pub fn retention_period(&self) -> ::std::option::Option<&crate::types::RetentionPeriod> {
        self.retention_period.as_ref()
    }
    /// <p>The lock state for the retention rule.</p>
    /// <ul>
    /// <li>
    /// <p><code>locked</code> - The retention rule is locked and can't be modified or deleted.</p></li>
    /// <li>
    /// <p><code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p></li>
    /// <li>
    /// <p><code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p></li>
    /// <li>
    /// <p><code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p></li>
    /// </ul>
    pub fn lock_state(&self) -> ::std::option::Option<&crate::types::LockState> {
        self.lock_state.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the retention rule.</p>
    pub fn rule_arn(&self) -> ::std::option::Option<&str> {
        self.rule_arn.as_deref()
    }
}
impl RuleSummary {
    /// Creates a new builder-style object to manufacture [`RuleSummary`](crate::types::RuleSummary).
    pub fn builder() -> crate::types::builders::RuleSummaryBuilder {
        crate::types::builders::RuleSummaryBuilder::default()
    }
}

/// A builder for [`RuleSummary`](crate::types::RuleSummary).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct RuleSummaryBuilder {
    pub(crate) identifier: ::std::option::Option<::std::string::String>,
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) retention_period: ::std::option::Option<crate::types::RetentionPeriod>,
    pub(crate) lock_state: ::std::option::Option<crate::types::LockState>,
    pub(crate) rule_arn: ::std::option::Option<::std::string::String>,
}
impl RuleSummaryBuilder {
    /// <p>The unique ID of the retention rule.</p>
    pub fn identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique ID of the retention rule.</p>
    pub fn set_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.identifier = input;
        self
    }
    /// <p>The unique ID of the retention rule.</p>
    pub fn get_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.identifier
    }
    /// <p>The retention rule description.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The retention rule description.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>The retention rule description.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
    pub fn retention_period(mut self, input: crate::types::RetentionPeriod) -> Self {
        self.retention_period = ::std::option::Option::Some(input);
        self
    }
    /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
    pub fn set_retention_period(mut self, input: ::std::option::Option<crate::types::RetentionPeriod>) -> Self {
        self.retention_period = input;
        self
    }
    /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
    pub fn get_retention_period(&self) -> &::std::option::Option<crate::types::RetentionPeriod> {
        &self.retention_period
    }
    /// <p>The lock state for the retention rule.</p>
    /// <ul>
    /// <li>
    /// <p><code>locked</code> - The retention rule is locked and can't be modified or deleted.</p></li>
    /// <li>
    /// <p><code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p></li>
    /// <li>
    /// <p><code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p></li>
    /// <li>
    /// <p><code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p></li>
    /// </ul>
    pub fn lock_state(mut self, input: crate::types::LockState) -> Self {
        self.lock_state = ::std::option::Option::Some(input);
        self
    }
    /// <p>The lock state for the retention rule.</p>
    /// <ul>
    /// <li>
    /// <p><code>locked</code> - The retention rule is locked and can't be modified or deleted.</p></li>
    /// <li>
    /// <p><code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p></li>
    /// <li>
    /// <p><code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p></li>
    /// <li>
    /// <p><code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p></li>
    /// </ul>
    pub fn set_lock_state(mut self, input: ::std::option::Option<crate::types::LockState>) -> Self {
        self.lock_state = input;
        self
    }
    /// <p>The lock state for the retention rule.</p>
    /// <ul>
    /// <li>
    /// <p><code>locked</code> - The retention rule is locked and can't be modified or deleted.</p></li>
    /// <li>
    /// <p><code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p></li>
    /// <li>
    /// <p><code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p></li>
    /// <li>
    /// <p><code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p></li>
    /// </ul>
    pub fn get_lock_state(&self) -> &::std::option::Option<crate::types::LockState> {
        &self.lock_state
    }
    /// <p>The Amazon Resource Name (ARN) of the retention rule.</p>
    pub fn rule_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.rule_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the retention rule.</p>
    pub fn set_rule_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.rule_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the retention rule.</p>
    pub fn get_rule_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.rule_arn
    }
    /// Consumes the builder and constructs a [`RuleSummary`](crate::types::RuleSummary).
    pub fn build(self) -> crate::types::RuleSummary {
        crate::types::RuleSummary {
            identifier: self.identifier,
            description: self.description,
            retention_period: self.retention_period,
            lock_state: self.lock_state,
            rule_arn: self.rule_arn,
        }
    }
}
