// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `ValidationExceptionReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let validationexceptionreason = unimplemented!();
/// match validationexceptionreason {
///     ValidationExceptionReason::InvalidPageToken => { /* ... */ },
///     ValidationExceptionReason::InvalidParameterValue => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `validationexceptionreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ValidationExceptionReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ValidationExceptionReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ValidationExceptionReason::NewFeature` is defined.
/// Specifically, when `validationexceptionreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ValidationExceptionReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ValidationExceptionReason {
    #[allow(missing_docs)] // documentation missing in model
    InvalidPageToken,
    #[allow(missing_docs)] // documentation missing in model
    InvalidParameterValue,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ValidationExceptionReason {
    fn from(s: &str) -> Self {
        match s {
            "INVALID_PAGE_TOKEN" => ValidationExceptionReason::InvalidPageToken,
            "INVALID_PARAMETER_VALUE" => ValidationExceptionReason::InvalidParameterValue,
            other => ValidationExceptionReason::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ValidationExceptionReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ValidationExceptionReason::from(s))
    }
}
impl ValidationExceptionReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ValidationExceptionReason::InvalidPageToken => "INVALID_PAGE_TOKEN",
            ValidationExceptionReason::InvalidParameterValue => "INVALID_PARAMETER_VALUE",
            ValidationExceptionReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["INVALID_PAGE_TOKEN", "INVALID_PARAMETER_VALUE"]
    }
}
impl AsRef<str> for ValidationExceptionReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ResourceNotFoundExceptionReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourcenotfoundexceptionreason = unimplemented!();
/// match resourcenotfoundexceptionreason {
///     ResourceNotFoundExceptionReason::RuleNotFound => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourcenotfoundexceptionreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceNotFoundExceptionReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceNotFoundExceptionReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceNotFoundExceptionReason::NewFeature` is defined.
/// Specifically, when `resourcenotfoundexceptionreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceNotFoundExceptionReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceNotFoundExceptionReason {
    #[allow(missing_docs)] // documentation missing in model
    RuleNotFound,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceNotFoundExceptionReason {
    fn from(s: &str) -> Self {
        match s {
            "RULE_NOT_FOUND" => ResourceNotFoundExceptionReason::RuleNotFound,
            other => ResourceNotFoundExceptionReason::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ResourceNotFoundExceptionReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceNotFoundExceptionReason::from(s))
    }
}
impl ResourceNotFoundExceptionReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceNotFoundExceptionReason::RuleNotFound => "RULE_NOT_FOUND",
            ResourceNotFoundExceptionReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["RULE_NOT_FOUND"]
    }
}
impl AsRef<str> for ResourceNotFoundExceptionReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ConflictExceptionReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let conflictexceptionreason = unimplemented!();
/// match conflictexceptionreason {
///     ConflictExceptionReason::InvalidRuleState => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `conflictexceptionreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConflictExceptionReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConflictExceptionReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConflictExceptionReason::NewFeature` is defined.
/// Specifically, when `conflictexceptionreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConflictExceptionReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConflictExceptionReason {
    #[allow(missing_docs)] // documentation missing in model
    InvalidRuleState,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConflictExceptionReason {
    fn from(s: &str) -> Self {
        match s {
            "INVALID_RULE_STATE" => ConflictExceptionReason::InvalidRuleState,
            other => ConflictExceptionReason::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ConflictExceptionReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConflictExceptionReason::from(s))
    }
}
impl ConflictExceptionReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConflictExceptionReason::InvalidRuleState => "INVALID_RULE_STATE",
            ConflictExceptionReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["INVALID_RULE_STATE"]
    }
}
impl AsRef<str> for ConflictExceptionReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `LockState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let lockstate = unimplemented!();
/// match lockstate {
///     LockState::Locked => { /* ... */ },
///     LockState::PendingUnlock => { /* ... */ },
///     LockState::Unlocked => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `lockstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LockState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LockState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LockState::NewFeature` is defined.
/// Specifically, when `lockstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LockState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LockState {
    #[allow(missing_docs)] // documentation missing in model
    Locked,
    #[allow(missing_docs)] // documentation missing in model
    PendingUnlock,
    #[allow(missing_docs)] // documentation missing in model
    Unlocked,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LockState {
    fn from(s: &str) -> Self {
        match s {
            "locked" => LockState::Locked,
            "pending_unlock" => LockState::PendingUnlock,
            "unlocked" => LockState::Unlocked,
            other => LockState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LockState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LockState::from(s))
    }
}
impl LockState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LockState::Locked => "locked",
            LockState::PendingUnlock => "pending_unlock",
            LockState::Unlocked => "unlocked",
            LockState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["locked", "pending_unlock", "unlocked"]
    }
}
impl AsRef<str> for LockState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `RuleStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let rulestatus = unimplemented!();
/// match rulestatus {
///     RuleStatus::Available => { /* ... */ },
///     RuleStatus::Pending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `rulestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RuleStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RuleStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RuleStatus::NewFeature` is defined.
/// Specifically, when `rulestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RuleStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RuleStatus {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RuleStatus {
    fn from(s: &str) -> Self {
        match s {
            "available" => RuleStatus::Available,
            "pending" => RuleStatus::Pending,
            other => RuleStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for RuleStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RuleStatus::from(s))
    }
}
impl RuleStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RuleStatus::Available => "available",
            RuleStatus::Pending => "pending",
            RuleStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["available", "pending"]
    }
}
impl AsRef<str> for RuleStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the resource tags used to identify resources that are retained by the retention rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceTag {
    /// <p>The tag key.</p>
    #[doc(hidden)]
    pub resource_tag_key: std::option::Option<std::string::String>,
    /// <p>The tag value.</p>
    #[doc(hidden)]
    pub resource_tag_value: std::option::Option<std::string::String>,
}
impl ResourceTag {
    /// <p>The tag key.</p>
    pub fn resource_tag_key(&self) -> std::option::Option<&str> {
        self.resource_tag_key.as_deref()
    }
    /// <p>The tag value.</p>
    pub fn resource_tag_value(&self) -> std::option::Option<&str> {
        self.resource_tag_value.as_deref()
    }
}
/// See [`ResourceTag`](crate::model::ResourceTag).
pub mod resource_tag {

    /// A builder for [`ResourceTag`](crate::model::ResourceTag).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_tag_key: std::option::Option<std::string::String>,
        pub(crate) resource_tag_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The tag key.</p>
        pub fn resource_tag_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_tag_key = Some(input.into());
            self
        }
        /// <p>The tag key.</p>
        pub fn set_resource_tag_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_tag_key = input;
            self
        }
        /// <p>The tag value.</p>
        pub fn resource_tag_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_tag_value = Some(input.into());
            self
        }
        /// <p>The tag value.</p>
        pub fn set_resource_tag_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_tag_value = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceTag`](crate::model::ResourceTag).
        pub fn build(self) -> crate::model::ResourceTag {
            crate::model::ResourceTag {
                resource_tag_key: self.resource_tag_key,
                resource_tag_value: self.resource_tag_value,
            }
        }
    }
}
impl ResourceTag {
    /// Creates a new builder-style object to manufacture [`ResourceTag`](crate::model::ResourceTag).
    pub fn builder() -> crate::model::resource_tag::Builder {
        crate::model::resource_tag::Builder::default()
    }
}

/// When writing a match expression against `ResourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourcetype = unimplemented!();
/// match resourcetype {
///     ResourceType::EbsSnapshot => { /* ... */ },
///     ResourceType::Ec2Image => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceType::NewFeature` is defined.
/// Specifically, when `resourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceType {
    #[allow(missing_docs)] // documentation missing in model
    EbsSnapshot,
    #[allow(missing_docs)] // documentation missing in model
    Ec2Image,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceType {
    fn from(s: &str) -> Self {
        match s {
            "EBS_SNAPSHOT" => ResourceType::EbsSnapshot,
            "EC2_IMAGE" => ResourceType::Ec2Image,
            other => ResourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceType::from(s))
    }
}
impl ResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceType::EbsSnapshot => "EBS_SNAPSHOT",
            ResourceType::Ec2Image => "EC2_IMAGE",
            ResourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EBS_SNAPSHOT", "EC2_IMAGE"]
    }
}
impl AsRef<str> for ResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the retention period for which the retention rule is to retain resources.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RetentionPeriod {
    /// <p>The period value for which the retention rule is to retain resources. The period is measured using the unit specified for <b>RetentionPeriodUnit</b>.</p>
    #[doc(hidden)]
    pub retention_period_value: std::option::Option<i32>,
    /// <p>The unit of time in which the retention period is measured. Currently, only <code>DAYS</code> is supported.</p>
    #[doc(hidden)]
    pub retention_period_unit: std::option::Option<crate::model::RetentionPeriodUnit>,
}
impl RetentionPeriod {
    /// <p>The period value for which the retention rule is to retain resources. The period is measured using the unit specified for <b>RetentionPeriodUnit</b>.</p>
    pub fn retention_period_value(&self) -> std::option::Option<i32> {
        self.retention_period_value
    }
    /// <p>The unit of time in which the retention period is measured. Currently, only <code>DAYS</code> is supported.</p>
    pub fn retention_period_unit(&self) -> std::option::Option<&crate::model::RetentionPeriodUnit> {
        self.retention_period_unit.as_ref()
    }
}
/// See [`RetentionPeriod`](crate::model::RetentionPeriod).
pub mod retention_period {

    /// A builder for [`RetentionPeriod`](crate::model::RetentionPeriod).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) retention_period_value: std::option::Option<i32>,
        pub(crate) retention_period_unit: std::option::Option<crate::model::RetentionPeriodUnit>,
    }
    impl Builder {
        /// <p>The period value for which the retention rule is to retain resources. The period is measured using the unit specified for <b>RetentionPeriodUnit</b>.</p>
        pub fn retention_period_value(mut self, input: i32) -> Self {
            self.retention_period_value = Some(input);
            self
        }
        /// <p>The period value for which the retention rule is to retain resources. The period is measured using the unit specified for <b>RetentionPeriodUnit</b>.</p>
        pub fn set_retention_period_value(mut self, input: std::option::Option<i32>) -> Self {
            self.retention_period_value = input;
            self
        }
        /// <p>The unit of time in which the retention period is measured. Currently, only <code>DAYS</code> is supported.</p>
        pub fn retention_period_unit(mut self, input: crate::model::RetentionPeriodUnit) -> Self {
            self.retention_period_unit = Some(input);
            self
        }
        /// <p>The unit of time in which the retention period is measured. Currently, only <code>DAYS</code> is supported.</p>
        pub fn set_retention_period_unit(
            mut self,
            input: std::option::Option<crate::model::RetentionPeriodUnit>,
        ) -> Self {
            self.retention_period_unit = input;
            self
        }
        /// Consumes the builder and constructs a [`RetentionPeriod`](crate::model::RetentionPeriod).
        pub fn build(self) -> crate::model::RetentionPeriod {
            crate::model::RetentionPeriod {
                retention_period_value: self.retention_period_value,
                retention_period_unit: self.retention_period_unit,
            }
        }
    }
}
impl RetentionPeriod {
    /// Creates a new builder-style object to manufacture [`RetentionPeriod`](crate::model::RetentionPeriod).
    pub fn builder() -> crate::model::retention_period::Builder {
        crate::model::retention_period::Builder::default()
    }
}

/// When writing a match expression against `RetentionPeriodUnit`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let retentionperiodunit = unimplemented!();
/// match retentionperiodunit {
///     RetentionPeriodUnit::Days => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `retentionperiodunit` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RetentionPeriodUnit::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RetentionPeriodUnit::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RetentionPeriodUnit::NewFeature` is defined.
/// Specifically, when `retentionperiodunit` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RetentionPeriodUnit::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RetentionPeriodUnit {
    #[allow(missing_docs)] // documentation missing in model
    Days,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RetentionPeriodUnit {
    fn from(s: &str) -> Self {
        match s {
            "DAYS" => RetentionPeriodUnit::Days,
            other => {
                RetentionPeriodUnit::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for RetentionPeriodUnit {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RetentionPeriodUnit::from(s))
    }
}
impl RetentionPeriodUnit {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RetentionPeriodUnit::Days => "DAYS",
            RetentionPeriodUnit::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DAYS"]
    }
}
impl AsRef<str> for RetentionPeriodUnit {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a retention rule lock configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LockConfiguration {
    /// <p>Information about the retention rule unlock delay.</p>
    #[doc(hidden)]
    pub unlock_delay: std::option::Option<crate::model::UnlockDelay>,
}
impl LockConfiguration {
    /// <p>Information about the retention rule unlock delay.</p>
    pub fn unlock_delay(&self) -> std::option::Option<&crate::model::UnlockDelay> {
        self.unlock_delay.as_ref()
    }
}
/// See [`LockConfiguration`](crate::model::LockConfiguration).
pub mod lock_configuration {

    /// A builder for [`LockConfiguration`](crate::model::LockConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) unlock_delay: std::option::Option<crate::model::UnlockDelay>,
    }
    impl Builder {
        /// <p>Information about the retention rule unlock delay.</p>
        pub fn unlock_delay(mut self, input: crate::model::UnlockDelay) -> Self {
            self.unlock_delay = Some(input);
            self
        }
        /// <p>Information about the retention rule unlock delay.</p>
        pub fn set_unlock_delay(
            mut self,
            input: std::option::Option<crate::model::UnlockDelay>,
        ) -> Self {
            self.unlock_delay = input;
            self
        }
        /// Consumes the builder and constructs a [`LockConfiguration`](crate::model::LockConfiguration).
        pub fn build(self) -> crate::model::LockConfiguration {
            crate::model::LockConfiguration {
                unlock_delay: self.unlock_delay,
            }
        }
    }
}
impl LockConfiguration {
    /// Creates a new builder-style object to manufacture [`LockConfiguration`](crate::model::LockConfiguration).
    pub fn builder() -> crate::model::lock_configuration::Builder {
        crate::model::lock_configuration::Builder::default()
    }
}

/// <p>Information about the retention rule unlock delay. The unlock delay is the period after which a retention rule can be modified or edited after it has been unlocked by a user with the required permissions. The retention rule can't be modified or deleted during the unlock delay.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UnlockDelay {
    /// <p>The unlock delay period, measured in the unit specified for <b> UnlockDelayUnit</b>.</p>
    #[doc(hidden)]
    pub unlock_delay_value: std::option::Option<i32>,
    /// <p>The unit of time in which to measure the unlock delay. Currently, the unlock delay can be measure only in days.</p>
    #[doc(hidden)]
    pub unlock_delay_unit: std::option::Option<crate::model::UnlockDelayUnit>,
}
impl UnlockDelay {
    /// <p>The unlock delay period, measured in the unit specified for <b> UnlockDelayUnit</b>.</p>
    pub fn unlock_delay_value(&self) -> std::option::Option<i32> {
        self.unlock_delay_value
    }
    /// <p>The unit of time in which to measure the unlock delay. Currently, the unlock delay can be measure only in days.</p>
    pub fn unlock_delay_unit(&self) -> std::option::Option<&crate::model::UnlockDelayUnit> {
        self.unlock_delay_unit.as_ref()
    }
}
/// See [`UnlockDelay`](crate::model::UnlockDelay).
pub mod unlock_delay {

    /// A builder for [`UnlockDelay`](crate::model::UnlockDelay).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) unlock_delay_value: std::option::Option<i32>,
        pub(crate) unlock_delay_unit: std::option::Option<crate::model::UnlockDelayUnit>,
    }
    impl Builder {
        /// <p>The unlock delay period, measured in the unit specified for <b> UnlockDelayUnit</b>.</p>
        pub fn unlock_delay_value(mut self, input: i32) -> Self {
            self.unlock_delay_value = Some(input);
            self
        }
        /// <p>The unlock delay period, measured in the unit specified for <b> UnlockDelayUnit</b>.</p>
        pub fn set_unlock_delay_value(mut self, input: std::option::Option<i32>) -> Self {
            self.unlock_delay_value = input;
            self
        }
        /// <p>The unit of time in which to measure the unlock delay. Currently, the unlock delay can be measure only in days.</p>
        pub fn unlock_delay_unit(mut self, input: crate::model::UnlockDelayUnit) -> Self {
            self.unlock_delay_unit = Some(input);
            self
        }
        /// <p>The unit of time in which to measure the unlock delay. Currently, the unlock delay can be measure only in days.</p>
        pub fn set_unlock_delay_unit(
            mut self,
            input: std::option::Option<crate::model::UnlockDelayUnit>,
        ) -> Self {
            self.unlock_delay_unit = input;
            self
        }
        /// Consumes the builder and constructs a [`UnlockDelay`](crate::model::UnlockDelay).
        pub fn build(self) -> crate::model::UnlockDelay {
            crate::model::UnlockDelay {
                unlock_delay_value: self.unlock_delay_value,
                unlock_delay_unit: self.unlock_delay_unit,
            }
        }
    }
}
impl UnlockDelay {
    /// Creates a new builder-style object to manufacture [`UnlockDelay`](crate::model::UnlockDelay).
    pub fn builder() -> crate::model::unlock_delay::Builder {
        crate::model::unlock_delay::Builder::default()
    }
}

/// When writing a match expression against `UnlockDelayUnit`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let unlockdelayunit = unimplemented!();
/// match unlockdelayunit {
///     UnlockDelayUnit::Days => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `unlockdelayunit` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UnlockDelayUnit::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UnlockDelayUnit::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UnlockDelayUnit::NewFeature` is defined.
/// Specifically, when `unlockdelayunit` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UnlockDelayUnit::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UnlockDelayUnit {
    #[allow(missing_docs)] // documentation missing in model
    Days,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for UnlockDelayUnit {
    fn from(s: &str) -> Self {
        match s {
            "DAYS" => UnlockDelayUnit::Days,
            other => UnlockDelayUnit::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for UnlockDelayUnit {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UnlockDelayUnit::from(s))
    }
}
impl UnlockDelayUnit {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UnlockDelayUnit::Days => "DAYS",
            UnlockDelayUnit::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DAYS"]
    }
}
impl AsRef<str> for UnlockDelayUnit {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ServiceQuotaExceededExceptionReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let servicequotaexceededexceptionreason = unimplemented!();
/// match servicequotaexceededexceptionreason {
///     ServiceQuotaExceededExceptionReason::ServiceQuotaExceeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `servicequotaexceededexceptionreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ServiceQuotaExceededExceptionReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ServiceQuotaExceededExceptionReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ServiceQuotaExceededExceptionReason::NewFeature` is defined.
/// Specifically, when `servicequotaexceededexceptionreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ServiceQuotaExceededExceptionReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ServiceQuotaExceededExceptionReason {
    #[allow(missing_docs)] // documentation missing in model
    ServiceQuotaExceeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ServiceQuotaExceededExceptionReason {
    fn from(s: &str) -> Self {
        match s {
            "SERVICE_QUOTA_EXCEEDED" => ServiceQuotaExceededExceptionReason::ServiceQuotaExceeded,
            other => ServiceQuotaExceededExceptionReason::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for ServiceQuotaExceededExceptionReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ServiceQuotaExceededExceptionReason::from(s))
    }
}
impl ServiceQuotaExceededExceptionReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ServiceQuotaExceededExceptionReason::ServiceQuotaExceeded => "SERVICE_QUOTA_EXCEEDED",
            ServiceQuotaExceededExceptionReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SERVICE_QUOTA_EXCEEDED"]
    }
}
impl AsRef<str> for ServiceQuotaExceededExceptionReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the tags to assign to the retention rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Tag {
    /// <p>The tag key.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The tag value.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>The tag key.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The tag value.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`Tag`](crate::model::Tag).
pub mod tag {

    /// A builder for [`Tag`](crate::model::Tag).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The tag key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The tag key.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The tag value.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The tag value.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag).
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag).
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>Information about a Recycle Bin retention rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RuleSummary {
    /// <p>The unique ID of the retention rule.</p>
    #[doc(hidden)]
    pub identifier: std::option::Option<std::string::String>,
    /// <p>The retention rule description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
    #[doc(hidden)]
    pub retention_period: std::option::Option<crate::model::RetentionPeriod>,
    /// <p>The lock state for the retention rule.</p>
    /// <ul>
    /// <li> <p> <code>locked</code> - The retention rule is locked and can't be modified or deleted.</p> </li>
    /// <li> <p> <code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p> </li>
    /// <li> <p> <code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p> </li>
    /// <li> <p> <code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub lock_state: std::option::Option<crate::model::LockState>,
}
impl RuleSummary {
    /// <p>The unique ID of the retention rule.</p>
    pub fn identifier(&self) -> std::option::Option<&str> {
        self.identifier.as_deref()
    }
    /// <p>The retention rule description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
    pub fn retention_period(&self) -> std::option::Option<&crate::model::RetentionPeriod> {
        self.retention_period.as_ref()
    }
    /// <p>The lock state for the retention rule.</p>
    /// <ul>
    /// <li> <p> <code>locked</code> - The retention rule is locked and can't be modified or deleted.</p> </li>
    /// <li> <p> <code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p> </li>
    /// <li> <p> <code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p> </li>
    /// <li> <p> <code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p> </li>
    /// </ul>
    pub fn lock_state(&self) -> std::option::Option<&crate::model::LockState> {
        self.lock_state.as_ref()
    }
}
/// See [`RuleSummary`](crate::model::RuleSummary).
pub mod rule_summary {

    /// A builder for [`RuleSummary`](crate::model::RuleSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identifier: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) retention_period: std::option::Option<crate::model::RetentionPeriod>,
        pub(crate) lock_state: std::option::Option<crate::model::LockState>,
    }
    impl Builder {
        /// <p>The unique ID of the retention rule.</p>
        pub fn identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.identifier = Some(input.into());
            self
        }
        /// <p>The unique ID of the retention rule.</p>
        pub fn set_identifier(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.identifier = input;
            self
        }
        /// <p>The retention rule description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The retention rule description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
        pub fn retention_period(mut self, input: crate::model::RetentionPeriod) -> Self {
            self.retention_period = Some(input);
            self
        }
        /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
        pub fn set_retention_period(
            mut self,
            input: std::option::Option<crate::model::RetentionPeriod>,
        ) -> Self {
            self.retention_period = input;
            self
        }
        /// <p>The lock state for the retention rule.</p>
        /// <ul>
        /// <li> <p> <code>locked</code> - The retention rule is locked and can't be modified or deleted.</p> </li>
        /// <li> <p> <code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p> </li>
        /// <li> <p> <code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p> </li>
        /// <li> <p> <code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p> </li>
        /// </ul>
        pub fn lock_state(mut self, input: crate::model::LockState) -> Self {
            self.lock_state = Some(input);
            self
        }
        /// <p>The lock state for the retention rule.</p>
        /// <ul>
        /// <li> <p> <code>locked</code> - The retention rule is locked and can't be modified or deleted.</p> </li>
        /// <li> <p> <code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p> </li>
        /// <li> <p> <code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p> </li>
        /// <li> <p> <code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p> </li>
        /// </ul>
        pub fn set_lock_state(
            mut self,
            input: std::option::Option<crate::model::LockState>,
        ) -> Self {
            self.lock_state = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleSummary`](crate::model::RuleSummary).
        pub fn build(self) -> crate::model::RuleSummary {
            crate::model::RuleSummary {
                identifier: self.identifier,
                description: self.description,
                retention_period: self.retention_period,
                lock_state: self.lock_state,
            }
        }
    }
}
impl RuleSummary {
    /// Creates a new builder-style object to manufacture [`RuleSummary`](crate::model::RuleSummary).
    pub fn builder() -> crate::model::rule_summary::Builder {
        crate::model::rule_summary::Builder::default()
    }
}
