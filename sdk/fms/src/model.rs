// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>A collection of key:value pairs associated with an AWS resource. The key:value pair can be anything you define. Typically, the tag key represents a category (such as "environment") and the tag value represents a specific value within that category (such as "test," "development," or "production"). You can add up to 50 tags to each AWS resource.  </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Tag {
    /// <p>Part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>Part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.  </p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Tag");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Tag`](crate::model::Tag)
pub mod tag {
    /// A builder for [`Tag`](crate::model::Tag)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>Part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.  </p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag)
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag)
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>An AWS Firewall Manager protocols list.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProtocolsListData {
    /// <p>The ID of the AWS Firewall Manager protocols list.</p>
    pub list_id: std::option::Option<std::string::String>,
    /// <p>The name of the AWS Firewall Manager protocols list.</p>
    pub list_name: std::option::Option<std::string::String>,
    /// <p>A unique identifier for each update to the list. When you update
    /// the list, the update token must match the token of the current version of the application list.
    /// You can retrieve the update token by getting the list. </p>
    pub list_update_token: std::option::Option<std::string::String>,
    /// <p>The time that the AWS Firewall Manager protocols list was created.</p>
    pub create_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time that the AWS Firewall Manager protocols list was last updated.</p>
    pub last_update_time: std::option::Option<smithy_types::Instant>,
    /// <p>An array of protocols in the AWS Firewall Manager protocols list.</p>
    pub protocols_list: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A map of previous version numbers to their corresponding protocol arrays.</p>
    pub previous_protocols_list: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
}
impl std::fmt::Debug for ProtocolsListData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProtocolsListData");
        formatter.field("list_id", &self.list_id);
        formatter.field("list_name", &self.list_name);
        formatter.field("list_update_token", &self.list_update_token);
        formatter.field("create_time", &self.create_time);
        formatter.field("last_update_time", &self.last_update_time);
        formatter.field("protocols_list", &self.protocols_list);
        formatter.field("previous_protocols_list", &self.previous_protocols_list);
        formatter.finish()
    }
}
/// See [`ProtocolsListData`](crate::model::ProtocolsListData)
pub mod protocols_list_data {
    /// A builder for [`ProtocolsListData`](crate::model::ProtocolsListData)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) list_id: std::option::Option<std::string::String>,
        pub(crate) list_name: std::option::Option<std::string::String>,
        pub(crate) list_update_token: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_update_time: std::option::Option<smithy_types::Instant>,
        pub(crate) protocols_list: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) previous_protocols_list: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
    }
    impl Builder {
        /// <p>The ID of the AWS Firewall Manager protocols list.</p>
        pub fn list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.list_id = Some(input.into());
            self
        }
        pub fn set_list_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.list_id = input;
            self
        }
        /// <p>The name of the AWS Firewall Manager protocols list.</p>
        pub fn list_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.list_name = Some(input.into());
            self
        }
        pub fn set_list_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.list_name = input;
            self
        }
        /// <p>A unique identifier for each update to the list. When you update
        /// the list, the update token must match the token of the current version of the application list.
        /// You can retrieve the update token by getting the list. </p>
        pub fn list_update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.list_update_token = Some(input.into());
            self
        }
        pub fn set_list_update_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.list_update_token = input;
            self
        }
        /// <p>The time that the AWS Firewall Manager protocols list was created.</p>
        pub fn create_time(mut self, input: smithy_types::Instant) -> Self {
            self.create_time = Some(input);
            self
        }
        pub fn set_create_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The time that the AWS Firewall Manager protocols list was last updated.</p>
        pub fn last_update_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_update_time = Some(input);
            self
        }
        pub fn set_last_update_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_update_time = input;
            self
        }
        pub fn protocols_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.protocols_list.unwrap_or_default();
            v.push(input.into());
            self.protocols_list = Some(v);
            self
        }
        pub fn set_protocols_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.protocols_list = input;
            self
        }
        pub fn previous_protocols_list(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.previous_protocols_list.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.previous_protocols_list = Some(hash_map);
            self
        }
        pub fn set_previous_protocols_list(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.previous_protocols_list = input;
            self
        }
        /// Consumes the builder and constructs a [`ProtocolsListData`](crate::model::ProtocolsListData)
        pub fn build(self) -> crate::model::ProtocolsListData {
            crate::model::ProtocolsListData {
                list_id: self.list_id,
                list_name: self.list_name,
                list_update_token: self.list_update_token,
                create_time: self.create_time,
                last_update_time: self.last_update_time,
                protocols_list: self.protocols_list,
                previous_protocols_list: self.previous_protocols_list,
            }
        }
    }
}
impl ProtocolsListData {
    /// Creates a new builder-style object to manufacture [`ProtocolsListData`](crate::model::ProtocolsListData)
    pub fn builder() -> crate::model::protocols_list_data::Builder {
        crate::model::protocols_list_data::Builder::default()
    }
}

/// <p>An AWS Firewall Manager policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Policy {
    /// <p>The ID of the AWS Firewall Manager policy.</p>
    pub policy_id: std::option::Option<std::string::String>,
    /// <p>The name of the AWS Firewall Manager policy.</p>
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>A unique identifier for each update to the policy. When issuing a <code>PutPolicy</code>
    /// request, the <code>PolicyUpdateToken</code> in the request must match the
    /// <code>PolicyUpdateToken</code> of the current policy version. To get the
    /// <code>PolicyUpdateToken</code> of the current policy version, use a <code>GetPolicy</code>
    /// request.</p>
    pub policy_update_token: std::option::Option<std::string::String>,
    /// <p>Details about the security service that is being used to protect the resources.</p>
    pub security_service_policy_data: std::option::Option<crate::model::SecurityServicePolicyData>,
    /// <p>The type of resource protected by or in scope of the policy. This is in the format shown
    /// in the <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">AWS Resource Types Reference</a>.
    /// For AWS WAF and Shield Advanced, examples include
    /// <code>AWS::ElasticLoadBalancingV2::LoadBalancer</code> and
    /// <code>AWS::CloudFront::Distribution</code>. For a security group common policy, valid values
    /// are <code>AWS::EC2::NetworkInterface</code> and <code>AWS::EC2::Instance</code>. For a
    /// security group content audit policy, valid values are <code>AWS::EC2::SecurityGroup</code>,
    /// <code>AWS::EC2::NetworkInterface</code>, and <code>AWS::EC2::Instance</code>. For a security
    /// group usage audit policy, the value is <code>AWS::EC2::SecurityGroup</code>. For an AWS Network Firewall policy,
    /// the value is <code>AWS::EC2::VPC</code>.</p>
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>An array of <code>ResourceType</code>.</p>
    pub resource_type_list: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An array of <code>ResourceTag</code> objects.</p>
    pub resource_tags: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
    /// <p>If set to <code>True</code>, resources with the tags that are specified in the
    /// <code>ResourceTag</code> array are not in scope of the policy. If set to <code>False</code>,
    /// and the <code>ResourceTag</code> array is not null, only resources with the specified tags are
    /// in scope of the policy.</p>
    pub exclude_resource_tags: bool,
    /// <p>Indicates if the policy should be automatically applied to new resources.</p>
    pub remediation_enabled: bool,
    /// <p>Specifies the AWS account IDs and AWS Organizations organizational units (OUs) to include in the policy.
    /// Specifying an OU is the equivalent of specifying all accounts in the OU and in any of its child OUs, including any child OUs and accounts that are added at a later time.</p>
    /// <p>You can specify inclusions or exclusions, but not both. If you specify an <code>IncludeMap</code>, AWS Firewall Manager
    /// applies the policy to all accounts specified by the <code>IncludeMap</code>, and
    /// does not evaluate any <code>ExcludeMap</code> specifications. If you do not specify an <code>IncludeMap</code>, then Firewall Manager
    /// applies the policy to all accounts except for those specified by the <code>ExcludeMap</code>.</p>
    /// <p>You can specify account IDs, OUs, or a combination: </p>
    /// <ul>
    /// <li>
    /// <p>Specify account IDs by setting the key to <code>ACCOUNT</code>. For example, the following is a valid map:  
    /// <code>{“ACCOUNT” : [“accountID1”, “accountID2”]}</code>.</p>
    /// </li>
    /// <li>
    /// <p>Specify OUs by setting the key to <code>ORG_UNIT</code>. For example, the following is a valid map:
    /// <code>{“ORG_UNIT” : [“ouid111”, “ouid112”]}</code>.</p>
    /// </li>
    /// <li>
    /// <p>Specify accounts and OUs together in a single map, separated with a comma. For example, the following is a valid map:
    /// <code>{“ACCOUNT” : [“accountID1”, “accountID2”], “ORG_UNIT” : [“ouid111”, “ouid112”]}</code>.</p>
    /// </li>
    /// </ul>
    pub include_map: std::option::Option<
        std::collections::HashMap<
            crate::model::CustomerPolicyScopeIdType,
            std::vec::Vec<std::string::String>,
        >,
    >,
    /// <p>Specifies the AWS account IDs and AWS Organizations organizational units (OUs) to exclude from the policy.
    /// Specifying an OU is the equivalent of specifying all accounts in the OU and in any of its child OUs, including any child OUs and accounts that are added at a later time.</p>
    /// <p>You can specify inclusions or exclusions, but not both. If you specify an <code>IncludeMap</code>, AWS Firewall Manager
    /// applies the policy to all accounts specified by the <code>IncludeMap</code>, and
    /// does not evaluate any <code>ExcludeMap</code> specifications. If you do not specify an <code>IncludeMap</code>, then Firewall Manager
    /// applies the policy to all accounts except for those specified by the <code>ExcludeMap</code>.</p>
    /// <p>You can specify account IDs, OUs, or a combination: </p>
    /// <ul>
    /// <li>
    /// <p>Specify account IDs by setting the key to <code>ACCOUNT</code>. For example, the following is a valid map:  
    /// <code>{“ACCOUNT” : [“accountID1”, “accountID2”]}</code>.</p>
    /// </li>
    /// <li>
    /// <p>Specify OUs by setting the key to <code>ORG_UNIT</code>. For example, the following is a valid map:
    /// <code>{“ORG_UNIT” : [“ouid111”, “ouid112”]}</code>.</p>
    /// </li>
    /// <li>
    /// <p>Specify accounts and OUs together in a single map, separated with a comma. For example, the following is a valid map:
    /// <code>{“ACCOUNT” : [“accountID1”, “accountID2”], “ORG_UNIT” : [“ouid111”, “ouid112”]}</code>.</p>
    /// </li>
    /// </ul>
    pub exclude_map: std::option::Option<
        std::collections::HashMap<
            crate::model::CustomerPolicyScopeIdType,
            std::vec::Vec<std::string::String>,
        >,
    >,
}
impl std::fmt::Debug for Policy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Policy");
        formatter.field("policy_id", &self.policy_id);
        formatter.field("policy_name", &self.policy_name);
        formatter.field("policy_update_token", &self.policy_update_token);
        formatter.field(
            "security_service_policy_data",
            &self.security_service_policy_data,
        );
        formatter.field("resource_type", &self.resource_type);
        formatter.field("resource_type_list", &self.resource_type_list);
        formatter.field("resource_tags", &self.resource_tags);
        formatter.field("exclude_resource_tags", &self.exclude_resource_tags);
        formatter.field("remediation_enabled", &self.remediation_enabled);
        formatter.field("include_map", &self.include_map);
        formatter.field("exclude_map", &self.exclude_map);
        formatter.finish()
    }
}
/// See [`Policy`](crate::model::Policy)
pub mod policy {
    /// A builder for [`Policy`](crate::model::Policy)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_id: std::option::Option<std::string::String>,
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) policy_update_token: std::option::Option<std::string::String>,
        pub(crate) security_service_policy_data:
            std::option::Option<crate::model::SecurityServicePolicyData>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) resource_type_list: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) resource_tags: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
        pub(crate) exclude_resource_tags: std::option::Option<bool>,
        pub(crate) remediation_enabled: std::option::Option<bool>,
        pub(crate) include_map: std::option::Option<
            std::collections::HashMap<
                crate::model::CustomerPolicyScopeIdType,
                std::vec::Vec<std::string::String>,
            >,
        >,
        pub(crate) exclude_map: std::option::Option<
            std::collections::HashMap<
                crate::model::CustomerPolicyScopeIdType,
                std::vec::Vec<std::string::String>,
            >,
        >,
    }
    impl Builder {
        /// <p>The ID of the AWS Firewall Manager policy.</p>
        pub fn policy_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_id = Some(input.into());
            self
        }
        pub fn set_policy_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_id = input;
            self
        }
        /// <p>The name of the AWS Firewall Manager policy.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// <p>A unique identifier for each update to the policy. When issuing a <code>PutPolicy</code>
        /// request, the <code>PolicyUpdateToken</code> in the request must match the
        /// <code>PolicyUpdateToken</code> of the current policy version. To get the
        /// <code>PolicyUpdateToken</code> of the current policy version, use a <code>GetPolicy</code>
        /// request.</p>
        pub fn policy_update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_update_token = Some(input.into());
            self
        }
        pub fn set_policy_update_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_update_token = input;
            self
        }
        /// <p>Details about the security service that is being used to protect the resources.</p>
        pub fn security_service_policy_data(
            mut self,
            input: crate::model::SecurityServicePolicyData,
        ) -> Self {
            self.security_service_policy_data = Some(input);
            self
        }
        pub fn set_security_service_policy_data(
            mut self,
            input: std::option::Option<crate::model::SecurityServicePolicyData>,
        ) -> Self {
            self.security_service_policy_data = input;
            self
        }
        /// <p>The type of resource protected by or in scope of the policy. This is in the format shown
        /// in the <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">AWS Resource Types Reference</a>.
        /// For AWS WAF and Shield Advanced, examples include
        /// <code>AWS::ElasticLoadBalancingV2::LoadBalancer</code> and
        /// <code>AWS::CloudFront::Distribution</code>. For a security group common policy, valid values
        /// are <code>AWS::EC2::NetworkInterface</code> and <code>AWS::EC2::Instance</code>. For a
        /// security group content audit policy, valid values are <code>AWS::EC2::SecurityGroup</code>,
        /// <code>AWS::EC2::NetworkInterface</code>, and <code>AWS::EC2::Instance</code>. For a security
        /// group usage audit policy, the value is <code>AWS::EC2::SecurityGroup</code>. For an AWS Network Firewall policy,
        /// the value is <code>AWS::EC2::VPC</code>.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        pub fn resource_type_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.resource_type_list.unwrap_or_default();
            v.push(input.into());
            self.resource_type_list = Some(v);
            self
        }
        pub fn set_resource_type_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.resource_type_list = input;
            self
        }
        pub fn resource_tags(mut self, input: impl Into<crate::model::ResourceTag>) -> Self {
            let mut v = self.resource_tags.unwrap_or_default();
            v.push(input.into());
            self.resource_tags = Some(v);
            self
        }
        pub fn set_resource_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
        ) -> Self {
            self.resource_tags = input;
            self
        }
        /// <p>If set to <code>True</code>, resources with the tags that are specified in the
        /// <code>ResourceTag</code> array are not in scope of the policy. If set to <code>False</code>,
        /// and the <code>ResourceTag</code> array is not null, only resources with the specified tags are
        /// in scope of the policy.</p>
        pub fn exclude_resource_tags(mut self, input: bool) -> Self {
            self.exclude_resource_tags = Some(input);
            self
        }
        pub fn set_exclude_resource_tags(mut self, input: std::option::Option<bool>) -> Self {
            self.exclude_resource_tags = input;
            self
        }
        /// <p>Indicates if the policy should be automatically applied to new resources.</p>
        pub fn remediation_enabled(mut self, input: bool) -> Self {
            self.remediation_enabled = Some(input);
            self
        }
        pub fn set_remediation_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.remediation_enabled = input;
            self
        }
        pub fn include_map(
            mut self,
            k: impl Into<crate::model::CustomerPolicyScopeIdType>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.include_map.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.include_map = Some(hash_map);
            self
        }
        pub fn set_include_map(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    crate::model::CustomerPolicyScopeIdType,
                    std::vec::Vec<std::string::String>,
                >,
            >,
        ) -> Self {
            self.include_map = input;
            self
        }
        pub fn exclude_map(
            mut self,
            k: impl Into<crate::model::CustomerPolicyScopeIdType>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.exclude_map.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.exclude_map = Some(hash_map);
            self
        }
        pub fn set_exclude_map(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    crate::model::CustomerPolicyScopeIdType,
                    std::vec::Vec<std::string::String>,
                >,
            >,
        ) -> Self {
            self.exclude_map = input;
            self
        }
        /// Consumes the builder and constructs a [`Policy`](crate::model::Policy)
        pub fn build(self) -> crate::model::Policy {
            crate::model::Policy {
                policy_id: self.policy_id,
                policy_name: self.policy_name,
                policy_update_token: self.policy_update_token,
                security_service_policy_data: self.security_service_policy_data,
                resource_type: self.resource_type,
                resource_type_list: self.resource_type_list,
                resource_tags: self.resource_tags,
                exclude_resource_tags: self.exclude_resource_tags.unwrap_or_default(),
                remediation_enabled: self.remediation_enabled.unwrap_or_default(),
                include_map: self.include_map,
                exclude_map: self.exclude_map,
            }
        }
    }
}
impl Policy {
    /// Creates a new builder-style object to manufacture [`Policy`](crate::model::Policy)
    pub fn builder() -> crate::model::policy::Builder {
        crate::model::policy::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CustomerPolicyScopeIdType {
    Account,
    OrgUnit,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CustomerPolicyScopeIdType {
    fn from(s: &str) -> Self {
        match s {
            "ACCOUNT" => CustomerPolicyScopeIdType::Account,
            "ORG_UNIT" => CustomerPolicyScopeIdType::OrgUnit,
            other => CustomerPolicyScopeIdType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CustomerPolicyScopeIdType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CustomerPolicyScopeIdType::from(s))
    }
}
impl CustomerPolicyScopeIdType {
    pub fn as_str(&self) -> &str {
        match self {
            CustomerPolicyScopeIdType::Account => "ACCOUNT",
            CustomerPolicyScopeIdType::OrgUnit => "ORG_UNIT",
            CustomerPolicyScopeIdType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["ACCOUNT", "ORG_UNIT"]
    }
}
impl AsRef<str> for CustomerPolicyScopeIdType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The resource tags that AWS Firewall Manager uses to determine if a particular resource
/// should be included or excluded from the AWS Firewall Manager policy. Tags enable you to
/// categorize your AWS resources in different ways, for example, by purpose, owner, or
/// environment. Each tag consists of a key and an optional value. Firewall Manager combines the
/// tags with "AND" so that, if you add more than one tag to a policy scope, a resource must have
/// all the specified tags to be included or excluded. For more information, see
/// <a href="https://docs.aws.amazon.com/awsconsolehelpdocs/latest/gsg/tag-editor.html">Working with Tag Editor</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceTag {
    /// <p>The resource tag key.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The resource tag value.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceTag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceTag");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`ResourceTag`](crate::model::ResourceTag)
pub mod resource_tag {
    /// A builder for [`ResourceTag`](crate::model::ResourceTag)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The resource tag key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The resource tag value.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceTag`](crate::model::ResourceTag)
        pub fn build(self) -> crate::model::ResourceTag {
            crate::model::ResourceTag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl ResourceTag {
    /// Creates a new builder-style object to manufacture [`ResourceTag`](crate::model::ResourceTag)
    pub fn builder() -> crate::model::resource_tag::Builder {
        crate::model::resource_tag::Builder::default()
    }
}

/// <p>Details about the security service that is being used to protect the resources.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SecurityServicePolicyData {
    /// <p>The service that the policy is using to protect the resources. This specifies the type of
    /// policy that is created, either an AWS WAF policy, a Shield Advanced policy, or a security
    /// group policy. For security group policies, Firewall Manager supports one security group for
    /// each common policy and for each content audit policy. This is an adjustable limit that you can
    /// increase by contacting AWS Support.</p>
    pub r#type: std::option::Option<crate::model::SecurityServiceType>,
    /// <p>Details about the service that are specific to the service type, in JSON format. For
    /// service type <code>SHIELD_ADVANCED</code>, this is an empty string.</p>
    /// <ul>
    /// <li>
    /// <p>Example: <code>NETWORK_FIREWALL</code>
    /// </p>
    /// <p>
    /// <code>"{\"type\":\"NETWORK_FIREWALL\",\"networkFirewallStatelessRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-west-1:1234567891011:stateless-rulegroup/rulegroup2\",\"priority\":10}],\"networkFirewallStatelessDefaultActions\":[\"aws:pass\",\"custom1\"],\"networkFirewallStatelessFragmentDefaultActions\":[\"custom2\",\"aws:pass\"],\"networkFirewallStatelessCustomActions\":[{\"actionName\":\"custom1\",\"actionDefinition\":{\"publishMetricAction\":{\"dimensions\":[{\"value\":\"dimension1\"}]}}},{\"actionName\":\"custom2\",\"actionDefinition\":{\"publishMetricAction\":{\"dimensions\":[{\"value\":\"dimension2\"}]}}}],\"networkFirewallStatefulRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-west-1:1234567891011:stateful-rulegroup/rulegroup1\"}],\"networkFirewallOrchestrationConfig\":{\"singleFirewallEndpointPerVPC\":true,\"allowedIPV4CidrList\":[\"10.24.34.0/28\"]} }"</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Example: <code>WAFV2</code>
    /// </p>
    /// <p>
    /// <code>"{\"type\":\"WAFV2\",\"preProcessRuleGroups\":[{\"ruleGroupArn\":null,\"overrideAction\":{\"type\":\"NONE\"},\"managedRuleGroupIdentifier\":{\"version\":null,\"vendorName\":\"AWS\",\"managedRuleGroupName\":\"AWSManagedRulesAmazonIpReputationList\"},\"ruleGroupType\":\"ManagedRuleGroup\",\"excludeRules\":[]}],\"postProcessRuleGroups\":[],\"defaultAction\":{\"type\":\"ALLOW\"},\"overrideCustomerWebACLAssociation\":false,\"loggingConfiguration\":{\"logDestinationConfigs\":[\"arn:aws:firehose:us-west-2:12345678912:deliverystream/aws-waf-logs-fms-admin-destination\"],\"redactedFields\":[{\"redactedFieldType\":\"SingleHeader\",\"redactedFieldValue\":\"Cookies\"},{\"redactedFieldType\":\"Method\"}]}}"</code>
    /// </p>
    /// <p>In the <code>loggingConfiguration</code>, you can specify one <code>logDestinationConfigs</code>, you can optionally provide up to 20 <code>redactedFields</code>, and the <code>RedactedFieldType</code> must be one of <code>URI</code>, <code>QUERY_STRING</code>, <code>HEADER</code>, or <code>METHOD</code>.</p>
    /// </li>
    /// <li>
    /// <p>Example: <code>WAF Classic</code>
    /// </p>
    /// <p>
    /// <code>"{\"type\": \"WAF\", \"ruleGroups\": [{\"id\":\"12345678-1bcd-9012-efga-0987654321ab\", \"overrideAction\" : {\"type\": \"COUNT\"}}], \"defaultAction\": {\"type\": \"BLOCK\"}}"</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Example: <code>SECURITY_GROUPS_COMMON</code>
    /// </p>
    /// <p>
    /// <code>"{\"type\":\"SECURITY_GROUPS_COMMON\",\"revertManualSecurityGroupChanges\":false,\"exclusiveResourceSecurityGroupManagement\":false, \"applyToAllEC2InstanceENIs\":false,\"securityGroups\":[{\"id\":\" sg-000e55995d61a06bd\"}]}"</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Example: <code>SECURITY_GROUPS_CONTENT_AUDIT</code>
    /// </p>
    /// <p>
    /// <code>"{\"type\":\"SECURITY_GROUPS_CONTENT_AUDIT\",\"securityGroups\":[{\"id\":\"sg-000e55995d61a06bd\"}],\"securityGroupAction\":{\"type\":\"ALLOW\"}}"</code>
    /// </p>
    /// <p>The security group action for content audit can be <code>ALLOW</code> or
    /// <code>DENY</code>. For <code>ALLOW</code>, all in-scope security group rules must be
    /// within the allowed range of the policy's security group rules. For <code>DENY</code>, all
    /// in-scope security group rules must not contain a value or a range that matches a rule
    /// value or range in the policy security group.</p>
    /// </li>
    /// <li>
    /// <p>Example: <code>SECURITY_GROUPS_USAGE_AUDIT</code>
    /// </p>
    /// <p>
    /// <code>"{\"type\":\"SECURITY_GROUPS_USAGE_AUDIT\",\"deleteUnusedSecurityGroups\":true,\"coalesceRedundantSecurityGroups\":true}"</code>
    /// </p>
    /// </li>
    /// </ul>
    pub managed_service_data: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SecurityServicePolicyData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SecurityServicePolicyData");
        formatter.field("r#type", &self.r#type);
        formatter.field("managed_service_data", &self.managed_service_data);
        formatter.finish()
    }
}
/// See [`SecurityServicePolicyData`](crate::model::SecurityServicePolicyData)
pub mod security_service_policy_data {
    /// A builder for [`SecurityServicePolicyData`](crate::model::SecurityServicePolicyData)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::SecurityServiceType>,
        pub(crate) managed_service_data: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The service that the policy is using to protect the resources. This specifies the type of
        /// policy that is created, either an AWS WAF policy, a Shield Advanced policy, or a security
        /// group policy. For security group policies, Firewall Manager supports one security group for
        /// each common policy and for each content audit policy. This is an adjustable limit that you can
        /// increase by contacting AWS Support.</p>
        pub fn r#type(mut self, input: crate::model::SecurityServiceType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::SecurityServiceType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Details about the service that are specific to the service type, in JSON format. For
        /// service type <code>SHIELD_ADVANCED</code>, this is an empty string.</p>
        /// <ul>
        /// <li>
        /// <p>Example: <code>NETWORK_FIREWALL</code>
        /// </p>
        /// <p>
        /// <code>"{\"type\":\"NETWORK_FIREWALL\",\"networkFirewallStatelessRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-west-1:1234567891011:stateless-rulegroup/rulegroup2\",\"priority\":10}],\"networkFirewallStatelessDefaultActions\":[\"aws:pass\",\"custom1\"],\"networkFirewallStatelessFragmentDefaultActions\":[\"custom2\",\"aws:pass\"],\"networkFirewallStatelessCustomActions\":[{\"actionName\":\"custom1\",\"actionDefinition\":{\"publishMetricAction\":{\"dimensions\":[{\"value\":\"dimension1\"}]}}},{\"actionName\":\"custom2\",\"actionDefinition\":{\"publishMetricAction\":{\"dimensions\":[{\"value\":\"dimension2\"}]}}}],\"networkFirewallStatefulRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-west-1:1234567891011:stateful-rulegroup/rulegroup1\"}],\"networkFirewallOrchestrationConfig\":{\"singleFirewallEndpointPerVPC\":true,\"allowedIPV4CidrList\":[\"10.24.34.0/28\"]} }"</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Example: <code>WAFV2</code>
        /// </p>
        /// <p>
        /// <code>"{\"type\":\"WAFV2\",\"preProcessRuleGroups\":[{\"ruleGroupArn\":null,\"overrideAction\":{\"type\":\"NONE\"},\"managedRuleGroupIdentifier\":{\"version\":null,\"vendorName\":\"AWS\",\"managedRuleGroupName\":\"AWSManagedRulesAmazonIpReputationList\"},\"ruleGroupType\":\"ManagedRuleGroup\",\"excludeRules\":[]}],\"postProcessRuleGroups\":[],\"defaultAction\":{\"type\":\"ALLOW\"},\"overrideCustomerWebACLAssociation\":false,\"loggingConfiguration\":{\"logDestinationConfigs\":[\"arn:aws:firehose:us-west-2:12345678912:deliverystream/aws-waf-logs-fms-admin-destination\"],\"redactedFields\":[{\"redactedFieldType\":\"SingleHeader\",\"redactedFieldValue\":\"Cookies\"},{\"redactedFieldType\":\"Method\"}]}}"</code>
        /// </p>
        /// <p>In the <code>loggingConfiguration</code>, you can specify one <code>logDestinationConfigs</code>, you can optionally provide up to 20 <code>redactedFields</code>, and the <code>RedactedFieldType</code> must be one of <code>URI</code>, <code>QUERY_STRING</code>, <code>HEADER</code>, or <code>METHOD</code>.</p>
        /// </li>
        /// <li>
        /// <p>Example: <code>WAF Classic</code>
        /// </p>
        /// <p>
        /// <code>"{\"type\": \"WAF\", \"ruleGroups\": [{\"id\":\"12345678-1bcd-9012-efga-0987654321ab\", \"overrideAction\" : {\"type\": \"COUNT\"}}], \"defaultAction\": {\"type\": \"BLOCK\"}}"</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Example: <code>SECURITY_GROUPS_COMMON</code>
        /// </p>
        /// <p>
        /// <code>"{\"type\":\"SECURITY_GROUPS_COMMON\",\"revertManualSecurityGroupChanges\":false,\"exclusiveResourceSecurityGroupManagement\":false, \"applyToAllEC2InstanceENIs\":false,\"securityGroups\":[{\"id\":\" sg-000e55995d61a06bd\"}]}"</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Example: <code>SECURITY_GROUPS_CONTENT_AUDIT</code>
        /// </p>
        /// <p>
        /// <code>"{\"type\":\"SECURITY_GROUPS_CONTENT_AUDIT\",\"securityGroups\":[{\"id\":\"sg-000e55995d61a06bd\"}],\"securityGroupAction\":{\"type\":\"ALLOW\"}}"</code>
        /// </p>
        /// <p>The security group action for content audit can be <code>ALLOW</code> or
        /// <code>DENY</code>. For <code>ALLOW</code>, all in-scope security group rules must be
        /// within the allowed range of the policy's security group rules. For <code>DENY</code>, all
        /// in-scope security group rules must not contain a value or a range that matches a rule
        /// value or range in the policy security group.</p>
        /// </li>
        /// <li>
        /// <p>Example: <code>SECURITY_GROUPS_USAGE_AUDIT</code>
        /// </p>
        /// <p>
        /// <code>"{\"type\":\"SECURITY_GROUPS_USAGE_AUDIT\",\"deleteUnusedSecurityGroups\":true,\"coalesceRedundantSecurityGroups\":true}"</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn managed_service_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.managed_service_data = Some(input.into());
            self
        }
        pub fn set_managed_service_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.managed_service_data = input;
            self
        }
        /// Consumes the builder and constructs a [`SecurityServicePolicyData`](crate::model::SecurityServicePolicyData)
        pub fn build(self) -> crate::model::SecurityServicePolicyData {
            crate::model::SecurityServicePolicyData {
                r#type: self.r#type,
                managed_service_data: self.managed_service_data,
            }
        }
    }
}
impl SecurityServicePolicyData {
    /// Creates a new builder-style object to manufacture [`SecurityServicePolicyData`](crate::model::SecurityServicePolicyData)
    pub fn builder() -> crate::model::security_service_policy_data::Builder {
        crate::model::security_service_policy_data::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SecurityServiceType {
    DnsFirewall,
    NetworkFirewall,
    SecurityGroupsCommon,
    SecurityGroupsContentAudit,
    SecurityGroupsUsageAudit,
    ShieldAdvanced,
    Waf,
    Wafv2,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SecurityServiceType {
    fn from(s: &str) -> Self {
        match s {
            "DNS_FIREWALL" => SecurityServiceType::DnsFirewall,
            "NETWORK_FIREWALL" => SecurityServiceType::NetworkFirewall,
            "SECURITY_GROUPS_COMMON" => SecurityServiceType::SecurityGroupsCommon,
            "SECURITY_GROUPS_CONTENT_AUDIT" => SecurityServiceType::SecurityGroupsContentAudit,
            "SECURITY_GROUPS_USAGE_AUDIT" => SecurityServiceType::SecurityGroupsUsageAudit,
            "SHIELD_ADVANCED" => SecurityServiceType::ShieldAdvanced,
            "WAF" => SecurityServiceType::Waf,
            "WAFV2" => SecurityServiceType::Wafv2,
            other => SecurityServiceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SecurityServiceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SecurityServiceType::from(s))
    }
}
impl SecurityServiceType {
    pub fn as_str(&self) -> &str {
        match self {
            SecurityServiceType::DnsFirewall => "DNS_FIREWALL",
            SecurityServiceType::NetworkFirewall => "NETWORK_FIREWALL",
            SecurityServiceType::SecurityGroupsCommon => "SECURITY_GROUPS_COMMON",
            SecurityServiceType::SecurityGroupsContentAudit => "SECURITY_GROUPS_CONTENT_AUDIT",
            SecurityServiceType::SecurityGroupsUsageAudit => "SECURITY_GROUPS_USAGE_AUDIT",
            SecurityServiceType::ShieldAdvanced => "SHIELD_ADVANCED",
            SecurityServiceType::Waf => "WAF",
            SecurityServiceType::Wafv2 => "WAFV2",
            SecurityServiceType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "DNS_FIREWALL",
            "NETWORK_FIREWALL",
            "SECURITY_GROUPS_COMMON",
            "SECURITY_GROUPS_CONTENT_AUDIT",
            "SECURITY_GROUPS_USAGE_AUDIT",
            "SHIELD_ADVANCED",
            "WAF",
            "WAFV2",
        ]
    }
}
impl AsRef<str> for SecurityServiceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An AWS Firewall Manager applications list.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AppsListData {
    /// <p>The ID of the AWS Firewall Manager applications list.</p>
    pub list_id: std::option::Option<std::string::String>,
    /// <p>The name of the AWS Firewall Manager applications list.</p>
    pub list_name: std::option::Option<std::string::String>,
    /// <p>A unique identifier for each update to the list. When you update
    /// the list, the update token must match the token of the current version of the application list.
    /// You can retrieve the update token by getting the list. </p>
    pub list_update_token: std::option::Option<std::string::String>,
    /// <p>The time that the AWS Firewall Manager applications list was created.</p>
    pub create_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time that the AWS Firewall Manager applications list was last updated.</p>
    pub last_update_time: std::option::Option<smithy_types::Instant>,
    /// <p>An array of applications in the AWS Firewall Manager applications list.</p>
    pub apps_list: std::option::Option<std::vec::Vec<crate::model::App>>,
    /// <p>A map of previous version numbers to their corresponding <code>App</code> object arrays.</p>
    pub previous_apps_list: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<crate::model::App>>,
    >,
}
impl std::fmt::Debug for AppsListData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AppsListData");
        formatter.field("list_id", &self.list_id);
        formatter.field("list_name", &self.list_name);
        formatter.field("list_update_token", &self.list_update_token);
        formatter.field("create_time", &self.create_time);
        formatter.field("last_update_time", &self.last_update_time);
        formatter.field("apps_list", &self.apps_list);
        formatter.field("previous_apps_list", &self.previous_apps_list);
        formatter.finish()
    }
}
/// See [`AppsListData`](crate::model::AppsListData)
pub mod apps_list_data {
    /// A builder for [`AppsListData`](crate::model::AppsListData)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) list_id: std::option::Option<std::string::String>,
        pub(crate) list_name: std::option::Option<std::string::String>,
        pub(crate) list_update_token: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_update_time: std::option::Option<smithy_types::Instant>,
        pub(crate) apps_list: std::option::Option<std::vec::Vec<crate::model::App>>,
        pub(crate) previous_apps_list: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<crate::model::App>>,
        >,
    }
    impl Builder {
        /// <p>The ID of the AWS Firewall Manager applications list.</p>
        pub fn list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.list_id = Some(input.into());
            self
        }
        pub fn set_list_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.list_id = input;
            self
        }
        /// <p>The name of the AWS Firewall Manager applications list.</p>
        pub fn list_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.list_name = Some(input.into());
            self
        }
        pub fn set_list_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.list_name = input;
            self
        }
        /// <p>A unique identifier for each update to the list. When you update
        /// the list, the update token must match the token of the current version of the application list.
        /// You can retrieve the update token by getting the list. </p>
        pub fn list_update_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.list_update_token = Some(input.into());
            self
        }
        pub fn set_list_update_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.list_update_token = input;
            self
        }
        /// <p>The time that the AWS Firewall Manager applications list was created.</p>
        pub fn create_time(mut self, input: smithy_types::Instant) -> Self {
            self.create_time = Some(input);
            self
        }
        pub fn set_create_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The time that the AWS Firewall Manager applications list was last updated.</p>
        pub fn last_update_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_update_time = Some(input);
            self
        }
        pub fn set_last_update_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_update_time = input;
            self
        }
        pub fn apps_list(mut self, input: impl Into<crate::model::App>) -> Self {
            let mut v = self.apps_list.unwrap_or_default();
            v.push(input.into());
            self.apps_list = Some(v);
            self
        }
        pub fn set_apps_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::App>>,
        ) -> Self {
            self.apps_list = input;
            self
        }
        pub fn previous_apps_list(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<crate::model::App>>,
        ) -> Self {
            let mut hash_map = self.previous_apps_list.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.previous_apps_list = Some(hash_map);
            self
        }
        pub fn set_previous_apps_list(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<crate::model::App>>,
            >,
        ) -> Self {
            self.previous_apps_list = input;
            self
        }
        /// Consumes the builder and constructs a [`AppsListData`](crate::model::AppsListData)
        pub fn build(self) -> crate::model::AppsListData {
            crate::model::AppsListData {
                list_id: self.list_id,
                list_name: self.list_name,
                list_update_token: self.list_update_token,
                create_time: self.create_time,
                last_update_time: self.last_update_time,
                apps_list: self.apps_list,
                previous_apps_list: self.previous_apps_list,
            }
        }
    }
}
impl AppsListData {
    /// Creates a new builder-style object to manufacture [`AppsListData`](crate::model::AppsListData)
    pub fn builder() -> crate::model::apps_list_data::Builder {
        crate::model::apps_list_data::Builder::default()
    }
}

/// <p>An individual AWS Firewall Manager application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct App {
    /// <p>The application's name.</p>
    pub app_name: std::option::Option<std::string::String>,
    /// <p>The IP protocol name or number. The name can be one of <code>tcp</code>, <code>udp</code>, or <code>icmp</code>. For information on possible numbers, see <a href="https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers</a>.</p>
    pub protocol: std::option::Option<std::string::String>,
    /// <p>The application's port number, for example <code>80</code>.</p>
    pub port: std::option::Option<i64>,
}
impl std::fmt::Debug for App {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("App");
        formatter.field("app_name", &self.app_name);
        formatter.field("protocol", &self.protocol);
        formatter.field("port", &self.port);
        formatter.finish()
    }
}
/// See [`App`](crate::model::App)
pub mod app {
    /// A builder for [`App`](crate::model::App)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_name: std::option::Option<std::string::String>,
        pub(crate) protocol: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The application's name.</p>
        pub fn app_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_name = Some(input.into());
            self
        }
        pub fn set_app_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_name = input;
            self
        }
        /// <p>The IP protocol name or number. The name can be one of <code>tcp</code>, <code>udp</code>, or <code>icmp</code>. For information on possible numbers, see <a href="https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers</a>.</p>
        pub fn protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.protocol = Some(input.into());
            self
        }
        pub fn set_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.protocol = input;
            self
        }
        /// <p>The application's port number, for example <code>80</code>.</p>
        pub fn port(mut self, input: i64) -> Self {
            self.port = Some(input);
            self
        }
        pub fn set_port(mut self, input: std::option::Option<i64>) -> Self {
            self.port = input;
            self
        }
        /// Consumes the builder and constructs a [`App`](crate::model::App)
        pub fn build(self) -> crate::model::App {
            crate::model::App {
                app_name: self.app_name,
                protocol: self.protocol,
                port: self.port,
            }
        }
    }
}
impl App {
    /// Creates a new builder-style object to manufacture [`App`](crate::model::App)
    pub fn builder() -> crate::model::app::Builder {
        crate::model::app::Builder::default()
    }
}

/// <p>Details of the AWS Firewall Manager protocols list.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProtocolsListDataSummary {
    /// <p>The Amazon Resource Name (ARN) of the specified protocols list.</p>
    pub list_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the specified protocols list.</p>
    pub list_id: std::option::Option<std::string::String>,
    /// <p>The name of the specified protocols list.</p>
    pub list_name: std::option::Option<std::string::String>,
    /// <p>An array of protocols in the AWS Firewall Manager protocols list.</p>
    pub protocols_list: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for ProtocolsListDataSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProtocolsListDataSummary");
        formatter.field("list_arn", &self.list_arn);
        formatter.field("list_id", &self.list_id);
        formatter.field("list_name", &self.list_name);
        formatter.field("protocols_list", &self.protocols_list);
        formatter.finish()
    }
}
/// See [`ProtocolsListDataSummary`](crate::model::ProtocolsListDataSummary)
pub mod protocols_list_data_summary {
    /// A builder for [`ProtocolsListDataSummary`](crate::model::ProtocolsListDataSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) list_arn: std::option::Option<std::string::String>,
        pub(crate) list_id: std::option::Option<std::string::String>,
        pub(crate) list_name: std::option::Option<std::string::String>,
        pub(crate) protocols_list: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the specified protocols list.</p>
        pub fn list_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.list_arn = Some(input.into());
            self
        }
        pub fn set_list_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.list_arn = input;
            self
        }
        /// <p>The ID of the specified protocols list.</p>
        pub fn list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.list_id = Some(input.into());
            self
        }
        pub fn set_list_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.list_id = input;
            self
        }
        /// <p>The name of the specified protocols list.</p>
        pub fn list_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.list_name = Some(input.into());
            self
        }
        pub fn set_list_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.list_name = input;
            self
        }
        pub fn protocols_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.protocols_list.unwrap_or_default();
            v.push(input.into());
            self.protocols_list = Some(v);
            self
        }
        pub fn set_protocols_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.protocols_list = input;
            self
        }
        /// Consumes the builder and constructs a [`ProtocolsListDataSummary`](crate::model::ProtocolsListDataSummary)
        pub fn build(self) -> crate::model::ProtocolsListDataSummary {
            crate::model::ProtocolsListDataSummary {
                list_arn: self.list_arn,
                list_id: self.list_id,
                list_name: self.list_name,
                protocols_list: self.protocols_list,
            }
        }
    }
}
impl ProtocolsListDataSummary {
    /// Creates a new builder-style object to manufacture [`ProtocolsListDataSummary`](crate::model::ProtocolsListDataSummary)
    pub fn builder() -> crate::model::protocols_list_data_summary::Builder {
        crate::model::protocols_list_data_summary::Builder::default()
    }
}

/// <p>Details of the AWS Firewall Manager policy. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PolicySummary {
    /// <p>The Amazon Resource Name (ARN) of the specified policy.</p>
    pub policy_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the specified policy.</p>
    pub policy_id: std::option::Option<std::string::String>,
    /// <p>The name of the specified policy.</p>
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>The type of resource protected by or in scope of the policy. This is in the format shown
    /// in the <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">AWS Resource Types Reference</a>.
    /// For AWS WAF and Shield Advanced, examples include
    /// <code>AWS::ElasticLoadBalancingV2::LoadBalancer</code> and
    /// <code>AWS::CloudFront::Distribution</code>. For a security group common policy, valid values
    /// are <code>AWS::EC2::NetworkInterface</code> and <code>AWS::EC2::Instance</code>. For a
    /// security group content audit policy, valid values are <code>AWS::EC2::SecurityGroup</code>,
    /// <code>AWS::EC2::NetworkInterface</code>, and <code>AWS::EC2::Instance</code>. For a security
    /// group usage audit policy, the value is <code>AWS::EC2::SecurityGroup</code>. For an AWS Network Firewall policy,
    /// the value is <code>AWS::EC2::VPC</code>.</p>
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The service that the policy is using to protect the resources. This specifies the type of
    /// policy that is created, either an AWS WAF policy, a Shield Advanced policy, or a security
    /// group policy.</p>
    pub security_service_type: std::option::Option<crate::model::SecurityServiceType>,
    /// <p>Indicates if the policy should be automatically applied to new resources.</p>
    pub remediation_enabled: bool,
}
impl std::fmt::Debug for PolicySummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PolicySummary");
        formatter.field("policy_arn", &self.policy_arn);
        formatter.field("policy_id", &self.policy_id);
        formatter.field("policy_name", &self.policy_name);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("security_service_type", &self.security_service_type);
        formatter.field("remediation_enabled", &self.remediation_enabled);
        formatter.finish()
    }
}
/// See [`PolicySummary`](crate::model::PolicySummary)
pub mod policy_summary {
    /// A builder for [`PolicySummary`](crate::model::PolicySummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_arn: std::option::Option<std::string::String>,
        pub(crate) policy_id: std::option::Option<std::string::String>,
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) security_service_type: std::option::Option<crate::model::SecurityServiceType>,
        pub(crate) remediation_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the specified policy.</p>
        pub fn policy_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_arn = Some(input.into());
            self
        }
        pub fn set_policy_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_arn = input;
            self
        }
        /// <p>The ID of the specified policy.</p>
        pub fn policy_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_id = Some(input.into());
            self
        }
        pub fn set_policy_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_id = input;
            self
        }
        /// <p>The name of the specified policy.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// <p>The type of resource protected by or in scope of the policy. This is in the format shown
        /// in the <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">AWS Resource Types Reference</a>.
        /// For AWS WAF and Shield Advanced, examples include
        /// <code>AWS::ElasticLoadBalancingV2::LoadBalancer</code> and
        /// <code>AWS::CloudFront::Distribution</code>. For a security group common policy, valid values
        /// are <code>AWS::EC2::NetworkInterface</code> and <code>AWS::EC2::Instance</code>. For a
        /// security group content audit policy, valid values are <code>AWS::EC2::SecurityGroup</code>,
        /// <code>AWS::EC2::NetworkInterface</code>, and <code>AWS::EC2::Instance</code>. For a security
        /// group usage audit policy, the value is <code>AWS::EC2::SecurityGroup</code>. For an AWS Network Firewall policy,
        /// the value is <code>AWS::EC2::VPC</code>.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The service that the policy is using to protect the resources. This specifies the type of
        /// policy that is created, either an AWS WAF policy, a Shield Advanced policy, or a security
        /// group policy.</p>
        pub fn security_service_type(mut self, input: crate::model::SecurityServiceType) -> Self {
            self.security_service_type = Some(input);
            self
        }
        pub fn set_security_service_type(
            mut self,
            input: std::option::Option<crate::model::SecurityServiceType>,
        ) -> Self {
            self.security_service_type = input;
            self
        }
        /// <p>Indicates if the policy should be automatically applied to new resources.</p>
        pub fn remediation_enabled(mut self, input: bool) -> Self {
            self.remediation_enabled = Some(input);
            self
        }
        pub fn set_remediation_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.remediation_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`PolicySummary`](crate::model::PolicySummary)
        pub fn build(self) -> crate::model::PolicySummary {
            crate::model::PolicySummary {
                policy_arn: self.policy_arn,
                policy_id: self.policy_id,
                policy_name: self.policy_name,
                resource_type: self.resource_type,
                security_service_type: self.security_service_type,
                remediation_enabled: self.remediation_enabled.unwrap_or_default(),
            }
        }
    }
}
impl PolicySummary {
    /// Creates a new builder-style object to manufacture [`PolicySummary`](crate::model::PolicySummary)
    pub fn builder() -> crate::model::policy_summary::Builder {
        crate::model::policy_summary::Builder::default()
    }
}

/// <p>Indicates whether the account is compliant with the specified policy. An account is
/// considered noncompliant if it includes resources that are not protected by the policy, for AWS
/// WAF and Shield Advanced policies, or that are noncompliant with the policy, for security group
/// policies.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PolicyComplianceStatus {
    /// <p>The AWS account that created the AWS Firewall Manager policy.</p>
    pub policy_owner: std::option::Option<std::string::String>,
    /// <p>The ID of the AWS Firewall Manager policy.</p>
    pub policy_id: std::option::Option<std::string::String>,
    /// <p>The name of the AWS Firewall Manager policy.</p>
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>The member account ID.</p>
    pub member_account: std::option::Option<std::string::String>,
    /// <p>An array of <code>EvaluationResult</code> objects.</p>
    pub evaluation_results: std::option::Option<std::vec::Vec<crate::model::EvaluationResult>>,
    /// <p>Timestamp of the last update to the <code>EvaluationResult</code> objects.</p>
    pub last_updated: std::option::Option<smithy_types::Instant>,
    /// <p>Details about problems with dependent services, such as AWS WAF or AWS Config, that are
    /// causing a resource to be noncompliant. The details include the name of the dependent service
    /// and the error message received that indicates the problem with the service.</p>
    pub issue_info_map: std::option::Option<
        std::collections::HashMap<crate::model::DependentServiceName, std::string::String>,
    >,
}
impl std::fmt::Debug for PolicyComplianceStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PolicyComplianceStatus");
        formatter.field("policy_owner", &self.policy_owner);
        formatter.field("policy_id", &self.policy_id);
        formatter.field("policy_name", &self.policy_name);
        formatter.field("member_account", &self.member_account);
        formatter.field("evaluation_results", &self.evaluation_results);
        formatter.field("last_updated", &self.last_updated);
        formatter.field("issue_info_map", &self.issue_info_map);
        formatter.finish()
    }
}
/// See [`PolicyComplianceStatus`](crate::model::PolicyComplianceStatus)
pub mod policy_compliance_status {
    /// A builder for [`PolicyComplianceStatus`](crate::model::PolicyComplianceStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_owner: std::option::Option<std::string::String>,
        pub(crate) policy_id: std::option::Option<std::string::String>,
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) member_account: std::option::Option<std::string::String>,
        pub(crate) evaluation_results:
            std::option::Option<std::vec::Vec<crate::model::EvaluationResult>>,
        pub(crate) last_updated: std::option::Option<smithy_types::Instant>,
        pub(crate) issue_info_map: std::option::Option<
            std::collections::HashMap<crate::model::DependentServiceName, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The AWS account that created the AWS Firewall Manager policy.</p>
        pub fn policy_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_owner = Some(input.into());
            self
        }
        pub fn set_policy_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_owner = input;
            self
        }
        /// <p>The ID of the AWS Firewall Manager policy.</p>
        pub fn policy_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_id = Some(input.into());
            self
        }
        pub fn set_policy_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_id = input;
            self
        }
        /// <p>The name of the AWS Firewall Manager policy.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// <p>The member account ID.</p>
        pub fn member_account(mut self, input: impl Into<std::string::String>) -> Self {
            self.member_account = Some(input.into());
            self
        }
        pub fn set_member_account(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.member_account = input;
            self
        }
        pub fn evaluation_results(
            mut self,
            input: impl Into<crate::model::EvaluationResult>,
        ) -> Self {
            let mut v = self.evaluation_results.unwrap_or_default();
            v.push(input.into());
            self.evaluation_results = Some(v);
            self
        }
        pub fn set_evaluation_results(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EvaluationResult>>,
        ) -> Self {
            self.evaluation_results = input;
            self
        }
        /// <p>Timestamp of the last update to the <code>EvaluationResult</code> objects.</p>
        pub fn last_updated(mut self, input: smithy_types::Instant) -> Self {
            self.last_updated = Some(input);
            self
        }
        pub fn set_last_updated(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_updated = input;
            self
        }
        pub fn issue_info_map(
            mut self,
            k: impl Into<crate::model::DependentServiceName>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.issue_info_map.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.issue_info_map = Some(hash_map);
            self
        }
        pub fn set_issue_info_map(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<crate::model::DependentServiceName, std::string::String>,
            >,
        ) -> Self {
            self.issue_info_map = input;
            self
        }
        /// Consumes the builder and constructs a [`PolicyComplianceStatus`](crate::model::PolicyComplianceStatus)
        pub fn build(self) -> crate::model::PolicyComplianceStatus {
            crate::model::PolicyComplianceStatus {
                policy_owner: self.policy_owner,
                policy_id: self.policy_id,
                policy_name: self.policy_name,
                member_account: self.member_account,
                evaluation_results: self.evaluation_results,
                last_updated: self.last_updated,
                issue_info_map: self.issue_info_map,
            }
        }
    }
}
impl PolicyComplianceStatus {
    /// Creates a new builder-style object to manufacture [`PolicyComplianceStatus`](crate::model::PolicyComplianceStatus)
    pub fn builder() -> crate::model::policy_compliance_status::Builder {
        crate::model::policy_compliance_status::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DependentServiceName {
    AwsConfig,
    AwsShieldAdvanced,
    AwsVirtualPrivateCloud,
    Awswaf,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DependentServiceName {
    fn from(s: &str) -> Self {
        match s {
            "AWSCONFIG" => DependentServiceName::AwsConfig,
            "AWSSHIELD_ADVANCED" => DependentServiceName::AwsShieldAdvanced,
            "AWSVPC" => DependentServiceName::AwsVirtualPrivateCloud,
            "AWSWAF" => DependentServiceName::Awswaf,
            other => DependentServiceName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DependentServiceName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DependentServiceName::from(s))
    }
}
impl DependentServiceName {
    pub fn as_str(&self) -> &str {
        match self {
            DependentServiceName::AwsConfig => "AWSCONFIG",
            DependentServiceName::AwsShieldAdvanced => "AWSSHIELD_ADVANCED",
            DependentServiceName::AwsVirtualPrivateCloud => "AWSVPC",
            DependentServiceName::Awswaf => "AWSWAF",
            DependentServiceName::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["AWSCONFIG", "AWSSHIELD_ADVANCED", "AWSVPC", "AWSWAF"]
    }
}
impl AsRef<str> for DependentServiceName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the compliance status for the account. An account is considered noncompliant if
/// it includes resources that are not protected by the specified policy or that don't comply with
/// the policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EvaluationResult {
    /// <p>Describes an AWS account's compliance with the AWS Firewall Manager policy.</p>
    pub compliance_status: std::option::Option<crate::model::PolicyComplianceStatusType>,
    /// <p>The number of resources that are noncompliant with the specified policy. For AWS WAF and
    /// Shield Advanced policies, a resource is considered noncompliant if it is not associated with
    /// the policy. For security group policies, a resource is considered noncompliant if it doesn't
    /// comply with the rules of the policy and remediation is disabled or not possible.</p>
    pub violator_count: i64,
    /// <p>Indicates that over 100 resources are noncompliant with the AWS Firewall Manager
    /// policy.</p>
    pub evaluation_limit_exceeded: bool,
}
impl std::fmt::Debug for EvaluationResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EvaluationResult");
        formatter.field("compliance_status", &self.compliance_status);
        formatter.field("violator_count", &self.violator_count);
        formatter.field("evaluation_limit_exceeded", &self.evaluation_limit_exceeded);
        formatter.finish()
    }
}
/// See [`EvaluationResult`](crate::model::EvaluationResult)
pub mod evaluation_result {
    /// A builder for [`EvaluationResult`](crate::model::EvaluationResult)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) compliance_status: std::option::Option<crate::model::PolicyComplianceStatusType>,
        pub(crate) violator_count: std::option::Option<i64>,
        pub(crate) evaluation_limit_exceeded: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Describes an AWS account's compliance with the AWS Firewall Manager policy.</p>
        pub fn compliance_status(
            mut self,
            input: crate::model::PolicyComplianceStatusType,
        ) -> Self {
            self.compliance_status = Some(input);
            self
        }
        pub fn set_compliance_status(
            mut self,
            input: std::option::Option<crate::model::PolicyComplianceStatusType>,
        ) -> Self {
            self.compliance_status = input;
            self
        }
        /// <p>The number of resources that are noncompliant with the specified policy. For AWS WAF and
        /// Shield Advanced policies, a resource is considered noncompliant if it is not associated with
        /// the policy. For security group policies, a resource is considered noncompliant if it doesn't
        /// comply with the rules of the policy and remediation is disabled or not possible.</p>
        pub fn violator_count(mut self, input: i64) -> Self {
            self.violator_count = Some(input);
            self
        }
        pub fn set_violator_count(mut self, input: std::option::Option<i64>) -> Self {
            self.violator_count = input;
            self
        }
        /// <p>Indicates that over 100 resources are noncompliant with the AWS Firewall Manager
        /// policy.</p>
        pub fn evaluation_limit_exceeded(mut self, input: bool) -> Self {
            self.evaluation_limit_exceeded = Some(input);
            self
        }
        pub fn set_evaluation_limit_exceeded(mut self, input: std::option::Option<bool>) -> Self {
            self.evaluation_limit_exceeded = input;
            self
        }
        /// Consumes the builder and constructs a [`EvaluationResult`](crate::model::EvaluationResult)
        pub fn build(self) -> crate::model::EvaluationResult {
            crate::model::EvaluationResult {
                compliance_status: self.compliance_status,
                violator_count: self.violator_count.unwrap_or_default(),
                evaluation_limit_exceeded: self.evaluation_limit_exceeded.unwrap_or_default(),
            }
        }
    }
}
impl EvaluationResult {
    /// Creates a new builder-style object to manufacture [`EvaluationResult`](crate::model::EvaluationResult)
    pub fn builder() -> crate::model::evaluation_result::Builder {
        crate::model::evaluation_result::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PolicyComplianceStatusType {
    Compliant,
    NonCompliant,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PolicyComplianceStatusType {
    fn from(s: &str) -> Self {
        match s {
            "COMPLIANT" => PolicyComplianceStatusType::Compliant,
            "NON_COMPLIANT" => PolicyComplianceStatusType::NonCompliant,
            other => PolicyComplianceStatusType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PolicyComplianceStatusType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PolicyComplianceStatusType::from(s))
    }
}
impl PolicyComplianceStatusType {
    pub fn as_str(&self) -> &str {
        match self {
            PolicyComplianceStatusType::Compliant => "COMPLIANT",
            PolicyComplianceStatusType::NonCompliant => "NON_COMPLIANT",
            PolicyComplianceStatusType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["COMPLIANT", "NON_COMPLIANT"]
    }
}
impl AsRef<str> for PolicyComplianceStatusType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details of the AWS Firewall Manager applications list.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AppsListDataSummary {
    /// <p>The Amazon Resource Name (ARN) of the applications list.</p>
    pub list_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the applications list.</p>
    pub list_id: std::option::Option<std::string::String>,
    /// <p>The name of the applications list.</p>
    pub list_name: std::option::Option<std::string::String>,
    /// <p>An array of <code>App</code> objects in the AWS Firewall Manager applications list.</p>
    pub apps_list: std::option::Option<std::vec::Vec<crate::model::App>>,
}
impl std::fmt::Debug for AppsListDataSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AppsListDataSummary");
        formatter.field("list_arn", &self.list_arn);
        formatter.field("list_id", &self.list_id);
        formatter.field("list_name", &self.list_name);
        formatter.field("apps_list", &self.apps_list);
        formatter.finish()
    }
}
/// See [`AppsListDataSummary`](crate::model::AppsListDataSummary)
pub mod apps_list_data_summary {
    /// A builder for [`AppsListDataSummary`](crate::model::AppsListDataSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) list_arn: std::option::Option<std::string::String>,
        pub(crate) list_id: std::option::Option<std::string::String>,
        pub(crate) list_name: std::option::Option<std::string::String>,
        pub(crate) apps_list: std::option::Option<std::vec::Vec<crate::model::App>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the applications list.</p>
        pub fn list_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.list_arn = Some(input.into());
            self
        }
        pub fn set_list_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.list_arn = input;
            self
        }
        /// <p>The ID of the applications list.</p>
        pub fn list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.list_id = Some(input.into());
            self
        }
        pub fn set_list_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.list_id = input;
            self
        }
        /// <p>The name of the applications list.</p>
        pub fn list_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.list_name = Some(input.into());
            self
        }
        pub fn set_list_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.list_name = input;
            self
        }
        pub fn apps_list(mut self, input: impl Into<crate::model::App>) -> Self {
            let mut v = self.apps_list.unwrap_or_default();
            v.push(input.into());
            self.apps_list = Some(v);
            self
        }
        pub fn set_apps_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::App>>,
        ) -> Self {
            self.apps_list = input;
            self
        }
        /// Consumes the builder and constructs a [`AppsListDataSummary`](crate::model::AppsListDataSummary)
        pub fn build(self) -> crate::model::AppsListDataSummary {
            crate::model::AppsListDataSummary {
                list_arn: self.list_arn,
                list_id: self.list_id,
                list_name: self.list_name,
                apps_list: self.apps_list,
            }
        }
    }
}
impl AppsListDataSummary {
    /// Creates a new builder-style object to manufacture [`AppsListDataSummary`](crate::model::AppsListDataSummary)
    pub fn builder() -> crate::model::apps_list_data_summary::Builder {
        crate::model::apps_list_data_summary::Builder::default()
    }
}

/// <p>Violations for a resource based on the specified AWS Firewall Manager policy and AWS account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ViolationDetail {
    /// <p>The ID of the AWS Firewall Manager policy that the violation details were requested for.</p>
    pub policy_id: std::option::Option<std::string::String>,
    /// <p>The AWS account that the violation details were requested for.</p>
    pub member_account: std::option::Option<std::string::String>,
    /// <p>The resource ID that the violation details were requested for.</p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The resource type that the violation details were requested for.</p>
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>List of violations for the requested resource.</p>
    pub resource_violations: std::option::Option<std::vec::Vec<crate::model::ResourceViolation>>,
    /// <p>The <code>ResourceTag</code> objects associated with the resource.</p>
    pub resource_tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Brief description for the requested resource.</p>
    pub resource_description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ViolationDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ViolationDetail");
        formatter.field("policy_id", &self.policy_id);
        formatter.field("member_account", &self.member_account);
        formatter.field("resource_id", &self.resource_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("resource_violations", &self.resource_violations);
        formatter.field("resource_tags", &self.resource_tags);
        formatter.field("resource_description", &self.resource_description);
        formatter.finish()
    }
}
/// See [`ViolationDetail`](crate::model::ViolationDetail)
pub mod violation_detail {
    /// A builder for [`ViolationDetail`](crate::model::ViolationDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_id: std::option::Option<std::string::String>,
        pub(crate) member_account: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) resource_violations:
            std::option::Option<std::vec::Vec<crate::model::ResourceViolation>>,
        pub(crate) resource_tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) resource_description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the AWS Firewall Manager policy that the violation details were requested for.</p>
        pub fn policy_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_id = Some(input.into());
            self
        }
        pub fn set_policy_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_id = input;
            self
        }
        /// <p>The AWS account that the violation details were requested for.</p>
        pub fn member_account(mut self, input: impl Into<std::string::String>) -> Self {
            self.member_account = Some(input.into());
            self
        }
        pub fn set_member_account(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.member_account = input;
            self
        }
        /// <p>The resource ID that the violation details were requested for.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The resource type that the violation details were requested for.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        pub fn resource_violations(
            mut self,
            input: impl Into<crate::model::ResourceViolation>,
        ) -> Self {
            let mut v = self.resource_violations.unwrap_or_default();
            v.push(input.into());
            self.resource_violations = Some(v);
            self
        }
        pub fn set_resource_violations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourceViolation>>,
        ) -> Self {
            self.resource_violations = input;
            self
        }
        pub fn resource_tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.resource_tags.unwrap_or_default();
            v.push(input.into());
            self.resource_tags = Some(v);
            self
        }
        pub fn set_resource_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.resource_tags = input;
            self
        }
        /// <p>Brief description for the requested resource.</p>
        pub fn resource_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_description = Some(input.into());
            self
        }
        pub fn set_resource_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_description = input;
            self
        }
        /// Consumes the builder and constructs a [`ViolationDetail`](crate::model::ViolationDetail)
        pub fn build(self) -> crate::model::ViolationDetail {
            crate::model::ViolationDetail {
                policy_id: self.policy_id,
                member_account: self.member_account,
                resource_id: self.resource_id,
                resource_type: self.resource_type,
                resource_violations: self.resource_violations,
                resource_tags: self.resource_tags,
                resource_description: self.resource_description,
            }
        }
    }
}
impl ViolationDetail {
    /// Creates a new builder-style object to manufacture [`ViolationDetail`](crate::model::ViolationDetail)
    pub fn builder() -> crate::model::violation_detail::Builder {
        crate::model::violation_detail::Builder::default()
    }
}

/// <p>Violation detail based on resource type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceViolation {
    /// <p>Violation details for security groups.</p>
    pub aws_vpc_security_group_violation:
        std::option::Option<crate::model::AwsVpcSecurityGroupViolation>,
    /// <p>Violation details for network interface.</p>
    pub aws_ec2_network_interface_violation:
        std::option::Option<crate::model::AwsEc2NetworkInterfaceViolation>,
    /// <p>Violation details for an EC2 instance.</p>
    pub aws_ec2_instance_violation: std::option::Option<crate::model::AwsEc2InstanceViolation>,
    /// <p>Violation detail for an Network Firewall policy that indicates that a subnet has no Firewall Manager
    /// managed firewall in its VPC. </p>
    pub network_firewall_missing_firewall_violation:
        std::option::Option<crate::model::NetworkFirewallMissingFirewallViolation>,
    /// <p>Violation detail for an Network Firewall policy that indicates that an Availability Zone is
    /// missing the expected Firewall Manager managed subnet.</p>
    pub network_firewall_missing_subnet_violation:
        std::option::Option<crate::model::NetworkFirewallMissingSubnetViolation>,
    /// <p>Violation detail for an Network Firewall policy that indicates that a subnet
    /// is not associated with the expected Firewall Manager managed route table. </p>
    pub network_firewall_missing_expected_rt_violation:
        std::option::Option<crate::model::NetworkFirewallMissingExpectedRtViolation>,
    /// <p>Violation detail for an Network Firewall policy that indicates that a firewall policy
    /// in an individual account has been modified in a way that makes it noncompliant.  
    /// For example, the individual account owner might have deleted a rule group,
    /// changed the priority of a stateless rule group, or changed a policy default action.</p>
    pub network_firewall_policy_modified_violation:
        std::option::Option<crate::model::NetworkFirewallPolicyModifiedViolation>,
    /// <p>Violation detail for a DNS Firewall policy that indicates that a rule group that Firewall Manager
    /// tried to associate with a VPC has the same priority as a rule group that's already associated. </p>
    pub dns_rule_group_priority_conflict_violation:
        std::option::Option<crate::model::DnsRuleGroupPriorityConflictViolation>,
    /// <p>Violation detail for a DNS Firewall policy that indicates that a rule group that Firewall Manager
    /// tried to associate with a VPC is already associated with the VPC and can't be associated again. </p>
    pub dns_duplicate_rule_group_violation:
        std::option::Option<crate::model::DnsDuplicateRuleGroupViolation>,
    /// <p>Violation details for a DNS Firewall policy that indicates that the VPC reached the limit for associated DNS Firewall rule groups. Firewall Manager tried to associate another rule group with the VPC and failed. </p>
    pub dns_rule_group_limit_exceeded_violation:
        std::option::Option<crate::model::DnsRuleGroupLimitExceededViolation>,
}
impl std::fmt::Debug for ResourceViolation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceViolation");
        formatter.field(
            "aws_vpc_security_group_violation",
            &self.aws_vpc_security_group_violation,
        );
        formatter.field(
            "aws_ec2_network_interface_violation",
            &self.aws_ec2_network_interface_violation,
        );
        formatter.field(
            "aws_ec2_instance_violation",
            &self.aws_ec2_instance_violation,
        );
        formatter.field(
            "network_firewall_missing_firewall_violation",
            &self.network_firewall_missing_firewall_violation,
        );
        formatter.field(
            "network_firewall_missing_subnet_violation",
            &self.network_firewall_missing_subnet_violation,
        );
        formatter.field(
            "network_firewall_missing_expected_rt_violation",
            &self.network_firewall_missing_expected_rt_violation,
        );
        formatter.field(
            "network_firewall_policy_modified_violation",
            &self.network_firewall_policy_modified_violation,
        );
        formatter.field(
            "dns_rule_group_priority_conflict_violation",
            &self.dns_rule_group_priority_conflict_violation,
        );
        formatter.field(
            "dns_duplicate_rule_group_violation",
            &self.dns_duplicate_rule_group_violation,
        );
        formatter.field(
            "dns_rule_group_limit_exceeded_violation",
            &self.dns_rule_group_limit_exceeded_violation,
        );
        formatter.finish()
    }
}
/// See [`ResourceViolation`](crate::model::ResourceViolation)
pub mod resource_violation {
    /// A builder for [`ResourceViolation`](crate::model::ResourceViolation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) aws_vpc_security_group_violation:
            std::option::Option<crate::model::AwsVpcSecurityGroupViolation>,
        pub(crate) aws_ec2_network_interface_violation:
            std::option::Option<crate::model::AwsEc2NetworkInterfaceViolation>,
        pub(crate) aws_ec2_instance_violation:
            std::option::Option<crate::model::AwsEc2InstanceViolation>,
        pub(crate) network_firewall_missing_firewall_violation:
            std::option::Option<crate::model::NetworkFirewallMissingFirewallViolation>,
        pub(crate) network_firewall_missing_subnet_violation:
            std::option::Option<crate::model::NetworkFirewallMissingSubnetViolation>,
        pub(crate) network_firewall_missing_expected_rt_violation:
            std::option::Option<crate::model::NetworkFirewallMissingExpectedRtViolation>,
        pub(crate) network_firewall_policy_modified_violation:
            std::option::Option<crate::model::NetworkFirewallPolicyModifiedViolation>,
        pub(crate) dns_rule_group_priority_conflict_violation:
            std::option::Option<crate::model::DnsRuleGroupPriorityConflictViolation>,
        pub(crate) dns_duplicate_rule_group_violation:
            std::option::Option<crate::model::DnsDuplicateRuleGroupViolation>,
        pub(crate) dns_rule_group_limit_exceeded_violation:
            std::option::Option<crate::model::DnsRuleGroupLimitExceededViolation>,
    }
    impl Builder {
        /// <p>Violation details for security groups.</p>
        pub fn aws_vpc_security_group_violation(
            mut self,
            input: crate::model::AwsVpcSecurityGroupViolation,
        ) -> Self {
            self.aws_vpc_security_group_violation = Some(input);
            self
        }
        pub fn set_aws_vpc_security_group_violation(
            mut self,
            input: std::option::Option<crate::model::AwsVpcSecurityGroupViolation>,
        ) -> Self {
            self.aws_vpc_security_group_violation = input;
            self
        }
        /// <p>Violation details for network interface.</p>
        pub fn aws_ec2_network_interface_violation(
            mut self,
            input: crate::model::AwsEc2NetworkInterfaceViolation,
        ) -> Self {
            self.aws_ec2_network_interface_violation = Some(input);
            self
        }
        pub fn set_aws_ec2_network_interface_violation(
            mut self,
            input: std::option::Option<crate::model::AwsEc2NetworkInterfaceViolation>,
        ) -> Self {
            self.aws_ec2_network_interface_violation = input;
            self
        }
        /// <p>Violation details for an EC2 instance.</p>
        pub fn aws_ec2_instance_violation(
            mut self,
            input: crate::model::AwsEc2InstanceViolation,
        ) -> Self {
            self.aws_ec2_instance_violation = Some(input);
            self
        }
        pub fn set_aws_ec2_instance_violation(
            mut self,
            input: std::option::Option<crate::model::AwsEc2InstanceViolation>,
        ) -> Self {
            self.aws_ec2_instance_violation = input;
            self
        }
        /// <p>Violation detail for an Network Firewall policy that indicates that a subnet has no Firewall Manager
        /// managed firewall in its VPC. </p>
        pub fn network_firewall_missing_firewall_violation(
            mut self,
            input: crate::model::NetworkFirewallMissingFirewallViolation,
        ) -> Self {
            self.network_firewall_missing_firewall_violation = Some(input);
            self
        }
        pub fn set_network_firewall_missing_firewall_violation(
            mut self,
            input: std::option::Option<crate::model::NetworkFirewallMissingFirewallViolation>,
        ) -> Self {
            self.network_firewall_missing_firewall_violation = input;
            self
        }
        /// <p>Violation detail for an Network Firewall policy that indicates that an Availability Zone is
        /// missing the expected Firewall Manager managed subnet.</p>
        pub fn network_firewall_missing_subnet_violation(
            mut self,
            input: crate::model::NetworkFirewallMissingSubnetViolation,
        ) -> Self {
            self.network_firewall_missing_subnet_violation = Some(input);
            self
        }
        pub fn set_network_firewall_missing_subnet_violation(
            mut self,
            input: std::option::Option<crate::model::NetworkFirewallMissingSubnetViolation>,
        ) -> Self {
            self.network_firewall_missing_subnet_violation = input;
            self
        }
        /// <p>Violation detail for an Network Firewall policy that indicates that a subnet
        /// is not associated with the expected Firewall Manager managed route table. </p>
        pub fn network_firewall_missing_expected_rt_violation(
            mut self,
            input: crate::model::NetworkFirewallMissingExpectedRtViolation,
        ) -> Self {
            self.network_firewall_missing_expected_rt_violation = Some(input);
            self
        }
        pub fn set_network_firewall_missing_expected_rt_violation(
            mut self,
            input: std::option::Option<crate::model::NetworkFirewallMissingExpectedRtViolation>,
        ) -> Self {
            self.network_firewall_missing_expected_rt_violation = input;
            self
        }
        /// <p>Violation detail for an Network Firewall policy that indicates that a firewall policy
        /// in an individual account has been modified in a way that makes it noncompliant.  
        /// For example, the individual account owner might have deleted a rule group,
        /// changed the priority of a stateless rule group, or changed a policy default action.</p>
        pub fn network_firewall_policy_modified_violation(
            mut self,
            input: crate::model::NetworkFirewallPolicyModifiedViolation,
        ) -> Self {
            self.network_firewall_policy_modified_violation = Some(input);
            self
        }
        pub fn set_network_firewall_policy_modified_violation(
            mut self,
            input: std::option::Option<crate::model::NetworkFirewallPolicyModifiedViolation>,
        ) -> Self {
            self.network_firewall_policy_modified_violation = input;
            self
        }
        /// <p>Violation detail for a DNS Firewall policy that indicates that a rule group that Firewall Manager
        /// tried to associate with a VPC has the same priority as a rule group that's already associated. </p>
        pub fn dns_rule_group_priority_conflict_violation(
            mut self,
            input: crate::model::DnsRuleGroupPriorityConflictViolation,
        ) -> Self {
            self.dns_rule_group_priority_conflict_violation = Some(input);
            self
        }
        pub fn set_dns_rule_group_priority_conflict_violation(
            mut self,
            input: std::option::Option<crate::model::DnsRuleGroupPriorityConflictViolation>,
        ) -> Self {
            self.dns_rule_group_priority_conflict_violation = input;
            self
        }
        /// <p>Violation detail for a DNS Firewall policy that indicates that a rule group that Firewall Manager
        /// tried to associate with a VPC is already associated with the VPC and can't be associated again. </p>
        pub fn dns_duplicate_rule_group_violation(
            mut self,
            input: crate::model::DnsDuplicateRuleGroupViolation,
        ) -> Self {
            self.dns_duplicate_rule_group_violation = Some(input);
            self
        }
        pub fn set_dns_duplicate_rule_group_violation(
            mut self,
            input: std::option::Option<crate::model::DnsDuplicateRuleGroupViolation>,
        ) -> Self {
            self.dns_duplicate_rule_group_violation = input;
            self
        }
        /// <p>Violation details for a DNS Firewall policy that indicates that the VPC reached the limit for associated DNS Firewall rule groups. Firewall Manager tried to associate another rule group with the VPC and failed. </p>
        pub fn dns_rule_group_limit_exceeded_violation(
            mut self,
            input: crate::model::DnsRuleGroupLimitExceededViolation,
        ) -> Self {
            self.dns_rule_group_limit_exceeded_violation = Some(input);
            self
        }
        pub fn set_dns_rule_group_limit_exceeded_violation(
            mut self,
            input: std::option::Option<crate::model::DnsRuleGroupLimitExceededViolation>,
        ) -> Self {
            self.dns_rule_group_limit_exceeded_violation = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceViolation`](crate::model::ResourceViolation)
        pub fn build(self) -> crate::model::ResourceViolation {
            crate::model::ResourceViolation {
                aws_vpc_security_group_violation: self.aws_vpc_security_group_violation,
                aws_ec2_network_interface_violation: self.aws_ec2_network_interface_violation,
                aws_ec2_instance_violation: self.aws_ec2_instance_violation,
                network_firewall_missing_firewall_violation: self
                    .network_firewall_missing_firewall_violation,
                network_firewall_missing_subnet_violation: self
                    .network_firewall_missing_subnet_violation,
                network_firewall_missing_expected_rt_violation: self
                    .network_firewall_missing_expected_rt_violation,
                network_firewall_policy_modified_violation: self
                    .network_firewall_policy_modified_violation,
                dns_rule_group_priority_conflict_violation: self
                    .dns_rule_group_priority_conflict_violation,
                dns_duplicate_rule_group_violation: self.dns_duplicate_rule_group_violation,
                dns_rule_group_limit_exceeded_violation: self
                    .dns_rule_group_limit_exceeded_violation,
            }
        }
    }
}
impl ResourceViolation {
    /// Creates a new builder-style object to manufacture [`ResourceViolation`](crate::model::ResourceViolation)
    pub fn builder() -> crate::model::resource_violation::Builder {
        crate::model::resource_violation::Builder::default()
    }
}

/// <p>The VPC that Firewall Manager was applying a DNS Fireall policy to reached the limit for associated DNS Firewall rule groups. Firewall Manager tried to associate another rule group with the VPC and failed due to the limit. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DnsRuleGroupLimitExceededViolation {
    /// <p>The ID of the VPC. </p>
    pub violation_target: std::option::Option<std::string::String>,
    /// <p>A description of the violation that specifies the rule group and VPC.</p>
    pub violation_target_description: std::option::Option<std::string::String>,
    /// <p>The number of rule groups currently associated with the VPC.  </p>
    pub number_of_rule_groups_already_associated: i32,
}
impl std::fmt::Debug for DnsRuleGroupLimitExceededViolation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DnsRuleGroupLimitExceededViolation");
        formatter.field("violation_target", &self.violation_target);
        formatter.field(
            "violation_target_description",
            &self.violation_target_description,
        );
        formatter.field(
            "number_of_rule_groups_already_associated",
            &self.number_of_rule_groups_already_associated,
        );
        formatter.finish()
    }
}
/// See [`DnsRuleGroupLimitExceededViolation`](crate::model::DnsRuleGroupLimitExceededViolation)
pub mod dns_rule_group_limit_exceeded_violation {
    /// A builder for [`DnsRuleGroupLimitExceededViolation`](crate::model::DnsRuleGroupLimitExceededViolation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) violation_target: std::option::Option<std::string::String>,
        pub(crate) violation_target_description: std::option::Option<std::string::String>,
        pub(crate) number_of_rule_groups_already_associated: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of the VPC. </p>
        pub fn violation_target(mut self, input: impl Into<std::string::String>) -> Self {
            self.violation_target = Some(input.into());
            self
        }
        pub fn set_violation_target(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.violation_target = input;
            self
        }
        /// <p>A description of the violation that specifies the rule group and VPC.</p>
        pub fn violation_target_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.violation_target_description = Some(input.into());
            self
        }
        pub fn set_violation_target_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.violation_target_description = input;
            self
        }
        /// <p>The number of rule groups currently associated with the VPC.  </p>
        pub fn number_of_rule_groups_already_associated(mut self, input: i32) -> Self {
            self.number_of_rule_groups_already_associated = Some(input);
            self
        }
        pub fn set_number_of_rule_groups_already_associated(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.number_of_rule_groups_already_associated = input;
            self
        }
        /// Consumes the builder and constructs a [`DnsRuleGroupLimitExceededViolation`](crate::model::DnsRuleGroupLimitExceededViolation)
        pub fn build(self) -> crate::model::DnsRuleGroupLimitExceededViolation {
            crate::model::DnsRuleGroupLimitExceededViolation {
                violation_target: self.violation_target,
                violation_target_description: self.violation_target_description,
                number_of_rule_groups_already_associated: self
                    .number_of_rule_groups_already_associated
                    .unwrap_or_default(),
            }
        }
    }
}
impl DnsRuleGroupLimitExceededViolation {
    /// Creates a new builder-style object to manufacture [`DnsRuleGroupLimitExceededViolation`](crate::model::DnsRuleGroupLimitExceededViolation)
    pub fn builder() -> crate::model::dns_rule_group_limit_exceeded_violation::Builder {
        crate::model::dns_rule_group_limit_exceeded_violation::Builder::default()
    }
}

/// <p>A DNS Firewall rule group that Firewall Manager
/// tried to associate with a VPC is already associated with the VPC and can't be associated again. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DnsDuplicateRuleGroupViolation {
    /// <p>The ID of the VPC. </p>
    pub violation_target: std::option::Option<std::string::String>,
    /// <p>A description of the violation that specifies the rule group and VPC.</p>
    pub violation_target_description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DnsDuplicateRuleGroupViolation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DnsDuplicateRuleGroupViolation");
        formatter.field("violation_target", &self.violation_target);
        formatter.field(
            "violation_target_description",
            &self.violation_target_description,
        );
        formatter.finish()
    }
}
/// See [`DnsDuplicateRuleGroupViolation`](crate::model::DnsDuplicateRuleGroupViolation)
pub mod dns_duplicate_rule_group_violation {
    /// A builder for [`DnsDuplicateRuleGroupViolation`](crate::model::DnsDuplicateRuleGroupViolation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) violation_target: std::option::Option<std::string::String>,
        pub(crate) violation_target_description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the VPC. </p>
        pub fn violation_target(mut self, input: impl Into<std::string::String>) -> Self {
            self.violation_target = Some(input.into());
            self
        }
        pub fn set_violation_target(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.violation_target = input;
            self
        }
        /// <p>A description of the violation that specifies the rule group and VPC.</p>
        pub fn violation_target_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.violation_target_description = Some(input.into());
            self
        }
        pub fn set_violation_target_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.violation_target_description = input;
            self
        }
        /// Consumes the builder and constructs a [`DnsDuplicateRuleGroupViolation`](crate::model::DnsDuplicateRuleGroupViolation)
        pub fn build(self) -> crate::model::DnsDuplicateRuleGroupViolation {
            crate::model::DnsDuplicateRuleGroupViolation {
                violation_target: self.violation_target,
                violation_target_description: self.violation_target_description,
            }
        }
    }
}
impl DnsDuplicateRuleGroupViolation {
    /// Creates a new builder-style object to manufacture [`DnsDuplicateRuleGroupViolation`](crate::model::DnsDuplicateRuleGroupViolation)
    pub fn builder() -> crate::model::dns_duplicate_rule_group_violation::Builder {
        crate::model::dns_duplicate_rule_group_violation::Builder::default()
    }
}

/// <p>A rule group that Firewall Manager
/// tried to associate with a VPC has the same priority as a rule group that's already associated. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DnsRuleGroupPriorityConflictViolation {
    /// <p>The ID of the VPC. </p>
    pub violation_target: std::option::Option<std::string::String>,
    /// <p>A description of the violation that specifies the VPC and the rule group that's already associated with it.</p>
    pub violation_target_description: std::option::Option<std::string::String>,
    /// <p>The priority setting of the two conflicting rule groups.</p>
    pub conflicting_priority: i32,
    /// <p>The ID of the Firewall Manager DNS Firewall policy that was already applied to the VPC.
    /// This policy contains the rule group that's already associated with the VPC. </p>
    pub conflicting_policy_id: std::option::Option<std::string::String>,
    /// <p>The priorities of rule groups that are already associated with the VPC. To retry your operation,
    /// choose priority settings that aren't in this list for the rule groups in your new DNS Firewall policy. </p>
    pub unavailable_priorities: std::option::Option<std::vec::Vec<i32>>,
}
impl std::fmt::Debug for DnsRuleGroupPriorityConflictViolation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DnsRuleGroupPriorityConflictViolation");
        formatter.field("violation_target", &self.violation_target);
        formatter.field(
            "violation_target_description",
            &self.violation_target_description,
        );
        formatter.field("conflicting_priority", &self.conflicting_priority);
        formatter.field("conflicting_policy_id", &self.conflicting_policy_id);
        formatter.field("unavailable_priorities", &self.unavailable_priorities);
        formatter.finish()
    }
}
/// See [`DnsRuleGroupPriorityConflictViolation`](crate::model::DnsRuleGroupPriorityConflictViolation)
pub mod dns_rule_group_priority_conflict_violation {
    /// A builder for [`DnsRuleGroupPriorityConflictViolation`](crate::model::DnsRuleGroupPriorityConflictViolation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) violation_target: std::option::Option<std::string::String>,
        pub(crate) violation_target_description: std::option::Option<std::string::String>,
        pub(crate) conflicting_priority: std::option::Option<i32>,
        pub(crate) conflicting_policy_id: std::option::Option<std::string::String>,
        pub(crate) unavailable_priorities: std::option::Option<std::vec::Vec<i32>>,
    }
    impl Builder {
        /// <p>The ID of the VPC. </p>
        pub fn violation_target(mut self, input: impl Into<std::string::String>) -> Self {
            self.violation_target = Some(input.into());
            self
        }
        pub fn set_violation_target(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.violation_target = input;
            self
        }
        /// <p>A description of the violation that specifies the VPC and the rule group that's already associated with it.</p>
        pub fn violation_target_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.violation_target_description = Some(input.into());
            self
        }
        pub fn set_violation_target_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.violation_target_description = input;
            self
        }
        /// <p>The priority setting of the two conflicting rule groups.</p>
        pub fn conflicting_priority(mut self, input: i32) -> Self {
            self.conflicting_priority = Some(input);
            self
        }
        pub fn set_conflicting_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.conflicting_priority = input;
            self
        }
        /// <p>The ID of the Firewall Manager DNS Firewall policy that was already applied to the VPC.
        /// This policy contains the rule group that's already associated with the VPC. </p>
        pub fn conflicting_policy_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.conflicting_policy_id = Some(input.into());
            self
        }
        pub fn set_conflicting_policy_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.conflicting_policy_id = input;
            self
        }
        pub fn unavailable_priorities(mut self, input: impl Into<i32>) -> Self {
            let mut v = self.unavailable_priorities.unwrap_or_default();
            v.push(input.into());
            self.unavailable_priorities = Some(v);
            self
        }
        pub fn set_unavailable_priorities(
            mut self,
            input: std::option::Option<std::vec::Vec<i32>>,
        ) -> Self {
            self.unavailable_priorities = input;
            self
        }
        /// Consumes the builder and constructs a [`DnsRuleGroupPriorityConflictViolation`](crate::model::DnsRuleGroupPriorityConflictViolation)
        pub fn build(self) -> crate::model::DnsRuleGroupPriorityConflictViolation {
            crate::model::DnsRuleGroupPriorityConflictViolation {
                violation_target: self.violation_target,
                violation_target_description: self.violation_target_description,
                conflicting_priority: self.conflicting_priority.unwrap_or_default(),
                conflicting_policy_id: self.conflicting_policy_id,
                unavailable_priorities: self.unavailable_priorities,
            }
        }
    }
}
impl DnsRuleGroupPriorityConflictViolation {
    /// Creates a new builder-style object to manufacture [`DnsRuleGroupPriorityConflictViolation`](crate::model::DnsRuleGroupPriorityConflictViolation)
    pub fn builder() -> crate::model::dns_rule_group_priority_conflict_violation::Builder {
        crate::model::dns_rule_group_priority_conflict_violation::Builder::default()
    }
}

/// <p>Violation details for AWS Network Firewall for a firewall policy that has a different
/// <a>NetworkFirewallPolicyDescription</a> than is required by the Firewall Manager policy. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkFirewallPolicyModifiedViolation {
    /// <p>The ID of the AWS Network Firewall or VPC resource that's in violation.</p>
    pub violation_target: std::option::Option<std::string::String>,
    /// <p>The policy that's currently in use in the individual account. </p>
    pub current_policy_description:
        std::option::Option<crate::model::NetworkFirewallPolicyDescription>,
    /// <p>The policy that should be in use in the individual account in order to be compliant. </p>
    pub expected_policy_description:
        std::option::Option<crate::model::NetworkFirewallPolicyDescription>,
}
impl std::fmt::Debug for NetworkFirewallPolicyModifiedViolation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkFirewallPolicyModifiedViolation");
        formatter.field("violation_target", &self.violation_target);
        formatter.field(
            "current_policy_description",
            &self.current_policy_description,
        );
        formatter.field(
            "expected_policy_description",
            &self.expected_policy_description,
        );
        formatter.finish()
    }
}
/// See [`NetworkFirewallPolicyModifiedViolation`](crate::model::NetworkFirewallPolicyModifiedViolation)
pub mod network_firewall_policy_modified_violation {
    /// A builder for [`NetworkFirewallPolicyModifiedViolation`](crate::model::NetworkFirewallPolicyModifiedViolation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) violation_target: std::option::Option<std::string::String>,
        pub(crate) current_policy_description:
            std::option::Option<crate::model::NetworkFirewallPolicyDescription>,
        pub(crate) expected_policy_description:
            std::option::Option<crate::model::NetworkFirewallPolicyDescription>,
    }
    impl Builder {
        /// <p>The ID of the AWS Network Firewall or VPC resource that's in violation.</p>
        pub fn violation_target(mut self, input: impl Into<std::string::String>) -> Self {
            self.violation_target = Some(input.into());
            self
        }
        pub fn set_violation_target(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.violation_target = input;
            self
        }
        /// <p>The policy that's currently in use in the individual account. </p>
        pub fn current_policy_description(
            mut self,
            input: crate::model::NetworkFirewallPolicyDescription,
        ) -> Self {
            self.current_policy_description = Some(input);
            self
        }
        pub fn set_current_policy_description(
            mut self,
            input: std::option::Option<crate::model::NetworkFirewallPolicyDescription>,
        ) -> Self {
            self.current_policy_description = input;
            self
        }
        /// <p>The policy that should be in use in the individual account in order to be compliant. </p>
        pub fn expected_policy_description(
            mut self,
            input: crate::model::NetworkFirewallPolicyDescription,
        ) -> Self {
            self.expected_policy_description = Some(input);
            self
        }
        pub fn set_expected_policy_description(
            mut self,
            input: std::option::Option<crate::model::NetworkFirewallPolicyDescription>,
        ) -> Self {
            self.expected_policy_description = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkFirewallPolicyModifiedViolation`](crate::model::NetworkFirewallPolicyModifiedViolation)
        pub fn build(self) -> crate::model::NetworkFirewallPolicyModifiedViolation {
            crate::model::NetworkFirewallPolicyModifiedViolation {
                violation_target: self.violation_target,
                current_policy_description: self.current_policy_description,
                expected_policy_description: self.expected_policy_description,
            }
        }
    }
}
impl NetworkFirewallPolicyModifiedViolation {
    /// Creates a new builder-style object to manufacture [`NetworkFirewallPolicyModifiedViolation`](crate::model::NetworkFirewallPolicyModifiedViolation)
    pub fn builder() -> crate::model::network_firewall_policy_modified_violation::Builder {
        crate::model::network_firewall_policy_modified_violation::Builder::default()
    }
}

/// <p>The definition of the AWS Network Firewall firewall policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkFirewallPolicyDescription {
    /// <p>The stateless rule groups that are used in the Network Firewall firewall policy. </p>
    pub stateless_rule_groups: std::option::Option<std::vec::Vec<crate::model::StatelessRuleGroup>>,
    /// <p>The actions to take on packets that don't match any of the stateless rule groups. </p>
    pub stateless_default_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The actions to take on packet fragments that don't match any of the stateless rule groups. </p>
    pub stateless_fragment_default_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Names of custom actions that are available for use in the stateless default actions settings.</p>
    pub stateless_custom_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The stateful rule groups that are used in the Network Firewall firewall policy. </p>
    pub stateful_rule_groups: std::option::Option<std::vec::Vec<crate::model::StatefulRuleGroup>>,
}
impl std::fmt::Debug for NetworkFirewallPolicyDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkFirewallPolicyDescription");
        formatter.field("stateless_rule_groups", &self.stateless_rule_groups);
        formatter.field("stateless_default_actions", &self.stateless_default_actions);
        formatter.field(
            "stateless_fragment_default_actions",
            &self.stateless_fragment_default_actions,
        );
        formatter.field("stateless_custom_actions", &self.stateless_custom_actions);
        formatter.field("stateful_rule_groups", &self.stateful_rule_groups);
        formatter.finish()
    }
}
/// See [`NetworkFirewallPolicyDescription`](crate::model::NetworkFirewallPolicyDescription)
pub mod network_firewall_policy_description {
    /// A builder for [`NetworkFirewallPolicyDescription`](crate::model::NetworkFirewallPolicyDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stateless_rule_groups:
            std::option::Option<std::vec::Vec<crate::model::StatelessRuleGroup>>,
        pub(crate) stateless_default_actions:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) stateless_fragment_default_actions:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) stateless_custom_actions:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) stateful_rule_groups:
            std::option::Option<std::vec::Vec<crate::model::StatefulRuleGroup>>,
    }
    impl Builder {
        pub fn stateless_rule_groups(
            mut self,
            input: impl Into<crate::model::StatelessRuleGroup>,
        ) -> Self {
            let mut v = self.stateless_rule_groups.unwrap_or_default();
            v.push(input.into());
            self.stateless_rule_groups = Some(v);
            self
        }
        pub fn set_stateless_rule_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StatelessRuleGroup>>,
        ) -> Self {
            self.stateless_rule_groups = input;
            self
        }
        pub fn stateless_default_actions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.stateless_default_actions.unwrap_or_default();
            v.push(input.into());
            self.stateless_default_actions = Some(v);
            self
        }
        pub fn set_stateless_default_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.stateless_default_actions = input;
            self
        }
        pub fn stateless_fragment_default_actions(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.stateless_fragment_default_actions.unwrap_or_default();
            v.push(input.into());
            self.stateless_fragment_default_actions = Some(v);
            self
        }
        pub fn set_stateless_fragment_default_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.stateless_fragment_default_actions = input;
            self
        }
        pub fn stateless_custom_actions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.stateless_custom_actions.unwrap_or_default();
            v.push(input.into());
            self.stateless_custom_actions = Some(v);
            self
        }
        pub fn set_stateless_custom_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.stateless_custom_actions = input;
            self
        }
        pub fn stateful_rule_groups(
            mut self,
            input: impl Into<crate::model::StatefulRuleGroup>,
        ) -> Self {
            let mut v = self.stateful_rule_groups.unwrap_or_default();
            v.push(input.into());
            self.stateful_rule_groups = Some(v);
            self
        }
        pub fn set_stateful_rule_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StatefulRuleGroup>>,
        ) -> Self {
            self.stateful_rule_groups = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkFirewallPolicyDescription`](crate::model::NetworkFirewallPolicyDescription)
        pub fn build(self) -> crate::model::NetworkFirewallPolicyDescription {
            crate::model::NetworkFirewallPolicyDescription {
                stateless_rule_groups: self.stateless_rule_groups,
                stateless_default_actions: self.stateless_default_actions,
                stateless_fragment_default_actions: self.stateless_fragment_default_actions,
                stateless_custom_actions: self.stateless_custom_actions,
                stateful_rule_groups: self.stateful_rule_groups,
            }
        }
    }
}
impl NetworkFirewallPolicyDescription {
    /// Creates a new builder-style object to manufacture [`NetworkFirewallPolicyDescription`](crate::model::NetworkFirewallPolicyDescription)
    pub fn builder() -> crate::model::network_firewall_policy_description::Builder {
        crate::model::network_firewall_policy_description::Builder::default()
    }
}

/// <p>AWS Network Firewall stateful rule group, used in a <a>NetworkFirewallPolicyDescription</a>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StatefulRuleGroup {
    /// <p>The name of the rule group.</p>
    pub rule_group_name: std::option::Option<std::string::String>,
    /// <p>The resource ID of the rule group.</p>
    pub resource_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StatefulRuleGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StatefulRuleGroup");
        formatter.field("rule_group_name", &self.rule_group_name);
        formatter.field("resource_id", &self.resource_id);
        formatter.finish()
    }
}
/// See [`StatefulRuleGroup`](crate::model::StatefulRuleGroup)
pub mod stateful_rule_group {
    /// A builder for [`StatefulRuleGroup`](crate::model::StatefulRuleGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_group_name: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the rule group.</p>
        pub fn rule_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_group_name = Some(input.into());
            self
        }
        pub fn set_rule_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_group_name = input;
            self
        }
        /// <p>The resource ID of the rule group.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StatefulRuleGroup`](crate::model::StatefulRuleGroup)
        pub fn build(self) -> crate::model::StatefulRuleGroup {
            crate::model::StatefulRuleGroup {
                rule_group_name: self.rule_group_name,
                resource_id: self.resource_id,
            }
        }
    }
}
impl StatefulRuleGroup {
    /// Creates a new builder-style object to manufacture [`StatefulRuleGroup`](crate::model::StatefulRuleGroup)
    pub fn builder() -> crate::model::stateful_rule_group::Builder {
        crate::model::stateful_rule_group::Builder::default()
    }
}

/// <p>AWS Network Firewall stateless rule group, used in a <a>NetworkFirewallPolicyDescription</a>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StatelessRuleGroup {
    /// <p>The name of the rule group.</p>
    pub rule_group_name: std::option::Option<std::string::String>,
    /// <p>The resource ID of the rule group.</p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The priority of the rule group. AWS Network Firewall evaluates the stateless rule groups in a firewall policy starting from the lowest priority setting. </p>
    pub priority: i32,
}
impl std::fmt::Debug for StatelessRuleGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StatelessRuleGroup");
        formatter.field("rule_group_name", &self.rule_group_name);
        formatter.field("resource_id", &self.resource_id);
        formatter.field("priority", &self.priority);
        formatter.finish()
    }
}
/// See [`StatelessRuleGroup`](crate::model::StatelessRuleGroup)
pub mod stateless_rule_group {
    /// A builder for [`StatelessRuleGroup`](crate::model::StatelessRuleGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_group_name: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) priority: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the rule group.</p>
        pub fn rule_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_group_name = Some(input.into());
            self
        }
        pub fn set_rule_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_group_name = input;
            self
        }
        /// <p>The resource ID of the rule group.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The priority of the rule group. AWS Network Firewall evaluates the stateless rule groups in a firewall policy starting from the lowest priority setting. </p>
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        /// Consumes the builder and constructs a [`StatelessRuleGroup`](crate::model::StatelessRuleGroup)
        pub fn build(self) -> crate::model::StatelessRuleGroup {
            crate::model::StatelessRuleGroup {
                rule_group_name: self.rule_group_name,
                resource_id: self.resource_id,
                priority: self.priority.unwrap_or_default(),
            }
        }
    }
}
impl StatelessRuleGroup {
    /// Creates a new builder-style object to manufacture [`StatelessRuleGroup`](crate::model::StatelessRuleGroup)
    pub fn builder() -> crate::model::stateless_rule_group::Builder {
        crate::model::stateless_rule_group::Builder::default()
    }
}

/// <p>Violation details for AWS Network Firewall for a subnet that's not associated to the expected
/// Firewall Manager managed route table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkFirewallMissingExpectedRtViolation {
    /// <p>The ID of the AWS Network Firewall or VPC resource that's in violation.</p>
    pub violation_target: std::option::Option<std::string::String>,
    /// <p>The resource ID of the VPC associated with a violating subnet.</p>
    pub vpc: std::option::Option<std::string::String>,
    /// <p>The Availability Zone of a violating subnet. </p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The resource ID of the current route table that's associated with the subnet, if one is available.</p>
    pub current_route_table: std::option::Option<std::string::String>,
    /// <p>The resource ID of the route table that should be associated with the subnet.</p>
    pub expected_route_table: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NetworkFirewallMissingExpectedRtViolation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkFirewallMissingExpectedRtViolation");
        formatter.field("violation_target", &self.violation_target);
        formatter.field("vpc", &self.vpc);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("current_route_table", &self.current_route_table);
        formatter.field("expected_route_table", &self.expected_route_table);
        formatter.finish()
    }
}
/// See [`NetworkFirewallMissingExpectedRtViolation`](crate::model::NetworkFirewallMissingExpectedRtViolation)
pub mod network_firewall_missing_expected_rt_violation {
    /// A builder for [`NetworkFirewallMissingExpectedRtViolation`](crate::model::NetworkFirewallMissingExpectedRtViolation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) violation_target: std::option::Option<std::string::String>,
        pub(crate) vpc: std::option::Option<std::string::String>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) current_route_table: std::option::Option<std::string::String>,
        pub(crate) expected_route_table: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the AWS Network Firewall or VPC resource that's in violation.</p>
        pub fn violation_target(mut self, input: impl Into<std::string::String>) -> Self {
            self.violation_target = Some(input.into());
            self
        }
        pub fn set_violation_target(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.violation_target = input;
            self
        }
        /// <p>The resource ID of the VPC associated with a violating subnet.</p>
        pub fn vpc(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc = Some(input.into());
            self
        }
        pub fn set_vpc(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc = input;
            self
        }
        /// <p>The Availability Zone of a violating subnet. </p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The resource ID of the current route table that's associated with the subnet, if one is available.</p>
        pub fn current_route_table(mut self, input: impl Into<std::string::String>) -> Self {
            self.current_route_table = Some(input.into());
            self
        }
        pub fn set_current_route_table(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.current_route_table = input;
            self
        }
        /// <p>The resource ID of the route table that should be associated with the subnet.</p>
        pub fn expected_route_table(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_route_table = Some(input.into());
            self
        }
        pub fn set_expected_route_table(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_route_table = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkFirewallMissingExpectedRtViolation`](crate::model::NetworkFirewallMissingExpectedRtViolation)
        pub fn build(self) -> crate::model::NetworkFirewallMissingExpectedRtViolation {
            crate::model::NetworkFirewallMissingExpectedRtViolation {
                violation_target: self.violation_target,
                vpc: self.vpc,
                availability_zone: self.availability_zone,
                current_route_table: self.current_route_table,
                expected_route_table: self.expected_route_table,
            }
        }
    }
}
impl NetworkFirewallMissingExpectedRtViolation {
    /// Creates a new builder-style object to manufacture [`NetworkFirewallMissingExpectedRtViolation`](crate::model::NetworkFirewallMissingExpectedRtViolation)
    pub fn builder() -> crate::model::network_firewall_missing_expected_rt_violation::Builder {
        crate::model::network_firewall_missing_expected_rt_violation::Builder::default()
    }
}

/// <p>Violation details for AWS Network Firewall for an Availability Zone that's
/// missing the expected Firewall Manager managed subnet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkFirewallMissingSubnetViolation {
    /// <p>The ID of the AWS Network Firewall or VPC resource that's in violation.</p>
    pub violation_target: std::option::Option<std::string::String>,
    /// <p>The resource ID of the VPC associated with a violating subnet.</p>
    pub vpc: std::option::Option<std::string::String>,
    /// <p>The Availability Zone of a violating subnet. </p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The reason the resource has this violation, if one is available. </p>
    pub target_violation_reason: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NetworkFirewallMissingSubnetViolation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkFirewallMissingSubnetViolation");
        formatter.field("violation_target", &self.violation_target);
        formatter.field("vpc", &self.vpc);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("target_violation_reason", &self.target_violation_reason);
        formatter.finish()
    }
}
/// See [`NetworkFirewallMissingSubnetViolation`](crate::model::NetworkFirewallMissingSubnetViolation)
pub mod network_firewall_missing_subnet_violation {
    /// A builder for [`NetworkFirewallMissingSubnetViolation`](crate::model::NetworkFirewallMissingSubnetViolation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) violation_target: std::option::Option<std::string::String>,
        pub(crate) vpc: std::option::Option<std::string::String>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) target_violation_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the AWS Network Firewall or VPC resource that's in violation.</p>
        pub fn violation_target(mut self, input: impl Into<std::string::String>) -> Self {
            self.violation_target = Some(input.into());
            self
        }
        pub fn set_violation_target(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.violation_target = input;
            self
        }
        /// <p>The resource ID of the VPC associated with a violating subnet.</p>
        pub fn vpc(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc = Some(input.into());
            self
        }
        pub fn set_vpc(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc = input;
            self
        }
        /// <p>The Availability Zone of a violating subnet. </p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The reason the resource has this violation, if one is available. </p>
        pub fn target_violation_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_violation_reason = Some(input.into());
            self
        }
        pub fn set_target_violation_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_violation_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkFirewallMissingSubnetViolation`](crate::model::NetworkFirewallMissingSubnetViolation)
        pub fn build(self) -> crate::model::NetworkFirewallMissingSubnetViolation {
            crate::model::NetworkFirewallMissingSubnetViolation {
                violation_target: self.violation_target,
                vpc: self.vpc,
                availability_zone: self.availability_zone,
                target_violation_reason: self.target_violation_reason,
            }
        }
    }
}
impl NetworkFirewallMissingSubnetViolation {
    /// Creates a new builder-style object to manufacture [`NetworkFirewallMissingSubnetViolation`](crate::model::NetworkFirewallMissingSubnetViolation)
    pub fn builder() -> crate::model::network_firewall_missing_subnet_violation::Builder {
        crate::model::network_firewall_missing_subnet_violation::Builder::default()
    }
}

/// <p>Violation details for AWS Network Firewall for a subnet that doesn't have a
/// Firewall Manager managed firewall in its VPC. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkFirewallMissingFirewallViolation {
    /// <p>The ID of the AWS Network Firewall or VPC resource that's in violation.</p>
    pub violation_target: std::option::Option<std::string::String>,
    /// <p>The resource ID of the VPC associated with a violating subnet.</p>
    pub vpc: std::option::Option<std::string::String>,
    /// <p>The Availability Zone of a violating subnet. </p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The reason the resource has this violation, if one is available. </p>
    pub target_violation_reason: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NetworkFirewallMissingFirewallViolation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkFirewallMissingFirewallViolation");
        formatter.field("violation_target", &self.violation_target);
        formatter.field("vpc", &self.vpc);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("target_violation_reason", &self.target_violation_reason);
        formatter.finish()
    }
}
/// See [`NetworkFirewallMissingFirewallViolation`](crate::model::NetworkFirewallMissingFirewallViolation)
pub mod network_firewall_missing_firewall_violation {
    /// A builder for [`NetworkFirewallMissingFirewallViolation`](crate::model::NetworkFirewallMissingFirewallViolation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) violation_target: std::option::Option<std::string::String>,
        pub(crate) vpc: std::option::Option<std::string::String>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) target_violation_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the AWS Network Firewall or VPC resource that's in violation.</p>
        pub fn violation_target(mut self, input: impl Into<std::string::String>) -> Self {
            self.violation_target = Some(input.into());
            self
        }
        pub fn set_violation_target(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.violation_target = input;
            self
        }
        /// <p>The resource ID of the VPC associated with a violating subnet.</p>
        pub fn vpc(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc = Some(input.into());
            self
        }
        pub fn set_vpc(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc = input;
            self
        }
        /// <p>The Availability Zone of a violating subnet. </p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The reason the resource has this violation, if one is available. </p>
        pub fn target_violation_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_violation_reason = Some(input.into());
            self
        }
        pub fn set_target_violation_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_violation_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkFirewallMissingFirewallViolation`](crate::model::NetworkFirewallMissingFirewallViolation)
        pub fn build(self) -> crate::model::NetworkFirewallMissingFirewallViolation {
            crate::model::NetworkFirewallMissingFirewallViolation {
                violation_target: self.violation_target,
                vpc: self.vpc,
                availability_zone: self.availability_zone,
                target_violation_reason: self.target_violation_reason,
            }
        }
    }
}
impl NetworkFirewallMissingFirewallViolation {
    /// Creates a new builder-style object to manufacture [`NetworkFirewallMissingFirewallViolation`](crate::model::NetworkFirewallMissingFirewallViolation)
    pub fn builder() -> crate::model::network_firewall_missing_firewall_violation::Builder {
        crate::model::network_firewall_missing_firewall_violation::Builder::default()
    }
}

/// <p>Violations for an EC2 instance resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2InstanceViolation {
    /// <p>The resource ID of the EC2 instance.</p>
    pub violation_target: std::option::Option<std::string::String>,
    /// <p>Violations for network interfaces associated with the EC2 instance.</p>
    pub aws_ec2_network_interface_violations:
        std::option::Option<std::vec::Vec<crate::model::AwsEc2NetworkInterfaceViolation>>,
}
impl std::fmt::Debug for AwsEc2InstanceViolation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2InstanceViolation");
        formatter.field("violation_target", &self.violation_target);
        formatter.field(
            "aws_ec2_network_interface_violations",
            &self.aws_ec2_network_interface_violations,
        );
        formatter.finish()
    }
}
/// See [`AwsEc2InstanceViolation`](crate::model::AwsEc2InstanceViolation)
pub mod aws_ec2_instance_violation {
    /// A builder for [`AwsEc2InstanceViolation`](crate::model::AwsEc2InstanceViolation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) violation_target: std::option::Option<std::string::String>,
        pub(crate) aws_ec2_network_interface_violations:
            std::option::Option<std::vec::Vec<crate::model::AwsEc2NetworkInterfaceViolation>>,
    }
    impl Builder {
        /// <p>The resource ID of the EC2 instance.</p>
        pub fn violation_target(mut self, input: impl Into<std::string::String>) -> Self {
            self.violation_target = Some(input.into());
            self
        }
        pub fn set_violation_target(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.violation_target = input;
            self
        }
        pub fn aws_ec2_network_interface_violations(
            mut self,
            input: impl Into<crate::model::AwsEc2NetworkInterfaceViolation>,
        ) -> Self {
            let mut v = self
                .aws_ec2_network_interface_violations
                .unwrap_or_default();
            v.push(input.into());
            self.aws_ec2_network_interface_violations = Some(v);
            self
        }
        pub fn set_aws_ec2_network_interface_violations(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AwsEc2NetworkInterfaceViolation>,
            >,
        ) -> Self {
            self.aws_ec2_network_interface_violations = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2InstanceViolation`](crate::model::AwsEc2InstanceViolation)
        pub fn build(self) -> crate::model::AwsEc2InstanceViolation {
            crate::model::AwsEc2InstanceViolation {
                violation_target: self.violation_target,
                aws_ec2_network_interface_violations: self.aws_ec2_network_interface_violations,
            }
        }
    }
}
impl AwsEc2InstanceViolation {
    /// Creates a new builder-style object to manufacture [`AwsEc2InstanceViolation`](crate::model::AwsEc2InstanceViolation)
    pub fn builder() -> crate::model::aws_ec2_instance_violation::Builder {
        crate::model::aws_ec2_instance_violation::Builder::default()
    }
}

/// <p>Violations for network interfaces associated with an EC2 instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsEc2NetworkInterfaceViolation {
    /// <p>The resource ID of the network interface.</p>
    pub violation_target: std::option::Option<std::string::String>,
    /// <p>List of security groups that violate the rules specified in the master security group of the AWS Firewall Manager policy.</p>
    pub violating_security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for AwsEc2NetworkInterfaceViolation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsEc2NetworkInterfaceViolation");
        formatter.field("violation_target", &self.violation_target);
        formatter.field("violating_security_groups", &self.violating_security_groups);
        formatter.finish()
    }
}
/// See [`AwsEc2NetworkInterfaceViolation`](crate::model::AwsEc2NetworkInterfaceViolation)
pub mod aws_ec2_network_interface_violation {
    /// A builder for [`AwsEc2NetworkInterfaceViolation`](crate::model::AwsEc2NetworkInterfaceViolation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) violation_target: std::option::Option<std::string::String>,
        pub(crate) violating_security_groups:
            std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The resource ID of the network interface.</p>
        pub fn violation_target(mut self, input: impl Into<std::string::String>) -> Self {
            self.violation_target = Some(input.into());
            self
        }
        pub fn set_violation_target(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.violation_target = input;
            self
        }
        pub fn violating_security_groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.violating_security_groups.unwrap_or_default();
            v.push(input.into());
            self.violating_security_groups = Some(v);
            self
        }
        pub fn set_violating_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.violating_security_groups = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsEc2NetworkInterfaceViolation`](crate::model::AwsEc2NetworkInterfaceViolation)
        pub fn build(self) -> crate::model::AwsEc2NetworkInterfaceViolation {
            crate::model::AwsEc2NetworkInterfaceViolation {
                violation_target: self.violation_target,
                violating_security_groups: self.violating_security_groups,
            }
        }
    }
}
impl AwsEc2NetworkInterfaceViolation {
    /// Creates a new builder-style object to manufacture [`AwsEc2NetworkInterfaceViolation`](crate::model::AwsEc2NetworkInterfaceViolation)
    pub fn builder() -> crate::model::aws_ec2_network_interface_violation::Builder {
        crate::model::aws_ec2_network_interface_violation::Builder::default()
    }
}

/// <p>Details of the rule violation in a security group when compared to the master security group of the AWS Firewall Manager policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsVpcSecurityGroupViolation {
    /// <p>The security group rule that is being evaluated.</p>
    pub violation_target: std::option::Option<std::string::String>,
    /// <p>A description of the security group that violates the policy.</p>
    pub violation_target_description: std::option::Option<std::string::String>,
    /// <p>List of rules specified in the security group of the AWS Firewall Manager policy that partially match the <code>ViolationTarget</code> rule.</p>
    pub partial_matches: std::option::Option<std::vec::Vec<crate::model::PartialMatch>>,
    /// <p>Remediation options for the rule specified in the <code>ViolationTarget</code>.</p>
    pub possible_security_group_remediation_actions:
        std::option::Option<std::vec::Vec<crate::model::SecurityGroupRemediationAction>>,
}
impl std::fmt::Debug for AwsVpcSecurityGroupViolation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsVpcSecurityGroupViolation");
        formatter.field("violation_target", &self.violation_target);
        formatter.field(
            "violation_target_description",
            &self.violation_target_description,
        );
        formatter.field("partial_matches", &self.partial_matches);
        formatter.field(
            "possible_security_group_remediation_actions",
            &self.possible_security_group_remediation_actions,
        );
        formatter.finish()
    }
}
/// See [`AwsVpcSecurityGroupViolation`](crate::model::AwsVpcSecurityGroupViolation)
pub mod aws_vpc_security_group_violation {
    /// A builder for [`AwsVpcSecurityGroupViolation`](crate::model::AwsVpcSecurityGroupViolation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) violation_target: std::option::Option<std::string::String>,
        pub(crate) violation_target_description: std::option::Option<std::string::String>,
        pub(crate) partial_matches: std::option::Option<std::vec::Vec<crate::model::PartialMatch>>,
        pub(crate) possible_security_group_remediation_actions:
            std::option::Option<std::vec::Vec<crate::model::SecurityGroupRemediationAction>>,
    }
    impl Builder {
        /// <p>The security group rule that is being evaluated.</p>
        pub fn violation_target(mut self, input: impl Into<std::string::String>) -> Self {
            self.violation_target = Some(input.into());
            self
        }
        pub fn set_violation_target(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.violation_target = input;
            self
        }
        /// <p>A description of the security group that violates the policy.</p>
        pub fn violation_target_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.violation_target_description = Some(input.into());
            self
        }
        pub fn set_violation_target_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.violation_target_description = input;
            self
        }
        pub fn partial_matches(mut self, input: impl Into<crate::model::PartialMatch>) -> Self {
            let mut v = self.partial_matches.unwrap_or_default();
            v.push(input.into());
            self.partial_matches = Some(v);
            self
        }
        pub fn set_partial_matches(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PartialMatch>>,
        ) -> Self {
            self.partial_matches = input;
            self
        }
        pub fn possible_security_group_remediation_actions(
            mut self,
            input: impl Into<crate::model::SecurityGroupRemediationAction>,
        ) -> Self {
            let mut v = self
                .possible_security_group_remediation_actions
                .unwrap_or_default();
            v.push(input.into());
            self.possible_security_group_remediation_actions = Some(v);
            self
        }
        pub fn set_possible_security_group_remediation_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SecurityGroupRemediationAction>>,
        ) -> Self {
            self.possible_security_group_remediation_actions = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsVpcSecurityGroupViolation`](crate::model::AwsVpcSecurityGroupViolation)
        pub fn build(self) -> crate::model::AwsVpcSecurityGroupViolation {
            crate::model::AwsVpcSecurityGroupViolation {
                violation_target: self.violation_target,
                violation_target_description: self.violation_target_description,
                partial_matches: self.partial_matches,
                possible_security_group_remediation_actions: self
                    .possible_security_group_remediation_actions,
            }
        }
    }
}
impl AwsVpcSecurityGroupViolation {
    /// Creates a new builder-style object to manufacture [`AwsVpcSecurityGroupViolation`](crate::model::AwsVpcSecurityGroupViolation)
    pub fn builder() -> crate::model::aws_vpc_security_group_violation::Builder {
        crate::model::aws_vpc_security_group_violation::Builder::default()
    }
}

/// <p>Remediation option for the rule specified in the <code>ViolationTarget</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SecurityGroupRemediationAction {
    /// <p>The remediation action that will be performed.</p>
    pub remediation_action_type: std::option::Option<crate::model::RemediationActionType>,
    /// <p>Brief description of the action that will be performed.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The final state of the rule specified in the <code>ViolationTarget</code> after it is remediated.</p>
    pub remediation_result: std::option::Option<crate::model::SecurityGroupRuleDescription>,
    /// <p>Indicates if the current action is the default action.</p>
    pub is_default_action: bool,
}
impl std::fmt::Debug for SecurityGroupRemediationAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SecurityGroupRemediationAction");
        formatter.field("remediation_action_type", &self.remediation_action_type);
        formatter.field("description", &self.description);
        formatter.field("remediation_result", &self.remediation_result);
        formatter.field("is_default_action", &self.is_default_action);
        formatter.finish()
    }
}
/// See [`SecurityGroupRemediationAction`](crate::model::SecurityGroupRemediationAction)
pub mod security_group_remediation_action {
    /// A builder for [`SecurityGroupRemediationAction`](crate::model::SecurityGroupRemediationAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) remediation_action_type:
            std::option::Option<crate::model::RemediationActionType>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) remediation_result:
            std::option::Option<crate::model::SecurityGroupRuleDescription>,
        pub(crate) is_default_action: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The remediation action that will be performed.</p>
        pub fn remediation_action_type(
            mut self,
            input: crate::model::RemediationActionType,
        ) -> Self {
            self.remediation_action_type = Some(input);
            self
        }
        pub fn set_remediation_action_type(
            mut self,
            input: std::option::Option<crate::model::RemediationActionType>,
        ) -> Self {
            self.remediation_action_type = input;
            self
        }
        /// <p>Brief description of the action that will be performed.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The final state of the rule specified in the <code>ViolationTarget</code> after it is remediated.</p>
        pub fn remediation_result(
            mut self,
            input: crate::model::SecurityGroupRuleDescription,
        ) -> Self {
            self.remediation_result = Some(input);
            self
        }
        pub fn set_remediation_result(
            mut self,
            input: std::option::Option<crate::model::SecurityGroupRuleDescription>,
        ) -> Self {
            self.remediation_result = input;
            self
        }
        /// <p>Indicates if the current action is the default action.</p>
        pub fn is_default_action(mut self, input: bool) -> Self {
            self.is_default_action = Some(input);
            self
        }
        pub fn set_is_default_action(mut self, input: std::option::Option<bool>) -> Self {
            self.is_default_action = input;
            self
        }
        /// Consumes the builder and constructs a [`SecurityGroupRemediationAction`](crate::model::SecurityGroupRemediationAction)
        pub fn build(self) -> crate::model::SecurityGroupRemediationAction {
            crate::model::SecurityGroupRemediationAction {
                remediation_action_type: self.remediation_action_type,
                description: self.description,
                remediation_result: self.remediation_result,
                is_default_action: self.is_default_action.unwrap_or_default(),
            }
        }
    }
}
impl SecurityGroupRemediationAction {
    /// Creates a new builder-style object to manufacture [`SecurityGroupRemediationAction`](crate::model::SecurityGroupRemediationAction)
    pub fn builder() -> crate::model::security_group_remediation_action::Builder {
        crate::model::security_group_remediation_action::Builder::default()
    }
}

/// <p>Describes a set of permissions for a security group rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SecurityGroupRuleDescription {
    /// <p>The IPv4 ranges for the security group rule.</p>
    pub ipv4_range: std::option::Option<std::string::String>,
    /// <p>The IPv6 ranges for the security group rule.</p>
    pub ipv6_range: std::option::Option<std::string::String>,
    /// <p>The ID of the prefix list for the security group rule.</p>
    pub prefix_list_id: std::option::Option<std::string::String>,
    /// <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>, <code>icmpv6</code>) or number.</p>
    pub protocol: std::option::Option<std::string::String>,
    /// <p>The start of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of <code>-1</code> indicates all ICMP/ICMPv6 types.</p>
    pub from_port: std::option::Option<i64>,
    /// <p>The end of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of <code>-1</code> indicates all ICMP/ICMPv6 codes.</p>
    pub to_port: std::option::Option<i64>,
}
impl std::fmt::Debug for SecurityGroupRuleDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SecurityGroupRuleDescription");
        formatter.field("ipv4_range", &self.ipv4_range);
        formatter.field("ipv6_range", &self.ipv6_range);
        formatter.field("prefix_list_id", &self.prefix_list_id);
        formatter.field("protocol", &self.protocol);
        formatter.field("from_port", &self.from_port);
        formatter.field("to_port", &self.to_port);
        formatter.finish()
    }
}
/// See [`SecurityGroupRuleDescription`](crate::model::SecurityGroupRuleDescription)
pub mod security_group_rule_description {
    /// A builder for [`SecurityGroupRuleDescription`](crate::model::SecurityGroupRuleDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ipv4_range: std::option::Option<std::string::String>,
        pub(crate) ipv6_range: std::option::Option<std::string::String>,
        pub(crate) prefix_list_id: std::option::Option<std::string::String>,
        pub(crate) protocol: std::option::Option<std::string::String>,
        pub(crate) from_port: std::option::Option<i64>,
        pub(crate) to_port: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The IPv4 ranges for the security group rule.</p>
        pub fn ipv4_range(mut self, input: impl Into<std::string::String>) -> Self {
            self.ipv4_range = Some(input.into());
            self
        }
        pub fn set_ipv4_range(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ipv4_range = input;
            self
        }
        /// <p>The IPv6 ranges for the security group rule.</p>
        pub fn ipv6_range(mut self, input: impl Into<std::string::String>) -> Self {
            self.ipv6_range = Some(input.into());
            self
        }
        pub fn set_ipv6_range(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ipv6_range = input;
            self
        }
        /// <p>The ID of the prefix list for the security group rule.</p>
        pub fn prefix_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix_list_id = Some(input.into());
            self
        }
        pub fn set_prefix_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.prefix_list_id = input;
            self
        }
        /// <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>, <code>icmpv6</code>) or number.</p>
        pub fn protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.protocol = Some(input.into());
            self
        }
        pub fn set_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.protocol = input;
            self
        }
        /// <p>The start of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of <code>-1</code> indicates all ICMP/ICMPv6 types.</p>
        pub fn from_port(mut self, input: i64) -> Self {
            self.from_port = Some(input);
            self
        }
        pub fn set_from_port(mut self, input: std::option::Option<i64>) -> Self {
            self.from_port = input;
            self
        }
        /// <p>The end of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of <code>-1</code> indicates all ICMP/ICMPv6 codes.</p>
        pub fn to_port(mut self, input: i64) -> Self {
            self.to_port = Some(input);
            self
        }
        pub fn set_to_port(mut self, input: std::option::Option<i64>) -> Self {
            self.to_port = input;
            self
        }
        /// Consumes the builder and constructs a [`SecurityGroupRuleDescription`](crate::model::SecurityGroupRuleDescription)
        pub fn build(self) -> crate::model::SecurityGroupRuleDescription {
            crate::model::SecurityGroupRuleDescription {
                ipv4_range: self.ipv4_range,
                ipv6_range: self.ipv6_range,
                prefix_list_id: self.prefix_list_id,
                protocol: self.protocol,
                from_port: self.from_port,
                to_port: self.to_port,
            }
        }
    }
}
impl SecurityGroupRuleDescription {
    /// Creates a new builder-style object to manufacture [`SecurityGroupRuleDescription`](crate::model::SecurityGroupRuleDescription)
    pub fn builder() -> crate::model::security_group_rule_description::Builder {
        crate::model::security_group_rule_description::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RemediationActionType {
    Modify,
    Remove,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RemediationActionType {
    fn from(s: &str) -> Self {
        match s {
            "MODIFY" => RemediationActionType::Modify,
            "REMOVE" => RemediationActionType::Remove,
            other => RemediationActionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RemediationActionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RemediationActionType::from(s))
    }
}
impl RemediationActionType {
    pub fn as_str(&self) -> &str {
        match self {
            RemediationActionType::Modify => "MODIFY",
            RemediationActionType::Remove => "REMOVE",
            RemediationActionType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["MODIFY", "REMOVE"]
    }
}
impl AsRef<str> for RemediationActionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The reference rule that partially matches the <code>ViolationTarget</code> rule and violation reason.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PartialMatch {
    /// <p>The reference rule from the master security group of the AWS Firewall Manager policy.</p>
    pub reference: std::option::Option<std::string::String>,
    /// <p>The violation reason.</p>
    pub target_violation_reasons: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for PartialMatch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PartialMatch");
        formatter.field("reference", &self.reference);
        formatter.field("target_violation_reasons", &self.target_violation_reasons);
        formatter.finish()
    }
}
/// See [`PartialMatch`](crate::model::PartialMatch)
pub mod partial_match {
    /// A builder for [`PartialMatch`](crate::model::PartialMatch)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reference: std::option::Option<std::string::String>,
        pub(crate) target_violation_reasons:
            std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The reference rule from the master security group of the AWS Firewall Manager policy.</p>
        pub fn reference(mut self, input: impl Into<std::string::String>) -> Self {
            self.reference = Some(input.into());
            self
        }
        pub fn set_reference(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reference = input;
            self
        }
        pub fn target_violation_reasons(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.target_violation_reasons.unwrap_or_default();
            v.push(input.into());
            self.target_violation_reasons = Some(v);
            self
        }
        pub fn set_target_violation_reasons(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.target_violation_reasons = input;
            self
        }
        /// Consumes the builder and constructs a [`PartialMatch`](crate::model::PartialMatch)
        pub fn build(self) -> crate::model::PartialMatch {
            crate::model::PartialMatch {
                reference: self.reference,
                target_violation_reasons: self.target_violation_reasons,
            }
        }
    }
}
impl PartialMatch {
    /// Creates a new builder-style object to manufacture [`PartialMatch`](crate::model::PartialMatch)
    pub fn builder() -> crate::model::partial_match::Builder {
        crate::model::partial_match::Builder::default()
    }
}

/// <p>Describes
/// the noncompliant resources in a member account for a specific AWS Firewall
/// Manager policy. A maximum of 100 entries are displayed. If more than 100 resources are
/// noncompliant, <code>EvaluationLimitExceeded</code> is set to <code>True</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PolicyComplianceDetail {
    /// <p>The AWS account that created the AWS Firewall Manager policy.</p>
    pub policy_owner: std::option::Option<std::string::String>,
    /// <p>The ID of the AWS Firewall Manager policy.</p>
    pub policy_id: std::option::Option<std::string::String>,
    /// <p>The AWS account ID.</p>
    pub member_account: std::option::Option<std::string::String>,
    /// <p>An array of resources that aren't protected by the AWS WAF or Shield Advanced policy or
    /// that aren't in compliance with the security group policy.</p>
    pub violators: std::option::Option<std::vec::Vec<crate::model::ComplianceViolator>>,
    /// <p>Indicates if over 100 resources are noncompliant with the AWS Firewall Manager
    /// policy.</p>
    pub evaluation_limit_exceeded: bool,
    /// <p>A timestamp that indicates when the returned information should be considered out of
    /// date.</p>
    pub expired_at: std::option::Option<smithy_types::Instant>,
    /// <p>Details about problems with dependent services, such as AWS WAF or AWS Config, that are
    /// causing a resource to be noncompliant. The details include the name of the dependent service
    /// and the error message received that indicates the problem with the service.</p>
    pub issue_info_map: std::option::Option<
        std::collections::HashMap<crate::model::DependentServiceName, std::string::String>,
    >,
}
impl std::fmt::Debug for PolicyComplianceDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PolicyComplianceDetail");
        formatter.field("policy_owner", &self.policy_owner);
        formatter.field("policy_id", &self.policy_id);
        formatter.field("member_account", &self.member_account);
        formatter.field("violators", &self.violators);
        formatter.field("evaluation_limit_exceeded", &self.evaluation_limit_exceeded);
        formatter.field("expired_at", &self.expired_at);
        formatter.field("issue_info_map", &self.issue_info_map);
        formatter.finish()
    }
}
/// See [`PolicyComplianceDetail`](crate::model::PolicyComplianceDetail)
pub mod policy_compliance_detail {
    /// A builder for [`PolicyComplianceDetail`](crate::model::PolicyComplianceDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_owner: std::option::Option<std::string::String>,
        pub(crate) policy_id: std::option::Option<std::string::String>,
        pub(crate) member_account: std::option::Option<std::string::String>,
        pub(crate) violators: std::option::Option<std::vec::Vec<crate::model::ComplianceViolator>>,
        pub(crate) evaluation_limit_exceeded: std::option::Option<bool>,
        pub(crate) expired_at: std::option::Option<smithy_types::Instant>,
        pub(crate) issue_info_map: std::option::Option<
            std::collections::HashMap<crate::model::DependentServiceName, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The AWS account that created the AWS Firewall Manager policy.</p>
        pub fn policy_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_owner = Some(input.into());
            self
        }
        pub fn set_policy_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_owner = input;
            self
        }
        /// <p>The ID of the AWS Firewall Manager policy.</p>
        pub fn policy_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_id = Some(input.into());
            self
        }
        pub fn set_policy_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_id = input;
            self
        }
        /// <p>The AWS account ID.</p>
        pub fn member_account(mut self, input: impl Into<std::string::String>) -> Self {
            self.member_account = Some(input.into());
            self
        }
        pub fn set_member_account(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.member_account = input;
            self
        }
        pub fn violators(mut self, input: impl Into<crate::model::ComplianceViolator>) -> Self {
            let mut v = self.violators.unwrap_or_default();
            v.push(input.into());
            self.violators = Some(v);
            self
        }
        pub fn set_violators(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ComplianceViolator>>,
        ) -> Self {
            self.violators = input;
            self
        }
        /// <p>Indicates if over 100 resources are noncompliant with the AWS Firewall Manager
        /// policy.</p>
        pub fn evaluation_limit_exceeded(mut self, input: bool) -> Self {
            self.evaluation_limit_exceeded = Some(input);
            self
        }
        pub fn set_evaluation_limit_exceeded(mut self, input: std::option::Option<bool>) -> Self {
            self.evaluation_limit_exceeded = input;
            self
        }
        /// <p>A timestamp that indicates when the returned information should be considered out of
        /// date.</p>
        pub fn expired_at(mut self, input: smithy_types::Instant) -> Self {
            self.expired_at = Some(input);
            self
        }
        pub fn set_expired_at(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.expired_at = input;
            self
        }
        pub fn issue_info_map(
            mut self,
            k: impl Into<crate::model::DependentServiceName>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.issue_info_map.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.issue_info_map = Some(hash_map);
            self
        }
        pub fn set_issue_info_map(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<crate::model::DependentServiceName, std::string::String>,
            >,
        ) -> Self {
            self.issue_info_map = input;
            self
        }
        /// Consumes the builder and constructs a [`PolicyComplianceDetail`](crate::model::PolicyComplianceDetail)
        pub fn build(self) -> crate::model::PolicyComplianceDetail {
            crate::model::PolicyComplianceDetail {
                policy_owner: self.policy_owner,
                policy_id: self.policy_id,
                member_account: self.member_account,
                violators: self.violators,
                evaluation_limit_exceeded: self.evaluation_limit_exceeded.unwrap_or_default(),
                expired_at: self.expired_at,
                issue_info_map: self.issue_info_map,
            }
        }
    }
}
impl PolicyComplianceDetail {
    /// Creates a new builder-style object to manufacture [`PolicyComplianceDetail`](crate::model::PolicyComplianceDetail)
    pub fn builder() -> crate::model::policy_compliance_detail::Builder {
        crate::model::policy_compliance_detail::Builder::default()
    }
}

/// <p>Details of the resource that is not protected by the policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ComplianceViolator {
    /// <p>The resource ID.</p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The reason that the resource is not protected by the policy.</p>
    pub violation_reason: std::option::Option<crate::model::ViolationReason>,
    /// <p>The resource type. This is in the format shown in the <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">AWS Resource Types Reference</a>. For example:
    /// <code>AWS::ElasticLoadBalancingV2::LoadBalancer</code>,
    /// <code>AWS::CloudFront::Distribution</code>, or
    /// <code>AWS::NetworkFirewall::FirewallPolicy</code>.</p>
    pub resource_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ComplianceViolator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ComplianceViolator");
        formatter.field("resource_id", &self.resource_id);
        formatter.field("violation_reason", &self.violation_reason);
        formatter.field("resource_type", &self.resource_type);
        formatter.finish()
    }
}
/// See [`ComplianceViolator`](crate::model::ComplianceViolator)
pub mod compliance_violator {
    /// A builder for [`ComplianceViolator`](crate::model::ComplianceViolator)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) violation_reason: std::option::Option<crate::model::ViolationReason>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The resource ID.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The reason that the resource is not protected by the policy.</p>
        pub fn violation_reason(mut self, input: crate::model::ViolationReason) -> Self {
            self.violation_reason = Some(input);
            self
        }
        pub fn set_violation_reason(
            mut self,
            input: std::option::Option<crate::model::ViolationReason>,
        ) -> Self {
            self.violation_reason = input;
            self
        }
        /// <p>The resource type. This is in the format shown in the <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">AWS Resource Types Reference</a>. For example:
        /// <code>AWS::ElasticLoadBalancingV2::LoadBalancer</code>,
        /// <code>AWS::CloudFront::Distribution</code>, or
        /// <code>AWS::NetworkFirewall::FirewallPolicy</code>.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ComplianceViolator`](crate::model::ComplianceViolator)
        pub fn build(self) -> crate::model::ComplianceViolator {
            crate::model::ComplianceViolator {
                resource_id: self.resource_id,
                violation_reason: self.violation_reason,
                resource_type: self.resource_type,
            }
        }
    }
}
impl ComplianceViolator {
    /// Creates a new builder-style object to manufacture [`ComplianceViolator`](crate::model::ComplianceViolator)
    pub fn builder() -> crate::model::compliance_violator::Builder {
        crate::model::compliance_violator::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ViolationReason {
    FmsCreatedSecurityGroupEdited,
    MissingExpectedRouteTable,
    MissingFirewall,
    MissingFirewallSubnetInAz,
    NetworkFirewallPolicyModified,
    ResourceIncorrectWebAcl,
    ResourceMissingDnsFirewall,
    ResourceMissingSecurityGroup,
    ResourceMissingShieldProtection,
    ResourceMissingWebAcl,
    ResourceMissingWebaclOrShieldProtection,
    ResourceViolatesAuditSecurityGroup,
    SecurityGroupRedundant,
    SecurityGroupUnused,
    WebAclMissingRuleGroup,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ViolationReason {
    fn from(s: &str) -> Self {
        match s {
            "FMS_CREATED_SECURITY_GROUP_EDITED" => ViolationReason::FmsCreatedSecurityGroupEdited,
            "MISSING_EXPECTED_ROUTE_TABLE" => ViolationReason::MissingExpectedRouteTable,
            "MISSING_FIREWALL" => ViolationReason::MissingFirewall,
            "MISSING_FIREWALL_SUBNET_IN_AZ" => ViolationReason::MissingFirewallSubnetInAz,
            "NETWORK_FIREWALL_POLICY_MODIFIED" => ViolationReason::NetworkFirewallPolicyModified,
            "RESOURCE_INCORRECT_WEB_ACL" => ViolationReason::ResourceIncorrectWebAcl,
            "RESOURCE_MISSING_DNS_FIREWALL" => ViolationReason::ResourceMissingDnsFirewall,
            "RESOURCE_MISSING_SECURITY_GROUP" => ViolationReason::ResourceMissingSecurityGroup,
            "RESOURCE_MISSING_SHIELD_PROTECTION" => {
                ViolationReason::ResourceMissingShieldProtection
            }
            "RESOURCE_MISSING_WEB_ACL" => ViolationReason::ResourceMissingWebAcl,
            "RESOURCE_MISSING_WEB_ACL_OR_SHIELD_PROTECTION" => {
                ViolationReason::ResourceMissingWebaclOrShieldProtection
            }
            "RESOURCE_VIOLATES_AUDIT_SECURITY_GROUP" => {
                ViolationReason::ResourceViolatesAuditSecurityGroup
            }
            "SECURITY_GROUP_REDUNDANT" => ViolationReason::SecurityGroupRedundant,
            "SECURITY_GROUP_UNUSED" => ViolationReason::SecurityGroupUnused,
            "WEB_ACL_MISSING_RULE_GROUP" => ViolationReason::WebAclMissingRuleGroup,
            other => ViolationReason::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ViolationReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ViolationReason::from(s))
    }
}
impl ViolationReason {
    pub fn as_str(&self) -> &str {
        match self {
            ViolationReason::FmsCreatedSecurityGroupEdited => "FMS_CREATED_SECURITY_GROUP_EDITED",
            ViolationReason::MissingExpectedRouteTable => "MISSING_EXPECTED_ROUTE_TABLE",
            ViolationReason::MissingFirewall => "MISSING_FIREWALL",
            ViolationReason::MissingFirewallSubnetInAz => "MISSING_FIREWALL_SUBNET_IN_AZ",
            ViolationReason::NetworkFirewallPolicyModified => "NETWORK_FIREWALL_POLICY_MODIFIED",
            ViolationReason::ResourceIncorrectWebAcl => "RESOURCE_INCORRECT_WEB_ACL",
            ViolationReason::ResourceMissingDnsFirewall => "RESOURCE_MISSING_DNS_FIREWALL",
            ViolationReason::ResourceMissingSecurityGroup => "RESOURCE_MISSING_SECURITY_GROUP",
            ViolationReason::ResourceMissingShieldProtection => {
                "RESOURCE_MISSING_SHIELD_PROTECTION"
            }
            ViolationReason::ResourceMissingWebAcl => "RESOURCE_MISSING_WEB_ACL",
            ViolationReason::ResourceMissingWebaclOrShieldProtection => {
                "RESOURCE_MISSING_WEB_ACL_OR_SHIELD_PROTECTION"
            }
            ViolationReason::ResourceViolatesAuditSecurityGroup => {
                "RESOURCE_VIOLATES_AUDIT_SECURITY_GROUP"
            }
            ViolationReason::SecurityGroupRedundant => "SECURITY_GROUP_REDUNDANT",
            ViolationReason::SecurityGroupUnused => "SECURITY_GROUP_UNUSED",
            ViolationReason::WebAclMissingRuleGroup => "WEB_ACL_MISSING_RULE_GROUP",
            ViolationReason::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "FMS_CREATED_SECURITY_GROUP_EDITED",
            "MISSING_EXPECTED_ROUTE_TABLE",
            "MISSING_FIREWALL",
            "MISSING_FIREWALL_SUBNET_IN_AZ",
            "NETWORK_FIREWALL_POLICY_MODIFIED",
            "RESOURCE_INCORRECT_WEB_ACL",
            "RESOURCE_MISSING_DNS_FIREWALL",
            "RESOURCE_MISSING_SECURITY_GROUP",
            "RESOURCE_MISSING_SHIELD_PROTECTION",
            "RESOURCE_MISSING_WEB_ACL",
            "RESOURCE_MISSING_WEB_ACL_OR_SHIELD_PROTECTION",
            "RESOURCE_VIOLATES_AUDIT_SECURITY_GROUP",
            "SECURITY_GROUP_REDUNDANT",
            "SECURITY_GROUP_UNUSED",
            "WEB_ACL_MISSING_RULE_GROUP",
        ]
    }
}
impl AsRef<str> for ViolationReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AccountRoleStatus {
    Creating,
    Deleted,
    Deleting,
    PendingDeletion,
    Ready,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AccountRoleStatus {
    fn from(s: &str) -> Self {
        match s {
            "CREATING" => AccountRoleStatus::Creating,
            "DELETED" => AccountRoleStatus::Deleted,
            "DELETING" => AccountRoleStatus::Deleting,
            "PENDING_DELETION" => AccountRoleStatus::PendingDeletion,
            "READY" => AccountRoleStatus::Ready,
            other => AccountRoleStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AccountRoleStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AccountRoleStatus::from(s))
    }
}
impl AccountRoleStatus {
    pub fn as_str(&self) -> &str {
        match self {
            AccountRoleStatus::Creating => "CREATING",
            AccountRoleStatus::Deleted => "DELETED",
            AccountRoleStatus::Deleting => "DELETING",
            AccountRoleStatus::PendingDeletion => "PENDING_DELETION",
            AccountRoleStatus::Ready => "READY",
            AccountRoleStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "CREATING",
            "DELETED",
            "DELETING",
            "PENDING_DELETION",
            "READY",
        ]
    }
}
impl AsRef<str> for AccountRoleStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
