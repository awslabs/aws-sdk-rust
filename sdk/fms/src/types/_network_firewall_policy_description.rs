// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The definition of the Network Firewall firewall policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NetworkFirewallPolicyDescription {
    /// <p>The stateless rule groups that are used in the Network Firewall firewall policy. </p>
    #[doc(hidden)]
    pub stateless_rule_groups: std::option::Option<std::vec::Vec<crate::types::StatelessRuleGroup>>,
    /// <p>The actions to take on packets that don't match any of the stateless rule groups. </p>
    #[doc(hidden)]
    pub stateless_default_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The actions to take on packet fragments that don't match any of the stateless rule groups. </p>
    #[doc(hidden)]
    pub stateless_fragment_default_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Names of custom actions that are available for use in the stateless default actions settings.</p>
    #[doc(hidden)]
    pub stateless_custom_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The stateful rule groups that are used in the Network Firewall firewall policy. </p>
    #[doc(hidden)]
    pub stateful_rule_groups: std::option::Option<std::vec::Vec<crate::types::StatefulRuleGroup>>,
    /// <p>The default actions to take on a packet that doesn't match any stateful rules. The stateful default action is optional, and is only valid when using the strict rule order.</p>
    /// <p> Valid values of the stateful default action: </p>
    /// <ul>
    /// <li> <p>aws:drop_strict</p> </li>
    /// <li> <p>aws:drop_established</p> </li>
    /// <li> <p>aws:alert_strict</p> </li>
    /// <li> <p>aws:alert_established</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub stateful_default_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Additional options governing how Network Firewall handles stateful rules. The stateful rule groups that you use in your policy must have stateful rule options settings that are compatible with these settings.</p>
    #[doc(hidden)]
    pub stateful_engine_options: std::option::Option<crate::types::StatefulEngineOptions>,
}
impl NetworkFirewallPolicyDescription {
    /// <p>The stateless rule groups that are used in the Network Firewall firewall policy. </p>
    pub fn stateless_rule_groups(
        &self,
    ) -> std::option::Option<&[crate::types::StatelessRuleGroup]> {
        self.stateless_rule_groups.as_deref()
    }
    /// <p>The actions to take on packets that don't match any of the stateless rule groups. </p>
    pub fn stateless_default_actions(&self) -> std::option::Option<&[std::string::String]> {
        self.stateless_default_actions.as_deref()
    }
    /// <p>The actions to take on packet fragments that don't match any of the stateless rule groups. </p>
    pub fn stateless_fragment_default_actions(
        &self,
    ) -> std::option::Option<&[std::string::String]> {
        self.stateless_fragment_default_actions.as_deref()
    }
    /// <p>Names of custom actions that are available for use in the stateless default actions settings.</p>
    pub fn stateless_custom_actions(&self) -> std::option::Option<&[std::string::String]> {
        self.stateless_custom_actions.as_deref()
    }
    /// <p>The stateful rule groups that are used in the Network Firewall firewall policy. </p>
    pub fn stateful_rule_groups(&self) -> std::option::Option<&[crate::types::StatefulRuleGroup]> {
        self.stateful_rule_groups.as_deref()
    }
    /// <p>The default actions to take on a packet that doesn't match any stateful rules. The stateful default action is optional, and is only valid when using the strict rule order.</p>
    /// <p> Valid values of the stateful default action: </p>
    /// <ul>
    /// <li> <p>aws:drop_strict</p> </li>
    /// <li> <p>aws:drop_established</p> </li>
    /// <li> <p>aws:alert_strict</p> </li>
    /// <li> <p>aws:alert_established</p> </li>
    /// </ul>
    pub fn stateful_default_actions(&self) -> std::option::Option<&[std::string::String]> {
        self.stateful_default_actions.as_deref()
    }
    /// <p>Additional options governing how Network Firewall handles stateful rules. The stateful rule groups that you use in your policy must have stateful rule options settings that are compatible with these settings.</p>
    pub fn stateful_engine_options(
        &self,
    ) -> std::option::Option<&crate::types::StatefulEngineOptions> {
        self.stateful_engine_options.as_ref()
    }
}
impl NetworkFirewallPolicyDescription {
    /// Creates a new builder-style object to manufacture [`NetworkFirewallPolicyDescription`](crate::types::NetworkFirewallPolicyDescription).
    pub fn builder() -> crate::types::builders::NetworkFirewallPolicyDescriptionBuilder {
        crate::types::builders::NetworkFirewallPolicyDescriptionBuilder::default()
    }
}

/// A builder for [`NetworkFirewallPolicyDescription`](crate::types::NetworkFirewallPolicyDescription).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct NetworkFirewallPolicyDescriptionBuilder {
    pub(crate) stateless_rule_groups:
        std::option::Option<std::vec::Vec<crate::types::StatelessRuleGroup>>,
    pub(crate) stateless_default_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) stateless_fragment_default_actions:
        std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) stateless_custom_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) stateful_rule_groups:
        std::option::Option<std::vec::Vec<crate::types::StatefulRuleGroup>>,
    pub(crate) stateful_default_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) stateful_engine_options: std::option::Option<crate::types::StatefulEngineOptions>,
}
impl NetworkFirewallPolicyDescriptionBuilder {
    /// Appends an item to `stateless_rule_groups`.
    ///
    /// To override the contents of this collection use [`set_stateless_rule_groups`](Self::set_stateless_rule_groups).
    ///
    /// <p>The stateless rule groups that are used in the Network Firewall firewall policy. </p>
    pub fn stateless_rule_groups(mut self, input: crate::types::StatelessRuleGroup) -> Self {
        let mut v = self.stateless_rule_groups.unwrap_or_default();
        v.push(input);
        self.stateless_rule_groups = Some(v);
        self
    }
    /// <p>The stateless rule groups that are used in the Network Firewall firewall policy. </p>
    pub fn set_stateless_rule_groups(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::StatelessRuleGroup>>,
    ) -> Self {
        self.stateless_rule_groups = input;
        self
    }
    /// Appends an item to `stateless_default_actions`.
    ///
    /// To override the contents of this collection use [`set_stateless_default_actions`](Self::set_stateless_default_actions).
    ///
    /// <p>The actions to take on packets that don't match any of the stateless rule groups. </p>
    pub fn stateless_default_actions(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.stateless_default_actions.unwrap_or_default();
        v.push(input.into());
        self.stateless_default_actions = Some(v);
        self
    }
    /// <p>The actions to take on packets that don't match any of the stateless rule groups. </p>
    pub fn set_stateless_default_actions(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.stateless_default_actions = input;
        self
    }
    /// Appends an item to `stateless_fragment_default_actions`.
    ///
    /// To override the contents of this collection use [`set_stateless_fragment_default_actions`](Self::set_stateless_fragment_default_actions).
    ///
    /// <p>The actions to take on packet fragments that don't match any of the stateless rule groups. </p>
    pub fn stateless_fragment_default_actions(
        mut self,
        input: impl Into<std::string::String>,
    ) -> Self {
        let mut v = self.stateless_fragment_default_actions.unwrap_or_default();
        v.push(input.into());
        self.stateless_fragment_default_actions = Some(v);
        self
    }
    /// <p>The actions to take on packet fragments that don't match any of the stateless rule groups. </p>
    pub fn set_stateless_fragment_default_actions(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.stateless_fragment_default_actions = input;
        self
    }
    /// Appends an item to `stateless_custom_actions`.
    ///
    /// To override the contents of this collection use [`set_stateless_custom_actions`](Self::set_stateless_custom_actions).
    ///
    /// <p>Names of custom actions that are available for use in the stateless default actions settings.</p>
    pub fn stateless_custom_actions(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.stateless_custom_actions.unwrap_or_default();
        v.push(input.into());
        self.stateless_custom_actions = Some(v);
        self
    }
    /// <p>Names of custom actions that are available for use in the stateless default actions settings.</p>
    pub fn set_stateless_custom_actions(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.stateless_custom_actions = input;
        self
    }
    /// Appends an item to `stateful_rule_groups`.
    ///
    /// To override the contents of this collection use [`set_stateful_rule_groups`](Self::set_stateful_rule_groups).
    ///
    /// <p>The stateful rule groups that are used in the Network Firewall firewall policy. </p>
    pub fn stateful_rule_groups(mut self, input: crate::types::StatefulRuleGroup) -> Self {
        let mut v = self.stateful_rule_groups.unwrap_or_default();
        v.push(input);
        self.stateful_rule_groups = Some(v);
        self
    }
    /// <p>The stateful rule groups that are used in the Network Firewall firewall policy. </p>
    pub fn set_stateful_rule_groups(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::StatefulRuleGroup>>,
    ) -> Self {
        self.stateful_rule_groups = input;
        self
    }
    /// Appends an item to `stateful_default_actions`.
    ///
    /// To override the contents of this collection use [`set_stateful_default_actions`](Self::set_stateful_default_actions).
    ///
    /// <p>The default actions to take on a packet that doesn't match any stateful rules. The stateful default action is optional, and is only valid when using the strict rule order.</p>
    /// <p> Valid values of the stateful default action: </p>
    /// <ul>
    /// <li> <p>aws:drop_strict</p> </li>
    /// <li> <p>aws:drop_established</p> </li>
    /// <li> <p>aws:alert_strict</p> </li>
    /// <li> <p>aws:alert_established</p> </li>
    /// </ul>
    pub fn stateful_default_actions(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.stateful_default_actions.unwrap_or_default();
        v.push(input.into());
        self.stateful_default_actions = Some(v);
        self
    }
    /// <p>The default actions to take on a packet that doesn't match any stateful rules. The stateful default action is optional, and is only valid when using the strict rule order.</p>
    /// <p> Valid values of the stateful default action: </p>
    /// <ul>
    /// <li> <p>aws:drop_strict</p> </li>
    /// <li> <p>aws:drop_established</p> </li>
    /// <li> <p>aws:alert_strict</p> </li>
    /// <li> <p>aws:alert_established</p> </li>
    /// </ul>
    pub fn set_stateful_default_actions(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.stateful_default_actions = input;
        self
    }
    /// <p>Additional options governing how Network Firewall handles stateful rules. The stateful rule groups that you use in your policy must have stateful rule options settings that are compatible with these settings.</p>
    pub fn stateful_engine_options(mut self, input: crate::types::StatefulEngineOptions) -> Self {
        self.stateful_engine_options = Some(input);
        self
    }
    /// <p>Additional options governing how Network Firewall handles stateful rules. The stateful rule groups that you use in your policy must have stateful rule options settings that are compatible with these settings.</p>
    pub fn set_stateful_engine_options(
        mut self,
        input: std::option::Option<crate::types::StatefulEngineOptions>,
    ) -> Self {
        self.stateful_engine_options = input;
        self
    }
    /// Consumes the builder and constructs a [`NetworkFirewallPolicyDescription`](crate::types::NetworkFirewallPolicyDescription).
    pub fn build(self) -> crate::types::NetworkFirewallPolicyDescription {
        crate::types::NetworkFirewallPolicyDescription {
            stateless_rule_groups: self.stateless_rule_groups,
            stateless_default_actions: self.stateless_default_actions,
            stateless_fragment_default_actions: self.stateless_fragment_default_actions,
            stateless_custom_actions: self.stateless_custom_actions,
            stateful_rule_groups: self.stateful_rule_groups,
            stateful_default_actions: self.stateful_default_actions,
            stateful_engine_options: self.stateful_engine_options,
        }
    }
}
