// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Represents the value of a cell in an Amazon Keyspaces table, supporting various data types with type-specific fields.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub enum KeyspacesCellValue {
    /// <p>A value of ASCII text type, containing US-ASCII characters.</p>
    AsciiT(::std::string::String),
    /// <p>A 64-bit signed integer value.</p>
    BigintT(::std::string::String),
    /// <p>A binary large object (BLOB) value stored as a Base64-encoded string.</p>
    BlobT(::aws_smithy_types::Blob),
    /// <p>A Boolean value, either <code>true</code> or <code>false</code>.</p>
    BoolT(bool),
    /// <p>A distributed counter value that can be incremented and decremented.</p>
    CounterT(::std::string::String),
    /// <p>A date value without a time component, represented as days since epoch (January 1, 1970).</p>
    DateT(::std::string::String),
    /// <p>A variable-precision decimal number value.</p>
    DecimalT(::std::string::String),
    /// <p>A 64-bit double-precision floating point value.</p>
    DoubleT(::std::string::String),
    /// <p>A 32-bit single-precision floating point value.</p>
    FloatT(::std::string::String),
    /// <p>An IP address value, either IPv4 or IPv6 format.</p>
    InetT(::std::string::String),
    /// <p>A 32-bit signed integer value.</p>
    IntT(::std::string::String),
    /// <p>An ordered collection of elements that can contain duplicate values.</p>
    ListT(::std::vec::Vec<crate::types::KeyspacesCell>),
    /// <p>A collection of key-value pairs where each key is unique.</p>
    MapT(::std::vec::Vec<crate::types::KeyspacesCellMapDefinition>),
    /// <p>An unordered collection of unique elements.</p>
    SetT(::std::vec::Vec<crate::types::KeyspacesCell>),
    /// <p>A 16-bit signed integer value.</p>
    SmallintT(::std::string::String),
    /// <p>A UTF-8 encoded string value.</p>
    TextT(::std::string::String),
    /// <p>A time value without a date component, with nanosecond precision.</p>
    TimeT(::std::string::String),
    /// <p>A timestamp value representing date and time with millisecond precision.</p>
    TimestampT(::std::string::String),
    /// <p>A universally unique identifier (UUID) that includes a timestamp component, ensuring both uniqueness and time ordering.</p>
    TimeuuidT(::std::string::String),
    /// <p>An 8-bit signed integer value.</p>
    TinyintT(::std::string::String),
    /// <p>A fixed-length ordered list of elements, where each element can be of a different data type.</p>
    TupleT(::std::vec::Vec<crate::types::KeyspacesCell>),
    /// <p>A user-defined type (UDT) value consisting of named fields, each with its own data type.</p>
    UdtT(::std::collections::HashMap<::std::string::String, crate::types::KeyspacesCell>),
    /// <p>A universally unique identifier (UUID) value.</p>
    UuidT(::std::string::String),
    /// <p>A UTF-8 encoded string value, functionally equivalent to text type.</p>
    VarcharT(::std::string::String),
    /// <p>A variable precision integer value with arbitrary length.</p>
    VarintT(::std::string::String),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl KeyspacesCellValue {
    /// Tries to convert the enum instance into [`AsciiT`](crate::types::KeyspacesCellValue::AsciiT), extracting the inner [`String`](::std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_ascii_t(&self) -> ::std::result::Result<&::std::string::String, &Self> {
        if let KeyspacesCellValue::AsciiT(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`AsciiT`](crate::types::KeyspacesCellValue::AsciiT).
    pub fn is_ascii_t(&self) -> bool {
        self.as_ascii_t().is_ok()
    }
    /// Tries to convert the enum instance into [`BigintT`](crate::types::KeyspacesCellValue::BigintT), extracting the inner [`String`](::std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_bigint_t(&self) -> ::std::result::Result<&::std::string::String, &Self> {
        if let KeyspacesCellValue::BigintT(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`BigintT`](crate::types::KeyspacesCellValue::BigintT).
    pub fn is_bigint_t(&self) -> bool {
        self.as_bigint_t().is_ok()
    }
    /// Tries to convert the enum instance into [`BlobT`](crate::types::KeyspacesCellValue::BlobT), extracting the inner [`Blob`](::aws_smithy_types::Blob).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_blob_t(&self) -> ::std::result::Result<&::aws_smithy_types::Blob, &Self> {
        if let KeyspacesCellValue::BlobT(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`BlobT`](crate::types::KeyspacesCellValue::BlobT).
    pub fn is_blob_t(&self) -> bool {
        self.as_blob_t().is_ok()
    }
    /// Tries to convert the enum instance into [`BoolT`](crate::types::KeyspacesCellValue::BoolT), extracting the inner [`bool`](bool).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_bool_t(&self) -> ::std::result::Result<&bool, &Self> {
        if let KeyspacesCellValue::BoolT(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`BoolT`](crate::types::KeyspacesCellValue::BoolT).
    pub fn is_bool_t(&self) -> bool {
        self.as_bool_t().is_ok()
    }
    /// Tries to convert the enum instance into [`CounterT`](crate::types::KeyspacesCellValue::CounterT), extracting the inner [`String`](::std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_counter_t(&self) -> ::std::result::Result<&::std::string::String, &Self> {
        if let KeyspacesCellValue::CounterT(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`CounterT`](crate::types::KeyspacesCellValue::CounterT).
    pub fn is_counter_t(&self) -> bool {
        self.as_counter_t().is_ok()
    }
    /// Tries to convert the enum instance into [`DateT`](crate::types::KeyspacesCellValue::DateT), extracting the inner [`String`](::std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_date_t(&self) -> ::std::result::Result<&::std::string::String, &Self> {
        if let KeyspacesCellValue::DateT(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`DateT`](crate::types::KeyspacesCellValue::DateT).
    pub fn is_date_t(&self) -> bool {
        self.as_date_t().is_ok()
    }
    /// Tries to convert the enum instance into [`DecimalT`](crate::types::KeyspacesCellValue::DecimalT), extracting the inner [`String`](::std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_decimal_t(&self) -> ::std::result::Result<&::std::string::String, &Self> {
        if let KeyspacesCellValue::DecimalT(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`DecimalT`](crate::types::KeyspacesCellValue::DecimalT).
    pub fn is_decimal_t(&self) -> bool {
        self.as_decimal_t().is_ok()
    }
    /// Tries to convert the enum instance into [`DoubleT`](crate::types::KeyspacesCellValue::DoubleT), extracting the inner [`String`](::std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_double_t(&self) -> ::std::result::Result<&::std::string::String, &Self> {
        if let KeyspacesCellValue::DoubleT(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`DoubleT`](crate::types::KeyspacesCellValue::DoubleT).
    pub fn is_double_t(&self) -> bool {
        self.as_double_t().is_ok()
    }
    /// Tries to convert the enum instance into [`FloatT`](crate::types::KeyspacesCellValue::FloatT), extracting the inner [`String`](::std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_float_t(&self) -> ::std::result::Result<&::std::string::String, &Self> {
        if let KeyspacesCellValue::FloatT(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`FloatT`](crate::types::KeyspacesCellValue::FloatT).
    pub fn is_float_t(&self) -> bool {
        self.as_float_t().is_ok()
    }
    /// Tries to convert the enum instance into [`InetT`](crate::types::KeyspacesCellValue::InetT), extracting the inner [`String`](::std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_inet_t(&self) -> ::std::result::Result<&::std::string::String, &Self> {
        if let KeyspacesCellValue::InetT(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`InetT`](crate::types::KeyspacesCellValue::InetT).
    pub fn is_inet_t(&self) -> bool {
        self.as_inet_t().is_ok()
    }
    /// Tries to convert the enum instance into [`IntT`](crate::types::KeyspacesCellValue::IntT), extracting the inner [`String`](::std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_int_t(&self) -> ::std::result::Result<&::std::string::String, &Self> {
        if let KeyspacesCellValue::IntT(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`IntT`](crate::types::KeyspacesCellValue::IntT).
    pub fn is_int_t(&self) -> bool {
        self.as_int_t().is_ok()
    }
    /// Tries to convert the enum instance into [`ListT`](crate::types::KeyspacesCellValue::ListT), extracting the inner [`Vec`](::std::vec::Vec).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_list_t(&self) -> ::std::result::Result<&::std::vec::Vec<crate::types::KeyspacesCell>, &Self> {
        if let KeyspacesCellValue::ListT(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`ListT`](crate::types::KeyspacesCellValue::ListT).
    pub fn is_list_t(&self) -> bool {
        self.as_list_t().is_ok()
    }
    /// Tries to convert the enum instance into [`MapT`](crate::types::KeyspacesCellValue::MapT), extracting the inner [`Vec`](::std::vec::Vec).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_map_t(&self) -> ::std::result::Result<&::std::vec::Vec<crate::types::KeyspacesCellMapDefinition>, &Self> {
        if let KeyspacesCellValue::MapT(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`MapT`](crate::types::KeyspacesCellValue::MapT).
    pub fn is_map_t(&self) -> bool {
        self.as_map_t().is_ok()
    }
    /// Tries to convert the enum instance into [`SetT`](crate::types::KeyspacesCellValue::SetT), extracting the inner [`Vec`](::std::vec::Vec).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_set_t(&self) -> ::std::result::Result<&::std::vec::Vec<crate::types::KeyspacesCell>, &Self> {
        if let KeyspacesCellValue::SetT(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`SetT`](crate::types::KeyspacesCellValue::SetT).
    pub fn is_set_t(&self) -> bool {
        self.as_set_t().is_ok()
    }
    /// Tries to convert the enum instance into [`SmallintT`](crate::types::KeyspacesCellValue::SmallintT), extracting the inner [`String`](::std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_smallint_t(&self) -> ::std::result::Result<&::std::string::String, &Self> {
        if let KeyspacesCellValue::SmallintT(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`SmallintT`](crate::types::KeyspacesCellValue::SmallintT).
    pub fn is_smallint_t(&self) -> bool {
        self.as_smallint_t().is_ok()
    }
    /// Tries to convert the enum instance into [`TextT`](crate::types::KeyspacesCellValue::TextT), extracting the inner [`String`](::std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_text_t(&self) -> ::std::result::Result<&::std::string::String, &Self> {
        if let KeyspacesCellValue::TextT(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`TextT`](crate::types::KeyspacesCellValue::TextT).
    pub fn is_text_t(&self) -> bool {
        self.as_text_t().is_ok()
    }
    /// Tries to convert the enum instance into [`TimeT`](crate::types::KeyspacesCellValue::TimeT), extracting the inner [`String`](::std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_time_t(&self) -> ::std::result::Result<&::std::string::String, &Self> {
        if let KeyspacesCellValue::TimeT(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`TimeT`](crate::types::KeyspacesCellValue::TimeT).
    pub fn is_time_t(&self) -> bool {
        self.as_time_t().is_ok()
    }
    /// Tries to convert the enum instance into [`TimestampT`](crate::types::KeyspacesCellValue::TimestampT), extracting the inner [`String`](::std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_timestamp_t(&self) -> ::std::result::Result<&::std::string::String, &Self> {
        if let KeyspacesCellValue::TimestampT(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`TimestampT`](crate::types::KeyspacesCellValue::TimestampT).
    pub fn is_timestamp_t(&self) -> bool {
        self.as_timestamp_t().is_ok()
    }
    /// Tries to convert the enum instance into [`TimeuuidT`](crate::types::KeyspacesCellValue::TimeuuidT), extracting the inner [`String`](::std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_timeuuid_t(&self) -> ::std::result::Result<&::std::string::String, &Self> {
        if let KeyspacesCellValue::TimeuuidT(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`TimeuuidT`](crate::types::KeyspacesCellValue::TimeuuidT).
    pub fn is_timeuuid_t(&self) -> bool {
        self.as_timeuuid_t().is_ok()
    }
    /// Tries to convert the enum instance into [`TinyintT`](crate::types::KeyspacesCellValue::TinyintT), extracting the inner [`String`](::std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_tinyint_t(&self) -> ::std::result::Result<&::std::string::String, &Self> {
        if let KeyspacesCellValue::TinyintT(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`TinyintT`](crate::types::KeyspacesCellValue::TinyintT).
    pub fn is_tinyint_t(&self) -> bool {
        self.as_tinyint_t().is_ok()
    }
    /// Tries to convert the enum instance into [`TupleT`](crate::types::KeyspacesCellValue::TupleT), extracting the inner [`Vec`](::std::vec::Vec).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_tuple_t(&self) -> ::std::result::Result<&::std::vec::Vec<crate::types::KeyspacesCell>, &Self> {
        if let KeyspacesCellValue::TupleT(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`TupleT`](crate::types::KeyspacesCellValue::TupleT).
    pub fn is_tuple_t(&self) -> bool {
        self.as_tuple_t().is_ok()
    }
    /// Tries to convert the enum instance into [`UdtT`](crate::types::KeyspacesCellValue::UdtT), extracting the inner [`HashMap`](::std::collections::HashMap).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_udt_t(&self) -> ::std::result::Result<&::std::collections::HashMap<::std::string::String, crate::types::KeyspacesCell>, &Self> {
        if let KeyspacesCellValue::UdtT(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`UdtT`](crate::types::KeyspacesCellValue::UdtT).
    pub fn is_udt_t(&self) -> bool {
        self.as_udt_t().is_ok()
    }
    /// Tries to convert the enum instance into [`UuidT`](crate::types::KeyspacesCellValue::UuidT), extracting the inner [`String`](::std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_uuid_t(&self) -> ::std::result::Result<&::std::string::String, &Self> {
        if let KeyspacesCellValue::UuidT(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`UuidT`](crate::types::KeyspacesCellValue::UuidT).
    pub fn is_uuid_t(&self) -> bool {
        self.as_uuid_t().is_ok()
    }
    /// Tries to convert the enum instance into [`VarcharT`](crate::types::KeyspacesCellValue::VarcharT), extracting the inner [`String`](::std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_varchar_t(&self) -> ::std::result::Result<&::std::string::String, &Self> {
        if let KeyspacesCellValue::VarcharT(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`VarcharT`](crate::types::KeyspacesCellValue::VarcharT).
    pub fn is_varchar_t(&self) -> bool {
        self.as_varchar_t().is_ok()
    }
    /// Tries to convert the enum instance into [`VarintT`](crate::types::KeyspacesCellValue::VarintT), extracting the inner [`String`](::std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_varint_t(&self) -> ::std::result::Result<&::std::string::String, &Self> {
        if let KeyspacesCellValue::VarintT(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`VarintT`](crate::types::KeyspacesCellValue::VarintT).
    pub fn is_varint_t(&self) -> bool {
        self.as_varint_t().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}
