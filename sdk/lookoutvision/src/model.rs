// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `ResourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourcetype = unimplemented!();
/// match resourcetype {
///     ResourceType::Dataset => { /* ... */ },
///     ResourceType::Model => { /* ... */ },
///     ResourceType::ModelPackageJob => { /* ... */ },
///     ResourceType::Project => { /* ... */ },
///     ResourceType::Trial => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceType::NewFeature` is defined.
/// Specifically, when `resourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceType {
    #[allow(missing_docs)] // documentation missing in model
    Dataset,
    #[allow(missing_docs)] // documentation missing in model
    Model,
    #[allow(missing_docs)] // documentation missing in model
    ModelPackageJob,
    #[allow(missing_docs)] // documentation missing in model
    Project,
    #[allow(missing_docs)] // documentation missing in model
    Trial,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceType {
    fn from(s: &str) -> Self {
        match s {
            "DATASET" => ResourceType::Dataset,
            "MODEL" => ResourceType::Model,
            "MODEL_PACKAGE_JOB" => ResourceType::ModelPackageJob,
            "PROJECT" => ResourceType::Project,
            "TRIAL" => ResourceType::Trial,
            other => ResourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceType::from(s))
    }
}
impl ResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceType::Dataset => "DATASET",
            ResourceType::Model => "MODEL",
            ResourceType::ModelPackageJob => "MODEL_PACKAGE_JOB",
            ResourceType::Project => "PROJECT",
            ResourceType::Trial => "TRIAL",
            ResourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DATASET", "MODEL", "MODEL_PACKAGE_JOB", "PROJECT", "TRIAL"]
    }
}
impl AsRef<str> for ResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DatasetStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datasetstatus = unimplemented!();
/// match datasetstatus {
///     DatasetStatus::CreateComplete => { /* ... */ },
///     DatasetStatus::CreateFailed => { /* ... */ },
///     DatasetStatus::CreateInProgress => { /* ... */ },
///     DatasetStatus::DeleteComplete => { /* ... */ },
///     DatasetStatus::DeleteFailed => { /* ... */ },
///     DatasetStatus::DeleteInProgress => { /* ... */ },
///     DatasetStatus::UpdateComplete => { /* ... */ },
///     DatasetStatus::UpdateFailedRollbackComplete => { /* ... */ },
///     DatasetStatus::UpdateFailedRollbackInProgress => { /* ... */ },
///     DatasetStatus::UpdateInProgress => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datasetstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DatasetStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DatasetStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DatasetStatus::NewFeature` is defined.
/// Specifically, when `datasetstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DatasetStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DatasetStatus {
    #[allow(missing_docs)] // documentation missing in model
    CreateComplete,
    #[allow(missing_docs)] // documentation missing in model
    CreateFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    DeleteComplete,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    DeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    UpdateComplete,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFailedRollbackComplete,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFailedRollbackInProgress,
    #[allow(missing_docs)] // documentation missing in model
    UpdateInProgress,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DatasetStatus {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_COMPLETE" => DatasetStatus::CreateComplete,
            "CREATE_FAILED" => DatasetStatus::CreateFailed,
            "CREATE_IN_PROGRESS" => DatasetStatus::CreateInProgress,
            "DELETE_COMPLETE" => DatasetStatus::DeleteComplete,
            "DELETE_FAILED" => DatasetStatus::DeleteFailed,
            "DELETE_IN_PROGRESS" => DatasetStatus::DeleteInProgress,
            "UPDATE_COMPLETE" => DatasetStatus::UpdateComplete,
            "UPDATE_FAILED_ROLLBACK_COMPLETE" => DatasetStatus::UpdateFailedRollbackComplete,
            "UPDATE_FAILED_ROLLBACK_IN_PROGRESS" => DatasetStatus::UpdateFailedRollbackInProgress,
            "UPDATE_IN_PROGRESS" => DatasetStatus::UpdateInProgress,
            other => DatasetStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DatasetStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DatasetStatus::from(s))
    }
}
impl DatasetStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DatasetStatus::CreateComplete => "CREATE_COMPLETE",
            DatasetStatus::CreateFailed => "CREATE_FAILED",
            DatasetStatus::CreateInProgress => "CREATE_IN_PROGRESS",
            DatasetStatus::DeleteComplete => "DELETE_COMPLETE",
            DatasetStatus::DeleteFailed => "DELETE_FAILED",
            DatasetStatus::DeleteInProgress => "DELETE_IN_PROGRESS",
            DatasetStatus::UpdateComplete => "UPDATE_COMPLETE",
            DatasetStatus::UpdateFailedRollbackComplete => "UPDATE_FAILED_ROLLBACK_COMPLETE",
            DatasetStatus::UpdateFailedRollbackInProgress => "UPDATE_FAILED_ROLLBACK_IN_PROGRESS",
            DatasetStatus::UpdateInProgress => "UPDATE_IN_PROGRESS",
            DatasetStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CREATE_COMPLETE",
            "CREATE_FAILED",
            "CREATE_IN_PROGRESS",
            "DELETE_COMPLETE",
            "DELETE_FAILED",
            "DELETE_IN_PROGRESS",
            "UPDATE_COMPLETE",
            "UPDATE_FAILED_ROLLBACK_COMPLETE",
            "UPDATE_FAILED_ROLLBACK_IN_PROGRESS",
            "UPDATE_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for DatasetStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A key and value pair that is attached to the specified Amazon Lookout for Vision model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Tag {
    /// <p>The key of the tag that is attached to the specified model.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The value of the tag that is attached to the specified model.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>The key of the tag that is attached to the specified model.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value of the tag that is attached to the specified model.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`Tag`](crate::model::Tag).
pub mod tag {

    /// A builder for [`Tag`](crate::model::Tag).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key of the tag that is attached to the specified model.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The key of the tag that is attached to the specified model.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value of the tag that is attached to the specified model.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the tag that is attached to the specified model.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag).
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag).
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// When writing a match expression against `ModelHostingStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let modelhostingstatus = unimplemented!();
/// match modelhostingstatus {
///     ModelHostingStatus::Hosted => { /* ... */ },
///     ModelHostingStatus::HostingFailed => { /* ... */ },
///     ModelHostingStatus::StartingHosting => { /* ... */ },
///     ModelHostingStatus::StoppingHosting => { /* ... */ },
///     ModelHostingStatus::SystemUpdating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `modelhostingstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ModelHostingStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ModelHostingStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ModelHostingStatus::NewFeature` is defined.
/// Specifically, when `modelhostingstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ModelHostingStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelHostingStatus {
    #[allow(missing_docs)] // documentation missing in model
    Hosted,
    #[allow(missing_docs)] // documentation missing in model
    HostingFailed,
    #[allow(missing_docs)] // documentation missing in model
    StartingHosting,
    #[allow(missing_docs)] // documentation missing in model
    StoppingHosting,
    #[allow(missing_docs)] // documentation missing in model
    SystemUpdating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ModelHostingStatus {
    fn from(s: &str) -> Self {
        match s {
            "HOSTED" => ModelHostingStatus::Hosted,
            "HOSTING_FAILED" => ModelHostingStatus::HostingFailed,
            "STARTING_HOSTING" => ModelHostingStatus::StartingHosting,
            "STOPPING_HOSTING" => ModelHostingStatus::StoppingHosting,
            "SYSTEM_UPDATING" => ModelHostingStatus::SystemUpdating,
            other => {
                ModelHostingStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ModelHostingStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelHostingStatus::from(s))
    }
}
impl ModelHostingStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ModelHostingStatus::Hosted => "HOSTED",
            ModelHostingStatus::HostingFailed => "HOSTING_FAILED",
            ModelHostingStatus::StartingHosting => "STARTING_HOSTING",
            ModelHostingStatus::StoppingHosting => "STOPPING_HOSTING",
            ModelHostingStatus::SystemUpdating => "SYSTEM_UPDATING",
            ModelHostingStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "HOSTED",
            "HOSTING_FAILED",
            "STARTING_HOSTING",
            "STOPPING_HOSTING",
            "SYSTEM_UPDATING",
        ]
    }
}
impl AsRef<str> for ModelHostingStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Configuration information for a Amazon Lookout for Vision model packaging job. For more information, see <code>StartModelPackagingJob</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ModelPackagingConfiguration {
    /// <p> Configuration information for the AWS IoT Greengrass component in a model packaging job. </p>
    #[doc(hidden)]
    pub greengrass: std::option::Option<crate::model::GreengrassConfiguration>,
}
impl ModelPackagingConfiguration {
    /// <p> Configuration information for the AWS IoT Greengrass component in a model packaging job. </p>
    pub fn greengrass(&self) -> std::option::Option<&crate::model::GreengrassConfiguration> {
        self.greengrass.as_ref()
    }
}
/// See [`ModelPackagingConfiguration`](crate::model::ModelPackagingConfiguration).
pub mod model_packaging_configuration {

    /// A builder for [`ModelPackagingConfiguration`](crate::model::ModelPackagingConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) greengrass: std::option::Option<crate::model::GreengrassConfiguration>,
    }
    impl Builder {
        /// <p> Configuration information for the AWS IoT Greengrass component in a model packaging job. </p>
        pub fn greengrass(mut self, input: crate::model::GreengrassConfiguration) -> Self {
            self.greengrass = Some(input);
            self
        }
        /// <p> Configuration information for the AWS IoT Greengrass component in a model packaging job. </p>
        pub fn set_greengrass(
            mut self,
            input: std::option::Option<crate::model::GreengrassConfiguration>,
        ) -> Self {
            self.greengrass = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelPackagingConfiguration`](crate::model::ModelPackagingConfiguration).
        pub fn build(self) -> crate::model::ModelPackagingConfiguration {
            crate::model::ModelPackagingConfiguration {
                greengrass: self.greengrass,
            }
        }
    }
}
impl ModelPackagingConfiguration {
    /// Creates a new builder-style object to manufacture [`ModelPackagingConfiguration`](crate::model::ModelPackagingConfiguration).
    pub fn builder() -> crate::model::model_packaging_configuration::Builder {
        crate::model::model_packaging_configuration::Builder::default()
    }
}

/// <p>Configuration information for the AWS IoT Greengrass component created in a model packaging job. For more information, see <code>StartModelPackagingJob</code>. </p> <note>
/// <p>You can't specify a component with the same <code>ComponentName</code> and <code>Componentversion</code> as an existing component with the same component name and component version.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GreengrassConfiguration {
    /// <p>Additional compiler options for the Greengrass component. Currently, only NVIDIA Graphics Processing Units (GPU) and CPU accelerators are supported. If you specify <code>TargetDevice</code>, don't specify <code>CompilerOptions</code>.</p>
    /// <p>For more information, see <i>Compiler options</i> in the Amazon Lookout for Vision Developer Guide. </p>
    #[doc(hidden)]
    pub compiler_options: std::option::Option<std::string::String>,
    /// <p>The target device for the model. Currently the only supported value is <code>jetson_xavier</code>. If you specify <code>TargetDevice</code>, you can't specify <code>TargetPlatform</code>. </p>
    #[doc(hidden)]
    pub target_device: std::option::Option<crate::model::TargetDevice>,
    /// <p>The target platform for the model. If you specify <code>TargetPlatform</code>, you can't specify <code>TargetDevice</code>. </p>
    #[doc(hidden)]
    pub target_platform: std::option::Option<crate::model::TargetPlatform>,
    /// <p> An S3 location in which Lookout for Vision stores the component artifacts. </p>
    #[doc(hidden)]
    pub s3_output_location: std::option::Option<crate::model::S3Location>,
    /// <p> A name for the AWS IoT Greengrass component. </p>
    #[doc(hidden)]
    pub component_name: std::option::Option<std::string::String>,
    /// <p>A Version for the AWS IoT Greengrass component. If you don't provide a value, a default value of <code> <i>Model Version</i>.0.0</code> is used. </p>
    #[doc(hidden)]
    pub component_version: std::option::Option<std::string::String>,
    /// <p> A description for the AWS IoT Greengrass component. </p>
    #[doc(hidden)]
    pub component_description: std::option::Option<std::string::String>,
    /// <p> A set of tags (key-value pairs) that you want to attach to the AWS IoT Greengrass component. </p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl GreengrassConfiguration {
    /// <p>Additional compiler options for the Greengrass component. Currently, only NVIDIA Graphics Processing Units (GPU) and CPU accelerators are supported. If you specify <code>TargetDevice</code>, don't specify <code>CompilerOptions</code>.</p>
    /// <p>For more information, see <i>Compiler options</i> in the Amazon Lookout for Vision Developer Guide. </p>
    pub fn compiler_options(&self) -> std::option::Option<&str> {
        self.compiler_options.as_deref()
    }
    /// <p>The target device for the model. Currently the only supported value is <code>jetson_xavier</code>. If you specify <code>TargetDevice</code>, you can't specify <code>TargetPlatform</code>. </p>
    pub fn target_device(&self) -> std::option::Option<&crate::model::TargetDevice> {
        self.target_device.as_ref()
    }
    /// <p>The target platform for the model. If you specify <code>TargetPlatform</code>, you can't specify <code>TargetDevice</code>. </p>
    pub fn target_platform(&self) -> std::option::Option<&crate::model::TargetPlatform> {
        self.target_platform.as_ref()
    }
    /// <p> An S3 location in which Lookout for Vision stores the component artifacts. </p>
    pub fn s3_output_location(&self) -> std::option::Option<&crate::model::S3Location> {
        self.s3_output_location.as_ref()
    }
    /// <p> A name for the AWS IoT Greengrass component. </p>
    pub fn component_name(&self) -> std::option::Option<&str> {
        self.component_name.as_deref()
    }
    /// <p>A Version for the AWS IoT Greengrass component. If you don't provide a value, a default value of <code> <i>Model Version</i>.0.0</code> is used. </p>
    pub fn component_version(&self) -> std::option::Option<&str> {
        self.component_version.as_deref()
    }
    /// <p> A description for the AWS IoT Greengrass component. </p>
    pub fn component_description(&self) -> std::option::Option<&str> {
        self.component_description.as_deref()
    }
    /// <p> A set of tags (key-value pairs) that you want to attach to the AWS IoT Greengrass component. </p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
/// See [`GreengrassConfiguration`](crate::model::GreengrassConfiguration).
pub mod greengrass_configuration {

    /// A builder for [`GreengrassConfiguration`](crate::model::GreengrassConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) compiler_options: std::option::Option<std::string::String>,
        pub(crate) target_device: std::option::Option<crate::model::TargetDevice>,
        pub(crate) target_platform: std::option::Option<crate::model::TargetPlatform>,
        pub(crate) s3_output_location: std::option::Option<crate::model::S3Location>,
        pub(crate) component_name: std::option::Option<std::string::String>,
        pub(crate) component_version: std::option::Option<std::string::String>,
        pub(crate) component_description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>Additional compiler options for the Greengrass component. Currently, only NVIDIA Graphics Processing Units (GPU) and CPU accelerators are supported. If you specify <code>TargetDevice</code>, don't specify <code>CompilerOptions</code>.</p>
        /// <p>For more information, see <i>Compiler options</i> in the Amazon Lookout for Vision Developer Guide. </p>
        pub fn compiler_options(mut self, input: impl Into<std::string::String>) -> Self {
            self.compiler_options = Some(input.into());
            self
        }
        /// <p>Additional compiler options for the Greengrass component. Currently, only NVIDIA Graphics Processing Units (GPU) and CPU accelerators are supported. If you specify <code>TargetDevice</code>, don't specify <code>CompilerOptions</code>.</p>
        /// <p>For more information, see <i>Compiler options</i> in the Amazon Lookout for Vision Developer Guide. </p>
        pub fn set_compiler_options(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.compiler_options = input;
            self
        }
        /// <p>The target device for the model. Currently the only supported value is <code>jetson_xavier</code>. If you specify <code>TargetDevice</code>, you can't specify <code>TargetPlatform</code>. </p>
        pub fn target_device(mut self, input: crate::model::TargetDevice) -> Self {
            self.target_device = Some(input);
            self
        }
        /// <p>The target device for the model. Currently the only supported value is <code>jetson_xavier</code>. If you specify <code>TargetDevice</code>, you can't specify <code>TargetPlatform</code>. </p>
        pub fn set_target_device(
            mut self,
            input: std::option::Option<crate::model::TargetDevice>,
        ) -> Self {
            self.target_device = input;
            self
        }
        /// <p>The target platform for the model. If you specify <code>TargetPlatform</code>, you can't specify <code>TargetDevice</code>. </p>
        pub fn target_platform(mut self, input: crate::model::TargetPlatform) -> Self {
            self.target_platform = Some(input);
            self
        }
        /// <p>The target platform for the model. If you specify <code>TargetPlatform</code>, you can't specify <code>TargetDevice</code>. </p>
        pub fn set_target_platform(
            mut self,
            input: std::option::Option<crate::model::TargetPlatform>,
        ) -> Self {
            self.target_platform = input;
            self
        }
        /// <p> An S3 location in which Lookout for Vision stores the component artifacts. </p>
        pub fn s3_output_location(mut self, input: crate::model::S3Location) -> Self {
            self.s3_output_location = Some(input);
            self
        }
        /// <p> An S3 location in which Lookout for Vision stores the component artifacts. </p>
        pub fn set_s3_output_location(
            mut self,
            input: std::option::Option<crate::model::S3Location>,
        ) -> Self {
            self.s3_output_location = input;
            self
        }
        /// <p> A name for the AWS IoT Greengrass component. </p>
        pub fn component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_name = Some(input.into());
            self
        }
        /// <p> A name for the AWS IoT Greengrass component. </p>
        pub fn set_component_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.component_name = input;
            self
        }
        /// <p>A Version for the AWS IoT Greengrass component. If you don't provide a value, a default value of <code> <i>Model Version</i>.0.0</code> is used. </p>
        pub fn component_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_version = Some(input.into());
            self
        }
        /// <p>A Version for the AWS IoT Greengrass component. If you don't provide a value, a default value of <code> <i>Model Version</i>.0.0</code> is used. </p>
        pub fn set_component_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.component_version = input;
            self
        }
        /// <p> A description for the AWS IoT Greengrass component. </p>
        pub fn component_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_description = Some(input.into());
            self
        }
        /// <p> A description for the AWS IoT Greengrass component. </p>
        pub fn set_component_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.component_description = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p> A set of tags (key-value pairs) that you want to attach to the AWS IoT Greengrass component. </p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p> A set of tags (key-value pairs) that you want to attach to the AWS IoT Greengrass component. </p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`GreengrassConfiguration`](crate::model::GreengrassConfiguration).
        pub fn build(self) -> crate::model::GreengrassConfiguration {
            crate::model::GreengrassConfiguration {
                compiler_options: self.compiler_options,
                target_device: self.target_device,
                target_platform: self.target_platform,
                s3_output_location: self.s3_output_location,
                component_name: self.component_name,
                component_version: self.component_version,
                component_description: self.component_description,
                tags: self.tags,
            }
        }
    }
}
impl GreengrassConfiguration {
    /// Creates a new builder-style object to manufacture [`GreengrassConfiguration`](crate::model::GreengrassConfiguration).
    pub fn builder() -> crate::model::greengrass_configuration::Builder {
        crate::model::greengrass_configuration::Builder::default()
    }
}

/// <p>Information about the location of training output or the output of a model packaging job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3Location {
    /// <p>The S3 bucket that contains the training or model packaging job output. If you are training a model, the bucket must in your AWS account. If you use an S3 bucket for a model packaging job, the S3 bucket must be in the same AWS Region and AWS account in which you use AWS IoT Greengrass.</p>
    #[doc(hidden)]
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The path of the folder, within the S3 bucket, that contains the output.</p>
    #[doc(hidden)]
    pub prefix: std::option::Option<std::string::String>,
}
impl S3Location {
    /// <p>The S3 bucket that contains the training or model packaging job output. If you are training a model, the bucket must in your AWS account. If you use an S3 bucket for a model packaging job, the S3 bucket must be in the same AWS Region and AWS account in which you use AWS IoT Greengrass.</p>
    pub fn bucket(&self) -> std::option::Option<&str> {
        self.bucket.as_deref()
    }
    /// <p>The path of the folder, within the S3 bucket, that contains the output.</p>
    pub fn prefix(&self) -> std::option::Option<&str> {
        self.prefix.as_deref()
    }
}
/// See [`S3Location`](crate::model::S3Location).
pub mod s3_location {

    /// A builder for [`S3Location`](crate::model::S3Location).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The S3 bucket that contains the training or model packaging job output. If you are training a model, the bucket must in your AWS account. If you use an S3 bucket for a model packaging job, the S3 bucket must be in the same AWS Region and AWS account in which you use AWS IoT Greengrass.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        /// <p>The S3 bucket that contains the training or model packaging job output. If you are training a model, the bucket must in your AWS account. If you use an S3 bucket for a model packaging job, the S3 bucket must be in the same AWS Region and AWS account in which you use AWS IoT Greengrass.</p>
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The path of the folder, within the S3 bucket, that contains the output.</p>
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        /// <p>The path of the folder, within the S3 bucket, that contains the output.</p>
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`S3Location`](crate::model::S3Location).
        pub fn build(self) -> crate::model::S3Location {
            crate::model::S3Location {
                bucket: self.bucket,
                prefix: self.prefix,
            }
        }
    }
}
impl S3Location {
    /// Creates a new builder-style object to manufacture [`S3Location`](crate::model::S3Location).
    pub fn builder() -> crate::model::s3_location::Builder {
        crate::model::s3_location::Builder::default()
    }
}

/// <p>The platform on which a model runs on an AWS IoT Greengrass core device.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TargetPlatform {
    /// <p>The target operating system for the model. Linux is the only operating system that is currently supported. </p>
    #[doc(hidden)]
    pub os: std::option::Option<crate::model::TargetPlatformOs>,
    /// <p>The target architecture for the model. The currently supported architectures are X86_64 (64-bit version of the x86 instruction set) and ARM_64 (ARMv8 64-bit CPU). </p>
    #[doc(hidden)]
    pub arch: std::option::Option<crate::model::TargetPlatformArch>,
    /// <p>The target accelerator for the model. Currently, Amazon Lookout for Vision only supports NVIDIA (Nvidia graphics processing unit) and CPU accelerators. If you specify NVIDIA as an accelerator, you must also specify the <code>gpu-code</code>, <code>trt-ver</code>, and <code>cuda-ver</code> compiler options. If you don't specify an accelerator, Lookout for Vision uses the CPU for compilation and we highly recommend that you use the <code>GreengrassConfiguration$CompilerOptions</code> field. For example, you can use the following compiler options for CPU: </p>
    /// <ul>
    /// <li> <p> <code>mcpu</code>: CPU micro-architecture. For example, <code>{'mcpu': 'skylake-avx512'}</code> </p> </li>
    /// <li> <p> <code>mattr</code>: CPU flags. For example, <code>{'mattr': ['+neon', '+vfpv4']}</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub accelerator: std::option::Option<crate::model::TargetPlatformAccelerator>,
}
impl TargetPlatform {
    /// <p>The target operating system for the model. Linux is the only operating system that is currently supported. </p>
    pub fn os(&self) -> std::option::Option<&crate::model::TargetPlatformOs> {
        self.os.as_ref()
    }
    /// <p>The target architecture for the model. The currently supported architectures are X86_64 (64-bit version of the x86 instruction set) and ARM_64 (ARMv8 64-bit CPU). </p>
    pub fn arch(&self) -> std::option::Option<&crate::model::TargetPlatformArch> {
        self.arch.as_ref()
    }
    /// <p>The target accelerator for the model. Currently, Amazon Lookout for Vision only supports NVIDIA (Nvidia graphics processing unit) and CPU accelerators. If you specify NVIDIA as an accelerator, you must also specify the <code>gpu-code</code>, <code>trt-ver</code>, and <code>cuda-ver</code> compiler options. If you don't specify an accelerator, Lookout for Vision uses the CPU for compilation and we highly recommend that you use the <code>GreengrassConfiguration$CompilerOptions</code> field. For example, you can use the following compiler options for CPU: </p>
    /// <ul>
    /// <li> <p> <code>mcpu</code>: CPU micro-architecture. For example, <code>{'mcpu': 'skylake-avx512'}</code> </p> </li>
    /// <li> <p> <code>mattr</code>: CPU flags. For example, <code>{'mattr': ['+neon', '+vfpv4']}</code> </p> </li>
    /// </ul>
    pub fn accelerator(&self) -> std::option::Option<&crate::model::TargetPlatformAccelerator> {
        self.accelerator.as_ref()
    }
}
/// See [`TargetPlatform`](crate::model::TargetPlatform).
pub mod target_platform {

    /// A builder for [`TargetPlatform`](crate::model::TargetPlatform).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) os: std::option::Option<crate::model::TargetPlatformOs>,
        pub(crate) arch: std::option::Option<crate::model::TargetPlatformArch>,
        pub(crate) accelerator: std::option::Option<crate::model::TargetPlatformAccelerator>,
    }
    impl Builder {
        /// <p>The target operating system for the model. Linux is the only operating system that is currently supported. </p>
        pub fn os(mut self, input: crate::model::TargetPlatformOs) -> Self {
            self.os = Some(input);
            self
        }
        /// <p>The target operating system for the model. Linux is the only operating system that is currently supported. </p>
        pub fn set_os(
            mut self,
            input: std::option::Option<crate::model::TargetPlatformOs>,
        ) -> Self {
            self.os = input;
            self
        }
        /// <p>The target architecture for the model. The currently supported architectures are X86_64 (64-bit version of the x86 instruction set) and ARM_64 (ARMv8 64-bit CPU). </p>
        pub fn arch(mut self, input: crate::model::TargetPlatformArch) -> Self {
            self.arch = Some(input);
            self
        }
        /// <p>The target architecture for the model. The currently supported architectures are X86_64 (64-bit version of the x86 instruction set) and ARM_64 (ARMv8 64-bit CPU). </p>
        pub fn set_arch(
            mut self,
            input: std::option::Option<crate::model::TargetPlatformArch>,
        ) -> Self {
            self.arch = input;
            self
        }
        /// <p>The target accelerator for the model. Currently, Amazon Lookout for Vision only supports NVIDIA (Nvidia graphics processing unit) and CPU accelerators. If you specify NVIDIA as an accelerator, you must also specify the <code>gpu-code</code>, <code>trt-ver</code>, and <code>cuda-ver</code> compiler options. If you don't specify an accelerator, Lookout for Vision uses the CPU for compilation and we highly recommend that you use the <code>GreengrassConfiguration$CompilerOptions</code> field. For example, you can use the following compiler options for CPU: </p>
        /// <ul>
        /// <li> <p> <code>mcpu</code>: CPU micro-architecture. For example, <code>{'mcpu': 'skylake-avx512'}</code> </p> </li>
        /// <li> <p> <code>mattr</code>: CPU flags. For example, <code>{'mattr': ['+neon', '+vfpv4']}</code> </p> </li>
        /// </ul>
        pub fn accelerator(mut self, input: crate::model::TargetPlatformAccelerator) -> Self {
            self.accelerator = Some(input);
            self
        }
        /// <p>The target accelerator for the model. Currently, Amazon Lookout for Vision only supports NVIDIA (Nvidia graphics processing unit) and CPU accelerators. If you specify NVIDIA as an accelerator, you must also specify the <code>gpu-code</code>, <code>trt-ver</code>, and <code>cuda-ver</code> compiler options. If you don't specify an accelerator, Lookout for Vision uses the CPU for compilation and we highly recommend that you use the <code>GreengrassConfiguration$CompilerOptions</code> field. For example, you can use the following compiler options for CPU: </p>
        /// <ul>
        /// <li> <p> <code>mcpu</code>: CPU micro-architecture. For example, <code>{'mcpu': 'skylake-avx512'}</code> </p> </li>
        /// <li> <p> <code>mattr</code>: CPU flags. For example, <code>{'mattr': ['+neon', '+vfpv4']}</code> </p> </li>
        /// </ul>
        pub fn set_accelerator(
            mut self,
            input: std::option::Option<crate::model::TargetPlatformAccelerator>,
        ) -> Self {
            self.accelerator = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetPlatform`](crate::model::TargetPlatform).
        pub fn build(self) -> crate::model::TargetPlatform {
            crate::model::TargetPlatform {
                os: self.os,
                arch: self.arch,
                accelerator: self.accelerator,
            }
        }
    }
}
impl TargetPlatform {
    /// Creates a new builder-style object to manufacture [`TargetPlatform`](crate::model::TargetPlatform).
    pub fn builder() -> crate::model::target_platform::Builder {
        crate::model::target_platform::Builder::default()
    }
}

/// When writing a match expression against `TargetPlatformAccelerator`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let targetplatformaccelerator = unimplemented!();
/// match targetplatformaccelerator {
///     TargetPlatformAccelerator::Nvidia => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `targetplatformaccelerator` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TargetPlatformAccelerator::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TargetPlatformAccelerator::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TargetPlatformAccelerator::NewFeature` is defined.
/// Specifically, when `targetplatformaccelerator` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TargetPlatformAccelerator::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TargetPlatformAccelerator {
    #[allow(missing_docs)] // documentation missing in model
    Nvidia,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TargetPlatformAccelerator {
    fn from(s: &str) -> Self {
        match s {
            "NVIDIA" => TargetPlatformAccelerator::Nvidia,
            other => TargetPlatformAccelerator::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for TargetPlatformAccelerator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TargetPlatformAccelerator::from(s))
    }
}
impl TargetPlatformAccelerator {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TargetPlatformAccelerator::Nvidia => "NVIDIA",
            TargetPlatformAccelerator::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["NVIDIA"]
    }
}
impl AsRef<str> for TargetPlatformAccelerator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TargetPlatformArch`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let targetplatformarch = unimplemented!();
/// match targetplatformarch {
///     TargetPlatformArch::Arm64 => { /* ... */ },
///     TargetPlatformArch::X8664 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `targetplatformarch` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TargetPlatformArch::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TargetPlatformArch::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TargetPlatformArch::NewFeature` is defined.
/// Specifically, when `targetplatformarch` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TargetPlatformArch::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TargetPlatformArch {
    #[allow(missing_docs)] // documentation missing in model
    Arm64,
    #[allow(missing_docs)] // documentation missing in model
    X8664,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TargetPlatformArch {
    fn from(s: &str) -> Self {
        match s {
            "ARM64" => TargetPlatformArch::Arm64,
            "X86_64" => TargetPlatformArch::X8664,
            other => {
                TargetPlatformArch::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for TargetPlatformArch {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TargetPlatformArch::from(s))
    }
}
impl TargetPlatformArch {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TargetPlatformArch::Arm64 => "ARM64",
            TargetPlatformArch::X8664 => "X86_64",
            TargetPlatformArch::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ARM64", "X86_64"]
    }
}
impl AsRef<str> for TargetPlatformArch {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TargetPlatformOs`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let targetplatformos = unimplemented!();
/// match targetplatformos {
///     TargetPlatformOs::Linux => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `targetplatformos` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TargetPlatformOs::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TargetPlatformOs::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TargetPlatformOs::NewFeature` is defined.
/// Specifically, when `targetplatformos` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TargetPlatformOs::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TargetPlatformOs {
    #[allow(missing_docs)] // documentation missing in model
    Linux,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TargetPlatformOs {
    fn from(s: &str) -> Self {
        match s {
            "LINUX" => TargetPlatformOs::Linux,
            other => TargetPlatformOs::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TargetPlatformOs {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TargetPlatformOs::from(s))
    }
}
impl TargetPlatformOs {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TargetPlatformOs::Linux => "LINUX",
            TargetPlatformOs::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LINUX"]
    }
}
impl AsRef<str> for TargetPlatformOs {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TargetDevice`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let targetdevice = unimplemented!();
/// match targetdevice {
///     TargetDevice::JetsonXavier => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `targetdevice` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TargetDevice::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TargetDevice::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TargetDevice::NewFeature` is defined.
/// Specifically, when `targetdevice` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TargetDevice::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TargetDevice {
    #[allow(missing_docs)] // documentation missing in model
    JetsonXavier,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TargetDevice {
    fn from(s: &str) -> Self {
        match s {
            "jetson_xavier" => TargetDevice::JetsonXavier,
            other => TargetDevice::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TargetDevice {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TargetDevice::from(s))
    }
}
impl TargetDevice {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TargetDevice::JetsonXavier => "jetson_xavier",
            TargetDevice::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["jetson_xavier"]
    }
}
impl AsRef<str> for TargetDevice {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Metadata about an Amazon Lookout for Vision project.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProjectMetadata {
    /// <p>The Amazon Resource Name (ARN) of the project.</p>
    #[doc(hidden)]
    pub project_arn: std::option::Option<std::string::String>,
    /// <p>The name of the project.</p>
    #[doc(hidden)]
    pub project_name: std::option::Option<std::string::String>,
    /// <p>The unix timestamp for the date and time that the project was created. </p>
    #[doc(hidden)]
    pub creation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl ProjectMetadata {
    /// <p>The Amazon Resource Name (ARN) of the project.</p>
    pub fn project_arn(&self) -> std::option::Option<&str> {
        self.project_arn.as_deref()
    }
    /// <p>The name of the project.</p>
    pub fn project_name(&self) -> std::option::Option<&str> {
        self.project_name.as_deref()
    }
    /// <p>The unix timestamp for the date and time that the project was created. </p>
    pub fn creation_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_timestamp.as_ref()
    }
}
/// See [`ProjectMetadata`](crate::model::ProjectMetadata).
pub mod project_metadata {

    /// A builder for [`ProjectMetadata`](crate::model::ProjectMetadata).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) project_arn: std::option::Option<std::string::String>,
        pub(crate) project_name: std::option::Option<std::string::String>,
        pub(crate) creation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the project.</p>
        pub fn project_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the project.</p>
        pub fn set_project_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_arn = input;
            self
        }
        /// <p>The name of the project.</p>
        pub fn project_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_name = Some(input.into());
            self
        }
        /// <p>The name of the project.</p>
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_name = input;
            self
        }
        /// <p>The unix timestamp for the date and time that the project was created. </p>
        pub fn creation_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_timestamp = Some(input);
            self
        }
        /// <p>The unix timestamp for the date and time that the project was created. </p>
        pub fn set_creation_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`ProjectMetadata`](crate::model::ProjectMetadata).
        pub fn build(self) -> crate::model::ProjectMetadata {
            crate::model::ProjectMetadata {
                project_arn: self.project_arn,
                project_name: self.project_name,
                creation_timestamp: self.creation_timestamp,
            }
        }
    }
}
impl ProjectMetadata {
    /// Creates a new builder-style object to manufacture [`ProjectMetadata`](crate::model::ProjectMetadata).
    pub fn builder() -> crate::model::project_metadata::Builder {
        crate::model::project_metadata::Builder::default()
    }
}

/// <p>Describes an Amazon Lookout for Vision model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ModelMetadata {
    /// <p>The unix timestamp for the date and time that the model was created. </p>
    #[doc(hidden)]
    pub creation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The version of the model.</p>
    #[doc(hidden)]
    pub model_version: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the model.</p>
    #[doc(hidden)]
    pub model_arn: std::option::Option<std::string::String>,
    /// <p>The description for the model.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The status of the model.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ModelStatus>,
    /// <p>The status message for the model.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
    /// <p>Performance metrics for the model. Not available until training has successfully completed.</p>
    #[doc(hidden)]
    pub performance: std::option::Option<crate::model::ModelPerformance>,
}
impl ModelMetadata {
    /// <p>The unix timestamp for the date and time that the model was created. </p>
    pub fn creation_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_timestamp.as_ref()
    }
    /// <p>The version of the model.</p>
    pub fn model_version(&self) -> std::option::Option<&str> {
        self.model_version.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the model.</p>
    pub fn model_arn(&self) -> std::option::Option<&str> {
        self.model_arn.as_deref()
    }
    /// <p>The description for the model.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The status of the model.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ModelStatus> {
        self.status.as_ref()
    }
    /// <p>The status message for the model.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>Performance metrics for the model. Not available until training has successfully completed.</p>
    pub fn performance(&self) -> std::option::Option<&crate::model::ModelPerformance> {
        self.performance.as_ref()
    }
}
/// See [`ModelMetadata`](crate::model::ModelMetadata).
pub mod model_metadata {

    /// A builder for [`ModelMetadata`](crate::model::ModelMetadata).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) creation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) model_version: std::option::Option<std::string::String>,
        pub(crate) model_arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ModelStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) performance: std::option::Option<crate::model::ModelPerformance>,
    }
    impl Builder {
        /// <p>The unix timestamp for the date and time that the model was created. </p>
        pub fn creation_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_timestamp = Some(input);
            self
        }
        /// <p>The unix timestamp for the date and time that the model was created. </p>
        pub fn set_creation_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_timestamp = input;
            self
        }
        /// <p>The version of the model.</p>
        pub fn model_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version = Some(input.into());
            self
        }
        /// <p>The version of the model.</p>
        pub fn set_model_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model.</p>
        pub fn model_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model.</p>
        pub fn set_model_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_arn = input;
            self
        }
        /// <p>The description for the model.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description for the model.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The status of the model.</p>
        pub fn status(mut self, input: crate::model::ModelStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the model.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::ModelStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>The status message for the model.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The status message for the model.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>Performance metrics for the model. Not available until training has successfully completed.</p>
        pub fn performance(mut self, input: crate::model::ModelPerformance) -> Self {
            self.performance = Some(input);
            self
        }
        /// <p>Performance metrics for the model. Not available until training has successfully completed.</p>
        pub fn set_performance(
            mut self,
            input: std::option::Option<crate::model::ModelPerformance>,
        ) -> Self {
            self.performance = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelMetadata`](crate::model::ModelMetadata).
        pub fn build(self) -> crate::model::ModelMetadata {
            crate::model::ModelMetadata {
                creation_timestamp: self.creation_timestamp,
                model_version: self.model_version,
                model_arn: self.model_arn,
                description: self.description,
                status: self.status,
                status_message: self.status_message,
                performance: self.performance,
            }
        }
    }
}
impl ModelMetadata {
    /// Creates a new builder-style object to manufacture [`ModelMetadata`](crate::model::ModelMetadata).
    pub fn builder() -> crate::model::model_metadata::Builder {
        crate::model::model_metadata::Builder::default()
    }
}

/// <p>Information about the evaluation performance of a trained model. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ModelPerformance {
    /// <p>The overall F1 score metric for the trained model.</p>
    #[doc(hidden)]
    pub f1_score: std::option::Option<f32>,
    /// <p>The overall recall metric value for the trained model. </p>
    #[doc(hidden)]
    pub recall: std::option::Option<f32>,
    /// <p>The overall precision metric value for the trained model.</p>
    #[doc(hidden)]
    pub precision: std::option::Option<f32>,
}
impl ModelPerformance {
    /// <p>The overall F1 score metric for the trained model.</p>
    pub fn f1_score(&self) -> std::option::Option<f32> {
        self.f1_score
    }
    /// <p>The overall recall metric value for the trained model. </p>
    pub fn recall(&self) -> std::option::Option<f32> {
        self.recall
    }
    /// <p>The overall precision metric value for the trained model.</p>
    pub fn precision(&self) -> std::option::Option<f32> {
        self.precision
    }
}
/// See [`ModelPerformance`](crate::model::ModelPerformance).
pub mod model_performance {

    /// A builder for [`ModelPerformance`](crate::model::ModelPerformance).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) f1_score: std::option::Option<f32>,
        pub(crate) recall: std::option::Option<f32>,
        pub(crate) precision: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>The overall F1 score metric for the trained model.</p>
        pub fn f1_score(mut self, input: f32) -> Self {
            self.f1_score = Some(input);
            self
        }
        /// <p>The overall F1 score metric for the trained model.</p>
        pub fn set_f1_score(mut self, input: std::option::Option<f32>) -> Self {
            self.f1_score = input;
            self
        }
        /// <p>The overall recall metric value for the trained model. </p>
        pub fn recall(mut self, input: f32) -> Self {
            self.recall = Some(input);
            self
        }
        /// <p>The overall recall metric value for the trained model. </p>
        pub fn set_recall(mut self, input: std::option::Option<f32>) -> Self {
            self.recall = input;
            self
        }
        /// <p>The overall precision metric value for the trained model.</p>
        pub fn precision(mut self, input: f32) -> Self {
            self.precision = Some(input);
            self
        }
        /// <p>The overall precision metric value for the trained model.</p>
        pub fn set_precision(mut self, input: std::option::Option<f32>) -> Self {
            self.precision = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelPerformance`](crate::model::ModelPerformance).
        pub fn build(self) -> crate::model::ModelPerformance {
            crate::model::ModelPerformance {
                f1_score: self.f1_score,
                recall: self.recall,
                precision: self.precision,
            }
        }
    }
}
impl ModelPerformance {
    /// Creates a new builder-style object to manufacture [`ModelPerformance`](crate::model::ModelPerformance).
    pub fn builder() -> crate::model::model_performance::Builder {
        crate::model::model_performance::Builder::default()
    }
}

/// When writing a match expression against `ModelStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let modelstatus = unimplemented!();
/// match modelstatus {
///     ModelStatus::Deleting => { /* ... */ },
///     ModelStatus::Hosted => { /* ... */ },
///     ModelStatus::HostingFailed => { /* ... */ },
///     ModelStatus::StartingHosting => { /* ... */ },
///     ModelStatus::StoppingHosting => { /* ... */ },
///     ModelStatus::SystemUpdating => { /* ... */ },
///     ModelStatus::Trained => { /* ... */ },
///     ModelStatus::Training => { /* ... */ },
///     ModelStatus::TrainingFailed => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `modelstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ModelStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ModelStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ModelStatus::NewFeature` is defined.
/// Specifically, when `modelstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ModelStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelStatus {
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Hosted,
    #[allow(missing_docs)] // documentation missing in model
    HostingFailed,
    #[allow(missing_docs)] // documentation missing in model
    StartingHosting,
    #[allow(missing_docs)] // documentation missing in model
    StoppingHosting,
    #[allow(missing_docs)] // documentation missing in model
    SystemUpdating,
    #[allow(missing_docs)] // documentation missing in model
    Trained,
    #[allow(missing_docs)] // documentation missing in model
    Training,
    #[allow(missing_docs)] // documentation missing in model
    TrainingFailed,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ModelStatus {
    fn from(s: &str) -> Self {
        match s {
            "DELETING" => ModelStatus::Deleting,
            "HOSTED" => ModelStatus::Hosted,
            "HOSTING_FAILED" => ModelStatus::HostingFailed,
            "STARTING_HOSTING" => ModelStatus::StartingHosting,
            "STOPPING_HOSTING" => ModelStatus::StoppingHosting,
            "SYSTEM_UPDATING" => ModelStatus::SystemUpdating,
            "TRAINED" => ModelStatus::Trained,
            "TRAINING" => ModelStatus::Training,
            "TRAINING_FAILED" => ModelStatus::TrainingFailed,
            other => ModelStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ModelStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelStatus::from(s))
    }
}
impl ModelStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ModelStatus::Deleting => "DELETING",
            ModelStatus::Hosted => "HOSTED",
            ModelStatus::HostingFailed => "HOSTING_FAILED",
            ModelStatus::StartingHosting => "STARTING_HOSTING",
            ModelStatus::StoppingHosting => "STOPPING_HOSTING",
            ModelStatus::SystemUpdating => "SYSTEM_UPDATING",
            ModelStatus::Trained => "TRAINED",
            ModelStatus::Training => "TRAINING",
            ModelStatus::TrainingFailed => "TRAINING_FAILED",
            ModelStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DELETING",
            "HOSTED",
            "HOSTING_FAILED",
            "STARTING_HOSTING",
            "STOPPING_HOSTING",
            "SYSTEM_UPDATING",
            "TRAINED",
            "TRAINING",
            "TRAINING_FAILED",
        ]
    }
}
impl AsRef<str> for ModelStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Metadata for a model packaging job. For more information, see <code>ListModelPackagingJobs</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ModelPackagingJobMetadata {
    /// <p> The name of the model packaging job. </p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p> The project that contains the model that is in the model package. </p>
    #[doc(hidden)]
    pub project_name: std::option::Option<std::string::String>,
    /// <p> The version of the model that is in the model package. </p>
    #[doc(hidden)]
    pub model_version: std::option::Option<std::string::String>,
    /// <p> The description for the model packaging job. </p>
    #[doc(hidden)]
    pub model_packaging_job_description: std::option::Option<std::string::String>,
    /// <p> The AWS service used to package the job. Currently Lookout for Vision can package jobs with AWS IoT Greengrass. </p>
    #[doc(hidden)]
    pub model_packaging_method: std::option::Option<std::string::String>,
    /// <p>The status of the model packaging job. </p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ModelPackagingJobStatus>,
    /// <p>The status message for the model packaging job. </p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The Unix timestamp for the time and date that the model packaging job was created.</p>
    #[doc(hidden)]
    pub creation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The Unix timestamp for the time and date that the model packaging job was last updated.</p>
    #[doc(hidden)]
    pub last_updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl ModelPackagingJobMetadata {
    /// <p> The name of the model packaging job. </p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p> The project that contains the model that is in the model package. </p>
    pub fn project_name(&self) -> std::option::Option<&str> {
        self.project_name.as_deref()
    }
    /// <p> The version of the model that is in the model package. </p>
    pub fn model_version(&self) -> std::option::Option<&str> {
        self.model_version.as_deref()
    }
    /// <p> The description for the model packaging job. </p>
    pub fn model_packaging_job_description(&self) -> std::option::Option<&str> {
        self.model_packaging_job_description.as_deref()
    }
    /// <p> The AWS service used to package the job. Currently Lookout for Vision can package jobs with AWS IoT Greengrass. </p>
    pub fn model_packaging_method(&self) -> std::option::Option<&str> {
        self.model_packaging_method.as_deref()
    }
    /// <p>The status of the model packaging job. </p>
    pub fn status(&self) -> std::option::Option<&crate::model::ModelPackagingJobStatus> {
        self.status.as_ref()
    }
    /// <p>The status message for the model packaging job. </p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>The Unix timestamp for the time and date that the model packaging job was created.</p>
    pub fn creation_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_timestamp.as_ref()
    }
    /// <p>The Unix timestamp for the time and date that the model packaging job was last updated.</p>
    pub fn last_updated_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_timestamp.as_ref()
    }
}
/// See [`ModelPackagingJobMetadata`](crate::model::ModelPackagingJobMetadata).
pub mod model_packaging_job_metadata {

    /// A builder for [`ModelPackagingJobMetadata`](crate::model::ModelPackagingJobMetadata).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) project_name: std::option::Option<std::string::String>,
        pub(crate) model_version: std::option::Option<std::string::String>,
        pub(crate) model_packaging_job_description: std::option::Option<std::string::String>,
        pub(crate) model_packaging_method: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ModelPackagingJobStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) creation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p> The name of the model packaging job. </p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p> The name of the model packaging job. </p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p> The project that contains the model that is in the model package. </p>
        pub fn project_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_name = Some(input.into());
            self
        }
        /// <p> The project that contains the model that is in the model package. </p>
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_name = input;
            self
        }
        /// <p> The version of the model that is in the model package. </p>
        pub fn model_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version = Some(input.into());
            self
        }
        /// <p> The version of the model that is in the model package. </p>
        pub fn set_model_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// <p> The description for the model packaging job. </p>
        pub fn model_packaging_job_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.model_packaging_job_description = Some(input.into());
            self
        }
        /// <p> The description for the model packaging job. </p>
        pub fn set_model_packaging_job_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_packaging_job_description = input;
            self
        }
        /// <p> The AWS service used to package the job. Currently Lookout for Vision can package jobs with AWS IoT Greengrass. </p>
        pub fn model_packaging_method(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_packaging_method = Some(input.into());
            self
        }
        /// <p> The AWS service used to package the job. Currently Lookout for Vision can package jobs with AWS IoT Greengrass. </p>
        pub fn set_model_packaging_method(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_packaging_method = input;
            self
        }
        /// <p>The status of the model packaging job. </p>
        pub fn status(mut self, input: crate::model::ModelPackagingJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the model packaging job. </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ModelPackagingJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The status message for the model packaging job. </p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The status message for the model packaging job. </p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The Unix timestamp for the time and date that the model packaging job was created.</p>
        pub fn creation_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_timestamp = Some(input);
            self
        }
        /// <p>The Unix timestamp for the time and date that the model packaging job was created.</p>
        pub fn set_creation_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_timestamp = input;
            self
        }
        /// <p>The Unix timestamp for the time and date that the model packaging job was last updated.</p>
        pub fn last_updated_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_timestamp = Some(input);
            self
        }
        /// <p>The Unix timestamp for the time and date that the model packaging job was last updated.</p>
        pub fn set_last_updated_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelPackagingJobMetadata`](crate::model::ModelPackagingJobMetadata).
        pub fn build(self) -> crate::model::ModelPackagingJobMetadata {
            crate::model::ModelPackagingJobMetadata {
                job_name: self.job_name,
                project_name: self.project_name,
                model_version: self.model_version,
                model_packaging_job_description: self.model_packaging_job_description,
                model_packaging_method: self.model_packaging_method,
                status: self.status,
                status_message: self.status_message,
                creation_timestamp: self.creation_timestamp,
                last_updated_timestamp: self.last_updated_timestamp,
            }
        }
    }
}
impl ModelPackagingJobMetadata {
    /// Creates a new builder-style object to manufacture [`ModelPackagingJobMetadata`](crate::model::ModelPackagingJobMetadata).
    pub fn builder() -> crate::model::model_packaging_job_metadata::Builder {
        crate::model::model_packaging_job_metadata::Builder::default()
    }
}

/// When writing a match expression against `ModelPackagingJobStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let modelpackagingjobstatus = unimplemented!();
/// match modelpackagingjobstatus {
///     ModelPackagingJobStatus::Created => { /* ... */ },
///     ModelPackagingJobStatus::Failed => { /* ... */ },
///     ModelPackagingJobStatus::Running => { /* ... */ },
///     ModelPackagingJobStatus::Succeeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `modelpackagingjobstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ModelPackagingJobStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ModelPackagingJobStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ModelPackagingJobStatus::NewFeature` is defined.
/// Specifically, when `modelpackagingjobstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ModelPackagingJobStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelPackagingJobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Created,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ModelPackagingJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "CREATED" => ModelPackagingJobStatus::Created,
            "FAILED" => ModelPackagingJobStatus::Failed,
            "RUNNING" => ModelPackagingJobStatus::Running,
            "SUCCEEDED" => ModelPackagingJobStatus::Succeeded,
            other => ModelPackagingJobStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ModelPackagingJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelPackagingJobStatus::from(s))
    }
}
impl ModelPackagingJobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ModelPackagingJobStatus::Created => "CREATED",
            ModelPackagingJobStatus::Failed => "FAILED",
            ModelPackagingJobStatus::Running => "RUNNING",
            ModelPackagingJobStatus::Succeeded => "SUCCEEDED",
            ModelPackagingJobStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CREATED", "FAILED", "RUNNING", "SUCCEEDED"]
    }
}
impl AsRef<str> for ModelPackagingJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The prediction results from a call to <code>DetectAnomalies</code>. <code>DetectAnomalyResult</code> includes classification information for the prediction (<code>IsAnomalous</code> and <code>Confidence</code>). If the model you use is an image segementation model, <code>DetectAnomalyResult</code> also includes segmentation information (<code>Anomalies</code> and <code>AnomalyMask</code>). Classification information is calculated separately from segmentation information and you shouldn't assume a relationship between them.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DetectAnomalyResult {
    /// <p>The source of the image that was analyzed. <code>direct</code> means that the images was supplied from the local computer. No other values are supported.</p>
    #[doc(hidden)]
    pub source: std::option::Option<crate::model::ImageSource>,
    /// <p>True if Amazon Lookout for Vision classifies the image as containing an anomaly, otherwise false.</p>
    #[doc(hidden)]
    pub is_anomalous: bool,
    /// <p>The confidence that Lookout for Vision has in the accuracy of the classification in <code>IsAnomalous</code>.</p>
    #[doc(hidden)]
    pub confidence: std::option::Option<f32>,
    /// <p>If the model is an image segmentation model, <code>Anomalies</code> contains a list of anomaly types found in the image. There is one entry for each type of anomaly found (even if multiple instances of an anomaly type exist on the image). The first element in the list is always an anomaly type representing the image background ('background') and shouldn't be considered an anomaly. Amazon Lookout for Vision automatically add the background anomaly type to the response, and you don't need to declare a background anomaly type in your dataset.</p>
    /// <p>If the list has one entry ('background'), no anomalies were found on the image.</p>
    /// <p></p>
    /// <p>An image classification model doesn't return an <code>Anomalies</code> list. </p>
    #[doc(hidden)]
    pub anomalies: std::option::Option<std::vec::Vec<crate::model::Anomaly>>,
    /// <p>If the model is an image segmentation model, <code>AnomalyMask</code> contains pixel masks that covers all anomaly types found on the image. Each anomaly type has a different mask color. To map a color to an anomaly type, see the <code>color</code> field of the <code>PixelAnomaly</code> object.</p>
    /// <p>An image classification model doesn't return an <code>Anomalies</code> list. </p>
    #[doc(hidden)]
    pub anomaly_mask: std::option::Option<aws_smithy_types::Blob>,
}
impl DetectAnomalyResult {
    /// <p>The source of the image that was analyzed. <code>direct</code> means that the images was supplied from the local computer. No other values are supported.</p>
    pub fn source(&self) -> std::option::Option<&crate::model::ImageSource> {
        self.source.as_ref()
    }
    /// <p>True if Amazon Lookout for Vision classifies the image as containing an anomaly, otherwise false.</p>
    pub fn is_anomalous(&self) -> bool {
        self.is_anomalous
    }
    /// <p>The confidence that Lookout for Vision has in the accuracy of the classification in <code>IsAnomalous</code>.</p>
    pub fn confidence(&self) -> std::option::Option<f32> {
        self.confidence
    }
    /// <p>If the model is an image segmentation model, <code>Anomalies</code> contains a list of anomaly types found in the image. There is one entry for each type of anomaly found (even if multiple instances of an anomaly type exist on the image). The first element in the list is always an anomaly type representing the image background ('background') and shouldn't be considered an anomaly. Amazon Lookout for Vision automatically add the background anomaly type to the response, and you don't need to declare a background anomaly type in your dataset.</p>
    /// <p>If the list has one entry ('background'), no anomalies were found on the image.</p>
    /// <p></p>
    /// <p>An image classification model doesn't return an <code>Anomalies</code> list. </p>
    pub fn anomalies(&self) -> std::option::Option<&[crate::model::Anomaly]> {
        self.anomalies.as_deref()
    }
    /// <p>If the model is an image segmentation model, <code>AnomalyMask</code> contains pixel masks that covers all anomaly types found on the image. Each anomaly type has a different mask color. To map a color to an anomaly type, see the <code>color</code> field of the <code>PixelAnomaly</code> object.</p>
    /// <p>An image classification model doesn't return an <code>Anomalies</code> list. </p>
    pub fn anomaly_mask(&self) -> std::option::Option<&aws_smithy_types::Blob> {
        self.anomaly_mask.as_ref()
    }
}
/// See [`DetectAnomalyResult`](crate::model::DetectAnomalyResult).
pub mod detect_anomaly_result {

    /// A builder for [`DetectAnomalyResult`](crate::model::DetectAnomalyResult).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source: std::option::Option<crate::model::ImageSource>,
        pub(crate) is_anomalous: std::option::Option<bool>,
        pub(crate) confidence: std::option::Option<f32>,
        pub(crate) anomalies: std::option::Option<std::vec::Vec<crate::model::Anomaly>>,
        pub(crate) anomaly_mask: std::option::Option<aws_smithy_types::Blob>,
    }
    impl Builder {
        /// <p>The source of the image that was analyzed. <code>direct</code> means that the images was supplied from the local computer. No other values are supported.</p>
        pub fn source(mut self, input: crate::model::ImageSource) -> Self {
            self.source = Some(input);
            self
        }
        /// <p>The source of the image that was analyzed. <code>direct</code> means that the images was supplied from the local computer. No other values are supported.</p>
        pub fn set_source(mut self, input: std::option::Option<crate::model::ImageSource>) -> Self {
            self.source = input;
            self
        }
        /// <p>True if Amazon Lookout for Vision classifies the image as containing an anomaly, otherwise false.</p>
        pub fn is_anomalous(mut self, input: bool) -> Self {
            self.is_anomalous = Some(input);
            self
        }
        /// <p>True if Amazon Lookout for Vision classifies the image as containing an anomaly, otherwise false.</p>
        pub fn set_is_anomalous(mut self, input: std::option::Option<bool>) -> Self {
            self.is_anomalous = input;
            self
        }
        /// <p>The confidence that Lookout for Vision has in the accuracy of the classification in <code>IsAnomalous</code>.</p>
        pub fn confidence(mut self, input: f32) -> Self {
            self.confidence = Some(input);
            self
        }
        /// <p>The confidence that Lookout for Vision has in the accuracy of the classification in <code>IsAnomalous</code>.</p>
        pub fn set_confidence(mut self, input: std::option::Option<f32>) -> Self {
            self.confidence = input;
            self
        }
        /// Appends an item to `anomalies`.
        ///
        /// To override the contents of this collection use [`set_anomalies`](Self::set_anomalies).
        ///
        /// <p>If the model is an image segmentation model, <code>Anomalies</code> contains a list of anomaly types found in the image. There is one entry for each type of anomaly found (even if multiple instances of an anomaly type exist on the image). The first element in the list is always an anomaly type representing the image background ('background') and shouldn't be considered an anomaly. Amazon Lookout for Vision automatically add the background anomaly type to the response, and you don't need to declare a background anomaly type in your dataset.</p>
        /// <p>If the list has one entry ('background'), no anomalies were found on the image.</p>
        /// <p></p>
        /// <p>An image classification model doesn't return an <code>Anomalies</code> list. </p>
        pub fn anomalies(mut self, input: crate::model::Anomaly) -> Self {
            let mut v = self.anomalies.unwrap_or_default();
            v.push(input);
            self.anomalies = Some(v);
            self
        }
        /// <p>If the model is an image segmentation model, <code>Anomalies</code> contains a list of anomaly types found in the image. There is one entry for each type of anomaly found (even if multiple instances of an anomaly type exist on the image). The first element in the list is always an anomaly type representing the image background ('background') and shouldn't be considered an anomaly. Amazon Lookout for Vision automatically add the background anomaly type to the response, and you don't need to declare a background anomaly type in your dataset.</p>
        /// <p>If the list has one entry ('background'), no anomalies were found on the image.</p>
        /// <p></p>
        /// <p>An image classification model doesn't return an <code>Anomalies</code> list. </p>
        pub fn set_anomalies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Anomaly>>,
        ) -> Self {
            self.anomalies = input;
            self
        }
        /// <p>If the model is an image segmentation model, <code>AnomalyMask</code> contains pixel masks that covers all anomaly types found on the image. Each anomaly type has a different mask color. To map a color to an anomaly type, see the <code>color</code> field of the <code>PixelAnomaly</code> object.</p>
        /// <p>An image classification model doesn't return an <code>Anomalies</code> list. </p>
        pub fn anomaly_mask(mut self, input: aws_smithy_types::Blob) -> Self {
            self.anomaly_mask = Some(input);
            self
        }
        /// <p>If the model is an image segmentation model, <code>AnomalyMask</code> contains pixel masks that covers all anomaly types found on the image. Each anomaly type has a different mask color. To map a color to an anomaly type, see the <code>color</code> field of the <code>PixelAnomaly</code> object.</p>
        /// <p>An image classification model doesn't return an <code>Anomalies</code> list. </p>
        pub fn set_anomaly_mask(
            mut self,
            input: std::option::Option<aws_smithy_types::Blob>,
        ) -> Self {
            self.anomaly_mask = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectAnomalyResult`](crate::model::DetectAnomalyResult).
        pub fn build(self) -> crate::model::DetectAnomalyResult {
            crate::model::DetectAnomalyResult {
                source: self.source,
                is_anomalous: self.is_anomalous.unwrap_or_default(),
                confidence: self.confidence,
                anomalies: self.anomalies,
                anomaly_mask: self.anomaly_mask,
            }
        }
    }
}
impl DetectAnomalyResult {
    /// Creates a new builder-style object to manufacture [`DetectAnomalyResult`](crate::model::DetectAnomalyResult).
    pub fn builder() -> crate::model::detect_anomaly_result::Builder {
        crate::model::detect_anomaly_result::Builder::default()
    }
}

/// <p>Information about an anomaly type found on an image by an image segmentation model. For more information, see <code>DetectAnomalies</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Anomaly {
    /// <p>The name of an anomaly type found in an image. <code>Name</code> maps to an anomaly type in the training dataset, apart from the anomaly type <code>background</code>. The service automatically inserts the <code>background</code> anomaly type into the response from <code>DetectAnomalies</code>. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Information about the pixel mask that covers an anomaly type.</p>
    #[doc(hidden)]
    pub pixel_anomaly: std::option::Option<crate::model::PixelAnomaly>,
}
impl Anomaly {
    /// <p>The name of an anomaly type found in an image. <code>Name</code> maps to an anomaly type in the training dataset, apart from the anomaly type <code>background</code>. The service automatically inserts the <code>background</code> anomaly type into the response from <code>DetectAnomalies</code>. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Information about the pixel mask that covers an anomaly type.</p>
    pub fn pixel_anomaly(&self) -> std::option::Option<&crate::model::PixelAnomaly> {
        self.pixel_anomaly.as_ref()
    }
}
/// See [`Anomaly`](crate::model::Anomaly).
pub mod anomaly {

    /// A builder for [`Anomaly`](crate::model::Anomaly).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) pixel_anomaly: std::option::Option<crate::model::PixelAnomaly>,
    }
    impl Builder {
        /// <p>The name of an anomaly type found in an image. <code>Name</code> maps to an anomaly type in the training dataset, apart from the anomaly type <code>background</code>. The service automatically inserts the <code>background</code> anomaly type into the response from <code>DetectAnomalies</code>. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of an anomaly type found in an image. <code>Name</code> maps to an anomaly type in the training dataset, apart from the anomaly type <code>background</code>. The service automatically inserts the <code>background</code> anomaly type into the response from <code>DetectAnomalies</code>. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Information about the pixel mask that covers an anomaly type.</p>
        pub fn pixel_anomaly(mut self, input: crate::model::PixelAnomaly) -> Self {
            self.pixel_anomaly = Some(input);
            self
        }
        /// <p>Information about the pixel mask that covers an anomaly type.</p>
        pub fn set_pixel_anomaly(
            mut self,
            input: std::option::Option<crate::model::PixelAnomaly>,
        ) -> Self {
            self.pixel_anomaly = input;
            self
        }
        /// Consumes the builder and constructs a [`Anomaly`](crate::model::Anomaly).
        pub fn build(self) -> crate::model::Anomaly {
            crate::model::Anomaly {
                name: self.name,
                pixel_anomaly: self.pixel_anomaly,
            }
        }
    }
}
impl Anomaly {
    /// Creates a new builder-style object to manufacture [`Anomaly`](crate::model::Anomaly).
    pub fn builder() -> crate::model::anomaly::Builder {
        crate::model::anomaly::Builder::default()
    }
}

/// <p>Information about the pixels in an anomaly mask. For more information, see <code>Anomaly</code>. <code>PixelAnomaly</code> is only returned by image segmentation models.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PixelAnomaly {
    /// <p>The percentage area of the image that the anomaly type covers.</p>
    #[doc(hidden)]
    pub total_percentage_area: std::option::Option<f32>,
    /// <p>A hex color value for the mask that covers an anomaly type. Each anomaly type has a different mask color. The color maps to the color of the anomaly type used in the training dataset. </p>
    #[doc(hidden)]
    pub color: std::option::Option<std::string::String>,
}
impl PixelAnomaly {
    /// <p>The percentage area of the image that the anomaly type covers.</p>
    pub fn total_percentage_area(&self) -> std::option::Option<f32> {
        self.total_percentage_area
    }
    /// <p>A hex color value for the mask that covers an anomaly type. Each anomaly type has a different mask color. The color maps to the color of the anomaly type used in the training dataset. </p>
    pub fn color(&self) -> std::option::Option<&str> {
        self.color.as_deref()
    }
}
/// See [`PixelAnomaly`](crate::model::PixelAnomaly).
pub mod pixel_anomaly {

    /// A builder for [`PixelAnomaly`](crate::model::PixelAnomaly).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) total_percentage_area: std::option::Option<f32>,
        pub(crate) color: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The percentage area of the image that the anomaly type covers.</p>
        pub fn total_percentage_area(mut self, input: f32) -> Self {
            self.total_percentage_area = Some(input);
            self
        }
        /// <p>The percentage area of the image that the anomaly type covers.</p>
        pub fn set_total_percentage_area(mut self, input: std::option::Option<f32>) -> Self {
            self.total_percentage_area = input;
            self
        }
        /// <p>A hex color value for the mask that covers an anomaly type. Each anomaly type has a different mask color. The color maps to the color of the anomaly type used in the training dataset. </p>
        pub fn color(mut self, input: impl Into<std::string::String>) -> Self {
            self.color = Some(input.into());
            self
        }
        /// <p>A hex color value for the mask that covers an anomaly type. Each anomaly type has a different mask color. The color maps to the color of the anomaly type used in the training dataset. </p>
        pub fn set_color(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.color = input;
            self
        }
        /// Consumes the builder and constructs a [`PixelAnomaly`](crate::model::PixelAnomaly).
        pub fn build(self) -> crate::model::PixelAnomaly {
            crate::model::PixelAnomaly {
                total_percentage_area: self.total_percentage_area,
                color: self.color,
            }
        }
    }
}
impl PixelAnomaly {
    /// Creates a new builder-style object to manufacture [`PixelAnomaly`](crate::model::PixelAnomaly).
    pub fn builder() -> crate::model::pixel_anomaly::Builder {
        crate::model::pixel_anomaly::Builder::default()
    }
}

/// <p>The source for an image.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImageSource {
    /// <p>The type of the image.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
}
impl ImageSource {
    /// <p>The type of the image.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
/// See [`ImageSource`](crate::model::ImageSource).
pub mod image_source {

    /// A builder for [`ImageSource`](crate::model::ImageSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of the image.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of the image.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`ImageSource`](crate::model::ImageSource).
        pub fn build(self) -> crate::model::ImageSource {
            crate::model::ImageSource {
                r#type: self.r#type,
            }
        }
    }
}
impl ImageSource {
    /// Creates a new builder-style object to manufacture [`ImageSource`](crate::model::ImageSource).
    pub fn builder() -> crate::model::image_source::Builder {
        crate::model::image_source::Builder::default()
    }
}

/// <p>Describe an Amazon Lookout for Vision project. For more information, see <code>DescribeProject</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProjectDescription {
    /// <p>The Amazon Resource Name (ARN) of the project.</p>
    #[doc(hidden)]
    pub project_arn: std::option::Option<std::string::String>,
    /// <p>The name of the project.</p>
    #[doc(hidden)]
    pub project_name: std::option::Option<std::string::String>,
    /// <p>The unix timestamp for the date and time that the project was created. </p>
    #[doc(hidden)]
    pub creation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A list of datasets in the project.</p>
    #[doc(hidden)]
    pub datasets: std::option::Option<std::vec::Vec<crate::model::DatasetMetadata>>,
}
impl ProjectDescription {
    /// <p>The Amazon Resource Name (ARN) of the project.</p>
    pub fn project_arn(&self) -> std::option::Option<&str> {
        self.project_arn.as_deref()
    }
    /// <p>The name of the project.</p>
    pub fn project_name(&self) -> std::option::Option<&str> {
        self.project_name.as_deref()
    }
    /// <p>The unix timestamp for the date and time that the project was created. </p>
    pub fn creation_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_timestamp.as_ref()
    }
    /// <p>A list of datasets in the project.</p>
    pub fn datasets(&self) -> std::option::Option<&[crate::model::DatasetMetadata]> {
        self.datasets.as_deref()
    }
}
/// See [`ProjectDescription`](crate::model::ProjectDescription).
pub mod project_description {

    /// A builder for [`ProjectDescription`](crate::model::ProjectDescription).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) project_arn: std::option::Option<std::string::String>,
        pub(crate) project_name: std::option::Option<std::string::String>,
        pub(crate) creation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) datasets: std::option::Option<std::vec::Vec<crate::model::DatasetMetadata>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the project.</p>
        pub fn project_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the project.</p>
        pub fn set_project_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_arn = input;
            self
        }
        /// <p>The name of the project.</p>
        pub fn project_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_name = Some(input.into());
            self
        }
        /// <p>The name of the project.</p>
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_name = input;
            self
        }
        /// <p>The unix timestamp for the date and time that the project was created. </p>
        pub fn creation_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_timestamp = Some(input);
            self
        }
        /// <p>The unix timestamp for the date and time that the project was created. </p>
        pub fn set_creation_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_timestamp = input;
            self
        }
        /// Appends an item to `datasets`.
        ///
        /// To override the contents of this collection use [`set_datasets`](Self::set_datasets).
        ///
        /// <p>A list of datasets in the project.</p>
        pub fn datasets(mut self, input: crate::model::DatasetMetadata) -> Self {
            let mut v = self.datasets.unwrap_or_default();
            v.push(input);
            self.datasets = Some(v);
            self
        }
        /// <p>A list of datasets in the project.</p>
        pub fn set_datasets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DatasetMetadata>>,
        ) -> Self {
            self.datasets = input;
            self
        }
        /// Consumes the builder and constructs a [`ProjectDescription`](crate::model::ProjectDescription).
        pub fn build(self) -> crate::model::ProjectDescription {
            crate::model::ProjectDescription {
                project_arn: self.project_arn,
                project_name: self.project_name,
                creation_timestamp: self.creation_timestamp,
                datasets: self.datasets,
            }
        }
    }
}
impl ProjectDescription {
    /// Creates a new builder-style object to manufacture [`ProjectDescription`](crate::model::ProjectDescription).
    pub fn builder() -> crate::model::project_description::Builder {
        crate::model::project_description::Builder::default()
    }
}

/// <p>Summary information for an Amazon Lookout for Vision dataset. For more information, see <code>DescribeDataset</code> and <code>ProjectDescription</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DatasetMetadata {
    /// <p>The type of the dataset.</p>
    #[doc(hidden)]
    pub dataset_type: std::option::Option<std::string::String>,
    /// <p>The Unix timestamp for the date and time that the dataset was created. </p>
    #[doc(hidden)]
    pub creation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status for the dataset.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::DatasetStatus>,
    /// <p>The status message for the dataset.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
}
impl DatasetMetadata {
    /// <p>The type of the dataset.</p>
    pub fn dataset_type(&self) -> std::option::Option<&str> {
        self.dataset_type.as_deref()
    }
    /// <p>The Unix timestamp for the date and time that the dataset was created. </p>
    pub fn creation_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_timestamp.as_ref()
    }
    /// <p>The status for the dataset.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::DatasetStatus> {
        self.status.as_ref()
    }
    /// <p>The status message for the dataset.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
}
/// See [`DatasetMetadata`](crate::model::DatasetMetadata).
pub mod dataset_metadata {

    /// A builder for [`DatasetMetadata`](crate::model::DatasetMetadata).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dataset_type: std::option::Option<std::string::String>,
        pub(crate) creation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status: std::option::Option<crate::model::DatasetStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of the dataset.</p>
        pub fn dataset_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.dataset_type = Some(input.into());
            self
        }
        /// <p>The type of the dataset.</p>
        pub fn set_dataset_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dataset_type = input;
            self
        }
        /// <p>The Unix timestamp for the date and time that the dataset was created. </p>
        pub fn creation_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_timestamp = Some(input);
            self
        }
        /// <p>The Unix timestamp for the date and time that the dataset was created. </p>
        pub fn set_creation_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_timestamp = input;
            self
        }
        /// <p>The status for the dataset.</p>
        pub fn status(mut self, input: crate::model::DatasetStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status for the dataset.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::DatasetStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The status message for the dataset.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The status message for the dataset.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// Consumes the builder and constructs a [`DatasetMetadata`](crate::model::DatasetMetadata).
        pub fn build(self) -> crate::model::DatasetMetadata {
            crate::model::DatasetMetadata {
                dataset_type: self.dataset_type,
                creation_timestamp: self.creation_timestamp,
                status: self.status,
                status_message: self.status_message,
            }
        }
    }
}
impl DatasetMetadata {
    /// Creates a new builder-style object to manufacture [`DatasetMetadata`](crate::model::DatasetMetadata).
    pub fn builder() -> crate::model::dataset_metadata::Builder {
        crate::model::dataset_metadata::Builder::default()
    }
}

/// <p> Information about a model packaging job. For more information, see <code>DescribeModelPackagingJob</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ModelPackagingDescription {
    /// <p> The name of the model packaging job. </p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The name of the project that's associated with a model that's in the model package. </p>
    #[doc(hidden)]
    pub project_name: std::option::Option<std::string::String>,
    /// <p>The version of the model used in the model packaging job. </p>
    #[doc(hidden)]
    pub model_version: std::option::Option<std::string::String>,
    /// <p> The configuration information used in the model packaging job. </p>
    #[doc(hidden)]
    pub model_packaging_configuration:
        std::option::Option<crate::model::ModelPackagingConfiguration>,
    /// <p>The description for the model packaging job. </p>
    #[doc(hidden)]
    pub model_packaging_job_description: std::option::Option<std::string::String>,
    /// <p>The AWS service used to package the job. Currently Lookout for Vision can package jobs with AWS IoT Greengrass. </p>
    #[doc(hidden)]
    pub model_packaging_method: std::option::Option<std::string::String>,
    /// <p>Information about the output of the model packaging job. For more information, see <code>DescribeModelPackagingJob</code>. </p>
    #[doc(hidden)]
    pub model_packaging_output_details:
        std::option::Option<crate::model::ModelPackagingOutputDetails>,
    /// <p> The status of the model packaging job. </p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ModelPackagingJobStatus>,
    /// <p> The status message for the model packaging job. </p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
    /// <p> The Unix timestamp for the time and date that the model packaging job was created. </p>
    #[doc(hidden)]
    pub creation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p> The Unix timestamp for the time and date that the model packaging job was last updated. </p>
    #[doc(hidden)]
    pub last_updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl ModelPackagingDescription {
    /// <p> The name of the model packaging job. </p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The name of the project that's associated with a model that's in the model package. </p>
    pub fn project_name(&self) -> std::option::Option<&str> {
        self.project_name.as_deref()
    }
    /// <p>The version of the model used in the model packaging job. </p>
    pub fn model_version(&self) -> std::option::Option<&str> {
        self.model_version.as_deref()
    }
    /// <p> The configuration information used in the model packaging job. </p>
    pub fn model_packaging_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ModelPackagingConfiguration> {
        self.model_packaging_configuration.as_ref()
    }
    /// <p>The description for the model packaging job. </p>
    pub fn model_packaging_job_description(&self) -> std::option::Option<&str> {
        self.model_packaging_job_description.as_deref()
    }
    /// <p>The AWS service used to package the job. Currently Lookout for Vision can package jobs with AWS IoT Greengrass. </p>
    pub fn model_packaging_method(&self) -> std::option::Option<&str> {
        self.model_packaging_method.as_deref()
    }
    /// <p>Information about the output of the model packaging job. For more information, see <code>DescribeModelPackagingJob</code>. </p>
    pub fn model_packaging_output_details(
        &self,
    ) -> std::option::Option<&crate::model::ModelPackagingOutputDetails> {
        self.model_packaging_output_details.as_ref()
    }
    /// <p> The status of the model packaging job. </p>
    pub fn status(&self) -> std::option::Option<&crate::model::ModelPackagingJobStatus> {
        self.status.as_ref()
    }
    /// <p> The status message for the model packaging job. </p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p> The Unix timestamp for the time and date that the model packaging job was created. </p>
    pub fn creation_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_timestamp.as_ref()
    }
    /// <p> The Unix timestamp for the time and date that the model packaging job was last updated. </p>
    pub fn last_updated_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_timestamp.as_ref()
    }
}
/// See [`ModelPackagingDescription`](crate::model::ModelPackagingDescription).
pub mod model_packaging_description {

    /// A builder for [`ModelPackagingDescription`](crate::model::ModelPackagingDescription).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) project_name: std::option::Option<std::string::String>,
        pub(crate) model_version: std::option::Option<std::string::String>,
        pub(crate) model_packaging_configuration:
            std::option::Option<crate::model::ModelPackagingConfiguration>,
        pub(crate) model_packaging_job_description: std::option::Option<std::string::String>,
        pub(crate) model_packaging_method: std::option::Option<std::string::String>,
        pub(crate) model_packaging_output_details:
            std::option::Option<crate::model::ModelPackagingOutputDetails>,
        pub(crate) status: std::option::Option<crate::model::ModelPackagingJobStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) creation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p> The name of the model packaging job. </p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p> The name of the model packaging job. </p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>The name of the project that's associated with a model that's in the model package. </p>
        pub fn project_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_name = Some(input.into());
            self
        }
        /// <p>The name of the project that's associated with a model that's in the model package. </p>
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_name = input;
            self
        }
        /// <p>The version of the model used in the model packaging job. </p>
        pub fn model_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version = Some(input.into());
            self
        }
        /// <p>The version of the model used in the model packaging job. </p>
        pub fn set_model_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// <p> The configuration information used in the model packaging job. </p>
        pub fn model_packaging_configuration(
            mut self,
            input: crate::model::ModelPackagingConfiguration,
        ) -> Self {
            self.model_packaging_configuration = Some(input);
            self
        }
        /// <p> The configuration information used in the model packaging job. </p>
        pub fn set_model_packaging_configuration(
            mut self,
            input: std::option::Option<crate::model::ModelPackagingConfiguration>,
        ) -> Self {
            self.model_packaging_configuration = input;
            self
        }
        /// <p>The description for the model packaging job. </p>
        pub fn model_packaging_job_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.model_packaging_job_description = Some(input.into());
            self
        }
        /// <p>The description for the model packaging job. </p>
        pub fn set_model_packaging_job_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_packaging_job_description = input;
            self
        }
        /// <p>The AWS service used to package the job. Currently Lookout for Vision can package jobs with AWS IoT Greengrass. </p>
        pub fn model_packaging_method(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_packaging_method = Some(input.into());
            self
        }
        /// <p>The AWS service used to package the job. Currently Lookout for Vision can package jobs with AWS IoT Greengrass. </p>
        pub fn set_model_packaging_method(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_packaging_method = input;
            self
        }
        /// <p>Information about the output of the model packaging job. For more information, see <code>DescribeModelPackagingJob</code>. </p>
        pub fn model_packaging_output_details(
            mut self,
            input: crate::model::ModelPackagingOutputDetails,
        ) -> Self {
            self.model_packaging_output_details = Some(input);
            self
        }
        /// <p>Information about the output of the model packaging job. For more information, see <code>DescribeModelPackagingJob</code>. </p>
        pub fn set_model_packaging_output_details(
            mut self,
            input: std::option::Option<crate::model::ModelPackagingOutputDetails>,
        ) -> Self {
            self.model_packaging_output_details = input;
            self
        }
        /// <p> The status of the model packaging job. </p>
        pub fn status(mut self, input: crate::model::ModelPackagingJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p> The status of the model packaging job. </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ModelPackagingJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p> The status message for the model packaging job. </p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p> The status message for the model packaging job. </p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p> The Unix timestamp for the time and date that the model packaging job was created. </p>
        pub fn creation_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_timestamp = Some(input);
            self
        }
        /// <p> The Unix timestamp for the time and date that the model packaging job was created. </p>
        pub fn set_creation_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_timestamp = input;
            self
        }
        /// <p> The Unix timestamp for the time and date that the model packaging job was last updated. </p>
        pub fn last_updated_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_timestamp = Some(input);
            self
        }
        /// <p> The Unix timestamp for the time and date that the model packaging job was last updated. </p>
        pub fn set_last_updated_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelPackagingDescription`](crate::model::ModelPackagingDescription).
        pub fn build(self) -> crate::model::ModelPackagingDescription {
            crate::model::ModelPackagingDescription {
                job_name: self.job_name,
                project_name: self.project_name,
                model_version: self.model_version,
                model_packaging_configuration: self.model_packaging_configuration,
                model_packaging_job_description: self.model_packaging_job_description,
                model_packaging_method: self.model_packaging_method,
                model_packaging_output_details: self.model_packaging_output_details,
                status: self.status,
                status_message: self.status_message,
                creation_timestamp: self.creation_timestamp,
                last_updated_timestamp: self.last_updated_timestamp,
            }
        }
    }
}
impl ModelPackagingDescription {
    /// Creates a new builder-style object to manufacture [`ModelPackagingDescription`](crate::model::ModelPackagingDescription).
    pub fn builder() -> crate::model::model_packaging_description::Builder {
        crate::model::model_packaging_description::Builder::default()
    }
}

/// <p> Information about the output from a model packaging job. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ModelPackagingOutputDetails {
    /// <p> Information about the AWS IoT Greengrass component in a model packaging job. </p>
    #[doc(hidden)]
    pub greengrass: std::option::Option<crate::model::GreengrassOutputDetails>,
}
impl ModelPackagingOutputDetails {
    /// <p> Information about the AWS IoT Greengrass component in a model packaging job. </p>
    pub fn greengrass(&self) -> std::option::Option<&crate::model::GreengrassOutputDetails> {
        self.greengrass.as_ref()
    }
}
/// See [`ModelPackagingOutputDetails`](crate::model::ModelPackagingOutputDetails).
pub mod model_packaging_output_details {

    /// A builder for [`ModelPackagingOutputDetails`](crate::model::ModelPackagingOutputDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) greengrass: std::option::Option<crate::model::GreengrassOutputDetails>,
    }
    impl Builder {
        /// <p> Information about the AWS IoT Greengrass component in a model packaging job. </p>
        pub fn greengrass(mut self, input: crate::model::GreengrassOutputDetails) -> Self {
            self.greengrass = Some(input);
            self
        }
        /// <p> Information about the AWS IoT Greengrass component in a model packaging job. </p>
        pub fn set_greengrass(
            mut self,
            input: std::option::Option<crate::model::GreengrassOutputDetails>,
        ) -> Self {
            self.greengrass = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelPackagingOutputDetails`](crate::model::ModelPackagingOutputDetails).
        pub fn build(self) -> crate::model::ModelPackagingOutputDetails {
            crate::model::ModelPackagingOutputDetails {
                greengrass: self.greengrass,
            }
        }
    }
}
impl ModelPackagingOutputDetails {
    /// Creates a new builder-style object to manufacture [`ModelPackagingOutputDetails`](crate::model::ModelPackagingOutputDetails).
    pub fn builder() -> crate::model::model_packaging_output_details::Builder {
        crate::model::model_packaging_output_details::Builder::default()
    }
}

/// <p>Information about the AWS IoT Greengrass component created by a model packaging job. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GreengrassOutputDetails {
    /// <p> The Amazon Resource Name (ARN) of the component. </p>
    #[doc(hidden)]
    pub component_version_arn: std::option::Option<std::string::String>,
    /// <p> The name of the component. </p>
    #[doc(hidden)]
    pub component_name: std::option::Option<std::string::String>,
    /// <p> The version of the component. </p>
    #[doc(hidden)]
    pub component_version: std::option::Option<std::string::String>,
}
impl GreengrassOutputDetails {
    /// <p> The Amazon Resource Name (ARN) of the component. </p>
    pub fn component_version_arn(&self) -> std::option::Option<&str> {
        self.component_version_arn.as_deref()
    }
    /// <p> The name of the component. </p>
    pub fn component_name(&self) -> std::option::Option<&str> {
        self.component_name.as_deref()
    }
    /// <p> The version of the component. </p>
    pub fn component_version(&self) -> std::option::Option<&str> {
        self.component_version.as_deref()
    }
}
/// See [`GreengrassOutputDetails`](crate::model::GreengrassOutputDetails).
pub mod greengrass_output_details {

    /// A builder for [`GreengrassOutputDetails`](crate::model::GreengrassOutputDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) component_version_arn: std::option::Option<std::string::String>,
        pub(crate) component_name: std::option::Option<std::string::String>,
        pub(crate) component_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The Amazon Resource Name (ARN) of the component. </p>
        pub fn component_version_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_version_arn = Some(input.into());
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the component. </p>
        pub fn set_component_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.component_version_arn = input;
            self
        }
        /// <p> The name of the component. </p>
        pub fn component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_name = Some(input.into());
            self
        }
        /// <p> The name of the component. </p>
        pub fn set_component_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.component_name = input;
            self
        }
        /// <p> The version of the component. </p>
        pub fn component_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_version = Some(input.into());
            self
        }
        /// <p> The version of the component. </p>
        pub fn set_component_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.component_version = input;
            self
        }
        /// Consumes the builder and constructs a [`GreengrassOutputDetails`](crate::model::GreengrassOutputDetails).
        pub fn build(self) -> crate::model::GreengrassOutputDetails {
            crate::model::GreengrassOutputDetails {
                component_version_arn: self.component_version_arn,
                component_name: self.component_name,
                component_version: self.component_version,
            }
        }
    }
}
impl GreengrassOutputDetails {
    /// Creates a new builder-style object to manufacture [`GreengrassOutputDetails`](crate::model::GreengrassOutputDetails).
    pub fn builder() -> crate::model::greengrass_output_details::Builder {
        crate::model::greengrass_output_details::Builder::default()
    }
}

/// <p>Describes an Amazon Lookout for Vision model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ModelDescription {
    /// <p>The version of the model</p>
    #[doc(hidden)]
    pub model_version: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the model.</p>
    #[doc(hidden)]
    pub model_arn: std::option::Option<std::string::String>,
    /// <p>The unix timestamp for the date and time that the model was created. </p>
    #[doc(hidden)]
    pub creation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The description for the model.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The status of the model.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ModelStatus>,
    /// <p>The status message for the model.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
    /// <p>Performance metrics for the model. Created during training.</p>
    #[doc(hidden)]
    pub performance: std::option::Option<crate::model::ModelPerformance>,
    /// <p>The S3 location where Amazon Lookout for Vision saves model training files.</p>
    #[doc(hidden)]
    pub output_config: std::option::Option<crate::model::OutputConfig>,
    /// <p>The S3 location where Amazon Lookout for Vision saves the manifest file that was used to test the trained model and generate the performance scores.</p>
    #[doc(hidden)]
    pub evaluation_manifest: std::option::Option<crate::model::OutputS3Object>,
    /// <p>The S3 location where Amazon Lookout for Vision saves the performance metrics.</p>
    #[doc(hidden)]
    pub evaluation_result: std::option::Option<crate::model::OutputS3Object>,
    /// <p>The unix timestamp for the date and time that the evaluation ended. </p>
    #[doc(hidden)]
    pub evaluation_end_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The identifer for the AWS Key Management Service (AWS KMS) key that was used to encrypt the model during training.</p>
    #[doc(hidden)]
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The minimum number of inference units used by the model. For more information, see <code>StartModel</code> </p>
    #[doc(hidden)]
    pub min_inference_units: std::option::Option<i32>,
    /// <p>The maximum number of inference units Amazon Lookout for Vision uses to auto-scale the model. For more information, see <code>StartModel</code>.</p>
    #[doc(hidden)]
    pub max_inference_units: std::option::Option<i32>,
}
impl ModelDescription {
    /// <p>The version of the model</p>
    pub fn model_version(&self) -> std::option::Option<&str> {
        self.model_version.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the model.</p>
    pub fn model_arn(&self) -> std::option::Option<&str> {
        self.model_arn.as_deref()
    }
    /// <p>The unix timestamp for the date and time that the model was created. </p>
    pub fn creation_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_timestamp.as_ref()
    }
    /// <p>The description for the model.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The status of the model.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ModelStatus> {
        self.status.as_ref()
    }
    /// <p>The status message for the model.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>Performance metrics for the model. Created during training.</p>
    pub fn performance(&self) -> std::option::Option<&crate::model::ModelPerformance> {
        self.performance.as_ref()
    }
    /// <p>The S3 location where Amazon Lookout for Vision saves model training files.</p>
    pub fn output_config(&self) -> std::option::Option<&crate::model::OutputConfig> {
        self.output_config.as_ref()
    }
    /// <p>The S3 location where Amazon Lookout for Vision saves the manifest file that was used to test the trained model and generate the performance scores.</p>
    pub fn evaluation_manifest(&self) -> std::option::Option<&crate::model::OutputS3Object> {
        self.evaluation_manifest.as_ref()
    }
    /// <p>The S3 location where Amazon Lookout for Vision saves the performance metrics.</p>
    pub fn evaluation_result(&self) -> std::option::Option<&crate::model::OutputS3Object> {
        self.evaluation_result.as_ref()
    }
    /// <p>The unix timestamp for the date and time that the evaluation ended. </p>
    pub fn evaluation_end_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.evaluation_end_timestamp.as_ref()
    }
    /// <p>The identifer for the AWS Key Management Service (AWS KMS) key that was used to encrypt the model during training.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>The minimum number of inference units used by the model. For more information, see <code>StartModel</code> </p>
    pub fn min_inference_units(&self) -> std::option::Option<i32> {
        self.min_inference_units
    }
    /// <p>The maximum number of inference units Amazon Lookout for Vision uses to auto-scale the model. For more information, see <code>StartModel</code>.</p>
    pub fn max_inference_units(&self) -> std::option::Option<i32> {
        self.max_inference_units
    }
}
/// See [`ModelDescription`](crate::model::ModelDescription).
pub mod model_description {

    /// A builder for [`ModelDescription`](crate::model::ModelDescription).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_version: std::option::Option<std::string::String>,
        pub(crate) model_arn: std::option::Option<std::string::String>,
        pub(crate) creation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ModelStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) performance: std::option::Option<crate::model::ModelPerformance>,
        pub(crate) output_config: std::option::Option<crate::model::OutputConfig>,
        pub(crate) evaluation_manifest: std::option::Option<crate::model::OutputS3Object>,
        pub(crate) evaluation_result: std::option::Option<crate::model::OutputS3Object>,
        pub(crate) evaluation_end_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) min_inference_units: std::option::Option<i32>,
        pub(crate) max_inference_units: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The version of the model</p>
        pub fn model_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version = Some(input.into());
            self
        }
        /// <p>The version of the model</p>
        pub fn set_model_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model.</p>
        pub fn model_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model.</p>
        pub fn set_model_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_arn = input;
            self
        }
        /// <p>The unix timestamp for the date and time that the model was created. </p>
        pub fn creation_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_timestamp = Some(input);
            self
        }
        /// <p>The unix timestamp for the date and time that the model was created. </p>
        pub fn set_creation_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_timestamp = input;
            self
        }
        /// <p>The description for the model.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description for the model.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The status of the model.</p>
        pub fn status(mut self, input: crate::model::ModelStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the model.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::ModelStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>The status message for the model.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The status message for the model.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>Performance metrics for the model. Created during training.</p>
        pub fn performance(mut self, input: crate::model::ModelPerformance) -> Self {
            self.performance = Some(input);
            self
        }
        /// <p>Performance metrics for the model. Created during training.</p>
        pub fn set_performance(
            mut self,
            input: std::option::Option<crate::model::ModelPerformance>,
        ) -> Self {
            self.performance = input;
            self
        }
        /// <p>The S3 location where Amazon Lookout for Vision saves model training files.</p>
        pub fn output_config(mut self, input: crate::model::OutputConfig) -> Self {
            self.output_config = Some(input);
            self
        }
        /// <p>The S3 location where Amazon Lookout for Vision saves model training files.</p>
        pub fn set_output_config(
            mut self,
            input: std::option::Option<crate::model::OutputConfig>,
        ) -> Self {
            self.output_config = input;
            self
        }
        /// <p>The S3 location where Amazon Lookout for Vision saves the manifest file that was used to test the trained model and generate the performance scores.</p>
        pub fn evaluation_manifest(mut self, input: crate::model::OutputS3Object) -> Self {
            self.evaluation_manifest = Some(input);
            self
        }
        /// <p>The S3 location where Amazon Lookout for Vision saves the manifest file that was used to test the trained model and generate the performance scores.</p>
        pub fn set_evaluation_manifest(
            mut self,
            input: std::option::Option<crate::model::OutputS3Object>,
        ) -> Self {
            self.evaluation_manifest = input;
            self
        }
        /// <p>The S3 location where Amazon Lookout for Vision saves the performance metrics.</p>
        pub fn evaluation_result(mut self, input: crate::model::OutputS3Object) -> Self {
            self.evaluation_result = Some(input);
            self
        }
        /// <p>The S3 location where Amazon Lookout for Vision saves the performance metrics.</p>
        pub fn set_evaluation_result(
            mut self,
            input: std::option::Option<crate::model::OutputS3Object>,
        ) -> Self {
            self.evaluation_result = input;
            self
        }
        /// <p>The unix timestamp for the date and time that the evaluation ended. </p>
        pub fn evaluation_end_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.evaluation_end_timestamp = Some(input);
            self
        }
        /// <p>The unix timestamp for the date and time that the evaluation ended. </p>
        pub fn set_evaluation_end_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.evaluation_end_timestamp = input;
            self
        }
        /// <p>The identifer for the AWS Key Management Service (AWS KMS) key that was used to encrypt the model during training.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The identifer for the AWS Key Management Service (AWS KMS) key that was used to encrypt the model during training.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The minimum number of inference units used by the model. For more information, see <code>StartModel</code> </p>
        pub fn min_inference_units(mut self, input: i32) -> Self {
            self.min_inference_units = Some(input);
            self
        }
        /// <p>The minimum number of inference units used by the model. For more information, see <code>StartModel</code> </p>
        pub fn set_min_inference_units(mut self, input: std::option::Option<i32>) -> Self {
            self.min_inference_units = input;
            self
        }
        /// <p>The maximum number of inference units Amazon Lookout for Vision uses to auto-scale the model. For more information, see <code>StartModel</code>.</p>
        pub fn max_inference_units(mut self, input: i32) -> Self {
            self.max_inference_units = Some(input);
            self
        }
        /// <p>The maximum number of inference units Amazon Lookout for Vision uses to auto-scale the model. For more information, see <code>StartModel</code>.</p>
        pub fn set_max_inference_units(mut self, input: std::option::Option<i32>) -> Self {
            self.max_inference_units = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelDescription`](crate::model::ModelDescription).
        pub fn build(self) -> crate::model::ModelDescription {
            crate::model::ModelDescription {
                model_version: self.model_version,
                model_arn: self.model_arn,
                creation_timestamp: self.creation_timestamp,
                description: self.description,
                status: self.status,
                status_message: self.status_message,
                performance: self.performance,
                output_config: self.output_config,
                evaluation_manifest: self.evaluation_manifest,
                evaluation_result: self.evaluation_result,
                evaluation_end_timestamp: self.evaluation_end_timestamp,
                kms_key_id: self.kms_key_id,
                min_inference_units: self.min_inference_units,
                max_inference_units: self.max_inference_units,
            }
        }
    }
}
impl ModelDescription {
    /// Creates a new builder-style object to manufacture [`ModelDescription`](crate::model::ModelDescription).
    pub fn builder() -> crate::model::model_description::Builder {
        crate::model::model_description::Builder::default()
    }
}

/// <p>The S3 location where Amazon Lookout for Vision saves training output.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OutputS3Object {
    /// <p>The bucket that contains the training output.</p>
    #[doc(hidden)]
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The location of the training output in the bucket.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
}
impl OutputS3Object {
    /// <p>The bucket that contains the training output.</p>
    pub fn bucket(&self) -> std::option::Option<&str> {
        self.bucket.as_deref()
    }
    /// <p>The location of the training output in the bucket.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
}
/// See [`OutputS3Object`](crate::model::OutputS3Object).
pub mod output_s3_object {

    /// A builder for [`OutputS3Object`](crate::model::OutputS3Object).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bucket that contains the training output.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        /// <p>The bucket that contains the training output.</p>
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The location of the training output in the bucket.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The location of the training output in the bucket.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// Consumes the builder and constructs a [`OutputS3Object`](crate::model::OutputS3Object).
        pub fn build(self) -> crate::model::OutputS3Object {
            crate::model::OutputS3Object {
                bucket: self.bucket,
                key: self.key,
            }
        }
    }
}
impl OutputS3Object {
    /// Creates a new builder-style object to manufacture [`OutputS3Object`](crate::model::OutputS3Object).
    pub fn builder() -> crate::model::output_s3_object::Builder {
        crate::model::output_s3_object::Builder::default()
    }
}

/// <p>The S3 location where Amazon Lookout for Vision saves model training files.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OutputConfig {
    /// <p>The S3 location for the output.</p>
    #[doc(hidden)]
    pub s3_location: std::option::Option<crate::model::S3Location>,
}
impl OutputConfig {
    /// <p>The S3 location for the output.</p>
    pub fn s3_location(&self) -> std::option::Option<&crate::model::S3Location> {
        self.s3_location.as_ref()
    }
}
/// See [`OutputConfig`](crate::model::OutputConfig).
pub mod output_config {

    /// A builder for [`OutputConfig`](crate::model::OutputConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_location: std::option::Option<crate::model::S3Location>,
    }
    impl Builder {
        /// <p>The S3 location for the output.</p>
        pub fn s3_location(mut self, input: crate::model::S3Location) -> Self {
            self.s3_location = Some(input);
            self
        }
        /// <p>The S3 location for the output.</p>
        pub fn set_s3_location(
            mut self,
            input: std::option::Option<crate::model::S3Location>,
        ) -> Self {
            self.s3_location = input;
            self
        }
        /// Consumes the builder and constructs a [`OutputConfig`](crate::model::OutputConfig).
        pub fn build(self) -> crate::model::OutputConfig {
            crate::model::OutputConfig {
                s3_location: self.s3_location,
            }
        }
    }
}
impl OutputConfig {
    /// Creates a new builder-style object to manufacture [`OutputConfig`](crate::model::OutputConfig).
    pub fn builder() -> crate::model::output_config::Builder {
        crate::model::output_config::Builder::default()
    }
}

/// <p>The description for a dataset. For more information, see <code>DescribeDataset</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DatasetDescription {
    /// <p>The name of the project that contains the dataset.</p>
    #[doc(hidden)]
    pub project_name: std::option::Option<std::string::String>,
    /// <p>The type of the dataset. The value <code>train</code> represents a training dataset or single dataset project. The value <code>test</code> represents a test dataset.</p>
    #[doc(hidden)]
    pub dataset_type: std::option::Option<std::string::String>,
    /// <p>The Unix timestamp for the time and date that the dataset was created.</p>
    #[doc(hidden)]
    pub creation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The Unix timestamp for the date and time that the dataset was last updated.</p>
    #[doc(hidden)]
    pub last_updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the dataset.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::DatasetStatus>,
    /// <p>The status message for the dataset. </p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
    /// <p>Statistics about the images in a dataset.</p>
    #[doc(hidden)]
    pub image_stats: std::option::Option<crate::model::DatasetImageStats>,
}
impl DatasetDescription {
    /// <p>The name of the project that contains the dataset.</p>
    pub fn project_name(&self) -> std::option::Option<&str> {
        self.project_name.as_deref()
    }
    /// <p>The type of the dataset. The value <code>train</code> represents a training dataset or single dataset project. The value <code>test</code> represents a test dataset.</p>
    pub fn dataset_type(&self) -> std::option::Option<&str> {
        self.dataset_type.as_deref()
    }
    /// <p>The Unix timestamp for the time and date that the dataset was created.</p>
    pub fn creation_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_timestamp.as_ref()
    }
    /// <p>The Unix timestamp for the date and time that the dataset was last updated.</p>
    pub fn last_updated_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_timestamp.as_ref()
    }
    /// <p>The status of the dataset.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::DatasetStatus> {
        self.status.as_ref()
    }
    /// <p>The status message for the dataset. </p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>Statistics about the images in a dataset.</p>
    pub fn image_stats(&self) -> std::option::Option<&crate::model::DatasetImageStats> {
        self.image_stats.as_ref()
    }
}
/// See [`DatasetDescription`](crate::model::DatasetDescription).
pub mod dataset_description {

    /// A builder for [`DatasetDescription`](crate::model::DatasetDescription).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) project_name: std::option::Option<std::string::String>,
        pub(crate) dataset_type: std::option::Option<std::string::String>,
        pub(crate) creation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status: std::option::Option<crate::model::DatasetStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) image_stats: std::option::Option<crate::model::DatasetImageStats>,
    }
    impl Builder {
        /// <p>The name of the project that contains the dataset.</p>
        pub fn project_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_name = Some(input.into());
            self
        }
        /// <p>The name of the project that contains the dataset.</p>
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_name = input;
            self
        }
        /// <p>The type of the dataset. The value <code>train</code> represents a training dataset or single dataset project. The value <code>test</code> represents a test dataset.</p>
        pub fn dataset_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.dataset_type = Some(input.into());
            self
        }
        /// <p>The type of the dataset. The value <code>train</code> represents a training dataset or single dataset project. The value <code>test</code> represents a test dataset.</p>
        pub fn set_dataset_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dataset_type = input;
            self
        }
        /// <p>The Unix timestamp for the time and date that the dataset was created.</p>
        pub fn creation_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_timestamp = Some(input);
            self
        }
        /// <p>The Unix timestamp for the time and date that the dataset was created.</p>
        pub fn set_creation_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_timestamp = input;
            self
        }
        /// <p>The Unix timestamp for the date and time that the dataset was last updated.</p>
        pub fn last_updated_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_timestamp = Some(input);
            self
        }
        /// <p>The Unix timestamp for the date and time that the dataset was last updated.</p>
        pub fn set_last_updated_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_timestamp = input;
            self
        }
        /// <p>The status of the dataset.</p>
        pub fn status(mut self, input: crate::model::DatasetStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the dataset.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::DatasetStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The status message for the dataset. </p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The status message for the dataset. </p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>Statistics about the images in a dataset.</p>
        pub fn image_stats(mut self, input: crate::model::DatasetImageStats) -> Self {
            self.image_stats = Some(input);
            self
        }
        /// <p>Statistics about the images in a dataset.</p>
        pub fn set_image_stats(
            mut self,
            input: std::option::Option<crate::model::DatasetImageStats>,
        ) -> Self {
            self.image_stats = input;
            self
        }
        /// Consumes the builder and constructs a [`DatasetDescription`](crate::model::DatasetDescription).
        pub fn build(self) -> crate::model::DatasetDescription {
            crate::model::DatasetDescription {
                project_name: self.project_name,
                dataset_type: self.dataset_type,
                creation_timestamp: self.creation_timestamp,
                last_updated_timestamp: self.last_updated_timestamp,
                status: self.status,
                status_message: self.status_message,
                image_stats: self.image_stats,
            }
        }
    }
}
impl DatasetDescription {
    /// Creates a new builder-style object to manufacture [`DatasetDescription`](crate::model::DatasetDescription).
    pub fn builder() -> crate::model::dataset_description::Builder {
        crate::model::dataset_description::Builder::default()
    }
}

/// <p>Statistics about the images in a dataset.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DatasetImageStats {
    /// <p>The total number of images in the dataset.</p>
    #[doc(hidden)]
    pub total: std::option::Option<i32>,
    /// <p>The total number of labeled images.</p>
    #[doc(hidden)]
    pub labeled: std::option::Option<i32>,
    /// <p>The total number of images labeled as normal.</p>
    #[doc(hidden)]
    pub normal: std::option::Option<i32>,
    /// <p>the total number of images labeled as an anomaly.</p>
    #[doc(hidden)]
    pub anomaly: std::option::Option<i32>,
}
impl DatasetImageStats {
    /// <p>The total number of images in the dataset.</p>
    pub fn total(&self) -> std::option::Option<i32> {
        self.total
    }
    /// <p>The total number of labeled images.</p>
    pub fn labeled(&self) -> std::option::Option<i32> {
        self.labeled
    }
    /// <p>The total number of images labeled as normal.</p>
    pub fn normal(&self) -> std::option::Option<i32> {
        self.normal
    }
    /// <p>the total number of images labeled as an anomaly.</p>
    pub fn anomaly(&self) -> std::option::Option<i32> {
        self.anomaly
    }
}
/// See [`DatasetImageStats`](crate::model::DatasetImageStats).
pub mod dataset_image_stats {

    /// A builder for [`DatasetImageStats`](crate::model::DatasetImageStats).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) total: std::option::Option<i32>,
        pub(crate) labeled: std::option::Option<i32>,
        pub(crate) normal: std::option::Option<i32>,
        pub(crate) anomaly: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The total number of images in the dataset.</p>
        pub fn total(mut self, input: i32) -> Self {
            self.total = Some(input);
            self
        }
        /// <p>The total number of images in the dataset.</p>
        pub fn set_total(mut self, input: std::option::Option<i32>) -> Self {
            self.total = input;
            self
        }
        /// <p>The total number of labeled images.</p>
        pub fn labeled(mut self, input: i32) -> Self {
            self.labeled = Some(input);
            self
        }
        /// <p>The total number of labeled images.</p>
        pub fn set_labeled(mut self, input: std::option::Option<i32>) -> Self {
            self.labeled = input;
            self
        }
        /// <p>The total number of images labeled as normal.</p>
        pub fn normal(mut self, input: i32) -> Self {
            self.normal = Some(input);
            self
        }
        /// <p>The total number of images labeled as normal.</p>
        pub fn set_normal(mut self, input: std::option::Option<i32>) -> Self {
            self.normal = input;
            self
        }
        /// <p>the total number of images labeled as an anomaly.</p>
        pub fn anomaly(mut self, input: i32) -> Self {
            self.anomaly = Some(input);
            self
        }
        /// <p>the total number of images labeled as an anomaly.</p>
        pub fn set_anomaly(mut self, input: std::option::Option<i32>) -> Self {
            self.anomaly = input;
            self
        }
        /// Consumes the builder and constructs a [`DatasetImageStats`](crate::model::DatasetImageStats).
        pub fn build(self) -> crate::model::DatasetImageStats {
            crate::model::DatasetImageStats {
                total: self.total,
                labeled: self.labeled,
                normal: self.normal,
                anomaly: self.anomaly,
            }
        }
    }
}
impl DatasetImageStats {
    /// Creates a new builder-style object to manufacture [`DatasetImageStats`](crate::model::DatasetImageStats).
    pub fn builder() -> crate::model::dataset_image_stats::Builder {
        crate::model::dataset_image_stats::Builder::default()
    }
}

/// <p>Information about the location of a manifest file that Amazon Lookout for Vision uses to to create a dataset.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DatasetSource {
    /// <p>Location information for the manifest file.</p>
    #[doc(hidden)]
    pub ground_truth_manifest: std::option::Option<crate::model::DatasetGroundTruthManifest>,
}
impl DatasetSource {
    /// <p>Location information for the manifest file.</p>
    pub fn ground_truth_manifest(
        &self,
    ) -> std::option::Option<&crate::model::DatasetGroundTruthManifest> {
        self.ground_truth_manifest.as_ref()
    }
}
/// See [`DatasetSource`](crate::model::DatasetSource).
pub mod dataset_source {

    /// A builder for [`DatasetSource`](crate::model::DatasetSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ground_truth_manifest:
            std::option::Option<crate::model::DatasetGroundTruthManifest>,
    }
    impl Builder {
        /// <p>Location information for the manifest file.</p>
        pub fn ground_truth_manifest(
            mut self,
            input: crate::model::DatasetGroundTruthManifest,
        ) -> Self {
            self.ground_truth_manifest = Some(input);
            self
        }
        /// <p>Location information for the manifest file.</p>
        pub fn set_ground_truth_manifest(
            mut self,
            input: std::option::Option<crate::model::DatasetGroundTruthManifest>,
        ) -> Self {
            self.ground_truth_manifest = input;
            self
        }
        /// Consumes the builder and constructs a [`DatasetSource`](crate::model::DatasetSource).
        pub fn build(self) -> crate::model::DatasetSource {
            crate::model::DatasetSource {
                ground_truth_manifest: self.ground_truth_manifest,
            }
        }
    }
}
impl DatasetSource {
    /// Creates a new builder-style object to manufacture [`DatasetSource`](crate::model::DatasetSource).
    pub fn builder() -> crate::model::dataset_source::Builder {
        crate::model::dataset_source::Builder::default()
    }
}

/// <p>Location information about a manifest file. You can use a manifest file to create a dataset.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DatasetGroundTruthManifest {
    /// <p>The S3 bucket location for the manifest file.</p>
    #[doc(hidden)]
    pub s3_object: std::option::Option<crate::model::InputS3Object>,
}
impl DatasetGroundTruthManifest {
    /// <p>The S3 bucket location for the manifest file.</p>
    pub fn s3_object(&self) -> std::option::Option<&crate::model::InputS3Object> {
        self.s3_object.as_ref()
    }
}
/// See [`DatasetGroundTruthManifest`](crate::model::DatasetGroundTruthManifest).
pub mod dataset_ground_truth_manifest {

    /// A builder for [`DatasetGroundTruthManifest`](crate::model::DatasetGroundTruthManifest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_object: std::option::Option<crate::model::InputS3Object>,
    }
    impl Builder {
        /// <p>The S3 bucket location for the manifest file.</p>
        pub fn s3_object(mut self, input: crate::model::InputS3Object) -> Self {
            self.s3_object = Some(input);
            self
        }
        /// <p>The S3 bucket location for the manifest file.</p>
        pub fn set_s3_object(
            mut self,
            input: std::option::Option<crate::model::InputS3Object>,
        ) -> Self {
            self.s3_object = input;
            self
        }
        /// Consumes the builder and constructs a [`DatasetGroundTruthManifest`](crate::model::DatasetGroundTruthManifest).
        pub fn build(self) -> crate::model::DatasetGroundTruthManifest {
            crate::model::DatasetGroundTruthManifest {
                s3_object: self.s3_object,
            }
        }
    }
}
impl DatasetGroundTruthManifest {
    /// Creates a new builder-style object to manufacture [`DatasetGroundTruthManifest`](crate::model::DatasetGroundTruthManifest).
    pub fn builder() -> crate::model::dataset_ground_truth_manifest::Builder {
        crate::model::dataset_ground_truth_manifest::Builder::default()
    }
}

/// <p>Amazon S3 Location information for an input manifest file. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InputS3Object {
    /// <p>The Amazon S3 bucket that contains the manifest.</p>
    #[doc(hidden)]
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The name and location of the manifest file withiin the bucket.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The version ID of the bucket.</p>
    #[doc(hidden)]
    pub version_id: std::option::Option<std::string::String>,
}
impl InputS3Object {
    /// <p>The Amazon S3 bucket that contains the manifest.</p>
    pub fn bucket(&self) -> std::option::Option<&str> {
        self.bucket.as_deref()
    }
    /// <p>The name and location of the manifest file withiin the bucket.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The version ID of the bucket.</p>
    pub fn version_id(&self) -> std::option::Option<&str> {
        self.version_id.as_deref()
    }
}
/// See [`InputS3Object`](crate::model::InputS3Object).
pub mod input_s3_object {

    /// A builder for [`InputS3Object`](crate::model::InputS3Object).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 bucket that contains the manifest.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        /// <p>The Amazon S3 bucket that contains the manifest.</p>
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The name and location of the manifest file withiin the bucket.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The name and location of the manifest file withiin the bucket.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The version ID of the bucket.</p>
        pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_id = Some(input.into());
            self
        }
        /// <p>The version ID of the bucket.</p>
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_id = input;
            self
        }
        /// Consumes the builder and constructs a [`InputS3Object`](crate::model::InputS3Object).
        pub fn build(self) -> crate::model::InputS3Object {
            crate::model::InputS3Object {
                bucket: self.bucket,
                key: self.key,
                version_id: self.version_id,
            }
        }
    }
}
impl InputS3Object {
    /// Creates a new builder-style object to manufacture [`InputS3Object`](crate::model::InputS3Object).
    pub fn builder() -> crate::model::input_s3_object::Builder {
        crate::model::input_s3_object::Builder::default()
    }
}
