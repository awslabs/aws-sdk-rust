// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn add_tags_to_resource(&self) -> fluent_builders::AddTagsToResource<C> {
        fluent_builders::AddTagsToResource::new(self.handle.clone())
    }
    pub fn apply_pending_maintenance_action(
        &self,
    ) -> fluent_builders::ApplyPendingMaintenanceAction<C> {
        fluent_builders::ApplyPendingMaintenanceAction::new(self.handle.clone())
    }
    pub fn cancel_replication_task_assessment_run(
        &self,
    ) -> fluent_builders::CancelReplicationTaskAssessmentRun<C> {
        fluent_builders::CancelReplicationTaskAssessmentRun::new(self.handle.clone())
    }
    pub fn create_endpoint(&self) -> fluent_builders::CreateEndpoint<C> {
        fluent_builders::CreateEndpoint::new(self.handle.clone())
    }
    pub fn create_event_subscription(&self) -> fluent_builders::CreateEventSubscription<C> {
        fluent_builders::CreateEventSubscription::new(self.handle.clone())
    }
    pub fn create_replication_instance(&self) -> fluent_builders::CreateReplicationInstance<C> {
        fluent_builders::CreateReplicationInstance::new(self.handle.clone())
    }
    pub fn create_replication_subnet_group(
        &self,
    ) -> fluent_builders::CreateReplicationSubnetGroup<C> {
        fluent_builders::CreateReplicationSubnetGroup::new(self.handle.clone())
    }
    pub fn create_replication_task(&self) -> fluent_builders::CreateReplicationTask<C> {
        fluent_builders::CreateReplicationTask::new(self.handle.clone())
    }
    pub fn delete_certificate(&self) -> fluent_builders::DeleteCertificate<C> {
        fluent_builders::DeleteCertificate::new(self.handle.clone())
    }
    pub fn delete_connection(&self) -> fluent_builders::DeleteConnection<C> {
        fluent_builders::DeleteConnection::new(self.handle.clone())
    }
    pub fn delete_endpoint(&self) -> fluent_builders::DeleteEndpoint<C> {
        fluent_builders::DeleteEndpoint::new(self.handle.clone())
    }
    pub fn delete_event_subscription(&self) -> fluent_builders::DeleteEventSubscription<C> {
        fluent_builders::DeleteEventSubscription::new(self.handle.clone())
    }
    pub fn delete_replication_instance(&self) -> fluent_builders::DeleteReplicationInstance<C> {
        fluent_builders::DeleteReplicationInstance::new(self.handle.clone())
    }
    pub fn delete_replication_subnet_group(
        &self,
    ) -> fluent_builders::DeleteReplicationSubnetGroup<C> {
        fluent_builders::DeleteReplicationSubnetGroup::new(self.handle.clone())
    }
    pub fn delete_replication_task(&self) -> fluent_builders::DeleteReplicationTask<C> {
        fluent_builders::DeleteReplicationTask::new(self.handle.clone())
    }
    pub fn delete_replication_task_assessment_run(
        &self,
    ) -> fluent_builders::DeleteReplicationTaskAssessmentRun<C> {
        fluent_builders::DeleteReplicationTaskAssessmentRun::new(self.handle.clone())
    }
    pub fn describe_account_attributes(&self) -> fluent_builders::DescribeAccountAttributes<C> {
        fluent_builders::DescribeAccountAttributes::new(self.handle.clone())
    }
    pub fn describe_applicable_individual_assessments(
        &self,
    ) -> fluent_builders::DescribeApplicableIndividualAssessments<C> {
        fluent_builders::DescribeApplicableIndividualAssessments::new(self.handle.clone())
    }
    pub fn describe_certificates(&self) -> fluent_builders::DescribeCertificates<C> {
        fluent_builders::DescribeCertificates::new(self.handle.clone())
    }
    pub fn describe_connections(&self) -> fluent_builders::DescribeConnections<C> {
        fluent_builders::DescribeConnections::new(self.handle.clone())
    }
    pub fn describe_endpoints(&self) -> fluent_builders::DescribeEndpoints<C> {
        fluent_builders::DescribeEndpoints::new(self.handle.clone())
    }
    pub fn describe_endpoint_settings(&self) -> fluent_builders::DescribeEndpointSettings<C> {
        fluent_builders::DescribeEndpointSettings::new(self.handle.clone())
    }
    pub fn describe_endpoint_types(&self) -> fluent_builders::DescribeEndpointTypes<C> {
        fluent_builders::DescribeEndpointTypes::new(self.handle.clone())
    }
    pub fn describe_event_categories(&self) -> fluent_builders::DescribeEventCategories<C> {
        fluent_builders::DescribeEventCategories::new(self.handle.clone())
    }
    pub fn describe_events(&self) -> fluent_builders::DescribeEvents<C> {
        fluent_builders::DescribeEvents::new(self.handle.clone())
    }
    pub fn describe_event_subscriptions(&self) -> fluent_builders::DescribeEventSubscriptions<C> {
        fluent_builders::DescribeEventSubscriptions::new(self.handle.clone())
    }
    pub fn describe_orderable_replication_instances(
        &self,
    ) -> fluent_builders::DescribeOrderableReplicationInstances<C> {
        fluent_builders::DescribeOrderableReplicationInstances::new(self.handle.clone())
    }
    pub fn describe_pending_maintenance_actions(
        &self,
    ) -> fluent_builders::DescribePendingMaintenanceActions<C> {
        fluent_builders::DescribePendingMaintenanceActions::new(self.handle.clone())
    }
    pub fn describe_refresh_schemas_status(
        &self,
    ) -> fluent_builders::DescribeRefreshSchemasStatus<C> {
        fluent_builders::DescribeRefreshSchemasStatus::new(self.handle.clone())
    }
    pub fn describe_replication_instances(
        &self,
    ) -> fluent_builders::DescribeReplicationInstances<C> {
        fluent_builders::DescribeReplicationInstances::new(self.handle.clone())
    }
    pub fn describe_replication_instance_task_logs(
        &self,
    ) -> fluent_builders::DescribeReplicationInstanceTaskLogs<C> {
        fluent_builders::DescribeReplicationInstanceTaskLogs::new(self.handle.clone())
    }
    pub fn describe_replication_subnet_groups(
        &self,
    ) -> fluent_builders::DescribeReplicationSubnetGroups<C> {
        fluent_builders::DescribeReplicationSubnetGroups::new(self.handle.clone())
    }
    pub fn describe_replication_task_assessment_results(
        &self,
    ) -> fluent_builders::DescribeReplicationTaskAssessmentResults<C> {
        fluent_builders::DescribeReplicationTaskAssessmentResults::new(self.handle.clone())
    }
    pub fn describe_replication_task_assessment_runs(
        &self,
    ) -> fluent_builders::DescribeReplicationTaskAssessmentRuns<C> {
        fluent_builders::DescribeReplicationTaskAssessmentRuns::new(self.handle.clone())
    }
    pub fn describe_replication_task_individual_assessments(
        &self,
    ) -> fluent_builders::DescribeReplicationTaskIndividualAssessments<C> {
        fluent_builders::DescribeReplicationTaskIndividualAssessments::new(self.handle.clone())
    }
    pub fn describe_replication_tasks(&self) -> fluent_builders::DescribeReplicationTasks<C> {
        fluent_builders::DescribeReplicationTasks::new(self.handle.clone())
    }
    pub fn describe_schemas(&self) -> fluent_builders::DescribeSchemas<C> {
        fluent_builders::DescribeSchemas::new(self.handle.clone())
    }
    pub fn describe_table_statistics(&self) -> fluent_builders::DescribeTableStatistics<C> {
        fluent_builders::DescribeTableStatistics::new(self.handle.clone())
    }
    pub fn import_certificate(&self) -> fluent_builders::ImportCertificate<C> {
        fluent_builders::ImportCertificate::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn modify_endpoint(&self) -> fluent_builders::ModifyEndpoint<C> {
        fluent_builders::ModifyEndpoint::new(self.handle.clone())
    }
    pub fn modify_event_subscription(&self) -> fluent_builders::ModifyEventSubscription<C> {
        fluent_builders::ModifyEventSubscription::new(self.handle.clone())
    }
    pub fn modify_replication_instance(&self) -> fluent_builders::ModifyReplicationInstance<C> {
        fluent_builders::ModifyReplicationInstance::new(self.handle.clone())
    }
    pub fn modify_replication_subnet_group(
        &self,
    ) -> fluent_builders::ModifyReplicationSubnetGroup<C> {
        fluent_builders::ModifyReplicationSubnetGroup::new(self.handle.clone())
    }
    pub fn modify_replication_task(&self) -> fluent_builders::ModifyReplicationTask<C> {
        fluent_builders::ModifyReplicationTask::new(self.handle.clone())
    }
    pub fn move_replication_task(&self) -> fluent_builders::MoveReplicationTask<C> {
        fluent_builders::MoveReplicationTask::new(self.handle.clone())
    }
    pub fn reboot_replication_instance(&self) -> fluent_builders::RebootReplicationInstance<C> {
        fluent_builders::RebootReplicationInstance::new(self.handle.clone())
    }
    pub fn refresh_schemas(&self) -> fluent_builders::RefreshSchemas<C> {
        fluent_builders::RefreshSchemas::new(self.handle.clone())
    }
    pub fn reload_tables(&self) -> fluent_builders::ReloadTables<C> {
        fluent_builders::ReloadTables::new(self.handle.clone())
    }
    pub fn remove_tags_from_resource(&self) -> fluent_builders::RemoveTagsFromResource<C> {
        fluent_builders::RemoveTagsFromResource::new(self.handle.clone())
    }
    pub fn start_replication_task(&self) -> fluent_builders::StartReplicationTask<C> {
        fluent_builders::StartReplicationTask::new(self.handle.clone())
    }
    pub fn start_replication_task_assessment(
        &self,
    ) -> fluent_builders::StartReplicationTaskAssessment<C> {
        fluent_builders::StartReplicationTaskAssessment::new(self.handle.clone())
    }
    pub fn start_replication_task_assessment_run(
        &self,
    ) -> fluent_builders::StartReplicationTaskAssessmentRun<C> {
        fluent_builders::StartReplicationTaskAssessmentRun::new(self.handle.clone())
    }
    pub fn stop_replication_task(&self) -> fluent_builders::StopReplicationTask<C> {
        fluent_builders::StopReplicationTask::new(self.handle.clone())
    }
    pub fn test_connection(&self) -> fluent_builders::TestConnection<C> {
        fluent_builders::TestConnection::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AddTagsToResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_tags_to_resource_input::Builder,
    }
    impl<C> AddTagsToResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddTagsToResourceOutput,
            smithy_http::result::SdkError<crate::error::AddTagsToResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Identifies the AWS DMS resource to which tags should be added. The value for this parameter is an Amazon Resource Name (ARN).</p>
        /// <p>For AWS DMS, you can tag a replication instance, an endpoint, or a replication task.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>One or more tags to be assigned to the resource.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ApplyPendingMaintenanceAction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::apply_pending_maintenance_action_input::Builder,
    }
    impl<C> ApplyPendingMaintenanceAction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ApplyPendingMaintenanceActionOutput,
            smithy_http::result::SdkError<crate::error::ApplyPendingMaintenanceActionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS DMS resource that the pending maintenance
        /// action applies to.</p>
        pub fn replication_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_instance_arn(input);
            self
        }
        pub fn set_replication_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_instance_arn(input);
            self
        }
        /// <p>The pending maintenance action to apply to this resource.</p>
        pub fn apply_action(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.apply_action(input);
            self
        }
        pub fn set_apply_action(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_apply_action(input);
            self
        }
        /// <p>A value that specifies the type of opt-in request, or undoes an opt-in request. You can't undo an
        /// opt-in request of type <code>immediate</code>.</p>
        /// <p>Valid values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>immediate</code> - Apply the maintenance action immediately.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>next-maintenance</code> - Apply the maintenance action during the next
        /// maintenance window for the resource.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>undo-opt-in</code> - Cancel any existing <code>next-maintenance</code> opt-in
        /// requests.</p>
        /// </li>
        /// </ul>
        pub fn opt_in_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.opt_in_type(input);
            self
        }
        pub fn set_opt_in_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_opt_in_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelReplicationTaskAssessmentRun<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_replication_task_assessment_run_input::Builder,
    }
    impl<C> CancelReplicationTaskAssessmentRun<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelReplicationTaskAssessmentRunOutput,
            smithy_http::result::SdkError<crate::error::CancelReplicationTaskAssessmentRunError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name (ARN) of the premigration assessment run to be canceled.</p>
        pub fn replication_task_assessment_run_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.replication_task_assessment_run_arn(input);
            self
        }
        pub fn set_replication_task_assessment_run_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_task_assessment_run_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateEndpoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_endpoint_input::Builder,
    }
    impl<C> CreateEndpoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateEndpointOutput,
            smithy_http::result::SdkError<crate::error::CreateEndpointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The database endpoint identifier. Identifiers must begin with a letter and must contain
        /// only ASCII letters, digits, and hyphens. They can't end with a hyphen, or contain two
        /// consecutive hyphens.</p>
        pub fn endpoint_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.endpoint_identifier(input);
            self
        }
        pub fn set_endpoint_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_endpoint_identifier(input);
            self
        }
        /// <p>The type of endpoint.  Valid values are <code>source</code> and <code>target</code>.</p>
        pub fn endpoint_type(mut self, input: crate::model::ReplicationEndpointTypeValue) -> Self {
            self.inner = self.inner.endpoint_type(input);
            self
        }
        pub fn set_endpoint_type(
            mut self,
            input: std::option::Option<crate::model::ReplicationEndpointTypeValue>,
        ) -> Self {
            self.inner = self.inner.set_endpoint_type(input);
            self
        }
        /// <p>The type of engine for the endpoint. Valid values, depending on the
        /// <code>EndpointType</code> value, include <code>"mysql"</code>, <code>"oracle"</code>,
        /// <code>"postgres"</code>, <code>"mariadb"</code>, <code>"aurora"</code>,
        /// <code>"aurora-postgresql"</code>, <code>"redshift"</code>, <code>"s3"</code>,
        /// <code>"db2"</code>, <code>"azuredb"</code>, <code>"sybase"</code>, <code>"dynamodb"</code>, <code>"mongodb"</code>,
        /// <code>"kinesis"</code>, <code>"kafka"</code>, <code>"elasticsearch"</code>, <code>"docdb"</code>,
        /// <code>"sqlserver"</code>, and <code>"neptune"</code>.</p>
        pub fn engine_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.engine_name(input);
            self
        }
        pub fn set_engine_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_engine_name(input);
            self
        }
        /// <p>The user name to be used to log in to the endpoint database.</p>
        pub fn username(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.username(input);
            self
        }
        pub fn set_username(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_username(input);
            self
        }
        /// <p>The password to be used to log in to the endpoint database.</p>
        pub fn password(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.password(input);
            self
        }
        pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_password(input);
            self
        }
        /// <p>The name of the server where the endpoint database resides.</p>
        pub fn server_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_name(input);
            self
        }
        pub fn set_server_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_name(input);
            self
        }
        /// <p>The port used by the endpoint database.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.inner = self.inner.port(input);
            self
        }
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_port(input);
            self
        }
        /// <p>The name of the endpoint database.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>Additional attributes associated with the connection. Each attribute is specified as a
        /// name-value pair associated by an equal sign (=). Multiple attributes are separated by a
        /// semicolon (;) with no additional white space. For information on the attributes available
        /// for connecting your source or target endpoint, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Endpoints.html">Working with
        /// AWS DMS Endpoints</a> in the <i>AWS Database Migration Service User
        /// Guide.</i>
        /// </p>
        pub fn extra_connection_attributes(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.extra_connection_attributes(input);
            self
        }
        pub fn set_extra_connection_attributes(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_extra_connection_attributes(input);
            self
        }
        /// <p>An AWS KMS key identifier that is used to encrypt the connection parameters for the endpoint.</p>
        /// <p>If you don't specify a value for the <code>KmsKeyId</code> parameter, then
        /// AWS DMS uses your default encryption key.</p>
        /// <p>AWS KMS creates the default encryption key for your AWS account. Your AWS account has a
        /// different default encryption key for each AWS Region.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_id(input);
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_id(input);
            self
        }
        /// <p>One or more tags to be assigned to the endpoint.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the certificate.</p>
        pub fn certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(input);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
        /// <p>The Secure Sockets Layer (SSL) mode to use for the SSL connection. The default is <code>none</code>
        /// </p>
        pub fn ssl_mode(mut self, input: crate::model::DmsSslModeValue) -> Self {
            self.inner = self.inner.ssl_mode(input);
            self
        }
        pub fn set_ssl_mode(
            mut self,
            input: std::option::Option<crate::model::DmsSslModeValue>,
        ) -> Self {
            self.inner = self.inner.set_ssl_mode(input);
            self
        }
        /// <p> The Amazon Resource Name (ARN) for the service access role that you want to use to
        /// create the endpoint. </p>
        pub fn service_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_access_role_arn(input);
            self
        }
        pub fn set_service_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_service_access_role_arn(input);
            self
        }
        /// <p>The external table definition. </p>
        pub fn external_table_definition(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.external_table_definition(input);
            self
        }
        pub fn set_external_table_definition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_external_table_definition(input);
            self
        }
        /// <p>Settings in JSON format for the target Amazon DynamoDB endpoint. For information about other
        /// available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.DynamoDB.html">Using Object Mapping to Migrate
        /// Data to DynamoDB</a> in the <i>AWS Database Migration Service User
        /// Guide.</i>
        /// </p>
        pub fn dynamo_db_settings(mut self, input: crate::model::DynamoDbSettings) -> Self {
            self.inner = self.inner.dynamo_db_settings(input);
            self
        }
        pub fn set_dynamo_db_settings(
            mut self,
            input: std::option::Option<crate::model::DynamoDbSettings>,
        ) -> Self {
            self.inner = self.inner.set_dynamo_db_settings(input);
            self
        }
        /// <p>Settings in JSON format for the target Amazon S3 endpoint. For more information about
        /// the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring">Extra
        /// Connection Attributes When Using Amazon S3 as a Target for AWS DMS</a> in the
        /// <i>AWS Database Migration Service User Guide.</i>
        /// </p>
        pub fn s3_settings(mut self, input: crate::model::S3Settings) -> Self {
            self.inner = self.inner.s3_settings(input);
            self
        }
        pub fn set_s3_settings(
            mut self,
            input: std::option::Option<crate::model::S3Settings>,
        ) -> Self {
            self.inner = self.inner.set_s3_settings(input);
            self
        }
        /// <p>The settings in JSON format for the DMS transfer type of source endpoint. </p>
        /// <p>Possible settings include the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ServiceAccessRoleArn</code> - The IAM role that has permission to access the
        /// Amazon S3 bucket.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>BucketName</code> - The name of the S3 bucket to use.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>CompressionType</code> - An optional parameter to use GZIP to compress the
        /// target files. To use GZIP, set this value to <code>NONE</code> (the default). To keep
        /// the files uncompressed, don't use this value.</p>
        /// </li>
        /// </ul>
        /// <p>Shorthand syntax for these settings is as follows:
        /// <code>ServiceAccessRoleArn=string,BucketName=string,CompressionType=string</code>
        /// </p>
        /// <p>JSON syntax for these settings is as follows: <code>{ "ServiceAccessRoleArn":
        /// "string", "BucketName": "string", "CompressionType": "none"|"gzip" } </code>
        /// </p>
        pub fn dms_transfer_settings(mut self, input: crate::model::DmsTransferSettings) -> Self {
            self.inner = self.inner.dms_transfer_settings(input);
            self
        }
        pub fn set_dms_transfer_settings(
            mut self,
            input: std::option::Option<crate::model::DmsTransferSettings>,
        ) -> Self {
            self.inner = self.inner.set_dms_transfer_settings(input);
            self
        }
        /// <p>Settings in JSON format for the source MongoDB endpoint. For more information about the
        /// available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.MongoDB.html#CHAP_Source.MongoDB.Configuration">Using MongoDB as a Target for AWS Database Migration Service</a> in the
        /// <i>AWS Database Migration Service User Guide.</i>
        /// </p>
        pub fn mongo_db_settings(mut self, input: crate::model::MongoDbSettings) -> Self {
            self.inner = self.inner.mongo_db_settings(input);
            self
        }
        pub fn set_mongo_db_settings(
            mut self,
            input: std::option::Option<crate::model::MongoDbSettings>,
        ) -> Self {
            self.inner = self.inner.set_mongo_db_settings(input);
            self
        }
        /// <p>Settings in JSON format for the target endpoint for Amazon Kinesis Data Streams. For
        /// more information about the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kinesis.html">Using Amazon Kinesis Data Streams
        /// as a Target for AWS Database Migration Service</a> in the <i>AWS Database Migration Service User
        /// Guide.</i>
        /// </p>
        pub fn kinesis_settings(mut self, input: crate::model::KinesisSettings) -> Self {
            self.inner = self.inner.kinesis_settings(input);
            self
        }
        pub fn set_kinesis_settings(
            mut self,
            input: std::option::Option<crate::model::KinesisSettings>,
        ) -> Self {
            self.inner = self.inner.set_kinesis_settings(input);
            self
        }
        /// <p>Settings in JSON format for the target Apache Kafka endpoint. For more information about
        /// the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kafka.html">Using Apache Kafka as a Target for
        /// AWS Database Migration Service</a> in the <i>AWS Database Migration Service User
        /// Guide.</i>
        /// </p>
        pub fn kafka_settings(mut self, input: crate::model::KafkaSettings) -> Self {
            self.inner = self.inner.kafka_settings(input);
            self
        }
        pub fn set_kafka_settings(
            mut self,
            input: std::option::Option<crate::model::KafkaSettings>,
        ) -> Self {
            self.inner = self.inner.set_kafka_settings(input);
            self
        }
        /// <p>Settings in JSON format for the target Elasticsearch endpoint. For more information
        /// about the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Elasticsearch.html#CHAP_Target.Elasticsearch.Configuration">Extra Connection Attributes When Using Elasticsearch as a Target for AWS DMS</a> in
        /// the <i>AWS Database Migration Service User Guide</i>.</p>
        pub fn elasticsearch_settings(
            mut self,
            input: crate::model::ElasticsearchSettings,
        ) -> Self {
            self.inner = self.inner.elasticsearch_settings(input);
            self
        }
        pub fn set_elasticsearch_settings(
            mut self,
            input: std::option::Option<crate::model::ElasticsearchSettings>,
        ) -> Self {
            self.inner = self.inner.set_elasticsearch_settings(input);
            self
        }
        /// <p>Settings in JSON format for the target Amazon Neptune endpoint.
        /// For more information
        /// about the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Neptune.html#CHAP_Target.Neptune.EndpointSettings">Specifying Endpoint Settings for Amazon Neptune as a Target</a>
        /// in the <i>AWS Database Migration Service User Guide.</i>
        /// </p>
        pub fn neptune_settings(mut self, input: crate::model::NeptuneSettings) -> Self {
            self.inner = self.inner.neptune_settings(input);
            self
        }
        pub fn set_neptune_settings(
            mut self,
            input: std::option::Option<crate::model::NeptuneSettings>,
        ) -> Self {
            self.inner = self.inner.set_neptune_settings(input);
            self
        }
        /// <p>Provides information that defines an Amazon Redshift endpoint.</p>
        pub fn redshift_settings(mut self, input: crate::model::RedshiftSettings) -> Self {
            self.inner = self.inner.redshift_settings(input);
            self
        }
        pub fn set_redshift_settings(
            mut self,
            input: std::option::Option<crate::model::RedshiftSettings>,
        ) -> Self {
            self.inner = self.inner.set_redshift_settings(input);
            self
        }
        /// <p>Settings in JSON format for the source and target PostgreSQL endpoint. For information
        /// about other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html">Extra connection
        /// attributes when using PostgreSQL as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.PostgreSQL.html">
        /// Extra connection attributes when using PostgreSQL as a target for AWS DMS</a> in the
        /// <i>AWS Database Migration Service User Guide.</i>
        /// </p>
        pub fn postgre_sql_settings(mut self, input: crate::model::PostgreSqlSettings) -> Self {
            self.inner = self.inner.postgre_sql_settings(input);
            self
        }
        pub fn set_postgre_sql_settings(
            mut self,
            input: std::option::Option<crate::model::PostgreSqlSettings>,
        ) -> Self {
            self.inner = self.inner.set_postgre_sql_settings(input);
            self
        }
        /// <p>Settings in JSON format for the source and target MySQL endpoint. For information about
        /// other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.MySQL.html">Extra connection attributes
        /// when using MySQL as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.MySQL.html">Extra connection attributes when using a MySQL-compatible database as a target for AWS DMS</a> in
        /// the <i>AWS Database Migration Service User Guide.</i>
        /// </p>
        pub fn my_sql_settings(mut self, input: crate::model::MySqlSettings) -> Self {
            self.inner = self.inner.my_sql_settings(input);
            self
        }
        pub fn set_my_sql_settings(
            mut self,
            input: std::option::Option<crate::model::MySqlSettings>,
        ) -> Self {
            self.inner = self.inner.set_my_sql_settings(input);
            self
        }
        /// <p>Settings in JSON format for the source and target Oracle endpoint. For information about
        /// other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html">Extra connection attributes
        /// when using Oracle as a source for AWS DMS</a> and
        /// <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Oracle.html">
        /// Extra connection attributes when using Oracle as a target for AWS DMS</a>
        /// in the <i>AWS Database Migration Service User Guide.</i>
        /// </p>
        pub fn oracle_settings(mut self, input: crate::model::OracleSettings) -> Self {
            self.inner = self.inner.oracle_settings(input);
            self
        }
        pub fn set_oracle_settings(
            mut self,
            input: std::option::Option<crate::model::OracleSettings>,
        ) -> Self {
            self.inner = self.inner.set_oracle_settings(input);
            self
        }
        /// <p>Settings in JSON format for the source and target SAP ASE endpoint. For information
        /// about other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.SAP.html">Extra connection attributes
        /// when using SAP ASE as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.SAP.html">Extra connection attributes
        /// when using SAP ASE as a target for AWS DMS</a> in the <i>AWS Database
        /// Migration Service User Guide.</i>
        /// </p>
        pub fn sybase_settings(mut self, input: crate::model::SybaseSettings) -> Self {
            self.inner = self.inner.sybase_settings(input);
            self
        }
        pub fn set_sybase_settings(
            mut self,
            input: std::option::Option<crate::model::SybaseSettings>,
        ) -> Self {
            self.inner = self.inner.set_sybase_settings(input);
            self
        }
        /// <p>Settings in JSON format for the source and target Microsoft SQL Server endpoint. For
        /// information about other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.SQLServer.html">Extra connection
        /// attributes when using SQL Server as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.SQLServer.html">
        /// Extra connection attributes when using SQL Server as a target for AWS DMS</a> in the
        /// <i>AWS Database Migration Service User Guide.</i>
        /// </p>
        pub fn microsoft_sql_server_settings(
            mut self,
            input: crate::model::MicrosoftSqlServerSettings,
        ) -> Self {
            self.inner = self.inner.microsoft_sql_server_settings(input);
            self
        }
        pub fn set_microsoft_sql_server_settings(
            mut self,
            input: std::option::Option<crate::model::MicrosoftSqlServerSettings>,
        ) -> Self {
            self.inner = self.inner.set_microsoft_sql_server_settings(input);
            self
        }
        /// <p>Settings in JSON format for the source IBM Db2 LUW endpoint. For information about other
        /// available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.DB2.html">Extra connection attributes
        /// when using Db2 LUW as a source for AWS DMS</a> in the <i>AWS Database
        /// Migration Service User Guide.</i>
        /// </p>
        pub fn ibm_db2_settings(mut self, input: crate::model::IbmDb2Settings) -> Self {
            self.inner = self.inner.ibm_db2_settings(input);
            self
        }
        pub fn set_ibm_db2_settings(
            mut self,
            input: std::option::Option<crate::model::IbmDb2Settings>,
        ) -> Self {
            self.inner = self.inner.set_ibm_db2_settings(input);
            self
        }
        /// <p>A friendly name for the resource identifier at the end of the <code>EndpointArn</code>
        /// response parameter that is returned in the created <code>Endpoint</code> object. The value
        /// for this parameter can have up to 31 characters. It can contain only ASCII letters, digits,
        /// and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens,
        /// and can only begin with a letter, such as <code>Example-App-ARN1</code>. For example, this
        /// value might result in the <code>EndpointArn</code> value
        /// <code>arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1</code>. If you don't
        /// specify a <code>ResourceIdentifier</code> value, AWS DMS generates a default identifier
        /// value for the end of <code>EndpointArn</code>.</p>
        pub fn resource_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_identifier(input);
            self
        }
        pub fn set_resource_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resource_identifier(input);
            self
        }
        /// <p>Provides information that defines a DocumentDB endpoint.</p>
        pub fn doc_db_settings(mut self, input: crate::model::DocDbSettings) -> Self {
            self.inner = self.inner.doc_db_settings(input);
            self
        }
        pub fn set_doc_db_settings(
            mut self,
            input: std::option::Option<crate::model::DocDbSettings>,
        ) -> Self {
            self.inner = self.inner.set_doc_db_settings(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateEventSubscription<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_event_subscription_input::Builder,
    }
    impl<C> CreateEventSubscription<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateEventSubscriptionOutput,
            smithy_http::result::SdkError<crate::error::CreateEventSubscriptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the AWS DMS event notification subscription. This name must be less than 255 characters.</p>
        pub fn subscription_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subscription_name(input);
            self
        }
        pub fn set_subscription_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_subscription_name(input);
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the Amazon SNS topic created for event notification.
        /// The ARN is created by Amazon SNS when you create a topic and subscribe to it. </p>
        pub fn sns_topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sns_topic_arn(input);
            self
        }
        pub fn set_sns_topic_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sns_topic_arn(input);
            self
        }
        /// <p> The type of AWS DMS resource that generates the events. For example, if you want to be
        /// notified of events generated by a replication instance, you set this parameter to
        /// <code>replication-instance</code>. If this value isn't specified, all events are
        /// returned. </p>
        /// <p>Valid values: <code>replication-instance</code> | <code>replication-task</code>
        /// </p>
        pub fn source_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_type(input);
            self
        }
        pub fn set_source_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_source_type(input);
            self
        }
        /// <p>A list of event categories for a source type that you want to subscribe to. For more
        /// information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Events.html">Working with Events and
        /// Notifications</a> in the <i>AWS Database Migration Service User
        /// Guide.</i>
        /// </p>
        pub fn event_categories(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.event_categories(inp);
            self
        }
        pub fn set_event_categories(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_event_categories(input);
            self
        }
        /// <p>A list of identifiers for which AWS DMS provides notification events.</p>
        /// <p>If you don't specify a value, notifications are provided for all sources.</p>
        /// <p>If you specify multiple values, they must be of the same type. For example, if you
        /// specify a database instance ID, then all of the other values must be database instance
        /// IDs.</p>
        pub fn source_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_ids(inp);
            self
        }
        pub fn set_source_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_source_ids(input);
            self
        }
        /// <p> A Boolean value; set to <code>true</code> to activate the subscription, or set to
        /// <code>false</code> to create the subscription but not activate it. </p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.enabled(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_enabled(input);
            self
        }
        /// <p>One or more tags to be assigned to the event subscription.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateReplicationInstance<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_replication_instance_input::Builder,
    }
    impl<C> CreateReplicationInstance<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateReplicationInstanceOutput,
            smithy_http::result::SdkError<crate::error::CreateReplicationInstanceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The replication instance identifier. This parameter is stored as a lowercase
        /// string.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must contain 1-63 alphanumeric characters or hyphens.</p>
        /// </li>
        /// <li>
        /// <p>First character must be a letter.</p>
        /// </li>
        /// <li>
        /// <p>Can't end with a hyphen or contain two consecutive hyphens.</p>
        /// </li>
        /// </ul>
        /// <p>Example: <code>myrepinstance</code>
        /// </p>
        pub fn replication_instance_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.replication_instance_identifier(input);
            self
        }
        pub fn set_replication_instance_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_instance_identifier(input);
            self
        }
        /// <p>The amount of storage (in gigabytes) to be initially allocated for the replication
        /// instance.</p>
        pub fn allocated_storage(mut self, input: i32) -> Self {
            self.inner = self.inner.allocated_storage(input);
            self
        }
        pub fn set_allocated_storage(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_allocated_storage(input);
            self
        }
        /// <p>The compute and memory capacity of the replication instance as defined for the specified
        /// replication instance class. For example to specify the instance class dms.c4.large, set this parameter to <code>"dms.c4.large"</code>.</p>
        /// <p>For more information on the settings and capacities for the available replication instance classes, see
        /// <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth">
        /// Selecting the right AWS DMS replication instance for your migration</a>.
        /// </p>
        pub fn replication_instance_class(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_instance_class(input);
            self
        }
        pub fn set_replication_instance_class(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_instance_class(input);
            self
        }
        /// <p> Specifies the VPC security group to be used with the replication instance. The VPC
        /// security group must work with the VPC containing the replication instance. </p>
        pub fn vpc_security_group_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_security_group_ids(inp);
            self
        }
        pub fn set_vpc_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_vpc_security_group_ids(input);
            self
        }
        /// <p>The Availability Zone where the replication instance will be created. The default
        /// value is a random, system-chosen Availability Zone in the endpoint's AWS Region, for
        /// example: <code>us-east-1d</code>
        /// </p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zone(input);
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_availability_zone(input);
            self
        }
        /// <p>A subnet group to associate with the replication instance.</p>
        pub fn replication_subnet_group_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.replication_subnet_group_identifier(input);
            self
        }
        pub fn set_replication_subnet_group_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_subnet_group_identifier(input);
            self
        }
        /// <p>The weekly time range during which system maintenance can occur, in Universal
        /// Coordinated Time (UTC).</p>
        /// <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code>
        /// </p>
        /// <p>Default: A 30-minute window selected at random from an 8-hour block of time per AWS
        /// Region, occurring on a random day of the week.</p>
        /// <p>Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun</p>
        /// <p>Constraints: Minimum 30-minute window.</p>
        pub fn preferred_maintenance_window(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.preferred_maintenance_window(input);
            self
        }
        pub fn set_preferred_maintenance_window(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_preferred_maintenance_window(input);
            self
        }
        /// <p> Specifies whether the replication instance is a Multi-AZ deployment. You can't set the
        /// <code>AvailabilityZone</code> parameter if the Multi-AZ parameter is set to
        /// <code>true</code>. </p>
        pub fn multi_az(mut self, input: bool) -> Self {
            self.inner = self.inner.multi_az(input);
            self
        }
        pub fn set_multi_az(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_multi_az(input);
            self
        }
        /// <p>The engine version number of the replication instance.</p>
        /// <p>If an engine version number is not specified when a replication
        /// instance is created, the default is the latest engine version available.</p>
        pub fn engine_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.engine_version(input);
            self
        }
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_engine_version(input);
            self
        }
        /// <p>A value that indicates whether minor engine upgrades are applied automatically to the
        /// replication instance during the maintenance window. This parameter defaults to
        /// <code>true</code>.</p>
        /// <p>Default: <code>true</code>
        /// </p>
        pub fn auto_minor_version_upgrade(mut self, input: bool) -> Self {
            self.inner = self.inner.auto_minor_version_upgrade(input);
            self
        }
        pub fn set_auto_minor_version_upgrade(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_auto_minor_version_upgrade(input);
            self
        }
        /// <p>One or more tags to be assigned to the replication instance.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>An AWS KMS key identifier that is used to encrypt the data on the replication
        /// instance.</p>
        /// <p>If you don't specify a value for the <code>KmsKeyId</code> parameter, then
        /// AWS DMS uses your default encryption key.</p>
        /// <p>AWS KMS creates the default encryption key for your AWS account. Your AWS account has a
        /// different default encryption key for each AWS Region.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_id(input);
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_id(input);
            self
        }
        /// <p> Specifies the accessibility options for the replication instance. A value of
        /// <code>true</code> represents an instance with a public IP address. A value of
        /// <code>false</code> represents an instance with a private IP address. The default value
        /// is <code>true</code>. </p>
        pub fn publicly_accessible(mut self, input: bool) -> Self {
            self.inner = self.inner.publicly_accessible(input);
            self
        }
        pub fn set_publicly_accessible(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_publicly_accessible(input);
            self
        }
        /// <p>A list of custom DNS name servers supported for the replication instance to access your
        /// on-premise source or target database. This list overrides the default name servers
        /// supported by the replication instance. You can specify a comma-separated list of internet
        /// addresses for up to four on-premise DNS name servers. For example:
        /// <code>"1.1.1.1,2.2.2.2,3.3.3.3,4.4.4.4"</code>
        /// </p>
        pub fn dns_name_servers(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dns_name_servers(input);
            self
        }
        pub fn set_dns_name_servers(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_dns_name_servers(input);
            self
        }
        /// <p>A friendly name for the resource identifier at the end of the <code>EndpointArn</code>
        /// response parameter that is returned in the created <code>Endpoint</code> object. The value
        /// for this parameter can have up to 31 characters. It can contain only ASCII letters, digits,
        /// and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens,
        /// and can only begin with a letter, such as <code>Example-App-ARN1</code>. For example, this
        /// value might result in the <code>EndpointArn</code> value
        /// <code>arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1</code>. If you don't
        /// specify a <code>ResourceIdentifier</code> value, AWS DMS generates a default identifier
        /// value for the end of <code>EndpointArn</code>.</p>
        pub fn resource_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_identifier(input);
            self
        }
        pub fn set_resource_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resource_identifier(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateReplicationSubnetGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_replication_subnet_group_input::Builder,
    }
    impl<C> CreateReplicationSubnetGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateReplicationSubnetGroupOutput,
            smithy_http::result::SdkError<crate::error::CreateReplicationSubnetGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name for the replication subnet group. This value is stored as a lowercase
        /// string.</p>
        /// <p>Constraints: Must contain no more than 255 alphanumeric characters, periods, spaces,
        /// underscores, or hyphens. Must not be "default".</p>
        /// <p>Example: <code>mySubnetgroup</code>
        /// </p>
        pub fn replication_subnet_group_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.replication_subnet_group_identifier(input);
            self
        }
        pub fn set_replication_subnet_group_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_subnet_group_identifier(input);
            self
        }
        /// <p>The description for the subnet group.</p>
        pub fn replication_subnet_group_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.replication_subnet_group_description(input);
            self
        }
        pub fn set_replication_subnet_group_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_subnet_group_description(input);
            self
        }
        /// <p>One or more subnet IDs to be assigned to the subnet group.</p>
        pub fn subnet_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_ids(inp);
            self
        }
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subnet_ids(input);
            self
        }
        /// <p>One or more tags to be assigned to the subnet group.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateReplicationTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_replication_task_input::Builder,
    }
    impl<C> CreateReplicationTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateReplicationTaskOutput,
            smithy_http::result::SdkError<crate::error::CreateReplicationTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An identifier for the replication task.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must contain 1-255 alphanumeric characters or hyphens.</p>
        /// </li>
        /// <li>
        /// <p>First character must be a letter.</p>
        /// </li>
        /// <li>
        /// <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
        /// </li>
        /// </ul>
        pub fn replication_task_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.replication_task_identifier(input);
            self
        }
        pub fn set_replication_task_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_task_identifier(input);
            self
        }
        /// <p>An Amazon Resource Name (ARN) that uniquely identifies the source endpoint.</p>
        pub fn source_endpoint_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_endpoint_arn(input);
            self
        }
        pub fn set_source_endpoint_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_endpoint_arn(input);
            self
        }
        /// <p>An Amazon Resource Name (ARN) that uniquely identifies the target endpoint.</p>
        pub fn target_endpoint_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_endpoint_arn(input);
            self
        }
        pub fn set_target_endpoint_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_endpoint_arn(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a replication instance.</p>
        pub fn replication_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_instance_arn(input);
            self
        }
        pub fn set_replication_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_instance_arn(input);
            self
        }
        /// <p>The migration type. Valid values: <code>full-load</code> | <code>cdc</code> | <code>full-load-and-cdc</code>
        /// </p>
        pub fn migration_type(mut self, input: crate::model::MigrationTypeValue) -> Self {
            self.inner = self.inner.migration_type(input);
            self
        }
        pub fn set_migration_type(
            mut self,
            input: std::option::Option<crate::model::MigrationTypeValue>,
        ) -> Self {
            self.inner = self.inner.set_migration_type(input);
            self
        }
        /// <p>The table mappings for the task, in JSON format. For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TableMapping.html">Using Table
        /// Mapping to Specify Task Settings</a> in the <i>AWS Database Migration Service User
        /// Guide.</i>
        /// </p>
        pub fn table_mappings(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_mappings(input);
            self
        }
        pub fn set_table_mappings(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_table_mappings(input);
            self
        }
        /// <p>Overall settings for the task, in JSON format. For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TaskSettings.html">Specifying Task
        /// Settings for AWS Database Migration Service Tasks</a> in the <i>AWS Database
        /// Migration User Guide.</i>
        /// </p>
        pub fn replication_task_settings(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_task_settings(input);
            self
        }
        pub fn set_replication_task_settings(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_task_settings(input);
            self
        }
        /// <p>Indicates the start time for a change data capture (CDC) operation. Use either
        /// CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start.
        /// Specifying both values results in an error.</p>
        /// <p>Timestamp Example: --cdc-start-time 2018-03-08T12:12:12</p>
        pub fn cdc_start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.cdc_start_time(input);
            self
        }
        pub fn set_cdc_start_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_cdc_start_time(input);
            self
        }
        /// <p>Indicates when you want a change data capture (CDC) operation to start. Use either
        /// CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start.
        /// Specifying both values results in an error.</p>
        /// <p> The value can be in date, checkpoint, or LSN/SCN format.</p>
        /// <p>Date Example: --cdc-start-position 2018-03-08T12:12:12</p>
        /// <p>Checkpoint Example: --cdc-start-position
        /// "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93"</p>
        /// <p>LSN Example: --cdc-start-position mysql-bin-changelog.000024:373</p>
        /// <note>
        /// <p>When you use this task setting with a source PostgreSQL database, a logical
        /// replication slot should already be created and associated with the source endpoint. You
        /// can verify this by setting the <code>slotName</code> extra connection attribute to the
        /// name of this logical replication slot. For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib">Extra Connection Attributes When Using PostgreSQL as a Source
        /// for AWS DMS</a>.</p>
        /// </note>
        pub fn cdc_start_position(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cdc_start_position(input);
            self
        }
        pub fn set_cdc_start_position(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_cdc_start_position(input);
            self
        }
        /// <p>Indicates when you want a change data capture (CDC) operation to stop. The value can be
        /// either server time or commit time.</p>
        /// <p>Server time example: --cdc-stop-position server_time:2018-02-09T12:12:12</p>
        /// <p>Commit time example: --cdc-stop-position commit_time: 2018-02-09T12:12:12 </p>
        pub fn cdc_stop_position(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cdc_stop_position(input);
            self
        }
        pub fn set_cdc_stop_position(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_cdc_stop_position(input);
            self
        }
        /// <p>One or more tags to be assigned to the replication task.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>Supplemental information that the task requires to migrate the data for certain source and target endpoints.
        /// For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.TaskData.html">Specifying Supplemental Data for Task Settings</a> in the
        /// <i>AWS Database Migration Service User Guide.</i>
        /// </p>
        pub fn task_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_data(input);
            self
        }
        pub fn set_task_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_data(input);
            self
        }
        /// <p>A friendly name for the resource identifier at the end of the <code>EndpointArn</code>
        /// response parameter that is returned in the created <code>Endpoint</code> object. The value
        /// for this parameter can have up to 31 characters. It can contain only ASCII letters, digits,
        /// and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens,
        /// and can only begin with a letter, such as <code>Example-App-ARN1</code>. For example, this
        /// value might result in the <code>EndpointArn</code> value
        /// <code>arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1</code>. If you don't
        /// specify a <code>ResourceIdentifier</code> value, AWS DMS generates a default identifier
        /// value for the end of <code>EndpointArn</code>.</p>
        pub fn resource_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_identifier(input);
            self
        }
        pub fn set_resource_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resource_identifier(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_certificate_input::Builder,
    }
    impl<C> DeleteCertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteCertificateOutput,
            smithy_http::result::SdkError<crate::error::DeleteCertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the deleted certificate.</p>
        pub fn certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(input);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteConnection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_connection_input::Builder,
    }
    impl<C> DeleteConnection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteConnectionOutput,
            smithy_http::result::SdkError<crate::error::DeleteConnectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.</p>
        pub fn endpoint_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.endpoint_arn(input);
            self
        }
        pub fn set_endpoint_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_endpoint_arn(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
        pub fn replication_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_instance_arn(input);
            self
        }
        pub fn set_replication_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_instance_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteEndpoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_endpoint_input::Builder,
    }
    impl<C> DeleteEndpoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteEndpointOutput,
            smithy_http::result::SdkError<crate::error::DeleteEndpointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.</p>
        pub fn endpoint_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.endpoint_arn(input);
            self
        }
        pub fn set_endpoint_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_endpoint_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteEventSubscription<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_event_subscription_input::Builder,
    }
    impl<C> DeleteEventSubscription<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteEventSubscriptionOutput,
            smithy_http::result::SdkError<crate::error::DeleteEventSubscriptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the DMS event notification subscription to be deleted.</p>
        pub fn subscription_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subscription_name(input);
            self
        }
        pub fn set_subscription_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_subscription_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteReplicationInstance<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_replication_instance_input::Builder,
    }
    impl<C> DeleteReplicationInstance<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteReplicationInstanceOutput,
            smithy_http::result::SdkError<crate::error::DeleteReplicationInstanceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the replication instance to be deleted.</p>
        pub fn replication_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_instance_arn(input);
            self
        }
        pub fn set_replication_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_instance_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteReplicationSubnetGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_replication_subnet_group_input::Builder,
    }
    impl<C> DeleteReplicationSubnetGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteReplicationSubnetGroupOutput,
            smithy_http::result::SdkError<crate::error::DeleteReplicationSubnetGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The subnet group name of the replication instance.</p>
        pub fn replication_subnet_group_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.replication_subnet_group_identifier(input);
            self
        }
        pub fn set_replication_subnet_group_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_subnet_group_identifier(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteReplicationTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_replication_task_input::Builder,
    }
    impl<C> DeleteReplicationTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteReplicationTaskOutput,
            smithy_http::result::SdkError<crate::error::DeleteReplicationTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the replication task to be deleted.</p>
        pub fn replication_task_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_task_arn(input);
            self
        }
        pub fn set_replication_task_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_task_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteReplicationTaskAssessmentRun<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_replication_task_assessment_run_input::Builder,
    }
    impl<C> DeleteReplicationTaskAssessmentRun<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteReplicationTaskAssessmentRunOutput,
            smithy_http::result::SdkError<crate::error::DeleteReplicationTaskAssessmentRunError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name (ARN) of the premigration assessment run to be deleted.</p>
        pub fn replication_task_assessment_run_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.replication_task_assessment_run_arn(input);
            self
        }
        pub fn set_replication_task_assessment_run_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_task_assessment_run_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAccountAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_account_attributes_input::Builder,
    }
    impl<C> DescribeAccountAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAccountAttributesOutput,
            smithy_http::result::SdkError<crate::error::DescribeAccountAttributesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeApplicableIndividualAssessments<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_applicable_individual_assessments_input::Builder,
    }
    impl<C> DescribeApplicableIndividualAssessments<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeApplicableIndividualAssessmentsOutput,
            smithy_http::result::SdkError<
                crate::error::DescribeApplicableIndividualAssessmentsError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name (ARN) of a migration task on which you want to base
        /// the default list of individual assessments.</p>
        pub fn replication_task_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_task_arn(input);
            self
        }
        pub fn set_replication_task_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_task_arn(input);
            self
        }
        /// <p>ARN of a replication instance on which you want to base the default list of individual
        /// assessments.</p>
        pub fn replication_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_instance_arn(input);
            self
        }
        pub fn set_replication_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_instance_arn(input);
            self
        }
        /// <p>Name of a database engine that the specified replication instance supports as a source.</p>
        pub fn source_engine_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_engine_name(input);
            self
        }
        pub fn set_source_engine_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_engine_name(input);
            self
        }
        /// <p>Name of a database engine that the specified replication instance supports as a target.</p>
        pub fn target_engine_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_engine_name(input);
            self
        }
        pub fn set_target_engine_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_engine_name(input);
            self
        }
        /// <p>Name of the migration type that each provided individual assessment must support.</p>
        pub fn migration_type(mut self, input: crate::model::MigrationTypeValue) -> Self {
            self.inner = self.inner.migration_type(input);
            self
        }
        pub fn set_migration_type(
            mut self,
            input: std::option::Option<crate::model::MigrationTypeValue>,
        ) -> Self {
            self.inner = self.inner.set_migration_type(input);
            self
        }
        /// <p>Maximum number of records to include in the response. If more records exist than the
        /// specified <code>MaxRecords</code> value, a pagination token called a marker is included in
        /// the response so that the remaining results can be retrieved.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
        /// <p>Optional pagination token provided by a previous request. If this parameter is
        /// specified, the response includes only records beyond the marker, up to the value specified
        /// by <code>MaxRecords</code>.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeCertificates<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_certificates_input::Builder,
    }
    impl<C> DescribeCertificates<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeCertificatesOutput,
            smithy_http::result::SdkError<crate::error::DescribeCertificatesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Filters applied to the certificates described in the form of key-value pairs.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p> The maximum number of records to include in the response. If more records exist than
        /// the specified <code>MaxRecords</code> value, a pagination token called a marker is included
        /// in the response so that the remaining results can be retrieved. </p>
        /// <p>Default: 10</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
        /// <p> An optional pagination token provided by a previous request. If this parameter is
        /// specified, the response includes only records beyond the marker, up to the value specified
        /// by <code>MaxRecords</code>. </p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeConnections<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_connections_input::Builder,
    }
    impl<C> DescribeConnections<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeConnectionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeConnectionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The filters applied to the connection.</p>
        /// <p>Valid filter names: endpoint-arn | replication-instance-arn</p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p> The maximum number of records to include in the response. If more records exist than
        /// the specified <code>MaxRecords</code> value, a pagination token called a marker is included
        /// in the response so that the remaining results can be retrieved. </p>
        /// <p>Default: 100</p>
        /// <p>Constraints: Minimum 20, maximum 100.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
        /// <p> An optional pagination token provided by a previous request. If this parameter is
        /// specified, the response includes only records beyond the marker, up to the value specified
        /// by <code>MaxRecords</code>. </p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeEndpoints<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_endpoints_input::Builder,
    }
    impl<C> DescribeEndpoints<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeEndpointsOutput,
            smithy_http::result::SdkError<crate::error::DescribeEndpointsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Filters applied to the endpoints.</p>
        /// <p>Valid filter names: endpoint-arn | endpoint-type | endpoint-id | engine-name</p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p> The maximum number of records to include in the response. If more records exist than
        /// the specified <code>MaxRecords</code> value, a pagination token called a marker is included
        /// in the response so that the remaining results can be retrieved. </p>
        /// <p>Default: 100</p>
        /// <p>Constraints: Minimum 20, maximum 100.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
        /// <p> An optional pagination token provided by a previous request. If this parameter is
        /// specified, the response includes only records beyond the marker, up to the value specified
        /// by <code>MaxRecords</code>. </p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeEndpointSettings<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_endpoint_settings_input::Builder,
    }
    impl<C> DescribeEndpointSettings<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeEndpointSettingsOutput,
            smithy_http::result::SdkError<crate::error::DescribeEndpointSettingsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The databse engine used for your source or target endpoint.</p>
        pub fn engine_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.engine_name(input);
            self
        }
        pub fn set_engine_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_engine_name(input);
            self
        }
        /// <p>The maximum number of records to include in the response. If more records exist than
        /// the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response
        /// so that the remaining results can be retrieved.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
        /// <p>An optional pagination token provided by a previous request. If this parameter is specified,
        /// the response includes only records beyond the marker, up to the value specified by <code>MaxRecords</code>.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeEndpointTypes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_endpoint_types_input::Builder,
    }
    impl<C> DescribeEndpointTypes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeEndpointTypesOutput,
            smithy_http::result::SdkError<crate::error::DescribeEndpointTypesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Filters applied to the endpoint types.</p>
        /// <p>Valid filter names: engine-name | endpoint-type</p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p> The maximum number of records to include in the response. If more records exist than
        /// the specified <code>MaxRecords</code> value, a pagination token called a marker is included
        /// in the response so that the remaining results can be retrieved. </p>
        /// <p>Default: 100</p>
        /// <p>Constraints: Minimum 20, maximum 100.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
        /// <p> An optional pagination token provided by a previous request. If this parameter is
        /// specified, the response includes only records beyond the marker, up to the value specified
        /// by <code>MaxRecords</code>. </p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeEventCategories<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_event_categories_input::Builder,
    }
    impl<C> DescribeEventCategories<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeEventCategoriesOutput,
            smithy_http::result::SdkError<crate::error::DescribeEventCategoriesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The type of AWS DMS resource that generates events. </p>
        /// <p>Valid values: replication-instance | replication-task</p>
        pub fn source_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_type(input);
            self
        }
        pub fn set_source_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_source_type(input);
            self
        }
        /// <p>Filters applied to the event categories.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeEvents<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_events_input::Builder,
    }
    impl<C> DescribeEvents<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeEventsOutput,
            smithy_http::result::SdkError<crate::error::DescribeEventsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The identifier of an event source.</p>
        pub fn source_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_identifier(input);
            self
        }
        pub fn set_source_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_identifier(input);
            self
        }
        /// <p>The type of AWS DMS resource that generates events.</p>
        /// <p>Valid values: replication-instance | replication-task</p>
        pub fn source_type(mut self, input: crate::model::SourceType) -> Self {
            self.inner = self.inner.source_type(input);
            self
        }
        pub fn set_source_type(
            mut self,
            input: std::option::Option<crate::model::SourceType>,
        ) -> Self {
            self.inner = self.inner.set_source_type(input);
            self
        }
        /// <p>The start time for the events to be listed.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The end time for the events to be listed.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>The duration of the events to be listed.</p>
        pub fn duration(mut self, input: i32) -> Self {
            self.inner = self.inner.duration(input);
            self
        }
        pub fn set_duration(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_duration(input);
            self
        }
        /// <p>A list of event categories for the source type that you've chosen.</p>
        pub fn event_categories(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.event_categories(inp);
            self
        }
        pub fn set_event_categories(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_event_categories(input);
            self
        }
        /// <p>Filters applied to events.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p> The maximum number of records to include in the response. If more records exist than
        /// the specified <code>MaxRecords</code> value, a pagination token called a marker is included
        /// in the response so that the remaining results can be retrieved. </p>
        /// <p>Default: 100</p>
        /// <p>Constraints: Minimum 20, maximum 100.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
        /// <p> An optional pagination token provided by a previous request. If this parameter is
        /// specified, the response includes only records beyond the marker, up to the value specified
        /// by <code>MaxRecords</code>. </p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeEventSubscriptions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_event_subscriptions_input::Builder,
    }
    impl<C> DescribeEventSubscriptions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeEventSubscriptionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeEventSubscriptionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the AWS DMS event subscription to be described.</p>
        pub fn subscription_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subscription_name(input);
            self
        }
        pub fn set_subscription_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_subscription_name(input);
            self
        }
        /// <p>Filters applied to event subscriptions.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p> The maximum number of records to include in the response. If more records exist than
        /// the specified <code>MaxRecords</code> value, a pagination token called a marker is included
        /// in the response so that the remaining results can be retrieved. </p>
        /// <p>Default: 100</p>
        /// <p>Constraints: Minimum 20, maximum 100.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
        /// <p> An optional pagination token provided by a previous request. If this parameter is
        /// specified, the response includes only records beyond the marker, up to the value specified
        /// by <code>MaxRecords</code>. </p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeOrderableReplicationInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_orderable_replication_instances_input::Builder,
    }
    impl<C> DescribeOrderableReplicationInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeOrderableReplicationInstancesOutput,
            smithy_http::result::SdkError<crate::error::DescribeOrderableReplicationInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The maximum number of records to include in the response. If more records exist than
        /// the specified <code>MaxRecords</code> value, a pagination token called a marker is included
        /// in the response so that the remaining results can be retrieved. </p>
        /// <p>Default: 100</p>
        /// <p>Constraints: Minimum 20, maximum 100.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
        /// <p> An optional pagination token provided by a previous request. If this parameter is
        /// specified, the response includes only records beyond the marker, up to the value specified
        /// by <code>MaxRecords</code>. </p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribePendingMaintenanceActions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_pending_maintenance_actions_input::Builder,
    }
    impl<C> DescribePendingMaintenanceActions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribePendingMaintenanceActionsOutput,
            smithy_http::result::SdkError<crate::error::DescribePendingMaintenanceActionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
        pub fn replication_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_instance_arn(input);
            self
        }
        pub fn set_replication_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_instance_arn(input);
            self
        }
        /// <p></p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p> An optional pagination token provided by a previous request. If this parameter is
        /// specified, the response includes only records beyond the marker, up to the value specified
        /// by <code>MaxRecords</code>. </p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p> The maximum number of records to include in the response. If more records exist than
        /// the specified <code>MaxRecords</code> value, a pagination token called a marker is included
        /// in the response so that the remaining results can be retrieved. </p>
        /// <p>Default: 100</p>
        /// <p>Constraints: Minimum 20, maximum 100.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeRefreshSchemasStatus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_refresh_schemas_status_input::Builder,
    }
    impl<C> DescribeRefreshSchemasStatus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeRefreshSchemasStatusOutput,
            smithy_http::result::SdkError<crate::error::DescribeRefreshSchemasStatusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.</p>
        pub fn endpoint_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.endpoint_arn(input);
            self
        }
        pub fn set_endpoint_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_endpoint_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeReplicationInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_replication_instances_input::Builder,
    }
    impl<C> DescribeReplicationInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeReplicationInstancesOutput,
            smithy_http::result::SdkError<crate::error::DescribeReplicationInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Filters applied to replication instances.</p>
        /// <p>Valid filter names: replication-instance-arn | replication-instance-id |
        /// replication-instance-class | engine-version</p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p> The maximum number of records to include in the response. If more records exist than
        /// the specified <code>MaxRecords</code> value, a pagination token called a marker is included
        /// in the response so that the remaining results can be retrieved. </p>
        /// <p>Default: 100</p>
        /// <p>Constraints: Minimum 20, maximum 100.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
        /// <p> An optional pagination token provided by a previous request. If this parameter is
        /// specified, the response includes only records beyond the marker, up to the value specified
        /// by <code>MaxRecords</code>. </p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeReplicationInstanceTaskLogs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_replication_instance_task_logs_input::Builder,
    }
    impl<C> DescribeReplicationInstanceTaskLogs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeReplicationInstanceTaskLogsOutput,
            smithy_http::result::SdkError<crate::error::DescribeReplicationInstanceTaskLogsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
        pub fn replication_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_instance_arn(input);
            self
        }
        pub fn set_replication_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_instance_arn(input);
            self
        }
        /// <p> The maximum number of records to include in the response. If more records exist than
        /// the specified <code>MaxRecords</code> value, a pagination token called a marker is included
        /// in the response so that the remaining results can be retrieved. </p>
        /// <p>Default: 100</p>
        /// <p>Constraints: Minimum 20, maximum 100.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
        /// <p> An optional pagination token provided by a previous request. If this parameter is
        /// specified, the response includes only records beyond the marker, up to the value specified
        /// by <code>MaxRecords</code>.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeReplicationSubnetGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_replication_subnet_groups_input::Builder,
    }
    impl<C> DescribeReplicationSubnetGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeReplicationSubnetGroupsOutput,
            smithy_http::result::SdkError<crate::error::DescribeReplicationSubnetGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Filters applied to replication subnet groups.</p>
        /// <p>Valid filter names: replication-subnet-group-id</p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p> The maximum number of records to include in the response. If more records exist than
        /// the specified <code>MaxRecords</code> value, a pagination token called a marker is included
        /// in the response so that the remaining results can be retrieved. </p>
        /// <p>Default: 100</p>
        /// <p>Constraints: Minimum 20, maximum 100.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
        /// <p> An optional pagination token provided by a previous request. If this parameter is
        /// specified, the response includes only records beyond the marker, up to the value specified
        /// by <code>MaxRecords</code>. </p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeReplicationTaskAssessmentResults<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_replication_task_assessment_results_input::Builder,
    }
    impl<C> DescribeReplicationTaskAssessmentResults<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeReplicationTaskAssessmentResultsOutput,
            smithy_http::result::SdkError<
                crate::error::DescribeReplicationTaskAssessmentResultsError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the task. When this input
        /// parameter is specified, the API returns only one result and ignore the values of the
        /// <code>MaxRecords</code> and <code>Marker</code> parameters. </p>
        pub fn replication_task_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_task_arn(input);
            self
        }
        pub fn set_replication_task_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_task_arn(input);
            self
        }
        /// <p> The maximum number of records to include in the response. If more records exist than
        /// the specified <code>MaxRecords</code> value, a pagination token called a marker is included
        /// in the response so that the remaining results can be retrieved. </p>
        /// <p>Default: 100</p>
        /// <p>Constraints: Minimum 20, maximum 100.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
        /// <p> An optional pagination token provided by a previous request. If this parameter is
        /// specified, the response includes only records beyond the marker, up to the value specified
        /// by <code>MaxRecords</code>. </p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeReplicationTaskAssessmentRuns<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_replication_task_assessment_runs_input::Builder,
    }
    impl<C> DescribeReplicationTaskAssessmentRuns<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeReplicationTaskAssessmentRunsOutput,
            smithy_http::result::SdkError<crate::error::DescribeReplicationTaskAssessmentRunsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Filters applied to the premigration assessment runs described in the form of key-value pairs.</p>
        /// <p>Valid filter names: <code>replication-task-assessment-run-arn</code>, <code>replication-task-arn</code>,
        /// <code>replication-instance-arn</code>, <code>status</code>
        /// </p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of records to include in the response. If more records exist than the
        /// specified <code>MaxRecords</code> value, a pagination token called a marker is included in
        /// the response so that the remaining results can be retrieved.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
        /// <p>An optional pagination token provided by a previous request. If this parameter is
        /// specified, the response includes only records beyond the marker, up to the value specified
        /// by <code>MaxRecords</code>.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeReplicationTaskIndividualAssessments<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_replication_task_individual_assessments_input::Builder,
    }
    impl<C> DescribeReplicationTaskIndividualAssessments<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeReplicationTaskIndividualAssessmentsOutput,
            smithy_http::result::SdkError<
                crate::error::DescribeReplicationTaskIndividualAssessmentsError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Filters applied to the individual assessments described in the form of key-value
        /// pairs.</p>
        /// <p>Valid filter names: <code>replication-task-assessment-run-arn</code>,
        /// <code>replication-task-arn</code>, <code>status</code>
        /// </p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of records to include in the response. If more records exist than the
        /// specified <code>MaxRecords</code> value, a pagination token called a marker is included in
        /// the response so that the remaining results can be retrieved.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
        /// <p>An optional pagination token provided by a previous request. If this parameter is
        /// specified, the response includes only records beyond the marker, up to the value specified
        /// by <code>MaxRecords</code>.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeReplicationTasks<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_replication_tasks_input::Builder,
    }
    impl<C> DescribeReplicationTasks<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeReplicationTasksOutput,
            smithy_http::result::SdkError<crate::error::DescribeReplicationTasksError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Filters applied to replication tasks.</p>
        /// <p>Valid filter names: replication-task-arn | replication-task-id | migration-type |
        /// endpoint-arn | replication-instance-arn</p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p> The maximum number of records to include in the response. If more records exist than
        /// the specified <code>MaxRecords</code> value, a pagination token called a marker is included
        /// in the response so that the remaining results can be retrieved. </p>
        /// <p>Default: 100</p>
        /// <p>Constraints: Minimum 20, maximum 100.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
        /// <p> An optional pagination token provided by a previous request. If this parameter is
        /// specified, the response includes only records beyond the marker, up to the value specified
        /// by <code>MaxRecords</code>. </p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>An option to set to avoid returning information about settings. Use this to reduce
        /// overhead when setting information is too large. To use this option, choose
        /// <code>true</code>; otherwise, choose <code>false</code> (the default).</p>
        pub fn without_settings(mut self, input: bool) -> Self {
            self.inner = self.inner.without_settings(input);
            self
        }
        pub fn set_without_settings(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_without_settings(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSchemas<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_schemas_input::Builder,
    }
    impl<C> DescribeSchemas<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSchemasOutput,
            smithy_http::result::SdkError<crate::error::DescribeSchemasError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.</p>
        pub fn endpoint_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.endpoint_arn(input);
            self
        }
        pub fn set_endpoint_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_endpoint_arn(input);
            self
        }
        /// <p> The maximum number of records to include in the response. If more records exist than
        /// the specified <code>MaxRecords</code> value, a pagination token called a marker is included
        /// in the response so that the remaining results can be retrieved. </p>
        /// <p>Default: 100</p>
        /// <p>Constraints: Minimum 20, maximum 100.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
        /// <p> An optional pagination token provided by a previous request. If this parameter is
        /// specified, the response includes only records beyond the marker, up to the value specified
        /// by <code>MaxRecords</code>. </p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTableStatistics<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_table_statistics_input::Builder,
    }
    impl<C> DescribeTableStatistics<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTableStatisticsOutput,
            smithy_http::result::SdkError<crate::error::DescribeTableStatisticsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the replication task.</p>
        pub fn replication_task_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_task_arn(input);
            self
        }
        pub fn set_replication_task_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_task_arn(input);
            self
        }
        /// <p> The maximum number of records to include in the response. If more records exist than
        /// the specified <code>MaxRecords</code> value, a pagination token called a marker is included
        /// in the response so that the remaining results can be retrieved. </p>
        /// <p>Default: 100</p>
        /// <p>Constraints: Minimum 20, maximum 500.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
        /// <p> An optional pagination token provided by a previous request. If this parameter is
        /// specified, the response includes only records beyond the marker, up to the value specified
        /// by <code>MaxRecords</code>. </p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>Filters applied to table statistics.</p>
        /// <p>Valid filter names: schema-name | table-name | table-state</p>
        /// <p>A combination of filters creates an AND condition where each record matches all
        /// specified filters.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ImportCertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::import_certificate_input::Builder,
    }
    impl<C> ImportCertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ImportCertificateOutput,
            smithy_http::result::SdkError<crate::error::ImportCertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A customer-assigned name for the certificate. Identifiers must begin with a letter and
        /// must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or
        /// contain two consecutive hyphens.</p>
        pub fn certificate_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_identifier(input);
            self
        }
        pub fn set_certificate_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_identifier(input);
            self
        }
        /// <p>The contents of a <code>.pem</code> file, which contains an X.509 certificate.</p>
        pub fn certificate_pem(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_pem(input);
            self
        }
        pub fn set_certificate_pem(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_pem(input);
            self
        }
        /// <p>The location of an imported Oracle Wallet certificate for use with SSL.</p>
        pub fn certificate_wallet(mut self, input: smithy_types::Blob) -> Self {
            self.inner = self.inner.certificate_wallet(input);
            self
        }
        pub fn set_certificate_wallet(
            mut self,
            input: std::option::Option<smithy_types::Blob>,
        ) -> Self {
            self.inner = self.inner.set_certificate_wallet(input);
            self
        }
        /// <p>The tags associated with the certificate.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the AWS DMS
        /// resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyEndpoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_endpoint_input::Builder,
    }
    impl<C> ModifyEndpoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyEndpointOutput,
            smithy_http::result::SdkError<crate::error::ModifyEndpointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.</p>
        pub fn endpoint_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.endpoint_arn(input);
            self
        }
        pub fn set_endpoint_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_endpoint_arn(input);
            self
        }
        /// <p>The database endpoint identifier. Identifiers must begin with a letter and must contain
        /// only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two
        /// consecutive hyphens.</p>
        pub fn endpoint_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.endpoint_identifier(input);
            self
        }
        pub fn set_endpoint_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_endpoint_identifier(input);
            self
        }
        /// <p>The type of endpoint.  Valid values are <code>source</code> and <code>target</code>.</p>
        pub fn endpoint_type(mut self, input: crate::model::ReplicationEndpointTypeValue) -> Self {
            self.inner = self.inner.endpoint_type(input);
            self
        }
        pub fn set_endpoint_type(
            mut self,
            input: std::option::Option<crate::model::ReplicationEndpointTypeValue>,
        ) -> Self {
            self.inner = self.inner.set_endpoint_type(input);
            self
        }
        /// <p>The type of engine for the endpoint. Valid values, depending on the EndpointType,
        /// include
        /// <code>"mysql"</code>, <code>"oracle"</code>, <code>"postgres"</code>,
        /// <code>"mariadb"</code>, <code>"aurora"</code>, <code>"aurora-postgresql"</code>,
        /// <code>"redshift"</code>, <code>"s3"</code>, <code>"db2"</code>, <code>"azuredb"</code>,
        /// <code>"sybase"</code>, <code>"dynamodb"</code>, <code>"mongodb"</code>,
        /// <code>"kinesis"</code>, <code>"kafka"</code>, <code>"elasticsearch"</code>,
        /// <code>"documentdb"</code>, <code>"sqlserver"</code>, and <code>"neptune"</code>.</p>
        pub fn engine_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.engine_name(input);
            self
        }
        pub fn set_engine_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_engine_name(input);
            self
        }
        /// <p>The user name to be used to login to the endpoint database.</p>
        pub fn username(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.username(input);
            self
        }
        pub fn set_username(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_username(input);
            self
        }
        /// <p>The password to be used to login to the endpoint database.</p>
        pub fn password(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.password(input);
            self
        }
        pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_password(input);
            self
        }
        /// <p>The name of the server where the endpoint database resides.</p>
        pub fn server_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_name(input);
            self
        }
        pub fn set_server_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_name(input);
            self
        }
        /// <p>The port used by the endpoint database.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.inner = self.inner.port(input);
            self
        }
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_port(input);
            self
        }
        /// <p>The name of the endpoint database.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.database_name(input);
            self
        }
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_database_name(input);
            self
        }
        /// <p>Additional attributes associated with the connection. To reset this parameter, pass the
        /// empty string ("") as an argument.</p>
        pub fn extra_connection_attributes(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.extra_connection_attributes(input);
            self
        }
        pub fn set_extra_connection_attributes(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_extra_connection_attributes(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the certificate used for SSL connection.</p>
        pub fn certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(input);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
        /// <p>The SSL mode used to connect to the endpoint.  The default value is <code>none</code>.</p>
        pub fn ssl_mode(mut self, input: crate::model::DmsSslModeValue) -> Self {
            self.inner = self.inner.ssl_mode(input);
            self
        }
        pub fn set_ssl_mode(
            mut self,
            input: std::option::Option<crate::model::DmsSslModeValue>,
        ) -> Self {
            self.inner = self.inner.set_ssl_mode(input);
            self
        }
        /// <p> The Amazon Resource Name (ARN) for the service access role you want to use to modify
        /// the endpoint. </p>
        pub fn service_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_access_role_arn(input);
            self
        }
        pub fn set_service_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_service_access_role_arn(input);
            self
        }
        /// <p>The external table definition.</p>
        pub fn external_table_definition(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.external_table_definition(input);
            self
        }
        pub fn set_external_table_definition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_external_table_definition(input);
            self
        }
        /// <p>Settings in JSON format for the target Amazon DynamoDB endpoint. For information about other
        /// available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.DynamoDB.html">Using Object Mapping to Migrate
        /// Data to DynamoDB</a> in the <i>AWS Database Migration Service User
        /// Guide.</i>
        /// </p>
        pub fn dynamo_db_settings(mut self, input: crate::model::DynamoDbSettings) -> Self {
            self.inner = self.inner.dynamo_db_settings(input);
            self
        }
        pub fn set_dynamo_db_settings(
            mut self,
            input: std::option::Option<crate::model::DynamoDbSettings>,
        ) -> Self {
            self.inner = self.inner.set_dynamo_db_settings(input);
            self
        }
        /// <p>Settings in JSON format for the target Amazon S3 endpoint. For more information about
        /// the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring">Extra
        /// Connection Attributes When Using Amazon S3 as a Target for AWS DMS</a> in the
        /// <i>AWS Database Migration Service User Guide.</i>
        /// </p>
        pub fn s3_settings(mut self, input: crate::model::S3Settings) -> Self {
            self.inner = self.inner.s3_settings(input);
            self
        }
        pub fn set_s3_settings(
            mut self,
            input: std::option::Option<crate::model::S3Settings>,
        ) -> Self {
            self.inner = self.inner.set_s3_settings(input);
            self
        }
        /// <p>The settings in JSON format for the DMS transfer type of source endpoint. </p>
        /// <p>Attributes include the following:</p>
        /// <ul>
        /// <li>
        /// <p>serviceAccessRoleArn - The AWS Identity and Access Management (IAM) role that has
        /// permission to access the Amazon S3 bucket.</p>
        /// </li>
        /// <li>
        /// <p>BucketName - The name of the S3 bucket to use.</p>
        /// </li>
        /// <li>
        /// <p>compressionType - An optional parameter to use GZIP to compress the target files.
        /// Either set this parameter to NONE (the default) or don't use it to leave the
        /// files uncompressed.</p>
        /// </li>
        /// </ul>
        /// <p>Shorthand syntax for these settings is as follows: <code>ServiceAccessRoleArn=string
        /// ,BucketName=string,CompressionType=string</code>
        /// </p>
        /// <p>JSON syntax for these settings is as follows: <code>{ "ServiceAccessRoleArn": "string",
        /// "BucketName": "string", "CompressionType": "none"|"gzip" } </code>
        /// </p>
        pub fn dms_transfer_settings(mut self, input: crate::model::DmsTransferSettings) -> Self {
            self.inner = self.inner.dms_transfer_settings(input);
            self
        }
        pub fn set_dms_transfer_settings(
            mut self,
            input: std::option::Option<crate::model::DmsTransferSettings>,
        ) -> Self {
            self.inner = self.inner.set_dms_transfer_settings(input);
            self
        }
        /// <p>Settings in JSON format for the source MongoDB endpoint. For more information about the
        /// available settings, see the configuration properties section in <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.MongoDB.html"> Using MongoDB as a Target for AWS
        /// Database Migration Service</a> in the <i>AWS Database Migration Service User
        /// Guide.</i>
        /// </p>
        pub fn mongo_db_settings(mut self, input: crate::model::MongoDbSettings) -> Self {
            self.inner = self.inner.mongo_db_settings(input);
            self
        }
        pub fn set_mongo_db_settings(
            mut self,
            input: std::option::Option<crate::model::MongoDbSettings>,
        ) -> Self {
            self.inner = self.inner.set_mongo_db_settings(input);
            self
        }
        /// <p>Settings in JSON format for the target endpoint for Amazon Kinesis Data Streams. For
        /// more information about the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kinesis.html">Using Amazon Kinesis Data Streams
        /// as a Target for AWS Database Migration Service</a> in the <i>AWS Database Migration Service User
        /// Guide.</i>
        /// </p>
        pub fn kinesis_settings(mut self, input: crate::model::KinesisSettings) -> Self {
            self.inner = self.inner.kinesis_settings(input);
            self
        }
        pub fn set_kinesis_settings(
            mut self,
            input: std::option::Option<crate::model::KinesisSettings>,
        ) -> Self {
            self.inner = self.inner.set_kinesis_settings(input);
            self
        }
        /// <p>Settings in JSON format for the target Apache Kafka endpoint. For more information about
        /// the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kafka.html">Using Apache Kafka as a Target for AWS
        /// Database Migration Service</a> in the <i>AWS Database Migration Service User
        /// Guide.</i>
        /// </p>
        pub fn kafka_settings(mut self, input: crate::model::KafkaSettings) -> Self {
            self.inner = self.inner.kafka_settings(input);
            self
        }
        pub fn set_kafka_settings(
            mut self,
            input: std::option::Option<crate::model::KafkaSettings>,
        ) -> Self {
            self.inner = self.inner.set_kafka_settings(input);
            self
        }
        /// <p>Settings in JSON format for the target Elasticsearch endpoint. For more information
        /// about the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Elasticsearch.html#CHAP_Target.Elasticsearch.Configuration">Extra Connection Attributes When Using Elasticsearch as a Target for AWS DMS</a> in
        /// the <i>AWS Database Migration Service User Guide.</i>
        /// </p>
        pub fn elasticsearch_settings(
            mut self,
            input: crate::model::ElasticsearchSettings,
        ) -> Self {
            self.inner = self.inner.elasticsearch_settings(input);
            self
        }
        pub fn set_elasticsearch_settings(
            mut self,
            input: std::option::Option<crate::model::ElasticsearchSettings>,
        ) -> Self {
            self.inner = self.inner.set_elasticsearch_settings(input);
            self
        }
        /// <p>Settings in JSON format for the target Amazon Neptune endpoint. For more information
        /// about the available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Neptune.html#CHAP_Target.Neptune.EndpointSettings">Specifying Endpoint Settings for Amazon Neptune as a Target</a>
        /// in the <i>AWS Database Migration Service User Guide.</i>
        /// </p>
        pub fn neptune_settings(mut self, input: crate::model::NeptuneSettings) -> Self {
            self.inner = self.inner.neptune_settings(input);
            self
        }
        pub fn set_neptune_settings(
            mut self,
            input: std::option::Option<crate::model::NeptuneSettings>,
        ) -> Self {
            self.inner = self.inner.set_neptune_settings(input);
            self
        }
        /// <p>Provides information that defines an Amazon Redshift endpoint.</p>
        pub fn redshift_settings(mut self, input: crate::model::RedshiftSettings) -> Self {
            self.inner = self.inner.redshift_settings(input);
            self
        }
        pub fn set_redshift_settings(
            mut self,
            input: std::option::Option<crate::model::RedshiftSettings>,
        ) -> Self {
            self.inner = self.inner.set_redshift_settings(input);
            self
        }
        /// <p>Settings in JSON format for the source and target PostgreSQL endpoint. For information
        /// about other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.ConnectionAttrib">Extra connection
        /// attributes when using PostgreSQL as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.PostgreSQL.ConnectionAttrib">
        /// Extra connection attributes when using PostgreSQL as a target for AWS DMS</a> in the
        /// <i>AWS Database Migration Service User Guide.</i>
        /// </p>
        pub fn postgre_sql_settings(mut self, input: crate::model::PostgreSqlSettings) -> Self {
            self.inner = self.inner.postgre_sql_settings(input);
            self
        }
        pub fn set_postgre_sql_settings(
            mut self,
            input: std::option::Option<crate::model::PostgreSqlSettings>,
        ) -> Self {
            self.inner = self.inner.set_postgre_sql_settings(input);
            self
        }
        /// <p>Settings in JSON format for the source and target MySQL endpoint. For information about
        /// other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.MySQL.ConnectionAttrib">Extra connection
        /// attributes when using MySQL as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.MySQL.ConnectionAttrib">Extra
        /// connection attributes when using a MySQL-compatible database as a target for AWS
        /// DMS</a> in the <i>AWS Database Migration Service User
        /// Guide.</i>
        /// </p>
        pub fn my_sql_settings(mut self, input: crate::model::MySqlSettings) -> Self {
            self.inner = self.inner.my_sql_settings(input);
            self
        }
        pub fn set_my_sql_settings(
            mut self,
            input: std::option::Option<crate::model::MySqlSettings>,
        ) -> Self {
            self.inner = self.inner.set_my_sql_settings(input);
            self
        }
        /// <p>Settings in JSON format for the source and target Oracle endpoint. For information about
        /// other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.ConnectionAttrib">Extra connection
        /// attributes when using Oracle as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Oracle.ConnectionAttrib">
        /// Extra connection attributes when using Oracle as a target for AWS DMS</a> in the
        /// <i>AWS Database Migration Service User Guide.</i>
        /// </p>
        pub fn oracle_settings(mut self, input: crate::model::OracleSettings) -> Self {
            self.inner = self.inner.oracle_settings(input);
            self
        }
        pub fn set_oracle_settings(
            mut self,
            input: std::option::Option<crate::model::OracleSettings>,
        ) -> Self {
            self.inner = self.inner.set_oracle_settings(input);
            self
        }
        /// <p>Settings in JSON format for the source and target SAP ASE endpoint. For information
        /// about other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.SAP.ConnectionAttrib">Extra connection attributes
        /// when using SAP ASE as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.SAP.ConnectionAttrib">Extra connection attributes
        /// when using SAP ASE as a target for AWS DMS</a> in the <i>AWS Database
        /// Migration Service User Guide.</i>
        /// </p>
        pub fn sybase_settings(mut self, input: crate::model::SybaseSettings) -> Self {
            self.inner = self.inner.sybase_settings(input);
            self
        }
        pub fn set_sybase_settings(
            mut self,
            input: std::option::Option<crate::model::SybaseSettings>,
        ) -> Self {
            self.inner = self.inner.set_sybase_settings(input);
            self
        }
        /// <p>Settings in JSON format for the source and target Microsoft SQL Server endpoint. For
        /// information about other available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.SQLServer.ConnectionAttrib">Extra connection
        /// attributes when using SQL Server as a source for AWS DMS</a> and <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.SQLServer.ConnectionAttrib">
        /// Extra connection attributes when using SQL Server as a target for AWS DMS</a> in the
        /// <i>AWS Database Migration Service User Guide.</i>
        /// </p>
        pub fn microsoft_sql_server_settings(
            mut self,
            input: crate::model::MicrosoftSqlServerSettings,
        ) -> Self {
            self.inner = self.inner.microsoft_sql_server_settings(input);
            self
        }
        pub fn set_microsoft_sql_server_settings(
            mut self,
            input: std::option::Option<crate::model::MicrosoftSqlServerSettings>,
        ) -> Self {
            self.inner = self.inner.set_microsoft_sql_server_settings(input);
            self
        }
        /// <p>Settings in JSON format for the source IBM Db2 LUW endpoint. For information about other
        /// available settings, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.DB2.ConnectionAttrib">Extra connection attributes
        /// when using Db2 LUW as a source for AWS DMS</a> in the <i>AWS Database
        /// Migration Service User Guide.</i>
        /// </p>
        pub fn ibm_db2_settings(mut self, input: crate::model::IbmDb2Settings) -> Self {
            self.inner = self.inner.ibm_db2_settings(input);
            self
        }
        pub fn set_ibm_db2_settings(
            mut self,
            input: std::option::Option<crate::model::IbmDb2Settings>,
        ) -> Self {
            self.inner = self.inner.set_ibm_db2_settings(input);
            self
        }
        /// <p>Settings in JSON format for the source DocumentDB endpoint. For more information about the
        /// available settings, see the configuration properties section in <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.DocumentDB.html"> Using DocumentDB as a Target for AWS
        /// Database Migration Service</a> in the <i>AWS Database Migration Service User
        /// Guide.</i>
        /// </p>
        pub fn doc_db_settings(mut self, input: crate::model::DocDbSettings) -> Self {
            self.inner = self.inner.doc_db_settings(input);
            self
        }
        pub fn set_doc_db_settings(
            mut self,
            input: std::option::Option<crate::model::DocDbSettings>,
        ) -> Self {
            self.inner = self.inner.set_doc_db_settings(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyEventSubscription<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_event_subscription_input::Builder,
    }
    impl<C> ModifyEventSubscription<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyEventSubscriptionOutput,
            smithy_http::result::SdkError<crate::error::ModifyEventSubscriptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the AWS DMS event notification subscription to be modified.</p>
        pub fn subscription_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subscription_name(input);
            self
        }
        pub fn set_subscription_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_subscription_name(input);
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the Amazon SNS topic created for event notification.
        /// The ARN is created by Amazon SNS when you create a topic and subscribe to it.</p>
        pub fn sns_topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sns_topic_arn(input);
            self
        }
        pub fn set_sns_topic_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sns_topic_arn(input);
            self
        }
        /// <p> The type of AWS DMS resource that generates the events you want to subscribe to. </p>
        /// <p>Valid values: replication-instance | replication-task</p>
        pub fn source_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_type(input);
            self
        }
        pub fn set_source_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_source_type(input);
            self
        }
        /// <p> A list of event categories for a source type that you want to subscribe to. Use the
        /// <code>DescribeEventCategories</code> action to see a list of event categories. </p>
        pub fn event_categories(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.event_categories(inp);
            self
        }
        pub fn set_event_categories(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_event_categories(input);
            self
        }
        /// <p> A Boolean value; set to <b>true</b> to activate the
        /// subscription. </p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.enabled(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_enabled(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyReplicationInstance<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_replication_instance_input::Builder,
    }
    impl<C> ModifyReplicationInstance<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyReplicationInstanceOutput,
            smithy_http::result::SdkError<crate::error::ModifyReplicationInstanceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
        pub fn replication_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_instance_arn(input);
            self
        }
        pub fn set_replication_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_instance_arn(input);
            self
        }
        /// <p>The amount of storage (in gigabytes) to be allocated for the replication
        /// instance.</p>
        pub fn allocated_storage(mut self, input: i32) -> Self {
            self.inner = self.inner.allocated_storage(input);
            self
        }
        pub fn set_allocated_storage(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_allocated_storage(input);
            self
        }
        /// <p>Indicates whether the changes should be applied immediately or during the next
        /// maintenance window.</p>
        pub fn apply_immediately(mut self, input: bool) -> Self {
            self.inner = self.inner.apply_immediately(input);
            self
        }
        pub fn set_apply_immediately(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_apply_immediately(input);
            self
        }
        /// <p>The compute and memory capacity of the replication instance as defined for the specified
        /// replication instance class. For example to specify the instance class dms.c4.large, set this parameter to <code>"dms.c4.large"</code>.</p>
        /// <p>For more information on the settings and capacities for the available replication instance classes, see
        /// <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth">
        /// Selecting the right AWS DMS replication instance for your migration</a>.
        /// </p>
        pub fn replication_instance_class(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_instance_class(input);
            self
        }
        pub fn set_replication_instance_class(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_instance_class(input);
            self
        }
        /// <p> Specifies the VPC security group to be used with the replication instance. The VPC
        /// security group must work with the VPC containing the replication instance. </p>
        pub fn vpc_security_group_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_security_group_ids(inp);
            self
        }
        pub fn set_vpc_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_vpc_security_group_ids(input);
            self
        }
        /// <p>The weekly time range (in UTC) during which system maintenance can occur, which might
        /// result in an outage. Changing this parameter does not result in an outage, except in the
        /// following situation, and the change is asynchronously applied as soon as possible. If
        /// moving this window to the current time, there must be at least 30 minutes between the
        /// current time and end of the window to ensure pending changes are applied.</p>
        /// <p>Default: Uses existing setting</p>
        /// <p>Format: ddd:hh24:mi-ddd:hh24:mi</p>
        /// <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p>
        /// <p>Constraints: Must be at least 30 minutes</p>
        pub fn preferred_maintenance_window(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.preferred_maintenance_window(input);
            self
        }
        pub fn set_preferred_maintenance_window(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_preferred_maintenance_window(input);
            self
        }
        /// <p> Specifies whether the replication instance is a Multi-AZ deployment. You can't set the
        /// <code>AvailabilityZone</code> parameter if the Multi-AZ parameter is set to
        /// <code>true</code>. </p>
        pub fn multi_az(mut self, input: bool) -> Self {
            self.inner = self.inner.multi_az(input);
            self
        }
        pub fn set_multi_az(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_multi_az(input);
            self
        }
        /// <p>The engine version number of the replication instance.</p>
        /// <p>When modifying a major engine version of an instance, also set
        /// <code>AllowMajorVersionUpgrade</code> to <code>true</code>.</p>
        pub fn engine_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.engine_version(input);
            self
        }
        pub fn set_engine_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_engine_version(input);
            self
        }
        /// <p>Indicates that major version upgrades are allowed. Changing this parameter does not
        /// result in an outage, and the change is asynchronously applied as soon as possible.</p>
        /// <p>This parameter must be set to <code>true</code> when specifying a value for the
        /// <code>EngineVersion</code> parameter that is a different major version than the
        /// replication instance's current version.</p>
        pub fn allow_major_version_upgrade(mut self, input: bool) -> Self {
            self.inner = self.inner.allow_major_version_upgrade(input);
            self
        }
        pub fn set_allow_major_version_upgrade(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_allow_major_version_upgrade(input);
            self
        }
        /// <p>A value that indicates that minor version upgrades are applied automatically to the
        /// replication instance during the maintenance window. Changing this parameter doesn't result
        /// in an outage, except in the case described following. The change is asynchronously applied
        /// as soon as possible. </p>
        /// <p>An outage does result if these factors apply: </p>
        /// <ul>
        /// <li>
        /// <p>This parameter is set to <code>true</code> during the maintenance window.</p>
        /// </li>
        /// <li>
        /// <p>A newer minor version is available. </p>
        /// </li>
        /// <li>
        /// <p>AWS DMS has enabled automatic patching for the given engine version. </p>
        /// </li>
        /// </ul>
        pub fn auto_minor_version_upgrade(mut self, input: bool) -> Self {
            self.inner = self.inner.auto_minor_version_upgrade(input);
            self
        }
        pub fn set_auto_minor_version_upgrade(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_auto_minor_version_upgrade(input);
            self
        }
        /// <p>The replication instance identifier. This parameter is stored as a lowercase
        /// string.</p>
        pub fn replication_instance_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.replication_instance_identifier(input);
            self
        }
        pub fn set_replication_instance_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_instance_identifier(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyReplicationSubnetGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_replication_subnet_group_input::Builder,
    }
    impl<C> ModifyReplicationSubnetGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyReplicationSubnetGroupOutput,
            smithy_http::result::SdkError<crate::error::ModifyReplicationSubnetGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the replication instance subnet group.</p>
        pub fn replication_subnet_group_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.replication_subnet_group_identifier(input);
            self
        }
        pub fn set_replication_subnet_group_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_subnet_group_identifier(input);
            self
        }
        /// <p>A description for the replication instance subnet group.</p>
        pub fn replication_subnet_group_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.replication_subnet_group_description(input);
            self
        }
        pub fn set_replication_subnet_group_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_subnet_group_description(input);
            self
        }
        /// <p>A list of subnet IDs.</p>
        pub fn subnet_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_ids(inp);
            self
        }
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subnet_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyReplicationTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_replication_task_input::Builder,
    }
    impl<C> ModifyReplicationTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyReplicationTaskOutput,
            smithy_http::result::SdkError<crate::error::ModifyReplicationTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the replication task.</p>
        pub fn replication_task_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_task_arn(input);
            self
        }
        pub fn set_replication_task_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_task_arn(input);
            self
        }
        /// <p>The replication task identifier.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must contain 1-255 alphanumeric characters or hyphens.</p>
        /// </li>
        /// <li>
        /// <p>First character must be a letter.</p>
        /// </li>
        /// <li>
        /// <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
        /// </li>
        /// </ul>
        pub fn replication_task_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.replication_task_identifier(input);
            self
        }
        pub fn set_replication_task_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_task_identifier(input);
            self
        }
        /// <p>The migration type. Valid values: <code>full-load</code> | <code>cdc</code> | <code>full-load-and-cdc</code>
        /// </p>
        pub fn migration_type(mut self, input: crate::model::MigrationTypeValue) -> Self {
            self.inner = self.inner.migration_type(input);
            self
        }
        pub fn set_migration_type(
            mut self,
            input: std::option::Option<crate::model::MigrationTypeValue>,
        ) -> Self {
            self.inner = self.inner.set_migration_type(input);
            self
        }
        /// <p>When using the AWS CLI or boto3, provide the path of the JSON file that contains the
        /// table mappings. Precede the path with <code>file://</code>.  For example,
        /// <code>--table-mappings file://mappingfile.json</code>. When working with the DMS API,
        /// provide the JSON as the parameter value.
        /// </p>
        pub fn table_mappings(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.table_mappings(input);
            self
        }
        pub fn set_table_mappings(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_table_mappings(input);
            self
        }
        /// <p>JSON file that contains settings for the task, such as task metadata settings.</p>
        pub fn replication_task_settings(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_task_settings(input);
            self
        }
        pub fn set_replication_task_settings(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_task_settings(input);
            self
        }
        /// <p>Indicates the start time for a change data capture (CDC) operation. Use either
        /// CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start.
        /// Specifying both values results in an error.</p>
        /// <p>Timestamp Example: --cdc-start-time 2018-03-08T12:12:12</p>
        pub fn cdc_start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.cdc_start_time(input);
            self
        }
        pub fn set_cdc_start_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_cdc_start_time(input);
            self
        }
        /// <p>Indicates when you want a change data capture (CDC) operation to start. Use either
        /// CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start.
        /// Specifying both values results in an error.</p>
        /// <p> The value can be in date, checkpoint, or LSN/SCN format.</p>
        /// <p>Date Example: --cdc-start-position 2018-03-08T12:12:12</p>
        /// <p>Checkpoint Example: --cdc-start-position
        /// "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93"</p>
        /// <p>LSN Example: --cdc-start-position mysql-bin-changelog.000024:373</p>
        /// <note>
        /// <p>When you use this task setting with a source PostgreSQL database, a logical
        /// replication slot should already be created and associated with the source endpoint. You
        /// can verify this by setting the <code>slotName</code> extra connection attribute to the
        /// name of this logical replication slot. For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib">Extra Connection Attributes When Using PostgreSQL as a Source
        /// for AWS DMS</a>.</p>
        /// </note>
        pub fn cdc_start_position(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cdc_start_position(input);
            self
        }
        pub fn set_cdc_start_position(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_cdc_start_position(input);
            self
        }
        /// <p>Indicates when you want a change data capture (CDC) operation to stop. The value can be
        /// either server time or commit time.</p>
        /// <p>Server time example: --cdc-stop-position server_time:2018-02-09T12:12:12</p>
        /// <p>Commit time example: --cdc-stop-position commit_time: 2018-02-09T12:12:12 </p>
        pub fn cdc_stop_position(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cdc_stop_position(input);
            self
        }
        pub fn set_cdc_stop_position(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_cdc_stop_position(input);
            self
        }
        /// <p>Supplemental information that the task requires to migrate the data for certain source and target endpoints.
        /// For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.TaskData.html">Specifying Supplemental Data for Task Settings</a> in the
        /// <i>AWS Database Migration Service User Guide.</i>
        /// </p>
        pub fn task_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_data(input);
            self
        }
        pub fn set_task_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_data(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct MoveReplicationTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::move_replication_task_input::Builder,
    }
    impl<C> MoveReplicationTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::MoveReplicationTaskOutput,
            smithy_http::result::SdkError<crate::error::MoveReplicationTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the task that you want to move.</p>
        pub fn replication_task_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_task_arn(input);
            self
        }
        pub fn set_replication_task_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_task_arn(input);
            self
        }
        /// <p>The ARN of the replication instance where you want to move the task to.</p>
        pub fn target_replication_instance_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.target_replication_instance_arn(input);
            self
        }
        pub fn set_target_replication_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_replication_instance_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RebootReplicationInstance<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reboot_replication_instance_input::Builder,
    }
    impl<C> RebootReplicationInstance<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RebootReplicationInstanceOutput,
            smithy_http::result::SdkError<crate::error::RebootReplicationInstanceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
        pub fn replication_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_instance_arn(input);
            self
        }
        pub fn set_replication_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_instance_arn(input);
            self
        }
        /// <p>If this parameter is <code>true</code>, the reboot is conducted through a Multi-AZ
        /// failover. (If the instance isn't configured for Multi-AZ, then you can't specify
        /// <code>true</code>.)</p>
        pub fn force_failover(mut self, input: bool) -> Self {
            self.inner = self.inner.force_failover(input);
            self
        }
        pub fn set_force_failover(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force_failover(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RefreshSchemas<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::refresh_schemas_input::Builder,
    }
    impl<C> RefreshSchemas<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RefreshSchemasOutput,
            smithy_http::result::SdkError<crate::error::RefreshSchemasError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.</p>
        pub fn endpoint_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.endpoint_arn(input);
            self
        }
        pub fn set_endpoint_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_endpoint_arn(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
        pub fn replication_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_instance_arn(input);
            self
        }
        pub fn set_replication_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_instance_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ReloadTables<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reload_tables_input::Builder,
    }
    impl<C> ReloadTables<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ReloadTablesOutput,
            smithy_http::result::SdkError<crate::error::ReloadTablesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the replication task. </p>
        pub fn replication_task_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_task_arn(input);
            self
        }
        pub fn set_replication_task_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_task_arn(input);
            self
        }
        /// <p>The name and schema of the table to be reloaded. </p>
        pub fn tables_to_reload(mut self, inp: impl Into<crate::model::TableToReload>) -> Self {
            self.inner = self.inner.tables_to_reload(inp);
            self
        }
        pub fn set_tables_to_reload(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TableToReload>>,
        ) -> Self {
            self.inner = self.inner.set_tables_to_reload(input);
            self
        }
        /// <p>Options for reload. Specify <code>data-reload</code> to reload the data and re-validate
        /// it if validation is enabled. Specify <code>validate-only</code> to re-validate the table.
        /// This option applies only when validation is enabled for the task. </p>
        /// <p>Valid values: data-reload, validate-only</p>
        /// <p>Default value is data-reload.</p>
        pub fn reload_option(mut self, input: crate::model::ReloadOptionValue) -> Self {
            self.inner = self.inner.reload_option(input);
            self
        }
        pub fn set_reload_option(
            mut self,
            input: std::option::Option<crate::model::ReloadOptionValue>,
        ) -> Self {
            self.inner = self.inner.set_reload_option(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveTagsFromResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::remove_tags_from_resource_input::Builder,
    }
    impl<C> RemoveTagsFromResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemoveTagsFromResourceOutput,
            smithy_http::result::SdkError<crate::error::RemoveTagsFromResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An AWS DMS resource from which you want to remove tag(s). The value for this parameter is an Amazon Resource Name (ARN).</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The tag key (name) of the tag to be removed.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartReplicationTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_replication_task_input::Builder,
    }
    impl<C> StartReplicationTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartReplicationTaskOutput,
            smithy_http::result::SdkError<crate::error::StartReplicationTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the replication task to be started.</p>
        pub fn replication_task_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_task_arn(input);
            self
        }
        pub fn set_replication_task_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_task_arn(input);
            self
        }
        /// <p>A type of replication task.</p>
        pub fn start_replication_task_type(
            mut self,
            input: crate::model::StartReplicationTaskTypeValue,
        ) -> Self {
            self.inner = self.inner.start_replication_task_type(input);
            self
        }
        pub fn set_start_replication_task_type(
            mut self,
            input: std::option::Option<crate::model::StartReplicationTaskTypeValue>,
        ) -> Self {
            self.inner = self.inner.set_start_replication_task_type(input);
            self
        }
        /// <p>Indicates the start time for a change data capture (CDC) operation. Use either
        /// CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start.
        /// Specifying both values results in an error.</p>
        /// <p>Timestamp Example: --cdc-start-time 2018-03-08T12:12:12</p>
        pub fn cdc_start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.cdc_start_time(input);
            self
        }
        pub fn set_cdc_start_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_cdc_start_time(input);
            self
        }
        /// <p>Indicates when you want a change data capture (CDC) operation to start. Use either
        /// CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start.
        /// Specifying both values results in an error.</p>
        /// <p> The value can be in date, checkpoint, or LSN/SCN format.</p>
        /// <p>Date Example: --cdc-start-position 2018-03-08T12:12:12</p>
        /// <p>Checkpoint Example: --cdc-start-position
        /// "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93"</p>
        /// <p>LSN Example: --cdc-start-position mysql-bin-changelog.000024:373</p>
        /// <note>
        /// <p>When you use this task setting with a source PostgreSQL database, a logical
        /// replication slot should already be created and associated with the source endpoint. You
        /// can verify this by setting the <code>slotName</code> extra connection attribute to the
        /// name of this logical replication slot. For more information, see <a href="https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib">Extra Connection Attributes When Using PostgreSQL as a Source
        /// for AWS DMS</a>.</p>
        /// </note>
        pub fn cdc_start_position(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cdc_start_position(input);
            self
        }
        pub fn set_cdc_start_position(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_cdc_start_position(input);
            self
        }
        /// <p>Indicates when you want a change data capture (CDC) operation to stop. The value can be
        /// either server time or commit time.</p>
        /// <p>Server time example: --cdc-stop-position server_time:2018-02-09T12:12:12</p>
        /// <p>Commit time example: --cdc-stop-position commit_time: 2018-02-09T12:12:12 </p>
        pub fn cdc_stop_position(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cdc_stop_position(input);
            self
        }
        pub fn set_cdc_stop_position(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_cdc_stop_position(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartReplicationTaskAssessment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_replication_task_assessment_input::Builder,
    }
    impl<C> StartReplicationTaskAssessment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartReplicationTaskAssessmentOutput,
            smithy_http::result::SdkError<crate::error::StartReplicationTaskAssessmentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The Amazon Resource Name (ARN) of the replication task. </p>
        pub fn replication_task_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_task_arn(input);
            self
        }
        pub fn set_replication_task_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_task_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartReplicationTaskAssessmentRun<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_replication_task_assessment_run_input::Builder,
    }
    impl<C> StartReplicationTaskAssessmentRun<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartReplicationTaskAssessmentRunOutput,
            smithy_http::result::SdkError<crate::error::StartReplicationTaskAssessmentRunError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name (ARN) of the migration task associated with the premigration
        /// assessment run that you want to start.</p>
        pub fn replication_task_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_task_arn(input);
            self
        }
        pub fn set_replication_task_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_task_arn(input);
            self
        }
        /// <p>ARN of a service role needed to start the assessment run.</p>
        pub fn service_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_access_role_arn(input);
            self
        }
        pub fn set_service_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_service_access_role_arn(input);
            self
        }
        /// <p>Amazon S3 bucket where you want AWS DMS to store the results of this assessment
        /// run.</p>
        pub fn result_location_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.result_location_bucket(input);
            self
        }
        pub fn set_result_location_bucket(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_result_location_bucket(input);
            self
        }
        /// <p>Folder within an Amazon S3 bucket where you want AWS DMS to store the results of this assessment
        /// run.</p>
        pub fn result_location_folder(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.result_location_folder(input);
            self
        }
        pub fn set_result_location_folder(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_result_location_folder(input);
            self
        }
        /// <p>Encryption mode that you can specify to encrypt the results of this assessment run. If
        /// you don't specify this request parameter, AWS DMS stores the assessment run results
        /// without encryption. You can specify one of the options following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>"SSE_S3"</code>  The server-side encryption provided as a default by
        /// Amazon S3.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>"SSE_KMS"</code>  AWS Key Management Service (AWS KMS) encryption.
        /// This encryption can use either a custom KMS encryption key that you specify or the
        /// default KMS encryption key that DMS provides.</p>
        /// </li>
        /// </ul>
        pub fn result_encryption_mode(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.result_encryption_mode(input);
            self
        }
        pub fn set_result_encryption_mode(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_result_encryption_mode(input);
            self
        }
        /// <p>ARN of a custom KMS encryption key that you specify when you set
        /// <code>ResultEncryptionMode</code> to <code>"SSE_KMS</code>".</p>
        pub fn result_kms_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.result_kms_key_arn(input);
            self
        }
        pub fn set_result_kms_key_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_result_kms_key_arn(input);
            self
        }
        /// <p>Unique name to identify the assessment run.</p>
        pub fn assessment_run_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.assessment_run_name(input);
            self
        }
        pub fn set_assessment_run_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_assessment_run_name(input);
            self
        }
        /// <p>Space-separated list of names for specific individual assessments that you want to
        /// include. These names come from the default list of individual assessments that AWS DMS
        /// supports for the associated migration task. This task is specified by
        /// <code>ReplicationTaskArn</code>.</p>
        /// <note>
        /// <p>You can't set a value for <code>IncludeOnly</code> if you also set a value for
        /// <code>Exclude</code> in the API operation. </p>
        /// <p>To identify the names of the default individual assessments that AWS DMS
        /// supports for the associated migration task, run the
        /// <code>DescribeApplicableIndividualAssessments</code> operation using its own
        /// <code>ReplicationTaskArn</code> request parameter.</p>
        /// </note>
        pub fn include_only(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.include_only(inp);
            self
        }
        pub fn set_include_only(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_include_only(input);
            self
        }
        /// <p>Space-separated list of names for specific individual assessments that you want to
        /// exclude. These names come from the default list of individual assessments that AWS DMS
        /// supports for the associated migration task. This task is specified by
        /// <code>ReplicationTaskArn</code>.</p>
        /// <note>
        /// <p>You can't set a value for <code>Exclude</code> if you also set a value for
        /// <code>IncludeOnly</code> in the API operation.</p>
        /// <p>To identify the names of the default individual assessments that AWS DMS
        /// supports for the associated migration task, run the
        /// <code>DescribeApplicableIndividualAssessments</code> operation using its own
        /// <code>ReplicationTaskArn</code> request parameter.</p>
        /// </note>
        pub fn exclude(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.exclude(inp);
            self
        }
        pub fn set_exclude(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_exclude(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopReplicationTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_replication_task_input::Builder,
    }
    impl<C> StopReplicationTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopReplicationTaskOutput,
            smithy_http::result::SdkError<crate::error::StopReplicationTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name(ARN) of the replication task to be stopped.</p>
        pub fn replication_task_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_task_arn(input);
            self
        }
        pub fn set_replication_task_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_task_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TestConnection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::test_connection_input::Builder,
    }
    impl<C> TestConnection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TestConnectionOutput,
            smithy_http::result::SdkError<crate::error::TestConnectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the replication instance.</p>
        pub fn replication_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replication_instance_arn(input);
            self
        }
        pub fn set_replication_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replication_instance_arn(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.</p>
        pub fn endpoint_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.endpoint_arn(input);
            self
        }
        pub fn set_endpoint_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_endpoint_arn(input);
            self
        }
    }
}
