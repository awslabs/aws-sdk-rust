// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Provides information that describes an Amazon Kinesis Data Stream endpoint. This information includes the output format of records applied to the endpoint and details of transaction and control table data information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct KinesisSettings {
    /// <p>The Amazon Resource Name (ARN) for the Amazon Kinesis Data Streams endpoint.</p>
    #[doc(hidden)]
    pub stream_arn: std::option::Option<std::string::String>,
    /// <p>The output format for the records created on the endpoint. The message format is <code>JSON</code> (default) or <code>JSON_UNFORMATTED</code> (a single line with no tab).</p>
    #[doc(hidden)]
    pub message_format: std::option::Option<crate::types::MessageFormatValue>,
    /// <p>The Amazon Resource Name (ARN) for the IAM role that DMS uses to write to the Kinesis data stream. The role must allow the <code>iam:PassRole</code> action.</p>
    #[doc(hidden)]
    pub service_access_role_arn: std::option::Option<std::string::String>,
    /// <p>Provides detailed transaction information from the source database. This information includes a commit timestamp, a log position, and values for <code>transaction_id</code>, previous <code>transaction_id</code>, and <code>transaction_record_id</code> (the record offset within a transaction). The default is <code>false</code>.</p>
    #[doc(hidden)]
    pub include_transaction_details: std::option::Option<bool>,
    /// <p>Shows the partition value within the Kinesis message output, unless the partition type is <code>schema-table-type</code>. The default is <code>false</code>.</p>
    #[doc(hidden)]
    pub include_partition_value: std::option::Option<bool>,
    /// <p>Prefixes schema and table names to partition values, when the partition type is <code>primary-key-type</code>. Doing this increases data distribution among Kinesis shards. For example, suppose that a SysBench schema has thousands of tables and each table has only limited range for a primary key. In this case, the same primary key is sent from thousands of tables to the same shard, which causes throttling. The default is <code>false</code>.</p>
    #[doc(hidden)]
    pub partition_include_schema_table: std::option::Option<bool>,
    /// <p>Includes any data definition language (DDL) operations that change the table in the control data, such as <code>rename-table</code>, <code>drop-table</code>, <code>add-column</code>, <code>drop-column</code>, and <code>rename-column</code>. The default is <code>false</code>.</p>
    #[doc(hidden)]
    pub include_table_alter_operations: std::option::Option<bool>,
    /// <p>Shows detailed control information for table definition, column definition, and table and column changes in the Kinesis message output. The default is <code>false</code>.</p>
    #[doc(hidden)]
    pub include_control_details: std::option::Option<bool>,
    /// <p>Include NULL and empty columns for records migrated to the endpoint. The default is <code>false</code>.</p>
    #[doc(hidden)]
    pub include_null_and_empty: std::option::Option<bool>,
    /// <p>Set this optional parameter to <code>true</code> to avoid adding a '0x' prefix to raw data in hexadecimal format. For example, by default, DMS adds a '0x' prefix to the LOB column type in hexadecimal format moving from an Oracle source to an Amazon Kinesis target. Use the <code>NoHexPrefix</code> endpoint setting to enable migration of RAW data type columns without adding the '0x' prefix.</p>
    #[doc(hidden)]
    pub no_hex_prefix: std::option::Option<bool>,
}
impl KinesisSettings {
    /// <p>The Amazon Resource Name (ARN) for the Amazon Kinesis Data Streams endpoint.</p>
    pub fn stream_arn(&self) -> std::option::Option<&str> {
        self.stream_arn.as_deref()
    }
    /// <p>The output format for the records created on the endpoint. The message format is <code>JSON</code> (default) or <code>JSON_UNFORMATTED</code> (a single line with no tab).</p>
    pub fn message_format(&self) -> std::option::Option<&crate::types::MessageFormatValue> {
        self.message_format.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) for the IAM role that DMS uses to write to the Kinesis data stream. The role must allow the <code>iam:PassRole</code> action.</p>
    pub fn service_access_role_arn(&self) -> std::option::Option<&str> {
        self.service_access_role_arn.as_deref()
    }
    /// <p>Provides detailed transaction information from the source database. This information includes a commit timestamp, a log position, and values for <code>transaction_id</code>, previous <code>transaction_id</code>, and <code>transaction_record_id</code> (the record offset within a transaction). The default is <code>false</code>.</p>
    pub fn include_transaction_details(&self) -> std::option::Option<bool> {
        self.include_transaction_details
    }
    /// <p>Shows the partition value within the Kinesis message output, unless the partition type is <code>schema-table-type</code>. The default is <code>false</code>.</p>
    pub fn include_partition_value(&self) -> std::option::Option<bool> {
        self.include_partition_value
    }
    /// <p>Prefixes schema and table names to partition values, when the partition type is <code>primary-key-type</code>. Doing this increases data distribution among Kinesis shards. For example, suppose that a SysBench schema has thousands of tables and each table has only limited range for a primary key. In this case, the same primary key is sent from thousands of tables to the same shard, which causes throttling. The default is <code>false</code>.</p>
    pub fn partition_include_schema_table(&self) -> std::option::Option<bool> {
        self.partition_include_schema_table
    }
    /// <p>Includes any data definition language (DDL) operations that change the table in the control data, such as <code>rename-table</code>, <code>drop-table</code>, <code>add-column</code>, <code>drop-column</code>, and <code>rename-column</code>. The default is <code>false</code>.</p>
    pub fn include_table_alter_operations(&self) -> std::option::Option<bool> {
        self.include_table_alter_operations
    }
    /// <p>Shows detailed control information for table definition, column definition, and table and column changes in the Kinesis message output. The default is <code>false</code>.</p>
    pub fn include_control_details(&self) -> std::option::Option<bool> {
        self.include_control_details
    }
    /// <p>Include NULL and empty columns for records migrated to the endpoint. The default is <code>false</code>.</p>
    pub fn include_null_and_empty(&self) -> std::option::Option<bool> {
        self.include_null_and_empty
    }
    /// <p>Set this optional parameter to <code>true</code> to avoid adding a '0x' prefix to raw data in hexadecimal format. For example, by default, DMS adds a '0x' prefix to the LOB column type in hexadecimal format moving from an Oracle source to an Amazon Kinesis target. Use the <code>NoHexPrefix</code> endpoint setting to enable migration of RAW data type columns without adding the '0x' prefix.</p>
    pub fn no_hex_prefix(&self) -> std::option::Option<bool> {
        self.no_hex_prefix
    }
}
impl KinesisSettings {
    /// Creates a new builder-style object to manufacture [`KinesisSettings`](crate::types::KinesisSettings).
    pub fn builder() -> crate::types::builders::KinesisSettingsBuilder {
        crate::types::builders::KinesisSettingsBuilder::default()
    }
}

/// A builder for [`KinesisSettings`](crate::types::KinesisSettings).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct KinesisSettingsBuilder {
    pub(crate) stream_arn: std::option::Option<std::string::String>,
    pub(crate) message_format: std::option::Option<crate::types::MessageFormatValue>,
    pub(crate) service_access_role_arn: std::option::Option<std::string::String>,
    pub(crate) include_transaction_details: std::option::Option<bool>,
    pub(crate) include_partition_value: std::option::Option<bool>,
    pub(crate) partition_include_schema_table: std::option::Option<bool>,
    pub(crate) include_table_alter_operations: std::option::Option<bool>,
    pub(crate) include_control_details: std::option::Option<bool>,
    pub(crate) include_null_and_empty: std::option::Option<bool>,
    pub(crate) no_hex_prefix: std::option::Option<bool>,
}
impl KinesisSettingsBuilder {
    /// <p>The Amazon Resource Name (ARN) for the Amazon Kinesis Data Streams endpoint.</p>
    pub fn stream_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.stream_arn = Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) for the Amazon Kinesis Data Streams endpoint.</p>
    pub fn set_stream_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.stream_arn = input;
        self
    }
    /// <p>The output format for the records created on the endpoint. The message format is <code>JSON</code> (default) or <code>JSON_UNFORMATTED</code> (a single line with no tab).</p>
    pub fn message_format(mut self, input: crate::types::MessageFormatValue) -> Self {
        self.message_format = Some(input);
        self
    }
    /// <p>The output format for the records created on the endpoint. The message format is <code>JSON</code> (default) or <code>JSON_UNFORMATTED</code> (a single line with no tab).</p>
    pub fn set_message_format(
        mut self,
        input: std::option::Option<crate::types::MessageFormatValue>,
    ) -> Self {
        self.message_format = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) for the IAM role that DMS uses to write to the Kinesis data stream. The role must allow the <code>iam:PassRole</code> action.</p>
    pub fn service_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.service_access_role_arn = Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) for the IAM role that DMS uses to write to the Kinesis data stream. The role must allow the <code>iam:PassRole</code> action.</p>
    pub fn set_service_access_role_arn(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.service_access_role_arn = input;
        self
    }
    /// <p>Provides detailed transaction information from the source database. This information includes a commit timestamp, a log position, and values for <code>transaction_id</code>, previous <code>transaction_id</code>, and <code>transaction_record_id</code> (the record offset within a transaction). The default is <code>false</code>.</p>
    pub fn include_transaction_details(mut self, input: bool) -> Self {
        self.include_transaction_details = Some(input);
        self
    }
    /// <p>Provides detailed transaction information from the source database. This information includes a commit timestamp, a log position, and values for <code>transaction_id</code>, previous <code>transaction_id</code>, and <code>transaction_record_id</code> (the record offset within a transaction). The default is <code>false</code>.</p>
    pub fn set_include_transaction_details(mut self, input: std::option::Option<bool>) -> Self {
        self.include_transaction_details = input;
        self
    }
    /// <p>Shows the partition value within the Kinesis message output, unless the partition type is <code>schema-table-type</code>. The default is <code>false</code>.</p>
    pub fn include_partition_value(mut self, input: bool) -> Self {
        self.include_partition_value = Some(input);
        self
    }
    /// <p>Shows the partition value within the Kinesis message output, unless the partition type is <code>schema-table-type</code>. The default is <code>false</code>.</p>
    pub fn set_include_partition_value(mut self, input: std::option::Option<bool>) -> Self {
        self.include_partition_value = input;
        self
    }
    /// <p>Prefixes schema and table names to partition values, when the partition type is <code>primary-key-type</code>. Doing this increases data distribution among Kinesis shards. For example, suppose that a SysBench schema has thousands of tables and each table has only limited range for a primary key. In this case, the same primary key is sent from thousands of tables to the same shard, which causes throttling. The default is <code>false</code>.</p>
    pub fn partition_include_schema_table(mut self, input: bool) -> Self {
        self.partition_include_schema_table = Some(input);
        self
    }
    /// <p>Prefixes schema and table names to partition values, when the partition type is <code>primary-key-type</code>. Doing this increases data distribution among Kinesis shards. For example, suppose that a SysBench schema has thousands of tables and each table has only limited range for a primary key. In this case, the same primary key is sent from thousands of tables to the same shard, which causes throttling. The default is <code>false</code>.</p>
    pub fn set_partition_include_schema_table(mut self, input: std::option::Option<bool>) -> Self {
        self.partition_include_schema_table = input;
        self
    }
    /// <p>Includes any data definition language (DDL) operations that change the table in the control data, such as <code>rename-table</code>, <code>drop-table</code>, <code>add-column</code>, <code>drop-column</code>, and <code>rename-column</code>. The default is <code>false</code>.</p>
    pub fn include_table_alter_operations(mut self, input: bool) -> Self {
        self.include_table_alter_operations = Some(input);
        self
    }
    /// <p>Includes any data definition language (DDL) operations that change the table in the control data, such as <code>rename-table</code>, <code>drop-table</code>, <code>add-column</code>, <code>drop-column</code>, and <code>rename-column</code>. The default is <code>false</code>.</p>
    pub fn set_include_table_alter_operations(mut self, input: std::option::Option<bool>) -> Self {
        self.include_table_alter_operations = input;
        self
    }
    /// <p>Shows detailed control information for table definition, column definition, and table and column changes in the Kinesis message output. The default is <code>false</code>.</p>
    pub fn include_control_details(mut self, input: bool) -> Self {
        self.include_control_details = Some(input);
        self
    }
    /// <p>Shows detailed control information for table definition, column definition, and table and column changes in the Kinesis message output. The default is <code>false</code>.</p>
    pub fn set_include_control_details(mut self, input: std::option::Option<bool>) -> Self {
        self.include_control_details = input;
        self
    }
    /// <p>Include NULL and empty columns for records migrated to the endpoint. The default is <code>false</code>.</p>
    pub fn include_null_and_empty(mut self, input: bool) -> Self {
        self.include_null_and_empty = Some(input);
        self
    }
    /// <p>Include NULL and empty columns for records migrated to the endpoint. The default is <code>false</code>.</p>
    pub fn set_include_null_and_empty(mut self, input: std::option::Option<bool>) -> Self {
        self.include_null_and_empty = input;
        self
    }
    /// <p>Set this optional parameter to <code>true</code> to avoid adding a '0x' prefix to raw data in hexadecimal format. For example, by default, DMS adds a '0x' prefix to the LOB column type in hexadecimal format moving from an Oracle source to an Amazon Kinesis target. Use the <code>NoHexPrefix</code> endpoint setting to enable migration of RAW data type columns without adding the '0x' prefix.</p>
    pub fn no_hex_prefix(mut self, input: bool) -> Self {
        self.no_hex_prefix = Some(input);
        self
    }
    /// <p>Set this optional parameter to <code>true</code> to avoid adding a '0x' prefix to raw data in hexadecimal format. For example, by default, DMS adds a '0x' prefix to the LOB column type in hexadecimal format moving from an Oracle source to an Amazon Kinesis target. Use the <code>NoHexPrefix</code> endpoint setting to enable migration of RAW data type columns without adding the '0x' prefix.</p>
    pub fn set_no_hex_prefix(mut self, input: std::option::Option<bool>) -> Self {
        self.no_hex_prefix = input;
        self
    }
    /// Consumes the builder and constructs a [`KinesisSettings`](crate::types::KinesisSettings).
    pub fn build(self) -> crate::types::KinesisSettings {
        crate::types::KinesisSettings {
            stream_arn: self.stream_arn,
            message_format: self.message_format,
            service_access_role_arn: self.service_access_role_arn,
            include_transaction_details: self.include_transaction_details,
            include_partition_value: self.include_partition_value,
            partition_include_schema_table: self.partition_include_schema_table,
            include_table_alter_operations: self.include_table_alter_operations,
            include_control_details: self.include_control_details,
            include_null_and_empty: self.include_null_and_empty,
            no_hex_prefix: self.no_hex_prefix,
        }
    }
}
