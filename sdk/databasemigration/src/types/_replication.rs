// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Provides information that describes a serverless replication created by the <code>CreateReplication</code> operation.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct Replication {
    /// <p>The identifier for the <code>ReplicationConfig</code> associated with the replication.</p>
    pub replication_config_identifier: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name for the <code>ReplicationConfig</code> associated with the replication.</p>
    pub replication_config_arn: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name for an existing <code>Endpoint</code> the serverless replication uses for its data source.</p>
    pub source_endpoint_arn: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name for an existing <code>Endpoint</code> the serverless replication uses for its data target.</p>
    pub target_endpoint_arn: ::std::option::Option<::std::string::String>,
    /// <p>The type of the serverless replication.</p>
    pub replication_type: ::std::option::Option<crate::types::MigrationTypeValue>,
    /// <p>The current status of the serverless replication.</p>
    pub status: ::std::option::Option<::std::string::String>,
    /// <p>Information about provisioning resources for an DMS serverless replication.</p>
    pub provision_data: ::std::option::Option<crate::types::ProvisionData>,
    /// <p>The reason the replication task was stopped. This response parameter can return one of the following values:</p>
    /// <ul>
    /// <li> <p> <code>"Stop Reason NORMAL"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason RECOVERABLE_ERROR"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason FATAL_ERROR"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason FULL_LOAD_ONLY_FINISHED"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_AFTER_FULL_LOAD"</code> – Full load completed, with cached changes not applied</p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_AFTER_CACHED_EVENTS"</code> – Full load completed, with cached changes applied</p> </li>
    /// <li> <p> <code>"Stop Reason EXPRESS_LICENSE_LIMITS_REACHED"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_AFTER_DDL_APPLY"</code> – User-defined stop task after DDL applied</p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_DUE_TO_LOW_MEMORY"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_DUE_TO_LOW_DISK"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_AT_SERVER_TIME"</code> – User-defined server time for stopping task</p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_AT_COMMIT_TIME"</code> – User-defined commit time for stopping task</p> </li>
    /// <li> <p> <code>"Stop Reason RECONFIGURATION_RESTART"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason RECYCLE_TASK"</code> </p> </li>
    /// </ul>
    pub stop_reason: ::std::option::Option<::std::string::String>,
    /// <p>Error and other information about why a serverless replication failed.</p>
    pub failure_messages: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>This object provides a collection of statistics about a serverless replication.</p>
    pub replication_stats: ::std::option::Option<crate::types::ReplicationStats>,
    /// <p>The replication type.</p>
    pub start_replication_type: ::std::option::Option<::std::string::String>,
    /// <p>Indicates the start time for a change data capture (CDC) operation. Use either <code>CdcStartTime</code> or <code>CdcStartPosition</code> to specify when you want a CDC operation to start. Specifying both values results in an error.</p>
    pub cdc_start_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>Indicates the start time for a change data capture (CDC) operation. Use either <code>CdcStartTime</code> or <code>CdcStartPosition</code> to specify when you want a CDC operation to start. Specifying both values results in an error.</p>
    pub cdc_start_position: ::std::option::Option<::std::string::String>,
    /// <p>Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time.</p>
    pub cdc_stop_position: ::std::option::Option<::std::string::String>,
    /// <p>Indicates the last checkpoint that occurred during a change data capture (CDC) operation. You can provide this value to the <code>CdcStartPosition</code> parameter to start a CDC operation that begins at that checkpoint.</p>
    pub recovery_checkpoint: ::std::option::Option<::std::string::String>,
    /// <p>The time the serverless replication was created.</p>
    pub replication_create_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The time the serverless replication was updated.</p>
    pub replication_update_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The timestamp when replication was last stopped.</p>
    pub replication_last_stop_time: ::std::option::Option<::aws_smithy_types::DateTime>,
}
impl Replication {
    /// <p>The identifier for the <code>ReplicationConfig</code> associated with the replication.</p>
    pub fn replication_config_identifier(&self) -> ::std::option::Option<&str> {
        self.replication_config_identifier.as_deref()
    }
    /// <p>The Amazon Resource Name for the <code>ReplicationConfig</code> associated with the replication.</p>
    pub fn replication_config_arn(&self) -> ::std::option::Option<&str> {
        self.replication_config_arn.as_deref()
    }
    /// <p>The Amazon Resource Name for an existing <code>Endpoint</code> the serverless replication uses for its data source.</p>
    pub fn source_endpoint_arn(&self) -> ::std::option::Option<&str> {
        self.source_endpoint_arn.as_deref()
    }
    /// <p>The Amazon Resource Name for an existing <code>Endpoint</code> the serverless replication uses for its data target.</p>
    pub fn target_endpoint_arn(&self) -> ::std::option::Option<&str> {
        self.target_endpoint_arn.as_deref()
    }
    /// <p>The type of the serverless replication.</p>
    pub fn replication_type(&self) -> ::std::option::Option<&crate::types::MigrationTypeValue> {
        self.replication_type.as_ref()
    }
    /// <p>The current status of the serverless replication.</p>
    pub fn status(&self) -> ::std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>Information about provisioning resources for an DMS serverless replication.</p>
    pub fn provision_data(&self) -> ::std::option::Option<&crate::types::ProvisionData> {
        self.provision_data.as_ref()
    }
    /// <p>The reason the replication task was stopped. This response parameter can return one of the following values:</p>
    /// <ul>
    /// <li> <p> <code>"Stop Reason NORMAL"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason RECOVERABLE_ERROR"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason FATAL_ERROR"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason FULL_LOAD_ONLY_FINISHED"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_AFTER_FULL_LOAD"</code> – Full load completed, with cached changes not applied</p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_AFTER_CACHED_EVENTS"</code> – Full load completed, with cached changes applied</p> </li>
    /// <li> <p> <code>"Stop Reason EXPRESS_LICENSE_LIMITS_REACHED"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_AFTER_DDL_APPLY"</code> – User-defined stop task after DDL applied</p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_DUE_TO_LOW_MEMORY"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_DUE_TO_LOW_DISK"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_AT_SERVER_TIME"</code> – User-defined server time for stopping task</p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_AT_COMMIT_TIME"</code> – User-defined commit time for stopping task</p> </li>
    /// <li> <p> <code>"Stop Reason RECONFIGURATION_RESTART"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason RECYCLE_TASK"</code> </p> </li>
    /// </ul>
    pub fn stop_reason(&self) -> ::std::option::Option<&str> {
        self.stop_reason.as_deref()
    }
    /// <p>Error and other information about why a serverless replication failed.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.failure_messages.is_none()`.
    pub fn failure_messages(&self) -> &[::std::string::String] {
        self.failure_messages.as_deref().unwrap_or_default()
    }
    /// <p>This object provides a collection of statistics about a serverless replication.</p>
    pub fn replication_stats(&self) -> ::std::option::Option<&crate::types::ReplicationStats> {
        self.replication_stats.as_ref()
    }
    /// <p>The replication type.</p>
    pub fn start_replication_type(&self) -> ::std::option::Option<&str> {
        self.start_replication_type.as_deref()
    }
    /// <p>Indicates the start time for a change data capture (CDC) operation. Use either <code>CdcStartTime</code> or <code>CdcStartPosition</code> to specify when you want a CDC operation to start. Specifying both values results in an error.</p>
    pub fn cdc_start_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.cdc_start_time.as_ref()
    }
    /// <p>Indicates the start time for a change data capture (CDC) operation. Use either <code>CdcStartTime</code> or <code>CdcStartPosition</code> to specify when you want a CDC operation to start. Specifying both values results in an error.</p>
    pub fn cdc_start_position(&self) -> ::std::option::Option<&str> {
        self.cdc_start_position.as_deref()
    }
    /// <p>Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time.</p>
    pub fn cdc_stop_position(&self) -> ::std::option::Option<&str> {
        self.cdc_stop_position.as_deref()
    }
    /// <p>Indicates the last checkpoint that occurred during a change data capture (CDC) operation. You can provide this value to the <code>CdcStartPosition</code> parameter to start a CDC operation that begins at that checkpoint.</p>
    pub fn recovery_checkpoint(&self) -> ::std::option::Option<&str> {
        self.recovery_checkpoint.as_deref()
    }
    /// <p>The time the serverless replication was created.</p>
    pub fn replication_create_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.replication_create_time.as_ref()
    }
    /// <p>The time the serverless replication was updated.</p>
    pub fn replication_update_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.replication_update_time.as_ref()
    }
    /// <p>The timestamp when replication was last stopped.</p>
    pub fn replication_last_stop_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.replication_last_stop_time.as_ref()
    }
}
impl Replication {
    /// Creates a new builder-style object to manufacture [`Replication`](crate::types::Replication).
    pub fn builder() -> crate::types::builders::ReplicationBuilder {
        crate::types::builders::ReplicationBuilder::default()
    }
}

/// A builder for [`Replication`](crate::types::Replication).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct ReplicationBuilder {
    pub(crate) replication_config_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) replication_config_arn: ::std::option::Option<::std::string::String>,
    pub(crate) source_endpoint_arn: ::std::option::Option<::std::string::String>,
    pub(crate) target_endpoint_arn: ::std::option::Option<::std::string::String>,
    pub(crate) replication_type: ::std::option::Option<crate::types::MigrationTypeValue>,
    pub(crate) status: ::std::option::Option<::std::string::String>,
    pub(crate) provision_data: ::std::option::Option<crate::types::ProvisionData>,
    pub(crate) stop_reason: ::std::option::Option<::std::string::String>,
    pub(crate) failure_messages: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) replication_stats: ::std::option::Option<crate::types::ReplicationStats>,
    pub(crate) start_replication_type: ::std::option::Option<::std::string::String>,
    pub(crate) cdc_start_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) cdc_start_position: ::std::option::Option<::std::string::String>,
    pub(crate) cdc_stop_position: ::std::option::Option<::std::string::String>,
    pub(crate) recovery_checkpoint: ::std::option::Option<::std::string::String>,
    pub(crate) replication_create_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) replication_update_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) replication_last_stop_time: ::std::option::Option<::aws_smithy_types::DateTime>,
}
impl ReplicationBuilder {
    /// <p>The identifier for the <code>ReplicationConfig</code> associated with the replication.</p>
    pub fn replication_config_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.replication_config_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The identifier for the <code>ReplicationConfig</code> associated with the replication.</p>
    pub fn set_replication_config_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.replication_config_identifier = input;
        self
    }
    /// <p>The identifier for the <code>ReplicationConfig</code> associated with the replication.</p>
    pub fn get_replication_config_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.replication_config_identifier
    }
    /// <p>The Amazon Resource Name for the <code>ReplicationConfig</code> associated with the replication.</p>
    pub fn replication_config_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.replication_config_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name for the <code>ReplicationConfig</code> associated with the replication.</p>
    pub fn set_replication_config_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.replication_config_arn = input;
        self
    }
    /// <p>The Amazon Resource Name for the <code>ReplicationConfig</code> associated with the replication.</p>
    pub fn get_replication_config_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.replication_config_arn
    }
    /// <p>The Amazon Resource Name for an existing <code>Endpoint</code> the serverless replication uses for its data source.</p>
    pub fn source_endpoint_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.source_endpoint_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name for an existing <code>Endpoint</code> the serverless replication uses for its data source.</p>
    pub fn set_source_endpoint_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.source_endpoint_arn = input;
        self
    }
    /// <p>The Amazon Resource Name for an existing <code>Endpoint</code> the serverless replication uses for its data source.</p>
    pub fn get_source_endpoint_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.source_endpoint_arn
    }
    /// <p>The Amazon Resource Name for an existing <code>Endpoint</code> the serverless replication uses for its data target.</p>
    pub fn target_endpoint_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.target_endpoint_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name for an existing <code>Endpoint</code> the serverless replication uses for its data target.</p>
    pub fn set_target_endpoint_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.target_endpoint_arn = input;
        self
    }
    /// <p>The Amazon Resource Name for an existing <code>Endpoint</code> the serverless replication uses for its data target.</p>
    pub fn get_target_endpoint_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.target_endpoint_arn
    }
    /// <p>The type of the serverless replication.</p>
    pub fn replication_type(mut self, input: crate::types::MigrationTypeValue) -> Self {
        self.replication_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The type of the serverless replication.</p>
    pub fn set_replication_type(mut self, input: ::std::option::Option<crate::types::MigrationTypeValue>) -> Self {
        self.replication_type = input;
        self
    }
    /// <p>The type of the serverless replication.</p>
    pub fn get_replication_type(&self) -> &::std::option::Option<crate::types::MigrationTypeValue> {
        &self.replication_type
    }
    /// <p>The current status of the serverless replication.</p>
    pub fn status(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.status = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The current status of the serverless replication.</p>
    pub fn set_status(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.status = input;
        self
    }
    /// <p>The current status of the serverless replication.</p>
    pub fn get_status(&self) -> &::std::option::Option<::std::string::String> {
        &self.status
    }
    /// <p>Information about provisioning resources for an DMS serverless replication.</p>
    pub fn provision_data(mut self, input: crate::types::ProvisionData) -> Self {
        self.provision_data = ::std::option::Option::Some(input);
        self
    }
    /// <p>Information about provisioning resources for an DMS serverless replication.</p>
    pub fn set_provision_data(mut self, input: ::std::option::Option<crate::types::ProvisionData>) -> Self {
        self.provision_data = input;
        self
    }
    /// <p>Information about provisioning resources for an DMS serverless replication.</p>
    pub fn get_provision_data(&self) -> &::std::option::Option<crate::types::ProvisionData> {
        &self.provision_data
    }
    /// <p>The reason the replication task was stopped. This response parameter can return one of the following values:</p>
    /// <ul>
    /// <li> <p> <code>"Stop Reason NORMAL"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason RECOVERABLE_ERROR"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason FATAL_ERROR"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason FULL_LOAD_ONLY_FINISHED"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_AFTER_FULL_LOAD"</code> – Full load completed, with cached changes not applied</p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_AFTER_CACHED_EVENTS"</code> – Full load completed, with cached changes applied</p> </li>
    /// <li> <p> <code>"Stop Reason EXPRESS_LICENSE_LIMITS_REACHED"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_AFTER_DDL_APPLY"</code> – User-defined stop task after DDL applied</p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_DUE_TO_LOW_MEMORY"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_DUE_TO_LOW_DISK"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_AT_SERVER_TIME"</code> – User-defined server time for stopping task</p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_AT_COMMIT_TIME"</code> – User-defined commit time for stopping task</p> </li>
    /// <li> <p> <code>"Stop Reason RECONFIGURATION_RESTART"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason RECYCLE_TASK"</code> </p> </li>
    /// </ul>
    pub fn stop_reason(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.stop_reason = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The reason the replication task was stopped. This response parameter can return one of the following values:</p>
    /// <ul>
    /// <li> <p> <code>"Stop Reason NORMAL"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason RECOVERABLE_ERROR"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason FATAL_ERROR"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason FULL_LOAD_ONLY_FINISHED"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_AFTER_FULL_LOAD"</code> – Full load completed, with cached changes not applied</p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_AFTER_CACHED_EVENTS"</code> – Full load completed, with cached changes applied</p> </li>
    /// <li> <p> <code>"Stop Reason EXPRESS_LICENSE_LIMITS_REACHED"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_AFTER_DDL_APPLY"</code> – User-defined stop task after DDL applied</p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_DUE_TO_LOW_MEMORY"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_DUE_TO_LOW_DISK"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_AT_SERVER_TIME"</code> – User-defined server time for stopping task</p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_AT_COMMIT_TIME"</code> – User-defined commit time for stopping task</p> </li>
    /// <li> <p> <code>"Stop Reason RECONFIGURATION_RESTART"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason RECYCLE_TASK"</code> </p> </li>
    /// </ul>
    pub fn set_stop_reason(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.stop_reason = input;
        self
    }
    /// <p>The reason the replication task was stopped. This response parameter can return one of the following values:</p>
    /// <ul>
    /// <li> <p> <code>"Stop Reason NORMAL"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason RECOVERABLE_ERROR"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason FATAL_ERROR"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason FULL_LOAD_ONLY_FINISHED"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_AFTER_FULL_LOAD"</code> – Full load completed, with cached changes not applied</p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_AFTER_CACHED_EVENTS"</code> – Full load completed, with cached changes applied</p> </li>
    /// <li> <p> <code>"Stop Reason EXPRESS_LICENSE_LIMITS_REACHED"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_AFTER_DDL_APPLY"</code> – User-defined stop task after DDL applied</p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_DUE_TO_LOW_MEMORY"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_DUE_TO_LOW_DISK"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_AT_SERVER_TIME"</code> – User-defined server time for stopping task</p> </li>
    /// <li> <p> <code>"Stop Reason STOPPED_AT_COMMIT_TIME"</code> – User-defined commit time for stopping task</p> </li>
    /// <li> <p> <code>"Stop Reason RECONFIGURATION_RESTART"</code> </p> </li>
    /// <li> <p> <code>"Stop Reason RECYCLE_TASK"</code> </p> </li>
    /// </ul>
    pub fn get_stop_reason(&self) -> &::std::option::Option<::std::string::String> {
        &self.stop_reason
    }
    /// Appends an item to `failure_messages`.
    ///
    /// To override the contents of this collection use [`set_failure_messages`](Self::set_failure_messages).
    ///
    /// <p>Error and other information about why a serverless replication failed.</p>
    pub fn failure_messages(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.failure_messages.unwrap_or_default();
        v.push(input.into());
        self.failure_messages = ::std::option::Option::Some(v);
        self
    }
    /// <p>Error and other information about why a serverless replication failed.</p>
    pub fn set_failure_messages(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.failure_messages = input;
        self
    }
    /// <p>Error and other information about why a serverless replication failed.</p>
    pub fn get_failure_messages(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.failure_messages
    }
    /// <p>This object provides a collection of statistics about a serverless replication.</p>
    pub fn replication_stats(mut self, input: crate::types::ReplicationStats) -> Self {
        self.replication_stats = ::std::option::Option::Some(input);
        self
    }
    /// <p>This object provides a collection of statistics about a serverless replication.</p>
    pub fn set_replication_stats(mut self, input: ::std::option::Option<crate::types::ReplicationStats>) -> Self {
        self.replication_stats = input;
        self
    }
    /// <p>This object provides a collection of statistics about a serverless replication.</p>
    pub fn get_replication_stats(&self) -> &::std::option::Option<crate::types::ReplicationStats> {
        &self.replication_stats
    }
    /// <p>The replication type.</p>
    pub fn start_replication_type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.start_replication_type = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The replication type.</p>
    pub fn set_start_replication_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.start_replication_type = input;
        self
    }
    /// <p>The replication type.</p>
    pub fn get_start_replication_type(&self) -> &::std::option::Option<::std::string::String> {
        &self.start_replication_type
    }
    /// <p>Indicates the start time for a change data capture (CDC) operation. Use either <code>CdcStartTime</code> or <code>CdcStartPosition</code> to specify when you want a CDC operation to start. Specifying both values results in an error.</p>
    pub fn cdc_start_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.cdc_start_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates the start time for a change data capture (CDC) operation. Use either <code>CdcStartTime</code> or <code>CdcStartPosition</code> to specify when you want a CDC operation to start. Specifying both values results in an error.</p>
    pub fn set_cdc_start_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.cdc_start_time = input;
        self
    }
    /// <p>Indicates the start time for a change data capture (CDC) operation. Use either <code>CdcStartTime</code> or <code>CdcStartPosition</code> to specify when you want a CDC operation to start. Specifying both values results in an error.</p>
    pub fn get_cdc_start_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.cdc_start_time
    }
    /// <p>Indicates the start time for a change data capture (CDC) operation. Use either <code>CdcStartTime</code> or <code>CdcStartPosition</code> to specify when you want a CDC operation to start. Specifying both values results in an error.</p>
    pub fn cdc_start_position(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cdc_start_position = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Indicates the start time for a change data capture (CDC) operation. Use either <code>CdcStartTime</code> or <code>CdcStartPosition</code> to specify when you want a CDC operation to start. Specifying both values results in an error.</p>
    pub fn set_cdc_start_position(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cdc_start_position = input;
        self
    }
    /// <p>Indicates the start time for a change data capture (CDC) operation. Use either <code>CdcStartTime</code> or <code>CdcStartPosition</code> to specify when you want a CDC operation to start. Specifying both values results in an error.</p>
    pub fn get_cdc_start_position(&self) -> &::std::option::Option<::std::string::String> {
        &self.cdc_start_position
    }
    /// <p>Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time.</p>
    pub fn cdc_stop_position(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cdc_stop_position = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time.</p>
    pub fn set_cdc_stop_position(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cdc_stop_position = input;
        self
    }
    /// <p>Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time.</p>
    pub fn get_cdc_stop_position(&self) -> &::std::option::Option<::std::string::String> {
        &self.cdc_stop_position
    }
    /// <p>Indicates the last checkpoint that occurred during a change data capture (CDC) operation. You can provide this value to the <code>CdcStartPosition</code> parameter to start a CDC operation that begins at that checkpoint.</p>
    pub fn recovery_checkpoint(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.recovery_checkpoint = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Indicates the last checkpoint that occurred during a change data capture (CDC) operation. You can provide this value to the <code>CdcStartPosition</code> parameter to start a CDC operation that begins at that checkpoint.</p>
    pub fn set_recovery_checkpoint(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.recovery_checkpoint = input;
        self
    }
    /// <p>Indicates the last checkpoint that occurred during a change data capture (CDC) operation. You can provide this value to the <code>CdcStartPosition</code> parameter to start a CDC operation that begins at that checkpoint.</p>
    pub fn get_recovery_checkpoint(&self) -> &::std::option::Option<::std::string::String> {
        &self.recovery_checkpoint
    }
    /// <p>The time the serverless replication was created.</p>
    pub fn replication_create_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.replication_create_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The time the serverless replication was created.</p>
    pub fn set_replication_create_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.replication_create_time = input;
        self
    }
    /// <p>The time the serverless replication was created.</p>
    pub fn get_replication_create_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.replication_create_time
    }
    /// <p>The time the serverless replication was updated.</p>
    pub fn replication_update_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.replication_update_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The time the serverless replication was updated.</p>
    pub fn set_replication_update_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.replication_update_time = input;
        self
    }
    /// <p>The time the serverless replication was updated.</p>
    pub fn get_replication_update_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.replication_update_time
    }
    /// <p>The timestamp when replication was last stopped.</p>
    pub fn replication_last_stop_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.replication_last_stop_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The timestamp when replication was last stopped.</p>
    pub fn set_replication_last_stop_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.replication_last_stop_time = input;
        self
    }
    /// <p>The timestamp when replication was last stopped.</p>
    pub fn get_replication_last_stop_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.replication_last_stop_time
    }
    /// Consumes the builder and constructs a [`Replication`](crate::types::Replication).
    pub fn build(self) -> crate::types::Replication {
        crate::types::Replication {
            replication_config_identifier: self.replication_config_identifier,
            replication_config_arn: self.replication_config_arn,
            source_endpoint_arn: self.source_endpoint_arn,
            target_endpoint_arn: self.target_endpoint_arn,
            replication_type: self.replication_type,
            status: self.status,
            provision_data: self.provision_data,
            stop_reason: self.stop_reason,
            failure_messages: self.failure_messages,
            replication_stats: self.replication_stats,
            start_replication_type: self.start_replication_type,
            cdc_start_time: self.cdc_start_time,
            cdc_start_position: self.cdc_start_position,
            cdc_stop_position: self.cdc_stop_position,
            recovery_checkpoint: self.recovery_checkpoint,
            replication_create_time: self.replication_create_time,
            replication_update_time: self.replication_update_time,
            replication_last_stop_time: self.replication_last_stop_time,
        }
    }
}
