// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `ResourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourcetype = unimplemented!();
/// match resourcetype {
///     ResourceType::Group => { /* ... */ },
///     ResourceType::GroupMembership => { /* ... */ },
///     ResourceType::IdentityStore => { /* ... */ },
///     ResourceType::User => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceType::NewFeature` is defined.
/// Specifically, when `resourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceType {
    #[allow(missing_docs)] // documentation missing in model
    Group,
    #[allow(missing_docs)] // documentation missing in model
    GroupMembership,
    #[allow(missing_docs)] // documentation missing in model
    IdentityStore,
    #[allow(missing_docs)] // documentation missing in model
    User,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceType {
    fn from(s: &str) -> Self {
        match s {
            "GROUP" => ResourceType::Group,
            "GROUP_MEMBERSHIP" => ResourceType::GroupMembership,
            "IDENTITY_STORE" => ResourceType::IdentityStore,
            "USER" => ResourceType::User,
            other => ResourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceType::from(s))
    }
}
impl ResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceType::Group => "GROUP",
            ResourceType::GroupMembership => "GROUP_MEMBERSHIP",
            ResourceType::IdentityStore => "IDENTITY_STORE",
            ResourceType::User => "USER",
            ResourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["GROUP", "GROUP_MEMBERSHIP", "IDENTITY_STORE", "USER"]
    }
}
impl AsRef<str> for ResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A user object that contains a specified userâ€™s metadata and attributes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct User {
    /// <p>A unique string used to identify the user. The length limit is 128 characters. This value can consist of letters, accented characters, symbols, numbers, and punctuation. This value is specified at the time the user is created and stored as an attribute of the user object in the identity store.</p>
    #[doc(hidden)]
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The identifier for a user in the identity store.</p>
    #[doc(hidden)]
    pub user_id: std::option::Option<std::string::String>,
    /// <p>A list of <code>ExternalId</code> objects that contains the identifiers issued to this resource by an external identity provider.</p>
    #[doc(hidden)]
    pub external_ids: std::option::Option<std::vec::Vec<crate::model::ExternalId>>,
    /// <p>An object containing the user's name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::Name>,
    /// <p>A string containing the user's name that's formatted for display when the user is referenced. For example, "John Doe."</p>
    #[doc(hidden)]
    pub display_name: std::option::Option<std::string::String>,
    /// <p>A string containing an alternate name for the user.</p>
    #[doc(hidden)]
    pub nick_name: std::option::Option<std::string::String>,
    /// <p>A string containing a URL that may be associated with the user.</p>
    #[doc(hidden)]
    pub profile_url: std::option::Option<std::string::String>,
    /// <p>A list of <code>Email</code> objects containing email addresses associated with the user.</p>
    #[doc(hidden)]
    pub emails: std::option::Option<std::vec::Vec<crate::model::Email>>,
    /// <p>A list of <code>Address</code> objects containing addresses associated with the user.</p>
    #[doc(hidden)]
    pub addresses: std::option::Option<std::vec::Vec<crate::model::Address>>,
    /// <p>A list of <code>PhoneNumber</code> objects containing phone numbers associated with the user.</p>
    #[doc(hidden)]
    pub phone_numbers: std::option::Option<std::vec::Vec<crate::model::PhoneNumber>>,
    /// <p>A string indicating the user's type. Possible values depend on each customer's specific needs, so they are left unspecified.</p>
    #[doc(hidden)]
    pub user_type: std::option::Option<std::string::String>,
    /// <p>A string containing the user's title. Possible values depend on each customer's specific needs, so they are left unspecified.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>A string containing the preferred language of the user. For example, "American English" or "en-us."</p>
    #[doc(hidden)]
    pub preferred_language: std::option::Option<std::string::String>,
    /// <p>A string containing the user's geographical region or location.</p>
    #[doc(hidden)]
    pub locale: std::option::Option<std::string::String>,
    /// <p>A string containing the user's time zone.</p>
    #[doc(hidden)]
    pub timezone: std::option::Option<std::string::String>,
    /// <p>The globally unique identifier for the identity store.</p>
    #[doc(hidden)]
    pub identity_store_id: std::option::Option<std::string::String>,
}
impl User {
    /// <p>A unique string used to identify the user. The length limit is 128 characters. This value can consist of letters, accented characters, symbols, numbers, and punctuation. This value is specified at the time the user is created and stored as an attribute of the user object in the identity store.</p>
    pub fn user_name(&self) -> std::option::Option<&str> {
        self.user_name.as_deref()
    }
    /// <p>The identifier for a user in the identity store.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>A list of <code>ExternalId</code> objects that contains the identifiers issued to this resource by an external identity provider.</p>
    pub fn external_ids(&self) -> std::option::Option<&[crate::model::ExternalId]> {
        self.external_ids.as_deref()
    }
    /// <p>An object containing the user's name.</p>
    pub fn name(&self) -> std::option::Option<&crate::model::Name> {
        self.name.as_ref()
    }
    /// <p>A string containing the user's name that's formatted for display when the user is referenced. For example, "John Doe."</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>A string containing an alternate name for the user.</p>
    pub fn nick_name(&self) -> std::option::Option<&str> {
        self.nick_name.as_deref()
    }
    /// <p>A string containing a URL that may be associated with the user.</p>
    pub fn profile_url(&self) -> std::option::Option<&str> {
        self.profile_url.as_deref()
    }
    /// <p>A list of <code>Email</code> objects containing email addresses associated with the user.</p>
    pub fn emails(&self) -> std::option::Option<&[crate::model::Email]> {
        self.emails.as_deref()
    }
    /// <p>A list of <code>Address</code> objects containing addresses associated with the user.</p>
    pub fn addresses(&self) -> std::option::Option<&[crate::model::Address]> {
        self.addresses.as_deref()
    }
    /// <p>A list of <code>PhoneNumber</code> objects containing phone numbers associated with the user.</p>
    pub fn phone_numbers(&self) -> std::option::Option<&[crate::model::PhoneNumber]> {
        self.phone_numbers.as_deref()
    }
    /// <p>A string indicating the user's type. Possible values depend on each customer's specific needs, so they are left unspecified.</p>
    pub fn user_type(&self) -> std::option::Option<&str> {
        self.user_type.as_deref()
    }
    /// <p>A string containing the user's title. Possible values depend on each customer's specific needs, so they are left unspecified.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>A string containing the preferred language of the user. For example, "American English" or "en-us."</p>
    pub fn preferred_language(&self) -> std::option::Option<&str> {
        self.preferred_language.as_deref()
    }
    /// <p>A string containing the user's geographical region or location.</p>
    pub fn locale(&self) -> std::option::Option<&str> {
        self.locale.as_deref()
    }
    /// <p>A string containing the user's time zone.</p>
    pub fn timezone(&self) -> std::option::Option<&str> {
        self.timezone.as_deref()
    }
    /// <p>The globally unique identifier for the identity store.</p>
    pub fn identity_store_id(&self) -> std::option::Option<&str> {
        self.identity_store_id.as_deref()
    }
}
impl std::fmt::Debug for User {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("User");
        formatter.field("user_name", &"*** Sensitive Data Redacted ***");
        formatter.field("user_id", &self.user_id);
        formatter.field("external_ids", &self.external_ids);
        formatter.field("name", &self.name);
        formatter.field("display_name", &"*** Sensitive Data Redacted ***");
        formatter.field("nick_name", &"*** Sensitive Data Redacted ***");
        formatter.field("profile_url", &"*** Sensitive Data Redacted ***");
        formatter.field("emails", &self.emails);
        formatter.field("addresses", &self.addresses);
        formatter.field("phone_numbers", &self.phone_numbers);
        formatter.field("user_type", &"*** Sensitive Data Redacted ***");
        formatter.field("title", &"*** Sensitive Data Redacted ***");
        formatter.field("preferred_language", &"*** Sensitive Data Redacted ***");
        formatter.field("locale", &"*** Sensitive Data Redacted ***");
        formatter.field("timezone", &"*** Sensitive Data Redacted ***");
        formatter.field("identity_store_id", &self.identity_store_id);
        formatter.finish()
    }
}
/// See [`User`](crate::model::User).
pub mod user {

    /// A builder for [`User`](crate::model::User).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) external_ids: std::option::Option<std::vec::Vec<crate::model::ExternalId>>,
        pub(crate) name: std::option::Option<crate::model::Name>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) nick_name: std::option::Option<std::string::String>,
        pub(crate) profile_url: std::option::Option<std::string::String>,
        pub(crate) emails: std::option::Option<std::vec::Vec<crate::model::Email>>,
        pub(crate) addresses: std::option::Option<std::vec::Vec<crate::model::Address>>,
        pub(crate) phone_numbers: std::option::Option<std::vec::Vec<crate::model::PhoneNumber>>,
        pub(crate) user_type: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) preferred_language: std::option::Option<std::string::String>,
        pub(crate) locale: std::option::Option<std::string::String>,
        pub(crate) timezone: std::option::Option<std::string::String>,
        pub(crate) identity_store_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique string used to identify the user. The length limit is 128 characters. This value can consist of letters, accented characters, symbols, numbers, and punctuation. This value is specified at the time the user is created and stored as an attribute of the user object in the identity store.</p>
        pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_name = Some(input.into());
            self
        }
        /// <p>A unique string used to identify the user. The length limit is 128 characters. This value can consist of letters, accented characters, symbols, numbers, and punctuation. This value is specified at the time the user is created and stored as an attribute of the user object in the identity store.</p>
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_name = input;
            self
        }
        /// <p>The identifier for a user in the identity store.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The identifier for a user in the identity store.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// Appends an item to `external_ids`.
        ///
        /// To override the contents of this collection use [`set_external_ids`](Self::set_external_ids).
        ///
        /// <p>A list of <code>ExternalId</code> objects that contains the identifiers issued to this resource by an external identity provider.</p>
        pub fn external_ids(mut self, input: crate::model::ExternalId) -> Self {
            let mut v = self.external_ids.unwrap_or_default();
            v.push(input);
            self.external_ids = Some(v);
            self
        }
        /// <p>A list of <code>ExternalId</code> objects that contains the identifiers issued to this resource by an external identity provider.</p>
        pub fn set_external_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ExternalId>>,
        ) -> Self {
            self.external_ids = input;
            self
        }
        /// <p>An object containing the user's name.</p>
        pub fn name(mut self, input: crate::model::Name) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>An object containing the user's name.</p>
        pub fn set_name(mut self, input: std::option::Option<crate::model::Name>) -> Self {
            self.name = input;
            self
        }
        /// <p>A string containing the user's name that's formatted for display when the user is referenced. For example, "John Doe."</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>A string containing the user's name that's formatted for display when the user is referenced. For example, "John Doe."</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>A string containing an alternate name for the user.</p>
        pub fn nick_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.nick_name = Some(input.into());
            self
        }
        /// <p>A string containing an alternate name for the user.</p>
        pub fn set_nick_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.nick_name = input;
            self
        }
        /// <p>A string containing a URL that may be associated with the user.</p>
        pub fn profile_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.profile_url = Some(input.into());
            self
        }
        /// <p>A string containing a URL that may be associated with the user.</p>
        pub fn set_profile_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.profile_url = input;
            self
        }
        /// Appends an item to `emails`.
        ///
        /// To override the contents of this collection use [`set_emails`](Self::set_emails).
        ///
        /// <p>A list of <code>Email</code> objects containing email addresses associated with the user.</p>
        pub fn emails(mut self, input: crate::model::Email) -> Self {
            let mut v = self.emails.unwrap_or_default();
            v.push(input);
            self.emails = Some(v);
            self
        }
        /// <p>A list of <code>Email</code> objects containing email addresses associated with the user.</p>
        pub fn set_emails(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Email>>,
        ) -> Self {
            self.emails = input;
            self
        }
        /// Appends an item to `addresses`.
        ///
        /// To override the contents of this collection use [`set_addresses`](Self::set_addresses).
        ///
        /// <p>A list of <code>Address</code> objects containing addresses associated with the user.</p>
        pub fn addresses(mut self, input: crate::model::Address) -> Self {
            let mut v = self.addresses.unwrap_or_default();
            v.push(input);
            self.addresses = Some(v);
            self
        }
        /// <p>A list of <code>Address</code> objects containing addresses associated with the user.</p>
        pub fn set_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Address>>,
        ) -> Self {
            self.addresses = input;
            self
        }
        /// Appends an item to `phone_numbers`.
        ///
        /// To override the contents of this collection use [`set_phone_numbers`](Self::set_phone_numbers).
        ///
        /// <p>A list of <code>PhoneNumber</code> objects containing phone numbers associated with the user.</p>
        pub fn phone_numbers(mut self, input: crate::model::PhoneNumber) -> Self {
            let mut v = self.phone_numbers.unwrap_or_default();
            v.push(input);
            self.phone_numbers = Some(v);
            self
        }
        /// <p>A list of <code>PhoneNumber</code> objects containing phone numbers associated with the user.</p>
        pub fn set_phone_numbers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PhoneNumber>>,
        ) -> Self {
            self.phone_numbers = input;
            self
        }
        /// <p>A string indicating the user's type. Possible values depend on each customer's specific needs, so they are left unspecified.</p>
        pub fn user_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_type = Some(input.into());
            self
        }
        /// <p>A string indicating the user's type. Possible values depend on each customer's specific needs, so they are left unspecified.</p>
        pub fn set_user_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_type = input;
            self
        }
        /// <p>A string containing the user's title. Possible values depend on each customer's specific needs, so they are left unspecified.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>A string containing the user's title. Possible values depend on each customer's specific needs, so they are left unspecified.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>A string containing the preferred language of the user. For example, "American English" or "en-us."</p>
        pub fn preferred_language(mut self, input: impl Into<std::string::String>) -> Self {
            self.preferred_language = Some(input.into());
            self
        }
        /// <p>A string containing the preferred language of the user. For example, "American English" or "en-us."</p>
        pub fn set_preferred_language(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.preferred_language = input;
            self
        }
        /// <p>A string containing the user's geographical region or location.</p>
        pub fn locale(mut self, input: impl Into<std::string::String>) -> Self {
            self.locale = Some(input.into());
            self
        }
        /// <p>A string containing the user's geographical region or location.</p>
        pub fn set_locale(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.locale = input;
            self
        }
        /// <p>A string containing the user's time zone.</p>
        pub fn timezone(mut self, input: impl Into<std::string::String>) -> Self {
            self.timezone = Some(input.into());
            self
        }
        /// <p>A string containing the user's time zone.</p>
        pub fn set_timezone(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.timezone = input;
            self
        }
        /// <p>The globally unique identifier for the identity store.</p>
        pub fn identity_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.identity_store_id = Some(input.into());
            self
        }
        /// <p>The globally unique identifier for the identity store.</p>
        pub fn set_identity_store_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.identity_store_id = input;
            self
        }
        /// Consumes the builder and constructs a [`User`](crate::model::User).
        pub fn build(self) -> crate::model::User {
            crate::model::User {
                user_name: self.user_name,
                user_id: self.user_id,
                external_ids: self.external_ids,
                name: self.name,
                display_name: self.display_name,
                nick_name: self.nick_name,
                profile_url: self.profile_url,
                emails: self.emails,
                addresses: self.addresses,
                phone_numbers: self.phone_numbers,
                user_type: self.user_type,
                title: self.title,
                preferred_language: self.preferred_language,
                locale: self.locale,
                timezone: self.timezone,
                identity_store_id: self.identity_store_id,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("user_name", &"*** Sensitive Data Redacted ***");
            formatter.field("user_id", &self.user_id);
            formatter.field("external_ids", &self.external_ids);
            formatter.field("name", &self.name);
            formatter.field("display_name", &"*** Sensitive Data Redacted ***");
            formatter.field("nick_name", &"*** Sensitive Data Redacted ***");
            formatter.field("profile_url", &"*** Sensitive Data Redacted ***");
            formatter.field("emails", &self.emails);
            formatter.field("addresses", &self.addresses);
            formatter.field("phone_numbers", &self.phone_numbers);
            formatter.field("user_type", &"*** Sensitive Data Redacted ***");
            formatter.field("title", &"*** Sensitive Data Redacted ***");
            formatter.field("preferred_language", &"*** Sensitive Data Redacted ***");
            formatter.field("locale", &"*** Sensitive Data Redacted ***");
            formatter.field("timezone", &"*** Sensitive Data Redacted ***");
            formatter.field("identity_store_id", &self.identity_store_id);
            formatter.finish()
        }
    }
}
impl User {
    /// Creates a new builder-style object to manufacture [`User`](crate::model::User).
    pub fn builder() -> crate::model::user::Builder {
        crate::model::user::Builder::default()
    }
}

/// <p>The phone number associated with the user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PhoneNumber {
    /// <p>A string containing a phone number. For example, "8675309" or "+1 (800) 123-4567".</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
    /// <p>A string representing the type of a phone number. For example, "Mobile."</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>A Boolean value representing whether this is the primary phone number for the associated resource.</p>
    #[doc(hidden)]
    pub primary: bool,
}
impl PhoneNumber {
    /// <p>A string containing a phone number. For example, "8675309" or "+1 (800) 123-4567".</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>A string representing the type of a phone number. For example, "Mobile."</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>A Boolean value representing whether this is the primary phone number for the associated resource.</p>
    pub fn primary(&self) -> bool {
        self.primary
    }
}
impl std::fmt::Debug for PhoneNumber {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PhoneNumber");
        formatter.field("value", &"*** Sensitive Data Redacted ***");
        formatter.field("r#type", &"*** Sensitive Data Redacted ***");
        formatter.field("primary", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`PhoneNumber`](crate::model::PhoneNumber).
pub mod phone_number {

    /// A builder for [`PhoneNumber`](crate::model::PhoneNumber).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) primary: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>A string containing a phone number. For example, "8675309" or "+1 (800) 123-4567".</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>A string containing a phone number. For example, "8675309" or "+1 (800) 123-4567".</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>A string representing the type of a phone number. For example, "Mobile."</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>A string representing the type of a phone number. For example, "Mobile."</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>A Boolean value representing whether this is the primary phone number for the associated resource.</p>
        pub fn primary(mut self, input: bool) -> Self {
            self.primary = Some(input);
            self
        }
        /// <p>A Boolean value representing whether this is the primary phone number for the associated resource.</p>
        pub fn set_primary(mut self, input: std::option::Option<bool>) -> Self {
            self.primary = input;
            self
        }
        /// Consumes the builder and constructs a [`PhoneNumber`](crate::model::PhoneNumber).
        pub fn build(self) -> crate::model::PhoneNumber {
            crate::model::PhoneNumber {
                value: self.value,
                r#type: self.r#type,
                primary: self.primary.unwrap_or_default(),
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("value", &"*** Sensitive Data Redacted ***");
            formatter.field("r#type", &"*** Sensitive Data Redacted ***");
            formatter.field("primary", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl PhoneNumber {
    /// Creates a new builder-style object to manufacture [`PhoneNumber`](crate::model::PhoneNumber).
    pub fn builder() -> crate::model::phone_number::Builder {
        crate::model::phone_number::Builder::default()
    }
}

/// <p>The address associated with the specified user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Address {
    /// <p>The street of the address.</p>
    #[doc(hidden)]
    pub street_address: std::option::Option<std::string::String>,
    /// <p>A string of the address locality.</p>
    #[doc(hidden)]
    pub locality: std::option::Option<std::string::String>,
    /// <p>The region of the address.</p>
    #[doc(hidden)]
    pub region: std::option::Option<std::string::String>,
    /// <p>The postal code of the address.</p>
    #[doc(hidden)]
    pub postal_code: std::option::Option<std::string::String>,
    /// <p>The country of the address.</p>
    #[doc(hidden)]
    pub country: std::option::Option<std::string::String>,
    /// <p>A string containing a formatted version of the address for display.</p>
    #[doc(hidden)]
    pub formatted: std::option::Option<std::string::String>,
    /// <p>A string representing the type of address. For example, "Home."</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>A Boolean value representing whether this is the primary address for the associated resource.</p>
    #[doc(hidden)]
    pub primary: bool,
}
impl Address {
    /// <p>The street of the address.</p>
    pub fn street_address(&self) -> std::option::Option<&str> {
        self.street_address.as_deref()
    }
    /// <p>A string of the address locality.</p>
    pub fn locality(&self) -> std::option::Option<&str> {
        self.locality.as_deref()
    }
    /// <p>The region of the address.</p>
    pub fn region(&self) -> std::option::Option<&str> {
        self.region.as_deref()
    }
    /// <p>The postal code of the address.</p>
    pub fn postal_code(&self) -> std::option::Option<&str> {
        self.postal_code.as_deref()
    }
    /// <p>The country of the address.</p>
    pub fn country(&self) -> std::option::Option<&str> {
        self.country.as_deref()
    }
    /// <p>A string containing a formatted version of the address for display.</p>
    pub fn formatted(&self) -> std::option::Option<&str> {
        self.formatted.as_deref()
    }
    /// <p>A string representing the type of address. For example, "Home."</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>A Boolean value representing whether this is the primary address for the associated resource.</p>
    pub fn primary(&self) -> bool {
        self.primary
    }
}
impl std::fmt::Debug for Address {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Address");
        formatter.field("street_address", &"*** Sensitive Data Redacted ***");
        formatter.field("locality", &"*** Sensitive Data Redacted ***");
        formatter.field("region", &"*** Sensitive Data Redacted ***");
        formatter.field("postal_code", &"*** Sensitive Data Redacted ***");
        formatter.field("country", &"*** Sensitive Data Redacted ***");
        formatter.field("formatted", &"*** Sensitive Data Redacted ***");
        formatter.field("r#type", &"*** Sensitive Data Redacted ***");
        formatter.field("primary", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`Address`](crate::model::Address).
pub mod address {

    /// A builder for [`Address`](crate::model::Address).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) street_address: std::option::Option<std::string::String>,
        pub(crate) locality: std::option::Option<std::string::String>,
        pub(crate) region: std::option::Option<std::string::String>,
        pub(crate) postal_code: std::option::Option<std::string::String>,
        pub(crate) country: std::option::Option<std::string::String>,
        pub(crate) formatted: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) primary: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The street of the address.</p>
        pub fn street_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.street_address = Some(input.into());
            self
        }
        /// <p>The street of the address.</p>
        pub fn set_street_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.street_address = input;
            self
        }
        /// <p>A string of the address locality.</p>
        pub fn locality(mut self, input: impl Into<std::string::String>) -> Self {
            self.locality = Some(input.into());
            self
        }
        /// <p>A string of the address locality.</p>
        pub fn set_locality(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.locality = input;
            self
        }
        /// <p>The region of the address.</p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        /// <p>The region of the address.</p>
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// <p>The postal code of the address.</p>
        pub fn postal_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.postal_code = Some(input.into());
            self
        }
        /// <p>The postal code of the address.</p>
        pub fn set_postal_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.postal_code = input;
            self
        }
        /// <p>The country of the address.</p>
        pub fn country(mut self, input: impl Into<std::string::String>) -> Self {
            self.country = Some(input.into());
            self
        }
        /// <p>The country of the address.</p>
        pub fn set_country(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.country = input;
            self
        }
        /// <p>A string containing a formatted version of the address for display.</p>
        pub fn formatted(mut self, input: impl Into<std::string::String>) -> Self {
            self.formatted = Some(input.into());
            self
        }
        /// <p>A string containing a formatted version of the address for display.</p>
        pub fn set_formatted(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.formatted = input;
            self
        }
        /// <p>A string representing the type of address. For example, "Home."</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>A string representing the type of address. For example, "Home."</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>A Boolean value representing whether this is the primary address for the associated resource.</p>
        pub fn primary(mut self, input: bool) -> Self {
            self.primary = Some(input);
            self
        }
        /// <p>A Boolean value representing whether this is the primary address for the associated resource.</p>
        pub fn set_primary(mut self, input: std::option::Option<bool>) -> Self {
            self.primary = input;
            self
        }
        /// Consumes the builder and constructs a [`Address`](crate::model::Address).
        pub fn build(self) -> crate::model::Address {
            crate::model::Address {
                street_address: self.street_address,
                locality: self.locality,
                region: self.region,
                postal_code: self.postal_code,
                country: self.country,
                formatted: self.formatted,
                r#type: self.r#type,
                primary: self.primary.unwrap_or_default(),
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("street_address", &"*** Sensitive Data Redacted ***");
            formatter.field("locality", &"*** Sensitive Data Redacted ***");
            formatter.field("region", &"*** Sensitive Data Redacted ***");
            formatter.field("postal_code", &"*** Sensitive Data Redacted ***");
            formatter.field("country", &"*** Sensitive Data Redacted ***");
            formatter.field("formatted", &"*** Sensitive Data Redacted ***");
            formatter.field("r#type", &"*** Sensitive Data Redacted ***");
            formatter.field("primary", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl Address {
    /// Creates a new builder-style object to manufacture [`Address`](crate::model::Address).
    pub fn builder() -> crate::model::address::Builder {
        crate::model::address::Builder::default()
    }
}

/// <p>The email address associated with the user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Email {
    /// <p>A string containing an email address. For example, "johndoe@amazon.com."</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
    /// <p>A string representing the type of address. For example, "Work."</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>A Boolean value representing whether this is the primary email address for the associated resource.</p>
    #[doc(hidden)]
    pub primary: bool,
}
impl Email {
    /// <p>A string containing an email address. For example, "johndoe@amazon.com."</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>A string representing the type of address. For example, "Work."</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>A Boolean value representing whether this is the primary email address for the associated resource.</p>
    pub fn primary(&self) -> bool {
        self.primary
    }
}
impl std::fmt::Debug for Email {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Email");
        formatter.field("value", &"*** Sensitive Data Redacted ***");
        formatter.field("r#type", &"*** Sensitive Data Redacted ***");
        formatter.field("primary", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`Email`](crate::model::Email).
pub mod email {

    /// A builder for [`Email`](crate::model::Email).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) primary: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>A string containing an email address. For example, "johndoe@amazon.com."</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>A string containing an email address. For example, "johndoe@amazon.com."</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>A string representing the type of address. For example, "Work."</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>A string representing the type of address. For example, "Work."</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>A Boolean value representing whether this is the primary email address for the associated resource.</p>
        pub fn primary(mut self, input: bool) -> Self {
            self.primary = Some(input);
            self
        }
        /// <p>A Boolean value representing whether this is the primary email address for the associated resource.</p>
        pub fn set_primary(mut self, input: std::option::Option<bool>) -> Self {
            self.primary = input;
            self
        }
        /// Consumes the builder and constructs a [`Email`](crate::model::Email).
        pub fn build(self) -> crate::model::Email {
            crate::model::Email {
                value: self.value,
                r#type: self.r#type,
                primary: self.primary.unwrap_or_default(),
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("value", &"*** Sensitive Data Redacted ***");
            formatter.field("r#type", &"*** Sensitive Data Redacted ***");
            formatter.field("primary", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl Email {
    /// Creates a new builder-style object to manufacture [`Email`](crate::model::Email).
    pub fn builder() -> crate::model::email::Builder {
        crate::model::email::Builder::default()
    }
}

/// <p>The full name of the user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Name {
    /// <p>A string containing a formatted version of the name for display.</p>
    #[doc(hidden)]
    pub formatted: std::option::Option<std::string::String>,
    /// <p>The family name of the user.</p>
    #[doc(hidden)]
    pub family_name: std::option::Option<std::string::String>,
    /// <p>The given name of the user.</p>
    #[doc(hidden)]
    pub given_name: std::option::Option<std::string::String>,
    /// <p>The middle name of the user.</p>
    #[doc(hidden)]
    pub middle_name: std::option::Option<std::string::String>,
    /// <p>The honorific prefix of the user. For example, "Dr."</p>
    #[doc(hidden)]
    pub honorific_prefix: std::option::Option<std::string::String>,
    /// <p>The honorific suffix of the user. For example, "M.D."</p>
    #[doc(hidden)]
    pub honorific_suffix: std::option::Option<std::string::String>,
}
impl Name {
    /// <p>A string containing a formatted version of the name for display.</p>
    pub fn formatted(&self) -> std::option::Option<&str> {
        self.formatted.as_deref()
    }
    /// <p>The family name of the user.</p>
    pub fn family_name(&self) -> std::option::Option<&str> {
        self.family_name.as_deref()
    }
    /// <p>The given name of the user.</p>
    pub fn given_name(&self) -> std::option::Option<&str> {
        self.given_name.as_deref()
    }
    /// <p>The middle name of the user.</p>
    pub fn middle_name(&self) -> std::option::Option<&str> {
        self.middle_name.as_deref()
    }
    /// <p>The honorific prefix of the user. For example, "Dr."</p>
    pub fn honorific_prefix(&self) -> std::option::Option<&str> {
        self.honorific_prefix.as_deref()
    }
    /// <p>The honorific suffix of the user. For example, "M.D."</p>
    pub fn honorific_suffix(&self) -> std::option::Option<&str> {
        self.honorific_suffix.as_deref()
    }
}
impl std::fmt::Debug for Name {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Name");
        formatter.field("formatted", &"*** Sensitive Data Redacted ***");
        formatter.field("family_name", &"*** Sensitive Data Redacted ***");
        formatter.field("given_name", &"*** Sensitive Data Redacted ***");
        formatter.field("middle_name", &"*** Sensitive Data Redacted ***");
        formatter.field("honorific_prefix", &"*** Sensitive Data Redacted ***");
        formatter.field("honorific_suffix", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`Name`](crate::model::Name).
pub mod name {

    /// A builder for [`Name`](crate::model::Name).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) formatted: std::option::Option<std::string::String>,
        pub(crate) family_name: std::option::Option<std::string::String>,
        pub(crate) given_name: std::option::Option<std::string::String>,
        pub(crate) middle_name: std::option::Option<std::string::String>,
        pub(crate) honorific_prefix: std::option::Option<std::string::String>,
        pub(crate) honorific_suffix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A string containing a formatted version of the name for display.</p>
        pub fn formatted(mut self, input: impl Into<std::string::String>) -> Self {
            self.formatted = Some(input.into());
            self
        }
        /// <p>A string containing a formatted version of the name for display.</p>
        pub fn set_formatted(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.formatted = input;
            self
        }
        /// <p>The family name of the user.</p>
        pub fn family_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.family_name = Some(input.into());
            self
        }
        /// <p>The family name of the user.</p>
        pub fn set_family_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.family_name = input;
            self
        }
        /// <p>The given name of the user.</p>
        pub fn given_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.given_name = Some(input.into());
            self
        }
        /// <p>The given name of the user.</p>
        pub fn set_given_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.given_name = input;
            self
        }
        /// <p>The middle name of the user.</p>
        pub fn middle_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.middle_name = Some(input.into());
            self
        }
        /// <p>The middle name of the user.</p>
        pub fn set_middle_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.middle_name = input;
            self
        }
        /// <p>The honorific prefix of the user. For example, "Dr."</p>
        pub fn honorific_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.honorific_prefix = Some(input.into());
            self
        }
        /// <p>The honorific prefix of the user. For example, "Dr."</p>
        pub fn set_honorific_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.honorific_prefix = input;
            self
        }
        /// <p>The honorific suffix of the user. For example, "M.D."</p>
        pub fn honorific_suffix(mut self, input: impl Into<std::string::String>) -> Self {
            self.honorific_suffix = Some(input.into());
            self
        }
        /// <p>The honorific suffix of the user. For example, "M.D."</p>
        pub fn set_honorific_suffix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.honorific_suffix = input;
            self
        }
        /// Consumes the builder and constructs a [`Name`](crate::model::Name).
        pub fn build(self) -> crate::model::Name {
            crate::model::Name {
                formatted: self.formatted,
                family_name: self.family_name,
                given_name: self.given_name,
                middle_name: self.middle_name,
                honorific_prefix: self.honorific_prefix,
                honorific_suffix: self.honorific_suffix,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("formatted", &"*** Sensitive Data Redacted ***");
            formatter.field("family_name", &"*** Sensitive Data Redacted ***");
            formatter.field("given_name", &"*** Sensitive Data Redacted ***");
            formatter.field("middle_name", &"*** Sensitive Data Redacted ***");
            formatter.field("honorific_prefix", &"*** Sensitive Data Redacted ***");
            formatter.field("honorific_suffix", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl Name {
    /// Creates a new builder-style object to manufacture [`Name`](crate::model::Name).
    pub fn builder() -> crate::model::name::Builder {
        crate::model::name::Builder::default()
    }
}

/// <p>The identifier issued to this resource by an external identity provider.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExternalId {
    /// <p>The issuer for an external identifier.</p>
    #[doc(hidden)]
    pub issuer: std::option::Option<std::string::String>,
    /// <p>The identifier issued to this resource by an external identity provider.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl ExternalId {
    /// <p>The issuer for an external identifier.</p>
    pub fn issuer(&self) -> std::option::Option<&str> {
        self.issuer.as_deref()
    }
    /// <p>The identifier issued to this resource by an external identity provider.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
}
impl std::fmt::Debug for ExternalId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExternalId");
        formatter.field("issuer", &"*** Sensitive Data Redacted ***");
        formatter.field("id", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`ExternalId`](crate::model::ExternalId).
pub mod external_id {

    /// A builder for [`ExternalId`](crate::model::ExternalId).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) issuer: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The issuer for an external identifier.</p>
        pub fn issuer(mut self, input: impl Into<std::string::String>) -> Self {
            self.issuer = Some(input.into());
            self
        }
        /// <p>The issuer for an external identifier.</p>
        pub fn set_issuer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.issuer = input;
            self
        }
        /// <p>The identifier issued to this resource by an external identity provider.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier issued to this resource by an external identity provider.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`ExternalId`](crate::model::ExternalId).
        pub fn build(self) -> crate::model::ExternalId {
            crate::model::ExternalId {
                issuer: self.issuer,
                id: self.id,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("issuer", &"*** Sensitive Data Redacted ***");
            formatter.field("id", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl ExternalId {
    /// Creates a new builder-style object to manufacture [`ExternalId`](crate::model::ExternalId).
    pub fn builder() -> crate::model::external_id::Builder {
        crate::model::external_id::Builder::default()
    }
}

/// <p>A query filter used by <code>ListUsers</code> and <code>ListGroups</code>. This filter object provides the attribute name and attribute value to search users or groups.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Filter {
    /// <p>The attribute path that is used to specify which attribute name to search. Length limit is 255 characters. For example, <code>UserName</code> is a valid attribute path for the <code>ListUsers</code> API, and <code>DisplayName</code> is a valid attribute path for the <code>ListGroups</code> API.</p>
    #[doc(hidden)]
    pub attribute_path: std::option::Option<std::string::String>,
    /// <p>Represents the data for an attribute. Each attribute value is described as a name-value pair. </p>
    #[doc(hidden)]
    pub attribute_value: std::option::Option<std::string::String>,
}
impl Filter {
    /// <p>The attribute path that is used to specify which attribute name to search. Length limit is 255 characters. For example, <code>UserName</code> is a valid attribute path for the <code>ListUsers</code> API, and <code>DisplayName</code> is a valid attribute path for the <code>ListGroups</code> API.</p>
    pub fn attribute_path(&self) -> std::option::Option<&str> {
        self.attribute_path.as_deref()
    }
    /// <p>Represents the data for an attribute. Each attribute value is described as a name-value pair. </p>
    pub fn attribute_value(&self) -> std::option::Option<&str> {
        self.attribute_value.as_deref()
    }
}
impl std::fmt::Debug for Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Filter");
        formatter.field("attribute_path", &self.attribute_path);
        formatter.field("attribute_value", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`Filter`](crate::model::Filter).
pub mod filter {

    /// A builder for [`Filter`](crate::model::Filter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) attribute_path: std::option::Option<std::string::String>,
        pub(crate) attribute_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The attribute path that is used to specify which attribute name to search. Length limit is 255 characters. For example, <code>UserName</code> is a valid attribute path for the <code>ListUsers</code> API, and <code>DisplayName</code> is a valid attribute path for the <code>ListGroups</code> API.</p>
        pub fn attribute_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.attribute_path = Some(input.into());
            self
        }
        /// <p>The attribute path that is used to specify which attribute name to search. Length limit is 255 characters. For example, <code>UserName</code> is a valid attribute path for the <code>ListUsers</code> API, and <code>DisplayName</code> is a valid attribute path for the <code>ListGroups</code> API.</p>
        pub fn set_attribute_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attribute_path = input;
            self
        }
        /// <p>Represents the data for an attribute. Each attribute value is described as a name-value pair. </p>
        pub fn attribute_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.attribute_value = Some(input.into());
            self
        }
        /// <p>Represents the data for an attribute. Each attribute value is described as a name-value pair. </p>
        pub fn set_attribute_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attribute_value = input;
            self
        }
        /// Consumes the builder and constructs a [`Filter`](crate::model::Filter).
        pub fn build(self) -> crate::model::Filter {
            crate::model::Filter {
                attribute_path: self.attribute_path,
                attribute_value: self.attribute_value,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("attribute_path", &self.attribute_path);
            formatter.field("attribute_value", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl Filter {
    /// Creates a new builder-style object to manufacture [`Filter`](crate::model::Filter).
    pub fn builder() -> crate::model::filter::Builder {
        crate::model::filter::Builder::default()
    }
}

/// When writing a match expression against `ConflictExceptionReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let conflictexceptionreason = unimplemented!();
/// match conflictexceptionreason {
///     ConflictExceptionReason::ConcurrentModification => { /* ... */ },
///     ConflictExceptionReason::UniquenessConstraintViolation => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `conflictexceptionreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConflictExceptionReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConflictExceptionReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConflictExceptionReason::NewFeature` is defined.
/// Specifically, when `conflictexceptionreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConflictExceptionReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConflictExceptionReason {
    #[allow(missing_docs)] // documentation missing in model
    ConcurrentModification,
    #[allow(missing_docs)] // documentation missing in model
    UniquenessConstraintViolation,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConflictExceptionReason {
    fn from(s: &str) -> Self {
        match s {
            "CONCURRENT_MODIFICATION" => ConflictExceptionReason::ConcurrentModification,
            "UNIQUENESS_CONSTRAINT_VIOLATION" => {
                ConflictExceptionReason::UniquenessConstraintViolation
            }
            other => ConflictExceptionReason::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ConflictExceptionReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConflictExceptionReason::from(s))
    }
}
impl ConflictExceptionReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConflictExceptionReason::ConcurrentModification => "CONCURRENT_MODIFICATION",
            ConflictExceptionReason::UniquenessConstraintViolation => {
                "UNIQUENESS_CONSTRAINT_VIOLATION"
            }
            ConflictExceptionReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CONCURRENT_MODIFICATION", "UNIQUENESS_CONSTRAINT_VIOLATION"]
    }
}
impl AsRef<str> for ConflictExceptionReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An operation that applies to the requested group. This operation might add, replace, or remove an attribute.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AttributeOperation {
    /// <p>A string representation of the path to a given attribute or sub-attribute. Supports JMESPath.</p>
    #[doc(hidden)]
    pub attribute_path: std::option::Option<std::string::String>,
    /// <p>The value of the attribute. This is a <code>Document</code> type. This type is not supported by Java V1, Go V1, and older versions of the AWS CLI.</p>
    #[doc(hidden)]
    pub attribute_value: std::option::Option<aws_smithy_types::Document>,
}
impl AttributeOperation {
    /// <p>A string representation of the path to a given attribute or sub-attribute. Supports JMESPath.</p>
    pub fn attribute_path(&self) -> std::option::Option<&str> {
        self.attribute_path.as_deref()
    }
    /// <p>The value of the attribute. This is a <code>Document</code> type. This type is not supported by Java V1, Go V1, and older versions of the AWS CLI.</p>
    pub fn attribute_value(&self) -> std::option::Option<&aws_smithy_types::Document> {
        self.attribute_value.as_ref()
    }
}
/// See [`AttributeOperation`](crate::model::AttributeOperation).
pub mod attribute_operation {

    /// A builder for [`AttributeOperation`](crate::model::AttributeOperation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute_path: std::option::Option<std::string::String>,
        pub(crate) attribute_value: std::option::Option<aws_smithy_types::Document>,
    }
    impl Builder {
        /// <p>A string representation of the path to a given attribute or sub-attribute. Supports JMESPath.</p>
        pub fn attribute_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.attribute_path = Some(input.into());
            self
        }
        /// <p>A string representation of the path to a given attribute or sub-attribute. Supports JMESPath.</p>
        pub fn set_attribute_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attribute_path = input;
            self
        }
        /// <p>The value of the attribute. This is a <code>Document</code> type. This type is not supported by Java V1, Go V1, and older versions of the AWS CLI.</p>
        pub fn attribute_value(mut self, input: aws_smithy_types::Document) -> Self {
            self.attribute_value = Some(input);
            self
        }
        /// <p>The value of the attribute. This is a <code>Document</code> type. This type is not supported by Java V1, Go V1, and older versions of the AWS CLI.</p>
        pub fn set_attribute_value(
            mut self,
            input: std::option::Option<aws_smithy_types::Document>,
        ) -> Self {
            self.attribute_value = input;
            self
        }
        /// Consumes the builder and constructs a [`AttributeOperation`](crate::model::AttributeOperation).
        pub fn build(self) -> crate::model::AttributeOperation {
            crate::model::AttributeOperation {
                attribute_path: self.attribute_path,
                attribute_value: self.attribute_value,
            }
        }
    }
}
impl AttributeOperation {
    /// Creates a new builder-style object to manufacture [`AttributeOperation`](crate::model::AttributeOperation).
    pub fn builder() -> crate::model::attribute_operation::Builder {
        crate::model::attribute_operation::Builder::default()
    }
}

/// <p>A group object that contains a specified groupâ€™s metadata and attributes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Group {
    /// <p>The identifier for a group in the identity store.</p>
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
    /// <p>The groupâ€™s display name value. The length limit is 1,024 characters. This value can consist of letters, accented characters, symbols, numbers, punctuation, tab, new line, carriage return, space, and nonbreaking space in this attribute. This value is specified at the time the group is created and stored as an attribute of the group object in the identity store.</p>
    #[doc(hidden)]
    pub display_name: std::option::Option<std::string::String>,
    /// <p>A list of <code>ExternalId</code> objects that contains the identifiers issued to this resource by an external identity provider.</p>
    #[doc(hidden)]
    pub external_ids: std::option::Option<std::vec::Vec<crate::model::ExternalId>>,
    /// <p>A string containing a description of the specified group.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The globally unique identifier for the identity store.</p>
    #[doc(hidden)]
    pub identity_store_id: std::option::Option<std::string::String>,
}
impl Group {
    /// <p>The identifier for a group in the identity store.</p>
    pub fn group_id(&self) -> std::option::Option<&str> {
        self.group_id.as_deref()
    }
    /// <p>The groupâ€™s display name value. The length limit is 1,024 characters. This value can consist of letters, accented characters, symbols, numbers, punctuation, tab, new line, carriage return, space, and nonbreaking space in this attribute. This value is specified at the time the group is created and stored as an attribute of the group object in the identity store.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>A list of <code>ExternalId</code> objects that contains the identifiers issued to this resource by an external identity provider.</p>
    pub fn external_ids(&self) -> std::option::Option<&[crate::model::ExternalId]> {
        self.external_ids.as_deref()
    }
    /// <p>A string containing a description of the specified group.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The globally unique identifier for the identity store.</p>
    pub fn identity_store_id(&self) -> std::option::Option<&str> {
        self.identity_store_id.as_deref()
    }
}
impl std::fmt::Debug for Group {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Group");
        formatter.field("group_id", &self.group_id);
        formatter.field("display_name", &"*** Sensitive Data Redacted ***");
        formatter.field("external_ids", &self.external_ids);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("identity_store_id", &self.identity_store_id);
        formatter.finish()
    }
}
/// See [`Group`](crate::model::Group).
pub mod group {

    /// A builder for [`Group`](crate::model::Group).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) external_ids: std::option::Option<std::vec::Vec<crate::model::ExternalId>>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) identity_store_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for a group in the identity store.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// <p>The identifier for a group in the identity store.</p>
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input;
            self
        }
        /// <p>The groupâ€™s display name value. The length limit is 1,024 characters. This value can consist of letters, accented characters, symbols, numbers, punctuation, tab, new line, carriage return, space, and nonbreaking space in this attribute. This value is specified at the time the group is created and stored as an attribute of the group object in the identity store.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>The groupâ€™s display name value. The length limit is 1,024 characters. This value can consist of letters, accented characters, symbols, numbers, punctuation, tab, new line, carriage return, space, and nonbreaking space in this attribute. This value is specified at the time the group is created and stored as an attribute of the group object in the identity store.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// Appends an item to `external_ids`.
        ///
        /// To override the contents of this collection use [`set_external_ids`](Self::set_external_ids).
        ///
        /// <p>A list of <code>ExternalId</code> objects that contains the identifiers issued to this resource by an external identity provider.</p>
        pub fn external_ids(mut self, input: crate::model::ExternalId) -> Self {
            let mut v = self.external_ids.unwrap_or_default();
            v.push(input);
            self.external_ids = Some(v);
            self
        }
        /// <p>A list of <code>ExternalId</code> objects that contains the identifiers issued to this resource by an external identity provider.</p>
        pub fn set_external_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ExternalId>>,
        ) -> Self {
            self.external_ids = input;
            self
        }
        /// <p>A string containing a description of the specified group.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A string containing a description of the specified group.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The globally unique identifier for the identity store.</p>
        pub fn identity_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.identity_store_id = Some(input.into());
            self
        }
        /// <p>The globally unique identifier for the identity store.</p>
        pub fn set_identity_store_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.identity_store_id = input;
            self
        }
        /// Consumes the builder and constructs a [`Group`](crate::model::Group).
        pub fn build(self) -> crate::model::Group {
            crate::model::Group {
                group_id: self.group_id,
                display_name: self.display_name,
                external_ids: self.external_ids,
                description: self.description,
                identity_store_id: self.identity_store_id,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("group_id", &self.group_id);
            formatter.field("display_name", &"*** Sensitive Data Redacted ***");
            formatter.field("external_ids", &self.external_ids);
            formatter.field("description", &"*** Sensitive Data Redacted ***");
            formatter.field("identity_store_id", &self.identity_store_id);
            formatter.finish()
        }
    }
}
impl Group {
    /// Creates a new builder-style object to manufacture [`Group`](crate::model::Group).
    pub fn builder() -> crate::model::group::Builder {
        crate::model::group::Builder::default()
    }
}

/// <p>Contains the identifiers for a group, a group member, and a <code>GroupMembership</code> object in the identity store.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GroupMembership {
    /// <p>The globally unique identifier for the identity store.</p>
    #[doc(hidden)]
    pub identity_store_id: std::option::Option<std::string::String>,
    /// <p>The identifier for a <code>GroupMembership</code> object in an identity store.</p>
    #[doc(hidden)]
    pub membership_id: std::option::Option<std::string::String>,
    /// <p>The identifier for a group in the identity store.</p>
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
    /// <p>An object that contains the identifier of a group member. Setting the <code>UserID</code> field to the specific identifier for a user indicates that the user is a member of the group.</p>
    #[doc(hidden)]
    pub member_id: std::option::Option<crate::model::MemberId>,
}
impl GroupMembership {
    /// <p>The globally unique identifier for the identity store.</p>
    pub fn identity_store_id(&self) -> std::option::Option<&str> {
        self.identity_store_id.as_deref()
    }
    /// <p>The identifier for a <code>GroupMembership</code> object in an identity store.</p>
    pub fn membership_id(&self) -> std::option::Option<&str> {
        self.membership_id.as_deref()
    }
    /// <p>The identifier for a group in the identity store.</p>
    pub fn group_id(&self) -> std::option::Option<&str> {
        self.group_id.as_deref()
    }
    /// <p>An object that contains the identifier of a group member. Setting the <code>UserID</code> field to the specific identifier for a user indicates that the user is a member of the group.</p>
    pub fn member_id(&self) -> std::option::Option<&crate::model::MemberId> {
        self.member_id.as_ref()
    }
}
/// See [`GroupMembership`](crate::model::GroupMembership).
pub mod group_membership {

    /// A builder for [`GroupMembership`](crate::model::GroupMembership).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identity_store_id: std::option::Option<std::string::String>,
        pub(crate) membership_id: std::option::Option<std::string::String>,
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) member_id: std::option::Option<crate::model::MemberId>,
    }
    impl Builder {
        /// <p>The globally unique identifier for the identity store.</p>
        pub fn identity_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.identity_store_id = Some(input.into());
            self
        }
        /// <p>The globally unique identifier for the identity store.</p>
        pub fn set_identity_store_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.identity_store_id = input;
            self
        }
        /// <p>The identifier for a <code>GroupMembership</code> object in an identity store.</p>
        pub fn membership_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.membership_id = Some(input.into());
            self
        }
        /// <p>The identifier for a <code>GroupMembership</code> object in an identity store.</p>
        pub fn set_membership_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.membership_id = input;
            self
        }
        /// <p>The identifier for a group in the identity store.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// <p>The identifier for a group in the identity store.</p>
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input;
            self
        }
        /// <p>An object that contains the identifier of a group member. Setting the <code>UserID</code> field to the specific identifier for a user indicates that the user is a member of the group.</p>
        pub fn member_id(mut self, input: crate::model::MemberId) -> Self {
            self.member_id = Some(input);
            self
        }
        /// <p>An object that contains the identifier of a group member. Setting the <code>UserID</code> field to the specific identifier for a user indicates that the user is a member of the group.</p>
        pub fn set_member_id(mut self, input: std::option::Option<crate::model::MemberId>) -> Self {
            self.member_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GroupMembership`](crate::model::GroupMembership).
        pub fn build(self) -> crate::model::GroupMembership {
            crate::model::GroupMembership {
                identity_store_id: self.identity_store_id,
                membership_id: self.membership_id,
                group_id: self.group_id,
                member_id: self.member_id,
            }
        }
    }
}
impl GroupMembership {
    /// Creates a new builder-style object to manufacture [`GroupMembership`](crate::model::GroupMembership).
    pub fn builder() -> crate::model::group_membership::Builder {
        crate::model::group_membership::Builder::default()
    }
}

/// <p>An object containing the identifier of a group member.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum MemberId {
    /// <p>An object containing the identifiers of resources that can be members.</p>
    UserId(std::string::String),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl MemberId {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`UserId`](crate::model::MemberId::UserId), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_user_id(&self) -> std::result::Result<&std::string::String, &Self> {
        if let MemberId::UserId(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`UserId`](crate::model::MemberId::UserId).
    pub fn is_user_id(&self) -> bool {
        self.as_user_id().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Indicates whether a resource is a member of a group in the identity store.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GroupMembershipExistenceResult {
    /// <p>The identifier for a group in the identity store.</p>
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
    /// <p>An object that contains the identifier of a group member. Setting the <code>UserID</code> field to the specific identifier for a user indicates that the user is a member of the group.</p>
    #[doc(hidden)]
    pub member_id: std::option::Option<crate::model::MemberId>,
    /// <p>Indicates whether a membership relation exists or not.</p>
    #[doc(hidden)]
    pub membership_exists: bool,
}
impl GroupMembershipExistenceResult {
    /// <p>The identifier for a group in the identity store.</p>
    pub fn group_id(&self) -> std::option::Option<&str> {
        self.group_id.as_deref()
    }
    /// <p>An object that contains the identifier of a group member. Setting the <code>UserID</code> field to the specific identifier for a user indicates that the user is a member of the group.</p>
    pub fn member_id(&self) -> std::option::Option<&crate::model::MemberId> {
        self.member_id.as_ref()
    }
    /// <p>Indicates whether a membership relation exists or not.</p>
    pub fn membership_exists(&self) -> bool {
        self.membership_exists
    }
}
impl std::fmt::Debug for GroupMembershipExistenceResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GroupMembershipExistenceResult");
        formatter.field("group_id", &self.group_id);
        formatter.field("member_id", &self.member_id);
        formatter.field("membership_exists", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`GroupMembershipExistenceResult`](crate::model::GroupMembershipExistenceResult).
pub mod group_membership_existence_result {

    /// A builder for [`GroupMembershipExistenceResult`](crate::model::GroupMembershipExistenceResult).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) member_id: std::option::Option<crate::model::MemberId>,
        pub(crate) membership_exists: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The identifier for a group in the identity store.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// <p>The identifier for a group in the identity store.</p>
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input;
            self
        }
        /// <p>An object that contains the identifier of a group member. Setting the <code>UserID</code> field to the specific identifier for a user indicates that the user is a member of the group.</p>
        pub fn member_id(mut self, input: crate::model::MemberId) -> Self {
            self.member_id = Some(input);
            self
        }
        /// <p>An object that contains the identifier of a group member. Setting the <code>UserID</code> field to the specific identifier for a user indicates that the user is a member of the group.</p>
        pub fn set_member_id(mut self, input: std::option::Option<crate::model::MemberId>) -> Self {
            self.member_id = input;
            self
        }
        /// <p>Indicates whether a membership relation exists or not.</p>
        pub fn membership_exists(mut self, input: bool) -> Self {
            self.membership_exists = Some(input);
            self
        }
        /// <p>Indicates whether a membership relation exists or not.</p>
        pub fn set_membership_exists(mut self, input: std::option::Option<bool>) -> Self {
            self.membership_exists = input;
            self
        }
        /// Consumes the builder and constructs a [`GroupMembershipExistenceResult`](crate::model::GroupMembershipExistenceResult).
        pub fn build(self) -> crate::model::GroupMembershipExistenceResult {
            crate::model::GroupMembershipExistenceResult {
                group_id: self.group_id,
                member_id: self.member_id,
                membership_exists: self.membership_exists.unwrap_or_default(),
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("group_id", &self.group_id);
            formatter.field("member_id", &self.member_id);
            formatter.field("membership_exists", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl GroupMembershipExistenceResult {
    /// Creates a new builder-style object to manufacture [`GroupMembershipExistenceResult`](crate::model::GroupMembershipExistenceResult).
    pub fn builder() -> crate::model::group_membership_existence_result::Builder {
        crate::model::group_membership_existence_result::Builder::default()
    }
}

/// <p>A unique identifier for a user or group that is not the primary identifier. This value can be an identifier from an external identity provider (IdP) that is associated with the user, the group, or a unique attribute. For example, a unique <code>GroupDisplayName</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum AlternateIdentifier {
    /// <p>The identifier issued to this resource by an external identity provider.</p>
    ExternalId(crate::model::ExternalId),
    /// <p>An entity attribute that's unique to a specific entity.</p>
    UniqueAttribute(crate::model::UniqueAttribute),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl AlternateIdentifier {
    /// Tries to convert the enum instance into [`ExternalId`](crate::model::AlternateIdentifier::ExternalId), extracting the inner [`ExternalId`](crate::model::ExternalId).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_external_id(&self) -> std::result::Result<&crate::model::ExternalId, &Self> {
        if let AlternateIdentifier::ExternalId(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ExternalId`](crate::model::AlternateIdentifier::ExternalId).
    pub fn is_external_id(&self) -> bool {
        self.as_external_id().is_ok()
    }
    /// Tries to convert the enum instance into [`UniqueAttribute`](crate::model::AlternateIdentifier::UniqueAttribute), extracting the inner [`UniqueAttribute`](crate::model::UniqueAttribute).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_unique_attribute(
        &self,
    ) -> std::result::Result<&crate::model::UniqueAttribute, &Self> {
        if let AlternateIdentifier::UniqueAttribute(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`UniqueAttribute`](crate::model::AlternateIdentifier::UniqueAttribute).
    pub fn is_unique_attribute(&self) -> bool {
        self.as_unique_attribute().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>An entity attribute that's unique to a specific entity.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UniqueAttribute {
    /// <p>A string representation of the path to a given attribute or sub-attribute. Supports JMESPath.</p>
    #[doc(hidden)]
    pub attribute_path: std::option::Option<std::string::String>,
    /// <p>The value of the attribute. This is a <code>Document</code> type. This type is not supported by Java V1, Go V1, and older versions of the AWS CLI.</p>
    #[doc(hidden)]
    pub attribute_value: std::option::Option<aws_smithy_types::Document>,
}
impl UniqueAttribute {
    /// <p>A string representation of the path to a given attribute or sub-attribute. Supports JMESPath.</p>
    pub fn attribute_path(&self) -> std::option::Option<&str> {
        self.attribute_path.as_deref()
    }
    /// <p>The value of the attribute. This is a <code>Document</code> type. This type is not supported by Java V1, Go V1, and older versions of the AWS CLI.</p>
    pub fn attribute_value(&self) -> std::option::Option<&aws_smithy_types::Document> {
        self.attribute_value.as_ref()
    }
}
/// See [`UniqueAttribute`](crate::model::UniqueAttribute).
pub mod unique_attribute {

    /// A builder for [`UniqueAttribute`](crate::model::UniqueAttribute).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute_path: std::option::Option<std::string::String>,
        pub(crate) attribute_value: std::option::Option<aws_smithy_types::Document>,
    }
    impl Builder {
        /// <p>A string representation of the path to a given attribute or sub-attribute. Supports JMESPath.</p>
        pub fn attribute_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.attribute_path = Some(input.into());
            self
        }
        /// <p>A string representation of the path to a given attribute or sub-attribute. Supports JMESPath.</p>
        pub fn set_attribute_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attribute_path = input;
            self
        }
        /// <p>The value of the attribute. This is a <code>Document</code> type. This type is not supported by Java V1, Go V1, and older versions of the AWS CLI.</p>
        pub fn attribute_value(mut self, input: aws_smithy_types::Document) -> Self {
            self.attribute_value = Some(input);
            self
        }
        /// <p>The value of the attribute. This is a <code>Document</code> type. This type is not supported by Java V1, Go V1, and older versions of the AWS CLI.</p>
        pub fn set_attribute_value(
            mut self,
            input: std::option::Option<aws_smithy_types::Document>,
        ) -> Self {
            self.attribute_value = input;
            self
        }
        /// Consumes the builder and constructs a [`UniqueAttribute`](crate::model::UniqueAttribute).
        pub fn build(self) -> crate::model::UniqueAttribute {
            crate::model::UniqueAttribute {
                attribute_path: self.attribute_path,
                attribute_value: self.attribute_value,
            }
        }
    }
}
impl UniqueAttribute {
    /// Creates a new builder-style object to manufacture [`UniqueAttribute`](crate::model::UniqueAttribute).
    pub fn builder() -> crate::model::unique_attribute::Builder {
        crate::model::unique_attribute::Builder::default()
    }
}
